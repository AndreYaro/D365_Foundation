<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesPurchLineInterface</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Base class providing an interface to common functionality applicable for tables mapped to the <c>SalesPurchLine</c> table map.
/// </summary>
abstract class SalesPurchLineInterface
{
    #ISOCountryRegionCodes

    private SalesPurchLine salesPurchLine;

    private InventTable inventTable;

    private SalesPurchLineInterface origInstance;

    private boolean inclTax, isInclTaxSet;


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initializeSalesPurchLine</Name>
				<Source><![CDATA[
    private void initializeSalesPurchLine(SalesPurchLine _salesPurchLine)
    {
        salesPurchLine = _salesPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPurchLine</Name>
				<Source><![CDATA[
    final public SalesPurchLine parmSalesPurchLine()
    {
        return salesPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    abstract public CurrencyCode parmCurrencyCode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    abstract public ItemId parmItemId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQty</Name>
				<Source><![CDATA[
    abstract public UnitQty parmQty()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a quantity value to the quantity field.
    /// </summary>
    /// <param name = "_qty">
    /// A new quantity value.
    /// </param>
    abstract protected void assignQty(UnitQty _qty)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUnitId</Name>
				<Source><![CDATA[
    abstract public UnitOfMeasureSymbol parmUnitId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a unit ID to the unit field.
    /// </summary>
    /// <param name = "_unitId">
    /// A new unit Id.
    /// </param>
    abstract protected void assignUnitId(UnitOfMeasureSymbol _unitId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrice</Name>
				<Source><![CDATA[
    abstract public PriceCur parmPrice()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a price to the price field.
    /// </summary>
    /// <param name = "_price">
    /// A new price.
    /// </param>
    abstract protected void assignPrice(PriceCur _price)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceUnit</Name>
				<Source><![CDATA[
    abstract public PriceUnit parmPriceUnit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignPriceUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a price unit value to the price unit field.
    /// </summary>
    /// <param name = "_priceUnit">
    /// A new price unit value.
    /// </param>
    abstract protected void assignPriceUnit(PriceUnit _priceUnit)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineAmount</Name>
				<Source><![CDATA[
    abstract public LineAmount parmLineAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a line amount value to the line amount field.
    /// </summary>
    /// <param name = "_lineAmount">
    /// A new line amount value.
    /// </param>
    abstract protected void assignLineAmount(LineAmount _lineAmount)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineDiscAmount</Name>
				<Source><![CDATA[
    abstract public DiscAmount parmLineDiscAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLineDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a line discount amount to the line discount amount field.
    /// </summary>
    /// <param name = "_lineDiscAmount">
    /// A new line discount amount.
    /// </param>
    abstract protected void assignLineDiscAmount(DiscAmount _lineDiscAmount)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineDiscPercent</Name>
				<Source><![CDATA[
    abstract public DiscPct parmLineDiscPercent()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLineDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a line discount percentage to the line discount percentage field.
    /// </summary>
    /// <param name = "_lineDiscPercent">
    /// A new line discount percentage.
    /// </param>
    abstract protected void assignLineDiscPercent(DiscPct _lineDiscPercent)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkup</Name>
				<Source><![CDATA[
    abstract public PriceMarkup parmMarkup()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a markup value to the markup field.
    /// </summary>
    /// <param name = "_markup">
    /// A new markup value.
    /// </param>
    abstract protected void assignMarkup(PriceMarkup _markup)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscPercent</Name>
				<Source><![CDATA[
    abstract public DiscPct parmDiscPercent()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscAmount</Name>
				<Source><![CDATA[
    abstract public DiscAmount parmDiscAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemLineDiscCode</Name>
				<Source><![CDATA[
    abstract protected LineDiscCode parmItemLineDiscCode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountLineDiscCode</Name>
				<Source><![CDATA[
    abstract protected LineDiscCode parmAccountLineDiscCode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceGroupId</Name>
				<Source><![CDATA[
    abstract protected PriceGroupId parmPriceGroupId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModuleType</Name>
				<Source><![CDATA[
    abstract public ModuleInventPurchSales parmModuleType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOrderId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the mapped table has an order ID field.
    /// </summary>
    /// <returns>
    /// true if the mapped table has an order ID field; otherwise, false.
    /// </returns>
    abstract public boolean hasOrderId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the line discount fields can be edited.
    /// </summary>
    /// <returns>
    /// true if the line discount fields can be edited; otherwise, false.
    /// </returns>
    abstract protected boolean canEditDisc()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPriceDisc</Name>
				<Source><![CDATA[
    abstract protected void initFromPriceDisc(
        PriceDisc_Price             _priceDisc,
        PriceDiscPolicyCheckPolicy  _checkPolicy,
        boolean                     _initDateFields,
        RetailOrderCalculator       _retailCalculator)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryId</Name>
				<Source><![CDATA[
    public EcoResCategoryId parmCategoryId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault parmDefaultDimension()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeliveryType</Name>
				<Source><![CDATA[
    protected TradeLineDlvType parmDeliveryType()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    public InventDimId parmInventDimId()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a <c>InventDimId</c> value to the InventDimId field.
    /// </summary>
    /// <param name = "_inventDimId">
    /// A new <c>InventDimId</c> value.
    /// </param>
    protected void assignInventDimId(InventDimId _inventDimId)
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransId</Name>
				<Source><![CDATA[
    public TradeInventTransId parmInventTransId()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventQty</Name>
				<Source><![CDATA[
    public InventQty parmInventQty()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns an inventory quantity value to the inventory quantity field.
    /// </summary>
    /// <param name = "_inventQty">
    /// A new inventory quantity value.
    /// </param>
    protected void assignInventQty(InventQty _inventQty)
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCWQty</Name>
				<Source><![CDATA[
    public PdsCWInventQty parmCWQty()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineDeliveryType</Name>
				<Source><![CDATA[
    public LineDeliveryType parmLineDeliveryType()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    public LineNum parmLineNum()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROrderLine2PriceHistoryRef</Name>
				<Source><![CDATA[
    protected MCROrderLinePriceHistoryReference parmMCROrderLine2PriceHistoryRef()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrderId</Name>
				<Source><![CDATA[
    public Num parmOrderId()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRetailVariantId</Name>
				<Source><![CDATA[
    public RetailVariantId parmRetailVariantId()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStocked</Name>
				<Source><![CDATA[
    protected TradeStockedProduct parmStocked()
    {
        return this.inventTable().isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentLine</Name>
				<Source><![CDATA[
    public SourceDocumentLineRecId parmSourceDocumentLine()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxGroup</Name>
				<Source><![CDATA[
    public TaxGroup parmTaxGroup()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxItemGroup</Name>
				<Source><![CDATA[
    public TaxItemGroup parmTaxItemGroup()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomerOrderAccount</Name>
				<Source><![CDATA[
    public CustAccount parmCustomerOrderAccount()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendorOrderAccount</Name>
				<Source><![CDATA[
    public VendAccount parmVendorOrderAccount()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateRetailGroupQty</Name>
				<Source><![CDATA[
    public UnitQty calculateRetailGroupQty()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrderAccount</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    final public CustVendAC parmOrderAccount()
    {
        CustVendAC orderAccount = this.parmCustomerOrderAccount();

        if (!orderAccount)
        {
            orderAccount = this.parmVendorOrderAccount();
        }

        return orderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceDate</Name>
				<Source><![CDATA[
    protected TransDate parmPriceDate()
    {
        return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMatchingAgreementLine</Name>
				<Source><![CDATA[
    protected AgreementLineRecId parmMatchingAgreementLine()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUseRetailPricing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the order is using retail price or not (Retail customer order).
    /// </summary>
    /// <returns>
    /// true if the order is a retail customer order; otherwise, false.
    /// </returns>
    protected boolean isUseRetailPricing()
    {
        return RetailParameters::isRetailEnabledAndInUse() && RetailPricingEngine::useRetailPricing(this.parmSalesPurchLine());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUseRetailPricingForSalesPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the order is using retail price or not (Retail customer order).
    /// </summary>
    /// <returns>
    /// true if the order is a retail customer order; otherwise, false.
    /// </returns>
    internal boolean isUseRetailPricingForSalesPurchLine()
    {
        return this.isUseRetailPricing();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>origInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a <c>SalesPurchLineInterface</c> object based on the <c>SalesPurchLine</c> orig-record.
    /// </summary>
    /// <returns>
    /// The instantiated <c>SalesPurchLineInterface</c> object.
    /// </returns>
    final public SalesPurchLineInterface origInstance()
    {
        if (!origInstance)
        {
            origInstance = SalesPurchLineInterface::createInstance(this.parmSalesPurchLine().orig());
        }

        return origInstance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>SalesPurchLineInterface</c> object based on the provided <c>SalesPurchLine</c> record.
    /// </summary>
    /// <param name = "_salesPurchLine">
    /// A <c>SalesPurchLine</c> record to create a <c>SalesPurchLineInterface</c> object for.
    /// </param>
    /// <returns>
    /// The instantiated <c>SalesPurchLineInterface</c> object.
    /// </returns>
    public static SalesPurchLineInterface createInstance(SalesPurchLine _salesPurchLine)
    {
        SalesPurchLineInterfaceFactoryAttribute attr = new SalesPurchLineInterfaceFactoryAttribute(tableId2Name(_salesPurchLine.tableId));
        
        SalesPurchLineInterface instance = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(SalesPurchLineInterface), attr) as SalesPurchLineInterface;

        instance.initializeSalesPurchLine(_salesPurchLine);

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>SalesPurchTable</c> record associated with the current <c>SalesPurchLine</c> record.
    /// </summary>
    /// <returns>
    /// The associated <c>SalesPurchTable</c> record.
    /// </returns>
    public SalesPurchTable salesPurchTable()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementHeaderExt_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the record ID of the <c>AgreementHeaderExt_RU</c> that is attached to the sales or purchase order.
    /// </summary>
    /// <returns>
    /// The agreement record ID.
    /// </returns>
    public AgreementHeaderExtRecId_RU agreementHeaderExt_RU()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementPartnerCode_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the order account of the sales or purchase table.
    /// </summary>
    /// <returns>
    /// The customer or vendor account number.
    /// </returns>
    public CustVendAC agreementPartnerCode_RU()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmountInclTax_RU</Name>
				<Source><![CDATA[
    public AmountCur calcLineAmountInclTax_RU(Qty          _qty = this.parmQty(),
                                              TransDate    _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        AmountCur lineAmount = this.calcLineAmount(_qty);

        if (! this.inclTax())
        {
            lineAmount += Tax::calcTaxAmount(this.parmTaxGroup(),
                                             this.parmTaxItemGroup(),
                                             this.taxDate(_transDate),
                                             this.parmCurrencyCode(),
                                             lineAmount,
                                             this.salesPurchTable().salesPurchTableInterface().parmTaxModuleType(),
                                             _qty,
                                             this.parmUnitId(),
                                             this.parmItemId(),
                                             TaxDirection::OutgoingTax);
        }
        return lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingProfile_RU</Name>
				<Source><![CDATA[
    public PostingProfile parmPostingProfile_RU(PostingProfile _postingProfile_RU = '')
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountExclTax</Name>
				<Source><![CDATA[
    public AmountCur amountExclTax(
        AmountCur _amountCur,
        Qty       _qty,
        TransDate _transDate,
        Tax       _tax = null,
        boolean   _skipRounding = false,
        boolean   _useRoundedTaxOrigin = true)
    {
        Percent         cashDiscPercent;
        TaxBase         taxOrigin;
        TaxSales        taxSales;
        AmountCur       lineEndDisc;

        AmountCur lineAmount = this.calcLineAmount(_qty);

        // if the document doesn't have taxes then no need to continue.
        // <GTE>
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            // </GTE>
            if (_tax
                && !Tax::isTaxIntegrationEnabledForTable(_tax.sourceTableId())
                && _tax.skipTaxCalculations())
            {
                return _amountCur;
            }
            // <GTE>
        }
        // </GTE>

        SalesPurchTableInterface salesPurchTableInterface = this.salesPurchTable().salesPurchTableInterface();

        boolean taxLessCashDisc = TaxParameters::find().TaxLessCashDisc;
        TaxIntegrationTaxJurisdictionParameters taxIntegrationTaxJurisdictionParameters = TaxIntegrationFacade::getTaxJurisdictionParametersByTable(this.salesPurchTable());
        if (taxIntegrationTaxJurisdictionParameters && !taxIntegrationTaxJurisdictionParameters.empty())
        {
            taxLessCashDisc = taxIntegrationTaxJurisdictionParameters.isCashDiscDeductedBeforeTaxCalculation();
        }

        if (taxLessCashDisc)
        {
            if (TaxParameters::canApplyCashDiscOnInvoice_ES() && salesPurchTableInterface.hasCashDiscPercent())
            {
                cashDiscPercent = salesPurchTableInterface.parmCashDiscPercent();
            }
            else
            {
                cashDiscPercent = CashDisc::find(salesPurchTableInterface.parmCashDisc()).Percent;
            }
        }

        // The Origin tax has only works as the line amount excluding tax if the amount sent in is equal to the line amount.
        if (abs(_amountCur) == abs(lineAmount))
        {
            // The calculation engine calculates the correct tax origin (amount excluding tax).
            if (_tax)
            {
                // try and get the origin from the tax instance.
                taxOrigin = _tax.getOriginForSourceLine(this.parmSalesPurchLine().TableId, this.parmSalesPurchLine().RecId, true, _amountCur);
            }

            // if we didn't get an origin from the tax instance and qty is other than zero, try and get the origin from TaxUncommitted.
            if (!taxOrigin && _qty)
            {
                taxOrigin = TaxUncommitted::getOriginForSourceLine(this.parmSalesPurchLine().TableId, this.parmSalesPurchLine().RecId, true, _amountCur);
            }

            if (taxOrigin)
            {
                if ((cashDiscPercent
                    || salesPurchTableInterface.parmDiscPercent())
                    && cashDiscPercent != 100
                    && salesPurchTableInterface.parmDiscPercent() != 100)
                {
                    if (_tax
                    && this.parmSalesPurchLine().TableId == tablenum(SalesLine)
                    && SysDictClass::isEqualOrSuperclass(classIdGet(_tax),classnum(TaxSales)))
                    {
                        taxSales = _tax;
                        lineEndDisc = taxSales.getSalesFormLetter().getSalesTotals().lineEndDiscBalance(this.parmSalesPurchLine().RecId);
                    }
                    if (lineEndDisc)
                    {
                        taxOrigin = taxOrigin / (1-cashDiscPercent/100) + lineEndDisc;
                    }
                    else
                    {
                        if (salesPurchTableInterface.parmDiscPercent() && this.endDisc())
                        {
                            taxOrigin = (taxOrigin / (1-cashDiscPercent/100)) / (1-salesPurchTableInterface.parmDiscPercent() / 100);
                        }
                        else
                        {
                            taxOrigin = taxOrigin / (1-cashDiscPercent/100);
                        }
                    }

                    if (!_skipRounding)
                    {
                        taxOrigin = CurrencyExchangeHelper::amount(taxOrigin, this.parmCurrencyCode());
                    }
                }
            }
        }

        //<GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            taxOrigin = Tax::baseAmountExclTax_IN(this.parmSalesPurchLine(), _transDate, this.parmLineAmount(), _amountCur, salesPurchTableInterface.parmDiscPercent(), _tax);

            if (this.parmLineAmount() == _amountCur
                && (cashDiscPercent
                || salesPurchTableInterface.parmDiscPercent())
                && cashDiscPercent != 100
                && salesPurchTableInterface.parmDiscPercent() != 100)
            {
                if (_tax
                && this.parmSalesPurchLine().TableId == tablenum(SalesLine)
                && _tax is TaxSales)
                {
                    taxSales = _tax;
                    lineEndDisc = taxSales.getSalesFormLetter().getSalesTotals().lineEndDiscBalance(this.parmSalesPurchLine().RecId);
                }
                if (lineEndDisc)
                {
                    taxOrigin = CurrencyExchangeHelper::amount((taxOrigin / (1-cashDiscPercent/100) + lineEndDisc), this.parmCurrencyCode());
                }
                else
                {
                    taxOrigin = CurrencyExchangeHelper::amount(((taxOrigin / (1-cashDiscPercent/100)) / (1 - salesPurchTableInterface.parmDiscPercent() / 100)), this.parmCurrencyCode());
                }
            }
            else
            {
                taxOrigin = CurrencyExchangeHelper::amount(taxOrigin, this.parmCurrencyCode());
            }
        }
        //</GIN>

        // as a last resort - calculate an origin on the fly.  This origin will not be correct in all scenarios.
        if (!taxOrigin)
        {
            taxOrigin = Tax::baseAmountExclTax(this.parmTaxGroup(),
                                          this.parmTaxItemGroup(),
                                          _transDate,
                                          this.parmCurrencyCode(),
                                          _amountCur,
                                          salesPurchTableInterface.parmTaxModuleType(),
                                          _qty,
                                          this.parmUnitId(),
                                          this.parmItemId(),
                                          TaxDirection::OutgoingTax,
                                          cashDiscPercent,
                                          true);
        }

        if (taxOrigin && TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            Common  transactionTable    = this.salesPurchTable();
            Common  transactionLine     = this.parmSalesPurchLine();
            
            ITaxDocument taxDocument = TaxBusinessService::calculateTax(
                TaxableDocumentObject::construct(
                    TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(transactionTable)));
            if (taxDocument)
            {
                ITaxDocumentLine taxDocumentLine = taxDocument.findLineBySource(transactionLine.TableId, transactionLine.RecId);
                if (taxDocumentLine)
                {
                    taxOrigin = taxOrigin - taxDocumentLine.getInclTax().amountTransactionCurrency();
                }
            }
        }

        // Ensures that the decimal digits of precision is not more than 6, if orders are with "Prices include sales tax" marked.
        if (PricesIncludeSalesTaxRecalculateTaxToggle::instance().isEnabled() && taxOrigin mod power(0.1, 6) != 0)
        {
            taxOrigin = round(taxOrigin, power(0.1, 6));
        }

        return taxOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the company currency amount for a given amount.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount to convert.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date used to calculate the exchange rate; optional.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate to use, if known; optional.
    /// </param>
    /// <param name="_exchrateSecondary">
    /// The secondary exchange rate to use, if known; optional.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    /// The exchange rate triangulation to use, if known; optional.
    /// </param>
    /// <returns>
    /// The amount in company currency.
    /// </returns>
    public AmountMST amountMST(
        AmountCur               _amountCur,
        TransDate               _exchRateDate            = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate                _exchRate                = 0,
        ExchrateSecondary       _exchrateSecondary       = 0,
        ExchRatesTriangulation  _exchRatesTriangulation  = UnknownNoYes::Unknown)
    {
        return CurrencyExchangeHelper::mstAmount(_amountCur, this.parmCurrencyCode(), _exchRateDate, _exchRatesTriangulation, _exchRate, _exchrateSecondary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBaseLineAmountExclTax</Name>
				<Source><![CDATA[
    public AmountCur calcBaseLineAmountExclTax(Qty _qty, TransDate _transDate)
    {
        SalesPurchTableInterface salesPurchTableInterface = this.salesPurchTable().salesPurchTableInterface();
        Percent         cashDiscPercent;

        AmountCur lineAmount = this.calcLineAmount(_qty);

        if (salesPurchTableInterface.parmInclTax())
        {
            boolean taxLessCashDisc = TaxCashDiscountParametersHelper::isCashDiscDeductedBeforeTaxCalculation(this.salesPurchTable().TableId, this.salesPurchTable().RecId);

            if (taxLessCashDisc)
            {
                if (TaxParameters::canApplyCashDiscOnInvoice_ES() && salesPurchTableInterface.hasCashDiscPercent())
                {
                    cashDiscPercent = salesPurchTableInterface.parmCashDiscPercent();
                }
                else
                {
                    cashDiscPercent = CashDisc::find(salesPurchTableInterface.parmCashDisc()).Percent;
                }
            }

            lineAmount = Tax::baseAmountExclTax(this.parmTaxGroup(),
                                            this.parmTaxItemGroup(),
                                            _transDate,
                                            this.parmCurrencyCode(),
                                            lineAmount,
                                            salesPurchTableInterface.parmTaxModuleType(),
                                            _qty,
                                            this.parmUnitId(),
                                            this.parmItemId(),
                                            TaxDirection::OutgoingTax,
                                            cashDiscPercent,
                                            true);
        }

        return lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcGrossAmount</Name>
				<Source><![CDATA[
    public AmountCur calcGrossAmount(Qty _qty = this.parmQty())
    {
        return this.createSalesPurchLinePriceDiscCalculationInstance().calcGrossAmount(_qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcGrossAmountExclTax</Name>
				<Source><![CDATA[
    public AmountCur calcGrossAmountExclTax(
        Qty       _qty       = this.parmQty(),
        TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        Tax       _tax       = null)
    {
        boolean includesFormulaDesignerTax;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (this.parmTaxItemGroup())
            {
                includesFormulaDesignerTax = FormulaDesigner_IN::isPriceInclTaxOnLineAmount(this.parmTaxItemGroup());
            }
        }

        AmountCur lineAmount = this.calcGrossAmount(_qty);

        if (includesFormulaDesignerTax || this.inclTax())
        {
            lineAmount = this.amountExclTax(lineAmount, _qty, _transDate, _tax);
        }

        return lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmount</Name>
				<Source><![CDATA[
    public AmountCur calcLineAmount(Qty _qty = this.parmQty())
    {
        return this.calcPrice2LineAmount(_qty, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmountExclTax</Name>
				<Source><![CDATA[
    public AmountCur calcLineAmountExclTax(
        Qty       _qty       = this.parmQty(),
        TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        Tax       _tax       = null,
        boolean   _skipRounding = false,
        boolean   _useRoundedTaxOrigin = true)
    {
        boolean includesFormulaDesignerTax;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (this.parmTaxItemGroup())
            {
                includesFormulaDesignerTax = FormulaDesigner_IN::isPriceInclTaxOnLineAmount(this.parmTaxItemGroup());
            }
        }

        AmountCur lineAmount = this.calcLineAmount(_qty);

        if (includesFormulaDesignerTax || this.inclTax())
        {
            lineAmount = this.amountExclTax(lineAmount, _qty, _transDate, _tax, _skipRounding);
        }

        return lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmountForced</Name>
				<Source><![CDATA[
    public AmountCur calcLineAmountForced(Qty _qty = this.parmQty(), PriceDiscPolicyCheckPolicy  _checkPolicy = null)
    {
        AmountCur   amountCur;

        if (!_checkPolicy)
        {
            _checkPolicy = PriceDiscPolicyCheckPolicy::newFromParm(this.parmSalesPurchLine());
        }

        boolean mustUpdateLineAmount = _checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, LineAmount)));

        if (mustUpdateLineAmount)
        {
            amountCur = this.calcPrice2LineAmount(_qty, true);
        }
        else
        {
            amountCur = this.parmLineAmount();
            this.lineAmountModified();
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineDisc</Name>
				<Source><![CDATA[
    public DiscAmount calcLineDisc(Qty _qty = this.parmQty())
    {
        return this.calcGrossAmount(_qty) - this.calcLineAmount(_qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineDiscExclTax</Name>
				<Source><![CDATA[
    public DiscAmount calcLineDiscExclTax(
        Qty       _qty       = this.parmQty(),
        TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        Tax       _tax       = null)
    {
        return this.calcGrossAmountExclTax(_qty, _transDate, _tax) -
               this.calcLineAmountExclTax(_qty, _transDate, _tax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPrice2LineAmount</Name>
				<Source><![CDATA[
    public AmountCur calcPrice2LineAmount(Qty _qty, boolean _forceLineAmountCalculation)
    {
        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            if (this.kittingSkipCalcPrice2LineAmount())
            {
                return 0;
            }
        }

        return this.createSalesPurchLinePriceDiscCalculationInstance().calcPrice2LineAmount(_qty, _forceLineAmountCalculation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcQtyOrdered</Name>
				<Source><![CDATA[
    public InventQty calcQtyOrdered(Qty _qtySalesPurch  = realMin())
    {
        InventQty qtyOrdered;

        if (this.isStocked())
        {
            qtyOrdered = this.calculateQuantityOrdered(_qtySalesPurch, InventTableModule::find(this.parmItemId(), ModuleInventPurchSales::Invent).UnitId);
        }

        return qtyOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateQuantityOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity ordered.
    /// </summary>
    /// <param name = "_qtySalesPurch">The sales or purchase quantity.</param>
    /// <param name = "_inventUnitId">The inventory unit id.</param>
    /// <returns>The inventory quantity.</returns>
    public InventQty calculateQuantityOrdered(
        Qty             _qtySalesPurch  = realMin(),
        InventUnitId    _inventUnitId   = InventTableModule::find(this.parmItemId(), ModuleInventPurchSales::Invent).UnitId)
    {
        InventQty       qty;
        Qty             qtySalesPurch = _qtySalesPurch;

        if (qtySalesPurch == realMin())
        {
            qtySalesPurch = this.parmQty();
        }

        if (!qtySalesPurch)
        {
            return 0;
        }

        if (this.parmUnitId() == _inventUnitId)
        {
            qty = decRound(qtySalesPurch, UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUnitId)));
        }
        else
        {
            qty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.parmItemId(),
                                                                                        this.parmInventDimId(),
                                                                                        qtySalesPurch,
                                                                                        this.parmUnitId(),
                                                                                        _inventUnitId,
                                                                                        NoYes::Yes);
        }

        return  qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSalesPurchQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the purchase or sales quantity for the current salesline or purchline based on the passed inventory quantity.
    /// </summary>
    /// <param name="_inventQty">
    /// An inventory quantity to convert to sales quantity.
    /// </param>
    /// <returns>
    ///  Returns the purchase or sales unit quantity.
    /// </returns>
    public UnitQty calcSalesPurchQty(InventQty _inventQty = realMin())
    {
        UnitQty qty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.parmItemId(),
                                                                                            this.parmInventDimId(),
                                                                                            _inventQty,
                                                                                            this.inventTable().inventUnitId(),
                                                                                            this.parmUnitId(),
                                                                                            NoYes::Yes);

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>grossAmount</Name>
				<Source><![CDATA[
    public AmountCur grossAmount(
        boolean   _set = false,
        AmountCur _grossAmount = 0)
    {
        if (_set)
        {
            if (_grossAmount)
            {
                this.assignPrice(this.createSalesPurchLinePriceDiscCalculationInstance().calcAmount2Price(_grossAmount));
                this.assignLineAmount(this.calcLineAmount());
            }

            return _grossAmount;
        }
        return this.calcGrossAmount(this.parmQty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountMST</Name>
				<Source><![CDATA[
    public AmountMST lineAmountMST(
        TransDate               _exchRateDate           = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate                _exchRate               = 0,
        ExchrateSecondary       _exchrateSecondary      = 0,
        ExchRatesTriangulation  _exchRatesTriangulation = UnknownNoYes::Unknown)
    {
        return this.amountMST(this.parmLineAmount(),_exchRateDate, _exchRate, _exchrateSecondary, _exchRatesTriangulation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountExclTax</Name>
				<Source><![CDATA[
    public AmountCur lineAmountExclTax(
        TransDate _transDate    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        Tax       _tax          = null,
        boolean   _skipRounding = false)
    {
        return this.lineAmountExcludingTax(_transDate, _tax, _skipRounding);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountExcludingTax</Name>
				<Source><![CDATA[
    public AmountCur lineAmountExcludingTax(
        TransDate _transDate            = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        Tax       _tax                  = null,
        boolean   _skipRounding         = false,
        boolean   _useRoundedTaxOrigin  = true)
    {
        boolean     includesFormulaDesignerTax;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && this.parmSalesPurchLine().TableId == tableNum(PurchLine))
        {
            includesFormulaDesignerTax = FormulaDesigner_IN::isPriceInclTaxOnLineAmount(this.parmTaxItemGroup());
        }

        AmountCur lineAmount = this.parmLineAmount();

        if (this.inclTax() || includesFormulaDesignerTax)
        {
            lineAmount = this.amountExclTax(lineAmount, this.parmQty(), _transDate, _tax, _skipRounding, _useRoundedTaxOrigin);
        }

        return lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountMSTExclTax</Name>
				<Source><![CDATA[
    public AmountMST lineAmountMSTExclTax(
        TransDate              _exchRateDate           = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate               _exchRate               = 0,
        ExchrateSecondary      _exchrateSecondary      = 0,
        ExchRatesTriangulation _exchRatesTriangulation = UnknownNoYes::Unknown,
        Tax                    _tax                    = null)
    {
        return this.amountMST(this.lineAmountExclTax(_exchRateDate, _tax), _exchRateDate, _exchRate, _exchrateSecondary, _exchRatesTriangulation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountModified</Name>
				<Source><![CDATA[
    public void lineAmountModified()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPurchLinePriceDiscCalculationType</Name>
				<Source><![CDATA[
    protected SalesPurchLinePriceDiscCalculationType salesPurchLinePriceDiscCalculationType()
    {
        return SalesPurchLinePriceDiscCalculationType::Standard;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesPurchLinePriceDiscCalculationInstance</Name>
				<Source><![CDATA[
    protected SalesPurchLinePriceDiscCalculation createSalesPurchLinePriceDiscCalculationInstance()
    {
        return SalesPurchLinePriceDiscCalculation::construct(this.salesPurchLinePriceDiscCalculationType(), this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxPcsPrice</Name>
				<Source><![CDATA[
    public PriceCur taxPcsPrice(TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Tax _tax = null)
    {
        return this.createSalesPurchLinePriceDiscCalculationInstance().taxPcsPrice(_transDate, _tax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retriees the effective unit price for the sales or purchase order line.
    /// </summary>
    /// <returns>
    /// The effective unit price for the sales or purchase order line.
    /// </returns>
    /// <remarks>
    /// For a line that uses advanced pricing, this will be the adjusted unit price, otherwise it is the
    /// standard unit price value on the line.
    /// </remarks>
    public Price pdsPrice()
    {
        return this.parmPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceDisc_LineDiscCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates the <c>PriceDisc_LineDisc</c> class.
    /// </summary>
    /// <param name="_inventDim">
    ///    A buffer of the <c>InventDim</c> table.
    /// </param>
    /// <param name="_doCallPriceDate">
    ///    A Boolean value that specifies whether to use the price date or the system date for the discount
    ///    calculation.
    /// </param>
    /// <returns>
    ///    An instance of the <c>PriceDisc_LineDisc</c> class.
    /// </returns>
    /// <remarks>
    ///    The instantiated <c>PriceDisc_LineDisc</c> class is stored in the global cache and first thing this
    ///    method tries to retrieve it from there.After instantiation or retrieval is the
    ///    <c>PriceDisc_LineDisc</c> class parameters updated and it is checked if the discount values still
    ///    are valid.If the price discount determination values are outdated a recalculation is executed.
    /// </remarks>
    public PriceDisc_LineDisc priceDisc_LineDiscCache(
        InventDim      _inventDim       = this.inventDim(),
        boolean        _doCallPriceDate = false,
        PriceDiscPriceAgreementParameters _parameters = PriceDiscPriceAgreementParameters::createInstance(salesPurchLine))
    {
        PriceDisc_LineDisc priceDisc_LineDisc = this.createPriceDisc_LineDisc();

        this.initializePriceDisc_LineDisc(priceDisc_LineDisc, _inventDim, _doCallPriceDate, _parameters);

        priceDisc_LineDisc.findLineDiscAgreement();

        return priceDisc_LineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDisc_LineDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an instance of priceDisc_LineDisc from cache or creates a new instance.
    /// </summary>
    /// <returns>An instance of the <c>PriceDisc_LineDisc</c> class.</returns>
    protected PriceDisc_LineDisc createPriceDisc_LineDisc()
    {
        container cacheKey = this.priceDiscCacheKey();

        PriceDisc_LineDisc priceDisc_LineDisc;
       if (appl.globalCache().isSet(classStr(PriceDisc_LineDisc), cacheKey))
        {
            priceDisc_LineDisc = appl.globalCache().get(classStr(PriceDisc_LineDisc), cacheKey);
        }
        else
        {
            priceDisc_LineDisc = PriceDisc_LineDisc::construct();
            appl.globalCache().set(classStr(PriceDisc_LineDisc), cacheKey, priceDisc_LineDisc);
        }

        return priceDisc_LineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePriceDisc_LineDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the given <c>PriceDisc_LineDisc</c> instance.
    /// </summary>
    /// <param name = "_priceDisc_LineDisc">An instance of the <c>PriceDisc_LineDisc</c> class to initialize.</param>
    /// <param name = "_inventDim">An <c>InventDim</c> record.</param>
    /// <param name = "_doCallPriceDate">A <c>boolean</c> value.</param>
    /// <param name = "_parameters">An instance of the <c>PriceDiscPriceAgreementParameters</c> class.</param>
    protected void initializePriceDisc_LineDisc(
        PriceDisc_LineDisc                  _priceDisc_LineDisc,
        InventDim                           _inventDim,
        boolean                             _doCallPriceDate,
        PriceDiscPriceAgreementParameters   _parameters)
    {
        if (this.hasOrderId())
        {
            _priceDisc_LineDisc.parmOrderNum(this.parmOrderId());
        }
        _priceDisc_LineDisc.parmModuleType(this.parmModuleType());
        _priceDisc_LineDisc.parmItemId(this.parmItemId());
        _priceDisc_LineDisc.parmInventDim(_inventDim);
        _priceDisc_LineDisc.parmUnitID(this.parmUnitId());
        if (_doCallPriceDate)
        {
            _priceDisc_LineDisc.parmDiscDate(this.parmPriceDate());
        }
        else
        {
            _priceDisc_LineDisc.parmDiscDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }
        _priceDisc_LineDisc.parmQty(this.parmQty());
        _priceDisc_LineDisc.parmAccountNum(this.parmOrderAccount());
        _priceDisc_LineDisc.parmCurrencyCode(this.parmCurrencyCode());
        _priceDisc_LineDisc.parmAccountLineDiscCode(this.parmAccountLineDiscCode());
        _priceDisc_LineDisc.parmItemLineDiscCode(this.parmItemLineDiscCOde());
        _priceDisc_LineDisc.parmSalesPurchLine(this.parmSalesPurchLine());
        _priceDisc_LineDisc.parmUseRetailPricing(this.isUseRetailPricing());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _priceDisc_LineDisc.parmAgreementHeaderExt_RU(this.agreementHeaderExt_RU());
            _priceDisc_LineDisc.parmAgreementPartnerCode_RU(this.agreementPartnerCode_RU());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceDisc_PriceCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>PriceDisc_Price</c> class.
    /// </summary>
    /// <param name="_inventDim">
    ///    A buffer of the <c>InventDim</c> table.
    /// </param>
    /// <param name="_doCallPriceDate">
    ///    A Boolean value that specifies whether to use the price date or the system date for the price
    ///    calculation.
    /// </param>
    /// <returns>
    ///    An instance of the <c>PriceDisc_Price</c> class.
    /// </returns>
    public  PriceDisc_Price priceDisc_PriceCache(
        InventDim      _inventDim       = this.inventDim(),
        boolean        _doCallPriceDate = false)
    {
        PriceDisc_Price priceDisc_Price;
        container cacheKey = this.priceDiscCacheKey();

        if (appl.globalCache().isSet(classStr(PriceDisc_Price), cacheKey))
        {
            priceDisc_Price = appl.globalCache().get(classStr(PriceDisc_Price), cacheKey);
        }
        else
        {
            priceDisc_Price =  PriceDisc_Price::construct();
            appl.globalCache().set(classStr(PriceDisc_Price), cacheKey, priceDisc_Price);
        }

        priceDisc_Price.parmSalesPurchLineInterface(this);
    
        if (this.hasOrderId())
        {
            priceDisc_Price.parmOrderNum(this.parmOrderId());
        }
        priceDisc_Price.parmModuleType(this.parmModuleType());
        priceDisc_Price.parmItemId(this.parmItemId());
        priceDisc_Price.parmInventDim(_inventDim);
        priceDisc_Price.parmUnitID(this.parmUnitId());
        if (_doCallPriceDate)
        {
            priceDisc_Price.parmPriceDate(this.parmPriceDate());
        }
        else
        {
            priceDisc_Price.parmPriceDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }
        priceDisc_Price.parmQty(this.salesPurchQty());
        priceDisc_Price.parmAccountNum(this.parmOrderAccount());
        priceDisc_Price.parmCurrencyCode(this.parmCurrencyCode());
        priceDisc_Price.parmPriceGroupId(this.parmPriceGroupId());
        priceDisc_Price.parmUseRetailPricing(this.isUseRetailPricing());

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            priceDisc_Price.parmAgreementHeaderExt_RU(this.agreementHeaderExt_RU());
            priceDisc_Price.parmAgreementPartnerCode_RU(this.agreementPartnerCode_RU());
        }
        // </GEERU>

        if (this.isUseRetailPricing())
        {
            priceDisc_Price.parmRetailGroupQty(this.calculateRetailGroupQty());
        }

        return priceDisc_Price;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceDiscCacheKey</Name>
				<Source><![CDATA[
    private container priceDiscCacheKey()
    {
        return [sessionId(), curext()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushPriceDisc_LineDiscCacheForCurrentSessionAndCompany</Name>
				<Source><![CDATA[
    public final void flushPriceDisc_LineDiscCacheForCurrentSessionAndCompany()
    {
        appl.globalCache().remove(classStr(PriceDisc_LineDisc), this.priceDiscCacheKey());
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushPriceDiscCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Flushes the cached instances of the <c>PriceDisc_LineDisc</c> and <c>PriceDisc_Price</c> classes.
    /// </summary>
    public static void flushPriceDiscCache()
    {
        appl.globalCache().clear(classStr(PriceDisc_LineDisc));
        appl.globalCache().clear(classStr(PriceDisc_Price));
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoMatchAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the matching agreement line and initializes the order line from it.
    /// </summary>
    /// <param name="_matchingAgreement">
    /// The record ID of the agreement header.
    /// </param>
    public void autoMatchAgreementLine(AgreementHeaderRecId _matchingAgreement)
    {
        if (_matchingAgreement)
        {
            AgreementLine agreementLine = AgreementLine::findLineForAutoMatch(this.parmSalesPurchLine(), _matchingAgreement);
            if (agreementLine.RecId)
            {
                this.initFromAgreementLine(agreementLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInitFromInventTable</Name>
				<Source><![CDATA[
    public boolean checkInitFromInventTable(InventTable _inventTable)
    {
        boolean ok = true;

        if (this.parmInventTransId())
        {
            MCROrderEventTable orderEventTable;
            select firstonly RecId from orderEventTable
                where orderEventTable.InventTransId == this.parmInventTransId()
                    && orderEventTable.MCROrderEventType == MCROrderEventType::AlternateItemUsed;

            if (!orderEventTable.RecId)
            {
                ok = checkFailed("@SYS10546" + '\n' +  "@SYS15394" );
            }
        }

        if (!_inventTable.checkValid(this.parmItemId()))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpPriceHistoryRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes price history references for the <c>SalesPurchLine</c> if the original
    /// reference is different than the current reference.
    /// </summary>
    /// <remarks>
    /// Required if the line has not yet been saved and the line is deleted.  Price history
    /// references are already created and need to be deleted.  In this case the original
    /// reference will be 0 which will not be equal to the non-zero current reference.
    ///
    /// Required if the line has been saved, edited to trigger a price/discount search,
    /// and then the line is deleted.  In this case the current reference also needs to be
    /// deleted and will not be equal to the original reference.
    ///
    /// Required if the line has been saved, edited to trigger a price/discount search,
    /// and then the line is reread.  In this case the current reference needs to be deleted
    /// as it will no longer apply to the line.  The original reference will be correct.
    /// </remarks>
    public void cleanUpPriceHistoryRef()
    {
        if (this.origInstance().parmMCROrderLine2PriceHistoryRef() != this.parmMCROrderLine2PriceHistoryRef())
        {
            MCROrderLine2PriceHistoryRef::deleteRef(this.parmMCROrderLine2PriceHistoryRef());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>editProductDimensionsAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the product dimensions on the line can be edited.
    /// </summary>
    /// <returns>
    /// true for order lines without delivery lines; otherwise, false.
    /// </returns>
    public boolean editProductDimensionsAllowed()
    {
        return (this.parmLineDeliveryType() == LineDeliveryType::OrderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endDisc</Name>
				<Source><![CDATA[
    public boolean endDisc()
    {
        if (this.isCategoryBased())
        {
            return true;
        }

        return InventTableModule::find(this.parmItemId(), this.parmModuleType()).EndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailLineDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get discount for the current line using the RetailOrderCalculator
    /// </summary>
    /// <returns>
    /// LineDisc for the current line.
    /// </returns>
    public DiscAmount getRetailLineDisc()
    {
        DiscAmount lineDisc;
    
        // True if the sales line has retail pricing aka came from Retail
        if (RetailPricingEngine::useRetailPricing(this.parmSalesPurchLine()))
        {
            RetailSalesPurchLineMap retailSalesPurchLineMap = RetailSalesLine::findBySalesLine(this.parmSalesPurchLine().RecId);
            RetailOrderCalculator retailCalculator = RetailOrderCalculator::construct(this.parmSalesPurchLine().TableId, this.parmOrderId(), this.parmSalesPurchLine());
            lineDisc = retailCalculator.getDiscountOnCurrentLine();
        }
    
        return lineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inclTax</Name>
				<Source><![CDATA[
    public boolean inclTax()
    {
        if (!isInclTaxSet)
        {
            SalesPurchTable salesPurchTable = this.salesPurchTable();

            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                SalesPurchJournalLine salesPurchJournalLine = SalesPurchJournalLine::findRecId(this.parmSalesPurchLine().TableId, this.parmSalesPurchLine().RecId);
                TaxModelTaxable taxModelTaxable = TaxModelDocLineFactory::newTaxModelDocLine(salesPurchJournalLine);
                if (taxModelTaxable)
                {
                    return taxModelTaxable.isPriceInclTax();
                }
            }
            inclTax = salesPurchTable.salesPurchTableInterface().parmInclTax();
            isInclTaxSet = true;
        }
        return inclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    public InventDim inventDim()
    {
        return InventDim::find(this.parmInventDimId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>InventTable</c> record that is related to the current item.
    /// </summary>
    /// <returns>A <c>InventTable</c> record; otherwise, an empty buffer.</returns>
    public InventTable inventTable()
    {
        if (!inventTable)
        {
            inventTable = InventTable::find(this.parmItemId());
        }
        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategoryBased</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the order line is category based.
    /// </summary>
    /// <returns>
    /// true if the order line is category based; otherwise, false.
    /// </returns>
    public boolean isCategoryBased()
    {
        return !this.parmItemId() && this.parmCategoryId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDropShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the order line is part of a drop shipment.
    /// </summary>
    /// <returns>
    /// true if the order line is part of a drop shipment; otherwise, false.
    /// </returns>
    public boolean isDropShipment()
    {
        return this.parmDeliveryType() == TradeLineDlvType::DropShip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the order line is tracked in inventory.
    /// </summary>
    /// <returns>
    /// true if the order line is tracked in inventory; otherwise, false.
    /// </returns>
    public boolean isStocked()
    {
        boolean isStocked;

        if (this.isCategoryBased())
        {
            isStocked = false;
        }
        else
        {
            isStocked = this.parmStocked() == NoYes::Yes;
        }

        return isStocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>legalEntityDataAreaId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the legal entity associated with the record in a table mapped to <c>SalesPurchLine</c> map.
    /// </summary>
    /// <returns>
    /// The legal entity associated with the record in a table mapped to <c>SalesPurchLine</c> map.
    /// </returns>
    public SelectableDataArea legalEntityDataAreaId()
    {
        return this.parmSalesPurchLine().DataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyWMSLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Modifies an <c>InventDim</c> record with WMS values.
    /// </summary>
    /// <param name="_inventDim">
    ///    The <c>InventDim</c> record to modify.
    /// </param>
    /// <param name="_resetWMSLocationId">
    ///    A Boolean value that specifies whether the <c>wMSLocationId</c> field will be reset, even if the
    ///    <c>LocationId</c> field is unchanged.
    /// </param>
    /// <param name="_defaultInventDirection">
    ///    Indicates whether it is per default an issue or a receipt transaction.
    /// </param>
    /// <param name="_positiveInventDirection">
    ///    Indicates whether it is an issue or a receipt transaction for a positive quantity ordered amount.
    /// </param>
    /// <remarks>
    ///    When changing the warehouse on a sales or purchase order line, the location is updated with the
    ///    default WMS values for items where the attached dimension group has the location set to active.
    /// </remarks>
    public void modifyWMSLocation(
        InventDim            _inventDim,
        boolean              _resetWMSLocationId,
        InventDirection      _defaultInventDirection,
        InventDirection      _positiveInventDirection)
    {
        InventDirection                 inventDirection;

        if (!this.parmItemId())
        {
            return;
        }

        // Don't default WMSLocation for WHS controlled items
        if (InventLocation::find(this.inventDim().InventLocationId).WHSEnabled  ||
            InventLocation::find(_inventDim.InventLocationId).WHSEnabled        ||
            InventLocation::find(this.origInstance().inventDim().InventLocationId).WHSEnabled)
        {
            return;
        }

        if (_resetWMSLocationId
            || this.inventDim().InventLocationId != this.origInstance().inventDim().InventLocationId // for new records
            || this.inventDim().InventLocationId != _inventDim.InventLocationId)                             // for existing records
        {
            if (EcoResDimensionGroupSetup::isInventoryDimensionActiveForItem(this.parmItemId(), fieldNum(InventDim,wmsLocationId)))
            {
                // validate that the already specified location actually exists
                if (!WMSLocation::exist(_inventDim.wmsLocationId, _inventDim.InventLocationId))
                {
                    _inventDim.wmsLocationId = ''; // clear the illegal location
                    _inventDim.wmsPalletId   = '';
                }

                // Set the direction according to quantity. For a positive quantity SO and Return SO lines have Issue as direction.
                // The default for 0 quantity is Issue for SO lines and Receipt for Return SO lines.
                // Receipt and Issue are swapped for PO lines.
                if (this.parmSalesPurchLine().TableId == tableNum(PurchReqLine))
                {
                    inventDirection = _defaultInventDirection;
                }
                else
                {
                    if (this.parmInventQty() > 0)
                        inventDirection = _positiveInventDirection;
                    else
                    if (this.parmInventQty() < 0)
                    {
                        inventDirection = _positiveInventDirection == InventDirection::Issue ? InventDirection::Receipt : InventDirection::Issue;
                    }
                    else
                    {
                        inventDirection = _defaultInventDirection;
                    }
                }
                WMSLocation wmsLocation = WMSLocation::defaultItemLocation(this.parmItemId(), inventDirection, InventDim::findOrCreate(_inventDim));
                if (wmsLocation)
                {
                    _inventDim.InventLocationId = wmsLocation.InventLocationId;
                    _inventDim.wmsLocationId    = wmsLocation.wmsLocationId;
                }

                // Set the InventDimId for the order line to the new one.
                this.assignInventDimId(InventDim::findOrCreate(_inventDim).InventDimId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementSkipAutoLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether this line should skip automatic <c>AgreementLine</c> matching
    /// </summary>
    /// <returns>
    /// True if no automatic matching should be done for this line
    /// </returns>
    protected boolean agreementSkipAutoLink()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>SalesPurchLine</c> table record with the values from the <c>AgreementLine</c> table record.
    /// </summary>
    /// <param name="_agreementLine">
    /// A record of the <c>AgreementLine</c> table.
    /// </param>
    public void initFromAgreementLine(AgreementLine _agreementLine)
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLinkedToAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the line is linked to an agreement line.
    /// </summary>
    /// <returns>
    /// true if the line is linked to an agreement line; otherwise, false.
    /// </returns>
    protected boolean isLinkedToAgreement()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceAgreementExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a price agreement exists for an item or account combination.
    /// </summary>
    /// <param name="_inventDim">
    /// A buffer of the <c>InventDim</c> table.
    /// </param>
    /// <returns>
    /// true if a price agreement exists; otherwise, false.
    /// </returns>
    public boolean priceAgreementExists(InventDim _inventDim)
    {
        PriceDisc_Price priceDisc_Price = this.priceDisc_PriceCache(_inventDim);

        // Ensure priceAgreementExist flag is populated
        priceDisc_Price.findPriceAgreement();

        return priceDisc_Price.priceAgreementExist() == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshAgreementLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the link between the <c>AgreementLine</c> and the <c>SalesPurchLine</c>. If the current link has
    /// become invalid, or if there is no current link, this will search for the best matching <c>AgreementLine</c>
    /// and possibly update the <c>SalesPurchLine</c> if a new match is found.
    /// </summary>
    /// <param name="_helper">
    /// An implementation of the <c>AgreementAutolinkHelper</c> interface suitable for the concrete <c>SalesPurchLine</c> type.
    /// </param>
    /// <param name="_showInfolog">
    /// A flag that indicates whether to print the errors in the Infolog; optional.
    /// </param>
    /// <returns>
    /// false if the link could not be refreshed, which means the current link is invalid and no better match could be found; otherwise, true.
    /// </returns>
    public boolean refreshAgreementLink(AgreementAutolinkHelper _helper, boolean _showInfolog = false)
    {
        boolean                             alreadyLinkedToAgreement = this.isLinkedToAgreement();
        boolean                             originalAgreementLinkIsValid = false;

        if (alreadyLinkedToAgreement)
        {
            // Re-evaluate original agreement link:
            originalAgreementLinkIsValid = _helper.isLinkValid(this.parmSalesPurchLine(), _showInfolog);
        }

        if (this.agreementSkipAutoLink())
        {
            // Skip automatic linking, just return the current agreement link state
            return !alreadyLinkedToAgreement || originalAgreementLinkIsValid;
        }

        if (originalAgreementLinkIsValid)
        {
            // The existing link is still valid, no need to search for best match
            return true;
        }

        // The line is not linked to an agreement, or the existing link is invalid
        // Try to find a best match for a line in agreement...
        AgreementLine bestMatchAgreementLine = _helper.findLineForAutoMatch(this.parmSalesPurchLine(), true);

        // If best match found, but it is the same agreement line, that has been already invalidated
        //    Notify user about disabling agreement line auto-re-linking for this order line;
        //    Update AgreementSkipAutoLink field of the order line to disable auto-relinking;
        //    Reset bestMatchAgreementLine - it is invalid anyway;
        if (   alreadyLinkedToAgreement
            && !originalAgreementLinkIsValid
            && bestMatchAgreementLine.RecId == this.parmMatchingAgreementLine())
        {
            // InfoLog Message:
            // Auto-linking to the agreement line will not be possible for this order line.
            // From now on create link to the agreement line manually.
            info("@SYS4050059");
            this.setAgreementSkipAutoLink(true);
            bestMatchAgreementLine.clear();
        }

        if (bestMatchAgreementLine)
        {
            if (_showInfolog)
            {
                if (alreadyLinkedToAgreement)
                {
                    info(strFmt("@SYS4004788", tableId2Name(this.parmSalesPurchLine().TableId)));
                }
                else
                {
                    info(strFmt("@SYS4004787", tableId2Name(this.parmSalesPurchLine().TableId)));
                }
            }

            _helper.initFromAgreementLine(this.parmSalesPurchLine(), bestMatchAgreementLine);

            return true;
        }
        else
        {
            // We end up here when no matching agreement line was found.
            // If we don't have any link already that's ok -- the state has not changed and we return true.
            // If we do have a link, this means that the link has become invalid and we return false.
            return !alreadyLinkedToAgreement;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetPriceAgreement</Name>
				<Source><![CDATA[
    public void resetPriceAgreement()
    {
        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            if (this.kittingSkipResetPriceAgreement())
            {
                return;
            }
        }

        if (this.mustResetPriceAgreement())
        {
            PriceDiscPolicyCheckPolicy checkPolicy  = PriceDiscPolicyCheckPolicy::newFromParm(this.parmSalesPurchLine());

            this.assignLineDiscAmount(checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, LineDisc))) ? 0 : this.parmLineDiscAmount());
            this.assignLineDiscPercent(checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, LinePercent))) ? 0 : this.parmLineDiscPercent());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustResetPriceAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether resetPriceAgreement must be exucuted.
    /// </summary>
    /// <returns>true if resetPriceAgreement must be executed; otherwise, false.</returns>
    protected boolean mustResetPriceAgreement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAgreementSkipAutoLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a value for the AgreementSkipAutoLink field.
    /// </summary>
    /// <param name="_agreementSkipAutoLink">
    /// Value for the AgreementSkipAutoLink field to be set on the instance of <c>SalesPurchLine</c>
    /// </param>
    /// <remarks>
    /// This value determines whether or not automatic attempt to link this line to agreement line should take place or not
    /// in case when agreement specific information is changed for this instance of <c>SalesPurchLine</c>
    /// </remarks>
    protected void setAgreementSkipAutoLink(AgreementSkipAutoLink _agreementSkipAutoLink)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAgreementQtyAndPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the price and discounts from the agreement line.
    /// </summary>
    /// <param name="_agreementLine">
    /// The <c>AgreementLine</c> record to set the price and discounts from.
    /// </param>
    /// <param name="_setQty">
    /// true if quantity is to be set based on <c>AgreementLine</c> record; otherwise false.
    /// </param>
    public void  setAgreementQtyAndPrice(AgreementLine _agreementLine, boolean _setQty = true)
    {
        boolean isUsingRetailPricing = this.isUseRetailPricing();

        // As collection classes not yet fully support ST/st records we can't rely on operator 'is' returning right value.
        // So, instead of using 'is' for condition statement:  if (_agreementLine is AgreementLineQuantityCommitment)
        // the logically equivalent condition is employed:
        if (_agreementLine.AgreementLineType == CommitmentType::ProductQuantity)
        {
            AgreementLineQuantityCommitment agreementLineQuantityCommitment = AgreementLineQuantityCommitment::find(_agreementLine.RecId);
            if (_setQty &&
                agreementLineQuantityCommitment.ProductUnitOfMeasure &&
                agreementLineQuantityCommitment.ProductUnitOfMeasure != this.parmUnitId())
            {
                this.assignQty(EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.parmItemId(),
                                                                                                     this.parmInventDimId(),                          
                                                                                                     this.parmQty(),
                                                                                                     this.parmUnitId(),
                                                                                                     agreementLineQuantityCommitment.ProductUnitOfMeasure,
                                                                                                     NoYes::No));

                this.assignUnitId(agreementLineQuantityCommitment.ProductUnitOfMeasure);
                this.assignInventQty(this.calcQtyOrdered());
                InventMovement::bufferSetRemainQty(this.parmSalesPurchLine());
            }
            this.assignPriceUnit(agreementLineQuantityCommitment.PriceUnit);
            CurrencyCode currencyCode = _agreementLine.currencyCode();

            real price = ExchangeRateHelper::curPrice2CurPrice(agreementLineQuantityCommitment.PricePerUnit, currencyCode, this.parmCurrencyCode());
            real discAmount = ExchangeRateHelper::curPrice2CurPrice(agreementLineQuantityCommitment.LineDiscountAmount, currencyCode, this.parmCurrencyCode());

            if (isUsingRetailPricing)
            {
                // Retail pricing engine mode sales agreement as a single calculated price, update here (manually link sales agreement) to keep consistent.
                // The price is the calculated value, and other fields are reset to default value (discount amount 0, discount percent 0, price unit 1).
                price = (price - discAmount) * (100 - _agreementLine.LineDiscountPercent) / (100 * agreementLineQuantityCommitment.PriceUnit);
                this.assignPrice(price);
                this.assignLineDiscAmount(0);
                this.assignPriceUnit(1);
            }
            else
            {
                this.assignPrice(price);
                this.assignLineDiscAmount(discAmount);
            }
        }

        real lineDiscPercent = isUsingRetailPricing ? 0 : _agreementLine.LineDiscountPercent;
        this.assignLineDiscPercent(lineDiscPercent);
        this.assignLineAmount(this.calcLineAmountForced());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Set price agreement for sales or purchase line.
    /// </summary>
    /// <param name="_inventDim">
    ///		An <c>InventDim</c> record that contains the dimensions the price disc should apply for.
    /// </param>
    /// <param name="_doCallPriceDate">
    ///    A Boolean value that specifies whether to use the price date or the system date for the price calculation; optional.
    /// </param>
    /// <param name="_checkPolicy">
    ///		An instance of the <c>PriceDiscPolicyCheckPolicy</c> class defining if price and discount fields should be updated; optional.
    /// </param>
    /// <param name="_initDateFields">
    ///		Indicates if the dates related to prices should be set or not; optional.
    /// </param>
    public void setPriceAgreement(
        InventDim					_inventDim,
        boolean						_doCallPriceDate	= false,
        PriceDiscPolicyCheckPolicy  _checkPolicy		= null,
        boolean						_initDateFields		= true,
        PriceDiscPriceAgreementParameters _parameters   = PriceDiscPriceAgreementParameters::createInstance(salesPurchLine))
    {
        PriceDisc_LineDisc          priceDisc_LineDisc;
        PriceDisc_Price             priceDisc_Price       = this.priceDisc_PriceCache(_inventDim, _doCallPriceDate);
        RetailOrderCalculator retailCalculator;
        boolean useRetailPricing = this.setPriceOnLineUsingRetailPricing();

        if (!this.mustSetPriceAgreement(_inventDim, _checkPolicy, _parameters))
        {
            return;
        }

        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            if (this.kittingSkipSetPriceAgreement(false))
            {
                return;
            }
        }

        if (!_checkPolicy)
        {
            _checkPolicy = PriceDiscPolicyCheckPolicy::newFromParm(this.parmSalesPurchLine());
        }

        boolean mustUpdateLineDisc    = _checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, LineDisc)));
        boolean mustUpdateLineDiscPct = _checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, LinePercent)));

        if (useRetailPricing)
        {
            retailCalculator = RetailOrderCalculator::construct(this.parmSalesPurchLine().TableId, this.parmOrderId(), this.parmSalesPurchLine());
        }

        if (!this.isCategoryBased())
        {
            this.initFromPriceDisc(priceDisc_Price, _checkPolicy, _initDateFields, retailCalculator);
        }

        if (this.canEditDisc())
        {
            if (useRetailPricing)
            {
                if (!RetailPricingEngineHelper::shouldSkipPriceDiscCalcForLine(this.parmSalesPurchLine()))
                {
                    // these are calculated by the call to retail price engine below,
                    //  which updates all order lines if necessary
                    this.assignLineDiscAmount(0);
                    this.assignLineDiscPercent(0);

                    if (!RetailPricingAvoidRepeatedPriceCalcFeatureFlight::instance().isEnabled())
                    {
                        retailCalculator.setPriceOnCurrentLine();
                    }
                    retailCalculator.setDiscountOnCurrentLine();
                }
            }
            else
            {
                boolean calculateLineDisc = true;

                if ((this.parmSalesPurchLine().TableId == TableNum(SalesLine) 
                    && SalesParameters::find().Disc == LineMultiLn::MultiLn) 
                    || (this.parmSalesPurchLine().TableId == TableNum(PurchLine) 
                    && PurchParameters::find().Disc == LineMultiLn::MultiLn))
                {
                    calculateLineDisc = false;
                }

                if (calculateLineDisc)
                {
                    priceDisc_LineDisc = this.priceDisc_LineDiscCache(_inventDim, _doCallPriceDate, _parameters);

                    if (priceDisc_LineDisc.discAgreementExist())
                    {
                        this.assignLineDiscAmount(mustUpdateLineDisc ? priceDisc_LineDisc.discAmount() : this.parmLineDiscAmount());
                        this.assignLineDiscPercent(mustUpdateLineDiscPct ? priceDisc_LineDisc.discPct() : this.parmLineDiscPercent());
                    }
                    else
                    {
                        this.assignLineDiscAmount(mustUpdateLineDisc ? 0 : this.parmLineDiscAmount());
                        this.assignLineDiscPercent(mustUpdateLineDiscPct ? 0 : this.parmLineDiscPercent());
                    }
                }
            }
        }

        this.updateMcrPriceHistory(priceDisc_Price, priceDisc_LineDisc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceOnLineUsingRetailPricing</Name>
				<Source><![CDATA[
    protected boolean setPriceOnLineUsingRetailPricing()
    {
        return this.isUseRetailPricing();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSetPriceAgreement</Name>
				<Source><![CDATA[
    public void kittingSetPriceAgreement(
        InventDim					_inventDim,
        boolean						_doCallPriceDate	= false,
        PriceDiscPolicyCheckPolicy  _checkPolicy		= null,
        boolean						_initDateFields		= true,
        PriceDiscPriceAgreementParameters _parameters   = PriceDiscPriceAgreementParameters::createInstance(salesPurchLine),
        boolean _forceSetPriceAgreementOnKitting = false)
    {
        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            if (this.kittingSkipSetPriceAgreement(_forceSetPriceAgreementOnKitting))
            {
                return;
            }
            
            this.setPriceAgreement(_inventDim, _doCallPriceDate, _checkPolicy, _initDateFields, _parameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMcrPriceHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the price history and, if necessary, any price history references for
    /// the record that was recently updated and requires a price history.
    /// </summary>
    /// <param name = "_priceDisc_Price">
    /// The object from which to retrieve already found <c>PriceDiscTable</c> prices.
    /// </param>
    /// <param name = "_priceDisc_LineDisc">
    /// The object from which to retrieve already found <c>PriceDiscTable</c> discounts.
    /// </param>
    protected void updateMcrPriceHistory(PriceDisc_Price _priceDisc_Price, PriceDisc_LineDisc _priceDisc_LineDisc)
    {
        boolean useRetailPricing = this.isUseRetailPricing();

        if (!this.isCategoryBased()
            && mcrPriceHistoryUpdate::isPriceHistoryUpdateEnabled(this.parmModuleType()))
        {
            // Check if object exists.  If it doesn't, then there is no need to update the price history.
            MCRPriceHistoryUpdate mcrPriceHistoryUpdate = MCRPriceHistoryUpdate::constructNoThrow(this.parmSalesPurchLine());
            if (mcrPriceHistoryUpdate)
            {
                if (useRetailPricing)
                {
                    mcrPriceHistoryUpdate.parmUseRetailPricing(true);
                }

                mcrPriceHistoryUpdate.update(_priceDisc_Price, _priceDisc_LineDisc);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetPriceAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the price agreement must be set.
    /// </summary>
    /// <param name = "_inventDim">An <c>InventDim</c> record.</param>
    /// <param name = "_checkPolicy">An instance of the <c>PriceDiscPolicyCheckPolicy</c> class.</param>
    /// <param name = "_parameters">An instance of the <c>PriceDiscPriceAgreementParameters</c> class.</param>
    /// <returns>true if the price agreement must be set; otherwise, false.</returns>
    protected boolean mustSetPriceAgreement(
        InventDim					_inventDim,
        PriceDiscPolicyCheckPolicy  _checkPolicy,
        PriceDiscPriceAgreementParameters _parameters)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCheckPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>PriceDiscPolicyCheckPolicy</c> class instance.
    /// </summary>
    /// <param name = "_parameters">
    /// An instance of the <c>PriceDiscPriceAgreementParameters</c> class, used to pass any parameters.
    /// </param>
    /// <returns>
    /// The <c>PriceDiscPolicyCheckPolicy</c> object.
    /// </returns>
    protected PriceDiscPolicyCheckPolicy initializeCheckPolicy(PriceDiscPriceAgreementParameters _parameters)
    {
        return PriceDiscPolicyCheckPolicy::newFromParm(this.parmSalesPurchLine());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets prices and discounts on the <c>SalesPurchLine</c>.
    /// </summary>
    /// <param name = "_inventDim">An <c>InventDim</c> record.</param>
    /// <param name = "_initDateFields">A <c>boolean</c> value.</param>
    /// <param name = "_parameters">An instance of the <c>PriceDiscPriceAgreementParameters</c> class, used to pass any additional parameters.</param>
    public void setPriceDisc(InventDim _inventDim, boolean _initDateFields, PriceDiscPriceAgreementParameters _parameters)
    {
        PriceDiscPolicyCheckPolicy  checkPolicy = this.initializeCheckPolicy(_parameters);

        if (this.mustSetPriceDisc(_inventDim, _initDateFields, _parameters))
        {
            this.setPriceAgreement(_inventDim, true, checkPolicy, _initDateFields, _parameters);
        }

        this.updateLineAmountAfterSettingPriceDisc(checkPolicy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if price and discount must be set on the <c>SalesLine</c>.
    /// </summary>
    /// <param name = "_inventDim">An <c>InventDim</c> record.</param>
    /// <param name = "_initDateFields">A <c>boolean</c> value.</param>
    /// <param name = "_parameters">An instance of the <c>PriceDiscPriceAgreementParameters</c> class.</param>
    /// <returns></returns>
    protected boolean mustSetPriceDisc(InventDim _inventDim, boolean _initDateFields, PriceDiscPriceAgreementParameters _parameters)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLineAmountAfterSettingPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates line amount after setting price and discount.
    /// </summary>
    /// <param name = "_checkPolicy">An instance of the <c>PriceDiscPolicyCheckPolicy</c> class.</param>
    protected void updateLineAmountAfterSettingPriceDisc(PriceDiscPolicyCheckPolicy _checkPolicy)
    {
        this.assignLineAmount(this.calcLineAmountForced(this.parmQty(), _checkPolicy));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the markup value, depending on trade agreements.
    /// </summary>
    /// <param name="_priceDisc">
    ///    A <c>PriceDisc</c> object.
    /// </param>
    /// <param name="_checkPolicy">
    ///    A <c>PriceDiscPolicyCheckPolicy</c> object.
    /// </param>
    public void setPriceDiscMarkup(
        PriceDisc_Price            _priceDisc,
        PriceDiscPolicyCheckPolicy _checkPolicy)
    {
        this.assignMarkup(_checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, Markup))) ? _priceDisc.priceMarkup() : this.parmMarkup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscPriceUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the price and price unit based on trade agreements.
    /// </summary>
    /// <param name="_priceDisc">
    ///    A <c>PriceDisc</c> object.
    /// </param>
    /// <param name="_checkPolicy">
    ///    A <c>PriceDiscPolicyCheckPolicy</c> object.
    /// </param>
    /// <param name="_retailCalculator">
    ///    A <c>RetailSalesOrderCalculator</c> object.
    /// </param>
    public void setPriceDiscPriceUnit(
        PriceDisc_Price            _priceDisc,
        PriceDiscPolicyCheckPolicy _checkPolicy,
        RetailOrderCalculator _retailCalculator = null)
    {
        boolean mustUpdatePrice     = _checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, Price)));
        boolean mustUpdatePriceUnit = _checkPolicy.mustUpdatePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, PriceUnit)));

        if (mustUpdatePrice || mustUpdatePriceUnit)
        {
            boolean useRetailPricing = RetailParameters::isRetailEnabledAndInUse() && RetailPricingEngine::useRetailPricing(this.parmSalesPurchLine()) &&
                _retailCalculator != null;
            if (mustUpdatePrice)
            {
                if (useRetailPricing)
                {
                    if (!RetailPricingEngineHelper::shouldSkipPriceDiscCalcForLine(this.parmSalesPurchLine()))
                    {
                        _retailCalculator.setPriceOnCurrentLine();
                    }
                }
                else
                {
                    this.assignPrice(_priceDisc.price());
                }
            }

            if (mustUpdatePriceUnit)
            {
                if (useRetailPricing)
                {
                    this.assignPriceUnit(1.0);
                }
                else
                {
                    this.assignPriceUnit(_priceDisc.priceUnit());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscPriceUnitMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the price, price unit, and markup based on the price discount change policy.
    /// </summary>
    /// <param name="_priceDisc">
    ///    A <c>PriceDisc</c> object.
    /// </param>
    /// <param name="_checkPolicy">
    ///    A <c>PriceDiscPolicyCheckPolicy</c> object.
    /// </param>
    /// <param name="_retailCalculator">
    ///    A <c>RetailSalesOrderCalculator</c> object.
    /// </param>
    public void setPriceDiscPriceUnitMarkup(
        PriceDisc_Price            _priceDisc,
        PriceDiscPolicyCheckPolicy _checkPolicy = null,
        RetailOrderCalculator _retailCalculator = null)
    {
        boolean useRetailCalculator = this.isUseRetailPricing() && _retailCalculator != null;

        if (_checkPolicy)
        {
            _priceDisc.parmUseRetailPricing(useRetailCalculator);
            this.setPriceDiscMarkup(_priceDisc, _checkPolicy);
            if (useRetailCalculator)
            {
                this.setPriceDiscPriceUnit(_priceDisc, _checkPolicy, _retailCalculator);
            }
            else
            {
                this.setPriceDiscPriceUnit(_priceDisc, _checkPolicy);
            }
        }
        else
        {
            if (useRetailCalculator)
            {
                if (!RetailPricingEngineHelper::shouldSkipPriceDiscCalcForLine(this.parmSalesPurchLine()))
                {
                    _retailCalculator.setPriceOnCurrentLine();
                }

                this.assignPriceUnit(1.0);

                this.assignMarkup(_priceDisc.priceMarkup());
            }
            else
            {
                this.assignPrice(_priceDisc.price());
                this.assignPriceUnit(_priceDisc.priceUnit());
                this.assignMarkup(_priceDisc.priceMarkup());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxDate</Name>
				<Source><![CDATA[
    public TransDate taxDate(TransDate _transDate)
    {
        return _transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExcludeTaxFromInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates an invoice to ensure that tax is not excluded for the tax code
    /// if the tax is included for the invoice.
    /// </summary>
    /// <param name="_inclTax">
    /// A <c>NoYes</c> enumeration value that indicates whether tax is included for the invoice.
    /// </param>
    /// <returns>
    /// true if the invoice is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This functionality is only valid in Lithuanian and Hungarian country context.
    /// </remarks>
    public boolean validateExcludeTaxFromInvoice(InclTax _inclTax)
    {
        if (_inclTax && TaxTable::getExcludeFromInvoice(this.parmTaxGroup(), this.parmTaxItemGroup()))
        {
            return checkFailed(strFmt("@GLS112720",
                                        new DictType(extendedTypeNum(TaxExcludeFromInvoice)).label(),
                                        new DictType(extendedTypeNum(InclTax)).label()));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscFixedPolicy</Name>
				<Source><![CDATA[
    public void setPriceDiscFixedPolicy(Common _common, AxInternalBase _axLine)
    {
        container priceDiscChangeFixedPolicyFieldIds = PriceDiscPolicyCheckPolicy::newFromParm(_common).getFixedPolicyFields();
        
		if (conLen(priceDiscChangeFixedPolicyFieldIds))
        {
            for(int i=1; i<=conLen(priceDiscChangeFixedPolicyFieldIds); i++)
            {
                _axLine.setFieldAsTouched(conPeek(priceDiscChangeFixedPolicyFieldIds, i));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPurchQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the sale quantity of a sales line
    /// </summary>
    /// <returns>
    /// The sales quantity of a sales line
    /// </returns>
    public UnitQty salesPurchQty()
    {
        UnitQty salesPurchQty;

        if(this.parmQty())
        {
            salesPurchQty = this.parmQty();
        }
        else if (salesPurchLine.TableId == tableNum(SalesLine))
        {
            SalesLine salesline = salesPurchLine;

            if(salesLine.SalesType == SalesType::ReturnItem)
            {
                salesPurchQty = salesline.ExpectedRetQty;
            }
        }

        return salesPurchQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount.
    /// </summary>
    /// <param name = "_qty">The quantity used to calculate the tax; optional.</param>
    /// <param name = "_transDate">The date used to calculate the tax; optional.</param>
    /// <returns>The calculated tax in transaction currency.</returns>
    public TaxAmountCur calcTaxAmount(Qty          _qty = this.parmQty(),
                                      TransDate    _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        AmountCur lineAmount = this.calcLineAmount(_qty);

        return Tax::calcTaxAmount(this.parmTaxGroup(),
                                  this.parmTaxItemGroup(),
                                  this.taxDate(_transDate),
                                  this.parmCurrencyCode(),
                                  lineAmount,
                                  this.salesPurchTable().salesPurchTableInterface().parmTaxModuleType(),
                                  _qty,
                                  this.parmUnitId(),
                                  this.parmItemId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainFinancialQty</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal UnitQty parmRemainFinancialQty()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainPhysicalQty</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal UnitQty parmRemainPhysicalQty()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountSalesReceiptLedgerDimension</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal LedgerDimensionDefaultAccount parmAccountSalesReceiptLedgerDimension()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountDiscLedgerDimension</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal LedgerDimensionDefaultAccount parmAccountDiscLedgerDimension()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingSalesReceipt</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal LedgerPostingType parmPostingSalesReceipt()
    {
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingDisc</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal LedgerPostingType parmPostingDisc()
    {
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDate</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    internal TransDate deliveryDate()
    {
        return Global::dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSkipCalcPrice2LineAmount_delegate</Name>
				<Source><![CDATA[
    delegate void kittingSkipCalcPrice2LineAmount_delegate(SalesPurchLine _salesPurchLine, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSkipCalcPrice2LineAmount</Name>
				<Source><![CDATA[
    boolean kittingSkipCalcPrice2LineAmount()
    {
        EventHandlerResult resultValue = new EventHandlerResult();
        this.kittingSkipCalcPrice2LineAmount_delegate(salesPurchLine, resultValue);
        return resultValue.hasResult() && resultValue.booleanResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSkipResetPriceAgreement_delegate</Name>
				<Source><![CDATA[
    delegate void kittingSkipResetPriceAgreement_delegate(SalesPurchLine _salesPurchLine, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSkipResetPriceAgreement</Name>
				<Source><![CDATA[
    boolean kittingSkipResetPriceAgreement()
    {
        EventHandlerResult resultValue = new EventHandlerResult();
        this.kittingSkipResetPriceAgreement_delegate(salesPurchLine, resultValue);
        return resultValue.hasResult() && resultValue.booleanResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSkipSetPriceAgreement_delegate</Name>
				<Source><![CDATA[
    delegate void kittingSkipSetPriceAgreement_delegate(SalesPurchLine _salesPurchLine, boolean _force, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSkipSetPriceAgreement</Name>
				<Source><![CDATA[
    boolean kittingSkipSetPriceAgreement(boolean _force)
    {
        EventHandlerResult resultValue = new EventHandlerResult();
        this.kittingSkipSetPriceAgreement_delegate(salesPurchLine, _force, resultValue);
        return resultValue.hasResult() && resultValue.booleanResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceDiscLookupCacheKey</Name>
				<Source><![CDATA[
    public str priceDiscLookupCacheKey(InventDim _inventDim)
    {
        str cacheKey = strRTrim(this.parmItemId()) + '~'
            + strRTrim(_inventDim.hashKey()) + '~'
            + strRTrim(this.parmUnitId()) + '~'
            + strRTrim(any2Str(this.salesPurchQty())) + '~'
            + strRTrim(any2Str(this.parmPrice())) + '~'
            + strRTrim(this.parmOrderAccount()) + '~'
            + strRTrim(this.parmCurrencyCode()) + '~'
            + strRTrim(this.parmPriceGroupId()) + '~'
            + strRTrim(any2Str(this.parmPriceDate())) + '~'
            + strRTrim(any2Str(this.parmLineDiscPercent())) + '~'
            + strRTrim(any2Str(this.parmLineDiscAmount()));
        
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            cacheKey += '~'
                + strRTrim(any2Str(this.agreementHeaderExt_RU())) + '~'
                + strRTrim(any2Str(this.agreementPartnerCode_RU()));
        }

        if (this.isUseRetailPricing())
        {
            cacheKey += '~' + strRTrim(any2Str(this.calculateRetailGroupQty()));
        }

        return cacheKey;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>