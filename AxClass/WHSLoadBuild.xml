<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSLoadBuild</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WHSLoadBuild</c> class build loads as part of the wave processing.
/// </summary>
public class WHSLoadBuild
{
    private WHSWaveTable            waveTable;
    private WHSWaveExecutionId      waveExecutionId;
    private WHSLoadLine             splitLoadLine;

    private List                        loadBuildTemplateBreakByList;
    private WHSLoadBuildTemplateRecId   loadBuildTemplateBreakByListRecId;

    private Map loadTableUpdaters;

    private WHSInstrumentationLogger instrumentationLogger;

    private boolean isLoadBuildLockFlightEnabled = WHSLoadBuildLockFlight::instance().isEnabled();


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addShipmentLineToLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the shipment line to a load.
    /// </summary>
    /// <param name="_loadLine">
    /// The line to add to the load.
    /// </param> 
    /// <param name="_loadId">
    /// The load where the line is being moved.
    /// </param>        
    protected final void addShipmentLineToLoad(
        WHSLoadLine _loadLine,
        WHSLoadId   _loadId)
    {
        ttsbegin;

        WHSLoadLine loadLine;
    
        select firstonly forupdate loadLine
            where loadLine.RecId == _loadLine.RecId;
    
        WHSLoadLine origLoadLine;

        origLoadLine = loadLine.data();

        loadLine.LoadId = _loadId;
    
        if (!loadLine.validateWrite())
        {
            throw error(strFmt("@WAX:ErrorLoadBuildLoadLineLoadId", loadLine.OrderNum, loadLine.ItemId, _loadId));
        }

        
        using (var insertParameters = WHSLoadLineInsertMethodParameters::newSkipLoadTableUpdate())
        {
            loadLine.update();
        }

        if (!loadTableUpdaters.exists(loadLine.LoadId))
        {
            WHSLoadTable loadTable;

            if (isLoadBuildLockFlightEnabled)
            {
                // Use pesimistic lock to avoid update conflicts
                select firstonly pessimisticlock loadTable
                    where loadTable.LoadId == loadLine.LoadId;
            }
            else
            {
                loadTable = WHSLoadTable::find(loadLine.LoadId, true);
            }

            WHSLoadTableUpdater loadTableUpdater = WHSLoadTableUpdater::newFromAddLoadLinesToLoad(loadTable);
            loadTableUpdaters.add(loadTable.LoadId, loadTableUpdater);
        }

        WHSLoadTableUpdater loadTableUpdater = loadTableUpdaters.lookup(loadLine.LoadId);
        loadTableUpdater.modifyOnLoadLineUpdate(loadLine, origLoadLine);
        

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLoadLinesToNewShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns load lines to a new shipment.
    /// </summary>
    /// <param name="_oldShipmentId">
    /// The original shipment ID.
    /// </param>
    /// <param name="_newShipmentId">
    /// The target shipment ID.
    /// </param>
    /// <param name="_loadId">
    /// The load ID for the lines to be moved.
    /// </param>
    private void assignLoadLinesToNewShipment(
        WHSShipmentId   _oldShipmentId,
        WHSShipmentId   _newShipmentId,
        WHSLoadId       _loadId)
    {
        if (_oldShipmentId && _newShipmentId && _loadId)
        {
            ttsbegin;

            WHSLoadLine loadLine;

            // The update method is overriden so just loop and update.
            while select forupdate loadLine
                where loadLine.ShipmentId   == _oldShipmentId
                &&    loadLine.LoadId       == _loadId
            {
                loadLine.ShipmentId = _newShipmentId;

                if (!loadLine.validateWrite())
                {
                    throw error(strFmt("@WAX:ErrorLoadBuildLoadLineShipId", _loadId, loadLine.ItemId, _newShipmentId));
                }

                loadLine.update();
            }
    
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearSplitLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the splitLoadLine variable back to null.
    /// </summary>
    protected final void clearSplitLoadLine()
    {
        splitLoadLine = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new load.
    /// </summary>
    /// <param name="_loadBuildTemplateName">
    /// The name of the load build template for the new load.
    /// </param>
    /// <param name="_loadTemplateId">
    /// The load template ID applied to the new load.
    /// </param>
    /// <param name="_shipmentId">
    /// The shipment ID used to create the new load.
    /// </param>
    /// <returns>
    /// Returns the load ID for the new load.
    /// </returns>
    protected final WHSLoadId createNewLoad(
        WHSLoadBuildTemplateName _loadBuildTemplateName,
        WHSLoadTemplateId        _loadTemplateId,
        WHSShipmentId            _shipmentId)
    {
        ttsbegin;

        WHSLoadTable loadTable;
    
        WHSLoadId loadId = WHSShipmentTable::find(_shipmentId).createNewLoad();
    
        select firstOnly forUpdate loadTable
            where loadTable.LoadId == loadId;
    
        if (loadTable.RecId != 0)
        {
            loadTable.LoadBuildTemplateName = _loadBuildTemplateName;
            loadTable.LoadTemplateId = _loadTemplateId;
            loadTable.LoadDirection = WHSLoadDirection::Outbound;
            loadTable.initFromLoadTemplateId(_loadTemplateId);
    
            if (!loadTable.validateWrite())
            {
                throw error(strFmt("@WAX:ErrorLoadBuildUpdateNewLoad", loadId));
            }

            loadTable.update();
        }
    
        ttscommit;
    
        return loadTable.LoadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new shipment based on an old shipment.
    /// </summary>
    /// <param name="_oldShipmentId">
    /// The original shipment.
    /// </param>
    /// <returns>
    /// The newly created shipment ID.
    /// </returns>
    private WHSShipmentId createNewShipment(WHSShipmentId   _oldShipmentId)
    {
        ttsbegin;
    
        WHSShipmentTable oldShipmentTable = WHSShipmentTable::find(_oldShipmentId);
        WHSShipmentTable newShipmentTable;
    
        buf2buf(oldShipmentTable, newShipmentTable);
    
        newShipmentTable.ShipmentId = newShipmentTable.getShipmentId();
    
        if (!newShipmentTable.validateWrite())
        {
            throw error("@WAX:ErrorLoadBuildCreateNewShipment");
        }

        newShipmentTable.insert();

        ttscommit;
    
        return newShipmentTable.ShipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewWaveLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new wave line based on a shipment ID.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment ID used to create the wave line.
    /// </param>
    private void createNewWaveLine(WHSShipmentId _shipmentId)
    {
        ttsbegin;

        WHSWaveLine waveLine;
    
        waveLine.WaveId = waveTable.WaveId;
        waveLine.initFromWHSShipmentTable(WHSShipmentTable::find(_shipmentId));

        if (!waveLine.validateWrite())
        {
            throw error(strFmt("@WAX:ErrorLoadBuildCreateNewWaveLine", waveTable.WaveId));
        }

        waveLine.insertWithoutBatchValidation();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates shipments based on a wave.
    /// </summary>
    [Hookable(true)]
    protected final void createOrUpdateShipments()
    {    
        ttsbegin;
    
        WHSShipmentTable    shipmentTable;
        WHSLoadLine         loadLine;
        WHSWaveLine         waveLine;
        WHSLoadId           tmpLoadId;
        WHSShipmentId       tmpshipmentId;
        boolean             firstShipment = true;

        SysDaQueryObject    shipmentQueryObject = new SysDaQueryObject(shipmentTable);
        SysDaQueryObject    loadLineQueryObject = new SysDaQueryObject(loadLine);
        SysDaQueryObject    waveLineQueryObject = new SysDaQueryObject(waveLine);

        shipmentQueryObject.projection().add(fieldStr(WHSShipmentTable, ShipmentId));       

        loadLineQueryObject.projection().add(fieldStr(WHSLoadLine, LoadId));
        loadLineQueryObject.projection().add(fieldStr(WHSLoadLine, ShipmentId));

        loadLineQueryObject.whereClause(new SysDaEqualsExpression
                                    (new SysDaFieldExpression(loadLine, fieldStr(WHSLoadLine, ShipmentId)),
                                     new SysDaFieldExpression(shipmentTable, fieldStr(WHSShipmentTable, ShipmentId))));     
        
        loadLineQueryObject.orderByClause(new SysDaOrderBys().add(fieldStr(WHSLoadLine, ShipmentId)));
        loadLineQueryObject.orderByClause().add(fieldStr(WHSLoadLine, LoadId));
        
        waveLineQueryObject.projection().add(fieldStr(WHSWaveLine, TableId));
        waveLineQueryObject.whereClause(new SysDaEqualsExpression
                                    (new SysDaFieldExpression(waveLine, fieldStr(WHSWaveLine, ShipmentId)),
                                     new SysDaFieldExpression(shipmentTable, fieldStr(WHSShipmentTable, ShipmentId)))
                                    .and(new SysDaEqualsExpression
                                    (new SysDaFieldExpression(waveLine, fieldStr(WHSWaveLine, WaveId)),
                                     new SysDaValueExpression(waveTable.WaveId))));  

        loadLineQueryObject.joinClause(SysDaJoinKind::InnerJoin, waveLineQueryObject);
        shipmentQueryObject.joinClause(SysDaJoinKind::InnerJoin, loadLineQueryObject);
        
        SysDaSearchObject    searchObject   = new SysDaSearchObject(shipmentQueryObject);
        SysDaSearchStatement searchStmt     = new SysDaSearchStatement();

        while (searchStmt.nextRecord(searchObject))
        {
            if (tmpLoadId && tmpLoadId != loadLine.LoadId)
            {
                tmpLoadId = '';
            }
    
            if (tmpshipmentId && tmpshipmentId != loadLine.ShipmentId)
            {
                firstShipment = true;
            }
    
            // If shipment completely assigned to load, fill loadId on waveLine
            if (firstShipment && loadLine.LoadId != '')
            {
                this.updateWaveLineLoadId(shipmentTable.ShipmentId, loadLine.LoadId);
                this.updateShipmentLoadId(shipmentTable.ShipmentId, loadLine.LoadId);
            }
    
            // If load ID's do not match, create new shipment
            if (loadLine.LoadId != tmpLoadId && !firstShipment)
            {
                WHSShipmentId newShipmentId = this.createNewShipment(shipmentTable.ShipmentId);

                this.assignLoadLinesToNewShipment(shipmentTable.ShipmentId, newShipmentId, loadLine.LoadId);
                this.updateShipmentLoadId(newShipmentId, loadLine.LoadId);
                this.createNewWaveLine(newShipmentId);
            }
    
            if (firstShipment)
            {
                firstShipment = false;
            }
    
            tmpLoadId       = loadLine.LoadId;
            tmpshipmentId   = loadLine.ShipmentId;
        }
    
        ttscommit;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateLoadBuildTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluate shipments for load build template.
    /// </summary>
    /// <param name="_loadBuildTemplate">
    /// The load build template to evaluate against.
    /// </param>
    /// <returns>
    /// Returns true if the shipment evaluates for a load build template, otherwise; false.
    /// </returns>
    protected final boolean evaluateLoadBuildTemplate(WHSLoadBuildTemplate _loadBuildTemplate)
    {
        using (var activityContext = this.instrumentationLogger().loadBuildActivities().evaluateLoadBuildTemplate())
        {
            boolean     ret;
            int         evaluatedShipmentCount;
            WHSWaveLine waveLine;
    
            // Loop over all shipments on a wave to see if any demand matches load build criteria
            while select ShipmentId from waveLine
                where waveLine.LoadId    == ''       
                &&    waveLine.WaveId    == waveTable.WaveId
            {
                evaluatedShipmentCount++;

                ret = _loadBuildTemplate.evaluateShipmentOnTemplate(waveLine.ShipmentId);
    
                if (ret)
                {
                    break;
                }
            }
    
            this.instrumentationLogger().loadBuildActivities().evaluatedLoadBuildTemplate(activityContext, ret, evaluatedShipmentCount);

            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildShipmentLineQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query with the shipment IDs that are on the wave.
    /// </summary>
    /// <param name="_loadBuildTemplate">
    /// The load build template to build the query from.
    /// </param>
    /// <returns>
    /// A query with the shipment ids as a range.
    /// </returns>
    private Query buildShipmentLineQuery(WHSLoadBuildTemplate _loadBuildTemplate)
    {
        str         shipmentList;
        WHSWaveLine waveLine;
    
        while select ShipmentId from waveLine
            where waveLine.WaveId	== waveTable.WaveId
			&&	  waveLine.LoadId	== ''
        {
            if (!shipmentList)
            {
                shipmentList = waveLine.ShipmentId;
            }
            else
            {
                shipmentList += ',' + waveLine.ShipmentId;
            }
        }
    
        var shipmentLineQuery = new Query(_loadBuildTemplate.PackedQueryRun);
        shipmentLineQuery.dataSourceTable(tableNum(WHSLoadLine)).addRange(fieldNum(WHSLoadLine, ShipmentId)).value(shipmentList);
        shipmentLineQuery.dataSourceTable(tableNum(WHSLoadLine)).addRange(fieldNum(WHSLoadLine, LoadId)).value(SysQueryRangeUtil::valueEmptyString());
    
        return shipmentLineQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSplitLoadLine</Name>
				<Source><![CDATA[
    protected final WHSLoadLine parmSplitLoadLine(WHSLoadLine _splitLoadLine = splitLoadLine)
    {
        splitLoadLine = _splitLoadLine;
    
        return splitLoadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitShipmentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits a quantity from load line to a new load line.
    /// </summary>
    /// <param name="_loadLine">
    /// The load line to split.
    /// </param>
    /// <param name="_emptyQty">
    /// The quantity to leave on the load line.
    /// </param>
    /// <param name="_maxUOM">
    /// The UOM to convert quantity.
    /// </param>
    private void splitShipmentLine(
        WHSLoadLine             _loadLine,
        Qty                     _emptyQty,
        UnitOfMeasureSymbol     _maxUOM)
    {
        ttsbegin;
    
        WHSLoadLine loadLine;

        select firstOnly forUpdate loadLine
            where loadLine.RecId == _loadLine.RecId;
    
        UnitOfMeasureSymbol inventUnit      = WHSCatchWeightHelper::inventHandlingUnitId(_loadLine.ItemId);
        InventQty           emptyInventQty  = WHSCatchWeightHelper::convertInventQuantity(_loadLine.ItemId, _maxUOM, _emptyQty, _loadLine.InventDimId);
        Qty                 newLoadLineQty  = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_loadLine.ItemId,
                                                                                                                    _loadLine.InventDimId,
                                                                                                                    _loadLine.InventQty - emptyInventQty,
                                                                                                                    inventUnit,
                                                                                                                    _maxUOM);
            
        WHSLoadLine newLoadLine;

        buf2buf(loadLine, newLoadLine);
    
        loadLine.Qty    = _emptyQty;
        loadLine.UOM    = _maxUOM;
    
        if (frac(newLoadLineQty))
        {
            newLoadLine.Qty = _loadLine.InventQty - emptyInventQty;
            newLoadLine.UOM = inventUnit;
        }
        else
        {
            newLoadLine.Qty = newLoadLineQty;
            newLoadLine.UOM = _maxUOM;
        }
    
        if (!loadLine.validateWrite())
        {
            throw error(strFmt("@WAX:ErrorLoadBuildUpdateLoadLine", loadLine.LoadId, loadLine.ItemId));
        }

        loadLine.update();

        if (!newLoadLine.validateWrite())
        {
            throw error(strFmt("@WAX:ErrorLoadBuildCreateLoadLine", loadLine.LoadId, loadLine.ItemId));
        }

        if (WhsSalesLineReleasedQtyFixAtLoadSplittingFlight::instance().isEnabled())
        {
            using (var insertParameters = WHSLoadLineInsertMethodParameters::newSkipLoadTableUpdate())
            {
                insertParameters.parmForceShipmentQtyUpdates(true);
                insertParameters.skipWHSLoadTableUpdate = (newLoadLine.LoadId == '');

                newLoadLine.insert();
            }
        }
        else
        {
            newLoadLine.insert();
        }

        this.parmSplitLoadLine(newLoadLine);
    
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateShipmentLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update shipments with new load ID.
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment ID for the shipment to update.
    /// </param>
    /// <param name="_loadId">
    /// The new load ID for the shipment.
    /// </param>
    private void updateShipmentLoadId(
        WHSShipmentId   _shipmentId,
        WHSLoadId       _loadId)
    {
        if (_shipmentId && _loadId)
        {
            ttsbegin;
    
            WHSShipmentTable shipmentTable;

            shipmentTable.skipDataMethods(true);

            update_recordSet shipmentTable
                setting LoadId = _loadId
                where shipmentTable.ShipmentId  == _shipmentId
                &&    shipmentTable.LoadId      != _loadId;
    
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveLineLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the load ID for a shipments wave lines.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment ID used to select wave lines.
    /// </param>
    /// <param name="_loadId">
    /// The new load ID.
    /// </param>
    private void updateWaveLineLoadId(
        WHSShipmentId   _shipmentId,
        WHSLoadId       _loadId)
    {
        WHSWaveLine waveLine;
    
        ttsbegin;
    
        select firstonly forUpdate waveLine
            where waveLine.WaveId       == waveTable.WaveId
            &&    waveLine.ShipmentId   == _shipmentId;
    
        waveLine.LoadId = _loadId;
    
        if (!waveLine.validateWrite())
        {
            throw error(strFmt("@WAX:ErrorLoadBuildUpdateWaveLineLoadId", waveTable.WaveId, _loadId));
        }

        waveLine.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the load.
    /// </summary>
    /// <param name="_loadBuildTemplate">
    /// The load build template to validate against.
    /// </param>
    /// <param name="_loadLine">
    /// The load line from the load.
    /// </param>
    /// <param name="_loadId">
    /// The load ID for the load to validate.
    /// </param>
    /// <returns>
    /// Returns true if the load is validate, otherwise; false.
    /// </returns>
    protected boolean validateLoad(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        WHSLoadLine             _loadLine,
        WHSLoadId               _loadId)
    {
        boolean ret = this.validateLoadLineAfterCreation(_loadBuildTemplate, _loadLine, _loadId);

        ret = ret && this.validateLoadLineBeforeCreation(_loadBuildTemplate, _loadLine, _loadId);
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadLineBeforeCreation</Name>
				<Source><![CDATA[
    private boolean validateLoadLineBeforeCreation(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        WHSLoadLine             _loadLine,
        WHSLoadId               _loadId,
        boolean                 _preCreateLoadValidation = false)
    {
        boolean     ret = true;

        // Evaluate mixing groups if specified on load build template
        if (_loadBuildTemplate.LoadMixGroupId && !this.validateLoadMixingRules(_loadBuildTemplate, _loadLine.ItemId, _loadId))
        {
            ret = false;
        }
    
        // Evaluate load weight/volume if template is configured to validate.
        if (ret && _loadBuildTemplate.ValidateVolumetrics && !this.validateLoadBuildWeightVolume(_loadLine, _loadId, _loadBuildTemplate, _preCreateLoadValidation))
        {
            ret = false;
        }
         
        // Evaluate load template quantity maximums
        if (ret && !this.validateLoadTemplateQty(_loadBuildTemplate, _loadLine, _loadId, _preCreateLoadValidation))
        {
            ret = false;
        }
              
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadLineAfterCreation</Name>
				<Source><![CDATA[
    private boolean validateLoadLineAfterCreation(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        WHSLoadLine             _loadLine,
        WHSLoadId               _loadId)
    {
        boolean     ret = true;
    
        // Evaluate Load Template/Equipment
        if (!_loadBuildTemplate.evaulateLoadTemplateOrEquipment(_loadId))
        {
            ret = false;
        }
    
        // Evaluate break by fields on load build template
        if (ret && !this.evaluateBreakBy(_loadBuildTemplate, _loadLine, _loadId))
        {
            ret = false;
        }
     
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateBreakBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates whether a shipment line matches the break by criteria from a load.
    /// </summary>
    /// <param name = "_loadBuildTemplate">The load build template specifying the break by criteria.</param>
    /// <param name = "_loadLine">The shipment Line being evaluated.</param>
    /// <param name = "_loadId">The load Id being evaluated against.</param>
    /// <returns>true if line matches break by criteria; otherwise false.</returns>
    private boolean evaluateBreakBy(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        WHSLoadLine             _loadLine,
        WHSLoadId               _loadId)
    {
        using (var activityContext = this.instrumentationLogger().loadBuildActivities().evaluateBreakBy())
        {
            boolean ret = true;
            int     breakByCount = this.loadBuildTemplateBreakByList(_loadBuildTemplate).elements();
            TableId breakByTableId;
            FieldId breakByFieldId;

            WHSLoadTable loadTable = WHSLoadTable::find(_loadId);

            if (breakByCount)
            {
                QueryRun assignQueryRun = new QueryRun(_loadBuildTemplate.PackedQueryRun);
                assignQueryRun.query().firstOnly1(true);
                assignQueryRun.query().dataSourceTable(tableNum(WHSLoadLine)).addRange(fieldNum(WHSLoadLine, RecId)).value(queryValue(_loadLine.RecId));

                if (assignQueryRun.next())
                {
                    ListEnumerator lineEnumerator = this.loadBuildTemplateBreakByList(_loadBuildTemplate).getEnumerator();

                    while (lineEnumerator.moveNext())
                    {
                        WHSLoadBuildTemplateLine loadBuildTemplateLine = lineEnumerator.current();

                        Common  breakTable = assignQueryRun.get(loadBuildTemplateLine.GroupTableId);
                        AnyType breakFieldValue = breakTable.(loadBuildTemplateLine.GroupFieldId);

                        QueryRun loadQueryRun = new QueryRun(_loadBuildTemplate.PackedQueryRun);
                        loadQueryRun.query().firstOnly1(true);
                        loadQueryRun.query().dataSourceTable(tableNum(WHSLoadLine)).addRange(fieldNum(WHSLoadLine, LoadId)).value(queryValue(_loadId));

                        QueryBuildDataSource qbdsShipment = loadQueryRun.query().dataSourceTable(loadBuildTemplateLine.GroupTableId);
                        qbdsShipment.addRange(loadBuildTemplateLine.GroupFieldId).value(SysQuery::valueNot(breakFieldValue));

                        if (loadQueryRun.next())
                        {
                            Common breakByTable = loadQueryRun.get(loadBuildTemplateLine.GroupTableId);

                            if (!breakByTable)
                            {
                                //the valueNot() range ruled out all records but next() executed as table was joined using left outer join.
                                continue;
                            }

                            breakByTableId = loadBuildTemplateLine.GroupTableId;
                            breakByFieldId = loadBuildTemplateLine.GroupFieldId;
                            ret = false;
                            break;
                        }
                    }
                }
            }

            this.instrumentationLogger().loadBuildActivities().evaluatedBreakBy(activityContext, ret, breakByCount, breakByTableId, breakByFieldId);

            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadBuildTemplateBreakByList</Name>
				<Source><![CDATA[
    private List loadBuildTemplateBreakByList(WHSLoadBuildTemplate _loadBuildTemplate)
    {
        if (_loadBuildTemplate.RecId != loadBuildTemplateBreakByListRecId || !loadBuildTemplateBreakByListRecId)
        {
            loadBuildTemplateBreakByListRecId = _loadBuildTemplate.RecId;

            loadBuildTemplateBreakByList = new List(Types::Record);

            WHSLoadBuildTemplateLine loadBuildTemplateLine;

            while select loadBuildTemplateLine
                order by LineNumber
                where loadBuildTemplateLine.LoadBuildTemplateName   == _loadBuildTemplate.LoadBuildTemplateName
                &&    loadBuildTemplateLine.BreakBy                 == NoYes::Yes
            {
                loadBuildTemplateBreakByList.addEnd(loadBuildTemplateLine);
            }
        }

        return loadBuildTemplateBreakByList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadBuildWeightVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the load build weight and volume.
    /// </summary>
    /// <param name="_loadLine">
    /// The load line that gets validated.
    /// </param>
    /// <param name="_loadId">
    /// The load ID for the load to be validated.
    /// </param>
    /// <param name="_loadTemplateId">
    /// The load template ID to validate against.
    /// </param>
    /// <returns>
    /// Returns true if the load is valid, otherwise; false.
    /// </returns>
    private boolean validateLoadBuildWeightVolume(
        WHSLoadLine             _loadLine,
        WHSLoadId               _loadId,
        WHSLoadBuildTemplate    _loadBuildTemplate,
        boolean                 _preCreateLoadValidation = false)
    {
        boolean ret = true;
      
        if (_preCreateLoadValidation)
        {
            WHSLoadTemplate loadTemplate = WHSLoadTemplate::find(_loadBuildTemplate.LoadTemplateId);

            // Evaluate Weight && Volume
            if ((_loadLine.loadLineWeight()) > loadTemplate.LoadMaxWeight    
                || (_loadLine.loadLineVolume()) > loadTemplate.LoadMaxVolume)
            {
                ret = false;
            }
        }
        else
        {
            WHSLoadTable loadTable;
            if (loadTableUpdaters.exists(_loadId))
            {
                WHSLoadTableUpdater loadTableUpdater = loadTableUpdaters.lookup(_loadId);
                loadTable = loadTableUpdater.loadTable();
            }

            if (!loadTable)
            {
                loadTable = WHSLoadTable::find(_loadId);
            }
    
            // Evaluate Weight && Volume
            if ((_loadLine.loadLineWeight() + loadTable.LoadWeight) > loadTable.LoadTipWeight    
                || (_loadLine.loadLineVolume() + loadTable.displayTotalVolume()) > loadTable.LoadTipVolume)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadMixingRules</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the load mixing rules for a load.
    /// </summary>
    /// <param name="_loadBuildTemplate">
    /// The load build template to validate against.
    /// </param>
    /// <param name="_itemId">
    /// The item ID for the load line.
    /// </param>
    /// <param name="_loadId">
    /// The load ID for the load to validate.
    /// </param>
    /// <returns>
    /// Returns true if the load is valid, otherwise; false.
    /// </returns>
    private boolean validateLoadMixingRules(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        ItemId                  _itemId,
        WHSLoadId               _loadId)
    {
        boolean ret;
    
        // Validate load mixing rules, writing to wave execution history where necessary
        switch (WHSLoadMixGroup::evaluateItemOnMixingGroup(_loadBuildTemplate.LoadMixGroupId, _itemId, _loadId))
        {
            case WHSLoadBuildAction::None:
                ret = true;
                break;
    
            case WHSLoadBuildAction::Warn:
                ret = true;
    
                // Log item mixing warning in wave exeuction history
                WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId,
                                                              waveExecutionId,
                                                              strfmt("@WAX:LoadBuildingItemWithMixingConstraintNotAllowed", _itemId, _loadId),
                                                              true);
                break;
    
            case WHSLoadBuildAction::Restrict:
                ret = false;
    
                // Log item mixing restriction in wave exeuction history
                WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId,
                                                              waveExecutionId,
                                                              strfmt("@WAX:LoadBuildingItemNotAllowedToBeLoaded", _itemId, _loadId, _loadBuildTemplate.LoadMixGroupId),
                                                              true);
                break;
    
            default:
                break;
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadTemplateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the load quantity based on its load template.
    /// </summary>
    /// <param name="_loadBuildTemplate">
    /// The load build template to validate against.
    /// </param>
    /// <param name="_loadLine">
    /// The load line to validate.
    /// </param>
    /// <param name="_loadId">
    /// The load ID used to validate.
    /// </param>
    /// <param name="_loadTemplateId">
    /// The load template ID to validate against.
    /// </param>
    /// <returns>
    /// Returns true if the load is valid, otherwise; false.
    /// </returns>
    private boolean validateLoadTemplateQty(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        WHSLoadLine             _loadLine,
        WHSLoadId               _loadId,
        boolean _preCreateLoadValidation = false)
    {
        WHSLoadTemplate     loadTemplate;
       
        boolean             ret = true;

        if (_preCreateLoadValidation)
        {
            loadTemplate = WHSLoadTemplate::find(_loadBuildTemplate.LoadTemplateId);
        }
        else
        {
            WHSLoadTable        loadTable;

            select firstOnly MaxQuantity, MaxUnit from loadTemplate
            exists join loadTable
            where loadTable.LoadTemplateId  == loadTemplate.LoadTemplateId
            &&    loadTable.LoadId          == _loadId;
        }
    
        // Only validate if max quantity exists on load template
        if (loadTemplate.MaxQuantity)
        {
            WHSLoadLine loadLine;
            Qty         loadQty;

            // Get total qty already existing on load in max UOM off load template
            if (!_preCreateLoadValidation)
            {
                while select ItemId, InventQty, InventDimId from loadLine
                    where loadLine.LoadId == _loadId
                {
                    loadQty += EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(loadLine.ItemId,
                                                                                                 loadLine.InventDimId,
                                                                                                 loadLine.InventQty,
                                                                                                 WHSCatchWeightHelper::inventHandlingUnitId(loadLine.ItemId),
                                                                                                 loadTemplate.MaxUnit);
                }
            }
           
    
            UnitOfMeasureSymbol inventUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_loadLine.ItemId);
    
            // Validate loadLine can be converted to load template max unit
            if (!EcoResProductUnitConverter::canBeConvertedGivenUnitSymbolsForReleasedProduct(_loadLine.ItemId,
                                                                                              _loadLine.InventDimId,
                                                                                              inventUnitId,
                                                                                              loadTemplate.MaxUnit))
            {
                ret = false;
            }
    
            // Validate adding load line would not exceed max quantity specified on load template
            if (ret)
            {
                Qty emptyQty = loadTemplate.MaxQuantity - loadQty; 
                Qty loadLineQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_loadLine.ItemId,
                                                                                                        _loadLine.InventDimId,
                                                                                                        _loadLine.InventQty,
                                                                                                        inventUnitId,
                                                                                                        loadTemplate.MaxUnit);
                        
                ret = loadLineQty <= emptyQty;
    
                // Split shipment line if allowed and there's space
                if (_loadBuildTemplate.AllowLoadLineSplit && emptyQty && !ret)
                {
                    this.splitShipmentLine(_loadLine, emptyQty, loadTemplate.MaxUnit);
                    ret = true;
                }
            }
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected static WHSLoadBuild construct()
    {
        return new WHSLoadBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    private void new()
    {
        loadTableUpdaters = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>WHSLoadBuild</c> class from a wave.
    /// </summary>
    /// <param name = "_waveTable">The wave table.</param>
    /// <param name = "_waveExecutionId">The wave execution ID.</param>
    /// <returns>The newly created instance.</returns>
    public static WHSLoadBuild newFromWave(
		WHSWaveTable            _waveTable,
        WHSWaveExecutionId      _waveExecutionId)
    {
        WHSLoadBuild loadBuild = WHSLoadBuild::construct();

        loadBuild.waveTable         = _waveTable;
        loadBuild.waveExecutionId   = _waveExecutionId;

        return loadBuild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds loads during wave execution.
    /// </summary>
    /// <param name = "_waveStepCode">The wave step code on the current wave template line.</param>
    internal void buildLoads(WHSWaveStepCode _waveStepCode)
    {
        using (var activityContext = this.instrumentationLogger().loadBuildActivities().buildLoads())
        {
            ttsbegin;
            int loadBuildTemplateCount = this.buildLoadFromTemplates(_waveStepCode);
            
            if (loadBuildTemplateCount == 0)
            {
                WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId,
                                                            waveExecutionId,
                                                            strFmt("@WAX:WHSLoadBuildTemplateNotExistError", _waveStepCode),
                                                            true);
            }
            // If during load building we split up shipments across loads, create new shipments
            this.createOrUpdateShipments();

            this.showWarningForFailedShipmentLine();

            this.deleteWaveLinesForShipmentWithoutLoad();

            ttscommit;

            this.instrumentationLogger().loadBuildActivities().builtLoads(activityContext, loadBuildTemplateCount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoadFromTemplates</Name>
				<Source><![CDATA[
    [Hookable(true)]
    protected final int buildLoadFromTemplates(WHSWaveStepCode _waveStepCode)
    {
        int                     loadBuildTemplateCount;            
        WHSLoadBuildTemplate    loadBuildTemplate;
        
        // Loop over load build templates and evaluate query
        while select loadBuildTemplate
            order by SequenceNumber asc
            where loadBuildTemplate.WaveStepCode == _waveStepCode
        {
            loadBuildTemplateCount++;

            if (!this.evaluateLoadBuildTemplate(loadBuildTemplate))
            {
                continue;
            }

            this.buildLoadsFromTemplate(loadBuildTemplate);
        }

        return loadBuildTemplateCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoadsFromTemplate</Name>
				<Source><![CDATA[
    private void buildLoadsFromTemplate(WHSLoadBuildTemplate _loadBuildTemplate)
    {
        using (var activityContext = this.instrumentationLogger().loadBuildActivities().buildLoadsFromTemplate(
                                                        _loadBuildTemplate.CreateLoads,
                                                        _loadBuildTemplate.UseOpenLoads,
                                                        _loadBuildTemplate.ValidateVolumetrics,
                                                        _loadBuildTemplate.AllowLoadLineSplit))
        {
            int shipmentLineCount;
            int createdLoadCount;
            int addShipmentLineCount;
            int maxOpenLoadCount;

            this.instrumentationLogger().logRecordInformation(_loadBuildTemplate);

            // Obtain sorted query for demand shipment lines
            QueryRun    shipmentLineQueryRun   = new QueryRun(this.buildShipmentLineQuery(_loadBuildTemplate));
            boolean     isLoadLineSplitted     = false;
            WHSLoadId   lastMatchingLoadId;

            while (isLoadLineSplitted || shipmentLineQueryRun.next())
            {
                shipmentLineCount++;

                WHSLoadLine loadLine;
                boolean     shipmentLineAssigned;
    
                // Store off shipment line we're trying to assign
                if (isLoadLineSplitted)
                {
                    loadLine = this.parmSplitLoadLine();
                    this.clearSplitLoadLine();
                    isLoadLineSplitted = false;
                }
                else
                {
                    loadLine = shipmentLineQueryRun.get(tableNum(WHSLoadLine));
                }
    
                WHSLoadTable loadTable;

                // First check to see if load build template allows using existing loads
                if (_loadBuildTemplate.UseOpenLoads == WHSUseOpenLoads::Any)
                {
                    if (lastMatchingLoadId)
                    {
                        loadTable = WHSLoadTable::find(lastMatchingLoadId);

                        if (this.validateLoad(_loadBuildTemplate, loadLine, loadTable.LoadId))
                        {
                            // Check to see if we split the load line
                            if (this.parmSplitLoadLine().RecId != 0)
                            {
                                loadLine = WHSLoadLine::findbyRecId(loadLine.RecId);
                                isLoadLineSplitted = true;
                            }
    
                            this.addShipmentLineToLoad(loadLine, loadTable.LoadId);
                            addShipmentLineCount++;
                            shipmentLineAssigned = true;
                            continue;
                        }
                    }

                    int openLoadCount;

                    str lockName;
                    boolean releaseLock;
                        
                    if (isLoadBuildLockFlightEnabled)
                    {
                        // Place a lock on the criteria, so multiple wave processes don't create the same load.
                        lockName = this.lockNameForBreakByCriteria(_loadBuildTemplate, loadLine);
                        boolean isLocked = WHSLoadBuildLockManager::hasWriterLock(lockName);
                        if (!isLocked)
                        {
                            WHSLoadBuildLockManager::enterWriterLock(lockName);

                            // If we have a lock, then we created the load. The lock should not be released before we commit.
                            releaseLock = true;
                        }
                    }

                    while select loadTable
                        where loadTable.InventSiteId        == waveTable.InventSiteId
                        &&    loadTable.InventLocationId    == waveTable.InventLocationId
                        &&    loadTable.LoadDirection       == WHSLoadDirection::Outbound
                        &&    loadTable.LoadStatus          != WHSLoadStatus::Shipped
                    {
                        openLoadCount++;

                        if (this.validateLoad(_loadBuildTemplate, loadLine, loadTable.LoadId))
                        {
                            // Check to see if we split the load line
                            if (this.parmSplitLoadLine().RecId != 0)
                            {
                                loadLine = WHSLoadLine::findbyRecId(loadLine.RecId);
                                isLoadLineSplitted = true;
                            }
    
                            this.addShipmentLineToLoad(loadLine, loadTable.LoadId);
                            addShipmentLineCount++;
                            lastMatchingLoadId = loadTable.LoadId;
                            shipmentLineAssigned = true;

                            if (isLoadBuildLockFlightEnabled && releaseLock)
                            {
                                // Relese lock for loads we didn't create so other processes can continue search for the load with the same criteria.
                                WHSLoadBuildLockManager::releaseLock(lockName);
                            }

                            break;
                        }
                    }

                    if (openLoadCount > maxOpenLoadCount)
                    {
                        maxOpenLoadCount = openLoadCount;
                    }
    
                    if (shipmentLineAssigned)
                    {
                        continue;
                    }
    
                    // If shipment line was not assigned to existing load, create new load depending on load build template config
                    if (_loadBuildTemplate.CreateLoads && _loadBuildTemplate.LoadTemplateId)
                    {
                        if (this.validateLoadLineBeforeCreation(_loadBuildTemplate, loadLine, lastMatchingLoadId, true))
                        {
                            lastMatchingLoadId = this.createNewLoad(_loadBuildTemplate.LoadBuildTemplateName, _loadBuildTemplate.LoadTemplateId, loadLine.ShipmentId);
                            createdLoadCount++;

                            if (this.validateLoadLineAfterCreation(_loadBuildTemplate, loadLine, lastMatchingLoadId))
                            {
                                this.addShipmentLineToLoad(loadLine, lastMatchingLoadId);
                                addShipmentLineCount++;
                            }
                        }
                    }
                }
                else if (_loadBuildTemplate.CreateLoads && _loadBuildTemplate.LoadTemplateId)
                {
                    if (lastMatchingLoadId)
                    {
                        [isLoadLineSplitted, shipmentLineAssigned] = this.assignShipmentToLoad(lastMatchingLoadId, _loadBuildTemplate, loadLine);
                    }

                    if (!shipmentLineAssigned)
                    {
                        if (this.validateLoadLineBeforeCreation(_loadBuildTemplate, loadLine, lastMatchingLoadId, true))
                        {
                            lastMatchingLoadId = this.createNewLoad(_loadBuildTemplate.LoadBuildTemplateName, _loadBuildTemplate.LoadTemplateId, loadLine.ShipmentId);
                            createdLoadCount++;

                            [isLoadLineSplitted, shipmentLineAssigned] = this.assignShipmentToLoad(lastMatchingLoadId, _loadBuildTemplate, loadLine, true);
                        }
                    }

                    if (shipmentLineAssigned)
                    {
                        addShipmentLineCount++;
                    }
                }
            }

            
            MapEnumerator loadTableUpdatersEnumerator = loadTableUpdaters.getEnumerator();

            while (loadTableUpdatersEnumerator.moveNext())
            {
                WHSLoadTableUpdater loadTableUpdater = loadTableUpdatersEnumerator.currentValue();
                loadTableUpdater.parmShouldInitStatusFromShipments(true);
                loadTableUpdater.parmShouldValidateWrite(true);
                loadTableUpdater.updateAfterAddingLines();
            }
            

            this.instrumentationLogger().loadBuildActivities().builtLoadsFromTemplate(activityContext, shipmentLineCount, createdLoadCount, addShipmentLineCount, maxOpenLoadCount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockNameForBreakByCriteria</Name>
				<Source><![CDATA[
    private str lockNameForBreakByCriteria(
        WHSLoadBuildTemplate    _loadBuildTemplate,
        WHSLoadLine             _loadLine)
    {
        int breakByCount = this.loadBuildTemplateBreakByList(_loadBuildTemplate).elements();
        str hashValue = curExt();

        if (breakByCount)
        {
            QueryRun assignQueryRun = new QueryRun(_loadBuildTemplate.PackedQueryRun);
            assignQueryRun.query().firstOnly1(true);
            assignQueryRun.query().dataSourceTable(tableNum(WHSLoadLine)).addRange(fieldNum(WHSLoadLine, RecId)).value(queryValue(_loadLine.RecId));

            if (assignQueryRun.next())
            {
                ListEnumerator lineEnumerator = this.loadBuildTemplateBreakByList(_loadBuildTemplate).getEnumerator();

                while (lineEnumerator.moveNext())
                {
                    WHSLoadBuildTemplateLine loadBuildTemplateLine = lineEnumerator.current();

                    Common  breakTable = assignQueryRun.get(loadBuildTemplateLine.GroupTableId);
                    AnyType breakFieldValue = breakTable.(loadBuildTemplateLine.GroupFieldId);

                    hashValue = hashValue + strFmt('#%1#%2#%3', loadBuildTemplateLine.GroupTableId, loadBuildTemplateLine.GroupFieldId, breakFieldValue);
                }
            }
        }
        return funcName() + ':' + HashFunctions::ComputeHashAsHexString(hashValue, HashType::SpookyHash);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignShipmentToLoad</Name>
				<Source><![CDATA[
    private container assignShipmentToLoad(
        WHSLoadId            _loadId,
        WHSLoadBuildTemplate _loadBuildTemplate,
        WHSLoadLine          _loadLine,
        boolean              _isLoadLineValidatedBeforeCreation = false)
    {
        WHSLoadTable loadTable = WHSLoadTable::find(_loadId);
        boolean isLoadLineSplitted;
        boolean shipmentLineAssigned;
    
        if (this.validateLoadLineAfterCreation(_loadBuildTemplate, _loadLine, loadTable.LoadId)
            && (_isLoadLineValidatedBeforeCreation || this.validateLoadLineBeforeCreation(_loadBuildTemplate, _loadLine, loadTable.LoadId)))
        {
            // Check to see if we split the load line
            if (this.parmSplitLoadLine().RecId != 0)
            {
                _loadLine = WHSLoadLine::findbyRecId(_loadLine.RecId);
                isLoadLineSplitted = true;
            }
    
            this.addShipmentLineToLoad(_loadLine, loadTable.LoadId);
            shipmentLineAssigned = true;
        }

        return [isLoadLineSplitted, shipmentLineAssigned];
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private WHSInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveLinesForShipmentWithoutLoad</Name>
				<Source><![CDATA[
    private void deleteWaveLinesForShipmentWithoutLoad()
    {
        boolean autoAddShipmentToWaveEnabledFlight = WHSAutoAddShipmentToWaveEnabledFlight::instance().isEnabled();
        WHSShipmentTable shipmentTable;

        while select ShipmentId from shipmentTable
            where shipmentTable.WaveId == waveTable.WaveId 
            && shipmentTable.LoadId == ''
        {
            WHSShipmentTable::reverseShipment(shipmentTable.ShipmentId);
            if(autoAddShipmentToWaveEnabledFlight)
            {
                WHSWaveProcessingRemovedShipment::updateOrCreateRemovedShipment(shipmentTable.ShipmentId, waveTable.WaveId, shipmentTable.ShipmentStatus, WHSWaveFailureErrorTypes::ShipmentLineNotAddedToLoad, strFmt("@WAX:ShipmentLineNotAddedToLoadWarning"));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showWarningForFailedShipmentLine</Name>
				<Source><![CDATA[
    private void showWarningForFailedShipmentLine()
    {
        WHSLoadLine shipmentLine;
        WHSWaveLine waveLine;

        while select OrderNum, ItemId from shipmentLine
                where shipmentLine.LoadId == ''
            exists join waveLine
                where waveLine.WaveId   == waveTable.WaveId
                && waveLine.ShipmentId  == shipmentLine.ShipmentId
                && waveLine.LoadId	    == ''
        {
            warning(strFmt("@WAX:ShipmentLineNotAddedToLoadWarning", shipmentLine.OrderNum, shipmentLine.ItemId));
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>