<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReleaseUpdateDB70_Retail</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ReleaseUpdateDB70_Retail</c> class contains upgrade scripts for retail module.
/// </summary>
public class ReleaseUpdateDB70_Retail extends ReleaseUpdateDB
{
    private const str RequiredDeviceTokenAlgorithm = 'SHA256';
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>moduleName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the module name of an upgrade class.
    /// </summary>
    /// <returns>
    ///    The module name.
    /// </returns>
    /// <remarks>
    ///    This method must be implemented by sub classes.The module name is displayed on the cockpit form for
    ///    every script.
    /// </remarks>
    public ReleaseUpdateModule moduleName()
    {
        return "@RET3014";
    }

]]></Source>
			</Method>
			<Method>
				<Name>myVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// The script runs in any system having version < CTP8.
    /// </summary>
    /// <returns>Script version.</returns>
    public sysReleasedVersion myVersion()
    {
        return sysReleasedVersion::R1; // For CTP8 hotfix scripts, version them as sysReleasedVersion::CTP8HF
    }

]]></Source>
			</Method>
			<Method>
				<Name>majorRetailBasicConfigurationKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uncheck the RetailBasic configuraiton key option to ensure AX menu options are displayed.  This is a new key in Rainier which should have a default
    /// value of false (as per AppOperations.cs table majorRetailBasicConfigurationKey).
    /// </summary>
    [UpgradeScriptDescriptionAttribute("@REX1125"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void majorRetailBasicConfigurationKey()
    {
        ConfigurationKeySet keySet = new ConfigurationKeySet();
        SysGlobalCache      cache = appl.globalCache();

        keySet.loadSystemSetup();
        keySet.enabled(configurationKeyNum(RetailCDXBackwardCompatibility), true);
        keySet.enabled(configurationKeyNum(RetailBasic), false);

        SysDictConfigurationKey::save(keySet.pack());

        // Call SysSecurity::reload with the following parameters:
        // _configurationChanged: true,
        // _allowSynchronize: false,
        // flushtable: true, 
        //_promptSynchronize: false, 
        //_syncRoleLicensesOnConfigurationChange: false
        SysSecurity::reload(true, false, true, false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasFoundDuplicateRetailChannelInDimensionAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Detects if there are DimensionAttributeValue records pointing to the same retail channel with different EntityInstance and DisplayValue.
    /// </summary>
    /// <param name = "_dimAttributeRetailChannel">The DimAttributeRetailChannel record containing RetailChannel RecId and natural key.</param>
    /// <returns>True if the records exist.</returns>
    private boolean hasFoundDuplicateRetailChannelInDimensionAttributeValue(
        DimAttributeRetailChannel _dimAttributeRetailChannel,
        DimensionAttributeValue _dimensionAttributeValueOMOperatingUnit,
        DimensionAttributeValue _dimensionAttributeValueRetailChannelTable)
    {
        OMOperatingUnit omOperatingUnit;

        // Get the OMOperatingUnit record matching the channel name of the DimAttributeRetailChannel record.
        select firstonly omOperatingUnit
            where omOperatingUnit.Name == _dimAttributeRetailChannel.Name;

        // Get the DimensionAttributeValue record matching the RecId and OMOperatingUnitNumber of the
        // OMOperatingUnit record.
        select firstonly _dimensionAttributeValueOMOperatingUnit
            where _dimensionAttributeValueOMOperatingUnit.EntityInstance == omOperatingUnit.RecId &&
                    _dimensionAttributeValueOMOperatingUnit.DisplayValue == omOperatingUnit.OMOperatingUnitNumber;

        // Get the DimensionAttributeValue record matching the Key (RetailChannelTable RecId) and Value
        // (RetailChannelTable natural key) of the DimAttributeRetailChannel record.
        select firstonly _dimensionAttributeValueRetailChannelTable
            where _dimensionAttributeValueRetailChannelTable.RecId != _dimensionAttributeValueOMOperatingUnit.RecId &&
                    _dimensionAttributeValueRetailChannelTable.EntityInstance == _dimAttributeRetailChannel.Key &&
                    _dimensionAttributeValueRetailChannelTable.DisplayValue == _dimAttributeRetailChannel.Value;

        // If the DimensionAttributeValue table has 2 records referencing to the same channel store,
        // which do not share the same EntityInstance (OMOperatingUnit RecId / RetailChannelTable RecId)
        // and DisplayValue (OMOperatingUnit OMOperatingUnitNumber / RetailChannelTable natural key),
        // then there is duplicate.
        return _dimensionAttributeValueOMOperatingUnit && _dimensionAttributeValueRetailChannelTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimensionAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the DimensionAttributeValue table after duplicate key error happened on postSyncMajorUpdateEntityInstanceDAV.
    /// There may be DimensionAttributeValue records pointing to the same retail channel but having different EntityInstance
    /// and DisplayValue. If such records exist an exception will be thrown to inform the customers.
    /// </summary>
    public str checkDimensionAttributeValue()
    {
        DimAttributeRetailChannel dimAttributeRetailChannel;
        DimensionAttributeValue dimensionAttributeValueRetailChannelTable;
        DimensionAttributeValue dimensionAttributeValueOMOperatingUnit;
        str errorMessage = '';

        while select dimAttributeRetailChannel
        {
            if (this.hasFoundDuplicateRetailChannelInDimensionAttributeValue(
                dimAttributeRetailChannel,
                dimensionAttributeValueOMOperatingUnit,
                dimensionAttributeValueRetailChannelTable))
            {
                errorMessage += strFmt("@Retail:UpgradeDimensionAttributeValueDuplicateRetailChannel",
                    dimensionAttributeValueRetailChannelTable.EntityInstance,
                    dimensionAttributeValueRetailChannelTable.DisplayValue,
                    dimensionAttributeValueRetailChannelTable.RecId,
                    dimensionAttributeValueOMOperatingUnit.EntityInstance,
                    dimensionAttributeValueOMOperatingUnit.DisplayValue,
                    dimensionAttributeValueOMOperatingUnit.RecId) + "\n\n";
            }
        }

        return errorMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSyncMajorUpdateEntityInstanceDAV</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>DimensionAttributeValue</c> table to account for orphan records in the Retail Financial Dimension.
    /// The routine verifies integrity of DimensionAttributeValue.EntityInstance and updates it to point to right RetailChannelTable record.
    /// </summary>
    [UpgradeScriptDescriptionAttribute("@RET5708"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::SharedScript),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeValue), false, true, true, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeLevelValue), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeValueSetItem), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttribute), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(RetailChannelTable), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(DirPartyTable), false, true, false, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void postSyncMajorUpdateEntityInstanceDAV()
    {
        DimensionAttribute dimensionAttribute;
        DimensionAttributeValue dimensionAttributeValue;
        DimensionAttributeLevelValue dimensionAttributeLevelValue, dimensionAttributeLevelValueDup;
        DimensionAttributeValueSetItem dimensionAttributeValueSetItem, dimensionAttributeValueSetItemDup;
        RetailChannelTable retailChannelTable;
        OMOperatingUnit oMOperatingUnit, oMOperatingUnitDup;

        boolean errorsDetected = false;
        Set dAVRecIdwithErrors = new Set(Types::String);
        str fixTips = '';

        ttsbegin;

        // Look for DimensionAttributeValues (DAV) with broken Retail Channel link
        while select forupdate EntityInstance,
                               RecId
        from dimensionAttributeValue
            where DimensionAttributeValue.IsDeleted == NoYes::No
        exists join dimensionAttribute
            where dimensionAttribute.RecId == dimensionAttributeValue.DimensionAttribute &&
                  (dimensionAttribute.ViewName == 'DimAttributeRetailChannel' || dimensionAttribute.ViewName == 'DimAttributeOMRetailChannel')
            notexists join RecId from retailChanneltable
            where retailChannelTable.RecId == dimensionAttributeValue.EntityInstance
        {
            // Verify if there are more than 1 value for the DAV in the DALV and DAVSI tables.
            // If there are more than 1 valid different DisplayValue for the current DAV on those tables
            // we cannot automatically define which one is the correct one, so we thow exception asking for
            // manual intervention prior to the upgrade
            select firstonly DisplayValue
                from dimensionAttributeLevelValue
                where dimensionAttributeLevelValue.DimensionAttributeValue == dimensionAttributeValue.RecId;

            select firstonly DisplayValue
                from dimensionAttributeLevelValueDup
                where dimensionAttributeLevelValueDup.DimensionAttributeValue == dimensionAttributeValue.RecId &&
                      dimensionAttributeLevelValueDup.DisplayValue != dimensionAttributeLevelValue.DisplayValue;

            if (!dimensionAttributeLevelValueDup)
            {
                select firstonly DisplayValue
                    from dimensionAttributeValueSetItem
                    where dimensionAttributeValueSetItem.DimensionAttributeValue == dimensionAttributeValue.RecId;

                select firstonly DisplayValue
                    from dimensionAttributeValueSetItemDup
                    where dimensionAttributeValueSetItemDup.DimensionAttributeValue == dimensionAttributeValue.RecId &&
                          dimensionAttributeValueSetItemDup.DisplayValue != dimensionAttributeValueSetItem.DisplayValue;
            }

            // Try to resolve current display values to existing Channels, using the 2 best hypothesis we have:
            // 1 - The DisplayValue is a DirPartyTable.OMOperatingUnitNumber
            // OR
            // 2 - The DisplayValue is a RetailChanneltable.RecId
            OMOperatingUnit firstDALVOMOperatingUnit,
                            secondDALVOMOperatingUnit,
                            firstDAVSIOMOperatingUnit,
                            secondDAVSIOMOperatingUnit;
            
            RetailChannelTable  firstDALVChannel,
                                secondDALVChannel,
                                firstDAVSIChannel,
                                secondDAVSIChannel;
            try
            {
                // Resolve OMOperatingUnit and RetailChannel for first unique item in DALV
                select firstDALVOMOperatingUnit where firstDALVOMOperatingUnit.OMOperatingUnitNumber == dimensionAttributeLevelValue.DisplayValue;
                select firstDALVChannel where firstDALVChannel.OMOperatingUnitID == firstDALVOMOperatingUnit.RecId;
                if ( !(firstDALVOMOperatingUnit && firstDALVChannel))
                {
                    firstDALVChannel = RetailChannelTable::findByRecId(str2Int64(dimensionAttributeLevelValue.DisplayValue));
                    firstDALVOMOperatingUnit = OMOperatingUnit::find(firstDALVChannel.OMOperatingUnitID, OMOperatingUnitType::RetailChannel);
                }

                // Resolve OMOperatingUnit and RetailChannel for second unique item in DALV 
                select secondDALVOMOperatingUnit where secondDALVOMOperatingUnit.OMOperatingUnitNumber == dimensionAttributeLevelValueDup.DisplayValue;
                select secondDALVChannel where secondDALVChannel.OMOperatingUnitID == secondDALVOMOperatingUnit.RecId;
                if ( !(secondDALVOMOperatingUnit && secondDALVChannel))
                {
                    secondDALVChannel = RetailChannelTable::findByRecId(str2Int64(dimensionAttributeLevelValueDup.DisplayValue));
                    secondDALVOMOperatingUnit = OMOperatingUnit::find(secondDALVChannel.OMOperatingUnitID, OMOperatingUnitType::RetailChannel);
                }

                // Resolve OMOperatingUnit and RetailChannel for first unique item in DAVSI
                select firstDAVSIOMOperatingUnit where firstDAVSIOMOperatingUnit.OMOperatingUnitNumber == dimensionAttributeValueSetItem.DisplayValue;
                select firstDAVSIChannel where firstDAVSIChannel.OMOperatingUnitID == firstDAVSIOMOperatingUnit.RecId;
                if (!(firstDAVSIOMOperatingUnit && firstDAVSIChannel))
                {
                    firstDAVSIChannel = RetailChannelTable::findByRecId(str2Int64(dimensionAttributeValueSetItem.DisplayValue));
                    firstDAVSIOMOperatingUnit = OMOperatingUnit::find(firstDAVSIChannel.OMOperatingUnitID, OMOperatingUnitType::RetailChannel);
                }

                // Resolve OMOperatingUnit and RetailChannel for second unique item in DAVSI
                select secondDAVSIOMOperatingUnit where secondDAVSIOMOperatingUnit.OMOperatingUnitNumber == dimensionAttributeValueSetItem.DisplayValue;
                select secondDAVSIChannel where secondDAVSIChannel.OMOperatingUnitID == secondDAVSIOMOperatingUnit.RecId;
                if (!(secondDAVSIOMOperatingUnit && secondDAVSIChannel))
                {
                    secondDAVSIChannel = RetailChannelTable::findByRecId(str2Int64(dimensionAttributeValueSetItem.DisplayValue));
                    secondDAVSIOMOperatingUnit = OMOperatingUnit::find(secondDAVSIChannel.OMOperatingUnitID, OMOperatingUnitType::RetailChannel);
                }
            }
            catch
            {
                // Catch generic errors
                // When trying to convert DisplayValues to int64 RecIds, the conversion could fail due to
                // the existence of DisplayValues with characteres in their masks.
                // In any other failure, we would skip to the final if() to throw an exception.
                errorsDetected = true;
            }
            
            if (! errorsDetected)
            {
                // Analyze results. Only pass if:
                // 1 - at least 1 party is resolved
                // 2 - All resolved parties refer to the same individual party
                boolean allDisplayValuesAreDeadLinks = (!firstDALVChannel)  &&
                                                       (!secondDALVChannel) &&
                                                       (!firstDAVSIChannel) &&
                                                       (!secondDAVSIChannel);

                boolean hasDMultipleDALVPerDAV       = (firstDALVChannel)   &&
                                                       (secondDALVChannel)  &&
                                                       (firstDALVChannel.RecId != secondDALVChannel.RecId);

                boolean hasDMultipleDAVSIPerDAV      = (firstDAVSIChannel)  &&
                                                       (secondDAVSIChannel) &&
                                                       (firstDAVSIChannel.RecId != secondDAVSIChannel.RecId);
            
                boolean isDALVNotEqualToDAVSI        = (firstDALVChannel)  &&
                                                       (firstDAVSIChannel) &&
                                                       (firstDALVChannel.RecId != firstDAVSIChannel.RecId);

                if (allDisplayValuesAreDeadLinks || hasDMultipleDALVPerDAV || hasDMultipleDAVSIPerDAV || isDALVNotEqualToDAVSI)
                {
                    fixTips = strFmt("@Retail:UpgradeDimensionAttributeValuesConflict", DimensionAttributeValue.RecId);

                    errorsDetected = true;
                    dAVRecIdwithErrors.add(int642Str(dimensionAttributeValue.RecId));
                }
                else
                {
                    // Recoverable DAV - Update DAV.EntityInstance with RetailChannel.RecId
                    if (firstDALVChannel)
                    {
                        // Resolve by DimensionAttributeLevelValue.DisplayValue (DALV)
                        dimensionAttributeValue.EntityInstance = firstDALVChannel.RecId;
                    }
                    else 
                    {   // Resolve by DimensionAttributeValueSetItem.DisplayValue (DAVSI)
                        dimensionAttributeValue.EntityInstance = firstDAVSIChannel.RecId;
                    }

                    try
                    {
                        dimensionAttributeValue.doUpdate();
                    }
                    catch (Exception::DuplicateKeyException)
                    {
                        errorsDetected = true;

                        str duplicateChannelDAVError = this.checkDimensionAttributeValue();
                        if (duplicateChannelDAVError != '')
                        {
                            fixTips = duplicateChannelDAVError;
                        }
                        else
                        {
                            fixTips = strFmt("@Retail:DuplicteKeyNotRecovered");
                        }

                        dAVRecIdwithErrors.add(int642Str(dimensionAttributeValue.RecId));
                    }
                }
            }
        }

        if (errorsDetected)
        {
            ttsabort;

            throw error(strFmt("@Retail:UpgradeDimensionAttributeValuesErrorMsg" + '\n' + fixTips, dAVRecIdwithErrors.toString()));
        }
        else
        {
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preSynchMajorAllowDupChannelIdxInRetailChannelTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index ChannelIdx in the table <c>RetailChannelTable</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>This is for the major verison upgrade.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET5708"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailChannelTable), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void preSynchMajorAllowDupChannelIdxInRetailChannelTable()
    {
        this.disableUniqueIndex(tableNum(RetailChannelTable), indexNum(RetailChannelTable, ChannelIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailChannelDA</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update DimensionAttribute <c>RetailChannel</c> to replace use of RecIds by RetailChannelId.
    /// </summary>
    /// <remarks>This will update the back Entity field and view used by the Retail Financial Dimension.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET5708"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(DimensionAttribute), false, true, true, false),
    UpgradeDependsOnTaskAttribute('postSyncMajorUpdateEntityInstanceDAV')
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailChannelDA()
    {
        DimensionAttribute dimensionAttribute;

        dimensionAttribute.disableCache(true);

        update_recordset dimensionAttribute
            setting BackingEntityTableName = 'RetailChannelTable',
                    BackingEntityValueFieldName = 'RetailChannelId',
                    ViewName = 'DimAttributeRetailChannel'
            where (dimensionAttribute.ViewName == 'DimAttributeOMRetailChannel') ||
                  (dimensionAttribute.ViewName == 'DimAttributeRetailChannel') ;

        DimensionAttribute::populateAllTableAndFieldNums();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailChannelTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign RetailChannelId values in table <c>RetailChannelTable</c> for entries where it was previously unassigned prior to upgrade.
    /// </summary>
    /// <remarks>This will ensure all transactions from retail channels are preserved during major upgrade.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET5708"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailChannelTable), false, true, true, false),
    UpgradeDependsOnTaskAttribute('updateMajorRetailChannelDA')
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailChannelTable()
    {
        RetailChannelTable retailChannelTable; // SaveDataPerCompany: No, SaveDataPerPartition: Yes

        // NOTE: See MSDN for useful info for number sequence: https://msdn.microsoft.com/en-us/library/aa608474.aspx
        // Load module that defines RetailChannelId number sequence.
        NumberSeqModuleRetailParameters numberSeqModuleRetailParam = new NumberSeqModuleRetailParameters();
        numberSeqModuleRetailParam.load();

        NumberSequenceTable::autoCreate(extendedTypeNum(RetailChannelId));

        NumberSequenceReference numberSequenceReference = NumberSeqReference::findReference(extendedTypeNum(RetailChannelId));

        // Find and resolve any duplicates/non-unique index: RetailChannelId
        while select forupdate retailChannelTable
                where (!retailChannelTable.RetailChannelId || retailChannelTable.RetailChannelId == '' )
        {
            retailChannelTable.RetailChannelId = NumberSeq::newGetNum(numberSequenceReference, false).num();
            retailChannelTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailChannelDAVC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Renames all <c>DimensionAttributeValueCombinations</c> with the new Retail Channel field RetailChannelId.
    /// This is the final step on top of previous two upgrade steps, in overall of updating DimensionAttribute <c>RetailChannel</c> to replace use of RecIds by RetailChannelId.
    /// </summary>
    /// <remarks>This will ensure all transactions with retail dimensions are preserved during major upgrade.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET5708"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailChannelTable), false, true, true, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeValue), false, true, true, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeLevelValue), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeValueSetItem), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(DimensionAttributeValueCombination), false, true, true, false),
    UpgradeScriptTableAttribute(tableStr(GeneralJournalAccountEntry), false, true, false, false),    UpgradeDependsOnTaskAttribute('updateMajorRetailChannelTable')
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailChannelDAVC()
    {
        // In previous step, we updated the registered column from RECID to RetailChannelId in DimensionAttribute table.
        // Now, we need to make the value for all related dimension table to update from RECID to RetailChannelId
        // We use the standard DimensionValueRename::syncRenamedValue to do that, it just like we previously having RECID as value, and now we updated as RetailchannelId.

        // Step 1: we query whether there is active dimensionAttribute for RetailChannelTable with RetailChannelId as field first
        DimensionAttribute dimAttr;
        while select dimAttr
            where dimAttr.BackingEntityTableName == tableStr(RetailChannelTable)
            && dimAttr.BackingEntityValueFieldName == fieldStr(RetailChannelTable, RetailChannelId)
        {
            if (dimAttr.getStatus() == DimensionAttributeStatus::Active)
            {
                // Step 2: use DimensionValueRename::syncRenamedValue to update value correctly from RECID to RetailChannelId
                RetailChannelTable rchTable;
                while select rchTable order by rchTable.RetailChannelId
                {
                    rchTable.RetailChannelId = any2Str(rchTable.RecId);
                    // Now the new value is actually the orig() one, i.e. the correct RetailChannelId, and the old value is that one with RECID
                    DimensionValueRename::syncRenamedValue(rchTable.orig(), rchTable);
                }

                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSyncUpdateRetailCreditMemoAppliedFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>RetailCreditVoucherTable</c> table to replace Recids by Ids in <c>AppliedInStoreId</c>
    /// and <c>AppliedByTerminalId</c> fields.
    /// </summary>
    /// <remarks>Minor upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET4774"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSyncUpdate),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript), // Shared script runs only once; Partition script runs in every Partition; Standard script runs in every Company.
    UpgradeScriptTableAttribute(tableStr(RetailCreditVoucherTable), false, true, true, false),
    UpgradeScriptTableAttribute(tableStr(RetailChanneltable), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(RetailTerminalTable), false, true, false, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void postSyncUpdateRetailCreditMemoAppliedFields()
    {
        this.updateRetailCreditMemoAppliedFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSyncMajorUpdateRetailCreditMemoAppliedFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// (Major) Updates the <c>RetailCreditVoucherTable</c> table to replace Recids by Ids in <c>AppliedInStoreId</c>
    /// and <c>AppliedByTerminalId</c> fields.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET4774"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript), // Shared script runs only once; Partition script runs in every Partition; Standard script runs in every Company.
    UpgradeScriptTableAttribute(tableStr(RetailCreditVoucherTable), false, true, true, false),
    UpgradeScriptTableAttribute(tableStr(RetailChanneltable), false, true, false, false),
    UpgradeScriptTableAttribute(tableStr(RetailTerminalTable), false, true, false, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void postSyncMajorUpdateRetailCreditMemoAppliedFields()
    {
        this.updateRetailCreditMemoAppliedFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailCreditMemoAppliedFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>RetailCreditVoucherTable</c> table to replace Recids by Ids in <c>AppliedInStoreId</c>
    /// and <c>AppliedByTerminalId</c> fields.
    /// </summary>
    private void updateRetailCreditMemoAppliedFields()
    {
        // Manual check: After the execution of this script, all records in RETAILCREDITVOUCHERTABLE
        // should have AppliedInStoreId and AppliedByTerminalId filled with StoreId and TerminalId respectively.
        // If the table still contains RecIds on these fields, then the script failed to upgrade.
        // A manual step to fix this would be manually replacing Recids from RETAILCREDITVOUCHERTABLE.AppliedInStoreId by
        // RetailChannelTable.StoreNumber for the record with RecId == AppliedInStoreId.
        // Same process is necessary to fix RETAILCREDITVOUCHERTABLE.AppliedByTerminalId
        RetailCreditVoucherTable RetailCreditVoucherTable;
        RetailStoreTable retailStoreTable;
        RetailTerminalTable retailTerminalTable;

        ttsbegin;

        while select forupdate retailCreditVoucherTable
        {
            if (isInteger(retailCreditVoucherTable.appliedInStoreId))
            {
                retailStoreTable = RetailStoreTable::findRecId(str2Int64(retailCreditVoucherTable.appliedInStoreId));
                if (retailStoreTable)
                {
                    retailCreditVoucherTable.appliedInStoreId = retailStoreTable.StoreNumber;
                }
            }

            if (isInteger(retailCreditVoucherTable.appliedByTerminalId))
            {
                retailTerminalTable = RetailTerminalTable::findByRecId(str2Int64(retailCreditVoucherTable.appliedByTerminalId));
                if (retailTerminalTable)
                {
                    retailCreditVoucherTable.appliedByTerminalId = retailTerminalTable.terminalId;
                }
            }
            retailCreditVoucherTable.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorKitLineIdxInRetailKitComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>KitLineIdx</c> in the table <c>RetailKitComponent</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@REX1071"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailKitComponent), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorKitLineIdxInRetailKitComponent()
    {
        this.disableUniqueIndex(tableNum(RetailKitComponent), indexNum(RetailKitComponent, KitLineIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailKitComponentKitLineIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailKitComponent</c> to include KitLineIdx {LineNum, Kit} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@REX1071"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailKitComponent), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailKitComponentKitLineIdx()
    {
        this.updateRetailKitComponentKitLineIdxLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailKitComponentKitLineIdxLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailKitComponent</c> to include KitLineIdx {LineNum, Kit} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateRetailKitComponentKitLineIdxLine()
    {
        RetailKitComponent retailKitComponent; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        RetailKitComponent duplicate;

        // Find and resolve any duplicates/non-unique index: SchemeLineIdx
        while select Kit from retailKitComponent
            group by Kit
            exists join duplicate
                where duplicate.Kit == retailKitComponent.Kit
                &&    duplicate.RecId != retailKitComponent.RecId
        {
            this.updateRetailKitComponentKitLineIdxGroup(retailKitComponent.Kit);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
              from retailKitComponent
        {
            retailKitComponent.LineNum = retailKitComponent.LineNum + 1;
            retailKitComponent.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailKitComponentKitLineIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailKitComponent</c> same Kit.
    /// </summary>
    /// <param name = "_kit">The Kit.</param>
    private void updateRetailKitComponentKitLineIdxGroup(Int64 _kit)
    {
        ttsbegin;

        RetailKitComponent retailKitComponent; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        this.callInsertUpdateRelatedSkipMethods(retailKitComponent);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailKitComponent
              order by RecId
              where retailKitComponent.Kit == _kit
        {
            retailKitComponent.LineNum = seqCounter;
            retailKitComponent.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorPolicyLineIdxInRetailReturnPolicyLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>PolicyLineIdx</c> in the table <c>RetailReturnPolicyLine</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@REX4160669"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailReturnPolicyLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorPolicyLineIdxInRetailReturnPolicyLine()
    {
        this.disableUniqueIndex(tableNum(RetailReturnPolicyLine), indexNum(RetailReturnPolicyLine, PolicyLineIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarjoRetailReturnPolicyLinePolicyLineIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailReturnPolicyLine</c> to include PolicyLineIdx {LineNum, Policy} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@REX4160669"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailReturnPolicyLine), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMarjoRetailReturnPolicyLinePolicyLineIdx()
    {
        this.updateRetailReturnPolicyLinePolicyLineIdxLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailReturnPolicyLinePolicyLineIdxLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailReturnPolicyLine</c> to include PolicyLineIdx {LineNum, Policy} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateRetailReturnPolicyLinePolicyLineIdxLine()
    {
        RetailReturnPolicyLine retailReturnPolicyLine; // SaveDataPerCompany: Yes, SaveDataPerPartition: Yes
        RetailReturnPolicyLine duplicate;

        // Find and resolve any duplicates/non-unique index: SchemeLineIdx
        while select Policy from retailReturnPolicyLine
            group by Policy
            exists join duplicate
                where duplicate.Policy == retailReturnPolicyLine.Policy
                &&    duplicate.RecId != retailReturnPolicyLine.RecId
        {
            this.updateRetailReturnPolicyLinePolicyLineIdxGroup(retailReturnPolicyLine.Policy);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
              from retailReturnPolicyLine
        {
            retailReturnPolicyLine.LineNum = retailReturnPolicyLine.LineNum + 1;
            retailReturnPolicyLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailReturnPolicyLinePolicyLineIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailReturnPolicyLine</c> same Policy.
    /// </summary>
    /// <param name = "_policy">The Policy.</param>
    private void updateRetailReturnPolicyLinePolicyLineIdxGroup(Int64 _policy)
    {
        ttsbegin;

        RetailReturnPolicyLine retailReturnPolicyLine; // SaveDataPerCompany: Yes, SaveDataPerPartition: Yes
        this.callInsertUpdateRelatedSkipMethods(retailReturnPolicyLine);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailReturnPolicyLine
              order by RecId
              where retailReturnPolicyLine.Policy == _policy
        {
            retailReturnPolicyLine.LineNum = seqCounter;
            retailReturnPolicyLine.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowMajorDupRetailAssortmentTableIdxInRetailAssortmentProductLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>RetailAssortmentTableIdx</c> in the table <c>RetailAssortmentProductLine</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET6066"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailAssortmentProductLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowMajorDupRetailAssortmentTableIdxInRetailAssortmentProductLine()
    {
        this.disableUniqueIndex(tableNum(RetailAssortmentProductLine), indexNum(RetailAssortmentProductLine, RetailAssortmentTableIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailAssortmentProductLineRetailAssortmentTableIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailAssortmentProductLine</c> to include RetailAssortmentTableIdx {LineNum, AssortmentRecId, Status} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET6066"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailAssortmentProductLine), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailAssortmentProductLineRetailAssortmentTableIdx()
    {
        this.updateRetailAssortmentProductLineRetailAssortmentTableIdxLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailAssortmentProductLineRetailAssortmentTableIdxLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailAssortmentProductLine</c> to include RetailAssortmentTableIdx {LineNum, AssortmentRecId, Status} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateRetailAssortmentProductLineRetailAssortmentTableIdxLine()
    {
        RetailAssortmentProductLine retailAssortmentProductLine; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        RetailAssortmentProductLine duplicate;

        // Find and resolve any duplicates/non-unique index: AssortmentTableIdx
        while select AssortmentRecId from retailAssortmentProductLine
            group by AssortmentRecId
            exists join duplicate
                where duplicate.AssortmentRecId == retailAssortmentProductLine.AssortmentRecId
                &&    duplicate.RecId != retailAssortmentProductLine.RecId
        {
            this.updateRetailAssortmentProductLineRetailAssortmentTableIdxGroup(retailAssortmentProductLine.AssortmentRecId);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
              from retailAssortmentProductLine
        {
            retailAssortmentProductLine.LineNum = retailAssortmentProductLine.LineNum + 1;
            retailAssortmentProductLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailAssortmentProductLineRetailAssortmentTableIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailAssortmentProductLine</c> same AssortmentRecId/Status}.
    /// </summary>
    /// <param name = "_assortmentRecId">The assortment.</param>
    private void updateRetailAssortmentProductLineRetailAssortmentTableIdxGroup(RefRecId _assortmentRecId)
    {
        ttsbegin;

        RetailAssortmentProductLine retailAssortmentProductLine; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        this.callInsertUpdateRelatedSkipMethods(retailAssortmentProductLine);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailAssortmentProductLine
              order by RecId
              where retailAssortmentProductLine.assortmentRecId == _assortmentRecId
        {
            retailAssortmentProductLine.LineNum = seqCounter;
            retailAssortmentProductLine.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorDlvModeLineNumIdxInRetailDlvModeProductLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>DlvModeLineNumIdx</c> in the table <c>RetailDlvModeProductLine</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET6066"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailDlvModeProductLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorDlvModeLineNumIdxInRetailDlvModeProductLine()
    {
        this.disableUniqueIndex(tableNum(RetailDlvModeProductLine), indexNum(RetailDlvModeProductLine, DlvModeLineNumIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailDlvModeProductLineDlvModeLineNumIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailDlvModeProductLine</c> to include DlvModeLineNumIdx {LineNum, DlvMode} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET6066"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailDlvModeProductLine), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailDlvModeProductLineDlvModeLineNumIdx()
    {
        this.updateRetailDlvModeProductLineDlvModeLineNumIdxLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailDlvModeProductLineDlvModeLineNumIdxLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailReturnPolicyLine</c> to include DlvModeLineNumIdx {LineNum, DlvMode} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateRetailDlvModeProductLineDlvModeLineNumIdxLine()
    {
        RetailDlvModeProductLine retailDlvModeProductLine; // SaveDataPerCompany: Yes, SaveDataPerPartition: Yes
        RetailDlvModeProductLine duplicate;

        // Find and resolve any duplicates/non-unique index: SchemeLineIdx
        while select DlvMode from retailDlvModeProductLine
            group by DlvMode
            exists join duplicate
                where duplicate.DlvMode == retailDlvModeProductLine.DlvMode
                &&    duplicate.RecId != retailDlvModeProductLine.RecId
        {
            this.updateRetailDlvModeProductLineDlvModeLineNumIdxGroup(retailDlvModeProductLine.DlvMode);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
              from retailDlvModeProductLine
        {
            retailDlvModeProductLine.LineNum = retailDlvModeProductLine.LineNum + 1;
            retailDlvModeProductLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailDlvModeProductLineDlvModeLineNumIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailReturnPolicyLine</c> same Policy.
    /// </summary>
    /// <param name = "_dlvMode">The DlvMode.</param>
    private void updateRetailDlvModeProductLineDlvModeLineNumIdxGroup(Int64 _dlvMode)
    {
        ttsbegin;

        RetailDlvModeProductLine retailDlvModeProductLine; // SaveDataPerCompany: Yes, SaveDataPerPartition: Yes
        this.callInsertUpdateRelatedSkipMethods(retailDlvModeProductLine);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailDlvModeProductLine
              order by RecId
              where retailDlvModeProductLine.DlvMode == _dlvMode
        {
            retailDlvModeProductLine.LineNum = seqCounter;
            retailDlvModeProductLine.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorSchemeLineIdxInRetailLoyaltyEarnSchemeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>SchemeLineIdx</c> in the table <c>RetailLoyaltyEarnSchemeLine</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@REX1455"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailLoyaltyEarnSchemeLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorSchemeLineIdxInRetailLoyaltyEarnSchemeLine()
    {
        this.disableUniqueIndex(tableNum(RetailLoyaltyEarnSchemeLine), indexNum(RetailLoyaltyEarnSchemeLine, SchemeLineIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailLoyaltyEarnSchemeLinesSchemeLineIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailLoyaltyEarnSchemeLine</c> to include SchemeLineIdx {LineNum, LoyaltyScheme} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@REX1455"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailLoyaltyEarnSchemeLine), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailLoyaltyEarnSchemeLinesSchemeLineIdx()
    {
        this.updateRetailLoyaltyEarnSchemeLinesSchemeLineIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailLoyaltyEarnSchemeLinesSchemeLineIdxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailLoyaltyEarnSchemeLine</c> to include SchemeLineIdx {LineNum, LoyaltyScheme} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateRetailLoyaltyEarnSchemeLinesSchemeLineIdxTable()
    {
        RetailLoyaltyEarnSchemeLine retailLoyaltyEarnSchemeLine; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        RetailLoyaltyEarnSchemeLine duplicate;

        // Find and resolve any duplicates/non-unique index: SchemeLineIdx
        while select LoyaltyScheme from retailLoyaltyEarnSchemeLine
            group by LoyaltyScheme
            exists join duplicate
                where duplicate.LoyaltyScheme == retailLoyaltyEarnSchemeLine.LoyaltyScheme
                &&    duplicate.RecId != retailLoyaltyEarnSchemeLine.RecId
        {
            this.updateRetailLoyaltyEarnSchemeLineIndexGroup(retailLoyaltyEarnSchemeLine.LoyaltyScheme);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
                from retailLoyaltyEarnSchemeLine
        {
            retailLoyaltyEarnSchemeLine.LineNum = retailLoyaltyEarnSchemeLine.LineNum + 1;
            retailLoyaltyEarnSchemeLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailLoyaltyEarnSchemeLineIndexGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailLoyaltyEarnSchemeLine</c> same LoyaltyScheme.
    /// </summary>
    /// <param name = "_loyaltyScheme">The loyalty scheme.</param>
    private void updateRetailLoyaltyEarnSchemeLineIndexGroup(RefRecId _loyaltyScheme)
    {
        ttsbegin;

        RetailLoyaltyEarnSchemeLine retailLoyaltyEarnSchemeLine;
        this.callInsertUpdateRelatedSkipMethods(retailLoyaltyEarnSchemeLine);

        int seqCounter = 0;
        // Ensure no duplicate records by assigning LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailLoyaltyEarnSchemeLine
              order by RecId
              where retailLoyaltyEarnSchemeLine.LoyaltyScheme == _loyaltyScheme
        {
            retailLoyaltyEarnSchemeLine.LineNum = seqCounter;
            retailLoyaltyEarnSchemeLine.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorSchemeLineIdxInRetailLoyaltyRedeemSchemeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>SchemeLineIdx</c> in the table <c>RetailLoyaltyRedeemSchemeLine</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@REX73"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailLoyaltyRedeemSchemeLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorSchemeLineIdxInRetailLoyaltyRedeemSchemeLine()
    {
        this.disableUniqueIndex(tableNum(RetailLoyaltyRedeemSchemeLine), indexNum(RetailLoyaltyRedeemSchemeLine, SchemeLineIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailLoyaltyRedeemSchemeLinesSchemeLineIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailLoyaltyRedeemSchemeLine</c> to include SchemeLineIdx {LineNum, LoyaltyScheme} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@REX73"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailLoyaltyRedeemSchemeLine), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailLoyaltyRedeemSchemeLinesSchemeLineIdx()
    {
        this.updateRetailLoyaltyRedeemSchemeLinesSchemeLineIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailLoyaltyRedeemSchemeLinesSchemeLineIdxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailLoyaltyRedeemSchemeLine</c> to include SchemeLineIdx {LineNum, LoyaltyScheme} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateRetailLoyaltyRedeemSchemeLinesSchemeLineIdxTable()
    {
        RetailLoyaltyRedeemSchemeLine retailLoyaltyRedeemSchemeLine; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        RetailLoyaltyRedeemSchemeLine duplicate;

        // Find and resolve any duplicates/non-unique index: SchemeLineIdx
        while select LoyaltyScheme from retailLoyaltyRedeemSchemeLine
            group by LoyaltyScheme
            exists join duplicate
                where duplicate.LoyaltyScheme == retailLoyaltyRedeemSchemeLine.LoyaltyScheme
                &&    duplicate.RecId != retailLoyaltyRedeemSchemeLine.RecId
        {
            this.updateRetailLoyaltyRedeemSchemeLineIndexGroup(retailLoyaltyRedeemSchemeLine.LoyaltyScheme);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
              from retailLoyaltyRedeemSchemeLine
        {
            retailLoyaltyRedeemSchemeLine.LineNum = retailLoyaltyRedeemSchemeLine.LineNum + 1;
            retailLoyaltyRedeemSchemeLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailLoyaltyRedeemSchemeLineIndexGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailLoyaltyRedeemSchemeLine</c> same LoyaltyScheme.
    /// </summary>
    /// <param name = "_loyaltyScheme">The loyalty scheme.</param>
    private void updateRetailLoyaltyRedeemSchemeLineIndexGroup(RefRecId _loyaltyScheme)
    {
        ttsbegin;

        RetailLoyaltyRedeemSchemeLine retailLoyaltyRedeemSchemeLine;
        this.callInsertUpdateRelatedSkipMethods(retailLoyaltyRedeemSchemeLine);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailLoyaltyRedeemSchemeLine
              order by RecId
              where retailLoyaltyRedeemSchemeLine.LoyaltyScheme == _loyaltyScheme
        {
            retailLoyaltyRedeemSchemeLine.LineNum = seqCounter;
            retailLoyaltyRedeemSchemeLine.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorCatalogNumberIdxInCatalog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>CatalogNumberIdx</c> in the table <c>Catalog</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET15004"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(Catalog), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorCatalogNumberIdxInCatalog()
    {
        this.disableUniqueIndex(tableNum(Catalog), indexNum(Catalog, CatalogNumberIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorCatalogCatalogNumberIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>Catalog</c> to include CatalogNumberIdx {CatalogId} as unique key.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET15004"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(Catalog), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorCatalogCatalogNumberIdx()
    {
        this.updateCatalogCatalogNumberIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCatalogCatalogNumberIdxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>Catalog</c> to include CatalogNumberIdx {CatalogId} as unique key.
    /// </summary>
    private void updateCatalogCatalogNumberIdxTable()
    {
        Catalog catalog; // SaveDataPerCompany: No, SaveDataPerPartition: Yes

        ttsbegin;

        // NOTE: See MSDN for useful info for number sequence: https://msdn.microsoft.com/en-us/library/aa608474.aspx
        NumberSeqModuleRetail numberSeqModuleRetail = new NumberSeqModuleRetail();
        NumberSeqModuleRetail.load();
        
        NumberSequenceTable::autoCreate(extendedTypeNum(RetailCatalogId));

        NumberSequenceReference numberSequenceReference = NumberSeqReference::findReference(extendedTypeNum(RetailCatalogId));

        // Find and resolve any duplicates/non-unique index: CatalogId
        while select forupdate CatalogId from catalog
                where (!catalog.CatalogId || catalog.CatalogId == '' )
        {
            catalog.CatalogId = NumberSeq::newGetNum(NumberSequenceReference, false).num();
            catalog.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorRequestNumInMCRRCAuthTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>RequestNum</c> in the table <c>MCRCatalogRequest</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@MCR10738"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(MCRCatalogRequest), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorRequestNumInMCRRCAuthTable()
    {
        this.disableUniqueIndex(tableNum(MCRCatalogRequest), indexNum(MCRCatalogRequest, RequestNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorMCRCatalogRequestRequestNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRCatalogRequest</c> to include RequestNum {MCRCatalogDescription, MCRCatalogRequestNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@MCR10738"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(MCRSourceCode)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(MCRCatalogRequest), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorMCRCatalogRequestRequestNum()
    {
        this.updateMCRCatalogRequestRequestNumTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRCatalogRequestRequestNumTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRCatalogRequest</c> to include RequestNum {MCRCatalogDescription, MCRCatalogRequestNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateMCRCatalogRequestRequestNumTable()
    {
        MCRCatalogRequest mcrCatalogRequest; // SaveDataPerCompany/SaveDataPerPartition: Yes/Yes, ConfigKey: MCRSourceCode
        MCRCatalogRequest duplicate;

        // Find and resolve any duplicates/non-unique index: RequestNum
        while select MCRCatalogDescription from mcrCatalogRequest
            group by MCRCatalogDescription
            exists join duplicate
                where duplicate.MCRCatalogDescription == mcrCatalogRequest.MCRCatalogDescription
                &&    duplicate.RecId != mcrCatalogRequest.RecId
        {
            this.updateMCRCatalogRequestRequestNumGroup(mcrCatalogRequest.MCRCatalogDescription);
        }

        //  make the LineNum (e.g., MCRCatalogRequestNum) base 1 instead of base 0 for all records
        while select forupdate MCRCatalogRequestNum
                from mcrCatalogRequest
        {
            mcrCatalogRequest.MCRCatalogRequestNum = mcrCatalogRequest.MCRCatalogRequestNum + 1;
            mcrCatalogRequest.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRCatalogRequestRequestNumGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>MCRCatalogRequest</c> same SalesId.
    /// </summary>
    /// <param name = "_description">The MCR catalog description.</param>
    private void updateMCRCatalogRequestRequestNumGroup(MCRCatalogDesc _description)
    {
        ttsbegin;

        MCRCatalogRequest mcrCatalogRequest;
        this.callInsertUpdateRelatedSkipMethods(mcrCatalogRequest);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon MCRCatalogDescription
        while select forupdate MCRCatalogRequestNum
              from mcrCatalogRequest
              order by RecId
              where mcrCatalogRequest.MCRCatalogDescription == _description
        {
            mcrCatalogRequest.MCRCatalogRequestNum = seqCounter;
            mcrCatalogRequest.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorSalesIdIdxInMCRRCAuthTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>SalesIdIdx</c> in the table <c>MCRRCAuthTable</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    [UpgradeScriptDescriptionAttribute("@MCR23538"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(MCRRCAuthTable), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorSalesIdIdxInMCRRCAuthTable()
    {
        this.disableUniqueIndex(tableNum(MCRRCAuthTable), indexNum(MCRRCAuthTable, SalesIdIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRRCAuthTableSalesIdIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRRCAuthTable</c> to include SalesIdIdx {SalesId, LineNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Minor upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@MCR23538"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(MCRPayment)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSyncUpdate),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(MCRRCAuthTable), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMCRRCAuthTableSalesIdIdx()
    {
        this.updateMCRRCAuthTableSalesIdIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorMCRRCAuthTableSalesIdIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRRCAuthTable</c> to include SalesIdIdx {SalesId, LineNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@MCR23538"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(MCRPayment)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(MCRRCAuthTable), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorMCRRCAuthTableSalesIdIdx()
    {
        this.updateMCRRCAuthTableSalesIdIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>truncateTable</Name>
				<Source><![CDATA[
    private void truncateTable(Common _table)
    {
        str tableName = _table.getPhysicalTableName();
        str sql = strFmt(@"TRUNCATE TABLE %1", tableName);

        Statement stmt = new Connection().createStatement();
        new SqlStatementExecutePermission(sql).assert();
        try
        {
            stmt.executeUpdateWithParameters(sql, null);
        }
        finally
        {
            CodeAccessPermission::revertAssert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRRCAuthTableSalesIdIdxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRRCAuthTable</c> to include SalesIdIdx {SalesId, LineNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateMCRRCAuthTableSalesIdIdxTable()
    {
        MCRRCAuthTable mcrRcAuthTable; // SaveDataPerCompany/SaveDataPerPartition: Yes/Yes, ConfigKey: MCRPayment
        MCRRCAuthTable duplicate;

        // Find and resolve any duplicates/non-unique index: SalesIdIdx
        while select SalesId from mcrRcAuthTable
            group by SalesId
            exists join duplicate
                where duplicate.SalesId == mcrRcAuthTable.SalesId
                &&    duplicate.RecId != mcrRcAuthTable.RecId
        {
            this.updateMCRRCAuthTableSalesIdIdxGroup(mcrRcAuthTable.SalesId);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
                from mcrRcAuthTable
        {
            mcrRcAuthTable.LineNum = mcrRcAuthTable.LineNum + 1;
            mcrRcAuthTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRRCAuthTableSalesIdIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>MCRRCAuthTable</c> same SalesId.
    /// </summary>
    /// <param name = "_salesId">The Sales Id.</param>
    private void updateMCRRCAuthTableSalesIdIdxGroup(SalesId _salesId)
    {
        ttsbegin;

        MCRRCAuthTable mcrRcAuthTable;
        this.callInsertUpdateRelatedSkipMethods(mcrRcAuthTable);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon SalesId
        while select forupdate LineNum
              from mcrRcAuthTable
              order by RecId
              where mcrRcAuthTable.SalesId == _salesId
        {
            mcrRcAuthTable.LineNum = seqCounter;
            mcrRcAuthTable.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorSalesIdIdxInMCRRCSettlementTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>SalesIdIdx</c> in the table <c>MCRRCSettlementTable</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@MCR23533"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(MCRRCSettlementTable), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorSalesIdIdxInMCRRCSettlementTable()
    {
        this.disableUniqueIndex(tableNum(MCRRCSettlementTable), indexNum(MCRRCSettlementTable, SalesIdIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorMCRRCSettlementTableSalesIdIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRRCSettlementTable</c> to include SalesIdIdx {SalesId, LineNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@MCR23533"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(MCRPayment)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(MCRRCSettlementTable), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorMCRRCSettlementTableSalesIdIdx()
    {
        this.updateMCRRCSettlementTableSalesIdIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRRCSettlementTableSalesIdIdxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>MCRRCSettlementTable</c> to include SalesIdIdx {SalesId, LineNum} as unique key.
    /// LineNum did not exist in prior release so we must add it.
    /// </summary>
    private void updateMCRRCSettlementTableSalesIdIdxTable()
    {
        MCRRCSettlementTable mcrRcSettlementTable; // SaveDataPerCompany/SaveDataPerPartition: Yes/Yes, ConfigKey: MCRPayment
        MCRRCSettlementTable duplicate;

        // Find and resolve any duplicates/non-unique index: SalesIdIdx
        while select SalesId from mcrRcSettlementTable
            group by SalesId
            exists join duplicate
                where duplicate.SalesId == mcrRcSettlementTable.SalesId
                &&    duplicate.RecId != mcrRcSettlementTable.RecId
        {
            this.updateMCRRCSettlementTableSalesIdIdxGroup(mcrRcSettlementTable.SalesId);
        }

        // make the LineNum  base 1 instead of base 0 for all records
        while select forupdate LineNum
                from mcrRcSettlementTable
        {
            mcrRcSettlementTable.LineNum = mcrRcSettlementTable.LineNum + 1;
            mcrRcSettlementTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRRCSettlementTableSalesidIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>MCRRCSettlementTable</c> same SalesId.
    /// </summary>
    /// <param name = "_salesId">The sales Id.</param>
    private void updateMCRRCSettlementTableSalesidIdxGroup(SalesId _salesId)
    {
        ttsbegin;

        MCRRCSettlementTable mcrRcSettlementTable;
        this.callInsertUpdateRelatedSkipMethods(mcrRcSettlementTable);

        int seqCounter = 0;
        // Remove duplicate names adding a LineNum to all based upon SalesId
        while select forupdate LineNum
              from mcrRcSettlementTable
              order by RecId
              where mcrRcSettlementTable.SalesId == _salesId
        {
            mcrRcSettlementTable.LineNum = seqCounter;
            mcrRcSettlementTable.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupMajorPriceRuleGroupIdxInRetailCategoryPriceRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>PriceRuleGroupIdx</c> in the table <c>RetailCategoryPriceRule</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@REX1215"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailCategoryPriceRule), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupMajorPriceRuleGroupIdxInRetailCategoryPriceRule()
    {
        this.disableUniqueIndex(tableNum(RetailCategoryPriceRule), indexNum(RetailCategoryPriceRule, PriceRuleGroupIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailCategoryPriceRulePriceRuleGroupIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailCategoryPriceRule</c> to include PriceRuleGroupIdx {CategoryPriceRuleGroupCode, LineNum} as unique key.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@REX1215"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailCategoryPriceRule), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailCategoryPriceRulePriceRuleGroupIdx()
    {
        this.updateRetailCategoryPriceRulePriceRuleGroupIdxTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailCategoryPriceRulePriceRuleGroupIdxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailCategoryPriceRule</c> to include PriceRuleGroupIdx {CategoryPriceRuleGroupCode, LineNum} as unique key.
    /// </summary>
    private void updateRetailCategoryPriceRulePriceRuleGroupIdxTable()
    {
        RetailCategoryPriceRule retailCategoryPriceRule; // SaveDataPerCompany: Yes, SaveDataPerPartition: Yes
        RetailCategoryPriceRule duplicate;

        // Find and resolve any duplicates/non-unique index: NameIdx
        while select CategoryPriceRuleGroupCode from retailCategoryPriceRule
            group by CategoryPriceRuleGroupCode
            exists join duplicate
                where duplicate.CategoryPriceRuleGroupCode == retailCategoryPriceRule.CategoryPriceRuleGroupCode
                &&    duplicate.RecId != retailCategoryPriceRule.RecId
        {
            this.updateRetailCategoryPriceRulePriceRuleGroupIdxGroup(retailCategoryPriceRule.CategoryPriceRuleGroupCode);
        }

        // make the LineNum base 1 instead of base 0 for all records
        while select forupdate LineNum
                from retailCategoryPriceRule
        {
            retailCategoryPriceRule.LineNum = retailCategoryPriceRule.LineNum + 1;
            retailCategoryPriceRule.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailCategoryPriceRulePriceRuleGroupIdxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LineNum all <c>RetailCategoryPriceRule</c> same PriceRuleGroupIdx.
    /// </summary>
    /// <param name = "_groupCode">The group code.</param>
    private void updateRetailCategoryPriceRulePriceRuleGroupIdxGroup(RetailCategoryPriceRuleGroupCode _groupCode)
    {
        ttsbegin;

        RetailCategoryPriceRule retailCategoryPriceRule;
        this.callInsertUpdateRelatedSkipMethods(retailCategoryPriceRule);

        int seqCounter = 0;
        // Ensure no duplicate records by assigning LineNum to all based upon loyaltyScheme
        while select forupdate LineNum
              from retailCategoryPriceRule
              order by RecId
              where retailCategoryPriceRule.CategoryPriceRuleGroupCode == _groupCode
        {
            retailCategoryPriceRule.LineNum = seqCounter;
            retailCategoryPriceRule.doUpdate();
            seqCounter += 1;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailDiscountLineOfferNMinus1</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailDiscountLineOffer</c> to for N-1.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET6364"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(RetailCDXBackwardCompatibility)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailDiscountLineOffer), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateRetailDiscountLineOfferNMinus1()
    {
        ttsbegin;

        // Calls the skip methods that are relevant when doing inserts or updates.
        RetailDiscountLineOffer lineOffer;
        this.callInsertUpdateRelatedSkipMethods(lineOffer);

        // Before using the new ax7 columns below, initialize them to default values as the upgrade framework is seeting some records of these
        // columns to invalid (null) value.
        update_recordset lineOffer
            setting discountMethodN1 = 0,
            offerPriceN1 = 0,
            offerPriceInclTaxN1 = 0;

        update_recordset lineOffer
        setting discountMethodN1 = RetailOfferLineDiscountMethodBaseN1::Price,
                offerPriceN1 = lineOffer.offerPrice
        where lineOffer.discountMethod == RetailDiscountOfferLineDiscMethodBase::Price;

        RetailDiscountLineOffer lineOfferIncludeTax;
        this.callInsertUpdateRelatedSkipMethods(lineOfferIncludeTax);

        update_recordset lineOfferIncludeTax
        setting discountMethodN1 = RetailOfferLineDiscountMethodBaseN1::PriceInclTax,
                offerPriceInclTaxN1 = lineOfferIncludeTax.offerPriceInclTax,
                discountMethod = RetailDiscountOfferLineDiscMethodBase::Price,
                offerPrice = lineOfferIncludeTax.offerPriceInclTax
        where lineOfferIncludeTax.discountMethod == 3;
            
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateMajorRetailSalesQuotationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the link in table <c>RetailSalesQuotationLine</c> so that the SalesQuotationLine links to the <c>SalesQuotationLine</c> RecId where previously it joined via the InventTransId.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET490383"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailSalesQuotationLine), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void populateMajorRetailSalesQuotationLine()
    {
        this.populateRetailSalesQuotationLineTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateRetailSalesQuotationLineTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the link in table <c>RetailSalesQuotationLine</c> so that the SalesQuotationLine links to the <c>SalesQuotationLine</c> RecId where previously it joined via the InventTransId.
    /// </summary>
    private void populateRetailSalesQuotationLineTable()
    {
        RetailSalesQuotationLine    retailSalesQuotationLine; // SaveDataPerCompany/Partition: Yes/Yes, ConfigKey: Retail
        SalesQuotationLine          salesQuotationLine;

        new SkipAOSValidationPermission().assert();
        
        this.callInsertUpdateRelatedSkipMethods(retailSalesQuotationLine);

        update_recordset retailSalesQuotationLine
            setting
                SalesQuotationLine  = salesQuotationLine.RecId
            join InventTransId, RecId
            from salesQuotationLine
                where salesQuotationLine.InventTransId == retailSalesQuotationLine.InventTransId;


        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorRetailSharedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>RetailSharedParameters</c>
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@RET5792"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailSharedParameters), false, true, true, false)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorRetailSharedParameters()
    {
        RetailSharedParameters retailSharedParameters; // SaveDataPerCompany: No, SaveDataPerPartition: Yes
        
        ttsbegin;

        while select forupdate retailSharedParameters where retailSharedParameters.DeviceTokenExpiration == 0
        {
            // for any records (should be exactly 0/1) where DeviceTokenExpiration is 0, set it to 365.
            retailSharedParameters.DeviceTokenExpiration = 365;
            retailSharedParameters.doUpdate();
        }

        while select forupdate retailSharedParameters where retailSharedParameters.DeviceTokenAlgorithm != RequiredDeviceTokenAlgorithm
        {
            // for any records (should be exactly 0/1), set DeviceTokenAlgorithm to 'SHA256'
            retailSharedParameters.DeviceTokenAlgorithm = RequiredDeviceTokenAlgorithm;
            retailSharedParameters.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupSalesLineIdxInRetailSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index SalesLineIdx in the table <c>RetailSalesLine</c> to allow duplicate records.
    /// </summary>
    /// <remarks>
    /// The SalesLine field is used in the unique index SalesLineIdx on the table <c>RetailSalesLine</c>.
    /// Initially this field contains no value. So the index is set to allow duplicates before the field is updated
    /// with the new values.
    /// </remarks>
    [UpgradeScriptDescriptionAttribute("@RET490383"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailSalesLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupSalesLineIdxInRetailSalesLine()
    {
        this.disableUniqueIndex(tableNum(RetailSalesLine), indexNum(RetailSalesLine, SalesLineIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateRetailSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates SalesLine field on the table <c>RetailSalesLine</c>.
    /// </summary>
    [UpgradeScriptDescriptionAttribute("@RET490383"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailSalesLine), false, true, true, true), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void populateRetailSalesLine()
    {
        RetailSalesLine    retailSalesLine;
        SalesLine          salesLine;

        new SkipAOSValidationPermission().assert();
        
        this.callInsertUpdateRelatedSkipMethods(retailSalesLine);

        update_recordset retailSalesLine
            setting
                SalesLine  = salesLine.RecId
        join InventTransId, RecId
            from salesLine
                where salesLine.InventTransId == retailSalesLine.InventTransId;

        // Delete any records that do not have SalesLine set on them. These are orphaned records that should have been cascade deleted when 
        // the parent <c>SalesLine</c> record was deleted.
        delete_from retailSalesLine
            where retailSalesLine.SalesLine == 0;

        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupSalesQuotationLineIdxInRetailSalesQuotationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index SalesQuotationLineIdx in the table <c>RetailSalesQuotationLine</c> to allow duplicate records.
    /// </summary>
    /// <remarks>
    /// The SalesQuotationLine field is used in the unique index SalesQuotationLineIdx on the table <c>RetailSalesQuotationLine</c>.
    /// Initially this field contains no value. So the index is set to allow duplicates before the field is updated
    /// with the new values.
    /// </remarks>
    [UpgradeScriptDescriptionAttribute("@RET490383"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StartScript),
    UpgradeScriptTableAttribute(tableStr(RetailSalesLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupSalesQuotationLineIdxInRetailSalesQuotationLine()
    {
        this.disableUniqueIndex(tableNum(RetailSalesQuotationLine), indexNum(RetailSalesQuotationLine, SalesQuotationLineIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateRetailSalesQuotationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the SalesQuotationLine field on the <c>RetailSalesQuotationLine</c> table.
    /// </summary>
    [UpgradeScriptDescriptionAttribute("@RET490383"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(RetailSalesLine), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void populateRetailSalesQuotationLine()
    {
        RetailSalesQuotationLine    retailSalesQuotationLine;
        SalesQuotationLine          salesQuotationLine;

        new SkipAOSValidationPermission().assert();
        
        this.callInsertUpdateRelatedSkipMethods(retailSalesQuotationLine);

        update_recordset retailSalesQuotationLine
            setting
                SalesQuotationLine  = salesQuotationLine.RecId
        join InventTransId, RecId
            from salesQuotationLine
                where salesQuotationLine.InventTransId == retailSalesQuotationLine.InventTransId;

        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupRetailCDXUploadSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>LocalUploadSessionIdIdx</c> in the table <c>RetailCDXUploadSession</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@REX4160373"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailCDXUploadSession), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupRetailCDXUploadSession()
    {
        this.disableUniqueIndex(tableNum(RetailCDXUploadSession), indexNum(RetailCDXUploadSession, LocalUploadSessionIdIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDupRetailConnScheduleJobMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ignores the index <c>ScheduleJobIdx</c> in the table <c>RetailConnScheduleJobMapping</c> to allow duplicate records until the upgrade is complete.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [UpgradeScriptDescriptionAttribute("@RET260723"),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::SharedScript),
    UpgradeScriptTableAttribute(tableStr(RetailConnScheduleJobMapping), false, true, true, false), Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void allowDupRetailConnScheduleJobMapping()
    {
        this.disableUniqueIndex(tableNum(RetailConnScheduleJobMapping), indexNum(RetailConnScheduleJobMapping, ScheduleJobIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailCDX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete all CDX log data and seed data.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@REX4160504"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Retail)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::PartitionScript),
    UpgradeScriptTableAttribute(tableStr(RetailCDXUploadSession), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXUploadSessionLog), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXDownloadSession), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXDownloadSessionDataStore), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXDataSyncRowVersion), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnChannelSchema), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnSchedulerJobTable), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnSchedulerSubjobTable), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnSchedulerJobLine), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnSchedulerSubjobFieldList), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnLocationDesignTable), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnLocationDesignTableField), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnScheduleJobMapping), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXScheduleDataGroup), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailConnSchedule), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXChangeTrackingSQL), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCDXChangeTrackingQueue), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCdxChannelSpecificTable), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCdxDataDistributionQuery), false, false, false, true),
    UpgradeScriptTableAttribute(tableStr(RetailCdxDataDistributionQueryFilter), false, false, false, true)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateRetailCDX()
    {
        // Clear logging data.
        RetailCDXUploadSession uploadSession;
        RetailCDXUploadSessionLog uploadSessionLog;
        RetailCDXDownloadSession downloadSession;
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;

        this.truncateTable(uploadSessionLog);
        this.truncateTable(uploadSession);
        this.truncateTable(downloadSessionDataStore);
        this.truncateTable(downloadSession);

        RetailCDXSeedDataBase::clearAllSeedData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableUniqueIndexMarkupAutoTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disable unique index on <c>MarkupAutoTable</c>.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@SYS55348"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Markup)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PreSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::SharedScript),
    UpgradeScriptTableAttribute(tableStr(MarkupAutoTable), false, false, false, true)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void disableUniqueIndexMarkupAutoTable()
    {
        this.disableUniqueIndex(tableNum(MarkupAutoTable), indexNum(MarkupAutoTable, MarkupIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMajorMarkupAutoTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete records with <c>RetailConcessionFee</c> column value as Yes 
    /// as the concession feature is not supported and we should not migrate 
    /// the data over.
    /// </summary>
    /// <remarks>Major upgrade version.</remarks>
    [
    UpgradeScriptDescriptionAttribute("@SYS124469"),
    UpgradeScriptConfigKeyAttribute(configurationKeyStr(Markup)),
    UpgradeScriptStageAttribute(ReleaseUpdateScriptStage::PostSync),
    UpgradeScriptTypeAttribute(ReleaseUpdateScriptType::StandardScript),
    UpgradeScriptTableAttribute(tableStr(MarkupAutoTable), false, false, false, true)
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateMajorMarkupAutoTable()
    {
        // Clear any records with RetailConcessionFee column value as Yes.
        MarkupAutoTable markupAutoTable;

        new SkipAOSValidationPermission().assert();

        delete_from markupAutoTable where markupAutoTable.RetailConcessionFee == NoYes::Yes;

        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableUniqueIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disables the specified unique index on the specified table.
    /// </summary>
    /// <remarks>
    ///  This local implementaiton is provided until this class can access the verion in <c>ReleaseUpdateDB_Extension</c>.
    /// </remarks>
    /// <param name = "_table">The table that owns the index to disable.</param>
    /// <param name = "_index">The index to disable.</param>
    private void disableUniqueIndex(TableId _table, IndexId _index)
    {
        ReleaseUpdateDBSyncManager manager = ReleaseUpdateDBSyncManager::Construct();
        DictTable table = new DictTable(_table);
        DictIndex idx = new DictIndex(_table, _index);
        manager.IgnoreIndexSynchronization(table, idx);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>