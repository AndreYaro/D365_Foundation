<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalCleanUp</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalCleanUp</c> class cleans up the ledger journals.
/// </summary>
class LedgerJournalCleanUp extends RunBaseBatch implements BatchRetryable
{
    NoYes           cleanUpDaily;                       // Daily
    NoYes           cleanUpAllocation;
    NoYes           cleanUpElimination;

    NoYes           cleanUpAssets;                      // Assets
    NoYes           cleanUpAssetBudget;                 // AssetBudget

    NoYes           cleanUpBankChequeReversal;
    NoYes           cleanUpBankDepositPaymCancel;

    NoYes           cleanUpProjExpense;                 // Cost

    NoYes           cleanUpCustPaym;                    // CustPayment

    NoYes           cleanUpBOEDraw;                     // CustBillOfExchangeDraw
    NoYes           cleanUpBOEProtest;                  // CustBillOfExchangeProtest
    NoYes           cleanUpBOERedraw;                   // CustBillOfExchangeRedraw
    NoYes           cleanUpBOERemittance;               // CustPaymRemittance
    NoYes           cleanUpBOESettle;                   // CustBillOfExchangeSettle

    NoYes           cleanUpVendPaym;                    // Payment

    NoYes           cleanUpPNDraw;                      // VendPromissoryNoteDraw
    NoYes           cleanUpPNRedraw;                    // VendPromissoryNoteRedraw
    NoYes           cleanUpPNRemittance;                // VendPaymRemittance
    NoYes           cleanUpPNSettle;                    // VendPromissoryNoteSettle

    NoYes           cleanUpVendInvoicePurchaseLedger;   // PurchaseLedger
    NoYes           cleanUpVendInvoiceApproval;         // Approval
    NoYes           cleanUpVendInvoiceRegister;         // VendInvoiceRegister

    private NoYes cleanUpCustVendNetting;               // Netting

    JournalPostedDateTime cleanUpFromDateTime;
    JournalPostedDateTime cleanUpToDateTime;

    DialogField     dialogCleanUpDaily;
    DialogField     dialogCleanUpAssets;
    DialogField     dialogCleanUpAllocation;
    DialogField     dialogCleanUpElimination;

    DialogField     dialogCleanUpAssetBudget;

    DialogField     dialogCleanUpBankChequeReversal;
    DialogField     dialogCleanUpBankDepositPaymCancel;

    DialogField     dialogCleanUpProjExpense;

    DialogField     dialogCleanUpCustPaym;

    DialogField     dialogCleanUpBOEDraw;
    DialogField     dialogCleanUpBOEProtest;
    DialogField     dialogCleanUpBOERedraw;
    DialogField     dialogCleanUpBOERemittance;
    DialogField     dialogCleanUpBOESettle;

    DialogField     dialogCleanUpVendPaym;

    DialogField     dialogCleanUpPNDraw;
    DialogField     dialogCleanUpPNRedraw;
    DialogField     dialogCleanUpPNRemittance;
    DialogField     dialogCleanUpPNSettle;

    DialogField     dialogCleanUpVendInvoicePL;
    DialogField     dialogCleanUpVendInvoiceApproval;
    DialogField     dialogCleanUpVendInvoiceRegister;

    DialogField dialogCleanUpFromDate;
    DialogField dialogCleanUpTodate;

    private DialogField dialogCleanUpCustVendNetting;

    #DEFINE.CurrentVersion(3)
    #LOCALMACRO.CurrentList
        cleanUpDaily,
        cleanUpAllocation,
        cleanUpElimination,
        cleanUpAssets,
        cleanUpAssetBudget,
        cleanUpBankChequeReversal,
        cleanUpBankDepositPaymCancel,
        cleanUpCustPaym,
        cleanUpBOEDraw,
        cleanUpBOEProtest,
        cleanUpBOERedraw,
        cleanUpBOERemittance,
        cleanUpBOESettle,
        cleanUpVendPaym,
        cleanUpPNDraw,
        cleanUpPNRedraw,
        cleanUpPNRemittance,
        cleanUpPNSettle,
        cleanUpVendInvoicePurchaseLedger,
        cleanUpVendInvoiceApproval,
        cleanUpVendInvoiceRegister,
        cleanUpProjExpense,
        cleanUpFromDateTime,
        cleanUpToDateTime
    #Endmacro

    #DEFINE.VersionV1(2)
    #LOCALMACRO.CurrentList_V1
        cleanUpDaily,
        cleanUpAllocation,
        cleanUpElimination,
        cleanUpAssets,
        cleanUpAssetBudget,
        cleanUpBankChequeReversal,
        cleanUpBankDepositPaymCancel,
        cleanUpCustPaym,
        cleanUpBOEDraw,
        cleanUpBOEProtest,
        cleanUpBOERedraw,
        cleanUpBOERemittance,
        cleanUpBOESettle,
        cleanUpVendPaym,
        cleanUpPNDraw,
        cleanUpPNRedraw,
        cleanUpPNRemittance,
        cleanUpPNSettle,
        cleanUpVendInvoicePurchaseLedger,
        cleanUpVendInvoiceApproval,
        cleanUpVendInvoiceRegister,
        cleanUpProjExpense
    #Endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides the delete actions and delete methods to increase performance.
    /// </summary>
    /// <remarks>
    ///    This method mimics the delete actions on the <c>LedgerJournalTrans</c> table and children of tables
    ///    that are defined as cascading deletes on the <c>LedgerJournalTrans</c> table. This method must
    ///    reproduce any delete methods on the tables that are defined as cascading deletes.
    /// </remarks>
    protected void deleteJournals()
    {
        boolean setBasedOpFlight = LedgerJournalCleanUpSetBasedDeleteFlight::instance().isEnabled();
        boolean skipBusinessEventsFlight = LedgerJournalCleanUpSkipBusinessEventsFlight::instance().isEnabled();
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTransAccrual ledgerJournalTransAccrual;
        LedgerJournalTransAccrualTrans ledgerJournalAccrualTrans;
        CustVendPaymJournalFee custVendPaymJournalFee;
        AssetBookTableDerivedJournal assetBookTableDerivedJournal;
        TaxWorkRegulation taxWorkRegulation;
        VendTransCashDisc vendTransCashDisc;
        LedgerJournalTrans_Project ledgerJournalTransProject;
        LedgerJournalTrans_Asset ledgerJournalTransAsset;
        VendInvoiceInfo vendInvoiceInfo;
        SpecTrans specTrans;
        TaxWithholdTrans taxWithholdTrans;
        CustVendCreditInvoicingTable custVendCreditInvoicingTable;
        DocuRef docuRef;
        CustTransCashDisc custTransCashDisc;
        TradeBLWIJournalPurposeCodes tradeBLWIJournalPurposeCodes;
        CustBillOfExchangeJour custBillOfExchangeJour;
        CustPaymSched custPaymSched;
        CustPaymSchedLine custPaymSchedLine;
        VendPromissoryNoteJour vendPromissoryNoteJour;
        LedgerJournalTransVoucherTemplate ledgerJournalTransVoucherTemplate;

        // Override cascading deletes and delete methods.
        ledgerJournalTable.skipDataMethods(true);
        ledgerJournalTable.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            ledgerJournalTable.skipDatabaseLog(true);
            ledgerJournalTable.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                ledgerJournalTable.skipBusinessEvents(true);
            }
        }

        delete_from ledgerJournalTable
            where ledgerJournalTable.Posted == NoYes::Yes
                && ((ledgerJournalTable.JournalType == LedgerJournalType::Daily && cleanUpDaily)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::Allocation && cleanUpAllocation)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::Elimination && cleanUpElimination)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::Assets && cleanUpAssets)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::AssetBudgets && cleanUpAssetBudget)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::BankChequeReversal && cleanUpBankChequeReversal)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::BankDepositPaymCancel && cleanUpBankDepositPaymCancel)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::Cost && cleanUpProjExpense)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustPayment && cleanUpCustPaym)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeDraw && cleanUpBOEDraw)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeProtest && cleanUpBOEProtest)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeRedraw && cleanUpBOERedraw)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance && cleanUpBOERemittance)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeSettle && cleanUpBOESettle)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::Payment && cleanUpVendPaym)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::VendPromissoryNoteDraw && cleanUpPNDraw)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::VendPromissoryNoteRedraw && cleanUpPNRedraw)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::VendPaymRemittance && cleanUpPNRemittance)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::VendPromissoryNoteSettle && cleanUpPNSettle)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger && cleanUpVendInvoicePurchaseLedger)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::Approval && cleanUpVendInvoiceApproval)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister && cleanUpVendInvoiceRegister)
                    || (ledgerJournalTable.JournalType == LedgerJournalType::CustVendNetting && cleanUpCustVendNetting))
                && ledgerJournalTable.PostedDateTime >= cleanUpFromDateTime && ledgerJournalTable.PostedDateTime <= cleanUpToDateTime
            notexists join ledgerJournalTransVoucherTemplate
                where ledgerJournalTable.JournalNum == ledgerJournalTransVoucherTemplate.JournalNum;

        // Override cascading deletes and delete methods.
        ledgerJournalTrans.skipDataMethods(true);
        ledgerJournalTrans.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            ledgerJournalTrans.skipDatabaseLog(true);
            ledgerJournalTrans.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                ledgerJournalTrans.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing ledger journal header.
        delete_from ledgerJournalTrans
            notexists join ledgerJournalTable
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

        // Override cascading deletes and delete methods.
        ledgerJournalTransAccrual.skipDataMethods(true);
        ledgerJournalTransAccrual.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            ledgerJournalTransAccrual.skipDatabaseLog(true);
            ledgerJournalTransAccrual.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                ledgerJournalTransAccrual.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from ledgerJournalTransAccrual
            notexists join ledgerJournalTrans
            where ledgerJournalTransAccrual.RefTableid  == ledgerJournalTrans.TableId
               && ledgerJournalTransAccrual.RefRecid    == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        ledgerJournalAccrualTrans.skipDataMethods(true);
        ledgerJournalAccrualTrans.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            ledgerJournalAccrualTrans.skipDatabaseLog(true);
            ledgerJournalAccrualTrans.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                ledgerJournalAccrualTrans.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing Trans Accrual records.
        delete_from ledgerJournalAccrualTrans
            notexists join ledgerJournalTransAccrual
            where ledgerJournalAccrualTrans.RefTableid  == ledgerJournalTransAccrual.RefTableid
               && ledgerJournalAccrualTrans.RefRecid    == ledgerJournalTransAccrual.RefRecid;

        // Override cascading deletes and delete methods.
        custVendPaymJournalFee.skipDataMethods(true);
        custVendPaymJournalFee.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            custVendPaymJournalFee.skipDatabaseLog(true);
            custVendPaymJournalFee.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                custVendPaymJournalFee.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from custVendPaymJournalFee
            notexists join ledgerJournalTrans
            where custVendPaymJournalFee.RefRecId == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        assetBookTableDerivedJournal.skipDataMethods(true);
        assetBookTableDerivedJournal.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            assetBookTableDerivedJournal.skipDatabaseLog(true);
            assetBookTableDerivedJournal.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                assetBookTableDerivedJournal.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from assetBookTableDerivedJournal
            notexists join ledgerJournalTrans
            where assetBookTableDerivedJournal.RefRecId == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        taxWorkRegulation.skipDataMethods(true);
        taxWorkRegulation.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            taxWorkRegulation.skipDatabaseLog(true);
            taxWorkRegulation.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                taxWorkRegulation.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from taxWorkRegulation
            where taxWorkRegulation.HeadingTableId  == ledgerJournalTrans.TableId
            notexists join ledgerJournalTrans
            where taxWorkRegulation.HeadingRecId == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        vendTransCashDisc.skipDataMethods(true);
        vendTransCashDisc.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            vendTransCashDisc.skipDatabaseLog(true);
            vendTransCashDisc.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                vendTransCashDisc.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from vendTransCashDisc
            where vendTransCashDisc.RefTableId  == ledgerJournalTrans.TableId
            notexists join ledgerJournalTrans
            where vendTransCashDisc.RefRecId    == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        ledgerJournalTransProject.skipDataMethods(true);
        ledgerJournalTransProject.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            ledgerJournalTransProject.skipDatabaseLog(true);
            ledgerJournalTransProject.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                ledgerJournalTransProject.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from ledgerJournalTransProject
            notexists join ledgerJournalTrans
            where ledgerJournalTransProject.RefRecId    == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        ledgerJournalTransAsset.skipDataMethods(true);
        ledgerJournalTransAsset.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            ledgerJournalTransAsset.skipDatabaseLog(true);
            ledgerJournalTransAsset.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                ledgerJournalTransAsset.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from ledgerJournalTransAsset
            notexists join ledgerJournalTrans
            where ledgerJournalTransAsset.RefRecId    == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        vendInvoiceInfo.skipDataMethods(true);
        vendInvoiceInfo.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            vendInvoiceInfo.skipDatabaseLog(true);
            vendInvoiceInfo.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                vendInvoiceInfo.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from vendInvoiceInfo
            where vendInvoiceInfo.RefTableId  == ledgerJournalTrans.TableId
            notexists join ledgerJournalTrans
            where vendInvoiceInfo.RefRecId    == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        specTrans.skipDataMethods(true);
        specTrans.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            specTrans.skipDatabaseLog(true);
            specTrans.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                specTrans.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from specTrans
            where specTrans.SpecTableId  == ledgerJournalTrans.TableId
                && specTrans.SpecCompany == curext()
            notexists join ledgerJournalTrans
            where specTrans.SpecRecId    == ledgerJournalTrans.RecId
                && specTrans.SpecCompany == ledgerJournalTrans.DataAreaId;

        // Override cascading deletes and delete methods.
        custVendCreditInvoicingTable.skipDataMethods(true);
        custVendCreditInvoicingTable.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            custVendCreditInvoicingTable.skipDatabaseLog(true);
            custVendCreditInvoicingTable.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                custVendCreditInvoicingTable.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existsing ledger journal lines.
        delete_from custVendCreditInvoicingTable
            where custVendCreditInvoicingTable.RefTableId  == ledgerJournalTrans.TableId
            notexists join ledgerJournalTrans
            where custVendCreditInvoicingTable.RefRecId    == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        docuRef.skipDataMethods(true);
        docuRef.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            docuRef.skipDatabaseLog(true);
            docuRef.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                docuRef.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing ledger journal lines.
        delete_from docuRef
            where
                docuRef.RefTableId == ledgerJournalTrans.TableId &&
                docuRef.RefCompanyId == curext()
            notexists join ledgerJournalTrans
            where
                docuRef.RefRecId == ledgerJournalTrans.RecId &&
                docuRef.RefCompanyId == ledgerJournalTrans.DataAreaId;

        // Override cascading deletes and delete methods.
        custTransCashDisc.skipDataMethods(true);
        custTransCashDisc.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            custTransCashDisc.skipDatabaseLog(true);
            custTransCashDisc.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                custTransCashDisc.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing ledger journal lines.
        delete_from custTransCashDisc
            where
                custTransCashDisc.RefTableId == ledgerJournalTrans.TableId
            notexists join ledgerJournalTrans
            where
                custTransCashDisc.RefRecId == ledgerJournalTrans.RecId;

        // Override cascading deletes and delete methods.
        tradeBLWIJournalPurposeCodes.skipDataMethods(true);
        tradeBLWIJournalPurposeCodes.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            tradeBLWIJournalPurposeCodes.skipDatabaseLog(true);
            tradeBLWIJournalPurposeCodes.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                tradeBLWIJournalPurposeCodes.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing ledger journal lines.
        delete_from tradeBLWIJournalPurposeCodes
            notexists join ledgerJournalTrans
            where
                tradeBLWIJournalPurposeCodes.RefRecId == ledgerJournalTrans.RecId &&
                (tradeBLWIJournalPurposeCodes.TypeOfForm == TradeBLWITypeOfForm::LedgerJournalTrans ||
                tradeBLWIJournalPurposeCodes.TypeOfForm == TradeBLWITypeOfForm::InvoiceRegister);

        // Override cascading deletes and delete methods.
        custBillOfExchangeJour.skipDataMethods(true);
        custBillOfExchangeJour.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            custBillOfExchangeJour.skipDatabaseLog(true);
            custBillOfExchangeJour.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                custBillOfExchangeJour.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing ledger journal lines.
        delete_from custBillOfExchangeJour
            where
                custBillOfExchangeJour.Status == CustVendNegInstStatus::None
            notexists join ledgerJournalTrans
            where
                custBillOfExchangeJour.BillOfExchangeId == ledgerJournalTrans.NegInstId;

        // Override cascading deletes and delete methods.
        custPaymSched.skipDataMethods(true);
        custPaymSched.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            custPaymSched.skipDatabaseLog(true);
            custPaymSched.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                custPaymSched.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing CustBillOfExchangeJour.
        delete_from custPaymSched
            notexists join custBillOfExchangeJour
            where
                custPaymSched.ExtTableId == custBillOfExchangeJour.TableId &&
                custPaymSched.ExtRecId == custBillOfExchangeJour.RecId;

        // Override cascading deletes and delete methods.
        custPaymSchedLine.skipDataMethods(true);
        custPaymSchedLine.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            custPaymSchedLine.skipDatabaseLog(true);
            custPaymSchedLine.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                custPaymSchedLine.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing CustPaymSched.
        delete_from custPaymSchedLine
            notexists join custPaymSched
            where
                custPaymSchedLine.ParentRecID == custPaymSched.RecId;

        // Override cascading deletes and delete methods.
        vendPromissoryNoteJour.skipDataMethods(true);
        vendPromissoryNoteJour.skipDeleteActions(true);

        if (setBasedOpFlight)
        {
            vendPromissoryNoteJour.skipDatabaseLog(true);
            vendPromissoryNoteJour.skipEvents(true);

            if (skipBusinessEventsFlight)
            {
                vendPromissoryNoteJour.skipBusinessEvents(true);
            }
        }

        // Delete records mapped to non-existing ledger journal lines.
        delete_from vendPromissoryNoteJour
            where
                vendPromissoryNoteJour.Status == CustVendNegInstStatus::None
            notexists join ledgerJournalTrans
            where
                vendPromissoryNoteJour.PromissoryNoteId == ledgerJournalTrans.NegInstId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be built by using the <c>Dialog</c> class or by using a class that is created in the
    ///    Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        #define.columns(2)
        #define.frameType(6)

        DialogRunbase       dialog = super();

        DialogTabPage       dialogTabPageGeneralLedger;
        DialogTabPage       dialogTabPageCust;
        DialogTabPage       dialogTabpageVend;

        DialogGroup         dialogGroupFixedAssets;
        DialogGroup         dialogGroupBOE;
        DialogGroup         dialogGroupPN;
        DialogGroup         dialogGroupVendInvoice;

        DialogGroup         dialogLogGroupGL;
        DialogGroup         dialogLogGroupCust;
        DialogGroup         dialogLogGroupVend;

        dialog.formBuildDesign().windowResize(0);

        // Date range group
        DialogGroup dialogGroupDate = dialog.addGroup("@SYS41297");
        dialogGroupDate.columns(#columns);
        dialogGroupDate.frameType(#frameType);

        dialogCleanUpFromDate = Dialog.addFieldValue(extendedtypestr(JournalPostedDateTime), cleanUpFromDateTime);
        dialogCleanUpFromDate.label("@GeneralLedger:GeneralJournalCleanUpFromDate");

        dialogCleanUpToDate = Dialog.addFieldValue(extendedtypestr(JournalPostedDateTime), cleanUpToDateTime);
        dialogCleanUpToDate.label("@GeneralLedger:GeneralJournalCleanUpToDate");

        // General ledger tab
        dialogTabPageGeneralLedger = dialog.addTabPage("@SYS24097");
        dialogTabPageGeneralLedger.configurationKey(configurationkeynum('LedgerBasic'));

        // Clean up... group
        dialogLogGroupGL = dialog.addGroup("@SYS74966");
        dialogLogGroupGL.columns(#columns);
        dialogLogGroupGL.frameType(#frameType);

        // General leger group
        dialog.addGroup("@SYS24097", dialogLogGroupGL);
        dialogCleanUpDaily = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpDaily, "@SYS25908");

        dialogCleanUpAllocation = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpAllocation);
        this.setDialogFieldProperties(dialogCleanUpAllocation, LedgerJournalType::Allocation);

        dialogCleanUpElimination = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpElimination);
        this.setDialogFieldProperties(dialogCleanUpElimination, LedgerJournalType::Elimination);

        // Fixed asset group
        dialogGroupFixedAssets = dialog.addGroup("@SYS12578", dialogLogGroupGL);

        dialogCleanUpAssets = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpAssets);
        this.setDialogFieldProperties(dialogCleanUpAssets, LedgerJournalType::Assets);

        dialogCleanUpAssetBudget    = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpAssetBudget);
        this.setDialogFieldProperties(dialogCleanUpAssetBudget, LedgerJournalType::AssetBudgets);

        // Bank group
        dialogGroupFixedAssets = dialog.addGroup("@SYS7439", dialogLogGroupGL);

        dialogCleanUpBankChequeReversal = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBankChequeReversal);
        this.setDialogFieldProperties(dialogCleanUpBankChequeReversal, LedgerJournalType::BankChequeReversal);

        dialogCleanUpBankDepositPaymCancel = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBankDepositPaymCancel);
        this.setDialogFieldProperties(dialogCleanUpBankDepositPaymCancel, LedgerJournalType::BankDepositPaymCancel);

        // Payment and cash group
        if (CustVendNettingJournalCleanUpFlight::instance().isEnabled())
        {
            dialog.addGroup("@CashManagement:PaymentAndCashGroup", dialogLogGroupGL);
            dialogCleanUpCustVendNetting = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpCustVendNetting);
            this.setDialogFieldProperties(dialogCleanUpCustVendNetting, LedgerJournalType::CustVendNetting);
        }

        // Project group
        dialog.addGroup("@SYS4534", dialogLogGroupGL);

        dialogCleanUpProjExpense = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpProjExpense);
        this.setDialogFieldProperties(dialogCleanUpProjExpense, LedgerJournalType::Cost);

        // Accounts receivable tab
        dialogTabPageCust = dialog.addTabPage("@SYS25196");
        dialogLogGroupCust = dialog.addGroup("@SYS74966");
        dialogLogGroupCust.columns(#columns);
        dialogLogGroupCust.frameType(#frameType);

        dialog.addGroup("@SYS828", dialogLogGroupCust);
        dialogCleanUpCustPaym   = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpCustPaym);
        this.setDialogFieldProperties(dialogCleanUpCustPaym, LedgerJournalType::CustPayment);

        dialogGroupBOE = dialog.addGroup("@SYS69795", dialogLogGroupCust);
        dialogCleanUpBOEDraw        = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBOEDraw);
        this.setDialogFieldProperties(dialogCleanUpBOEDraw, LedgerJournalType::CustBillOfExchangeDraw);

        dialogCleanUpBOEProtest     = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBOEProtest);
        this.setDialogFieldProperties(dialogCleanUpBOEProtest, LedgerJournalType::CustBillOfExchangeProtest);

        dialogCleanUpBOERedraw      = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBOERedraw);
        this.setDialogFieldProperties(dialogCleanUpBOERedraw, LedgerJournalType::CustBillOfExchangeRedraw);

        dialogCleanUpBOERemittance  = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBOERemittance);
        this.setDialogFieldProperties(dialogCleanUpBOERemittance, LedgerJournalType::CustPaymRemittance);

        dialogCleanUpBOESettle      = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpBOESettle);
        this.setDialogFieldProperties(dialogCleanUpBOESettle, LedgerJournalType::CustBillOfExchangeSettle);

        // Accounts payable tab
        dialogTabpageVend = dialog.addTabPage("@SYS25194");
        dialogLogGroupVend = dialog.addGroup("@SYS74966");
        dialogLogGroupVend.columns(2);
        dialogLogGroupVend.frameType(#frameType);
        dialog.addGroup("@SYS828", dialogLogGroupVend);

        dialogCleanUpVendPaym = dialog.addFieldValue(enumstr(NoYes), cleanUpVendPaym);
        this.setDialogFieldProperties(dialogCleanUpVendPaym, LedgerJournalType::Payment);

        dialogGroupPN = dialog.addGroup("@SYS71440", dialogLogGroupVend);
        dialogCleanUpPNDraw         = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpPNDraw);
        this.setDialogFieldProperties(dialogCleanUpPNDraw, LedgerJournalType::VendPromissoryNoteDraw);

        dialogCleanUpPNRedraw       = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpPNRedraw);
        this.setDialogFieldProperties(dialogCleanUpPNRedraw, LedgerJournalType::VendPromissoryNoteRedraw);

        dialogCleanUpPNRemittance   = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpPNRemittance);
        this.setDialogFieldProperties(dialogCleanUpPNRemittance, LedgerJournalType::VendPaymRemittance);

        dialogCleanUpPNSettle       = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpPNSettle);
        this.setDialogFieldProperties(dialogCleanUpPNSettle, LedgerJournalType::VendPromissoryNoteSettle);

        dialogCleanUpVendInvoicePL = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpVendInvoicePurchaseLedger);
        this.setDialogFieldProperties(dialogCleanUpVendInvoicePL, LedgerJournalType::PurchaseLedger);

        dialogCleanUpVendInvoiceApproval = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpVendInvoiceApproval);
        this.setDialogFieldProperties(dialogCleanUpVendInvoiceApproval, LedgerJournalType::Approval);

        dialogCleanUpVendInvoiceRegister = dialog.addFieldValue(extendedtypestr(NoYesId), cleanUpVendInvoiceRegister);
        this.setDialogFieldProperties(dialogCleanUpVendInvoiceRegister, LedgerJournalType::VendInvoiceRegister, "@SYS15721");

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        cleanUpDaily                        = dialogCleanUpDaily.value();
        cleanUpAllocation                   = dialogCleanUpAllocation.value();
        cleanUpElimination                  = dialogCleanUpElimination.value();

        cleanUpAssets                       = dialogCleanUpAssets.value();
        cleanUpAssetBudget                  = dialogCleanUpAssetBudget.value();

        cleanUpBankChequeReversal           = dialogCleanUpBankChequeReversal.value();
        cleanUpBankDepositPaymCancel        = dialogCleanUpBankDepositPaymCancel.value();

        cleanUpProjExpense                  = dialogCleanUpProjExpense.value();

        cleanUpCustPaym                     = dialogCleanUpCustPaym.value();

        cleanUpBOEDraw                      = dialogCleanUpBOEDraw.value();
        cleanUpBOEProtest                   = dialogCleanUpBOEProtest.value();
        cleanUpBOERedraw                    = dialogCleanUpBOERedraw.value();
        cleanUpBOERemittance                = dialogCleanUpBOERemittance.value();
        cleanUpBOESettle                    = dialogCleanUpBOESettle.value();

        cleanUpVendPaym                     = dialogCleanUpVendPaym.value();

        cleanUpPNDraw                       = dialogCleanUpPNDraw.value();
        cleanUpPNRedraw                     = dialogCleanUpPNRedraw.value();
        cleanUpPNRemittance                 = dialogCleanUpPNRemittance.value();
        cleanUpPNSettle                     = dialogCleanUpPNSettle.value();

        cleanUpVendInvoicePurchaseLedger    = dialogCleanUpVendInvoicePL.value();
        cleanUpVendInvoiceApproval          = dialogCleanUpVendInvoiceApproval.value();
        cleanUpVendInvoiceRegister          = dialogCleanUpVendInvoiceRegister.value();

        cleanUpFromDateTime = dialogCleanUpFromDate.value();
        cleanUpToDateTime = dialogCleanUpTodate.value();

        if (CustVendNettingJournalCleanUpFlight::instance().isEnabled())
        {
            cleanUpCustVendNetting = dialogCleanUpCustVendNetting.value();
        }

        boolean isValid = true;

        if (cleanUpFromDateTime == DateTimeUtil::minValue() || cleanUpToDateTime == DateTimeUtil::minValue())
        {
            isValid = checkFailed("@GeneralLedger:GeneralJournalCleanupDateCriteriaRequired");

            return isValid;
        }

        if (cleanUpFromDateTime > cleanUpToDateTime)
        {
            isValid = checkFailed(strFmt("@SYS55013", cleanUpFromDateTime, cleanUpToDateTime));
            
            return isValid;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, #CurrentList];

        if (CustVendNettingJournalCleanUpFlight::instance().isEnabled())
        {
            packed = SysPackExtensions::appendVariableToPack(packed, this.name(), varStr(cleanUpCustVendNetting), cleanUpCustVendNetting);
        }

        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        #OCCRetryCount
        if (! this.validate())
        {
            throw error("@SYS18447");
        }

        try
        {
            ttsbegin;

            this.deleteJournals();

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend this class must override the <c>runsImpersonated</c> method and return
    ///    false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDialogFieldProperties</Name>
				<Source><![CDATA[
    private void setDialogFieldProperties(
        DialogField         _dialogField,
        LedgerJournalType   _ledgerJournalType,
        FieldLabel          _fieldLabel = '')
    {
        DictEnum    dictEnum = new DictEnum(enumnum(LedgerJournalType));

        if (_fieldLabel != '')
        {
            _dialogField.label(_fieldLabel);
        }
        else
        {
            _dialogField.label(dictEnum.value2Label(enum2int(_ledgerJournalType)));
        }

        _dialogField.configurationKey(dictEnum.value2ConfigurationKey(enum2int(_ledgerJournalType)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList] = _packedClass;
                break;

            case #VersionV1 :
                [version, #CurrentList_V1] = _packedClass;
                break;

            default :
                return false;
        }

        if (CustVendNettingJournalCleanUpFlight::instance().isEnabled())
        {
            cleanUpCustVendNetting = SysPackExtensions::extractPackedVariable(_packedClass, this.name(), varStr(cleanUpCustVendNetting));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static public ClassDescription description()
    {
        return "@SYS74933";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        LedgerJournalCleanUp ledgerJournalCleanUp = new LedgerJournalCleanUp();

        if (ledgerJournalCleanUp.prompt())
        {
            ledgerJournalCleanUp.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>