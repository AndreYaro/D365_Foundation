<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransUpdateLedger</Name>
	<SourceCode>
		<Declaration><![CDATA[
class LedgerJournalTransUpdateLedger extends LedgerJournalTransUpdate
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    boolean  check(LedgerJournalTrans           _ledgerJournalTrans,
                   boolean                      _checkNoSettlement = true,
                   LedgerVoucher                _ledgerVoucher = null,
                   LedgerPostingMessageLog      _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;

        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval &&
            !_ledgerJournalTrans.Approved)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS18394", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap))) && ok;
            }
            else
            {
                ok = checkFailed(strFmt("@SYS18394", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap))) && ok;
            }
        }

        ok = super(_ledgerJournalTrans, _checkNoSettlement, _ledgerVoucher, _ledgerPostingMessageCollection) && ok;

        if (ok)
        {
            ok = this.checkDocumentDate(_ledgerJournalTrans);
        }

        ok = this.checkTaxCombinationInTaxGroupCompany(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;

        ok = this.checkDuplicateInvoice(_ledgerJournalTrans) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDuplicateInvoice</Name>
				<Source><![CDATA[
    private boolean checkDuplicateInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ok = true;

        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval)
        {
            VendTrans vendTransCheck = VendTrans::find(_ledgerJournalTrans.VendTransId);
            VendTable vendTableCheck = VendTable::find(vendTransCheck.AccountNum);

            if (vendTransCheck.Invoice != _ledgerJournalTrans.Invoice)
            {
                ok = vendTableCheck.checkInvoice(_ledgerJournalTrans.Invoice, _ledgerJournalTrans.TransDate);
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDocumentDate</Name>
				<Source><![CDATA[
    boolean checkDocumentDate(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean             ok  = true;
        LedgerJournalTable  ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        if ((ledgerJournalTable.JournalType == LedgerJournalType::Daily) &&
            (ledgerJournalTable.ledgerJournalName().TaxBookTypeJournal == TaxBookTypeJournal::Purchase))
        {
            ok = VendParameters::checkDocumentDate(_ledgerJournalTrans.TransDate, _ledgerJournalTrans.DocumentDate);

            if (!ok && _ledgerPostingMessageCollection)
            {
                _ledgerPostingMessageCollection.addLastMessage();
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymStatus</Name>
				<Source><![CDATA[
    public boolean checkPaymStatus(
        LedgerJournalType _ledgerJournalType,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean paymentStatusValid = true;

        // We will verify the payment status when working with a payment journal.
        if (_ledgerJournalTrans.PaymMode && _ledgerJournalType == LedgerJournalType::Payment)
        {
            // We do not verify payment status for payment fees against ledger accounts.
            if (_ledgerJournalTrans.TransactionType != LedgerTransType::Fee)
            {
                // Check if the method of payment exists in the company of the account being validated (either primary or offset)
                CustVendPaymModeTable custVendPaymModeTable = CustVendPaymModeTable::findModule(ModuleCustVend::Vend, _ledgerJournalTrans.PaymMode);

                if (custVendPaymModeTable)
                {
                    paymentStatusValid = CustVendPaym::checkPaymStatus(ModuleCustVend::Vend, _ledgerJournalTrans.PaymMode, _ledgerJournalTrans.PaymentStatus);
                    
                    if (!paymentStatusValid)
                    {
                        CustVendPaymStatus expectedPaymStatus = custVendPaymModeTable.PaymStatus;

                        if (_ledgerPostingMessageCollection)
                        {
                            _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                            _ledgerJournalTrans.PaymentStatus,
                            expectedPaymStatus));
                        }
                        else
                        {
                            checkFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                            _ledgerJournalTrans.PaymentStatus,
                            expectedPaymStatus));
                        }
                    }
                }
                else
                {
                    // Two messages are used to describe the error and the associated company.
                    // This was found too close to RTM to add a new message.
                    if (_ledgerPostingMessageCollection)
                    {
                        _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS110249", curext()));
                        paymentStatusValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS16654", _ledgerJournalTrans.PaymMode));
                    }
                    else
                    {
                        checkFailed(strFmt("@SYS110249", curext()));
                        paymentStatusValid = checkFailed(strFmt("@SYS16654", _ledgerJournalTrans.PaymMode));
                    }
                }
            }
        }

        return paymentStatusValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPerformMainAccountTypeTaxValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the journal line should perform main account tax posting type validation if no tax code has been specified
    /// on the journal line, and the main account posting type is of a tax type.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> table record to be validated.</param>
    /// <returns>true if the main account tax posting type validation should be performed; otherwise, false.</returns>
    [Wrappable]
    protected final boolean shouldPerformMainAccountTypeTaxValidation(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.TransactionType != LedgerTransType::Allocation &&
            _ledgerJournalTrans.TransactionType != LedgerTransType::Elimination);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWhenPost</Name>
				<Source><![CDATA[
    boolean checkWhenPost(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans          _originalLedgerJournalTrans,
        boolean                     _checkNoSettlement = true,
        LedgerPostingMessageLog     _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;

        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        if (this.shouldPerformMainAccountTypeTaxValidation(_ledgerJournalTrans))
        {
            ok = _ledgerJournalTrans.checkVATPosting();
        }

        ok = this.checkTaxCombinationInTaxGroupCompany(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;

        if (ledgerJournalTable.JournalType == LedgerJournalType::Approval &&
            !_ledgerJournalTrans.Approved)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(
                    strFmt("@SYS18394", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap))) && ok;
            }
            else
            {
                ok = checkFailed(strFmt("@SYS18394", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap))) && ok;
            }
        }

        ok = this.checkPaymStatus(ledgerJournalTable.JournalType, _ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        ok = this.furtherPostingType(_ledgerJournalTrans, true) && ok;
        ok = super(_ledgerJournalTrans, _originalLedgerJournalTrans, _checkNoSettlement, _ledgerPostingMessageCollection) && ok;

        if (ok)
        {
            ok = this.checkDocumentDate(_ledgerJournalTrans);
        }

        ok = this.checkDuplicateInvoice(_ledgerJournalTrans) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareMainAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if the two records from the <c>DimensionAttributeValueCombination</c> table have the same main account.
    /// </summary>
    /// <param name="_dimensionAttributeValueCombination">
    ///    The <c>DimensionAttributeValueCombination</c>.
    /// </param>
    /// <param name="_dimensionAttributeValueCombinationToCompare">
    ///    The <c>DimensionAttributeValueCombination</c> to be compared.
    /// </param>
    /// <returns>
    ///   true if the two <c>DimensionAttributeValueCombination</c> record ID's passed in have the same <c>MainAccountId</c> value; otherwise, false.
    /// </returns>
    private boolean compareMainAccounts(recId _dimensionAttributeValueCombination, recId _dimensionAttributeValueCombinationToCompare)
    {
        MainAccountRecId mainAccountRecId;
        MainAccountRecId mainAccountRecIdToCompare;

        mainAccountRecId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_dimensionAttributeValueCombination);
        mainAccountRecIdToCompare = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_dimensionAttributeValueCombinationToCompare);

        return mainAccountRecId == mainAccountRecIdToCompare;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxLinkForTaxTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>TaxTransGeneralJournalAccountEntry</c> table if the transaction is a tax transfer.
    /// </summary>
    /// <param name="_originalLedgerJournalTrans">
    /// The original unmodified <c>LedgerJournalTrans</c> record that is posted.
    /// </param>
    /// <param name="_postingTransaction">
    /// The <c>LedgerVoucherTransObject</c> object for the journal line.
    /// </param>
    [Wrappable(true)]
    protected final void createTaxLinkForTaxTransfer(LedgerJournalTrans _originalLedgerJournalTrans, LedgerVoucherTransObject _postingTransaction)
    {
        TaxTrans                    taxTrans;

        if ((_originalLedgerJournalTrans.TaxCode
            && !isOffset
            && _originalLedgerJournalTrans.AccountType == LedgerJournalACType::Ledger
            && TaxLedgerAccountGroup::ledgerDimensionExistInGroup(TaxTable::find(_originalLedgerJournalTrans.TaxCode).TaxAccountGroup, _originalLedgerJournalTrans.LedgerDimension))
            ||
            (_originalLedgerJournalTrans.TaxCode
            && isOffset
            && _originalLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger
            && TaxLedgerAccountGroup::ledgerDimensionExistInGroup(TaxTable::find(_originalLedgerJournalTrans.TaxCode).TaxAccountGroup, _originalLedgerJournalTrans.OffsetLedgerDimension)))
        {
            if (_postingTransaction.parmLedgerPostingType() == LedgerPostingType::InterCompany)
            {
                return;
            }
            // in a tax transfer scenario there will only be 1 TaxTrans record for this line.
            // And the line amount is the tax amount.
            select firstonly RecId, TaxCode from taxTrans
            where taxTrans.SourceTableId == _originalLedgerJournalTrans.TableId &&
                    taxTrans.SourceRecId == _originalLedgerJournalTrans.RecId;

            if (taxTrans.RecId)
            {
                // The line amount is the tax amount so the tax relationship is to the posting of the line amount.
                _postingTransaction.addTaxTransRelationship(taxTrans.RecId,
                                                            TaxTransRelationshipType::Tax,
                                                            curext(),
                                                            _postingTransaction.parmAccountingCurrencyAmount(),
                                                            _postingTransaction.parmTransactionCurrencyAmount());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>furtherPostingType</Name>
				<Source><![CDATA[
    boolean furtherPostingType(LedgerJournalTrans _ledgerJournalTrans, boolean _update = false)
    {
        return LedgerTransFurtherPosting::settle(_ledgerJournalTrans, _update);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount ledgerDimension(LedgerJournalTrans _journalTrans)
    {
        return _journalTrans.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get tax amount calculated by GTE
    /// </summary>
    /// <param name = "_ledgerJournalTrans">the journal line for which tax is calculated</param>
    /// <returns>tax amount calculated by GTE</returns>
    protected TaxAmount getTaxAmountGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GTE>
        TaxAmount           taxAmountGTE;
        ITaxableDocument    taxableDocument;
        ITaxDocument        taxDocumentObject;
        LedgerJournalTrans  ledgerJournalTransGTE;
        ITaxDocumentLine    taxDocumentLineObject;
          
        if (ledgerJournalTransGTE.ledgerJournalTable().JournalType   != LedgerJournalType::Approval)
        {
            ledgerJournalTransGTE = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, false);
            if (ledgerJournalTransGTE.parmOffsetLedgerDimension() == 0 )
            {
                taxableDocument = TaxableDocumentObject::construct(
                    TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans));
                
                taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
                if (taxDocumentObject)
                {
                    taxDocumentLineObject = taxDocumentObject.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                    
                    if (taxDocumentLineObject && taxDocumentLineObject.priceInclTax())
                    {
                        taxAmountGTE = taxDocumentLineObject.getInclTax().amountTransactionCurrency();

                        if (LedgerJournalTrans::isCustomerInvoice(_ledgerJournalTrans)
                            && _ledgerJournalTrans.OffsetLedgerDimension == 0)
                        {
                            taxAmountGTE = -taxAmountGTE;
                        }
                    }
                }
            }
        }

        return taxAmountGTE;
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    void updateNow(LedgerVoucher        _ledgerVoucher,
                   LedgerPostingType    _posting,
                   LedgerJournalTrans   _ledgerJournalTrans,
                   LedgerJournalTrans   _originalLedgerJournalTrans,
                   boolean              _interCompany = false,
                   boolean              _reversalsMayExist = true,
                   boolean              _isDueToDueFromAccount =  false)
    {
        AssetTrans                  assetTrans;
        boolean                     markBridging;
        CustPaymModeTable           custPaymModeTableFieldList;
        LedgerAccrualTrans          ledgerAccrualTrans;
        LedgerAccount               sumAccount;
        LedgerJournalTrans_Asset    ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        TaxAmount                   taxAmount;
        VendPaymModeTable           vendPaymModeTableFieldList;
        LedgerPostingController     ledgerPostingController;
        LedgerVoucherObject         postingReference;
        LedgerInterCompany          ledgerInterCompany;
        LedgerJournalTable          ledgerJournalTable;

        //<GIN>
        CurrencyExchangeHelper            exchangeRateHelperLoc;
        boolean                           priceNotInclTaxIN;
        TaxAmountCur                      withholdTaxAmountCur;
        // </GIN>
        CurrencyExchangeHelper            exchangeRateHelper;
        JournalizingDefinitionManagerBank journalizingDefinitionManagerBank;
        List                              systemGeneratedEntriesList;
        ListEnumerator                    systemGeneratedEntriesListEnumerator;
        JournalizingDefinitionEntry       JournalizingDefinitionEntry;
        VendInvoiceJour                   vendInvoiceJour;
        VendTrans                         vendTrans;
        LedgerVoucherTransObject          ledgerVoucherTransObject;
        boolean                           isDueToDueFromAccountLocal = _isDueToDueFromAccount;
        LedgerJournalTrans_Customs_IT     customsTrans_IT;

        taxAmount = 0;

        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);

        // If asset journal line is not initialized from _ledgerJournalTrans for offset type, this will initialize from original journal line buffer.
        if (!ledgerJournalTrans_Asset && isOffset)
        {
            ledgerJournalTrans_Asset = _ledgerJournalTrans.orig().findLedgerJournalTransAssetSibling();
        }

        if (!_isDueToDueFromAccount && _interCompany)
        {
            // _dueToDueFromAccount won't be set correctly if posting in the intercompany journal.
            // Detect if this is the due to/due from account
            ledgerInterCompany = LedgerInterCompany::findCompanyPair(_ledgerJournalTrans.ForeignCompany, curExt());

            if (this.compareMainAccounts(ledgerInterCompany.DestinationCreditLedgerDimension, _ledgerJournalTrans.parmLedgerDimension()) ||
                this.compareMainAccounts(ledgerInterCompany.DestinationDebitLedgerDimension, _ledgerJournalTrans.parmLedgerDimension()))
            {
                isDueToDueFromAccountLocal = true;
            }
        }

        if (!ledgerJournalTable.isTaxSupported())
        {
            taxAmount = 0;
        }
        else
        {
            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                if (!TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans).skipTaxDocument())
                {
                    taxAmount = this.getTaxAmountGTE(_ledgerJournalTrans);
                }
                else
                {
                    taxAmount = 0;
                }
            }
            else
            {
                // </GTE>
                taxAmount = taxVoucherService.taxAmountForLedgerType(_originalLedgerJournalTrans, isOffset, _interCompany, isDueToDueFromAccountLocal);
                // <GTE>
            }
            // </GTE>
        }

        ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::Payment:
            case LedgerJournalType::VendPaymRemittance:
                if (_ledgerJournalTrans.PaymMode)
                {
                    select firstonly FurtherPosting, InterCompanyLedgerDimension, BridgingAccountByBank from vendPaymModeTableFieldList
                        index hint PaymModeIdx
                        where vendPaymModeTableFieldList.PaymMode == _ledgerJournalTrans.PaymMode;

                    if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) && ledgerJournalTable.JournalType == LedgerJournalType::Payment)
                    {
                        markBridging = BankAccountBridgingPostingHelper::shouldMarkBridging(
                            vendPaymModeTableFieldList,
                            _ledgerJournalTrans.BridgingBankAccount,
                            _ledgerJournalTrans.LedgerDimension);
                    }
                    else if (vendPaymModeTableFieldList.FurtherPosting
                        && LedgerDimensionFacade::areEqual(vendPaymModeTableFieldList.InterCompanyLedgerDimension, LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_ledgerJournalTrans.LedgerDimension)))
                    {
                        markBridging = true;
                    }
                }
                
                break;

            case LedgerJournalType::CustPayment:
            case LedgerJournalType::CustPaymRemittance:
                if (_ledgerJournalTrans.PaymMode)
                {
                    select firstonly FurtherPosting, InterCompanyLedgerDimension, BridgingAccountByBank from custPaymModeTableFieldList
                        index hint PaymModeIdx
                        where custPaymModeTableFieldList.PaymMode == _ledgerJournalTrans.PaymMode;

                    if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) && ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
                    {
                        markBridging = BankAccountBridgingPostingHelper::shouldMarkBridging(
                            custPaymModeTableFieldList,
                            _ledgerJournalTrans.BridgingBankAccount,
                            _ledgerJournalTrans.LedgerDimension);
                    }
                    else if (custPaymModeTableFieldList.FurtherPosting
                        && LedgerDimensionFacade::areEqual(custPaymModeTableFieldList.InterCompanyLedgerDimension, LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_ledgerJournalTrans.LedgerDimension)))
                    {
                        markBridging = true;
                    }
                }
                break;

            case LedgerJournalType::Approval:
                if (_ledgerJournalTrans.VendTransId && taxAmount)
                {
                    vendTrans = VendTrans::find(_ledgerJournalTrans.VendTransId);

                    vendInvoiceJour = VendInvoiceJour::findFromVendTrans(
                        vendTrans.Invoice,
                        _ledgerJournalTrans.TransDate,
                        vendTrans.AccountNum,
                        true,
                        _ledgerJournalTrans.Voucher
                        );

                    if (vendInvoiceJour.RecId != 0)
                    {
                        if (!vendTrans.displayTaxAmountReverse())
                        {
                            vendInvoiceJour.SumTax += taxAmount;
                        }

                        vendInvoiceJour.SalesBalance  = vendInvoiceJour.InvoiceAmount - vendInvoiceJour.SumTax;
                        vendInvoiceJour.doUpdate();

                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                        {
                            DebitCredit debCred = _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ? DebitCredit::Credit : DebitCredit::Debit;
                            UnknownNoYes journalInclTax = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).LedgerJournalInclTax ? UnknownNoYes::Yes : UnknownNoYes::No;

                            VendInvoiceTrans vendInvTrans;
                            while select forupdate vendInvTrans
                            where vendInvTrans.PurchID == vendInvoiceJour.PurchId &&
                                vendInvTrans.InvoiceId == vendInvoiceJour.InvoiceId &&
                                vendInvTrans.InvoiceDate == vendInvoiceJour.InvoiceDate &&
                                vendInvTrans.numberSequenceGroup == vendInvoiceJour.numberSequenceGroup &&
                                vendInvTrans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId
                            {
                                vendInvTrans.updateFromLedgerJournalTrans_RU(_ledgerJournalTrans, journalInclTax, debCred);
                                vendInvTrans.doUpdate();
                            }
                        }
                    }
                }

                if (_ledgerJournalTrans.Cancel && TaxParameters::find().PurchTaxOnOperations)
                {
                    LedgerJournalTrans ledgerJournalTransFromRegister;

                    //When cancelling a posted register from the approval journal when PurchTaxOnOperations is applicable, we need to properly back out any taxes
                    //that were created on the register.
                    if (_ledgerJournalTrans.PoolRecId)
                    {
                        LedgerJournalTrans ledgerJournalTransFromRegisterOriginal;

                        //Since there is a PoolRecId, the tax needs to be traced back to it's original LedgerJournalTrans record from the Invoice register.
                        //In order to get to the original LedgerJournalTrans that the tax is associated with, the offsetting ledger offset entry needs to be discovered.
                        //From there, the proper tax amount can be determined.
                        select firstonly Voucher, TransDate, RecId from ledgerJournalTransFromRegisterOriginal
                        exists join ledgerJournalTransFromRegister
                                where ledgerJournalTransFromRegister.RecId == _ledgerJournalTrans.PoolRecId
                                    && ledgerJournalTransFromRegister.PoolRecId == ledgerJournalTransFromRegisterOriginal.RecId;

                        if (ledgerJournalTransFromRegisterOriginal.RecId)
                        {
                            taxAmount = -Tax::taxAmountToSubtract(ledgerJournalTransFromRegisterOriginal.Voucher, ledgerJournalTransFromRegisterOriginal.TransDate, ledgerJournalTransFromRegisterOriginal.RecId);
                        }
                    }
                    else
                    {
                        //Since there isn't a PoolRecId, then tax amounts will come from the posted invoice register record.
                        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;

                        //If the LedgerJournalTrans record that is being processed at this point does not have a PoolRecId, then all of the possible taxes for the register will
                        //be found on the single LedgerJournalTrans record with the Vendor account type. There will be only 1 record of the Vendor account type from the register.
                        select firstonly Voucher, TransDate, RecId from ledgerJournalTransFromRegister
                            where ledgerJournalTransFromRegister.AccountType == LedgerJournalACType::Vend
                                && ledgerJournalTransFromRegister.RecId != _ledgerJournalTrans.RecId
                                && ledgerJournalTransFromRegister.Transferred == NoYes::No
                                && ledgerJournalTransFromRegister.NoEdit == NoYes::No
                            exists join ledgerJournalVoucherChanged
                                where ledgerJournalVoucherChanged.JournalNum == _ledgerJournalTrans.JournalNum
                                    && ledgerJournalVoucherChanged.ToVoucher == _ledgerJournalTrans.Voucher
                                    && ledgerJournalVoucherChanged.FromVoucher == ledgerJournalTransFromRegister.Voucher;

                        if (ledgerJournalTransFromRegister.RecId)
                        {
                            taxAmount = -Tax::taxAmountToSubtract(ledgerJournalTransFromRegister.Voucher, ledgerJournalTransFromRegister.TransDate, ledgerJournalTransFromRegister.RecId);
                        }
                    }
                }
                break;

            case LedgerJournalType::CustomsDeclaration_IT:
                customsTrans_IT = LedgerJournalTrans_Customs_IT::findByLedgerJournalTrans(_ledgerJournalTrans.RecId);
                markBridging = _ledgerJournalTrans.FurtherPostingType;
                break;

            default:
                markBridging = _ledgerJournalTrans.FurtherPostingType;
        }

        _ledgerVoucher.parmJournalNumber(_ledgerJournalTrans.JournalNum);

        if (ledgerPostingController.findReference(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate))
        {
            postingReference = ledgerPostingController.getReference();
        }
        else
        {
            postingReference = LedgerVoucherObject::newReference(
                _ledgerJournalTrans.Voucher,
                _ledgerJournalTrans.TransDate,
                _ledgerVoucher.parmSysModuleDefault());

            postingReference.parmJournalCategory(_ledgerJournalTrans.TransactionType);

            ledgerPostingController.addReference(postingReference);
        }

        boolean checkTaxParametersIN = TaxParameters::checkTaxParameters_IN();
        // <GIN>
        if (checkTaxParametersIN
            && _ledgerJournalTrans.isTaxTypeApplicable_IN())
        {
            // totLoiAmount is initialized here.
            if (taxVoucherService.parmIsLedgerLedger_IN() && isOffset)// No LOI for offset for L-L combination.
            {
                totLoiAmount = 0;
            }
        }
        if ((_originalLedgerJournalTrans.AccountType == LedgerJournalACType::Vend  && _originalLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _originalLedgerJournalTrans.AmountCurDebit  > 0
                && MainAccount::findByLedgerDimension(_originalLedgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash)
            || (_originalLedgerJournalTrans.AccountType == LedgerJournalACType::Ledger && _originalLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend && _originalLedgerJournalTrans.AmountCurCredit > 0
                && MainAccount::findByLedgerDimension(_originalLedgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::PurchCash)
            && _originalLedgerJournalTrans.ledgerJournalTransTaxExtensionIN().tdsGroup)
        {
            taxAmount = TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(tableNum(LedgerJournalTable), ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, false);
        }

        priceNotInclTaxIN = checkTaxParametersIN &&
            ledgerJournalTable.LedgerJournalInclTax &&
            FormulaDesigner_IN::existByItemGroup(_ledgerJournalTrans.TaxItemGroup) &&
            !FormulaDesigner_IN::findPriceInclTax(_ledgerJournalTrans.TaxItemGroup);
        // </GIN>

        LedgerVoucherTransObject postingTransaction = this.instantiatePostingTransaction(ledgerJournalTable, _ledgerVoucher, _posting, _ledgerJournalTrans, _originalLedgerJournalTrans, taxAmount,
                                                                                         markBridging, _reversalsMayExist, _interCompany, _isDueToDueFromAccount, priceNotInclTaxIN);
      
        
        Amount amountReportingCurrency = ledgerJournalTrans_Asset.amountReportingCurrency();

        if (AssetPost::isFixedAssetReportingCurrencyAmountShouldBeUsed(_ledgerJournalTrans, ledgerJournalTrans_Asset))
        {
            postingTransaction.parmReportingCurrencyAmount(-amountReportingCurrency);
        }

        // In the case of Approval journal cancellation setting the correction field value from "Transaction reversal correction" field of Ledger Parameters.
        if (!priceNotInclTaxIN && _ledgerJournalTrans.Cancel == NoYes::Yes)
        {
            boolean isTransactionReversalCorrectionOn = LedgerParameters::find().TransactionReversalCorrection == NoYes::Yes;

            if (isTransactionReversalCorrectionOn && ledgerJournalTable.JournalType == LedgerJournalType::Approval)
            {
                postingTransaction.parmIsCorrection(_ledgerJournalTrans.correct());
            }
            else
            {
                postingTransaction.parmIsCorrection(isTransactionReversalCorrectionOn);
            }
        }

        // <GIN>

        if (TaxWithholdParameters_IN::checkTaxParameters()
            && TaxWithholdParameters_IN::findByCompany(_ledgerJournalTrans.ForeignCompany).CrossCompanyPayment)
        {
            withholdTaxAmountCur = _ledgerVoucher.parmAdvancePaymentWHT_IN();

            if (withholdTaxAmountCur)
            {
                exchangeRateHelperLoc = CurrencyExchangeHelper::newExchangeDate(
                    Ledger::primaryLedger(_ledgerJournalTrans.companyInfo().RecId),
                    _ledgerJournalTrans.TransDate);
                exchangeRateHelperLoc.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                exchangeRateHelperLoc.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                exchangeRateHelperLoc.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                exchangeRateHelperLoc.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                postingTransaction.parmAmountCur(
                    postingTransaction.parmAmountCur() -
                    withholdTaxAmountCur -
                    _ledgerVoucher.parmBackWardAmountWHT_IN());
                postingTransaction.parmAmountMST(exchangeRateHelperLoc.calculateTransactionToAccounting(_ledgerJournalTrans.CurrencyCode, postingTransaction.parmAmountCur(), true));
                postingTransaction.parmReportingCurrencyAmount(exchangeRateHelperLoc.calculateTransactionCurrencyToReportingCurrency(_ledgerJournalTrans.CurrencyCode, postingTransaction.parmAmountCur(), true));
                _ledgerVoucher.parmAdvancePaymentWHT_IN(0);
                _ledgerVoucher.parmBackWardAmountWHT_IN(0);

                if (AssetPost::isFixedAssetReportingCurrencyAmountShouldBeUsed(_ledgerJournalTrans, ledgerJournalTrans_Asset))
                {
                    postingTransaction.parmReportingCurrencyAmount(amountReportingCurrency);
                }
            }
        }
        // </GIN>
        if (accrual)
        {
            exchangeRateHelper =
                CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId), _ledgerJournalTrans.TransDate);

            if (exchangeRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId)) == 0)
            {
                exchangeRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
            }

            exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
            exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
            exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
            exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

            postingReference.parmAcknowledgementDate(_ledgerJournalTrans.AcknowledgementDate);

            ledgerAccrualTrans = LedgerAccrualTrans::construct(LedgerJournalTransAccrual::find(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, true));
            ledgerAccrualTrans.parmLedgerJournalTrans(LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, false));
            ledgerAccrualTrans.parmPostingLayer(ledgerJournalTable.CurrentOperationsTax);
            ledgerAccrualTrans.post(ledgerPostingController, postingTransaction, exchangeRateHelper);
        }
        else
        {
            boolean canApplyCashDiscOnInvoiceES = TaxParameters::canApplyCashDiscOnInvoice_ES();
            if (canApplyCashDiscOnInvoiceES)
            {
                sumAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(this.vendSummaryLedgerDimension(_ledgerJournalTrans));
            }

            if (_ledgerJournalTrans.LedgerDimension
                && LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_ledgerJournalTrans.LedgerDimension) == sumAccount
                && canApplyCashDiscOnInvoiceES)
            {
                if (_originalLedgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::Ledger)
                    && this.canPostNonRecoverableTax(_ledgerJournalTrans, _originalLedgerJournalTrans))
                {
                    if (!isDueToDueFromAccountLocal)
                    {
                        postingTransaction.parmUseTaxParentTaxUncommitted(taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Source);
                        if (!_interCompany || taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Destination)
                        {
                            postingTransaction.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
                        }
                        else
                        {
                            postingTransaction.parmTaxParentReferenceRecId(taxVoucherService.getOriginatingLJTFromIntercompanyLJT(_ledgerJournalTrans.RecId));
                        }
                        postingTransaction.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
                    }
                }

                this.createTaxLinkForTaxTransfer(_originalLedgerJournalTrans, postingTransaction);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransLedgerJournal(_ledgerJournalTrans, taxAmount + _ledgerJournalTrans.CashDiscAmount, markBridging, conNull(), _reversalsMayExist);

                if (AssetPost::isFixedAssetReportingCurrencyAmountShouldBeUsed(_ledgerJournalTrans, ledgerJournalTrans_Asset))
                {
                    ledgerVoucherTransObject.parmReportingCurrencyAmount(-amountReportingCurrency);
                }
                ledgerVoucherTransObject.parmPostingType(LedgerPostingType::LedgerJournal);
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
            else
            {
                if ((_ledgerJournalTrans.TransactionType == LedgerTransType::Allocation
                    || _ledgerJournalTrans.TransactionType == LedgerTransType::Elimination)
                    && (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting))))
                {
                    postingTransaction.parmPostingType(LedgerPostingType::LedgerJournal);
                }

                postingReference.parmAcknowledgementDate(_ledgerJournalTrans.AcknowledgementDate);

                if (!_originalLedgerJournalTrans.Prepayment &&
                    _originalLedgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::Ledger) &&
                    ((!isOffset && _originalLedgerJournalTrans.isPrimaryTaxable()) ||
                    (isOffset && _originalLedgerJournalTrans.isOffsetTaxable())))
                {
                    if (!isDueToDueFromAccountLocal)
                    {
                        postingTransaction.parmUseTaxParentTaxUncommitted(taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Source);
                        if (!_interCompany || taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Destination)
                        {
                            postingTransaction.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
                        }
                        else
                        {
                            postingTransaction.parmTaxParentReferenceRecId(taxVoucherService.getOriginatingLJTFromIntercompanyLJT(_ledgerJournalTrans.RecId));
                        }
                        postingTransaction.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
                    }
                }

                this.createTaxLinkForTaxTransfer(_originalLedgerJournalTrans, postingTransaction);

                if (customsTrans_IT)
                {
                    CustomsVoucher_IT::newFromParameters(customsTrans_IT, ledgerPostingController, postingTransaction).run();
                }

                ledgerPostingController.addTrans(postingTransaction);

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    if (LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes
                        && _originalLedgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                        && _originalLedgerJournalTrans.ledgerJournalTable().JournalName == CustParameters::find().CollectionsWriteOffLedgerJournalName)
                    {
                        journalizingDefinitionManagerBank = JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                            _originalLedgerJournalTrans.BankAccountId,
                            _originalLedgerJournalTrans.PaymMode,
                            _originalLedgerJournalTrans.TransDate,
                            LedgerPostingType::CustSettlement);

                        journalizingDefinitionManagerBank.parmBankTransactionTypes(BankTransactionTypes::AccountsReceivableSettlement);
                        journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());

                        systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, postingTransaction.parmLedgerDimensionId());
                        systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

                        while (systemGeneratedEntriesListEnumerator.moveNext())
                        {
                            JournalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();
                            postingTransaction = LedgerVoucherTransObject::newTransLedgerJournal(_ledgerJournalTrans, taxAmount, markBridging, this.parmIntercompanyRecIds()
                                , _reversalsMayExist
                                );
                            postingTransaction.parmLedgerDimensionId(JournalizingDefinitionEntry.parmLedgerDimension());
                            if (JournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Credit)
                            {
                                postingTransaction.parmTransactionCurrencyAmount(-postingTransaction.parmTransactionCurrencyAmount());
                                postingTransaction.parmAccountingCurrencyAmount(-postingTransaction.parmAccountingCurrencyAmount());
                                postingTransaction.parmReportingCurrencyAmount(-postingTransaction.parmReportingCurrencyAmount());

                                if (AssetPost::isFixedAssetReportingCurrencyAmountShouldBeUsed(_ledgerJournalTrans, ledgerJournalTrans_Asset))
                                {
                                    postingTransaction.parmReportingCurrencyAmount(-amountReportingCurrency);
                                }
                            }
                            ledgerPostingController.addTrans(postingTransaction);
                        }
                    }
                }
            }
        }

        if (this.canPostNonRecoverableTax(_ledgerJournalTrans, _originalLedgerJournalTrans))
        {
            if (TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled(true) && _ledgerJournalTrans.TaxCode)
            {
                postingTransaction.parmLedgerDimensionId(TaxConsInvoice_JP::getNondeductibleTaxLedgerDimension(
                    _ledgerJournalTrans.TaxCode,
                    LedgerJournalTransUpdateLedger::getTaxDefaultDimension(_ledgerJournalTrans)));
            }
            this.postNonReoverableTax(
                    _ledgerVoucher,
                    ledgerPostingController,
                    _originalLedgerJournalTrans,
                    _ledgerJournalTrans,
                    postingTransaction.parmLedgerDimensionId(),
                    _interCompany,
                    isDueToDueFromAccountLocal);
        }

        if (ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::CapitalReserveTransfer &&
            ledgerJournalTrans_Asset.ReserveTransId)
        {
            select firstonly forupdate assetTrans
                   where assetTrans.RecId == ledgerJournalTrans_Asset.ReserveTransId;

            if (assetTrans)
            {
                assetTrans.ReserveTransferDone = NoYes::Yes;
                assetTrans.update();
            }
        }

        if (FeatureStateProvider::isFeatureEnabled(LedgerJournalTransIntercompanyTaxInSourceFlight::instance())
            && _interCompany
            && taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Source)
        {
            LedgerJournalTrans ledgerJournalTransExcludeTax = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, true);

            if (ledgerJournalTransExcludeTax)
            {
                if (ledgerJournalTable.LedgerJournalInclTax && taxAmount != 0)
                {
                    if (ledgerJournalTransExcludeTax.AmountCurCredit > 0)
                    {
                        ledgerJournalTransExcludeTax.AmountCurCredit += taxAmount;
                    }
                    else if (ledgerJournalTransExcludeTax.AmountCurDebit > 0)
                    {
                        ledgerJournalTransExcludeTax.AmountCurDebit -= taxAmount;
                    }
                }

                if (ledgerJournalTransExcludeTax.TaxGroup)
                {
                    ledgerJournalTransExcludeTax.TaxGroup = '';
                }

                if (ledgerJournalTransExcludeTax.TaxItemGroup)
                {
                    ledgerJournalTransExcludeTax.TaxItemGroup = '';
                }

                ledgerJournalTransExcludeTax.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiatePostingTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a new instance of <c>LedgerVoucherTransObject</c>.
    /// </summary>
    /// <param name = "_ledgerJournalTable">A <c>LedgerJournalTable</c>.</param>
    /// <param name = "_ledgerVoucher">A <c>LedgerVoucher</c>.</param>
    /// <param name = "_posting">A <c>LedgerPostingType</c>.</param>
    /// <param name = "_ledgerJournalTrans">A <c>LedgerJournalTrans</c>.</param>
    /// <param name = "_originalLedgerJournalTrans">A <c>LedgerJournalTrans</c>.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_markBridging">A Boolean indicating whether to the transaction should be bridged.</param>
    /// <param name = "_reversalsMayExist">A Boolean indicating whether reversal is allowed for the <c>LedgerVoucherTransObject</c></param>
    /// <param name = "_priceNotInclTaxIN">A Boolean indicating whether to include tax.</param>
    /// <param name = "_interCompany">A Boolean.</param>
    /// <param name = "_isDueToDueFromAccount">A Boolean.</param>
    /// <returns>The instantiated <c>LedgerVoucherTransObject</c> instance.</returns>
    protected LedgerVoucherTransObject instantiatePostingTransaction(
        LedgerJournalTable  _ledgerJournalTable,
        LedgerVoucher       _ledgerVoucher,
        LedgerPostingType   _posting,
        LedgerJournalTrans  _ledgerJournalTrans,
        LedgerJournalTrans  _originalLedgerJournalTrans,
        TaxAmount           _taxAmount,
        boolean             _markBridging,
        boolean             _reversalsMayExist,
        boolean             _interCompany,
        boolean             _isDueToDueFromAccount,
        boolean             _priceNotInclTaxIN)
    {
        TaxAmount taxAmount = _taxAmount;

        // <GIN>
        if (_priceNotInclTaxIN)
        {
            taxAmount = 0;
        }
        // </GIN>

        if (_ledgerJournalTable.JournalType == LedgerJournalType::ReportingCurrencyAdjustment)
        {
            return LedgerVoucherTransObject::newTransLedgerReportingCurrencyAdjustment(_ledgerJournalTrans);
        }
        else
        {
            return LedgerVoucherTransObject::newTransLedgerJournal(_ledgerJournalTrans, taxAmount, _markBridging, this.parmIntercompanyRecIds(), _reversalsMayExist);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendSummaryLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount vendSummaryLedgerDimension(LedgerJournalTrans _ledgerJournalTrans)
    {
        VendLedgerAccounts      vendLedgerAccounts;
        LedgerJournalTrans      ledgerJournalTrans;

        PostingProfile          vendParameterPostingProfile;
        VendGroupId             vendGroup;
        LedgerDimensionDefaultAccount ledgerDimension;
        boolean                 one = true;

        vendParameterPostingProfile = VendParameters::find().PostingProfile;

        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.Voucher        == _ledgerJournalTrans.Voucher &&
                  (ledgerJournalTrans.AccountType   == LedgerJournalACType::Vend || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend);

        if (ledgerJournalTrans)
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                vendGroup = VendTable::findByLedgerDimension(ledgerJournalTrans.LedgerDimension).VendGroup;
            }
            else
            {
                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    vendGroup = VendTable::findByLedgerDimension(ledgerJournalTrans.parmOffsetLedgerDimension()).VendGroup;
                }
                else
                {
                    one = false;
                    ledgerDimension = 0;
                }
            }

            if (one)
            {
                select firstonly SummaryLedgerDimension from vendLedgerAccounts
                    where vendLedgerAccounts.PostingProfile == vendParameterPostingProfile &&
                          vendLedgerAccounts.Num            == vendGroup;

                ledgerDimension = vendLedgerAccounts.SummaryLedgerDimension;
            }
        }
        else
        {
            ledgerDimension = 0;
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostNonRecoverableTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines whether to post non recoverable tax.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// Ledger journal trans.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original unmodified <c>LedgerJournalTrans</c> record that is posted.
    /// </param>
    /// <returns>
    /// True if it can post the tax, otherwise, false.
    /// </returns>
    protected boolean canPostNonRecoverableTax(LedgerJournalTrans _ledgerJournalTrans,
                                              LedgerJournalTrans _originalLedgerJournalTrans)
    {
        return ((!isOffset && _originalLedgerJournalTrans.isPrimaryTaxable()) 
            || (isOffset && _originalLedgerJournalTrans.isOffsetTaxable())
            || TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the default dimension from the transaction line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     Ledger journal trans.
    /// </param>
    /// <returns>
    ///     The default dimension of the transaction line.
    /// </returns>
    private static DimensionDefault getTaxDefaultDimension(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.LedgerDimension)
        {
            return LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_ledgerJournalTrans.LedgerDimension);
        }
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.OffsetLedgerDimension)
        {
            return LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension);
        }

        return _ledgerJournalTrans.DefaultDimension;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>