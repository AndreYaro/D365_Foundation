<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjAccountDetailHistoryDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProjAccountDetailHistoryDP</c> class provides data for the
/// <c>ProjAccountDetailHistory</c>Microsoft SQL Server Reporting Services report.
/// </summary>
[
    SRSReportQueryAttribute(querystr(ProjTable)),
    SRSReportParameterAttribute(classstr(ProjAccountDetailHistoryContract))
]
class ProjAccountDetailHistoryDP extends SRSReportDataProviderBase
{
    ProjTmpAccountDetailHistory         projTmpAccountDetailHistory;
    ProjAccountDetailHistoryContract    contract;
    Name                                projDimensionFocus;
    TransDate                           projFromDate;
    TransDate                           projToDate;
    TransDate                           ledgerFromDate;
    TransDate                           ledgerToDate;
    TransDate                           projTransdate;
    TransDate                           ledgerTransdate;
    Map                                 accumulatedAmountMap;
    Map                                 dimensionFocusMap;
    DimensionDisplayValue               dimensionDisplayValue;
    LedgerDimensionAccount              ledgerDimension;
    LedgerDimensionAccount              defaultDimension;

    #define.Budget("Budget")
    #define.Actual("Actual")
    #define.CommittedCost("CommitedCost")
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>collectData</Name>
				<Source><![CDATA[
    private void collectData(
        Query    _query,
        FromDate _fromDate,
        ToDate   _toDate,
        Name     _dimensionFocus)
    {
        QueryRun    projAccountDetailHistoryReportRun;
        ProjTable   projTable;

        projAccountDetailHistoryReportRun = new QueryRun(_query);

        while (projAccountDetailHistoryReportRun.next())
        {
            projTable = projAccountDetailHistoryReportRun.get(tablenum(ProjTable));

            this.populateProjectBudgetData(projTable, _fromDate, _toDate, _dimensionFocus);
            this.populateProjectTransactionData(projTable, _fromDate, _toDate, _dimensionFocus);
            this.populateProjectCommittedCostsData(projTable, _fromDate, _toDate, _dimensionFocus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjTmpAccountDetailHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a buffer of the <c>ProjTmpAccountDetailHistory</c> table.
    /// </summary>
    /// <returns>
    /// A buffer of the <c>ProjTmpAccountDetailHistory</c> table.
    /// </returns>
    [
        SRSReportDataSetAttribute('ProjTmpAccountDetailHistory')
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ProjTmpAccountDetailHistory getProjTmpAccountDetailHistory()
    {
        select projTmpAccountDetailHistory;
        return projTmpAccountDetailHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBeginningActuals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates records in the <c>ProjTmpAccountDetailHistory</c> table for the specified project.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void populateBeginningActuals(ProjTable _projTable)
    {
        ProjTransPosting    projTransPosting;
        MainAccount         mainAccount;

        while select sum(AmountMst), LedgerDimension, DefaultDimension from projTransPosting group by LedgerDimension,DefaultDimension
            where projTransPosting.ProjId           == _projTable.ProjId
                && projTransPosting.CostSales       == ProjCostSales::Cost
                && (projTransPosting.ProjTransType  == ProjTransType::Cost
                || projTransPosting.ProjTransType   == ProjTransType::Hour
                || projTransPosting.ProjTransType   == ProjTransType::Item)
                && projTransPosting.PostingType     != LedgerPostingType::ProjNeverLedger
                && projTransPosting.PostingType     != LedgerPostingType::ProjNoLedger
                && projTransPosting.LedgerTransDate < ledgerFromDate
                && projTransPosting.ProjTransDate   < projFromDate
        {
            if (BudgetControlStatisticsManager::getDimensionFocus(LedgerDimensionFacade::serviceCreateLedgerDimension(projTransPosting.LedgerDimension, projTransPosting.DefaultDimension),
                                                                projDimensionFocus) == dimensionDisplayValue)
            {
                if (projTransPosting.LedgerDimension && projTransPosting.AmountMst > 0)
                {
                    mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(projTransPosting.LedgerDimension);

                    select forUpdate AmountActual from projTmpAccountDetailHistory
                        where  projTmpAccountDetailHistory.ProjId          == _projTable.ProjId
                            && projTmpAccountDetailHistory.MainAccountId   ==  mainAccount.MainAccountId
                            && projTmpAccountDetailHistory.DimensionFocus  == dimensionDisplayValue;

                    if (projTmpAccountDetailHistory)
                    {
                        projTmpAccountDetailHistory.AmountActual += projTransPosting.AmountMst;
                        projTmpAccountDetailHistory.Actuals      += projTransPosting.AmountMst;
                        ttsBegin;
                        projTmpAccountDetailHistory.update();
                        ttsCommit;
                    }
                    else
                    {
                        projTmpAccountDetailHistory.ProjId          = _projTable.ProjId;
                        projTmpAccountDetailHistory.ProjName        = _projTable.Name;
                        projTmpAccountDetailHistory.LedgerDimension = projTransPosting.LedgerDimension;
                        projTmpAccountDetailHistory.DimensionFocus  = dimensionDisplayValue;

                        projTmpAccountDetailHistory.MainAccountId   = mainAccount.MainAccountId;
                        projTmpAccountDetailHistory.AccountName     = mainAccount.localizedName();
                        projTmpAccountDetailHistory.AmountActual    = projTransPosting.AmountMst;
                        projTmpAccountDetailHistory.Actuals         = projTransPosting.AmountMst;
                        projTmpAccountDetailHistory.Currency        = SystemParameters::find(false).SystemCurrencyCode;
                        projTmpAccountDetailHistory.insert();
                    }
                    accumulatedAmountMap.insert(strfmt("%1:%2:%3", #Actual, mainAccount.MainAccountId,dimensionDisplayValue), projTmpAccountDetailHistory.Actuals);
                    projTmpAccountDetailHistory.clear();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetProjectBeginningBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the base query to select all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </summary>
    /// <param name = "_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <returns>
    /// Returns query instance to select the project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </returns>
    protected Query buildQueryToGetProjectBeginningBudget(ProjTable _projTable)
    {
        Query query = new Query();
        QueryBuildDataSource projTransBudgetQbds = query.addDataSource(tableNum(ProjTransBudget));
        projTransBudgetQbds.addGroupByField(fieldNum(ProjTransBudget, LedgerDimension));
        projTransBudgetQbds.addGroupByField(fieldNum(ProjTransBudget, ModelId));
        projTransBudgetQbds.addGroupByField(fieldNum(ProjTransBudget, DefaultDimension));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, AmountMst), SelectionField::Sum);
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, LedgerDimension));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, ModelId));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, DefaultDimension));
        //Adding the range to projTransBudgetQbds
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(_projTable.ProjId));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, CostSales)).value(queryValue(ProjCostSales::Cost));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, PaymentStatus)).value(queryValue(ProjPaymentStatus::Paid));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, PostingType)).value(strFmt('((%1 != %2) && (%1 != %3 ))', fieldStr(ProjTransBudget, PostingType), any2Int(LedgerPostingType::ProjNeverLedger), any2Int(LedgerPostingType::ProjNoLedger)));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, LedgerTransDate)).value(strFmt('(%1 < %2)', fieldStr(ProjTransBudget, LedgerTransDate), date2StrXpp(ledgerFromDate)));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(strFmt('(%1 < %2)', fieldStr(ProjTransBudget, ProjTransDate), date2StrXpp(projFromDate)));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBeginningBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Popluates records in the <c>ProjTmpAccountDetailHistory</c> table for the specified project.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void populateBeginningBudget(ProjTable _projTable)
    {
        
        QueryRun queryRun = new QueryRun(this.buildQueryToGetProjectBeginningBudget(_projTable));

        while(queryRun.next())
        {
            ProjTransBudget projTransBudget = queryRun.get(tableNum(ProjTransBudget));

            if (BudgetControlStatisticsManager::getDimensionFocus(LedgerDimensionFacade::serviceCreateLedgerDimension(projTransBudget.LedgerDimension, projTransBudget.DefaultDimension),
                                                                projDimensionFocus) == dimensionDisplayValue)
            {
                if (projTransBudget.LedgerDimension
                    && projTransBudget.AmountMst > 0
                    && ForecastModel::findForecastModelByName(projTransBudget.ModelId).ProjBudgetType == ProjBudgetType::OriginalBudget)
                {
                    MainAccount mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(projTransBudget.LedgerDimension);

                    select forupdate ProjId, LedgerDimension, RevisedBudget from projTmpAccountDetailHistory
                        where projTmpAccountDetailHistory.ProjId            == _projTable.ProjId
                            && projtmpaccountdetailhistory.mainaccountid    == mainaccount.mainaccountid
                            && projTmpAccountDetailHistory.DimensionFocus   == dimensionDisplayValue;

                    if (projTmpAccountDetailHistory)
                    {
                        projTmpAccountDetailHistory.RevisedBudget  += ProjTransBudget.AmountMst;
                        projTmpAccountDetailHistory.OriginalBudget += projTransBudget.AmountMst;
                        ttsBegin;
                        projTmpAccountDetailHistory.update();
                        ttsCommit;
                    }
                    else
                    {
                        projTmpAccountDetailHistory.ProjId          = _projTable.ProjId;
                        projTmpAccountDetailHistory.ProjName        = _projTable.Name;
                        projTmpAccountDetailHistory.LedgerDimension = projTransBudget.LedgerDimension;
                        projTmpAccountDetailHistory.DimensionFocus  = dimensionDisplayValue;
                        projTmpAccountDetailHistory.MainAccountId   = mainAccount.MainAccountId;
                        projTmpAccountDetailHistory.AccountName     = mainAccount.localizedName();
                        projTmpAccountDetailHistory.RevisedBudget   = projTransBudget.AmountMst;
                        projTmpAccountDetailHistory.OriginalBudget  = projTransBudget.AmountMst;
                        projTmpAccountDetailHistory.Currency        = SystemParameters::find(false).SystemCurrencyCode;

                        projTmpAccountDetailHistory.insert();
                    }
                    accumulatedAmountMap.insert(strfmt("%1:%2:%3", #Budget, mainAccount.MainAccountId,dimensionDisplayValue), projTmpAccountDetailHistory.RevisedBudget);
                    projTmpAccountDetailHistory.clear();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBeginningCommittedCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates records in the <c>ProjTmpAccountDetailHistory</c> table for the specified project.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void populateBeginningCommittedCosts(ProjTable _projTable)
    {
        ProjParameters                  projParameters;
        MainAccount                     mainAccount;
        CostControlTransCommittedCost   costControlTransCommittedCost;

        projParameters = ProjParameters::find();

        if (projParameters.TrackCommittedCostItemRequirement        == NoYes::Yes
            || projParameters.TrackCommittedCostPurchaseOrder       == NoYes::Yes
            || projParameters.TrackCommittedCostPurchaseRequisition == NoYes::Yes)
        {
            while select LedgerDimension,DefaultDimension, sum(AmountMst) from costControlTransCommittedCost group by LedgerDimension,DefaultDimension
                where costControlTransCommittedCost.ProjId          == _projTable.ProjId
                    && (costControlTransCommittedCost.ProjTransType == ProjTransType::Cost
                    || costControlTransCommittedCost.ProjTransType  == ProjTransType::Hour
                    || costControlTransCommittedCost.ProjTransType  == ProjTransType::Item)
                    && costControlTransCommittedCost.CommittedDate  <  ledgerFromDate
                    && costControlTransCommittedCost.CommittedDate  <  projFromDate
            {
                if (BudgetControlStatisticsManager::getDimensionFocus(LedgerDimensionFacade::serviceCreateLedgerDimension(costControlTransCommittedCost.LedgerDimension, costControlTransCommittedCost.DefaultDimension),
                                                                    projDimensionFocus) == dimensionDisplayValue)
                {
                    if (costControlTransCommittedCost.LedgerDimension && costControlTransCommittedCost.AmountMst > 0)
                    {
                        mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(costControlTransCommittedCost.LedgerDimension);
                        select forUpdate CommittedCost from projTmpAccountDetailHistory
                            where projTmpAccountDetailHistory.ProjId           == _projTable.ProjId
                                && projTmpAccountDetailHistory.MainAccountId   == mainAccount.MainAccountId
                                && projTmpAccountDetailHistory.DimensionFocus  == dimensionDisplayValue;

                        if (projTmpAccountDetailHistory)
                        {
                            projTmpAccountDetailHistory.AmountCommittedCost += costControlTransCommittedCost.AmountMst;
                            projTmpAccountDetailHistory.CommittedCost       += costControlTransCommittedCost.AmountMst;
                            ttsBegin;
                            projTmpAccountDetailHistory.update();
                            ttsCommit;
                        }
                        else
                        {
                            projTmpAccountDetailHistory.ProjId              = _projTable.ProjId;
                            projTmpAccountDetailHistory.ProjName            = _projTable.Name;
                            projTmpAccountDetailHistory.LedgerDimension     = costControlTransCommittedCost.LedgerDimension;
                            projTmpAccountDetailHistory.MainAccountId       = mainAccount.MainAccountId;
                            projTmpAccountDetailHistory.DimensionFocus      = dimensionDisplayValue;

                            projTmpAccountDetailHistory.AccountName         = mainAccount.localizedName();
                            projTmpAccountDetailHistory.AmountCommittedCost = costControlTransCommittedCost.AmountMst;
                            projTmpAccountDetailHistory.CommittedCost       = costControlTransCommittedCost.AmountMst;
                            projTmpAccountDetailHistory.Currency            = SystemParameters::find(false).SystemCurrencyCode;
                            projTmpAccountDetailHistory.insert();
                        }
                        accumulatedAmountMap.insert(strfmt("%1:%2:%3", #CommittedCost, mainAccount.MainAccountId,dimensionDisplayValue), projTmpAccountDetailHistory.CommittedCost);
                        projTmpAccountDetailHistory.clear();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetProjectBudgetData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the base query to select all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </summary>
    /// <param name = "_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name = "_fromDate">
    ///  A date to be used as query filter.
    /// </param>
    /// <param name = "_toDate">
    ///  A date to be used as query filter.
    /// </param>
    /// <returns>
    /// Returns query instance to select project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </returns>
    protected Query buildQueryToGetProjectBudgetData(ProjTable _projTable, FromDate _fromDate, ToDate _toDate)
    {
        Query query = new Query();
        QueryBuildDataSource projTransBudgetQbds = query.addDataSource(tableNum(ProjTransBudget));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, ProjTransDate));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, TransId));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, LedgerDimension));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, ProjTransType));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, AmountMst));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, DefaultDimension));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, ProjId));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(_projTable.ProjId));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, CostSales)).value(queryValue(ProjCostSales::Cost));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, PaymentStatus)).value(queryValue(ProjPaymentStatus::Paid));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, PostingType)).value(strFmt('((%1 != %2) && (%1 != %3))', fieldStr(ProjTransBudget, PostingType), any2Int(LedgerPostingType::ProjNeverLedger), any2Int(LedgerPostingType::ProjNoLedger)));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(strFmt('((%1 >= %2) && (%1 <= %3))',fieldStr(ProjTransBudget, ProjTransDate), date2StrXpp(_fromDate), date2StrXpp(_toDate)));

        QueryBuildDataSource forecastModelQbds = projTransBudgetQbds.addDataSource(tableNum(ForecastModel));
        forecastModelQbds.joinMode(JoinMode::ExistsJoin);
        forecastModelQbds.addLink(fieldNum(ProjTransBudget, ModelId),fieldNum(ForecastModel, ModelId));
        forecastModelQbds.addRange(fieldNum(ForecastModel, ProjBudgetType)).value(queryValue(ProjBudgetType::OriginalBudget));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjectBudgetData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates records in the <c>ProjTmpAccountDetailHistory</c> table for all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_fromDate">
    /// A date to be used as query filter.
    /// </param>
    /// <param name="_toDate">
    /// A date to be used as query filter.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimenison focus name to be used to group the data.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void populateProjectBudgetData(
        ProjTable   _projTable,
        FromDate    _fromDate,
        ToDate      _toDate,
        Name        _dimensionFocusName)
    {
        ProjTransBudget       projTransBudget;
        MainAccount           mainAccount;
        Boolean               doInsert;
        DimensionDisplayValue currentDimensionDisplayValue;

        QueryRun queryRun = new QueryRun(this.buildQueryToGetProjectBudgetData(_projTable, _fromDate, _toDate));

        while(queryRun.next())
        {
            projTransBudget = queryRun.get(tableNum(ProjTransBudget));
            doInsert = true;

            if (projTransBudget.LedgerDimension)
            {
                currentDimensionDisplayValue = BudgetControlStatisticsManager::getDimensionFocus(
                    LedgerDimensionFacade::serviceCreateLedgerDimension(projTransBudget.LedgerDimension, projTransBudget.DefaultDimension),
                    _dimensionFocusName);

                this.setTransactionText(ProjOrigin::None, '', projTransBudget.ProjId);

                projTmpAccountDetailHistory.ProjId          = _projTable.ProjId;
                projTmpAccountDetailHistory.ProjName        = _projTable.Name;
                projTmpAccountDetailHistory.TransDate       = projTransBudget.ProjTransDate;
                projTmpAccountDetailHistory.TransId         = projTransBudget.TransId;
                projTmpAccountDetailHistory.LedgerDimension = projTransBudget.LedgerDimension;
                projTmpAccountDetailHistory.DimensionFocus  = currentDimensionDisplayValue;

                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(projTransBudget.LedgerDimension);

                projTmpAccountDetailHistory.MainAccountId  = mainAccount.MainAccountId;
                projTmpAccountDetailHistory.AccountName    = mainAccount.localizedName();

                doInsert = this.setBudgetAmount(
                            projTransBudget.ProjTransType,
                            projTransBudget.AmountMst,
                            projTransBudget.TransId);

                if (doInsert)
                {
                    projTmpAccountDetailHistory.Currency = SystemParameters::find(false).SystemCurrencyCode;
                    projTmpAccountDetailHistory.Insert();
                }

                projTmpAccountDetailHistory.clear();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjectCommittedCostsData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates records in the <c>ProjTmpAccountDetailHistory</c> table for all the project committed cost transactions saved to the <c>CostControlTransCommittedCost</c> table.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_fromDate">
    /// A date to be used as query filter.
    /// </param>
    /// <param name="_toDate">
    /// A date to be used as query filter.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimenison focus name to be used to group the data.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void populateProjectCommittedCostsData(
        ProjTable   _projTable,
        FromDate    _fromDate,
        ToDate      _toDate,
        Name        _dimensionFocusName)
    {
        ProjParameters                  projParameters;
        MainAccount                     mainAccount;
        CostControlTransCommittedCost   costControlTransCommittedCost;
        DimensionDisplayValue           currentDimensionDisplayValue;

        projParameters = ProjParameters::find();

        if (projParameters.TrackCommittedCostItemRequirement        == NoYes::Yes
            || projParameters.TrackCommittedCostPurchaseOrder       == NoYes::Yes
            || projParameters.TrackCommittedCostPurchaseRequisition == NoYes::Yes)
        {
            while select CommittedDate, ProjTransId, LedgerDimension, AmountMst,DefaultDimension,CommittedCostOrig, SourceDocumentLine
                from costControlTransCommittedCost
                    where costControlTransCommittedCost.ProjId           == _projTable.ProjId
                        &&  (costControlTransCommittedCost.ProjTransType == ProjTransType::Cost
                        ||  costControlTransCommittedCost.ProjTransType  == ProjTransType::Hour
                        ||  costControlTransCommittedCost.ProjTransType  == ProjTransType::Item)
                        &&  costControlTransCommittedCost.CommittedDate  >= _fromDate
                        &&  costControlTransCommittedCost.CommittedDate  <= _toDate
            {
                currentDimensionDisplayValue = BudgetControlStatisticsManager::getDimensionFocus(LedgerDimensionFacade::serviceCreateLedgerDimension(costControlTransCommittedCost.LedgerDimension, costControlTransCommittedCost.DefaultDimension),
                                                        projDimensionFocus);

                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(costControlTransCommittedCost.LedgerDimension);

                this.setTransactionOrigin(costControlTransCommittedCost.CommittedCostOrig);

                this.setTransactionText(
                        projTmpAccountDetailHistory.TransactionOrigin,
                        costControlTransCommittedCost.ProjTransId,
                        _projTable.ProjId,
                        '',
                        '',
                        costControlTransCommittedCost.SourceDocumentLine);

                projTmpAccountDetailHistory.ProjId              = _projTable.ProjId;
                projTmpAccountDetailHistory.ProjName            = _projTable.Name;
                projTmpAccountDetailHistory.TransDate           = costControlTransCommittedCost.CommittedDate;
                projTmpAccountDetailHistory.TransId             = costControlTransCommittedCost.ProjTransId;
                projTmpAccountDetailHistory.LedgerDimension     = costControlTransCommittedCost.LedgerDimension;
                projTmpAccountDetailHistory.DimensionFocus      = currentDimensionDisplayValue;
                projTmpAccountDetailHistory.MainAccountId       = mainAccount.MainAccountId;
                projTmpAccountDetailHistory.AccountName         = mainAccount.localizedName();
                projTmpAccountDetailHistory.AmountCommittedCost = costControlTransCommittedCost.AmountMst;
                projTmpAccountDetailHistory.NetAmount           = -costControlTransCommittedCost.AmountMst;
                projTmpAccountDetailHistory.Currency            = SystemParameters::find(false).SystemCurrencyCode;
                projTmpAccountDetailHistory.insert();

                projTmpAccountDetailHistory.clear();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjectTransactionData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates records in the <c>ProjTmpAccountDetailHistory</c> table for all the project transactions of type hour, expense, and item posted to the <c>ProjTransPosting</c> table.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_fromDate">
    /// A date to be used as query filter.
    /// </param>
    /// <param name="_toDate">
    /// A date to be used as query filter.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimenison focus name to be used to group the data.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void populateProjectTransactionData(
        ProjTable   _projTable,
        FromDate    _fromDate,
        ToDate      _toDate,
        Name        _dimensionFocusName)
    {
        ProjTransPosting        projTransPosting;
        MainAccount             mainAccount;
        boolean                 doInsert;
        DimensionDisplayValue   currentDimensionDisplayValue;

        ProjTable projTable;

        while select ProjTransDate, TransactionOrigin, TransId, LedgerDimension, ProjTransType, InventTransId, AmountMst,DefaultDimension, CategoryId, ProjId, Voucher from projTransPosting
            where projTransPosting.CostSales == ProjCostSales::Cost
                && (projTransPosting.ProjTransType == ProjTransType::Cost
                || projTransPosting.ProjTransType == ProjTransType::Hour
                || projTransPosting.ProjTransType == ProjTransType::Item)
                && projTransPosting.PostingType != LedgerPostingType::ProjNeverLedger
                && projTransPosting.PostingType != LedgerPostingType::ProjNoLedger
                && projTransPosting.PaymentStatus != ProjPaymentStatus::NoPayment
                && projTransPosting.ProjTransDate >= _fromDate
                && projTransPosting.ProjTransDate <= _toDate
            exists join projTable
            where projTable.ProjId == projTransPosting.ProjId
                && (projTable.ProjId == _projTable.ProjId
                || (projTable.UseAlternateProject == NoYes::Yes
                && projTable.AlternateBudgetProject == _projTable.ProjId))
        {
            if (projTransPosting.LedgerDimension)
            {
                doInsert = this.setTransactionText(
                                projTransPosting.TransactionOrigin == any2Enum(ProjOrigin::PurchaseOrder)? any2Enum(ProjOrigin::VendorInvoice): any2Enum(projTransPosting.TransactionOrigin),
                                projTransPosting.TransId,
                                projTransPosting.ProjId,
                                projTransPosting.Voucher,
                                projTransPosting.CategoryId);

                if (doInsert)
                {
                    mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(projTransPosting.LedgerDimension);

                    currentDimensionDisplayValue = BudgetControlStatisticsManager::getDimensionFocus(LedgerDimensionFacade::serviceCreateLedgerDimension(projTransPosting.LedgerDimension, projTransPosting.DefaultDimension),
                        projDimensionFocus);

                    projTmpAccountDetailHistory.ProjId            = _projTable.ProjId;
                    projTmpAccountDetailHistory.ProjName          = _projTable.Name;
                    projTmpAccountDetailHistory.TransDate         = projTransPosting.ProjTransDate;
                    projTmpAccountDetailHistory.TransactionOrigin = projTransPosting.TransactionOrigin;
                    projTmpAccountDetailHistory.TransId           = projTransPosting.TransId;
                    projTmpAccountDetailHistory.LedgerDimension   = projTransPosting.LedgerDimension;
                    projTmpAccountDetailHistory.DimensionFocus    = currentDimensionDisplayValue;
                    projTmpAccountDetailHistory.MainAccountId     = mainAccount.MainAccountId;
                    projTmpAccountDetailHistory.AccountName       = mainAccount.localizedName();
                    projTmpAccountDetailHistory.AmountActual      = projTransPosting.AmountMst;
                    projTmpAccountDetailHistory.NetAmount         = -projTransPosting.AmountMst;
                    projTmpAccountDetailHistory.Currency          = SystemParameters::find(false).SystemCurrencyCode;
                    projTmpAccountDetailHistory.insert();

                    projTmpAccountDetailHistory.clear();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    public void processReport()
    {
        Query   query;

        contract = this.parmDataContract() as ProjAccountDetailHistoryContract;

        projDimensionFocus  = contract.parmProjDimensionFocus();
        projFromDate        = contract.parmProjFromDate();
        projToDate          = contract.parmProjToDate();
        ledgerFromDate      = contract.parmLedgerFromDate();
        ledgerToDate        = contract.parmLedgerToDate();

        query = this.parmQuery();
        //this.processReportData(query);
        this.collectData(query, projFromDate, projToDate, projDimensionFocus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReportData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the data to be displayed on the <c>ProjAccountDetailHistory</c> report.
    /// </summary>
    /// <param name="_query">
    /// The query used to select the projects for which the report data is to be processed.
    /// </param>
    private void processReportData(Query _query)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBudgetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the budget amount on the <c>ProjTmpAccountDetailHistory</c> table.
    /// </summary>
    /// <param name="_projTransType">
    /// An element of the <c>ProjTransType</c> enum.
    /// </param>
    /// <param name="_amountMst">
    /// The amount to be set in <c>ProjTmpAccountDetailHistory</c> table.
    /// </param>
    /// <param name="_transId">
    /// The transanction ID that is used to filter the type of project buffer.
    /// </param>
    /// <returns>
    /// A boolean value which states that either the amount is inserted in the <c>ProjTmpAccountDetailHistory</c> table.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The element of the <c>ProjTransType</c> enum that passed into the method was not expected.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Boolean setBudgetAmount(ProjTransType _projTransType, AmountMst _amountMst, Num _transId)
    {
        ProjForecastCost    projForecastCost;
        ProjForecastEmpl    projForecastEmpl;
        ProjForecastRevenue projForecastRevenue;
        ProjForecastOnAcc   projForecastOnAcc;
        ForecastSales       forecastSales;
        boolean             doInsert;

        switch (_projTransType)
        {
            case ProjTransType::Hour:
                select projForecastBudgetType from projForecastEmpl where projForecastEmpl.TransId == _transId;
                doInsert = this.setOriginalOrRevisionAmount(projForecastEmpl.projForecastBudgetType, _amountMst);
                break;

            case ProjTransType::Cost:
                select projForecastBudgetType from projForecastCost where projForecastCost.TransId == _transId;
                doInsert = this.setOriginalOrRevisionAmount(projForecastCost.projForecastBudgetType, _amountMst);
                break;

            case ProjTransType::Revenue:
                select projForecastBudgetType from projForecastRevenue where projForecastRevenue.TransId == _transId;
                doInsert = this.setOriginalOrRevisionAmount(projForecastRevenue.projForecastBudgetType, _amountMst);
                break;

            case ProjTransType::OnAccount:
                select projForecastBudgetType from projForecastonAcc where projForecastonAcc.TransId == _transId;
                doInsert = this.setOriginalOrRevisionAmount(projForecastonAcc.projForecastBudgetType, _amountMst);
                break;

            case ProjTransType::Item:
                select  projForecastBudgetType from forecastSales where forecastSales.ProjTransId == _transId;
                doInsert = this.setOriginalOrRevisionAmount(forecastSales.projForecastBudgetType, _amountMst);
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return doInsert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOriginalOrRevisionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the original and revised amount on the <c>ProjTmpAccountDetailHistory</c> table.
    /// </summary>
    /// <param name="_projForecastBudgetType">
    /// An element of the <c>ProjForecastBudgetType</c> enum.
    /// </param>
    /// <param name="_amountMST">
    /// The amount to be set in the <c>ProjTmpAccountDetailHistory</c> table.
    /// </param>
    /// <returns>
    /// A boolean value which states that either the amount is inserted in the <c>ProjTmpAccountDetailHistory</c> table.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Boolean setOriginalOrRevisionAmount(ProjForecastBudgetType _projForecastBudgetType, AmountMST _amountMST)
    {
        boolean doInsert = true;

        switch (_projForecastBudgetType)
        {
            case ProjForecastBudgetType::OriginalBudget:
                projTmpAccountDetailHistory.OriginalBudget = _amountMST;
                projTmpAccountDetailHistory.NetAmount = _amountMST;
                break;
            case ProjForecastBudgetType::Amendment:
                projTmpAccountDetailHistory.Revisions = _amountMST;
                projTmpAccountDetailHistory.NetAmount = _amountMST;
                break;
            default:
                doInsert = false;
        }

        return doInsert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>TransactionOrigin</c> field on the basis of <c>CommittedCostOrig</c> enum value.
    /// </summary>
    /// <param name="_committedCostOrig">
    /// An element of the <c>CommittedCostOrig</c> enum.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The element of the <c>CommittedCostOrig</c> enum that passed into the method was not expected.
    /// </exception>
    private void setTransactionOrigin(CommittedCostOrig  _committedCostOrig)
    {
        switch (_committedCostOrig)
        {
            case CommittedCostOrig::PurchaseOrder:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::PurchaseOrder;
                break;
            case CommittedCostOrig::ItemRequirement:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::ItemRequirement;
                break;
            case CommittedCostOrig::ItemJournal:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::ItemJournal;
                break;
            case CommittedCostOrig::PurchaseRequisition:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::PurchaseRequisition;
                break;
            case CommittedCostOrig::VendorInvoice:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::VendorInvoice;
                break;
            case CommittedCostOrig::None:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::None;
                break;

            default:
                projTmpAccountDetailHistory.TransactionOrigin = ProjOrigin::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the transaction text on the <c>ProjTmpAccountDetailHistory</c> table.
    /// </summary>
    /// <param name="_projTransactionOrigin">
    /// An element of the <c>ProjTransactionOrigin</c> enumeration value.
    /// </param>
    /// <param name="_transId">
    /// The transaction ID that filters the type of project record.
    /// </param>
    /// <param name="_projId">
    /// The project ID that obtains the description of budget allocation transaction.
    /// </param>
    /// <param name="_voucher">
    /// The voucher that obtains the description of budget allocation transaction.
    /// </param>
    /// <param name="_categoryId">
    /// The category ID number that is used to get the description of budget allocation transaction
    /// specific to ALE.
    /// </param>
    /// <param name="_sourceDocumentLineId">
    /// The source document line record ID to be used to find the original document of the project transaction.
    /// </param>
    /// <returns>
    /// true if a match is found for project origin; otherwise, false
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The element of the <c>ProjTransactionOrigin</c> enumeration value that passed into the method was
    /// invalid.
    /// </exception>
    private boolean setTransactionText(
        ProjTransactionOrigin   _projTransactionOrigin,
        Num                     _transId,
        ProjId                  _projId = '',
        Voucher                 _voucher = '',
        CategoryId              _categoryId = '',
        SourceDocumentLineRecId _sourceDocumentLineId = 0)
    {
        ProjCostTrans                    projCostTrans;
        ProjItemTrans                    projItemTrans;
        ProjEmplTrans                    projEmplTrans;
        ProjBudget                       projBudget;
        LedgerJournalTrans               ledgerJournalTrans;
        LedgerJournalTrans_Project       ledgerJournalTrans_Project;
        ProjRevenueTrans                 projRevenueTrans;
        ProjBegBalJournalTrans_CostSales projBegBalJournalTrans;
        ProjCategory                     projCategory;
        VendInvoiceInfoLine              vendInvoiceInfoLine;
        VendInvoiceInfoTable             vendInvoiceInfoTable;
        PurchTable                       purchTable;
        PurchLine                        purchLine;
        ReasonTableRef                   reasonTableRef;
        PurchReqLine                     purchReqLine;
        PurchReqTable                    purchReqTable;
        ProjAdvancedJournalLine          projAdvancedJournalLine;

        if (!_transId)
        {
            select Description
                from  projBudget
                where projBudget.RootProjId == _projId;

            projTmpAccountDetailHistory.TransactionText = projBudget.Description;
        }
        else
        {
            switch (_projTransactionOrigin)
            {
                case ProjOrigin::CostJournal:
                    select firstonly Txt from projCostTrans where projCostTrans.TransId == _transId;
                    projTmpAccountDetailHistory.TransactionText = projCostTrans.Txt;
                    break;

                case ProjOrigin::PurchaseRequisition:
                    select PurchReqName
                    from purchReqTable
                        exists join purchReqLine
                        where purchReqLine.PurchReqTable      == purchReqTable.RecId
                           && purchReqLine.SourceDocumentLine == _sourceDocumentLineId;

                    projTmpAccountDetailHistory.TransactionText = purchReqTable.PurchReqName;
                    break;

                case ProjOrigin::VendorInvoice:
                    select Description
                    from vendInvoiceInfoTable
                        exists join vendInvoiceInfoLine
                        where vendInvoiceInfoLine.TableRefId         == vendInvoiceInfoTable.TableRefId
                           && vendInvoiceInfoLine.ParmId             == vendInvoiceInfoTable.ParmId
                           && vendInvoiceInfoLine.SourceDocumentLine == _sourceDocumentLineId;

                    projTmpAccountDetailHistory.TransactionText = vendInvoiceInfoTable.Description;
                    break;

                case ProjOrigin::ProjAdvancedJournal:
                    select firstonly Text from projAdvancedJournalLine where projAdvancedJournalLine.Voucher == _voucher;
                    projTmpAccountDetailHistory.TransactionText = projAdvancedJournalLine.Text;
                    break;

                case ProjOrigin::PurchaseOrder:
                    select Reason
                    from reasonTableRef
                        exists join purchTable
                        where purchTable.ReasonTableRef == reasonTableRef.RecId
                            exists join purchLine
                            where purchLine.PurchId            == purchTable.PurchId
                               && purchLine.SourceDocumentLine == _sourceDocumentLineId;

                    projTmpAccountDetailHistory.TransactionText = reasonTableRef.Reason;
                    break;

                case ProjOrigin::SalesOrder:
                case ProjOrigin::ItemJournal:
                    select firstonly Txt from projItemTrans where projItemTrans.ProjTransId == _transId;
                    projTmpAccountDetailHistory.TransactionText = projItemTrans.Txt;
                    break;

                case ProjOrigin::HourJournal:
                    select firstonly Txt from projEmplTrans where projEmplTrans.TransId == _transId;
                    projTmpAccountDetailHistory.TransactionText = projEmplTrans.Txt;
                    break;

                case ProjOrigin::FreeTextInvoice:
                case ProjOrigin::FeeJournal:
                    select firstonly Txt from projRevenueTrans where projRevenueTrans.TransId == _transId;
                    projTmpAccountDetailHistory.TransactionText = projRevenueTrans.Txt;
                    break;

                case ProjOrigin::GeneralJournal:
                    select firstOnly Txt, RecId from ledgerJournalTrans
                        join RefRecId from ledgerJournalTrans_Project
                        where ledgerJournalTrans.RecId    == ledgerJournalTrans_Project.RefRecId
                            && ledgerJournalTrans.Voucher == _voucher;
                    projTmpAccountDetailHistory.TransactionText = ledgerJournalTrans.Txt;
                    break;

                case ProjOrigin::AdvancedLedgerEntry:
                    select CategoryType from projCategory where projCategory.CategoryId ==_categoryId;
                    switch (projCategory.CategoryType)
                    {
                        case ProjCategoryType::Cost:
                            select firstonly Txt from projCostTrans where projCostTrans.TransId == _transId;
                            projTmpAccountDetailHistory.TransactionText = projCostTrans.Txt;
                            break;

                        case ProjCategoryType::Hour:
                            select firstonly Txt from projEmplTrans where projEmplTrans.TransId == _transId;
                            projTmpAccountDetailHistory.TransactionText = projEmplTrans.Txt;
                            break;

                        case ProjCategoryType::Item:
                            select firstonly Txt from projItemTrans where projItemTrans.ProjTransId == _transId;
                            projTmpAccountDetailHistory.TransactionText = projItemTrans.Txt;
                            break;

                        case ProjCategoryType::Revenue:
                            select firstonly Txt from projRevenueTrans where projRevenueTrans.TransId == _transId;
                            projTmpAccountDetailHistory.TransactionText = projRevenueTrans.Txt;
                            break;
                    }
                    break;

                case ProjOrigin::BeginningBalance:
                    select Txt from projBegBalJournalTrans where projBegBalJournalTrans.TransId == _transId;
                    projTmpAccountDetailHistory.TransactionText = projBegBalJournalTrans.Txt;
                    break;

                default:
                    return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetProjTransPostingWithDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the base query to select all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransPosting</c> table.
    /// </summary>
    /// <param name = "_ProjId">
    /// The value of project Id.
    /// </param>
    /// <returns>
    /// Returns query instance to select all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransPosting</c> table.
    /// </returns>
    protected Query buildQueryToGetProjTransPostingWithDimension(ProjId _ProjId)
    {
        Query query = new Query();
        QueryBuildDataSource projTransPostingQbds = query.addDataSource(tableNum(ProjTransPosting));
        projTransPostingQbds.addGroupByField(fieldNum(ProjTransPosting, LedgerDimension));
        projTransPostingQbds.addGroupByField(fieldNum(ProjTransPosting, DefaultDimension));
        projTransPostingQbds.addSelectionField(fieldNum(ProjTransPosting,AmountMst), SelectionField::Sum);
        projTransPostingQbds.addSelectionField(fieldNum(ProjTransPosting, LedgerDimension));
        projTransPostingQbds.addSelectionField(fieldNum(ProjTransPosting, DefaultDimension));
        //Adding the range to projTransPostingQbds
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, ProjId)).value(queryValue(_ProjId));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, CostSales)).value(queryValue(ProjCostSales::Cost));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Cost));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Item));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Hour));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, PaymentStatus)).value(queryValue(ProjPaymentStatus::Paid));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, PaymentStatus)).value(queryValue(ProjPaymentStatus::ExpectedPayment));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, PostingType)).value(strFmt('((%1 != %2) && (%1 != %3))', fieldStr(ProjTransPosting, PostingType),any2Int(LedgerPostingType::ProjNeverLedger), any2Int(LedgerPostingType::ProjNoLedger)));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, LedgerTransDate)).value(strFmt('((%1 >= %2) && (%1 <= %3))', fieldStr(ProjTransPosting, LedgerTransDate), date2StrXpp(ledgerFromDate), date2StrXpp(ledgertodate)));
        projTransPostingQbds.addRange(fieldNum(ProjTransPosting, ProjTransDate)).value(strFmt('((%1 >= %2) && (%1 <= %3))', fieldStr(ProjTransPosting, ProjTransDate), date2StrXpp(projFromDate), date2StrXpp(projToDate)));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetProjTransBudgetWithDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the base query to select all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </summary>
    /// <param name = "_ProjId">
    /// The value of project Id.
    /// </param>
    /// <returns>
    /// Returns query instance to select all the project budget transactions of type hour, expense, and item posted to the <c>ProjTransBudget</c> table.
    /// </returns>
    protected Query buildQueryToGetProjTransBudgetWithDimension(ProjId _ProjId)
    {
        Query query = new Query();
        QueryBuildDataSource projTransBudgetQbds = query.addDataSource(tableNum(ProjTransBudget));
        projTransBudgetQbds.addGroupByField(fieldNum(ProjTransBudget, LedgerDimension));
        projTransBudgetQbds.addGroupByField(fieldNum(ProjTransBudget, DefaultDimension));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, AmountMst), SelectionField::Sum);
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, LedgerDimension));
        projTransBudgetQbds.addSelectionField(fieldNum(ProjTransBudget, DefaultDimension));
        //Adding the range to projTransBudgetQbds
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(_ProjId));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, CostSales)).value(queryValue(ProjCostSales::Cost));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, PaymentStatus)).value(queryValue(ProjPaymentStatus::Paid));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, PostingType)).value(strFmt('((%1 != %2) && (%1 != %3 ))', fieldStr(ProjTransBudget, PostingType), any2Int(LedgerPostingType::ProjNeverLedger), any2Int(LedgerPostingType::ProjNoLedger)));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, LedgerTransDate)).value(strFmt('((%1 >= %2) && (%1 <= %3))', fieldStr(ProjTransBudget, LedgerTransDate), date2StrXpp(ledgerFromDate), date2StrXpp(ledgertodate)));
        projTransBudgetQbds.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(strFmt('((%1 >= %2) && (%1 <= %3))', fieldStr(ProjTransBudget, ProjTransDate), date2StrXpp(projFromDate), date2StrXpp(projToDate)));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>SortByDimensionFocus</Name>
				<Source><![CDATA[
    private void SortByDimensionFocus(ProjId _ProjId)
    {
        
        CostControlTransCommittedCost   costControlTransCommittedCost;
        QueryRun   queryRun = new  QueryRun(this.buildQueryToGetProjTransPostingWithDimension(_ProjId));

        while(queryRun.next())
        {
            ProjTransPosting projTransPosting = queryRun.get(tableNum(ProjTransPosting));
            dimensionDisplayValue = BudgetControlStatisticsManager::getDimensionFocus(
                                                LedgerDimensionFacade::serviceCreateLedgerDimension(projTransPosting.LedgerDimension, projTransPosting.DefaultDimension),
                                                                 projDimensionFocus);
            if (!dimensionFocusMap.exists(dimensionDisplayValue))
            {
                dimensionFocusMap.insert(dimensionDisplayValue,[projTransPosting.LedgerDimension,projTransPosting.DefaultDimension]);
            }
        }

        queryRun = new  QueryRun(this.buildQueryToGetProjTransBudgetWithDimension(_ProjId));
        while(queryRun.next())
        {
            ProjTransBudget projTransBudget = queryRun.get(tableNum(ProjTransBudget));
            dimensionDisplayValue = BudgetControlStatisticsManager::getDimensionFocus(
                                                LedgerDimensionFacade::serviceCreateLedgerDimension(projTransBudget.LedgerDimension, projTransBudget.DefaultDimension),
                                                                 projDimensionFocus);
            if (!dimensionFocusMap.exists(dimensionDisplayValue))
            {
                dimensionFocusMap.insert(dimensionDisplayValue,[projTransBudget.LedgerDimension,projTransBudget.DefaultDimension]);
            }
        }

        while select sum(AmountMst), DefaultDimension, LedgerDimension from costControlTransCommittedCost
            group by LedgerDimension, DefaultDimension
                   where costControlTransCommittedCost.ProjId           == _ProjId
                    &&  (costControlTransCommittedCost.ProjTransType == ProjTransType::Cost
                    ||  costControlTransCommittedCost.ProjTransType  == ProjTransType::Hour
                    ||  costControlTransCommittedCost.ProjTransType  == ProjTransType::Item)
                    &&  costControlTransCommittedCost.CommittedDate  >= ledgerFromDate
                    &&  costControlTransCommittedCost.CommittedDate  <= ledgerToDate
        {
            dimensionDisplayValue = BudgetControlStatisticsManager::getDimensionFocus(
                                                LedgerDimensionFacade::serviceCreateLedgerDimension(costControlTransCommittedCost.LedgerDimension, costControlTransCommittedCost.DefaultDimension),
                                                                 projDimensionFocus);
            if (!dimensionFocusMap.exists(dimensionDisplayValue))
            {
                dimensionFocusMap.insert(dimensionDisplayValue,[costControlTransCommittedCost.LedgerDimension,costControlTransCommittedCost.DefaultDimension]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccumulatedValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates accumulated values of Budget, Actual and Commited Cost.
    /// </summary>
    /// <param name="_transType">
    /// The transanction types of project transactions.
    /// </param>
    /// <param name="_amountMST">
    /// The amount that is utuilize to update the accumulated values of budget transactions.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The string that passed into the method was not expected.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateAccumulatedValues(String255 _transType, AmountMST _amountMST)
    {
        String255   transTypeAccount;

        switch (_transType)
        {
            case #Budget:
                projTmpAccountDetailHistory.RevisedBudget = _amountMST;
                break;
            case #Actual:
                projTmpAccountDetailHistory.Actuals = _amountMST;
                break;
            case #CommittedCost:
                projTmpAccountDetailHistory.CommittedCost = _amountMst;
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        transTypeAccount = strfmt("%1:%2:%3", #Budget, projTmpAccountDetailHistory.MainAccountId,dimensionDisplayValue);
        if (accumulatedAmountMap.exists(transTypeAccount))
        {
            projTmpAccountDetailHistory.RevisedBudget += any2real(accumulatedAmountMap.lookup(transTypeAccount));
        }

        transTypeAccount = strfmt("%1:%2:%3", #Actual, projTmpAccountDetailHistory.MainAccountId,dimensionDisplayValue);
        if (accumulatedAmountMap.exists(transTypeAccount))
        {
            projTmpAccountDetailHistory.Actuals += any2real(accumulatedAmountMap.lookup(transTypeAccount));
        }

        transTypeAccount = strfmt("%1:%2:%3", #CommittedCost, projTmpAccountDetailHistory.MainAccountId,dimensionDisplayValue);
        if (accumulatedAmountMap.exists(transTypeAccount))
        {
            projTmpAccountDetailHistory.CommittedCost += any2real(accumulatedAmountMap.lookup(transTypeAccount));
        }

        accumulatedAmountMap.insert(strfmt("%1:%2:%3", #Budget, projTmpAccountDetailHistory.MainAccountId,dimensionDisplayValue), projTmpAccountDetailHistory.RevisedBudget);
        accumulatedAmountMap.insert(strfmt("%1:%2:%3", #Actual, projTmpAccountDetailHistory.MainAccountId,dimensionDisplayValue), projTmpAccountDetailHistory.Actuals);
        accumulatedAmountMap.insert(strfmt("%1:%2:%3", #CommittedCost, projTmpAccountDetailHistory.MainAccountId,dimensionDisplayValue), projTmpAccountDetailHistory.CommittedCost);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>