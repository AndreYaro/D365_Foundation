<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventModelType_StdCost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class InventModelType_StdCost extends InventModelType
{

    // Handle for processing of inventCostTrans and
    // inventCostTrasnVariance records
    InventCostMovement          inventCostMovement;
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCostTransVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>inventCostMovement</c> class to add an <c>inventTrans</c> record to this framework.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is currently processed and must be added.
    /// </param>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher that is currently processed.
    /// </param>
    /// <param name="_transDate">
    ///    The <c>transDate</c> that is used for this process.
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> enumeration that indicates whether it is a financial or physical
    ///    update process.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates whether this method is called during a return process; optional.
    /// </param>
    /// <param name="_inventTransOrig">
    ///    The <c>inventTrans</c> record that is returned; optional.
    /// </param>
    /// <remarks>
    ///    This method interacts with the <c>inventCostMovement.addInventTrans</c> method, to pass the
    ///    <c>inventTrans</c> record over to the <c>inventCost</c> framework.
    /// </remarks>
    public void addCostTransVariance(InventTrans           _inventTrans,
                                     InventMovement        _inventMovement,
                                     Voucher               _voucher,
                                     TransDate             _transDate,
                                     InventCostTransState  _costTransState,
                                     boolean               _isReturn = false,
                                     InventTrans           _inventTransOrig = null)
    {
        // <GIN>

        super(_inventTrans,
              _inventMovement,
              _voucher,
              _transDate,
              _costTransState,
              _isReturn,
              _inventTransOrig);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            InventTransOrigin inventTransOrigin = _inventTrans.inventTransOrigin();
            if (inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderShip
                || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive
                || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderScrap)
            {
                InventTransferTable inventransferTable = InventTransferTable::find(_inventTrans.inventTransferLine().TransferId);
                if (inventransferTable.TransferType_IN == TransferType_IN::StockTransfer &&
                    !inventransferTable.StockTransferCostPriceHandlingImprovement_IN)
                {
                    return;
                }
            }
        }
        // </GIN>

        // Add this inventTrans record to the costMovement class
        this.inventCostMovement().addInventTrans(_inventTrans,
                                                 _inventMovement,
                                                 _voucher,
                                                 _transDate,
                                                 _costTransState,
                                                 _isReturn,
                                                 _inventTransOrig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>inventCostAdjust::adjustFromInventTrans</c> method to create a variance for the passed
    ///    in <c>inventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is currently processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher that is currently processed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher that is currently processed.
    /// </param>
    /// <param name="_transDate">
    ///    The <c>transDate</c> that is used for this process.
    /// </param>
    /// <param name="_adjustment">
    ///    The <c>costAmount</c> to be added as a variance.
    /// </param>
    /// <param name="_inventCostTransVarianceList">
    ///    The <c>inventCostTransVarianceList</c> that has to be added as a variance.
    /// </param>
    /// <param name="_inventAdjustmentSpec">
    ///    Specifies how the adjustment is summarized in general ledger. The default is total.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    Specifies which currency should be used for posting.
    /// </param>
    /// <remarks>
    ///    The <c>inventCostAdjust::adjustFromInventTrans</c> method is called, which provides the interface
    ///    to the <c>inventCostAdjust</c> class. This class will handle the creation of the variance for this
    ///    <c>inventTrans</c> record.
    /// </remarks>
    public void adjustCostTrans(InventTrans                 _inventTrans,
                                LedgerVoucher               _ledgerVoucher,
                                Voucher                     _voucher,
                                TransDate                   _transDate,
                                CostAmount                  _adjustment,
                                InventCostTransVarianceList  _inventCostTransVarianceList = null,
                                InventAdjustmentSpec        _inventAdjustmentSpec = InventAdjustmentSpec::Total,
                                InventTransCurrency_RU      _inventTransCurrency  = InventTransCurrency_RU::PrimaryCur)
    {
        // Create the adjustment for this inventTrans record
        // <GEERU>
        InventCostAdjust::adjustFromInventTrans(_inventTrans, _ledgerVoucher, _voucher, _transDate, _adjustment, _inventCostTransVarianceList, _inventAdjustmentSpec, _inventTransCurrency);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowOnhandAdjustment</Name>
				<Source><![CDATA[
    public boolean allowOnhandAdjustment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTransactionAdjustment</Name>
				<Source><![CDATA[
    public boolean allowTransactionAdjustment(InventTrans _inventTrans = null, InventTransOrigin _inventTransOrigin = null)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFinancialOnhandOnFinancialUpdate</Name>
				<Source><![CDATA[
    public boolean cacheFinancialOnhandOnFinancialUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFinancialOnhandOnPhysicalUpdate</Name>
				<Source><![CDATA[
    public boolean cacheFinancialOnhandOnPhysicalUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventModelGroupSetup</Name>
				<Source><![CDATA[
    protected boolean checkInventModelGroupSetup(InventModelGroupItem _inventModelGroupItem, boolean _inclConvCheck)
    {
        InventModelGroup    inventModelGroup        = _inventModelGroupItem.modelGroup();
        InventTable         inventTable             = InventTable::find(_inventModelGroupItem.ItemId);
        InventModelGroup    inventModelGroupOrig;

        switch (inventTable.ItemType)
        {
            case ItemType::Item:
                // <GEERU>
                if ((inventTransCurrency == InventTransCurrency_RU::PrimaryCur   && ! inventModelGroup.PostOnhandFinancial)          ||
                    (inventTransCurrency == InventTransCurrency_RU::SecondaryCur && ! inventModelGroup.PostOnhandFinancialSecCur_RU) ||
                    ! inventModelGroup.PostOnhandPhysical)
                    // </GEERU>
                {
                    return checkFailed(strFmt("@SYS104448"+'\n'+"@SYS104449", _inventModelGroupItem.ModelGroupId));
                }
                break;

            case ItemType::Service:
                return checkFailed("@SYS121704");
        }

        if (_inclConvCheck && !this.newInventModelType_Orig(_inventModelGroupItem).stdCostBased() && inventTable.hasInventTrans())
        {
            // <GEERU>
            if (inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
            {
                return checkFailed(strFmt("@SYS119355",
                                   inventModelGroupOrig.ModelGroupId, inventModelGroupOrig.InventModelSecCur_RU,
                                   _inventModelGroupItem.ModelGroupId, inventModelGroup.InventModelSecCur_RU, inventTable.ItemId));
            }
            // </GEERU>
            inventModelGroupOrig = _inventModelGroupItem.orig().modelGroup();
            return checkFailed(strFmt("@SYS119355",
                               inventModelGroupOrig.ModelGroupId, inventModelGroupOrig.InventModel,
                               _inventModelGroupItem.ModelGroupId, inventModelGroup.InventModel, inventTable.ItemId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delayVarianceProcess</Name>
				<Source><![CDATA[
    protected boolean delayVarianceProcess(InventOnhand _inventOnhand)
    {
        const int RoundDiffToleranceMultiFactor = 10;
        RoundOff roundOffunit = Currency::roundingPrecisionAdjusted(Ledger::accountingCurrency());
        RoundOff roundDiffTolerance = max(1, roundOffunit * RoundDiffToleranceMultiFactor);

        CostAmount postedValue = _inventOnhand.postedValue();
        InventQty postedQty = _inventOnhand.postedQty();
        CostPrice costPrice = _inventOnhand.costPricePcs(false, maxDate());
        CostAmount expectedValue = CurrencyExchangeHelper::amount(postedQty * costPrice);

        if (abs(postedValue - expectedValue) <= roundDiffTolerance)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOnHand</Name>
				<Source><![CDATA[
    public boolean checkInventOnHand(InventOnhand _inventOnhand, boolean _checkOnly = false)
    {
        InventQty postedQty = _inventOnhand.postedQty();
        CostAmount postedValue = _inventOnhand.postedValue();
        boolean setKey = true;

        if (postedQty)
        {
            try
            {
                CostPrice costPrice = _inventOnhand.costPricePcs(false, maxDate());

                if (postedValue != CurrencyExchangeHelper::amount(postedQty * costPrice))
                {
                    if (_checkOnly)
                    {
                        return false;
                    }

                    if (CostStdOnHandCheckDelayVarianceProcessDisableFlight::instance().isEnabled()
                        || !this.delayVarianceProcess(_inventOnhand))
                    {
                        CostManagementInstrumentationLogger logger =  CostManagementInstrumentationLogger::createLogger(classStr(InventModelType_StdCost));

                        InventDimId dimension;
                        ItemId item;

                        InventSum inventSum = _inventOnhand.inventSumWithoutAvailability(setKey);
                        dimension = inventSum.InventDimId;
                        item = inventSum.ItemId;
                        
                        RecId tableRecId = InventTable::find(item).RecId;

                        using (var inventModelTypeActivityContext = logger.inventModelTypeActivities().checkInventOnHand(
                            classStr(InventModelType_StdCost),
                            dimension,
                            tableRecId,
                            postedQty,
                            postedValue,
                            costPrice))
                        {
                            infolog.add(Exception::UpdateConflict, strFmt("@SCM:UpdateConflictWithInventDimId", postedValue, postedQty, costPrice, item, dimension));
                            throw Exception::UpdateConflict;
                        }
                    }
                }
            }
            catch (Exception::Error)
            {
                if (_checkOnly)
                {
                    return false;
                }
                throw Exception::Error;
            }
        }
        else if (postedValue)
        {
            if (_checkOnly)
            {
                return false;
            }
            CostManagementInstrumentationLogger logger =  CostManagementInstrumentationLogger::createLogger(classStr(InventModelType_StdCost));

            InventDimId dimension;
            ItemId item;

            InventSum inventSum = _inventOnhand.inventSumWithoutAvailability(setKey);
            dimension = inventSum.InventDimId;
            item = inventSum.ItemId;
            
            RecId tableRecId = InventTable::find(item).RecId;
            CostPrice costPrice = _inventOnhand.costPricePcs(false, maxDate());

            using (var inventModelTypeActivityContext = logger.inventModelTypeActivities().checkInventOnHand(
                classStr(InventModelType_StdCost),
                dimension,
                tableRecId,
                postedQty,
                postedValue,
                costPrice))
            {
                infolog.add(Exception::UpdateConflict, strFmt("@SCM:UpdateConflictWithInventDimId", postedValue, postedQty, costPrice, item, dimension));
                throw Exception::UpdateConflict;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemDimCostPriceChange</Name>
				<Source><![CDATA[
    protected boolean checkItemDimCostPriceChange(InventTable _inventTable)
    {
        return InventItemDimCostPriceFieldChange::newInventTable(_inventTable).checkItemDimCostPriceChange();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemUpdateLastCostPrice</Name>
				<Source><![CDATA[
    protected boolean checkItemUpdateLastCostPrice(InventTable _inventTable)
    {
        if (_inventTable.CostModel)
        {
            return checkFailed(strFmt("@SYS106229", this.inventModel()));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNewDimensionGroupsForItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the suggested new dimension groups can be used for the specified item.
    /// </summary>
    /// <param name="_inventDimGroupSetupOrig">
    ///    The original set of dimension groups for the item.
    /// </param>
    /// <param name="_inventDimGroupSetupNew">
    ///    The suggested set of new dimension groups for the item.
    /// </param>
    /// <param name="_itemId">
    ///    The item for which the validation is performed.
    /// </param>
    /// <param name="_modelGroupId">
    ///    The inventory model group for the item.
    /// </param>
    /// <returns>
    ///    true if validation is successful; otherwise, false.
    /// </returns>
    public boolean checkNewDimensionGroupsForItem(
        InventDimGroupSetup         _inventDimGroupSetupOrig,
        InventDimGroupSetup         _inventDimGroupSetupNew,
        ItemId                      _itemId,
        InventModelGroupId          _modelGroupId)
    {
        InventDimParm           inventDimParmFinancialFrom;
        InventDimParm           inventDimParmFinancialTo;

        Query                   query;

        InventDimParm           inventDimParmCriteria;

        boolean                 ret;

        ret = super(_inventDimGroupSetupOrig, _inventDimGroupSetupNew, _itemId, _modelGroupId);

        if (ret)
        {
			_inventDimGroupSetupOrig.inventDimParmActiveFinancialInventory(inventDimParmFinancialFrom);
			_inventDimGroupSetupNew.inventDimParmActiveFinancialInventory(inventDimParmFinancialTo);

			if (! InventDimParm::isInventDimParmEqual(inventDimParmFinancialFrom,inventDimParmFinancialTo))
			{
				inventDimParmCriteria.ItemIdFlag = NoYes::Yes;

				setPrefix(_inventDimGroupSetupNew.prefixString());

				List selectedDimFields = inventDimParmFinancialTo.selectedDimFields();

				query = InventSum::newQuery(query, _itemId, null, inventDimParmCriteria, inventDimParmFinancialTo,selectedDimFields);
				QueryRun queryRun = new QueryRun(query);

				while (queryRun.next()) // loop all new financial dimensions
				{
					InventSum inventSum = queryRun.get(tableNum(InventSum));
					InventDim inventDim = queryRun.get(tableNum(InventDim));

					setPrefix(  fieldLabelValue(tableNum(InventSum), fieldNum(InventSum,ItemId), inventSum.ItemId +', '+
								inventDim.preFix(selectedDimFields)));

					InventOnhand inventOnhand = InventOnhand::newParameters(_itemId,inventDim,inventDimParmFinancialTo);
					inventOnhand.parmInventSum(inventSum);

					if (! this.checkInventOnHand(inventOnhand, true))
					{
						return checkFailed("@SYS105434");
					}
				}
			}
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPricePcs</Name>
				<Source><![CDATA[
    public CostPrice costPricePcs(
        InventSum           _inventSum,
        InventModelGroup    _inventModelGroup,
        boolean             _onHandOnly = false,
        PriceDate           _priceDate  = maxDate())
    {
        if (!_inventSum.inventDim().isOwnerCurrentLegalEntity())
        {
            return 0;
        }

        return InventTable::findCostPcsPrice(_inventSum.ItemId, _inventSum.InventDimId, _inventSum.inventDim(), _priceDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCostTransVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>inventCostMovement.finalizeCostMovement</c> method, which will pass all the
    ///    <c>recordSortedLists</c> to the <c>inventCostUpdate</c> class.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The LedgerVoucher object to which the postings must be added.
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> enumeration that indicates whether it is a financial or physical
    ///    update process.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates whether this method is called during a return process; optional.
    /// </param>
    /// <returns>
    ///    true if worked successfully
    /// </returns>
    /// <remarks>
    ///    When all the records for one <c>inventMovement</c> class have been processed, this method will be
    ///    called. The call of the <c>inventCostMovement.finalizeCostMovement</c> method will pass all the
    ///    records that have been stored in the <c>inventCostMovement</c> class to the <c>inventCostUpdate</c>
    ///    class, which will keep the records in memory until the last commit is called.After this call, the
    ///    global class instance of the <c>inventCostMovement</c> class will be reset.
    /// </remarks>
    public boolean finalizeCostTransVariance(InventMovement        _inventMovement,
                                             LedgerVoucher         _ledgerVoucher,
                                             InventCostTransState  _costTransState,
                                             boolean               _isReturn = false)
    {
        // Put variances to record sorted list
        this.inventCostMovement().finalizeCostMovement(_inventMovement, _ledgerVoucher, _costTransState, _isReturn);
        // <GEERU>
        return true;
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCostTransVarianceSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>inventCostMovement.finalizeCostMovement</c> method, which will pass all the
    ///    <c>recordSortedLists</c> to the <c>inventCostUpdate</c> class.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object to which the postings needs to be added.
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> enumeration that indicates whether it is a financial or physical
    ///    update process.
    /// </param>
    /// <param name="_secondary">
    ///    True, if primary model is also "Standard cost" and thus primary cost variances are already finalized.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates whether this method is called during a return process; optional.
    /// </param>
    /// <returns>
    ///    Returns boolean flag of successful cost variance processing.
    /// </returns>
    /// <remarks>
    ///    When all the records for one <c>inventMovement</c> class have been processed, this method will be
    ///    called. The call of the <c>inventCostMovement.finalizeCostMovement</c> method will pass all the
    ///    records that have been stored in the <c>inventCostMovement</c> class to the <c>inventCostUpdate</c>
    ///    class, which will keep the records in memory until the last commit is called.
    ///    After this call, the
    ///    global class instance of the <c>inventCostMovement</c> class will be reset.
    /// </remarks>
    public boolean finalizeCostTransVarianceSecCur_RU(InventMovement        _inventMovement,
                                                      LedgerVoucher         _ledgerVoucher,
                                                      InventCostTransState  _costTransState,
                                                      boolean               _secondary,
                                                      boolean               _isReturn = false)
    {
        // Put variances to record sorted list
        this.inventCostMovement().finalizeCostMovement(_inventMovement, _ledgerVoucher, _costTransState, _isReturn, InventTransCurrency_RU::SecondaryCur, _secondary);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost value for a financial issue.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The instance of the <c>InventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record that is currently processed.
    /// </param>
    /// <param name="_inventOnhand">
    ///    The instance of the <c>InventOnHand</c> class that is currently processed.
    /// </param>
    /// <returns>
    ///    The cost value for a financial issue.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The transaction is not an issue.
    /// </exception>
    public CostAmount financialIssueCostValue(
        InventMovement   _inventMovement,
        InventTrans      _inventTrans,
        InventOnhand     _inventOnhand)
    {
        if (_inventTrans.Qty >= 0)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_inventMovement.isReturned(_inventTrans.Qty) && (_inventMovement is InventMov_Purch))
        {
            // Purchase order return without marking - use the posted amount
            return _inventTrans.CostAmountPosted;
        }

        // When called during posting CostAmountPhysical is adjusted back to the standard cost at the time the physical transaction was created.
        return _inventTrans.CostAmountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValueSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost value for a financial issue.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record that is currently processed.
    /// </param>
    /// <param name="_inventOnhand">
    ///    The <c>InventOnHand</c> class that is currently processed.
    /// </param>
    /// <returns>
    ///    The cost value for a financial issue.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    The transaction is not an issue.
    /// </exception>
    public CostAmount financialIssueCostValueSecCur_RU(
        InventMovement   _inventMovement,
        InventTrans      _inventTrans,
        InventOnhand     _inventOnhand)
    {
        if (_inventTrans.Qty >= 0)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_inventMovement.isReturned(_inventTrans.Qty) && (_inventMovement is InventMov_Purch))
        {
            // Purchase order return without marking - use the posted amount
            return _inventTrans.CostAmountSecCurPosted_RU;
        }

        // When called during posting CostAmountPhysical is adjusted back to the standard cost at the time the physical transaction was created.
        return _inventTrans.CostAmountSecCurPhysical_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialReceiptCostValue</Name>
				<Source><![CDATA[
    public CostAmount financialReceiptCostValue(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans,
        int             _returnMode)
    {
        if (_inventTrans.Qty <= 0)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_inventTrans.ProjId && _inventMovement is InventMov_Virtuel)
        {
            // When called during posting CostAmountPhysical is adjusted back to the standard cost at the time the physical transaction was created.
            return _inventTrans.CostAmountPhysical;
        }
        else
        if (_inventTrans.ReturnInventTransOrigin && (_returnMode || (_inventMovement.isReturned(_inventTrans.Qty))))
        {
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * InventModelType_StdCost::calcReturnFinancialCostPricePcs(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin));
        }

        return _inventTrans.CostAmountPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialReceiptCostValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount financialReceiptCostValueSecCur_RU(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans,
        int             _returnMode)
    {
        if (_inventTrans.Qty <= 0)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_inventTrans.ProjId && (_inventMovement is InventMov_Virtuel))
        {
            // When called during posting CostAmountPhysical is adjusted back to the standard cost at the time the physical transaction was created.
            return _inventTrans.CostAmountSecCurPhysical_RU;
        }
        else
        if (_inventTrans.ReturnInventTransOrigin && (_returnMode || (_inventMovement.isReturned(_inventTrans.Qty))))
        {
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * InventModelType_StdCost::calcReturnFinancialCostPricePcsSecCur_RU(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin), CompanyInfoHelper::secondaryCurrency_RU());
        }

        return _inventTrans.CostAmountSecCurPosted_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWarningItemDimCostPriceOff</Name>
				<Source><![CDATA[
    protected str getWarningItemDimCostPriceOff()
    {
        return "@SYS111321";
    }

]]></Source>
			</Method>
			<Method>
				<Name>htmlHelpTopic</Name>
				<Source><![CDATA[
    public str htmlHelpTopic()
    {
        return 'html/8fc791e7-f406-4a2b-bebc-eef4edb47d8f.htm';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCostTransVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the initialization of the <c>inventCostMovement</c> class instance.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher that is currently processed.
    /// </param>
    /// <param name="_transDate">
    ///    The <c>transDate</c> used for this process.
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> enumeration that indicates whether it is a financial or physical
    ///    update process.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates whether this method is called during a return process; optional.
    /// </param>
    /// <remarks>
    ///    First, the global class instance of the <c>inventCostMovement</c> class will be created. Then the
    ///    <c>inventCostMovement.initCostMovement</c> method will be called to initialize the
    ///    <c>inventCostMovement</c> class.
    /// </remarks>
    public void initCostTransVariance(InventMovement        _inventMovement,
                                      Voucher               _voucher,
                                      TransDate             _transDate,
                                      InventCostTransState  _costTransState,
                                      boolean               _isReturn = false)
    {
        super(_inventMovement, _voucher, _transDate, _costTransState, _isReturn);

        // Create instance InventCostMovement
        this.initInventCostMovement(_inventMovement);

        // Initialize parameters
        this.inventCostMovement().initCostMovement(_costTransState, _voucher, _transDate, _isReturn);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventCostMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>inventCostMovement::newFromInventMovement</c> method to create a new
    ///    <c>inventCostMovement</c> class instance.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class for which the <c>inventCostMovement</c> class will be created.
    /// </param>
    /// <remarks>
    ///    The <c>inventCostMovement::newFromInventMovement</c> provides a constructor interface for the
    ///    <c>inventCostMovement</c> class to guarantee that the correct instance will be created.
    /// </remarks>
    protected void initInventCostMovement(InventMovement      _inventMovement)
    {
        // Create InventCostMovement instance
        inventCostMovement = InventCostMovement::newFromInventMovement(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the global instance of the <c>inventCostMovement</c> class.
    /// </summary>
    /// <returns>
    ///    The global instance of the <c>inventCostMovement</c> class.
    /// </returns>
    /// <remarks>
    ///    The instance must have been initialized earlier by calling the
    ///    <c>inventModelType_StdCost.initCostTransVariance</c> method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    If the instance has not been created, the <c>inventModelType_StdCost.initCostTransVariance</c>
    ///    method has not been called.
    /// </exception>
    public InventCostMovement inventCostMovement()
    {
        if (!inventCostMovement)
        {
            // Assert, to ensure, that initCostTransVariiance has been called before.
            throw error("@SYS113363");
        }

        return inventCostMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostPriceMap</Name>
				<Source><![CDATA[
    public InventPriceMap inventCostPriceMap(
        InventTable             _inventTable,
        InventDimId             _inventDimId,
        InventTableModule       _inventTableModuleInvent    = null, // set this parameter for better performance if avail
        TransDate               _transDate                  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        InventSiteId            _newSiteId                  = '',
        boolean                 _throwError                 = false)
    {
        return InventItemPrice::stdCostFindDate(_inventTable, _transDate, _inventDimId, null, _newSiteId, _throwError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModel</Name>
				<Source><![CDATA[
    public InventModel inventModel()
    {
        return InventModel::StdCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryOwnerAllowed</Name>
				<Source><![CDATA[
    public boolean isInventoryOwnerAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettled</Name>
				<Source><![CDATA[
    public boolean isSettled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAlwaysBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean mustAlwaysBeBookedPhysically()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeClosed</Name>
				<Source><![CDATA[
    public boolean mustBeClosed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckInventOnHand</Name>
				<Source><![CDATA[
    public boolean mustCheckInventOnHand(InventSumDelta _inventSumDelta)
    {
        if (_inventSumDelta.PostedQty ||
            _inventSumDelta.PostedValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSplitInventSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>InventSettlement</c> must be split when <c>InventTrans</c> is split.
    /// </summary>
    /// <returns>
    /// true if <c>InventSettlement</c> must be split when <c>InventTrans</c> is split; otherwise, false.
    /// </returns>
    public boolean mustSplitInventSettlement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventJournalCost</Name>
				<Source><![CDATA[
    public boolean mustUpdateInventJournalCost(InventJournalType _inventJournalType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTableCostPrice</Name>
				<Source><![CDATA[
    public boolean mustUpdateInventTableCostPrice()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originalCostAmountPhysical</Name>
				<Source><![CDATA[
    public CostAmount originalCostAmountPhysical(InventTrans _inventTrans)
    {
        return _inventTrans.CostAmountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalSettlementList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns physical inventory settlement adjustments related to an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction.
    /// </param>
    /// <param name="_transDate">
    ///    The date that is used for the backdate check.
    /// </param>
    /// <returns>
    ///    A record sorted list that has inventory settlement records.
    /// </returns>
    protected RecordSortedList physicalSettlementList(
        InventTrans _inventTrans,
        TransDate   _transDate = _inventTrans.DateFinancial
        )
    {
        InventSettlement    inventSettlement;

        if (!physicalSettlementList)
        {
            physicalSettlementList = new RecordSortedList(tableNum(InventSettlement));
            physicalSettlementList.sortOrder(fieldNum(InventSettlement, RecId));

            while select inventSettlement
            where inventSettlement.TransRecId           == _inventTrans.RecId
               && inventSettlement.Cancelled            == NoYes::No
               && inventSettlement.SettleModel          == InventSettleModel::PhysicalValue
               && ( inventSettlement.OperationsPosting  == LedgerPostingType::InventStdCostRoundingVariance
               || ( inventSettlement.TransDate           > _transDate ))
               // <GEERU>
               && inventSettlement.InventTransCurrency_RU == inventTransCurrency
               // </GEERU>
            {
                 physicalSettlementList.ins(inventSettlement);
            }
        }
        return physicalSettlementList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateFinancial</Name>
				<Source><![CDATA[
    public void postUpdateFinancial(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand = null)
    {
        this.updateLedgerFinancialPriceVariance(_inventMovement, _ledgerVoucher, _inventTrans);
        this.updateLedgerRedoAdjustments(_inventMovement, _ledgerVoucher, _inventTrans);
        if (!this.skipStandardCostRounding())
        {
            this.updateLedgerFinancialRounding(_inventMovement, _ledgerVoucher, _inventTrans, _inventOnhand);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipStandardCostRounding</Name>
				<Source><![CDATA[
    protected boolean skipStandardCostRounding()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateFinancialAdjustment</Name>
				<Source><![CDATA[
    public void postUpdateFinancialAdjustment(
        InventTrans     _inventTrans,
        Voucher         _voucher,
        TransDate       _postingDate,
        CostAmount      _costAmount)
    {
        // <GEERU>
        InventSettlement inventSettlement = _inventTrans.updateStdCostPriceVarianceFin(_inventTrans.inventMovement(true),
                                                                                       _voucher,
                                                                                       _postingDate,
                                                                                       -_costAmount,
                                                                                       inventTransCurrency);
        // </GEERU>

        if (inventSettlement.CostAmountAdjustment)
        {
            inventSettlement.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdatePhysical</Name>
				<Source><![CDATA[
    public void postUpdatePhysical(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _financialInventOnhand = null)
    {
        this.updateLedgerPhysicalPriceVariance(_inventMovement, _ledgerVoucher, _inventTrans);
        this.updateLedgerRevaluation(_inventMovement, _ledgerVoucher, _inventTrans);
        this.updateLedgerPhysicalBackDate(_inventMovement, _ledgerVoucher, _inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdatePhysicalReturn</Name>
				<Source><![CDATA[
    public void postUpdatePhysicalReturn(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventTrans     _returnInventTrans)
    {
        InventSettlement    settlement;

        // Operate with ledgerVoucher transdate, because date financial is not set at this point
        TransDate transDate = _ledgerVoucher.lastTransDate();

        // Adjust the cost of the return inventrans back value at the transaction date
        boolean more = this.physicalSettlementList(_returnInventTrans, transDate).first(settlement);
        while (more)
        {
            if (!settlement.isBackDate(transDate) && !_returnInventTrans.inventTransOrigin().isPhysicalTransfer())
            {
                this.reversePhysicalSettlement(_inventMovement, _ledgerVoucher, _inventTrans, settlement);
                // <GEERU>
                if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                {
                // </GEERU>
                    _returnInventTrans.CostAmountPhysical += settlement.CostAmountAdjustment;
                // <GEERU>
                }
                else
                {
                    _returnInventTrans.CostAmountSecCurPhysical_RU += settlement.CostAmountAdjustment;
                }
                // </GEERU>
            }

            more = this.physicalSettlementList(_returnInventTrans, transDate).next(settlement);
        }
        physicalSettlementList = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateFinancial</Name>
				<Source><![CDATA[
    public void preUpdateFinancial(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand = null)
    {
        this.updateLedgerReverseAdjustments(_inventMovement, _ledgerVoucher, _inventTrans);
        _inventTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateInventTable</Name>
				<Source><![CDATA[
    public void preUpdateInventTable(InventTable _inventTable)
    {
        this.trackInventDimCombinationChange(_inventTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePhysicalSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses a physical value adjustment.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    /// <param name="_inventSettlement">
    ///    The <c>InventSettlement</c> that should be reversed.
    /// </param>
    protected void reversePhysicalSettlement(
        InventMovement   _inventMovement,
        LedgerVoucher    _ledgerVoucher,
        InventTrans      _inventTrans,
        InventSettlement _inventSettlement
        )
    {
        InventSettlement reverseSettlement = InventSettlement::reserveAdjustment(_ledgerVoucher, _inventSettlement);
        reverseSettlement.initFromInventTrans(_inventTrans, _inventSettlement.DefaultDimension);

        reverseSettlement.TransDate = InventModelType_StdCost::calcFinancialTransDate(_ledgerVoucher, _inventTrans, reverseSettlement);

        // <GEERU>
        if (reverseSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur)
        {
        // </GEERU>
            _inventTrans.CostAmountPhysical += reverseSettlement.CostAmountAdjustment;
        // <GEERU>
        }
        else
        {
            _inventTrans.CostAmountSecCurPhysical_RU += reverseSettlement.CostAmountAdjustment;
        }
        // </GEERU>

        if (_inventSettlement.Posted == NoYes::Yes)
        {
            reverseSettlement.post(_ledgerVoucher);
        }

        reverseSettlement.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>stdCostBased</Name>
				<Source><![CDATA[
    public boolean stdCostBased()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackInventDimCombinationChange</Name>
				<Source><![CDATA[
    protected void trackInventDimCombinationChange(InventTable _inventTable)
    {
        InventItemDimCostPriceFieldChange::newInventTable(_inventTable).createPrices();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancialPriceVariance</Name>
				<Source><![CDATA[
    protected void updateLedgerFinancialPriceVariance(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        // <GEERU>
        InventSettlement inventSettlement = _inventTrans.updateStdCostPriceVarianceFin(
            _inventMovement,
            _ledgerVoucher.lastVoucher(),
            _ledgerVoucher.lastTransDate(),
            inventTransCurrency == InventTransCurrency_RU::PrimaryCur
                ? _inventTrans.CostAmountPhysical          - _inventTrans.CostAmountPosted          - _inventTrans.CostAmountAdjustment
                : _inventTrans.CostAmountSecCurPhysical_RU - _inventTrans.CostAmountSecCurPosted_RU - _inventTrans.CostAmountSecCurAdjustment_RU,
            inventTransCurrency);
        // </GEERU>

        if (inventSettlement.CostAmountAdjustment)
        {
            if (_inventMovement.mustBeBookedFinancially())
            {
                inventSettlement.post(_ledgerVoucher);
            }
            inventSettlement.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancialRounding</Name>
				<Source><![CDATA[
    protected void updateLedgerFinancialRounding(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand = null)
    {
        InventDimParm       inventDimParmFinancial;
        // <GEERU>
        InventItemPrice     inventItemPrice = InventItemPrice::findCurrent(_inventMovement.itemId(), CostingVersionPriceType::Cost, _inventMovement.inventDimId(), dateMax());
        // </GEERU>
        InventOnhand        financialInventOnHand = _inventOnhand;

        // <GEERU>
        CostAmount costPcsPrice = inventTransCurrency == InventTransCurrency_RU::PrimaryCur ? inventItemPrice.pcsPrice() : inventItemPrice.pcsPriceSecCur_RU();
        // </GEERU>        
        
        if (!financialInventOnHand)
        {
            _inventMovement.inventDimGroupSetup().inventDimParmActiveFinancialInventory(inventDimParmFinancial);
            InventDim inventDimFinancial = InventDim::find(_inventTrans.InventDimId);
            inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);
            inventDimFinancial    = InventDim::findOrCreate(inventDimFinancial);
            financialInventOnHand = InventOnhand::newItemDim(_inventMovement.itemId(), inventDimFinancial, inventDimParmFinancial);
            
            //we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
            financialInventOnHand.parmDelayAvailabilityCalculation(true);
        }
        // <GEERU>
                
        CostAmount rounding = CurrencyExchangeHelper::amount(costPcsPrice * (financialInventOnHand.postedQty() + _inventTrans.Qty));
        if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
        {
             rounding -= (financialInventOnHand.postedValue()          + _inventTrans.costValue());
        }
        else
        {
             rounding -= (financialInventOnHand.postedValueSecCur_RU() + _inventTrans.costValueSecCur_RU());
        }
        // </GEERU>
        if (rounding)
        {
            if (FeatureStateProvider::isFeatureEnabled(InventStdCostRevaluationRelatedVoucherFeature::instance()))
            {
                LedgerVoucher ledgerVoucherForStdCostRevaluation = this.createLedgerVoucherForStdCostRevaluation();
                this.updateLedgerFinancialRevaluation(_inventMovement, ledgerVoucherForStdCostRevaluation, _inventTrans, inventItemPrice, rounding);
                ledgerVoucherForStdCostRevaluation.end();
                ledgerVoucherForStdCostRevaluation.createVoucherLinks(_ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate());
            }
            else
            {
                this.updateLedgerFinancialRevaluation(_inventMovement, _ledgerVoucher, _inventTrans, inventItemPrice, rounding);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancialRevaluation</Name>
				<Source><![CDATA[
    private void updateLedgerFinancialRevaluation(
        InventMovement   _inventMovement,
        LedgerVoucher    _ledgerVoucher,
        InventTrans      _inventTrans,
        InventItemPrice  _inventItemPrice,
        CostAmount _rounding)
    {
        InventSettlement financialRevaluation;

        if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
        {
            InventItemPrice preInventItemPrice = InventItemPrice::stdCostFindPrev(_inventMovement.itemId(), _inventItemPrice.InventDimId, _inventItemPrice.CreatedDateTime);
            InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
            helper.parmPreInventSettlement(InventSettlement::GetPreInventSettlementAccordingToPreInventCostTrans(preInventItemPrice, _inventTrans));
            financialRevaluation = helper.updateStdCostPriceRevaluationFin(_inventTrans,
                                                                           _inventMovement.inventTable(),
                                                                           _ledgerVoucher.lastVoucher(),
                                                                           _rounding,
                                                                           DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                                           _inventMovement,
                                                                           true,
                                                                           inventTransCurrency);
        }
        else
        {
            financialRevaluation = _inventTrans.updateStdCostPriceRevaluationFin(_inventMovement.inventTable(),
                                                                                 _ledgerVoucher.lastVoucher(),
                                                                                 _rounding,
                                                                                 DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                                                 _inventMovement,
                                                                                 true,
                                                                                 inventTransCurrency);
        }

        if (_inventMovement.mustBeBookedFinancially())
        {
            financialRevaluation.post(_ledgerVoucher);
        }
        financialRevaluation.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventStdCostRevaluationNumberSeq</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static NumberSeq getInventStdCostRevaluationNumberSeq()
    {
        NumberSeq               numberSeq;
        NumberSequenceReference numberSequenceReference;
        NumberSequenceTable     numberSequenceTable;

        numberSequenceReference = InventParameters::numRefInventStdCostRevaluationVoucherId();

        numberSequenceTable = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

        if (numberSequenceTable)
        {
            if (numberSequenceTable.Manual == NoYes::Yes)
            {
                throw error(strFmt("@SCM:NumberSequenceCannotBeManual", "@SYS104371", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()));
            }
            else
            {
                numberSeq = NumberSeq::newGetNum(numberSequenceReference);
            }
        }

        if (numberSeq == null)
        {
            throw error(strFmt("@SYS53911", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()));
        }

        return numberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherForStdCostRevaluation</Name>
				<Source><![CDATA[
    private LedgerVoucher createLedgerVoucherForStdCostRevaluation()
    {
        ttsbegin;
        NumberSeq numberSeq;
 
        numberSeq = InventModelType_StdCost::getInventStdCostRevaluationNumberSeq();
        
        InventStdCostRevaluationVoucherId voucherId = numberSeq.num();
        TransDate transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        NumberSequenceCode voucherSequence = numberSeq.parmNumberSequenceCode();

        TransactionLog::create(TransactionLogType::InventStdCostChange, voucherId);
        ttscommit;

        TransactionTxt transactionTxt  = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::InventStdCostRevaluation);
        transactionTxt.setDate(transDate);
        transactionTxt.setVoucher(voucherId);

        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                   SysModule::Invent,
                                                                   voucherSequence);
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherId,
                                                                                  transDate,
                                                                                  SysModule::Invent,
                                                                                  LedgerTransType::Invent);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);
        ledgerVoucher.parmCheckTransOnInsert(true);
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPhysicalBackDate</Name>
				<Source><![CDATA[
    protected void updateLedgerPhysicalBackDate(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        InventItemPrice         inventItemPrice;
        TransDate               previousActivationDate;
        InventDimId             inventDimId;

        InventDim inventDimCriteria  = InventItemPrice::initializeInventDimCriteria(_inventMovement.inventTable(), inventDimId, _inventMovement.inventdim());

        // <GEERU>
        CostAmount previousPcsPrice = inventTransCurrency == InventTransCurrency_RU::PrimaryCur ?
                                      _inventTrans.costPricePhysical()                          :
                                      _inventTrans.costPricePhysicalSecCur_RU();
       // </GEERU>

        InventDim inventDim = InventDim::findDim(inventDimCriteria);

        while select inventItemPrice
            order by ActivationDate, CreatedDateTime desc
            where inventItemPrice.ItemId           == _inventTrans.ItemId
               && inventItemPrice.PriceType        == CostingVersionPriceType::Cost
               && inventItemPrice.ActivationDate   > _inventTrans.DatePhysical
               && inventItemPrice.InventDimId      == inventDim.inventDimId
        {
            if (previousActivationDate == inventItemPrice.ActivationDate)
            {
                continue;
            }
            previousActivationDate  = inventItemPrice.ActivationDate;

            // <GEERU>
            Price stdPrice = inventTransCurrency == InventTransCurrency_RU::PrimaryCur ?
                                                    inventItemPrice.InventPriceMap::pcsPrice()                :
                                                    inventItemPrice.InventPriceMap::pcsPriceSecCur_RU();

            if (previousPcsPrice == stdPrice)
            // </GEERU>
            {
                continue;
            }

            // <GEERU>
            CostAmount adjustment;
            if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            {
                adjustment = CurrencyExchangeHelper::amount(_inventTrans.Qty * stdPrice) - _inventTrans.CostAmountPhysical;
            }
            else
            {
                adjustment = CurrencyExchangeHelper::amount(_inventTrans.Qty * stdPrice, CompanyInfoHelper::secondaryCurrency_RU()) - _inventTrans.CostAmountSecCurPhysical_RU;
            }

            InventSettlement physicalRevaluation;

            if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
            {
                InventItemPrice preInventItemPrice = InventItemPrice::stdCostFindPrev(inventItemPrice.ItemId, inventItemPrice.InventDimId, inventItemPrice.CreatedDateTime);
                InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
                helper.parmPreInventSettlement(InventSettlement::GetPreInventSettlementAccordingToPreInventCostTrans(preInventItemPrice, _inventTrans));
                physicalRevaluation = helper.updateStdCostPriceRevaluationPhy(_inventTrans,
                                                                              _inventMovement.inventTable(),
                                                                              _ledgerVoucher.lastVoucher(),
                                                                              // <GEERU>
                                                                              adjustment,
                                                                              // </GEERU>
                                                                              inventItemPrice.ActivationDate,
                                                                              // <GEERU>
                                                                              _inventMovement,
                                                                              inventTransCurrency);
            }
            else
            {
                // </GEERU>
                physicalRevaluation = _inventTrans.updateStdCostPriceRevaluationPhy(_inventMovement.inventTable(),
                                                                                    _ledgerVoucher.lastVoucher(),
                                                                                    // <GEERU>
                                                                                    adjustment,
                                                                                    // </GEERU>
                                                                                    inventItemPrice.ActivationDate,
                                                                                    // <GEERU>
                                                                                    _inventMovement,
                                                                                    inventTransCurrency);
                // </GEERU>
            }

            // <GEERU>
            if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur && _inventMovement.mustBeBookedPhysically())
            // </GEERU>
            {
                physicalRevaluation.post(_ledgerVoucher);
            }
            physicalRevaluation.insert();

            // <GEERU>
            previousPcsPrice = inventTransCurrency == InventTransCurrency_RU::PrimaryCur ?
                               inventItemPrice.InventPriceMap::pcsPrice()                :
                               inventItemPrice.InventPriceMap::pcsPriceSecCur_RU();
                               // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPhysicalPriceVariance</Name>
				<Source><![CDATA[
    protected void updateLedgerPhysicalPriceVariance(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        // <GEERU>
        InventSettlement inventSettlement = _inventTrans.updateStdCostPriceVariancePhy(_inventMovement, inventTransCurrency);
        // </GEERU>

        if (inventSettlement.CostAmountAdjustment)
        {
            // <GEERU>
            if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur && _inventMovement.mustBeBookedPhysically())
            // </GEERU>
            {
                inventSettlement.post(_ledgerVoucher);
            }
            inventSettlement.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerRedoAdjustments</Name>
				<Source><![CDATA[
    protected void updateLedgerRedoAdjustments(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        InventSettlement    physicalSettlement;
        InventTransOrigin   inventTransOrigin = _inventTrans.inventTransOrigin();

        ttsbegin;
        // <GEERU>
        boolean more = this.physicalSettlementList(_inventTrans, _inventTrans.DateFinancial).first(physicalSettlement);
        // </GEERU>
        while (more)
        {
            if (! inventTransOrigin.isPhysicalTransfer() || (inventTransOrigin.isPhysicalTransfer() && physicalSettlement.isBackDate(_inventTrans.DateFinancial)))
            {
                InventSettlement financialSettlement = InventSettlement::stdCostPhysical2FinancialAdjustment(_ledgerVoucher, _inventMovement, _inventTrans, physicalSettlement);
                // <GEERU>
                if (_inventMovement.mustBeBookedFinancially() &&
                    (inventTransCurrency == InventTransCurrency_RU::PrimaryCur || _inventMovement.mustBeBookedOnhandSecCur_RU()))
                // </GEERU>
                {
                    financialSettlement.post(_ledgerVoucher);
                }
                financialSettlement.insert();
                // <GEERU>

                if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                {
                // </GEERU>
                    _inventTrans.CostAmountAdjustment += financialSettlement.CostAmountAdjustment;
                    if (!financialSettlement.isBackDate(_inventTrans.DateFinancial) && ! inventTransOrigin.isPhysicalTransfer())
                    {
                        _inventTrans.CostAmountPhysical += physicalSettlement.CostAmountAdjustment;
                    }
                }
                // <GEERU>
                else
                {
                    _inventTrans.CostAmountSecCurAdjustment_RU   += financialSettlement.CostAmountAdjustment;
                    if (!financialSettlement.isBackDate(_inventTrans.DateFinancial) && ! inventTransOrigin.isPhysicalTransfer())
                    {
                        _inventTrans.CostAmountSecCurPhysical_RU += physicalSettlement.CostAmountAdjustment;
                    }
                }
            }
            more = this.physicalSettlementList(_inventTrans, _inventTrans.DateFinancial).next(physicalSettlement);
            // </GEERU>
        }
        physicalSettlementList = null;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerRevaluation</Name>
				<Source><![CDATA[
    protected void updateLedgerRevaluation(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        CostPricePcs        costPricePcs;
        // <GEERU>
        CostAmount          adjustment;
        // </GEERU>

        // <GEERU>
        if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
        {
        // </GEERU>
            costPricePcs = _inventMovement.inventTable().costPcsPrice(_inventTrans.InventDimId, _inventMovement.inventdim(), null, _inventTrans.DatePhysical, true);
        // <GEERU>
            adjustment   = CurrencyExchangeHelper::amount(_inventTrans.Qty * costPricePcs) - _inventTrans.CostAmountPhysical;
        }
        else
        {
            costPricePcs = _inventMovement.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId, _inventMovement.inventdim(), null, _inventTrans.DatePhysical, true);
            adjustment   = CurrencyExchangeHelper::amount(_inventTrans.Qty * costPricePcs, CompanyInfoHelper::secondaryCurrency_RU()) - _inventTrans.CostAmountSecCurPhysical_RU;
        }
        // </GEERU>

        InventSettlement physicalRevaluation;

        if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
        {
            InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
            helper.parmPreInventSettlement(InventSettlement::GetPreInventSettlementAccordingToPreInventCostTrans(_inventTrans.FindPreSTDItemPrice(), _inventTrans));
            physicalRevaluation = helper.updateStdCostPriceRevaluationPhy(_inventTrans,
                                                                          _inventMovement.inventTable(),
                                                                          _ledgerVoucher.lastVoucher(),
                                                                          // <GEERU>
                                                                          adjustment,
                                                                          // </GEERU>
                                                                          _ledgerVoucher.lastTransDate(),
                                                                          // <GEERU>
                                                                          _inventMovement,
                                                                          inventTransCurrency);
        }
        else
        {
            physicalRevaluation = _inventTrans.updateStdCostPriceRevaluationPhy(_inventMovement.inventTable(),
                                                                                _ledgerVoucher.lastVoucher(),
                                                                                // <GEERU>
                                                                                adjustment,
                                                                                // </GEERU>
                                                                                _ledgerVoucher.lastTransDate(),
                                                                                // <GEERU>
                                                                                _inventMovement,
                                                                                inventTransCurrency);
            // </GEERU>
        }

        if (physicalRevaluation.CostAmountAdjustment)
        {
            // <GEERU>
            if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur && _inventMovement.mustBeBookedPhysically())
            // </GEERU>
            {
                physicalRevaluation.post(_ledgerVoucher);
            }
            physicalRevaluation.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerReverseAdjustments</Name>
				<Source><![CDATA[
    protected void updateLedgerReverseAdjustments(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventTrans     _returnInventTrans = null)
    {
        InventSettlement    settlement;

        // Operate with ledgerVoucher transdate, because date financial is not set at this point
        TransDate transDate = _ledgerVoucher.lastTransDate();

        ttsbegin;
        boolean more = this.physicalSettlementList(_inventTrans, transDate).first(settlement);
        while (more)
        {
            if (_returnInventTrans)
            {
                this.reversePhysicalSettlement(_inventMovement,_ledgerVoucher,_returnInventTrans, settlement);
            }
            else if (settlement.isBackDate(transDate))
            {
                this.reversePhysicalSettlement(_inventMovement,_ledgerVoucher,_inventTrans, settlement);
            }
            else if ( ! _inventTrans.inventTransOrigin().isPhysicalTransfer())
            {
                // <GEERU>
                if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                {
                // </GEERU>
                    _inventTrans.CostAmountPhysical -= settlement.CostAmountAdjustment;
                // <GEERU>
                }
                else
                {
                    _inventTrans.CostAmountSecCurPhysical_RU -= settlement.CostAmountAdjustment;
                }
                // </GEERU>
            }

            more = this.physicalSettlementList(_inventTrans, transDate).next(settlement);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldInventTable</Name>
				<Source><![CDATA[
    public boolean validateFieldInventTable(InventTable _inventTable, FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret = true;

        switch (_fieldName)
        {
            case fieldStr(InventTable, ItemDimCostPrice):
                ret = InventItemDimCostPriceFieldChange::newInventTable(_inventTable).checkItemDimCostPriceChange();
                break;

            case fieldStr(InventTable, CostModel):
                ret = this.checkItemUpdateLastCostPrice(_inventTable);
                break;
        }

        ret = ret && super(_inventTable, _fieldName, _arrayIndex);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFinAndPhysOnHandTheSame_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that posting financial inventory and post physical inventory is enabled or disabled both.
    /// </summary>
    /// <param name="_inventModelGroup">
    ///     The <c>InventModelGroup</c> table buffer to validate.
    /// </param>
    /// <returns>
    ///     true if fields have same values; otherwise, false.
    /// </returns>
    private boolean validateFinAndPhysOnHandTheSame_RU(InventModelGroup  _inventModelGroup)
    {
        if (_inventModelGroup.PostOnhandFinancialSecCur_RU != _inventModelGroup.PostOnhandPhysical)
        {
            return checkFailed(strFmt("@GLS112126", enum2str(_inventModelGroup.InventModelSecCur_RU)));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInclPhysicValueInCostDisabled_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that include physical value in cost is disabled.
    /// </summary>
    /// <param name="_inventModelGroup">
    ///     The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    ///     true if include physical value in cost is disabled; otherwise, false.
    /// </returns>
    private boolean validateInclPhysicValueInCostDisabled_RU(InventModelGroup  _inventModelGroup)
    {
        if (_inventModelGroup.InclPhysicalValueInCost)
        {
            return checkFailed(strFmt("@SYS104453",enum2str(_inventModelGroup.InventModelSecCur_RU)));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventModelChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the inventory model group can be changed.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if if the inventory model group can be changed; otherwise, false.
    /// </returns>
    protected boolean validateInventModelChange(InventModelGroup _inventModelGroup)
    {
        if (_inventModelGroup.orig().RecId)
        {
            switch (_inventModelGroup.orig().InventModel)
            {
                case InventModel::StdCost:
                    return true;

                default:
                    if (_inventModelGroup.hasInventTrans())
                    {
                        checkFailed(strFmt("@SYS128861", _inventModelGroup.orig().InventModel, _inventModelGroup.InventModel));
                        checkFailed("@SYS128862");
                        return false;
                    }
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventModelChange_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates if the inventory model group can be changed.
    /// </summary>
    /// <param name="_inventModelGroup">
    ///     The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    ///     true if the inventory model group can be changed; otherwise, false.
    /// </returns>
    private boolean validateInventModelChange_RU(InventModelGroup _inventModelGroup)
    {
        if (_inventModelGroup.orig().RecId)
        {
            switch (_inventModelGroup.orig().InventModelSecCur_RU)
            {
                case InventModel::StdCost:
                    return true;

                default:
                    if (_inventModelGroup.hasInventTrans())
                    {
                        checkFailed(strFmt("@SYS128861", _inventModelGroup.orig().InventModelSecCur_RU, _inventModelGroup.InventModelSecCur_RU));
                        checkFailed("@SYS128862");
                        return false;
                    }
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateModelGroupHasNoService_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates if no items of type Service are associated with the inventory model group.
    /// </summary>
    /// <param name="_inventModelGroup">
    ///     The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    ///     true if no items of type Service are associated with the inventory model group; otherwise, false.
    /// </returns>
    private boolean validateModelGroupHasNoService_RU(InventModelGroup _inventModelGroup)
    {
        InventTable             inventTable;
        InventModelGroupItem    inventModelGroupItem;

        select firstonly RecId from inventTable
            where inventTable.ItemType == ItemType::Service
        exists join inventModelGroupItem
            where inventModelGroupItem.ModelGroupId         == _inventModelGroup.ModelGroupId
               && inventModelGroupItem.ModelGroupDataAreaId == _inventModelGroup.DataAreaId
               && inventModelGroupItem.ItemId               == inventTable.ItemId;

        if (inventTable.RecId)
        {
            return checkFailed(strFmt("@FPK270056", this.inventModel()));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePostOnhandFinancialEnabled_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that post financial inventory is enabled for the inventory model group.
    /// </summary>
    /// <param name="_inventModelGroup">
    ///     The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    ///     true if post financial inventory is enabled; otherwise, false.
    /// </returns>
    private boolean validatePostOnhandFinancialEnabled_RU(InventModelGroup  _inventModelGroup)
    {
        if (!_inventModelGroup.PostOnhandFinancialSecCur_RU)
        {
            return checkFailed(strFmt("@FPK270057", this.inventModel()));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStandardCostDisabled_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that standard cost parameter is disabled.
    /// </summary>
    /// <param name="_inventModelGroup">
    ///     The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    ///     true if the standard cost parameter  is disabled; otherwise, false.
    /// </returns>
    private boolean validateStandardCostDisabled_RU(InventModelGroup  _inventModelGroup)
    {
        if (_inventModelGroup.StandardCost)
        {
            return checkFailed(strFmt("@SYS104454",enum2str(_inventModelGroup.InventModelSecCur_RU)));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventItemPrice</Name>
				<Source><![CDATA[
    protected boolean validateWriteInventItemPrice(InventItemPrice _inventItemPrice)
    {
        real        zero;
        InventTable inventTable     = InventTable::find(_inventItemPrice.ItemId);

        if (_inventItemPrice.Markup
            && ! _inventItemPrice.PriceAllocateMarkup
            && _inventItemPrice.PriceType == CostingVersionPriceType::Cost)
        {
            return checkFailed(strFmt("@SYS105683",zero));
        }

        if (_inventItemPrice.RecId &&
            _inventItemPrice.PriceType  == CostingVersionPriceType::Cost &&
            FormDataUtil::isFormDataSource(_inventItemPrice) &&
            _inventItemPrice.pcsPrice()  != _inventItemPrice.orig().pcsPrice() &&
            inventTable.inventItemType().mustInventBeControlled())
        {
            if (inventTable.ItemDimCostPrice)
            {
                return (Box::okCancel("@SYS104647", DialogButton::Cancel, "@SYS6998") == DialogButton::Ok);
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventItemPriceSim</Name>
				<Source><![CDATA[
    public boolean validateWriteInventItemPriceSim(InventItemPriceSim _inventItemPriceSim)
    {
        #define.Zero(0.00)

        // <GEERU>
        if (  ((inventTransCurrency == InventTransCurrency_RU::PrimaryCur && _inventItemPriceSim.Markup)
            || (inventTransCurrency == InventTransCurrency_RU::SecondaryCur && _inventItemPriceSim.MarkupSecCur_RU))
        // </GEERU>
            && !_inventItemPriceSim.PriceAllocateMarkup
            && _inventItemPriceSim.PriceType == CostingVersionPriceType::Cost)
        {
            return checkFailed(strFmt("@SYS105683", #Zero));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroup</Name>
				<Source><![CDATA[
    public boolean validateWriteInventModelGroup(InventModelGroup  _inventModelGroup)
    {
        // <GEERU>
        if (inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
        {
            return this.validateWriteInventModelGroupSecCur_RU(_inventModelGroup);
        }
        // </GEERU>

        boolean ret = this.validateInventModelChange(_inventModelGroup);
        ret         = this.validatePostOnhandPhysicalEnabled(_inventModelGroup) && ret;
        ret         = this.validatePostOnhandFinancialEnabled(_inventModelGroup) && ret;
        ret         = this.validateInclPhysicalValueInCostDisabled(_inventModelGroup) && ret;
        ret         = this.validateStandardCostDisabled(_inventModelGroup) && ret;
        ret         = this.validateModelGroupHasNoService(_inventModelGroup) && ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroupItem</Name>
				<Source><![CDATA[
    public boolean validateWriteInventModelGroupItem(InventModelGroupItem _inventModelGroupItem, boolean _inclConvCheck = true)
    {
        boolean ret = this.checkInventModelGroupSetup(_inventModelGroupItem, _inclConvCheck);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroupSecCur_RU</Name>
				<Source><![CDATA[
    private boolean validateWriteInventModelGroupSecCur_RU(InventModelGroup  _inventModelGroup)
    {
        boolean ret = this.validateFinAndPhysOnHandTheSame_RU(_inventModelGroup);
        ret         = this.validateInventModelChange_RU(_inventModelGroup) && ret;
        ret         = this.validatePostOnhandPhysicalEnabled(_inventModelGroup) && ret;
        ret         = this.validatePostOnhandFinancialEnabled_RU(_inventModelGroup) && ret;
        ret         = this.validateInclPhysicValueInCostDisabled_RU(_inventModelGroup) && ret;
        ret         = this.validateStandardCostDisabled_RU(_inventModelGroup) && ret;
        ret         = this.validateModelGroupHasNoService_RU(_inventModelGroup) && ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventTable</Name>
				<Source><![CDATA[
    public boolean validateWriteInventTable(InventTable _inventTable)
    {
        boolean ret = this.checkItemDimCostPriceChange(_inventTable);
        ret = ret && this.checkItemUpdateLastCostPrice(_inventTable);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFinancialTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the transaction date for a settlement.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher that holds the current posting date.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is processed.
    /// </param>
    /// <param name="_inventSettlement">
    ///    The <c>inventSettlement</c> that holds the settlement for the given transaction.
    /// </param>
    /// <returns>
    ///    The current posting date, if the settlement transaction date and the date physical are equal;
    ///    otherwise, the maximum of either the current posting date or the settlement transaction date.
    /// </returns>
    public static TransDate calcFinancialTransDate(
        LedgerVoucher       _ledgerVoucher,
        InventTrans         _inventTrans,
        InventSettlement    _inventSettlement
        )
    {
        if (_inventTrans.DatePhysical == _inventSettlement.TransDate)
        {
            // Adjustments on the physical date must be moved to the financial date.
            return _ledgerVoucher.lastTransDate();
        }

        // Adjustments not on the physical date must at least be moved to the financial date.
        return max(_inventSettlement.TransDate, _ledgerVoucher.lastTransDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReturnFinancialCostPricePcs</Name>
				<Source><![CDATA[
    public static CostPricePcs calcReturnFinancialCostPricePcs(
        InventTransOriginId     _returnTransOriginId,
        InventTransOriginId     _toTransOriginId)
    {
        InventTrans     inventTrans;

        select sum(Qty),sum(CostAmountPosted) from inventTrans
            where inventTrans.InventTransOrigin         == _returnTransOriginId
               && inventTrans.StatusIssue               == StatusIssue::Sold
               && inventTrans.StatusReceipt             == StatusReceipt::None
               && inventTrans.PackingSlipReturned       == NoYes::No
               && inventTrans.ReturnInventTransOrigin   == _toTransOriginId;

        return inventTrans.Qty ? inventTrans.CostAmountPosted / inventTrans.Qty : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReturnFinancialCostPricePcsSecCur_RU</Name>
				<Source><![CDATA[
    public static CostPricePcs calcReturnFinancialCostPricePcsSecCur_RU(
        InventTransOriginId  _returnTransOriginId,
        InventTransOriginId  _toTransOriginId)
    {
        InventTrans     inventTrans;

        select sum(Qty),sum(CostAmountSecCurPosted_RU) from inventTrans
            where inventTrans.InventTransOrigin         == _returnTransOriginId
               && inventTrans.StatusIssue               == StatusIssue::Sold
               && inventTrans.StatusReceipt             == StatusReceipt::None
               && inventTrans.PackingSlipReturned       == NoYes::No
               && inventTrans.ReturnInventTransOrigin   == _toTransOriginId;

        return inventTrans.Qty ? inventTrans.CostAmountSecCurPosted_RU / inventTrans.Qty : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventModelType_StdCost construct()
    {
        return new InventModelType_StdCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueStdCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> object that is processed.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is processed.
    /// </param>
    /// <returns>
    ///    The estimated physical value for the transaction.
    /// </returns>
    public static CostAmount estimatedPhysicalValueStdCost(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans)
    {
        boolean throwErrorIfPriceNotFound()
        {
            return _inventTrans.isUpdatedPhysical() || _inventTrans.isUpdatedFinancial();
        }

        if (_inventTrans.ReturnInventTransOrigin && _inventTrans.Qty > 0 && _inventMovement.isReturned(_inventTrans.Qty))
        {
            // The sales order line that is returned will always be financially updated
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * InventModelType_StdCost::calcReturnFinancialCostPricePcs(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin));
        }
        else if (_inventTrans.isTransferReceipt() && _inventMovement.isTransfer())
        {
            // Get the cost price of the issue
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * _inventMovement.inventTable().costPcsPrice('', _inventMovement.transferIssueCostPriceInventDim(), null, _inventTrans.DatePhysical, throwErrorIfPriceNotFound()));
        }

        return CurrencyExchangeHelper::amount(_inventTrans.Qty * _inventMovement.inventTable().costPcsPrice(_inventTrans.InventDimId, _inventMovement.inventdim(), null, _inventTrans.DatePhysical, throwErrorIfPriceNotFound()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueStdCostSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> object that is processed.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is processed.
    /// </param>
    /// <returns>
    ///    The estimated physical value for the transaction.
    /// </returns>
    public static CostAmount estimatedPhysicalValueStdCostSecCur_RU(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans)
    {
        if (_inventTrans.ReturnInventTransOrigin && _inventTrans.Qty > 0 && _inventMovement.isReturned(_inventTrans.Qty))
        {
            // The sales order line that is returned will always be financially updated
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * InventModelType_StdCost::calcReturnFinancialCostPricePcsSecCur_RU(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin), CompanyInfoHelper::secondaryCurrency_RU());
        }
        else if (_inventTrans.isTransferReceipt() && _inventMovement.isTransfer())
        {
            // Get the cost price of the issue
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * _inventMovement.inventTable().costPcsPriceSecCur_RU('', _inventMovement.newMovement_TransferIssue().inventdim()), CompanyInfoHelper::secondaryCurrency_RU());
        }

        return CurrencyExchangeHelper::amount(_inventTrans.Qty * _inventMovement.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId, _inventMovement.inventdim()), CompanyInfoHelper::secondaryCurrency_RU());
    }

]]></Source>
			</Method>
			<Method>
				<Name>stdCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the standard cost value for an inventory transaction.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> object that is processed.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction record that is processed.
    /// </param>
    /// <returns>
    ///    The standard cost value for the transaction.
    /// </returns>
    public static CostAmount stdCostValue(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans)
    {
        return CurrencyExchangeHelper::amount(_inventTrans.Qty * _inventMovement.inventTable().costPcsPrice(_inventTrans.InventDimId, _inventMovement.inventdim(), null, _inventTrans.DatePhysical, true));
    }

]]></Source>
			</Method>
			<Method>
				<Name>stdCostValueSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the secondary standard cost value for an inventory transaction.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> object that is processed.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction record that is processed.
    /// </param>
    /// <returns>
    ///    The standard cost value for the transaction.
    /// </returns>
    public static CostAmount stdCostValueSecCur_RU(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans)
    {
        return CurrencyExchangeHelper::amount(_inventTrans.Qty * _inventMovement.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId, _inventMovement.inventdim(), null, _inventTrans.DatePhysical, true), CompanyInfoHelper::secondaryCurrency_RU());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>