<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecuteDisplay</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Stopwatch = System.Diagnostics.Stopwatch;
using Microsoft.Dynamics.ApplicationPlatform;

#ISOCountryRegionCodes

/// <summary>
/// The <c>WhsWorkExecuteDisplay</c> class is used to build display screens for work execution in RF device.
/// </summary>
public abstract class WhsWorkExecuteDisplay
{
    #WHSWorkExecuteControlElements
    #WHSWorkExecuteDisplayCases
    #WHSRF
    #XmlDocumentation
    #OCCRetryCount

    #define.IndexOfDataInBuildControl(5) // This is the index at which data is set in the buildControl function
    #define.IndexOfNameInBuildControl(2) // This is the index at which control name is set in the buildControl function
    #define.IndexOfErrorControlInContainer(3)

    private str warningLabel = '';

    private const str IndexOfLastUsedSerialNumber = 'LastUsedSerialNumber'; // This is the index of last serial number used in PO receiving
    protected const str ListOfSerialNumbersForReceiving = 'InventSerial%1'; // This is used to simulate a list of serial number used for receiving

    WHSWorkExecuteMode  mode;
    int                 step;

    WHSWorkLine         workLine;
    protected WHSUserId           userId;
    protected WHSRFPassthrough    pass;
    WHSWorkTable        workTable;
    boolean             addLPOverride;
    boolean             addSplitButton;
    boolean             noFullButton;
    List				olderBatchLocationList;

    Set                 passValuesToRemoveOnException;
    readonly            WhsWorkExecuteDisplayController controller = WhsWorkExecuteDisplayController::construct();
    private             WHSWorkExecuteDisplayReceivingOrderProvider receivingOrderProvider;

    private const str uomQtySeparator = ';\t';
    private WHSInstrumentationLogger instrumentationLogger;
    private int iteration = 0;
    protected boolean overrideSession;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmOverrideSession</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final boolean parmOverrideSession()
    {
        return overrideSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStep</Name>
				<Source><![CDATA[
    public int parmStep()
    {
        return step;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModeInternal</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final WHSWorkExecuteMode parmModeInternal() //Named to avoid name clash with partner code
    {
        return mode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateSessionOnError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if this flow must update the session if an error occurs.
    /// </summary>
    /// <returns>true if the session must be updated; otherwise, false.</returns>
    [Wrappable(false)]
    protected boolean mustUpdateSessionOnError()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callMustUpdateSessionOnError</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final boolean callMustUpdateSessionOnError()
    {
        return this.mustUpdateSessionOnError();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPassValuesToRemoveOnException</Name>
				<Source><![CDATA[
    public Set parmPassValuesToRemoveOnException()
    {
        return passValuesToRemoveOnException;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        // Constructor must be public as instances are created through reflection.
    }

]]></Source>
			</Method>
			<Method>
				<Name>processControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the value of a control.
    /// </summary>
    /// <param name = "_control">The the control to process.</param>
    /// <param name = "_value">The value of the control.</param>
    /// <returns>true if processing succeeded; otherwise, false.</returns>
    /// <remarks>This method is only invoked when <c>WhsRfControlData::processDataWithCallback()</c> is used instead of <c>WhsRfControlData::processData()</c>.</remarks>
    public boolean processControl(WhsControl _control, str _value)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSplitOfQuantityWhenFull</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a split of the quantity is allowed when the Full functionality is used.
    /// </summary>
    /// <param name = "_menuItem">The menu item being used.</param>
    /// <param name = "_workLine">The current work line.</param>
    /// <returns>True if split of the quantity is allowed; otherwise false.</returns>
    protected boolean allowSplitOfQuantityWhenFull(WHSRFMenuItemTable _menuItem, WHSWorkLine _workLine)
    {
        return (_menuItem.AllowFullSplit && !_workLine.ReplenDemand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLicensePlateFieldsOnPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets license plate related fields in the pass.
    /// </summary>
    /// <param name = "_licensePlateId">A license plate ID.</param>
    protected void setLicensePlateFieldsOnPass(WHSLicensePlateId _licensePlateId)
    {
        if (_licensePlateId)
        {
            pass.insert(#TargetLicensePlateId, _licensePlateId);
            pass.insert(#LicensePlateId, _licensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBlockedByReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the controls for the screen used when the remaining work is blocked by replenishment.
    /// </summary>
    /// <param name = "_workLine">The current work line.</param>
    /// <returns>The state of the form.</returns>
    protected container buildBlockedByReplenishment(WHSWorkLine _workLine)
    {
        container ret;
        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayBlockedByReplenishmentControls::ReplenishmentBlockedInstructionsLabel, "@WAX:MobileDeviceBlockByReplenishmentMessage", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFButton, #RFSkip, "@SYS89581", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret = this.addFullButton(ret);
        ret = this.addCancelButton(ret);

        pass.insert(#AddButtons, false);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildContainerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a list of container type codes to assign to the license plate.
    /// </summary>
    /// <param name="_con">
    /// Container holding RF information
    /// </param>
    /// <param name="_selected">
    /// Selected value for container type control.
    /// </param>
    /// <param name="_enabled">
    /// Determines if the control is enabled for editing or not.
    /// </param>
    /// <param name="_addEmpty">
    /// Determines if an empty entry should be added as the first container type code.
    /// </param>
    /// <returns>
    /// A container with the possible container type values.
    /// </returns>
    public container buildContainerType(
        container    _con,
        str          _selected = '',
        boolean      _enabled = true,
        boolean      _addEmpty = true)
    {
        container           ret = _con;
        boolean             first = true;
        str                 elements = '';
        WHSContainerType    containerType;
        str                 selected = _selected;

        if (_addEmpty)
        {
            elements += #ListSeparator;
        }

        while select ContainerTypeCode from containerType
        {
            if (!first)
            {
                elements += #ListSeparator;
            }
            elements += containerType.ContainerTypeCode;
            first = false;
        }

        if (!selected)
        {
            selected = WHSLicensePlate::getDefaultContainerType(pass.lookupStr(#LicensePlateId),
                                                                pass.lookup(#MenuItem),
                                                                pass.lookup(#UserId),
                                                                pass.lookupStr(#InventLocationId),
                                                                pass.lookupStr(#WMSLocationId),
                                                                pass.lookupStr(#ItemId),
                                                                WHSInventTable::find(pass.lookupStr(#ItemId)).UOMSeqGroupId,
                                                                pass.lookupStr(#UOM));
        }

        ret += [this.buildControl(#RFCombobox, #ContainerType, "@WAX1440", 1, elements, #WHSRFUndefinedDataType, '', 0, _enabled, selected ? selected : '', WHSRFColorText::Default, extendedTypeNum(WHSDefaultContainerTypeCode))];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdatedPass</Name>
				<Source><![CDATA[
    ///<summary>
    /// Correctly save the mobile device state before running confirmation process.
    /// </summary>
    /// <param name="_con">
    /// The current form state.
    /// </param>
    /// <param name="_pass">
    /// The current RF passthrough.
    /// </param>
    /// <param name="_mode">
    /// The work execution type that is running the confirmation.
    /// </param>
    /// <returns>
    /// The updated RF passthrough
    /// </returns>
    /// <remarks>
    /// If custom logic is needed to save a work mode's form state before running the
    /// confirmation dialog it can be added to this method.
    /// </remarks>
    public WHSRFPassthrough createUpdatedPass(container _con, WHSRFPassthrough _pass, WHSWorkExecuteMode _mode)
    {
        container           con = _con;
        WHSRFPassthrough    locPass = _pass;
        container           tmpFieldValues;
        WHSRFPassthrough    fieldValues;

        [con, tmpFieldValues] = WHSRFControlData::processData(con, locPass);
        fieldValues = WHSRFPassthrough::create(tmpFieldValues);

        return fieldValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBackButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Back button data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// Integer that indicates if the button is placed in a new line in the form.
    /// </param>
    /// <param name="_defaultButton">
    /// Integer that indicates if the button is the default button of the form.
    /// </param>
    /// <returns>
    /// Container containing state of the form after button is added.
    /// </returns>
    container addBackButton(container   _con,
                            int         _newLine = 1,
                            int         _defaultButton = 0)
    {
        container ret = _con;
        boolean override;
            
        if (mode == WHSWorkExecuteMode::Menu ||
            mode == WHSWorkExecuteMode::ChangeWarehouse)
        {
            override = true;
        }

        if (override ||
            (controller.canAddBackButtonForWorkType(workLine.WorkType) &&
             controller.canAddBackButtonForMode(mode)))
        {
            ret += [this.buildControl(#RFButton, #RFBack, "@SYS56453", _newLine, '', #WHSRFUndefinedDataType, '', _defaultButton)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addButtons</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds buttons to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before buttons are added.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after buttons are added.
    /// </returns>
    container addButtons(container _con)
    {
        container       ret = _con;
        boolean         createOk = true;
        boolean         createCancel = true;
        boolean         createDrop = true;
        boolean         createBack = true;
        boolean         createDone = true;
        boolean         createFull = true;
        boolean         createOverride = true;
        boolean         createSuggestLocation = true;
        boolean         createShortPick = true;
        boolean         createSkip = true;
        boolean         createOverpick = true;
        boolean         createSplitPut = true;
        boolean         createLPOverride = true;
        int             length;
        int             i = 1;
        str             controlType;
        str             name;

        if (conLen(conPeek(_con, 1)) == 2)
        {
            i = 3;
        }

        length = conLen(_con);

        for (i = i; i <= length; i++)
        {
            controlType = conPeek(conPeek(_con, i), #controlType);
            name = conPeek(conPeek(_con, i), #name);

            if (controlType == #RFButton)
            {
                switch (name)
                {
                    case #RFOK:
                        createOk = false;
                        break;

                    case #RFDone:
                        createDone = false;
                        break;

                    case #RFBack:
                        createBack = false;
                        break;

                    case #RFCancel:
                        createCancel = false;
                        break;

                    case #RFFull:
                        createFull = false;
                        break;

                    case #RFDrop:
                        createDrop = false;
                        break;

                    case #RFOverride:
                        createOverride = false;
                        break;

                    case #RFNoLocation:
                        createSuggestLocation = false;
                        break;

                    case #RFShortPick:
                        createShortPick = false;
                        break;

                    case #RFSkip:
                    case WHSWorkExecuteShowWorkLineListConstants::SkipToButton:
                        createSkip = false;
                        break;

                    case #RFOverpick:
                        createOverpick = false;
                        break;

                    case #RFSplitPut:
                        createSplitPut = false;
                        break;

                    case #RFOverrideLP:
                        createLPOverride = false;
                        break;
                }
            }
        }

        if (createOk)
        {
            ret = this.addOkButton(ret);
        }

        if (createFull)
        {
            ret = this.addFullButton(ret);
        }

        if (createDrop)
        {
            ret = this.addDropButton(ret);
        }

        if (createDone)
        {
            ret = this.addDoneButton(ret);
        }

        if (createBack)
        {
            ret = this.addBackButton(ret);
        }

        if (createCancel)
        {
            ret = this.addCancelButton(ret);
        }

        if (createSplitPut)
        {
            ret = this.addSplitPutButton(ret);
        }

        if (createLPOverride)
        {
            ret = this.addOverrideLPButton(ret);
        }

        if (createOverride)
        {
            ret = this.addOverrideButton(ret);
        }

        if (createSuggestLocation)
        {
            ret = this.addSuggestLocationButton(ret);
        }

        if (createShortPick)
        {
            ret = this.addShortPickButton(ret);
        }

        if (createOverpick)
        {
            ret = this.addOverpickButton(ret);
        }

        if (createSkip)
        {
            ret = this.addSkipButton(ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasButton</Name>
				<Source><![CDATA[
    private boolean hasButton(container _con, str _name)
    {
        int i = 1;

        if (conLen(conPeek(_con, 1)) == 2)
        {
            i = 3;
        }

        int length = conLen(_con);

        for (i = i; i <= length; ++i)
        {
            str name = conPeek(conPeek(_con, i), #name);

            if (name == _name)
            {
                str controlType = conPeek(conPeek(_con, i), #controlType);
                if (controlType == #RFButton)
                {
                    return true;
                }
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCancelButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Cancel button data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <param name="_override">
    /// Determines whether adding condition should be overridden.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addCancelButton(container _con,
                              int       _newLine = 1,
                              boolean   _override = false)
    {
        container ret = _con;

        if (_override
            || controller.canAddCancelButtonForWorkType(workLine.WorkType)
            || controller.canAddCancelButtonForMode(mode))
        {
            if (!this.hasButton(_con, #RFCancel) &&
                controller.canAddCancelButtonForWorkLine(workLine, mode, pass))
            {
                ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConsumeLPButton</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Create a button for consuming an entire license plate within the material consumption mobile device flow.
    /// </summary>
    /// <param name="_con">
    ///  A container of mobile device fields.
    /// </param>
    /// <param name="_newLine">
    ///  Defines whether the button should be on a new line or not.
    /// </param>
    /// <returns>
    ///  Returns a container with a button to consume an entire license plate.
    /// </returns>
    public container addConsumeLPButton(
        container   _con,
        int         _newLine = 1)
    {
        container   ret = _con;

        if (pass.hasValue(#LicensePlateId) &&
            controller.canAddConsumeLPButtonForMode(mode))
        {
            ret += [this.buildControl(#RFButton, #RFConsumeLP, "@WAX:ConsumeFullLP", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDoneButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Done button data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before the button is added.
    /// </param>
    /// <param name="_override">
    /// Determines whether the adding condition should be overridden.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after the button is added.
    /// </returns>
    public container addDoneButton(container _con, boolean _override = false)
    {
        container   ret = _con;

        if (_override ||
            (controller.canAddDoneButtonForMode(mode)                  &&
             controller.canAddDoneButtonForWorkType(workLine.WorkType) &&
             controller.canAddDoneButtonForStep(step)))
        {
            ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        else if (mode == WHSWorkExecuteMode::SystemGrouping &&
                 pass.exists(#AddDoneButton)                &&
                 workLine.WorkType == WHSWorkType::Pick     &&
                 step != #OverrideStep1                     &&
                 step != #OverrideStep2                     &&
                 step != #NoLocation)
        {
            ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        else if (workLine.WorkType == WHSWorkType::Pick
             &&  step              == #ShortPick
             &&  this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                     workLine.WorkType,
                                                     workLine.ItemId))
        {
            ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDropButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Drop button data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before the button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the after the button is added.
    /// </returns>
    container addDropButton(container   _con,
                            int         _newLine = 1)
    {
        container   ret = _con;

        if (controller.canAddDropButtonForWorkType(workLine.WorkType) &&
            controller.canAddDropButtonForMode(mode))
        {
            ret += [this.buildControl(#RFButton, #RFDrop, "@WAX1202", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addErrorLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Error label data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before label is added.
    /// </param>
    /// <param name="_error">
    /// Error text of the label.
    /// </param>
    /// <param name="_color">
    /// Error color of the label.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after label is added.
    /// </returns>
    container addErrorLabel(container       _con,
                            str             _error,
                            WHSRFColorText  _color = WHSRFColorText::Default)
    {
        container   ret = _con;

        ret += [this.buildControl(#RFLabel, #RFError, _error, 1, '', #WHSRFUndefinedDataType, '', 0, true, '', _color)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addErrorLabelFromInfolog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an error message from the infolog to the specified container.
    /// </summary>
    /// <param name="_con">
    /// The container to add the error to.
    /// </param>
    /// <param name="_startInfologLine">
    /// The starting line from which to retrieve the infolog message; optional.
    /// </param>
    /// <param name="_color">
    /// The color in which the message should appear; optional.
    /// </param>
    /// <returns>
    /// The container updated with the error message.
    /// </returns>
    public container addErrorLabelFromInfolog(
        container       _con,
        int             _startInfologLine   = infologLine(),
        WHSRFColorText  _color              = WHSRFColorText::Default)
    {
        return this.addErrorLabelFromInfologOrDefault('', _con, _color, _startInfologLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addErrorLabelFromInfologOrDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an error message from the infolog to the specified container. If no error found in infolog, add the default error message.
    /// </summary>
    /// <param name="_defaultErrorMessage">
    /// Default error message if none found in infolog; optional.
    /// </param>
    /// <param name="_con">
    /// The container to add the error to; optional.
    /// </param>
    /// <param name="_color">
    /// The color in which the message should appear; optional.
    /// </param>
    /// <param name="_startInfologLine">
    /// The starting line from which to retrieve the infolog message; optional.
    /// </param>
    /// <returns>
    /// The container updated with the error message.
    /// </returns>
    protected container addErrorLabelFromInfologOrDefault(
        str             _defaultErrorMessage = '',
        container       _con                = conNull(),
        WHSRFColorText  _color              = WHSRFColorText::Error,
        int             _startInfologLine   = infologLine())
    {
        str errorString = WHSWorkExecuteDisplay::parseInfoLogForErrorString(_startInfologLine);

        if (!errorString)
        {
            errorString = _defaultErrorMessage;
        }

        errorString = this.formatErrorMessage(errorString);

        return this.addErrorLabel(_con, errorString, _color);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showWarningFromPass</Name>
				<Source><![CDATA[
    private container showWarningFromPass(container _con)
    {
        if (pass.exists(WHSWorkExecuteDisplayItemReallocationControls::WarningLabel))
        {
            _con = this.addErrorLabel(_con, this.formatErrorMessage(pass.lookup(WHSWorkExecuteDisplayItemReallocationControls::WarningLabel)), WHSRFColorText::Warning);
            pass.remove(WHSWorkExecuteDisplayItemReallocationControls::WarningLabel);
        }
        return _con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parseInfoLogForErrorString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses the infolog to return the error string.
    /// </summary>
    /// <param name = "_startInfoLogLine">
    /// The line number of the infolog from where parsing should start.
    /// </param>
    /// <returns>
    /// The parsed error string.
    /// </returns>
    public static final str parseInfoLogForErrorString(int _startInfoLogLine)
    {
        str errorString;

        if (infologLine() != 0)
        {
            SysInfoLogStr currentPrefixes[];
            int currentPrefixesLength;

            for (int currentInfologLine = _startInfologLine; currentInfologLine <= infologLine(); currentInfologLine++)
            {
                SysInfologMessageStruct sysInfologMessageStruct = SysInfologMessageStruct::construct(infolog.text(currentInfologLine));

                // Iterates through the new prefix to find from where it differs from the current prefix
                int prefixDepth = 1;
                while (prefixDepth <= sysInfologMessageStruct.prefixDepth() &&
                       prefixDepth <= currentPrefixesLength &&
                       currentPrefixes[prefixDepth] == sysInfologMessageStruct.preFixTextElement(prefixDepth))
                {
                    prefixDepth++;
                }

                // Writes the remaining tabbed prefixes if needed
                while (prefixDepth <= sysInfologMessageStruct.prefixDepth())
                {
                    currentPrefixes[prefixDepth] = sysInfologMessageStruct.preFixTextElement(prefixDepth);
                    errorString += strRep(' ', prefixDepth - 1) + sysInfologMessageStruct.preFixTextElement(prefixDepth) + '\n';
                    prefixDepth++;
                }

                currentPrefixesLength = sysInfologMessageStruct.prefixDepth();

                str errorLine = strRep(' ', currentPrefixesLength) + sysInfologMessageStruct.message();
                // Writes the error message
                errorString += errorLine ? errorLine + '\n' : '';
            }
        }

        return errorString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExceptionButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Exception button data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addExceptionButton(container  _con,
                                 int        _newLine = 1)
    {
        container   ret = _con;

        if (controller.canAddExceptionButtonForMode(mode) &&
            controller.canAddExceptionButtonForStep(step) &&
            !this.hasButton(_con, #RFException))
        {
            ret += [this.buildControl(#RFButton, #RFException, "@SYS24667", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFullButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Full button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addFullButton(container _con, int _newLine = 1)
    {
        container   ret = _con;

        if (workLine.WorkType       == WHSWorkType::Pick
            && workLine.ContainerId == ''
            && controller.canAddFullButtonForStep(step)
            && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
            && (!WhsWorkExecute::isWorkLineStagingPick(workTable, workLine) || this.canShowFullButtonForStagingPickWorkLine()))
        {
            if (workLine.InventQtyWork == workLine.InventQtyRemain                      &&
                    step != #WorkAuditTemplate                                              &&
                    controller.canAddFullButtonForMode(mode)                                &&
                    WHSWorkTable::anyPicksBeforeFirstPutCompleted(workLine.WorkId)          &&
                    !this.shouldHandleByLP())
            {
                ret += [this.buildControl(#RFButton, #RFFull, "@WAX1203", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
            }
            else if (!noFullButton                                                      &&
                     !workTable.isInbound()                                                 &&
                     WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AllowFullSplit)
            {
                ret += [this.buildControl(#RFButton, #RFFull, "@WAX1203", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canShowFullButtonForStagingPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a full button can be shown if the work line is a staging pick work line.
    /// The conditions checked here are just applicable if the work line is a staging pick work line.
    /// </summary>
    /// <returns>
    /// true if the work line is not the first pick line or the work line is already partially picked; otherwise, false.
    /// </returns>
    private boolean canShowFullButtonForStagingPickWorkLine()
    {
        return !workLine.isFirstPickLineInProgress()
            || workLine.InventQtyRemain < workLine.InventQtyWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOverpickButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the over pick button if possible.
    /// </summary>
    /// <param name="_con">
    /// The container with fields currently displayed on the mobile device.
    /// </param>
    /// <param name="_newLine">
    /// Specifies if the next field on the mobile device should be on a new line.
    /// </param>
    /// <returns>
    /// The mobile device fields.
    /// </returns>
    public container addOverpickButton(container _con, int _newLine = 1)
    {
        container ret = _con;

        if (this.canAddOverpickButton())
        {
            ret += [this.buildControl(#RFButton, #RFOverpick, "@WAX:MobileDeviceOverPickUIText", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddOverpickButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the overpick button can be added to the warehouse mobile device page.
    /// </summary>
    /// <returns>true if the overpick button can be added; otherwise, false.</returns>
    [Wrappable(true)]
    internal boolean canAddOverpickButton()
    {
        if (workLine.WorkType == WHSWorkType::Pick
            && controller.canAddOverPickButtonForWorkTransType(workTable.WorkTransType)
            && controller.canAddOverPickButtonForMode(mode)
            && controller.canAddOverPickButtonForStep(step)
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).shippingOverpickEnabled(userId, workLine, workTable.WorkTransType)
            && this.canAddOverPickButtonForProdPickWork())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddOverPickButtonForProdPickWork</Name>
				<Source><![CDATA[
    private boolean canAddOverPickButtonForProdPickWork()
    {
        boolean ret = true;

        if (workTable.WorkTransType == WHSWorkTransType::ProdPick
            && WHSProductionRawMaterialOverpickingFlight::instance().isEnabled())
        {
            if (workLine.WMSLocationId == ''
                || WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
                || WhsWorkExecute::isWorkLineStagingPick(workTable, workLine)
                || WHSWorkTable::find(workLine.WorkId).InventLocationId != workTable.InventLocationId)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMoveLPButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Move LP button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addMoveLPButton(container _con, int _newLine = 1)
    {
        container ret = _con;

        if (pass.hasValue(#LicensePlateId) &&
                controller.canAddMoveLPButtonForMode(mode))
        {
            ret += [this.buildControl(#RFButton, #RFMoveLp, "@WAX1481", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOkButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds OK button to form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addOkButton(container _con,
                              int       _newLine = 1)
    {
        container   ret = _con;

        if (controller.canAddOkButtonForWorkType(workLine.WorkType)   ||
                controller.canAddOkButtonForMode(mode) &&
                controller.canAddOkButtonForStep(step))
        {
            ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", _newLine, '', #WHSRFUndefinedDataType, '', 1)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOverrideBtnAccess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the override button can be added to the warehouse mobile device page.
    /// </summary>
    /// <param name="_workType">
    /// The type of work.
    /// </param>
    /// <returns>true if the override button can be added; otherwise, false.</returns>
    internal boolean hasOverrideBtnAccess(WHSWorkType _workType)
    {
        return !this.shouldHandleByLP()
            && !pass.exists(#NoOverrideButton)
            && !pass.exists(#WorkComplete)
            && controller.canAddOverrideButtonForStep(step)
            && step != #CWOutboundWeightCapture
            && WHSWorkUser::allowOverride(pass.lookup(#UserId), _workType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOverrideButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Override button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addOverrideButton(
            container _con,
            int       _newLine = 1)
    {
        container       ret = _con;

        if (this.hasOverrideBtnAccess(workLine.WorkType))
        {
            if (workLine.WorkType == WHSWorkType::Pick)
            {
                InventLocation inventLocation = InventLocation::find(workTable.InventLocationId);

                if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
                    && WHSWorkTable::find(workLine.WorkId).InventLocationId == workTable.InventLocationId
                    && !this.isWorkProcessingModeSupportingLocationOverride())
                {
                    ret += [this.buildControl(#RFButton, #RFOverride, "@WAX:OverrideLoc", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
                }
            }
            else if (workLine.WMSLocationId)
            {
                WHSWorkTable work = workLine.whsWorkTable();
                if (!work.isReplenDemand()
                    &&  !WhsWorkExecuteDisplay::isFinalPutKanbanAutoComplete(workLine))
                {
                    ret += [this.buildControl(#RFButton, #RFOverride, "@WAX:OverrideLoc", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkProcessingModeSupportingLocationOverride</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether work processing mode is supporting location override.
    /// </summary>
    /// <returns>true if work processing mode is supporting location override; otherwise, false.</returns>
    protected boolean isWorkProcessingModeSupportingLocationOverride()
    {
        return mode == WHSWorkExecuteMode::MovementByTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addShipConfirmButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Ship confirm button to form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    protected container addShipConfirmButton(
            container _con,
            int       _newLine = 1)
    {
        container ret = _con;

        if (controller.canAddShipConfirmButtonForMode(mode)
                && controller.canAddShipConfirmButtonForAllowedShipConfirmationType(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AllowedShipConfirmationType))
        {
            ret += [this.buildControl(#RFButton, #RFShipConfirm, "@WAX:WHSRFShipConfirm", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addShortPickButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Short Pick button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    public container addShortPickButton(container _con, int _newLine = 1)
    {
        container ret = _con;

        if (this.canAddShortPickButton())
        {
            ret += [this.buildControl(#RFButton, #RFShortPick, "@WAX1322", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddShortPickButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the short pick button can be added to the warehouse mobile device page.
    /// </summary>
    /// <returns>true if the short pick button can be added; otherwise, false.</returns>
    [Wrappable(true)]
    internal boolean canAddShortPickButton()
    {
        if (controller.canAddShortPickButtonForMode(mode)
            && controller.canAddShortPickButtonForStep(step)
            && controller.canAddShortPickButtonForWorkTransType(workTable.WorkTransType)
            && !this.shouldHandleByLP()
            && this.canAddShortPickButtonForWork())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddShortPickButtonForWork</Name>
				<Source><![CDATA[
    private boolean canAddShortPickButtonForWork()
    {
        if (workLine.WorkType == WHSWorkType::Pick
            && workLine.WMSLocationId != ''
            && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
            && !WHSWorkExecute::isPotentialOverPick(workTable, workLine)
            && WHSWorkTable::find(workLine.WorkId).InventLocationId == workTable.InventLocationId)
        {
            return true;
        }

        return false;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSkipButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Skip button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addSkipButton(container   _con,
                            int         _newLine = 1)
    {
        container   ret = _con;

        if (this.shouldAddSkipButton())
        {
            if (this.useSkipToButton(workLine))
            {
                ret += [this.buildControl(#RFButton, WHSWorkExecuteShowWorkLineListConstants::SkipToButton, "@WAX:SkipTo", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
            }
            else
            {
                ret += [this.buildControl(#RFButton, #RFSkip, "@WAX3534", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAddSkipButton</Name>
				<Source><![CDATA[
    private boolean shouldAddSkipButton()
    {
        if (!controller.canAddSkipButtonForStep(step) || step == #CWOutboundWeightCapture || pass.exists(#GroupPutaway) || this.shouldHandleByLP())
        {
            return false;
        }

        if (workLine.WorkType == WHSWorkType::Put)
        {
            return !workLine.isPickLineAfter() && workLine.hasMultipleFinalPuts();
        }
        
        if (workLine.WorkType == WHSWorkType::Pick)
        {
            if (workLine.InventQtyWork == workLine.InventQtyRemain)
            {
                // Only show the Skip button for Pick's which aren't the last Pick or system directed menu items
                return mode == WHSWorkExecuteMode::SystemGrouping || !workLine.isLastRemainingPick()
                    || WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected;
            }
            else if (WHSWorkExecuteDisplayWorkLineListKeepLineNumFlight::instance().isEnabled())
            {       
                WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
                
                // Show Skip to button in case Work line list is displayed before every pick even if work line is partially picked
                return menuItemTable.ShowWorkLineList == WHSShowWorkLineList::EveryPick
                    && (mode == WHSWorkExecuteMode::SystemGrouping || menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected 
                    || !workLine.isLastRemainingPick());
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSkipToButton</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean useSkipToButton(WHSWorkLine _workLine)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOverPickScreen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds fields to over pick work to the mobile device.
    /// </summary>
    /// <param name="_con">
    /// The current mobile device screen.
    /// </param>
    /// <returns>
    /// The updated fields that should be displayed on the mobile device.
    /// </returns>
    public container buildOverPickScreen(container _con)
    {
        container           ret = _con;
        WMSLocation         location;
        WHSRFDescription1   description1;
        WHSRFDescription2   description2;
        InventDim           inventDim;
        Qty                 qty;
        UnitOfMeasureSymbol uom;

        description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        inventDim       = InventDim::find(workLine.InventDimId);
        qty             = workLine.QtyRemain;
        uom             = workLine.UnitId;

        if (workLine.wmsLocationId)
        {
            location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
        }

        ret += [this.buildControl(#RFLabel, #RFOverPick, "@WAX:MobileDeviceOverPickUIText", 1, '',#WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (workLine.ItemId)
        {
            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '',#WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(workLine.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        // Build label controls for all dimensions specified above location
        ret = this.buildAboveLocationDimensions(ret, inventDim, workLine.ItemId);

        ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1685", qty, uom), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];

        ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookupStr(#QtyToPick), extendedTypeNum(Qty), '', 0)];

        ret = this.buildUOM(ret, '', false, false, false, pass.lookupStr(#SelectedValueUOM));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSuggestLocationButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Suggest Location button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before the button is added.
    /// </param>
    /// <param name="_override">
    /// Determines whether adding condition should be skipped.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after the button is added.
    /// </returns>
    container addSuggestLocationButton(container    _con,
                                       boolean      _override = false)
    {
        container   ret = _con;

        if (step == #NoLocation || _override)
        {
            ret += [this.buildControl(#RFButton, #RFNoLocation, "@WAX1281", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTrackingDimRecUOMControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the batch UOM control to the RF container.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_label">
    ///     The label to be used for the control.
    /// </param>
    /// <param name="_elements">
    ///     The elements to be included in the combobox.
    /// </param>
    /// <param name="_selected">
    ///     A Boolean value indicating the value that must be selected from the list of available options.
    /// </param>
    /// <param name="_enabled">
    ///     A Boolean value indicating whether the control is enabled for edit.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container addTrackingDimRecUOMControl(
        container   _con,
        str         _label,
        str         _elements,
        str         _selected,
        boolean     _enabled)
    {
        container   ret = _con;
        str         label;

        label =  _label ? _label : "@WAX721";   // UOM

        if (!_enabled && _selected)
        {
            ret += [this.buildControl(#RFCombobox, #DimUOM, label, 1, _selected, #WHSRFUndefinedDataType, '', 0, _enabled, _selected, WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
        }
        else
        {
            ret += [this.buildControl(#RFCombobox, #DimUOM, label, 1, _elements, #WHSRFUndefinedDataType, '', 0, _enabled, _selected ? _selected : '', WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetFieldNameScanFieldOK</Name>
				<Source><![CDATA[
    /// <summary>Adds controls to form state for scanning system grouping field value.</summary>
    /// <param name="_con">Container containing the form state before the controls are added.</param>
    /// <param name="_extraText">Label if it should display something other than the default label.</param>
    /// <returns>Container holding the form state after the controls are added.</returns>
    protected container buildGetFieldNameScanFieldOK(
            container   _con,
            str         _extraText  = '')
    {
        container           ret             = _con;
        WHSRFSysGroupLabel  sysGroupLabel   = WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfSysGroupLabel;
        str                 finalLabel      = _extraText ? _extraText : strFmt("@WAX1988", sysGroupLabel);

        ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        if (WHSUseMobileAppSystemGroupingFieldEDTFlight::instance().isEnabled())
        {
            ret += [this.buildControl(#RFText, #Field, sysGroupLabel, 1, '', extendedTypeNum(WHSMobileAppSystemGroupingField), '', 0)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #Field, sysGroupLabel, 1, '', extendedTypeNum(Description), '', 0)];
        }
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAboveLocationDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method builds label controls on the RF screen for all dimensions above location in the reservation hierarchy.
    /// </summary>
    /// <param name="_con">
    /// A container holding all the current RF screen information
    /// </param>
    /// <param name="_inventDim">
    /// The inventDim holding values to be displayed.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which determines the reservation hierarchy, thus, determining the dimensions above location.
    /// </param>
    /// <param name="_addBatchVerification">
    /// Determines if a batch number verification control must be added. Default value is true.
    /// </param>
    /// <returns>
    /// A container with the updated RF screen information
    /// </returns>
    protected container buildAboveLocationDimensions(
        container   _con,
        InventDim   _inventDim,
        ItemId      _itemId,
        boolean     _addBatchVerification = true)
    {
        WHSReservationHierarchyProvider     reservationHierarchyProvider;
        WHSReservationHierarchyElementData  hierarchyElementData;
        container                           ret = _con;
        ListEnumerator                      le;
        FieldId                             dimFieldId;
        boolean                             displayInventStatus;

        if (_itemId)
        {
            reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
            displayInventStatus = WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfDisplayStatus;

            // Add product dimensions
            le = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId).activeFields().getEnumerator();
            while (le.moveNext())
            {
                dimFieldId = le.current();
                if (_inventDim.(dimFieldId))
                {
                    ret += this.buildDimensionControl(_inventDim, dimFieldId);
                }
            }

            InventDim workLineInventDim = workLine.inventDim();
            InventTable inventTable = InventTable::find(_itemId);

            // Add dimensions from hierarchy
            le = reservationHierarchyProvider.getDimListAboveLocationFromInventTable(
                        inventTable,
                        WHSReservationHierarchySortOrder::TopDown)
                    .getEnumerator();
            

            while (le.moveNext())
            {
                hierarchyElementData = le.current();
                dimFieldId = hierarchyElementData.parmDimensionFieldId();

                // Filter out status, warehouse and site.
                if (_inventDim.(dimFieldId)
                    && this.mustShowInventoryDimensionForItem(inventTable, dimFieldId)
                    && dimFieldId != fieldNum(InventDim, InventLocationId)
                    && dimFieldId != fieldNum(InventDim, InventSiteId)
                    && (dimFieldId != fieldNum(InventDim, InventStatusId)
                        || displayInventStatus))
                {
                    ret += this.buildDimensionControl(_inventDim, dimFieldId);

                    if (_addBatchVerification
                        &&  dimFieldId == fieldNum(InventDim, inventBatchId)
                        &&  workLineInventDim.inventBatchId)
                    {
                        ret += this.addBatchVerificationControl();
                    }

                    if (dimFieldId == fieldNum(InventDim, inventSerialId)
                        && workLineInventDim.inventSerialId)
                    {
                        ret += this.addSerialVerificationControl();
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBelowLocationDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method builds label controls on the RF screen for all flexible dimensions below location in the reservation hierarchy.
    /// </summary>
    /// <param name = "_con">A container holding all the current RF screen information.</param>
    /// <param name = "_addBatchVerification">Determines if a batch number verification control must be added. Default value is true.</param>
    /// <returns>A container with the updated RF screen information.</returns>
    protected container buildBelowLocationDimensions(container _con, boolean _addBatchVerification = true)
    {
        WHSReservationHierarchyProvider					reservationHierarchyProvider;
        WHSReservationHierarchyElementPolicyProvider	reservationHierarchyElementPolicyProvider;
        WHSReservationHierarchyElementData				hierarchyElementData;
        ListEnumerator									le;
        FieldId											dimFieldId;
        container										ret = _con;

        if (workLine.OrderCommittedInventDimId
            && workLine.ItemId)
        {
            InventDim inventDim = InventDim::find(workLine.OrderCommittedInventDimId);
            reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
            reservationHierarchyElementPolicyProvider = WHSReservationHierarchyElementPolicyProvider::singleton();
            InventTable inventTable = InventTable::find(workLine.ItemId);

            // Add dimensions from hierarchy
            le = reservationHierarchyProvider.getDimListBelowLocation(
                        inventTable,
                        WHSReservationHierarchySortOrder::TopDown)
                        .getEnumerator();

            while (le.moveNext())
            {
                hierarchyElementData = le.current();
                dimFieldId = hierarchyElementData.parmDimensionFieldId();

                // Filter out license plate
                if (inventDim.(dimFieldId)
                    && this.mustShowInventoryDimensionForItem(inventTable, dimFieldId)
                    && dimFieldId != fieldNum(InventDim, LicensePlateId)
                    && reservationHierarchyElementPolicyProvider.isReservationOnDemandOrderEnabled(inventTable.whsReservationHierarchy(), dimFieldId))
                {
                    ret += this.buildDimensionControl(inventDim, dimFieldId);

                    if (_addBatchVerification
                        &&  dimFieldId == fieldNum(InventDim, inventBatchId)
                        &&  inventDim.inventBatchId)
                    {
                        ret += this.addBatchVerificationControl();
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDimensionControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds dimension control for display.
    /// </summary>
    /// <param name = "_internalInventDim">The inventDim holding values to be displayed.</param>
    /// <param name = "_internalDimFieldId">Dimension field identifier.</param>
    /// <returns>Container containing control parameters.</returns>
    protected container buildDimensionControl(InventDim _internalInventDim, FieldId _internalDimFieldId)
    {
        return [this.buildControl(#RFLabel,
                        fieldId2name(tableNum(InventDim), _internalDimFieldId),
                        strFmt("@SYS332066", new DictField(tableNum(InventDim), _internalDimFieldId).label(), _internalInventDim.(_internalDimFieldId)),
                        1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, new DictField(tableNum(InventDim), _internalDimFieldId).typeId())];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAdjustInTrackingDimensions</Name>
				<Source><![CDATA[
    protected container buildAdjustInTrackingDimensions(
        container   _con,
        ItemId      _itemId)
    {
        container       ret = _con;
        ListEnumerator  le;
        str             dateFormat = WHSParameters::getDateFormat(pass.lookupStr(#UserId));

        InventTable inventTable = InventTable::find(_itemId);

        le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            if (!this.mustShowInventoryDimensionForItem(inventTable, le.current()))
            {
                continue;
            }

            switch (le.current())
            {
                case fieldNum(InventDim, InventBatchId):
                    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, '', extendedTypeNum(InventBatchId), '', 0)];

                    if (pass.exists(#BatchId) && pass.lookup(#BatchId) != '')
                    {
                        if (InventBatch::exist(pass.lookup(#BatchId), pass.lookup(#ItemId)))
                        {
                            ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, WhsrfControlData::convertDate2DateFormatStrCurrentUserDateCulture(InventBatch::find(pass.lookup(#BatchId), pass.lookup(#ItemId)).ExpDate, pass.lookupStr(#UserId)), extendedTypeNum(InventBatchExpDate), '', 0, false)];
                        }
                        else
                        {
                            if (!pass.exists(#ExpDate) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DefaultData)
                            {
                                ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, WHSRFDefaultData::getDefaultValue(pass.lookup(#MenuItem),
                                                                                                                                                  WHSDefaultDataField::ExpDate,
                                                                                                                                                  pass.lookup(#UserId),
                                                                                                                                                  pass.lookup(#InventLocationId),
                                                                                                                                                  pass.lookup(#WMSLocationId)), extendedTypeNum(InventBatchExpDate), '', 0)];
                            }
                            else if (InventTable::find(_itemId).isShelfLifeItem())
                            {
                                InventBatch inventBatch;

                                ttsbegin;
                                inventBatch.ItemId          = _itemId;
                                inventBatch.InventBatchId   = pass.lookupStr(#BatchId);
                                inventBatch.initializeProductionDate();
                                inventBatch.ExpDate         = inventBatch.ProdDate;
                                inventBatch.insert();
                                ttscommit;

                                ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, WHSRFControlData::convertDate2DateFormatStrCurrentUserDateCulture(inventBatch.ExpDate, pass.lookupStr(#UserId)), extendedTypeNum(InventBatchExpDate), '', 0)];
                            }
                            else
                            {
                                ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, '', extendedTypeNum(InventBatchExpDate), '', 0)];
                            }
                        }
                    }
                    break;

                case fieldNum(InventSerial, InventSerialId):
                    if (this.mustCaptureSerialOnReceipt(_itemId))
                    {
                        ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, '', extendedTypeNum(InventSerialId), '', 0)];
                    }
                    break;

                default:
                    ret += [this.buildControlForTableField(tableNum(InventDim), le.current(), fieldId2name(tableNum(InventDim), le.current()), 1, '', true)];
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAdjustmentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Adjustment Type combobox to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before the combobox is added.
    /// </param>
    /// <param name="_label">
    /// Label to be shown on combobox.
    /// </param>
    /// <param name="_showRemove">
    /// Determines whether Remove button should be shown, default value is false.
    /// </param>
    /// <param name="_showBlank">
    /// Determines whether elements of the combobox should be blank.
    /// </param>
    /// <param name="_showOK">
    /// Determines whether OK button should be shown, default value is true.
    /// </param>
    /// <param name="_selected">
    /// Selected element from the elements of combobox, default value is empty string.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after the combobox is added.
    /// </returns>
    container buildAdjustmentType(container    _con,
                                  str          _label = '',
                                  boolean      _showRemove = false,
                                  boolean      _showBlank = false,
                                  boolean      _showOK = true,
                                  str          _selected = '')
    {
        WHSAdjustmentType   adjustmentType;
        container           ret = _con;
        boolean             first = true;
        str                 elements;
        str                 label = _label ? _label : "@SYS17769";      // Adjustment Type

        if (_showBlank)
        {
            elements = '||';
        }

        while select AdjustmentTypeCode from adjustmentType
        {
            if (first)
            {
                elements += adjustmentType.AdjustmentTypeCode;
                first = false;
            }
            else
            {
                elements = elements + '||' + adjustmentType.AdjustmentTypeCode;
            }
        }

        ret += [this.buildControl(#RFCombobox, #AdjustmentType, label, 1, elements, #WHSRFUndefinedDataType, '', 0, true, _selected ? _selected : WHSRFMenuItemTable::getDefaultAdjustmentTypeCode(pass.lookup(#MenuItem)), WHSRFColorText::Default, extendedTypeNum(WHSAdjustmentTypeCode))];
        pass.insert(#SelectedAdjustmentType, _selected ? _selected : WHSRFMenuItemTable::getDefaultAdjustmentTypeCode(pass.lookup(#MenuItem)));

        if (_showRemove)
        {
            ret += [this.buildControl(#RFButton, "@SYS26394", "@WAX879", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        if (_showOK)
        {
            ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAssignSerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Assign Serial form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after controls are added.
    /// </returns>
    container buildAssignSerial(container _con, str _extraText = '')
    {
        container   ret = _con;
        str         finalLabel = _extraText ? _extraText : "@WAX3318";

        ret += [this.buildControl(#RFLabel, #Enter, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (pass.exists(#LicensePlateId))
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }

        ret += [this.buildControl(#RFText, #ItemId, "@SYS111673", 1, pass.lookupStr(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        // Build control to capture next dimension
        // No need to prompt for dimension if raw material picking in a license plate controlled location since full LP qty is picked
        ret = this.buildNextDimensionCaptureControl(ret, workLine.inventDimWithLocation(), workLine.ItemId, workLine.InventQtyRemain, true, true);

        InventTable inventTable = InventTable::find(workLine.ItemId);
        if (inventTable.isSalesProcessSerialActive())
        {
            FieldId fieldId = fieldNum(InventDim, InventSerialId);
            FieldName fieldName = fieldId2name(tableNum(InventDim), fieldId);
            DictField dictField = new DictField(tableNum(InventDim), fieldId);

            ret += [this.buildControl(
                #RFLabel,
            #SerialCounter,
            strFmt("@WAX3121", pass.lookup(#SerialCounter), pass.lookupNum(#SerialQty), inventTable.inventUnitId()),
                1, '', #WHSRFUndefinedDataType, '', 0)];

            ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0)];
        }

        ret  = this.addOkButton(ret);
        ret += [this.buildControl(#RFButton, #RFSerialUnreadable, "@SYS4030029", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchDisposition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the batch disposition control on the RF screen.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_controlName">
    ///     The name used to identify the RF control.
    /// </param>
    /// <param name="_label">
    ///     The label to be used for the RF control.
    /// </param>
    /// <param name="_editable">
    ///     A Boolean value indicating whether the control is editable.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container buildBatchDisposition(
        container       _con,
        str             _controlName = #BatchDisposition,
        str             _label = "@PRO173",
        boolean         _editable = true)
    {
        container               ret = _con;
        ItemId                  itemId;
        PdsBatchDispositionCode defaultValue;
        PdsBatchDispositionCode selectedValue;
        str                     elements;
        boolean                 showBlank;

        if (this.displayBatchDisposition())
        {
            itemId = pass.lookupStr(#ItemId);

            // Get the default batch disposition code.
            [defaultValue, showBlank] = this.getDefaultBatchDispositionCode(itemId);

            // If the batch ID has changed, reset the selected value to the default.
            if (pass.exists(#ResetBatchDisposition))
            {
                selectedValue = defaultValue;

                pass.remove(#ResetBatchDisposition);
            }
            else
            {
                selectedValue = pass.lookupStr(_controlName);
            }

            // Build the batch disposition elements.
            elements = this.buildBatchDispositionElements(showBlank);

            ret += [this.buildControl(#RFComboBox, _controlName, _label, 1, elements, #WHSRFUndefinedDataType, '', 0, _editable, selectedValue ? selectedValue : defaultValue, WHSRFColorText::Default, extendedTypeNum(PdsBatchDispositionCode))];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchDispositionElements</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a pipe-delimited string containing batch disposition values.
    /// </summary>
    /// <param name="_showBlank">
    ///     A Boolean value to indicate whether a blank value should be included in the list of available options.
    /// </param>
    /// <returns>
    ///     Returns a pipe-delimited string containing batch disposition values.
    /// </returns>
    protected str buildBatchDispositionElements(boolean _showBlank)
    {
        PdsDispositionMaster    pdsDispositionMaster;
        boolean                 first = true;
        str                     elements;

        if (_showBlank)
        {
            elements = '||';
        }
        if (pass.exists(#ItemId))
        {
            while select DispositionCode from pdsDispositionMaster
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    elements += '||';
                }

                elements += pdsDispositionMaster.DispositionCode;
            }
        }

        return elements;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchExpDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the batch expiration date control on the RF screen.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_batchId">
    ///     The batch for which the expiry date control is being constructed; optional.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container buildBatchExpDate(container _con, InventBatchId _batchId = '')
    {
        container                       ret = _con;
        str                             expDate;
        InventTable                     inventTable;
        boolean                         enabled = false;
        str                             dateFormat;

        inventTable = InventTable::find(pass.lookupStr(#ItemId));

        // For shelf life items, expiration date is calculated at registration rather than being captured through the RF.
        if (!inventTable.isShelfLifeItem())
        {
            if (pass.exists(#VendBatchInfoEntered))
            {
                expDate = pass.lookupStr(#ExpDate);
            }
            else
            {
                InventBatchId inventBatchId = (_batchId) ? _batchId : this.getInventBatchId();

                if (inventBatchId)
                {
                    expDate = WhsrfControlData::convertDate2DateFormatStrCurrentUserDateCulture(WHSWorkExecuteDisplay::getBatchExpDate(inventTable.ItemId, inventBatchId, pass.lookupStr(#ReceiptId)), pass.lookupStr(#UserId));
                }

                if (!this.itemRequiresManualDimTracking(inventTable, InventTrackingDimType::Batch))
                {
                    if (inventBatchId
                        && (pass.lookupStr(#AutoGeneratedBatchId) == inventBatchId || InventBatch::exist(inventBatchId, inventTable.ItemId)))
                    {
                        enabled = false;
                    }
                    else
                    {
                        enabled = true;
                    }
                }
                else
                {
                    enabled = !(expDate
                                || pass.lookupStr(#ExpDate)
                                || InventBatch::exist(inventBatchId, inventTable.ItemId));
                }
            }

            dateFormat = WHSParameters::getDateFormat(pass.lookupStr(#UserId));

            ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, expDate, extendedTypeNum(InventBatchExpDate), '', 0, enabled)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchOverrideIfMenuItemAllows</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If the menu item allows batch number override, build the batch control elements.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_inventBatchId">
    ///     The original inventory batch ID.
    /// </param>
    /// <param name="_licensePlateId">
    ///     The license plate ID.
    /// </param>
    /// <param name="_addLicensePlate">
    ///     A flag stating if the license plate should be added; optional.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container buildBatchOverrideIfMenuItemAllows(
        container           _con,
        InventBatchId       _inventBatchId,
        WHSLicensePlateId   _licensePlateId,
        boolean             _addLicensePlate = true)
    {
        container           ret = _con;
        InventBatchId       batchId;
        WHSRFMenuItemTable  menuItemTable;
        str                 defaultValue;
        boolean             editable = true;
        InventBatch         inventBatch;
        str                 dateFormat = WHSParameters::getDateFormat(pass.lookupStr(#UserId));
        InventTable         inventTable;

        menuItemTable = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));

        if (menuItemTable.OverrideInventBatchId
            && pass.hasValue(#ItemId)
            && InventTable::find(pass.lookup(#ItemId)).isItemBatchActivated())
        {
            inventTable = InventTable::find(pass.lookup(#ItemId));

            if (!pass.exists(#BatchId) && _inventBatchId)
            {
                pass.insert(#BatchId, _inventBatchId);
            }

            batchId = pass.lookupStr(#BatchId);

            ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0)];

            if (!inventTable.isShelfLifeItem())
            {
                inventBatch = InventBatch::find(batchId, inventTable.ItemId);

                if (inventBatch.RecId != 0 && inventBatch.ExpDate != dateNull())
                {
                    defaultValue = WHSRFControlData::convertDate2DateFormatStrCurrentUserDateCulture(inventBatch.ExpDate, pass.lookupStr(#UserId));
                    editable = false;
                }
                else if (!pass.exists(#ExpDate) && menuItemTable.DefaultData)
                {
                    defaultValue =  WHSRFDefaultData::getDefaultValue(pass.lookup(#MenuItem),
                                        WHSDefaultDataField::ExpDate,
                                        pass.lookup(#UserId),
                                        pass.lookup(#InventLocationId),
                                        pass.lookup(#WMSLocationId));
                }

                ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, defaultValue, extendedTypeNum(InventBatchExpDate), '', 0, editable)];
            }
            else if (InventBatch::exist(batchId, inventTable.ItemId))
            {
                editable = false;
            }

            // Build the batch disposition control.
            ret = this.buildBatchDisposition(ret);

            // For the sake of adding a grouping header for the potency control, we must add LP prior to adding potency on the RF screen.
            if (_addLicensePlate)
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, _licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0)];
            }

            // Build the potency control.
            ret = this.buildGetPotency(ret, batchId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildComments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Comments form state for picking details of the work.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after controls are added.
    /// </returns>
    container buildComments(container _con)
    {
        container ret = _con;

        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfDisplayPickSummary)
        {
            Counter     numOfPicks, numOfPicksReplenBlocked, numOfPicksOpen;
            Qty         inventUnits, inventUnitsReplenBlocked, inventUnitsOpen;
            Weight      totalWeight, totalWeightReplenBlocked, itemGrossWeight, totalWeightOpen;
            WHSWorkLine tmpWorkLine;

            WHSWorkId currentWorkId = workLine.WorkId;
            if (!currentWorkId)
            {
                currentWorkId = workTable.WorkId;
            }

            WHSWorkLine firstPutLine = WHSWorkTable::getFirstPutWorkLine(currentWorkId);

            while select WorkType, InventQtyWork, ItemId, ReplenDemand, WorkStatus from tmpWorkLine
                    order by LineNum
                    where tmpWorkLine.WorkId == currentWorkId
                        && tmpWorkLine.WorkType == WHSWorkType::Pick
                        && tmpWorkLine.WorkStatus != WHSWorkStatus::Cancelled
                        && tmpWorkLine.LineNum < firstPutLine.LineNum
            {
                itemGrossWeight = InventTable::find(tmpWorkLine.ItemId).grossWeight();

                ++numOfPicks;
                inventUnits += tmpWorkLine.InventQtyWork;
                totalWeight += tmpWorkLine.InventQtyWork * itemGrossWeight;

                if (tmpWorkLine.ReplenDemand == NoYes::Yes)
                {
                    ++numOfPicksReplenBlocked;
                    inventUnitsReplenBlocked += tmpWorkLine.InventQtyWork;
                    totalWeightReplenBlocked += tmpWorkLine.InventQtyWork * itemGrossWeight;
                }

                if (tmpWorkLine.WorkStatus == WHSWorkStatus::Open || tmpWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                {
                    ++numOfPicksOpen;
                    inventUnitsOpen += tmpWorkLine.InventQtyWork;
                    totalWeightOpen += tmpWorkLine.InventQtyWork * itemGrossWeight;
                }
            }
 
            ret += [this.buildControl(#RFLabel, #Comments, strFmt("@WAX2958", numOfPicksOpen, numOfPicks), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(Counter))];
            ret += [this.buildControl(#RFLabel, #CommentsNumOfPicksBlocked, strFmt("@WAX:TotalPicksBlocked", numOfPicksReplenBlocked), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(Counter))];
            ret += [this.buildControl(#RFLabel, #CommentsLinesUnit, strFmt("@WAX2959", inventUnitsOpen, inventUnits), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(Qty))];
            ret += [this.buildControl(#RFLabel, #CommentsUnitsBlocked, strFmt("@WAX:TotalUnitsBlocked", inventUnitsReplenBlocked), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(Qty))];
            ret += [this.buildControl(#RFLabel, #CommentsLinesWeight, strFmt("@WAX2960", totalWeightOpen, totalWeight), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(Weight))];
            ret += [this.buildControl(#RFLabel, #CommentsWeightBlocked, strFmt("@WAX:TotalWeightBlocked", totalWeightReplenBlocked) + '\n', 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(Weight))];
        }

        Set shipments;

        if (!workLine.WorkId)
        {
            shipments = workTable.shipmentIds();
        }
        else
        {
            shipments = workLine.whsWorkTable().shipmentIds();
        }

        SetEnumerator shipmentEnumerator = shipments.getEnumerator();
        WHSParameters parameters = WHSParameters::find();

        while (shipmentEnumerator.moveNext())
        {
            WHSShipmentTable shipmentTable = WHSShipmentTable::find(shipmentEnumerator.current());
            DocuRef docuRef;
            str     notes;
            RecId   prevDocu;

            while select Notes, RecId from docuRef
                    order by docuRef.RecId
                    where docuRef.RefCompanyId == shipmentTable.DataAreaId
                       && docuRef.RefTableId == shipmentTable.TableId
                       && docuRef.RefRecId == shipmentTable.RecId
                       && docuRef.TypeId == parameters.rfNoteType
            {
                if (prevDocu != docuRef.RecId)
                {
                    notes += docuRef.Notes;
                    notes += '\n';

                    prevDocu = docuRef.RecId;
                }
            }

            if (notes)
            {
                ret += [this.buildControl(#RFLabel, #Comments, strFmt("@WAX2500", shipmentTable.ShipmentId, '\n', notes), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSShipmentId))];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildConfirmScreen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Confirm form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before controls are added.
    /// </param>
    /// <param name="_message">
    /// Message to be displayed for confirmation.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after controls are added.
    /// </returns>
    container buildConfirmScreen(container _con, str _message)
    {
        container           ret = _con;
        WHSWorkTypeCustom   workTypeCustom;

        workTypeCustom = WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode);

        ret += [this.buildControl(#RFLabel, #Confirmation, _message, 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (workTypeCustom.CaptureData)
        {
            ret += [this.buildControl(#RFText, #Custom, workTypeCustom.rfLabel, 1, '', extendedTypeNum(Description), '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a control to be displayed on form.
    /// </summary>
    /// <param name="_controlType">
    /// Type of the control.
    /// </param>
    /// <param name="_name">
    /// Name of the control.
    /// </param>
    /// <param name="_label">
    /// Label of the control.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the control is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <param name="_data">
    /// Data of the control.
    /// </param>
    /// <param name="_inputType">
    /// Input type of the control.
    /// </param>
    /// <param name="_error">
    /// Error string of the control.
    /// </param>
    /// <param name="_defaultButton">
    /// 1 if the control is a default button, 0 otherwise.
    /// </param>
    /// <param name="_enabled">
    /// Determines whether the control is enabled or not, default value is true.
    /// </param>
    /// <param name="_selected">
    /// Selected value of the control. Useful for multiple-choice controls, default value is empty string.
    /// </param>
    /// <param name="_color">
    /// Color of the control, default value is default RF color text.
    /// </param>
    /// <param name="_dataType">
    /// Type of the label and combobox controls.
    /// </param>
    /// <returns>
    /// A container containing the state of the control.
    /// </returns>
    container buildControl(str                  _controlType,
                           str                  _name,
                           str                  _label,
                           int                  _newLine,
                           str                  _data,
                           ExtendedTypeId       _inputType,
                           str                  _error,
                           int                  _defaultButton,
                           boolean              _enabled = true,
                           str                  _selected = '',
                           WHSRFColorText       _color = WHSRFColorText::Default,
                           ExtendedTypeId       _dataType = _inputType)
    {
        container   ret         = conNull();
        int         length      = -1;
        str         typeStr     = #TypeUndefined;
        SysDictType sysTypeDict = new SysDictType(_inputType);
        Types       type;

        if (_inputType != #WHSRFUndefinedDataType && sysTypeDict)
        {
            type    = sysTypeDict.isTime() ? Types::Time : sysTypeDict.baseType();
            typeStr = enum2Symbol(enumNum(Types), type);
            if (type == Types::String)
            {
                length = sysTypeDict.stringLen();
            }
        }

        ret = [_controlType];
        ret += _name;
        ret += _label;
        ret += _newLine;
        ret += _data;
        ret += typeStr;
        ret += length;
        ret += _error == '' ? '0' : '1';
        ret += _defaultButton;
        ret += _enabled ? 1 : 0;
        ret += _selected;
        ret += #RFColorDefault;
        ret += _color;
        ret += _dataType;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFastValidationControls</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds fast validation controls to be displayed on form.
    /// </summary>
    /// <param name = "_ret">
    /// A container containing the state of the control.
    /// </param>
    /// <param name="_params">
    /// A WHSFastValidationControlsBuildParameter instance which contains all controls build parameters .
    /// </param>
    /// <returns>A container containing the state of the control.</returns>
    [Hookable(false)]
    protected container buildFastValidationControls(container _ret, WHSFastValidationControlsBuildParameters _params)
    {
        container ret = _ret;
        ret += [this.buildControl(#RFFastValidationText, '', _params.inputLabel, 1, '', _params.inputType, '', 0)];
        ret += [this.buildControl(#RFFastValidationIds, _params.inputName, _params.inputLabel, 1, con2Str(_params.data, #FastValidationListSeparator),	0, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #MsgScanFail, _params.msgScanFail, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #MsgScanSuccess, _params.msgScanSuccess, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #MsgScanDuplicated, _params.msgScanDuplicated, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #TitleListScanned, _params.titleListScanned, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #TitleListToScan, _params.titleListToScan, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #MustPlaySoundOnGoodScan, enum2Symbol(enumNum(NoYes), _params.mustPlaySoundOnGoodScan), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFFastValidationLabel, #MustPlaySoundOnBadScan, enum2Symbol(enumNum(NoYes), _params.mustPlaySoundOnBadScan), 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (_params.numOfThingsToScan > 0)
        {
            ret += [this.buildControl(#RFFastValidationLabel, #NumOfThingsToScan, int2Str(_params.numOfThingsToScan), 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        if (_params.scanTitle)
        {
            ret += [this.buildControl(#RFFastValidationLabel, #Scan, _params.scanTitle, 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildControlForTableField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a control based on a table field.
    /// </summary>
    /// <param name="_tableId">
    ///    The table ID of the field.
    /// </param>
    /// <param name="_fieldId">
    ///    The field ID.
    /// </param>
    /// <param name="_name">
    ///    The name of the control.
    /// </param>
    /// <param name="_newLine">
    ///    The new line value for the control.
    /// </param>
    /// <param name="_data">
    ///    The control value.
    /// </param>
    /// <param name="_enabled">
    ///    A Boolean value that indicates if the field is enabled.
    /// </param>
    /// <returns>
    ///    A container that represents the control.
    /// </returns>
    protected container buildControlForTableField(
        TableId _tableId,
        FieldId _fieldId,
        str     _name,
        int     _newLine,
        str     _data,
        boolean _enabled)
    {
        container   result;

        DictType    dictType = WHSWorkExecuteDisplay::dictTypeForTableField(_tableId,_fieldId);

        if (dictType)
        {
            result = this.buildControl(#RFText,_name,dictType.label(),_newLine,_data, dictType.id() ,'',0,_enabled);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCountingReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a counting reason code control.
    /// </summary>
    /// <param name = "_con">
    /// Container holding the state of the form before controls are added.
    /// </param>
    /// <param name = "_countingReasonCode">
    /// The control value.
    /// </param>
    /// <param name = "_editReasonCode">
    /// A boolean value that indicates if the field is enabled.
    /// </param>
    /// <returns>
    /// A container holding the state of the control.
    /// </returns>
    protected container buildCountingReasonCode(
            container                  _con,
            InventCountingReasonCodeId _countingReasonCode,
            WHSEditReasonCode          _editReasonCode)
    {
        InventCountingReasonCode  reasonCodes;
        str                       elements;
        container                 ret   = _con;
        boolean                   first = true;

        if (!_countingReasonCode)
        {
            elements = '||';
        }

        while select ReasonCode from reasonCodes
        {
            if (first)
            {
                elements += reasonCodes.ReasonCode;
                first    = false;
            }
            else
            {
                elements = elements + '||' + reasonCodes.ReasonCode;
            }
        }

        ret += [this.buildControl(#RFCombobox, WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode, "@SCM:InventCountingReasonCode", 1,
                                      elements, #WHSRFUndefinedDataType, '', 0, _editReasonCode,
                                      pass.hasValue(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode) ? pass.lookup(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode) : _countingReasonCode,
                                      WHSRFColorText::Default, extendedTypeNum(InventCountingReasonCodeId))];
        pass.insert(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode,
                        pass.hasValue(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode) ? pass.lookup(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode) : _countingReasonCode);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCycleCountUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Cycle Count UOM combobox data to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before controls are added.
    /// </param>
    /// <param name="_label">
    /// Label of the combobox.
    /// </param>
    /// <param name="_showBlank">
    /// Determines whether the UOM sequence group control should be blank or not.
    /// </param>
    /// <param name="_selected">
    /// Selected element from combobox.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after controls are added.
    /// </returns>
    container buildCycleCountUOM(container    _con,
                                 str          _label = '',
                                 boolean      _showBlank = false,
                                 str          _selected = '')
    {
        WHSInventTable      whsInventTable;
        WHSUOMSeqGroupLine  uomSeqGroupLine;
        container           ret = _con;
        str                 elements;
        str                 label = _label ? _label : "@WAX721";      // UOM
        int                 countUOM = 0;
        ItemId              itemId;

        if (pass.exists(#ItemId))
        {
            itemId = pass.lookup(#ItemId);
            whsInventTable = WHSInventTable::find(itemId);
        }

        if (!WHSUOMSeqGroupTable::hasCycleCountUOM(whsInventTable.uomSeqGroupId))
        {
            ret += [this.buildControl(#RFText, #CycleCountQty1, "@SYS105177", 1, pass.lookupStr(#CycleCountQty1), extendedTypeNum(Qty), '', 0)];

            elements = this.buildUOMSequenceGroupString(itemId, _showBlank);

            ret += [this.buildControl(#RFCombobox, #CycleCountUOM1, label, 0, elements, #WHSRFUndefinedDataType, '', 0, true, _selected ? _selected : '', WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
        }
        else
        {
            while select reverse UnitId from uomSeqGroupLine
                where uomSeqGroupLine.uomSeqGroupId  == whsInventTable.uomSeqGroupId  &&
                      uomSeqGroupLine.CycleCountUOM  == NoYes::Yes
            {
                if (countUOM < 4)
                {
                    switch (countUOM)
                    {
                        case 0:
                            ret += [this.buildControl(#RFText, #CycleCountQty1, strFmt("@WAX:QtyUOM", uomSeqGroupLine.UnitId), 1, pass.lookupStr(#CycleCountQty1), extendedTypeNum(Qty), '', 0)];
                            ret += [this.buildControl(#RFCombobox, #CycleCountUOM1, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId, WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
                            countUOM++;
                            break;

                        case 1:
                            ret += [this.buildControl(#RFText, #CycleCountQty2, strFmt("@WAX:QtyUOM", uomSeqGroupLine.UnitId), 1, pass.lookupStr(#CycleCountQty2), extendedTypeNum(Qty), '', 0)];
                            ret += [this.buildControl(#RFCombobox, #CycleCountUOM2, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId, WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
                            countUOM++;
                            break;

                        case 2:
                            ret += [this.buildControl(#RFText, #CycleCountQty3, strFmt("@WAX:QtyUOM", uomSeqGroupLine.UnitId), 1, pass.lookupStr(#CycleCountQty3), extendedTypeNum(Qty), '', 0)];
                            ret += [this.buildControl(#RFCombobox, #CycleCountUOM3, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId, WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
                            countUOM++;
                            break;

                        case 3:
                            ret += [this.buildControl(#RFText, #CycleCountQty4, strFmt("@WAX:QtyUOM", uomSeqGroupLine.UnitId), 1, pass.lookupStr(#CycleCountQty4), extendedTypeNum(Qty), '', 0)];
                            ret += [this.buildControl(#RFCombobox, #CycleCountUOM4, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId, WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
                            countUOM++;
                            break;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDispositon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a list of disposition codes to be used within the RF
    /// </summary>
    /// <param name="_con">
    /// Container holding RF information
    /// </param>
    /// <param name="_selected">
    /// Selected value for disposition control
    /// </param>
    /// <param name="_enabled">
    /// Determines if control is enabled or not
    /// </param>
    /// <param name="_addEmpty">
    /// Determines if an empty entry should be added as the first disposition code
    /// </param>
    /// <returns>
    /// Container with disposition values
    /// </returns>
    public container buildDispositon(
        container    _con,
        str          _selected = '',
        boolean      _enabled = true,
        boolean      _addEmpty = false)
    {
        container           ret = _con;       
        str                 elements;       
        WHSDispositionCode  dispositionCode;
        str                 selected = _selected;
        WHSRFMenuItemTable  menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        var orderProvider = this.receivingOrderProvider(false);
        WHSMobileAppDispositionCodeControlOptionsBuilder dispositionCodesBuilder = WHSMobileAppDispositionCodeControlOptionsBuilder::newFromParams(
            mode,
            menuItemTable.MixedLPReceivingMode,
            orderProvider ? orderProvider.workTransType() : WHSWorkTransType::None);
        dispositionCodesBuilder.parmAddEmpty(_addEmpty);

        elements = dispositionCodesBuilder.availableDispositionCodes();        

        if (menuItemTable.DefaultData)
        {
            dispositionCode = WHSRFDefaultData::getDefaultValue(pass.lookup(#MenuItem),
                                                                WHSDefaultDataField::Disposition,
                                                                pass.lookup(#UserId),
                                                                pass.lookupStr(#InventLocationId),
                                                                pass.lookupStr(#WMSLocationId));
        }

        if (!selected && dispositionCode)
        {
            selected = dispositionCode;
        }

        ret += [this.buildControl(#RFCombobox, #Disposition, "@WAX1841", 1, elements, #WHSRFUndefinedDataType, '', 0, _enabled, selected ? selected : '', WHSRFColorText::Default, extendedTypeNum(WHSDispositionCode))];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetBatchLoop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls for batch picking to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before controls are added.
    /// </param>
    /// <param name="_defaultQty">
    /// Default picking quantity.
    /// </param>
    /// <param name="_extraText">
    /// Text of the label.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after controls are added.
    /// </returns>
    container buildGetBatchLoop(container     _con,
                                Qty           _defaultQty,
                                str           _extraText = '')
    {
        container       ret = _con;
        WMSLocation     location;

        location = WMSLocation::find(pass.lookup(#WMSLocationId), pass.lookup(#InventLocationId));

        ret += [this.buildControl(#RFLabel, #BatchLoop, "@WAX2009", 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (location.whsLocationIsLPControlled())
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        }

        if (_defaultQty)
        {
            ret += [this.buildControl(#RFText, #BatchQtyToPick, "@WAX2011", 1, WHSWorkExecuteDisplay::num2StrDisplay(_defaultQty), extendedTypeNum(Qty), '', 0, false)];
            ret += [this.buildControl(#RFText, #BatchQtyPicked, "@WAX2012", 1, '0', extendedTypeNum(Qty), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #BatchQtyToPick, "@WAX2011", 1, pass.lookup(#BatchQtyToPick), extendedTypeNum(Qty), '', 0, false)];
            ret += [this.buildControl(#RFText, #BatchQtyPicked, "@WAX2011", 1, pass.lookup(#BatchQtyPicked), extendedTypeNum(Qty), '', 0, false)];
        }

        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, '', extendedTypeNum(InventBatchId), '', 0)];

        ret = this.addOkButton(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetFullQtyWithError</Name>
				<Source><![CDATA[
    private container buildGetFullQtyWithError(
            container _con,
            str       _errorText)
    {
        container ret;

        ret += this.addErrorLabel(_con, _errorText, WHSRFColorText::Error);
        ret += [this.buildControl(#RFLabel, #Enter, "@WAX727", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #FullQty, "@WAX1327", 1, '', extendedTypeNum(Qty), _errorText, 0, true, '', WHSRFColorText::Error)];
        ret  = this.buildGetFullQtyBody(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetFullQtyBody</Name>
				<Source><![CDATA[
    private container buildGetFullQtyBody(container _con)
    {
        container ret = _con;

        InventHandlingUnitId inventHandlingUnit = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);
        InventQty inventRemainQty = workLine.InventQtyRemain;

        if (WHSEnableFullQtyGroupPickFlight::instance().isEnabled() && pass.isGroupPick())
        {
            inventRemainQty = WHSGroupPickLineDetails::newFromWorkLine(workLine).inventQty;
        }

        if (inventHandlingUnit == workLine.UnitId)
        {
            ret += [this.buildControl(#RFLabel, #UOM, inventHandlingUnit, 0, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
            ret += [this.buildControl(#RFLabel,
                                          #RFQtyLabel,
            strFmt("@WAX2611", inventRemainQty, inventHandlingUnit),
                                          1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
        }
        else
        {
            str uomsToConfirm = this.buildUOMSequenceGroupString(workLine.ItemId, false);
            str selectedUOM;

            if (WHSBuildGetFullQtyBodyPiecePickingUseInventUOMFlight::instance().isEnabled())
            {
                selectedUOM = this.calculateFullQtyBodySelectedUOM(inventHandlingUnit);
            }
            else
            {
                selectedUOM = pass.lookupStr(#SelectedValueUOM) == '' ? workLine.UnitId : pass.lookupStr(#SelectedValueUOM);
            }

            ret += [this.buildControl(#RFCombobox, #UOM, "@WAX721", 1, uomsToConfirm, #WHSRFUndefinedDataType, '', 0, true,  selectedUOM)];
            ret += [this.buildControl(#RFLabel,
                                          #RFQtyLabel,
            strFmt("@WAX:MobileDevice_CurrentQtyLeftToPickWorkAndInventUnit_Message",
                                                 inventRemainQty,
                                                 inventHandlingUnit,
                                                 uomQtySeparator,
                                                 workLine.QtyRemain,
                                                 workLine.UnitId),
                                          1, '', #WHSRFUndefinedDataType, '', 0, true, '', WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFullQtyBodySelectedUOM</Name>
				<Source><![CDATA[
    private str calculateFullQtyBodySelectedUOM(InventHandlingUnitId _inventHandlingUnit)
    {
        if (pass.lookupStr(#SelectedValueUOM) != '')
        {
            return pass.lookupStr(#SelectedValueUOM);
        }
        else if (pass.parmPiecesConfirmed() != 0)
        {
            // If PiecesConfirmed has a value, it indicates piece picking is used, in which case FullQty is always in the inventory units.
            return _inventHandlingUnit;
        }
        else
        {
            return workLine.UnitId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetFullQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for getting full quantity from user.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after controls are added.
    /// </returns>
    public container buildGetFullQty(
            container _con,
            str      _extraText = '')
    {
        container   ret = _con;
        str         finalLabel = _extraText ? _extraText : "@WAX727";     // Enter a Quantity

        ret += [this.buildControl(#RFLabel, #Enter, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        if (WhsWorkExecute::isWorkLineStagingPick(workTable, workLine))
        {
            ret += [this.buildControl(#RFText, #FullQty, "@WAX1327", 1, '0', extendedTypeNum(Qty), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #FullQty, "@WAX1327", 1, pass.lookupStr(#FullQty), extendedTypeNum(Qty), '', 0, true)];
        }
        ret  = this.buildGetFullQtyBody(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorText</Name>
				<Source><![CDATA[
    private str getErrorText(container _con)
    {
        int     length = conLen(_con);
        int     offset = 3;

        while (offset <= length)
        {
            if (conPeek(conPeek(_con, offset), #controlType) == #RFLabel
                    && conPeek(conPeek(_con, offset), #name) == #RFError)
            {
                return conPeek(conPeek(_con, offset), #label);
            }

            offset++;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for getting item id from user.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after controls are added.
    /// </returns>
    container buildGetItemId(container _con, str _extraText = '')
    {
        container           ret = _con;
        str                 finalLabel = _extraText ? _extraText : "@WAX720";     // Enter an ItemId
        InventTable         inventTable;

        inventTable = InventTable::find(pass.lookupStr(#ItemId));

        ret += [this.buildControl(#RFLabel, #Enter, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #ItemId, "@SYS111673", 1, pass.lookupStr(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0)];

        ret = this.buildProductDimensionsText(ret, inventTable.ItemId, true, true, true);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning license plate.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id stored as data in the control.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildGetLicensePlate(container _con, str _extraText = '', WHSLicensePlateId _licensePlateId = '')
    {
        container   ret = _con;
        str         finalLabel = _extraText ? _extraText : "@WAX722";     // Scan a License Plate

        ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX359", 1, _licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0)];

        if (WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).DisplayContainerTypeCode == NoYes::Yes)
        {
            if (_licensePlateId)
            {
                ret = this.buildContainerType(ret, pass.lookupStr(#ContainerType));
                pass.insert(#Initiation, 1);
            }
            else if (!pass.exists(#Initiation) && pass.hasValue(#ContainerType))
            {
                pass.remove(#ContainerType);
            }
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning location.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <param name="_location">
    /// Location to be stored as data in the control.
    /// </param>
    /// <returns>
    /// Container containing the form state after controls are added.
    /// </returns>
    container buildGetLocation(container        _con,
                               str              _extraText = '',
                               WMSLocationId    _location = '')
    {
        container   ret = _con;
        str         finalLabel = _extraText ? _extraText : "@WAX723";     // Scan a Location

        ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #WMSLocationId, "@SYS80395", 1, _location, extendedTypeNum(WMSLocationId), '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetPotency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the batch potency control.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_inventBatchId">
    ///     The inventory batch ID specified on the inbound order line.
    /// </param>
    /// <param name="_includeGroupLabel">
    ///     Boolean value indicating whether the group label must be included.
    /// </param>
    /// <returns>
    ///     The updated RF container variable.
    /// </returns>
    protected container buildGetPotency(
        container       _con,
        InventBatchId   _inventBatchId,
        boolean         _includeGroupLabel = true)
    {
        container           ret = _con;
        ItemId              itemId;
        InventTable         inventTable;
        PdsBatchAttribValue defaultValue;
        InventBatchId       batchId;
        boolean             enabled;

        itemId = pass.lookupStr(#ItemId);

        if (this.capturePotency(itemId))
        {
            inventTable = InventTable::find(itemId);

            pass.insert(#BaseAttributeId, inventTable.pdsBaseAttributeId);

            if (pass.exists(#VendBatchInfoEntered))
            {
                defaultValue = pass.lookupStr(#Potency);
            }
            else
            {
                if (_inventBatchId)
                {
                    batchId = _inventBatchId;
                }
                else
                {
                    batchId = this.getInventBatchId();
                }

                if (InventBatch::exist(batchId, itemId))
                {
                    defaultValue = PdsBatchAttributes::find(itemId, batchId, inventTable.pdsBaseAttributeId).PdsBatchAttribValue;
                }
                else
                {
                    defaultValue = WHSInventBatchReceiptDetails::find(pass.lookupStr(#ReceiptId), itemId, batchId).PdsPotencyBaseValue;
                }
            }
            enabled = (!defaultValue);

            if (_includeGroupLabel)
            {
                ret += [this.buildControl(#RFLabel, #PotencyRFLabel, "@PSC61", 1, '', #WHSRFUndefinedDataType, '', 0)];
            }

            ret += [this.buildControl(#RFText, #Potency, inventTable.pdsBaseAttributeId, 1, defaultValue, extendedTypeNum(PDSBaseAttributeId), '', 0, enabled)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetProdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning a production order id.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after controls are added.
    /// </returns>
    container buildGetProdId(container _con, str _extraText = '')
    {
        container   ret = _con;
        str         finalLabel = _extraText ? _extraText : "@WAX726";     // Scan a Prod Id

        ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #ProdId, "@WAX725", 1, '', extendedTypeNum(ProdId), '', 0)];
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetVendBatchDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the RF screen to capture vendor batch information.
    /// </summary>
    /// <param name="_con">
    ///     The container to store RF values.
    /// </param>
    /// <returns>
    ///     The updated RF container variable.
    /// </returns>
    protected container buildGetVendBatchDetails(container _con)
    {
        container   ret = _con;
        str         elements;
        str         dateFormat = WHSParameters::getDateFormat(pass.lookupStr(#UserId));
        boolean     useVendExpDateEditable;

        useVendExpDateEditable = InventTable::find(pass.lookup(#ItemId)).isShelfLifeItem();

        elements = this.buildNoYesCombobox();

        ret += [this.buildControl(#RFLabel, #VendBatchInfo, "@SYS345080", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookup(#BatchId), extendedTypeNum(InventBatchId), '', 0, false)];

        ret += [this.buildControl(#RFText, #VendBatchId, "@PDS1349", 1, pass.lookup(#VendBatchId), extendedTypeNum(PdsVendBatchId), '', 0)];

        ret += [this.buildControl(#RFText, #VendBatchDate, strFmt("@WAX5517", dateFormat), 1, pass.lookup(#VendBatchDate), extendedTypeNum(PdsVendBatchDate), '', 0)];
        ret += [this.buildControl(#RFCombobox, #UseVendBatchDate, "@PRO2223", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookup(#UseVendBatchDate))];

        ret += [this.buildControl(#RFText, #VendExpDate, strFmt("@WAX5518", dateFormat), 1, pass.lookup(#VendExpDate), extendedTypeNum(PdsVendExpiryDate), '', 0)];

        if (useVendExpDateEditable)
        {
            ret += [this.buildControl(#RFCombobox, #UseVendExpDate, "@PDS1343", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookup(#UseVendExpDate))];
        }
        else
        {
            ret += [this.buildControl(#RFCombobox, #UseVendExpDate, "@PDS1343", 1, elements, #WHSRFUndefinedDataType, '', 0, false, enum2str(NoYes::No))];

            pass.insert(#UseVendExpDate, enum2str(NoYes::No));
        }

        ret += [this.buildControl(#RFText, #CountryOfOrigin1, "@PDS1345", 1, pass.lookup(#CountryOfOrigin1), extendedTypeNum(PdsCountryOfOrigin1), '', 0)];
        ret += [this.buildControl(#RFText, #CountryOfOrigin2, "@PDS1347", 1, pass.lookup(#CountryOfOrigin2), extendedTypeNum(PdsCountryOfOrigin2), '', 0)];

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetWorkId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning a work id.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after controls are added.
    /// </returns>
    container buildGetWorkId(container _con, str _extraText = '')
    {
        container   ret = _con;
        str         finalLabel = _extraText ? _extraText : "@WAX729";     // Scan a Work Id

        ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #WorkId, "@WAX273", 1, '', extendedTypeNum(WHSWorkId), '', 0)];
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetWorkIdLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning a work ID or license plate ID.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildGetWorkIdLicensePlateId(container _con, str _extraText = '')
    {
        container   ret			= _con;
        str         finalLabel	= _extraText ? _extraText : "@WAX1056";     // Scan a work ID / license plate ID

        ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #WHSWorkLicensePlateId, "@WAX33", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        if (!pass.exists(#AddCancel))
        {
            ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        ret = this.addShipConfirmButton(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupedPutaway</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for grouped put away.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_overrideLP">
    /// Determines whether the Override LP control needs to be added or not.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildGroupedPutaway(container _con, boolean _overrideLP = false)
    {
        container           ret = _con;
        WHSWorkGrouping     workGrouping;
        WHSWorkLine         groupWorkLine;
        Qty                 qty;
        InventHandlingQty   inventHandlingQty;
        UnitOfMeasureSymbol workUnitId;
        InventHandlingUnitId inventHandlingUnitId;
        ItemId              itemId;
        boolean             multipleItem;
        boolean             multipleUOM;
        boolean             multipleInventUOM;
        WHSRFDescription1   description1;
        WHSRFDescription2   description2;
        WHSLicensePlateId   groupLicensePlateId;
        InventHandlingUnitId tmpInventHandlingUnitId;

        void setMultipleValues()
        {
            tmpInventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(groupWorkLine.ItemId);

            if ((itemId && itemId != groupWorkLine.ItemId) || !groupWorkLine.ItemId)
            {
                multipleItem = true;
            }

            if ((workUnitId && workUnitId != groupWorkLine.UnitId) || !groupWorkLine.UnitId)
            {
                multipleUOM = true;
            }

            if ((inventHandlingUnitId && inventHandlingUnitId != tmpInventHandlingUnitId) || !tmpInventHandlingUnitId)
            {
                multipleInventUOM = true;
            }

            qty += groupWorkLine.QtyRemain;
            inventHandlingQty += groupWorkLine.InventQtyRemain;

            itemId = groupWorkLine.ItemId;
            workUnitId = groupWorkLine.UnitId;
            inventHandlingUnitId = tmpInventHandlingUnitId;
        }

        int numberOfWorkLines;

        if (pass.exists(#WorkGroupingId) && pass.lookup(#WorkGroupingId) != '' && WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).GroupPutaway)
        {
            while select WorkId from workGrouping
                where workGrouping.WorkGroupingId == pass.lookup(#WorkGroupingId)
            {
                // Loop next set of put lines on the work
                while select groupWorkLine
                    order by LineNum
                    where groupWorkLine.WorkId       == workGrouping.WorkId
                        && groupWorkLine.WorkStatus   <= WHSWorkStatus::InProcess
                {
                    numberOfWorkLines++;

                    if (groupWorkLine.WorkType == WHSWorkType::Pick)
                    {
                        break;
                    }

                    setMultipleValues();
                }
            }
        }
        else
        {
            // If Grouping Id does not exist must be in a multi-put scenario.
            while select groupWorkLine
                where groupWorkLine.WorkId  == workLine.WorkId
                &&    groupWorkLine.LineNum >= workLine.LineNum
                &&    groupWorkLine.QtyRemain > 0
            {
                numberOfWorkLines++;

                setMultipleValues();

                if (!groupLicensePlateId)
                {
                    groupLicensePlateId = workTable.TargetLicensePlateId;
                }
            }
        }

        ret += [this.buildControl(#RFLabel, 'Put', strFmt("@WAX1270", workTable.WorkTransType), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Put) &&
            !pass.exists(#GroupPutaway))
        {
            if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).CheckText)
            {
                ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, '', extendedTypeNum(WMSCheckText), '', 0)];
            }
            else if (pass.exists(#SystemPopulated))
            {
                if ((!pass.exists(#PrevStep) || pass.lookup(#PrevStep) != WHSWorkExecuteDisplay::num2StrDisplay(#OverrideStep2)) && !pass.exists(#GroupPutawayConfirm))
                {
                    ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
                }
            }
        }

        if (groupLicensePlateId && !_overrideLP)
        {
            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, pass.lookupStr(#TargetLicensePlateId) ? pass.lookupStr(#TargetLicensePlateId) : groupLicensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }
        else if (_overrideLP)
        {
            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, pass.lookupStr(#TargetLicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        }

        // Clear out UOM values if grouped work units do not match
        if (multipleUOM)
        {
            workUnitId = '';
        }

        if (multipleInventUOM)
        {
            inventHandlingUnitId = '';
        }

        if (multipleItem)
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@WAX402", extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, itemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            ret += this.addProductConfirmationControl(WHSWorkType::Put);
        }

        if (workUnitId)
        {
            ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1283", qty, workUnitId, inventHandlingQty, inventHandlingUnitId, uomQtySeparator), 1, '', #WHSRFUndefinedDataType, '', 0, true, '', WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1685", inventHandlingQty, inventHandlingUnitId), 1, '', #WHSRFUndefinedDataType, '', 0, true, '', WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
        }

        if (WHSRFAutoConfirm::isVerifyQtyConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Put) &&
            !pass.exists(#GroupPutaway))
        {
            ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
            ret += [this.buildControl(#RFLabel, #QtyVerifyUOM, workUnitId, 0, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
        }

        if (!multipleItem)
        {
            description1    = WHSInventTable::find(itemId).rfDescription1;
            description2    = WHSInventTable::find(itemId).rfDescription2;

            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(workLine.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        // Set LicensePlateId to TargetLicensePlateId so that later source LP can be correctly calculated in this.initializeSourceAndTargetLicensePlateIds method.
        // Without it sourceLP would be calculated as LP from Receiving location, which later would be passed to WhsWorkExecutePutAwayToLocation.run method.
        // In others words we would try to put from LP1 (receiving location) to LP2 (final location), while the item would actually be on LP2 (user location).
        // This line of code is relevant when Work inventory transactions are enabled
        // (without it the logic in WhsWorkExecutePutAwayToLocation.run just ignores sourceLP and calculates it based on InventDim of previously completed Pick operation).
        pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
        pass.insert(#TargetLicensePlateId, workTable.TargetLicensePlateId);

        if (workLine.WMSLocationId
            && controller.canAddSplitAndLPOverrideButtonsForWorkTransType(workTable.WorkTransType)
            && !WHSWorkLine::getNextOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType))
        {
            if (workTable.WorkTransType != WHSWorkTransType::Replenishment
                && numberOfWorkLines == 1)
            {
                addSplitButton = true;
            }

            if (WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).AllowLicensePlatePutOverride
                && WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled()
                && !_overrideLP)
            {
                addLPOverride = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryStatusesToShow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list of inventory statuses to show.
    /// </summary>
    /// <returns>A list of inventory status ids.</returns>
    protected List inventoryStatusesToShow()
    {
        List result = new List(Types::String);
        
        WHSInventStatus inventStatus;
        while select inventStatus
        {
            result.addEnd(inventStatus.InventStatusId);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventoryStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for selecting inventory status.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before controls are added.
    /// </param>
    /// <param name="_label">
    /// Label text.
    /// </param>
    /// <param name="_showRemove">
    /// Determines whether Remove From Quarantine button should be shown, false by default.
    /// </param>
    /// <param name="_showBlank">
    /// Determines whether inventory status combobox should be blank, false by default.
    /// </param>
    /// <param name="_showOK">
    /// Determines whether OK button should be shown, true by default.
    /// </param>
    /// <param name="_selected">
    /// Selected element from inventory status combobox.
    /// </param>
    /// <param name="_enabled">
    /// Determines whether the combobox is enabled, true by default.
    /// </param>
    /// <returns>
    /// Container containing the form state after controls are added.
    /// </returns>
    public container buildInventoryStatus(
        container    _con,
        str          _label = '',
        boolean      _showRemove = false,
        boolean      _showBlank = false,
        boolean      _showOK = true,
        str          _selected = '',
        boolean      _enabled = true)
    {
        container           ret = _con;
        boolean             first = true;
        str                 elements;
        str                 label = _label ? _label : "@WAX357";      // Inventory Status
        str                 selected;
        ListEnumerator      inventoryStatuses  = this.inventoryStatusesToShow().getEnumerator();
        System.Text.StringBuilder statusBuilder;
        str                 statusOptions;

        // If this context exists it is allowed to have an empty string '' as a selected value
        if (WHSAllowBuildInventoryStatusWithEmptySelectedValueContext::current())
        {
            selected = _selected;
        }
        else
        {
            selected = _selected ? _selected : WHSInventStatus::getDefaultInventStatus(pass.lookupStr(#InventLocationId)).InventStatusId;
        }

        statusBuilder = PooledStringBuilder::GetInstance();

        if (_showBlank)
        {
            statusBuilder.Append('||');
        }

        while (inventoryStatuses.moveNext())
        {
            if (first)
            {
                statusBuilder.Append(inventoryStatuses.current());
               
                first = false;
            }
            else
            {
                statusBuilder.Append('||');
                statusBuilder.Append(inventoryStatuses.current());
            }
        }

        statusOptions = PooledStringBuilder::GetStringAndRelease(statusBuilder);

        var context = WHSWorkExecuteDisplayContext::current();
        
        if (context 
            && context.mustUpdateControl)
        {
            ret = this.updateControlInContainer(ret, #InventoryStatus, statusOptions);
        }
        else
        {
            // Create a new control
            ret += [this.buildControl(#RFCombobox, #InventoryStatus, label, 1, statusOptions, #WHSRFUndefinedDataType, '', 0, _enabled, selected, WHSRFColorText::Default, extendedTypeNum(WHSInventStatusId))];

            if (_showRemove)
            {
                ret += [this.buildControl(#RFButton, "@SYS26394", "@WAX879", 1, '', #WHSRFUndefinedDataType, '', 0)];
            }

            if (_showOK)
            {
                ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateControlInContainer</Name>
				<Source><![CDATA[
    private container updateControlInContainer(container _con, str _controlName, str _options)
    {
        container ret = _con;

        // Update an existing control
        int controlLocation = this.getControlLocation(ret, _controlName);

        if (controlLocation > 0)
        {
            // Find the control within the RF container.
            container control = conPeek(ret, controlLocation);

            // Determine the currently selected value.
            str selectedValue = conPeek(control, #data);

            if (selectedValue == _options && conPeek(control, #selected))
            {
                selectedValue = conPeek(control, #selected);
            }

            control  = conDel(control, #data, 1);
            control  = conIns(control, #data, _options);
            control  = conDel(control, #selected, 1);
            control  = conIns(control, #selected, selectedValue);

            ret = conDel(ret, controlLocation, 1);
            ret = conIns(ret, controlLocation, control);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationListFromSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes a location set.
    /// </summary>
    /// <param name="_locations">
    /// Set containing locations.
    /// </param>
    /// <returns>
    /// String representation of the location set.
    /// </returns>
    str buildLocationListFromSet(Set _locations)
    {
        return this.buildCommaDelimitedStrFromSet(_locations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationListFromStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deserializes a string containing locations.
    /// </summary>
    /// <param name="_locations">
    /// String containing locations.
    /// </param>
    /// <returns>
    /// Set containing locations.
    /// </returns>
    Set buildLocationListFromStr(str _locations)
    {
        return this.buildSetFromCommaDelimitedStr(_locations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLineSerialValidated</Name>
				<Source><![CDATA[
    private boolean isWorkLineSerialValidated(WHSWorkLine _workLine)
    {
        Set serialValidatedWorkLineSet = this.buildSetFromCommaDelimitedStr(pass.lookupStr(#SkipSerialValidate));
        return serialValidatedWorkLineSet.in(any2Str(_workLine.RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignSerial</Name>
				<Source><![CDATA[
    private boolean assignSerial(WHSWorkLine _workLine)
    {
        return pass.exists(#AssignSerial) || this.isWorkLineSerialValidated(workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markWorkLineSerialValidated</Name>
				<Source><![CDATA[
    private void markWorkLineSerialValidated(WHSWorkLine _workLine)
    {
        Set serialValidatedWorkLineSet = this.buildSetFromCommaDelimitedStr(pass.lookupStr(#SkipSerialValidate));
        serialValidatedWorkLineSet.add(any2Str(_workLine.RecId));
        pass.insert(#SkipSerialValidate, this.buildCommaDelimitedStrFromSet(serialValidatedWorkLineSet));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCommaDelimitedStrFromSet</Name>
				<Source><![CDATA[
    private str buildCommaDelimitedStrFromSet(Set _set)
    {
        str ret;

        if (_set)
        {
            SetEnumerator se = _set.getEnumerator();

            while (se.moveNext())
            {
                str current = se.current();

                if (!ret)
                {
                    ret = current;
                }
                else
                {
                    ret = ret + ',' + current;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSetFromCommaDelimitedStr</Name>
				<Source><![CDATA[
    private Set buildSetFromCommaDelimitedStr(str _str)
    {
        Set ret = new Set(Types::String);

        if (_str)
        {
            List list = strSplit(_str, ',');
            ListEnumerator le = list.getEnumerator();

            while (le.moveNext())
            {
                str current = le.current();
                ret.add(current);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipOnhandCheckIfBatchItemAllowsNegativeInventory</Name>
				<Source><![CDATA[
    private boolean skipOnhandCheckIfBatchItemAllowsNegativeInventory(InventDim _inventDim, ItemId _itemId)
    {
        WHSLocationProfile locationProfile = _inventDim.wmsLocation().whsLocationProfile();

        if (!locationProfile.LPControlled
            && locationProfile.AllowNegative)
        {
            InventTable item = InventTable::find(_itemId);

            if (item.isItemBatchActivated()
                && item.whsAllowPhysNeg())
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureMoreDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if more dimensions must be captured.
    /// </summary>
    /// <param name = "_assignSerial">A boolean which determines if we should add serial control, as item is serial enabled and serial number is capture at picking.</param>
    /// <param name = "_inventDim">The inventory dimensions</param>
    /// <param name = "_itemId">The item</param>
    /// <param name = "_qty">The qty remaining to be picked.</param>
    /// <returns>true if more dimensions must be captured; otherwise, false.</returns>
    protected boolean mustCaptureMoreDimensions(boolean _assignSerial, InventDim _inventDim, ItemId _itemId, Qty _qty)
    {
        // Call method to determine if on demand quantity is greater than what is on the dimensions set
        // and if it isn't check that we are not piece picking or batch confirming
        if (!_assignSerial  
            && !this.skipOnhandCheckIfBatchItemAllowsNegativeInventory(_inventDim, _itemId)
            && !this.isOnHandGreaterThanDemand(_inventDim, _itemId, _qty)
            && !this.isPiecePickingOrBatchConfirmation())
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildNextDimensionCaptureControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the next input control for inventory dimension capture if needed.
    /// </summary>
    /// <param name="_con">
    /// Current container that represents the currently build RF screen.
    /// </param>
    /// <param name="_inventDim">
    /// The inventDim holding values predetermined by the work.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which determines the reservation hierarchy, thus, determining the next dimensions control.
    /// </param>
    /// <param name="_qty">
    /// The qty remaining to be picked.
    /// </param>
    /// <param name="_updatePass">
    /// A boolean which determines how we are updating the global pass. If building a new dim control we must prompt the user again.
    /// </param>
    /// <param name="_assignSerial">
    /// A boolean which determines if we should add serial control, as item is serial enabled and serial number is capture at picking.
    /// </param>
    /// <returns>
    /// A container that represents the currently build RF screen including any controls built in this method.
    /// </returns>
    protected container buildNextDimensionCaptureControl(
        container   _con,
        InventDim   _inventDim,
        ItemId      _itemId,
        InventQty   _qty,
        boolean     _updatePass = true,
        boolean     _assignSerial = false)
    {
        ListEnumerator                      enumerator;
        container                           ret = _con;
        InventDim                           inventDim = _inventDim;
        InventDim                           tmpInventDim;
        FieldId                             fieldId;
        FieldName                           fieldName;
        DictField                           dictField;
        boolean                             prompt;
        WHSReservationHierarchyProvider     reservationHierarchyProvider;
        WHSReservationHierarchyElementData  elementData;
        InventTable                         inventTable;

        // If item is not specified, no need to evaluate and display dim controls
        if (!_itemId || !_qty)
        {
            return ret;
        }

        if (pass.exists(#LicensePlateId))
        {
            inventDim.LicensePlateId = pass.lookup(#LicensePlateId);
        }

        // Get invent table for current item id
        inventTable = InventTable::find(_itemId);

        // Get List
        reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();

        List hierarchyList = reservationHierarchyProvider.getDimListBelowLicensePlate(
                            inventTable,
                            WHSReservationHierarchySortOrder::TopDown);

        if (workLine.OrderCommittedInventDimId)
        {
            hierarchyList = WHSReservationHierarchyProvider::removeFlexibleDimensions(hierarchyList, workLine.ItemId);
        }

        enumerator = hierarchyList.getEnumerator();

        while (enumerator.moveNext())
        {
            elementData = enumerator.current();
            fieldId = elementData.parmDimensionFieldId();
            fieldName = fieldId2name(inventDim.TableId, fieldId);
            dictField = new DictField(tableNum(InventDim), fieldId);

            if (pass.exists(fieldName) && pass.hasValue(fieldName))
            {
                boolean enabled = mode != WHSWorkExecuteMode::MovementByTemplate
                                   && (!WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookupStr(#MenuItem), workLine.WorkType)
                                        || PdsGlobal::pdsIsCWItem(inventTable.ItemId));

                inventDim.(fieldId) = pass.lookup(fieldName);
                ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0, enabled)];
                continue;
            }

            if (!this.mustCaptureMoreDimensions(_assignSerial, inventDim, _itemId, _qty))
            {
                break;
            }

            // Check to see if we are allowed to pick a batch negative, if so prompt for desired batch
            if (this.promptForNegativeBatch(fieldId, inventDim, _itemId))
            {
                if (!pass.exists(#BatchId) || !pass.hasValue(#BatchId))
                {
                    InventBatchId defaultBatchId = this.findDefaultBatch(inventTable, inventDim.wmsLocation());
                        
                    if (defaultBatchId)
                    {
                        pass.insert(#BatchId, defaultBatchId);
                    }
                    else
                    {
                        ret += this.addOldestBatchFEFOLabel();
                    }
                }

                ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookupStr(#BatchId), extendedTypeNum(InventBatchId), '', 0)];

                break;
            }

            if (fieldId == fieldNum(InventDim, inventBatchId)
                    && !this.findDefaultBatch(inventTable, inventDim.wmsLocation()))
            {
                ret += this.addOldestBatchFEFOLabel();
            }

            if (fieldId == fieldNum(InventDim, InventGTDId_RU)
                && SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoRU])
                && WHSRFMenuItemTable::find(pass.parmMenuItem()).IsSuggestGTDEnabled_RU)
            {
                ret += this.addSuggestedGTDsLabel_RU(inventDim);
            }

            // Call a method used for defaulting the dim field if there is only one available
            if (!_assignSerial)
            {
                if (inventDim.InventStatusId 
                    && fieldId == fieldNum(InventDim, inventBatchId))
                {
                    InventDim inventDimToGetDefaultValue = inventDim.data();
                    inventDimToGetDefaultValue.InventStatusId = '';

                    [tmpInventDim, prompt] = this.getDefaultDimValue(inventDimToGetDefaultValue, fieldId, _itemId);
                }
                else
                {
                    [tmpInventDim, prompt] = this.getDefaultDimValue(inventDim, fieldId, _itemId);
                }

                if (!prompt)
                {
                    inventDim.(fieldId) = tmpInventDim.(fieldId);
                    this.validateDefaultDimValue(fieldId, inventDim, _itemId);

                    continue;
                }
            }

            // Ask for current dimension
            // For Serial id, we might have multiple so we want to keep the counter
            if (fieldId == fieldNum(InventDim, InventSerialId) && _assignSerial)
            {
                ret += [this.buildControl(#RFLabel,
                    #SerialCounter,
                strFmt("@WAX3121", pass.lookup(#SerialCounter), pass.lookupNum(#SerialQty), WHSCatchWeightHelper::inventHandlingUnitId(inventTable.ItemId)),
                    1, '', #WHSRFUndefinedDataType, '', 0)];
            }

            ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0)];

            if (!_updatePass)
            {
                if (fieldId == fieldNum(InventDim, InventSerialId)
                && pass.exists(#SerialId)
                && !pass.lookup(#SerialId)
                && WhsWorkExecuteDisplay::isBlanksSerialNumberAssignmentAllowed(workLine, pass.lookup(#ItemId)))
                {
                    continue;
                }

                if (fieldId == fieldNum(InventDim, InventGTDId_RU)
                    && pass.exists(#GtdId_RU)
                    && !pass.lookup(#GtdId_RU)
                    && WHSInvent::isGTDNumberOptional(pass.parmItemId()))
                {
                    continue;
                }
                
                pass.insert(#DimPrompt, 1);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlanksSerialNumberAssignmentAllowed</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean isBlanksSerialNumberAssignmentAllowed(WHSWorkLine _workLine, ItemId _itemId)
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(_workLine.whsWorkTable().WorkTransType).isBlankSerialNumberAssignmentAllowed()
            && WhsInvent::isSerialNumberOptional(_itemId)
            && WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLPOldestBatchLabel</Name>
				<Source><![CDATA[
    protected container addLPOldestBatchLabel()
    {
        container   ret;

        if (this.isInitialPickForFEFOBatch())
        {
            str labelStr = strFmt("@WAX:SuggestedFEFOLPs", this.getLPWithOldestBatches().toString());

            ret += [this.buildControl(#RFLabel, 
                                        WHSWorkExecuteDisplayFEFOBatchLabelControls::FEFOBatchLPList, 
                                        labelStr, 1, '', extendedTypeNum(WHSSuggestedLPs), '', 0)];           
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMinAllowedExpiryDate</Name>
				<Source><![CDATA[
    protected InventBatchExpDate getMinAllowedExpiryDate()
    {
        if (workLine.LoadLineRefRecId)
        {
            return InventMovement::construct(WHSLoadLine::findbyRecId(workLine.LoadLineRefRecId).getOrderCommonFromLoadLine()).minAllowedExpiryDate();
        }

        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMinAllowedBestBeforeDate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static PdsBestBeforeDate getMinAllowedBestBeforeDate(WHSWorkLine _workLine)
    {
        if (_workLine.LoadLineRefRecId)
        {
            return InventMovement::construct(WHSLoadLine::findbyRecId(_workLine.LoadLineRefRecId).getOrderCommonFromLoadLine()).minAllowedBestBeforeDate();
        }

        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOldestExpDate</Name>
				<Source><![CDATA[
    private InventBatchExpDate getOldestExpDate(InventDim _inventDim = workLine.inventDimWithLocation())
    {
        InventBatchExpDate expDate;

        if (workLine.WorkType == WHSWorkType::Pick)
        {
            InventBatch inventBatch = this.getBatches(_inventDim);

            while (inventBatch)
            {
                if (inventBatch.validateBatchDispCodeForPicking(workLine.whsWorkTable().WorkTransType))
                {
                    break;
                }

                next inventBatch;
            }

            expDate = inventBatch.expDate;
        }
        else
        {
            expDate = this.getBatches(workLine.inventDimWithLocation()).expDate;
        }  

        return expDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLPWithOldestBatches</Name>
				<Source><![CDATA[
    private Set getLPWithOldestBatches()
    {
        Set lpWithOldestBatchSet = new Set(Types::String);
        Set usedLPSet = new Set(Types::String);

        if (!workLine.ItemId)
        {
            return lpWithOldestBatchSet;
        }

        InventBatchExpDate  batchExpDate = this.getMinAllowedExpiryDate();
        PdsBestBeforeDate   batchBestBeforeDate = WhsWorkExecuteDisplay::getMinAllowedBestBeforeDate(workLine);

        InventDim           workLineDimWithLocation = workLine.inventDimWithLocation();

        if (workLine.OrderCommittedInventDimId)
        {
            workLineDimWithLocation.inventBatchId = InventDim::find(workLine.OrderCommittedInventDimId).inventBatchId;
            workLineDimWithLocation = InventDim::findOrCreate(workLineDimWithLocation);
        }

        InventBatch inventBatch;
        SysDaQueryObject queryObject;
        SysDaQueryObject inventSumQuery;

        InventSum inventSum;
        InventDim inventDim;
        InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty;

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(workLine.ItemId))
        {
            inventSumQuery = 
                WHSWorkExecuteDisplaySysDaQueries::buildQueryInventSumWithInventDimUnionDeltaPhysicalQtyWithPhysicalInventForItem(
                    inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty, workLine.ItemId);

            queryObject = WHSWorkExecuteDisplaySysDaQueries::buildQueryLPsByBatchExpDateForInvSumOrInvSumInvDimUnionDeltaInvDimPhysicalQty(inventBatch,
                                inventSumQuery,
                                inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty,
                                workLine.ItemId,
                                batchExpDate,
                                batchBestBeforeDate,
                                workLineDimWithLocation);
        }
        else
        {
            inventSumQuery = WHSWorkExecuteDisplaySysDaQueries::buildQueryInventSumWithPhysicalInventForItem(inventSum, workLine.ItemId);
                
            queryObject = WHSWorkExecuteDisplaySysDaQueries::buildQueryLPsByBatchExpDateForInvSumOrInvSumInvDimUnionDeltaInvDimPhysicalQty(inventBatch,
                                inventSumQuery,
                                inventSum,
                                workLine.ItemId,
                                batchExpDate,
                                batchBestBeforeDate,
                                workLineDimWithLocation);
        }

        SysDaFindStatement findStatement = new SysDaFindStatement();
        findStatement.find(new SysDaFindObject(queryObject));
        
        const int   MaximumLPSet = 5;
        InventBatchExpDate  oldestBatchExpirationDate;
        str suggestedLPWithQtyStr;

        if (WHSWorkExecuteDisplaySuggestedLPIncludeQtyFlight::instance().isEnabled() && workLine.LocatedLPId)
        {
            suggestedLPWithQtyStr = this.getSuggestedLPwithQtyStr(workLine.LocatedLPId, workLineDimWithLocation);
                
            lpWithOldestBatchSet.add(suggestedLPWithQtyStr);
            usedLPSet.add(workLine.LocatedLPId);
        }

        while (inventBatch)
        {
            if (!inventBatch.validateBatchDispCodeForPicking(workLine.whsWorkTable().WorkTransType))
            {
                next inventBatch;
                continue;
            }

            if (oldestBatchExpirationDate != dateNull() && oldestBatchExpirationDate != inventBatch.expDate)
            {
                // If we have moved to batches with a different expiration date, it means that we have exhausted the oldest batches and we should not get more license plates.
                break;
            }

            if (lpWithOldestBatchSet.elements() >= MaximumLPSet)
            {
                break;
            }

            oldestBatchExpirationDate = inventBatch.expDate;   
            
            if (WHSWorkExecuteDisplaySuggestedLPIncludeQtyFlight::instance().isEnabled())
            {
                WHSLicensePlateId suggestedLP;

                if (inventDim.LicensePlateId)
                {
                    suggestedLP = inventDim.LicensePlateId;
                }
                else if (inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty.LicensePlateId)
                {
                    suggestedLP = inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty.LicensePlateId;
                }
                else
                {
                    suggestedLP = inventSum.LicensePlateId;
                }

                if (!usedLPSet.in(suggestedLP))
                {
                    suggestedLPWithQtyStr = this.getSuggestedLPwithQtyStr(suggestedLP, workLineDimWithLocation);
                
                    lpWithOldestBatchSet.add(suggestedLPWithQtyStr);
                    usedLPSet.add(suggestedLP);
                }
            }
            else
            {
                if (inventDim.LicensePlateId)
                {
                    lpWithOldestBatchSet.add(inventDim.LicensePlateId);
                }
                else if (inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty.LicensePlateId)
                {
                    lpWithOldestBatchSet.add(inventSumWithInventDimUnionDeltaWithInventDimPhysicalQty.LicensePlateId);
                }
                else
                {                                                      
                    lpWithOldestBatchSet.add(inventSum.LicensePlateId);
                }
            }

            next inventBatch;
        }

        return lpWithOldestBatchSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useGetOldestBatchLocationsDenormalizedView</Name>
				<Source><![CDATA[
    private boolean useGetOldestBatchLocationsDenormalizedView()
    {
        return WHSGetOldestBatchLocationsAndQuantitiesPerfFlight::instance().isEnabled() &&
               InventUseDimOfInventSumToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSuggestedLPwithQtyStr</Name>
				<Source><![CDATA[
    private str getSuggestedLPwithQtyStr(WHSLicensePlateId _suggestedLP, InventDim _workLineDimWithLocation)
    {
        InventDim inventDimLP;
        inventDimLP.initFromInventDim(_workLineDimWithLocation);
        inventDimLP.LicensePlateId = _suggestedLP;
        inventDimLP = InventDim::findDim(inventDimLP);

        str suggestedLPWithQty = strFmt('%1: %2', _suggestedLP, WHSInventOnHand::getWorkPhysicalInventHandlingQty(workLine.ItemId, inventDimLP.InventDimId));
           
        return suggestedLPWithQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOldestBatchLocationsAndQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines oldest batch locations with quantities.
    /// </summary>
    /// <returns>List of oldest batch locations with quantities.</returns>
    [Wrappable(false)]
    protected Map getOldestBatchLocationsAndQuantities()
    {
        InventDim                       inventDim;
        InventDim                       workLineDimNoLocation = workLine.inventDim();
        InventBatch                     inventBatch;
        InventBatchExpDate				minimumAllowedBatchExpiryDate = this.getMinAllowedExpiryDate();
        InventBatchExpDate				oldestOnLocation = this.getOldestExpDate();
        InventBatchExpDate				oldestInWarehouse;
        PdsBestBeforeDate               minimumAllowedBatchBestBeforeDate = WhsWorkExecuteDisplay::getMinAllowedBestBeforeDate(workLine);
        
        oldestInWarehouse =  this.getOldestExpDate(workLineDimNoLocation);

        if (oldestOnLocation == oldestInWarehouse)
        {
            // If work line location has oldest batch we can ignore checking again.
            pass.insert(WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn, 1);
            return null;
        }

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(workLineDimNoLocation);
            
        WHSWorkLine otherWorkLine;
        Map olderBatchLocation = new Map(Types::String, Types::Container);
        olderBatchLocationList = new List(Types::String);
        
        boolean isCWItem = PdsGlobal::pdsIsCWItem(workLine.ItemId);
        //we need to look at reservations at location level to exclude reservations on locations for other worklines
        WHSReservationHierarchyLevel reservationLevel = WHSReservationHierarchyProvider::construct().getLocationHierarchyLevel(InventTable::find(workLine.ItemId));

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(workLine.itemId))
        {

            if (this.useGetOldestBatchLocationsDenormalizedView())
            {
                InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumUnionDeltaWithInventDim;

                while select expDate, inventBatchId from inventBatch
                order by expDate asc
                where  inventBatch.ItemId  == workLine.ItemId
                    && inventBatch.expDate >= minimumAllowedBatchExpiryDate
                    && inventBatch.expDate < oldestOnLocation
                    && inventBatch.PdsBestBeforeDate >= minimumAllowedBatchBestBeforeDate
                join inventSumUnionDeltaWithInventDim
                    where #InventDimFieldsFilter(inventSumUnionDeltaWithInventDim, workLineDimNoLocation, inventDimParm)
                        && inventSumUnionDeltaWithInventDim.InventBatchId == inventBatch.inventBatchId
                        && ((isCWItem
                            && inventSumUnionDeltaWithInventDim.PdsCWPhysicalInvent > 0)
                        || (!isCWItem
                            && inventSumUnionDeltaWithInventDim.PhysicalInvent      > 0))
                notexists join otherWorkLine
                    where  otherWorkLine.WorkId     == workLine.WorkId
                        && otherWorkLine.WorkStatus == WHSWorkStatus::Open
                        && otherWorkLine.WorkType   == WHSWorkType::Pick
                        && otherWorkLine.ItemId     == workLine.ItemId
                        && otherWorkLine.WMSLocationId == inventSumUnionDeltaWithInventDim.wMSLocationId
                {
                    InventDim inventDimLocal = InventDim::initFromInventSumWithInventDimUnionDeltaWithInventDimPhysicalQty(inventSumUnionDeltaWithInventDim, true);

                    WHSInventReserveQuantities availableQty = whsInventOnHand::getAllAvailQuantities(
                    workLine.ItemId,
                    inventDimLocal,
                    true,
                    reservationLevel);

                    InventHandlingQty handlingQty = isCWItem ? availableQty.CWAvailPhysical : availableQty.AvailPhysical;
                    if (handlingQty <= 0)
                    {
                        continue;
                    }

                    if (olderBatchLocation.exists(inventDimLocal.wMSLocationId))
                    {
                        container batchDateQty = olderBatchLocation.lookup(inventDimLocal.wMSLocationId);
                        batchDateQty += [inventBatch.inventBatchId, inventBatch.expDate, handlingQty];
                        olderBatchLocation.insert(inventDimLocal.wMSLocationId, batchDateQty);
                    }
                    else
                    {
                        // We only add each location to the list once to ensure the correct order, the location with the oldest batch is at the top of the list, is kept.
                        olderBatchLocationList.addEnd(inventDimLocal.wMSLocationId);
                        olderBatchLocation.insert(inventDimLocal.wMSLocationId, [inventBatch.inventBatchId, inventBatch.expDate, handlingQty]);
                    }
                }
            }
            else
            {
                InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;

                while select expDate, inventBatchId from inventBatch
                order by expDate asc
                where  inventBatch.ItemId  == workLine.ItemId
                    && inventBatch.expDate >= minimumAllowedBatchExpiryDate
                    && inventBatch.expDate < oldestOnLocation
                    && inventBatch.PdsBestBeforeDate >= minimumAllowedBatchBestBeforeDate
                join tableId from inventSumUnionDeltaPhysicalQty
                    where inventSumUnionDeltaPhysicalQty.ItemId == inventBatch.ItemId
                        && ((isCWItem
                            && inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent > 0)
                        || (!isCWItem
                            && inventSumUnionDeltaPhysicalQty.PhysicalInvent      > 0))
                #InventDimInnerJoin(inventSumUnionDeltaPhysicalQty.InventDimId, inventDim, workLineDimNoLocation, inventDimParm)
                && inventDim.inventBatchId == inventBatch.inventBatchId
                notexists join otherWorkLine
                    where  otherWorkLine.WorkId     == workLine.WorkId
                        && otherWorkLine.WorkStatus == WHSWorkStatus::Open
                        && otherWorkLine.WorkType   == WHSWorkType::Pick
                        && otherWorkLine.ItemId     == workLine.ItemId
                        && otherWorkLine.WMSLocationId == inventDim.wMSLocationId
                {
                    WHSInventReserveQuantities availableQty = whsInventOnHand::getAllAvailQuantities(
                    workLine.ItemId,
                    inventDim,
                    true,
                    reservationLevel);

                    InventHandlingQty handlingQty = isCWItem ? availableQty.CWAvailPhysical : availableQty.AvailPhysical;
                    if (handlingQty <= 0)
                    {
                        continue;
                    }

                    if (olderBatchLocation.exists(inventDim.wMSLocationId))
                    {
                        container batchDateQty = olderBatchLocation.lookup(inventDim.wMSLocationId);
                        batchDateQty += [inventBatch.inventBatchId, inventBatch.expDate, handlingQty];
                        olderBatchLocation.insert(inventDim.wMSLocationId, batchDateQty);
                    }
                    else
                    {
                        // We only add each location to the list once to ensure the correct order, the location with the oldest batch is at the top of the list, is kept.
                        olderBatchLocationList.addEnd(inventDim.wMSLocationId);
                        olderBatchLocation.insert(inventDim.wMSLocationId, [inventBatch.inventBatchId, inventBatch.expDate, handlingQty]);
                    }
                }
            }
        }
        else
        {
            InventSum  inventSum;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select expDate, inventBatchId from inventBatch
                    order by expDate asc
                    where inventBatch.ItemId == workLine.ItemId
                        && inventBatch.expDate >= minimumAllowedBatchExpiryDate
                        && inventBatch.expDate < oldestOnLocation
                        && inventBatch.PdsBestBeforeDate >= minimumAllowedBatchBestBeforeDate
                    join tableId, #InventDimGroupAllFields from inventSum
                        where  inventSum.ItemId == inventBatch.ItemId
                            && inventSum.ClosedQty == NoYes::No
                            && ((isCWItem
                                && inventSum.PdsCWPhysicalInvent > 0)
                            || (!isCWItem
                                && inventSum.PhysicalInvent      > 0))
                            && #InventDimFieldsFilter(inventSum, workLineDimNoLocation, inventDimParm)
                            && inventSum.inventBatchId == inventBatch.inventBatchId
                    notexists join otherWorkLine
                        where otherWorkLine.WorkId == workLine.WorkId
                            && otherWorkLine.WorkStatus == WHSWorkStatus::Open
                            && otherWorkLine.WorkType == WHSWorkType::Pick
                            && otherWorkLine.ItemId == workLine.ItemId
                            && otherWorkLine.WMSLocationId == inventSum.wMSLocationId
                {
                    inventDim.clear();
                    inventDim.initFromInventSum(inventSum);

                    WHSInventReserveQuantities availableQty = whsInventOnHand::getAllAvailQuantities(
                        workLine.ItemId,
                        inventDim,
                        false,
                        reservationLevel);

                    InventHandlingQty handlingQty = isCWItem ? availableQty.CWAvailPhysical : availableQty.AvailPhysical;
                    if (handlingQty <= 0)
                    {
                        continue;
                    }

                    if (olderBatchLocation.exists(inventDim.wMSLocationId))
                    {
                        container batchDateQty = olderBatchLocation.lookup(inventDim.wMSLocationId);
                        batchDateQty += [inventBatch.inventBatchId, inventBatch.expDate, handlingQty];
                        olderBatchLocation.insert(inventDim.wMSLocationId, batchDateQty);
                    }
                    else
                    {
                        // We only add each location to the list once to ensure the correct order, the location with the oldest batch is at the top of the list, is kept.
                        olderBatchLocationList.addEnd(inventDim.wMSLocationId);
                        olderBatchLocation.insert(inventDim.wMSLocationId, [inventBatch.inventBatchId, inventBatch.expDate, handlingQty]);
                    }
                }
            }
            else
            {
                while select expDate, inventBatchId from inventBatch
                    order by expDate asc
                    where inventBatch.ItemId == workLine.ItemId
                        && inventBatch.expDate >= minimumAllowedBatchExpiryDate
                        && inventBatch.expDate < oldestOnLocation
                        && inventBatch.PdsBestBeforeDate >= minimumAllowedBatchBestBeforeDate
                    join tableId from inventSum
                        where  inventSum.ItemId == inventBatch.ItemId
                            && inventSum.ClosedQty == NoYes::No
                            && ((isCWItem
                                && inventSum.PdsCWPhysicalInvent > 0)
                            || (!isCWItem
                                && inventSum.PhysicalInvent      > 0))
                    #InventDimInnerJoin(inventSum.InventDimId, inventDim, workLineDimNoLocation, inventDimParm)
                && inventDim.inventBatchId == inventBatch.inventBatchId
                    notexists join otherWorkLine
                        where otherWorkLine.WorkId == workLine.WorkId
                            && otherWorkLine.WorkStatus == WHSWorkStatus::Open
                            && otherWorkLine.WorkType == WHSWorkType::Pick
                            && otherWorkLine.ItemId == workLine.ItemId
                            && otherWorkLine.WMSLocationId == inventDim.wMSLocationId
                {
                    WHSInventReserveQuantities availableQty = whsInventOnHand::getAllAvailQuantities(
                        workLine.ItemId,
                        inventDim,
                        false,
                        reservationLevel);

                    InventHandlingQty handlingQty = isCWItem ? availableQty.CWAvailPhysical : availableQty.AvailPhysical;
                    if (handlingQty <= 0)
                    {
                        continue;
                    }

                    if (olderBatchLocation.exists(inventDim.wMSLocationId))
                    {
                        container batchDateQty = olderBatchLocation.lookup(inventDim.wMSLocationId);
                        batchDateQty += [inventBatch.inventBatchId, inventBatch.expDate, handlingQty];
                        olderBatchLocation.insert(inventDim.wMSLocationId, batchDateQty);
                    }
                    else
                    {
                        // We only add each location to the list once to ensure the correct order, the location with the oldest batch is at the top of the list, is kept.
                        olderBatchLocationList.addEnd(inventDim.wMSLocationId);
                        olderBatchLocation.insert(inventDim.wMSLocationId, [inventBatch.inventBatchId, inventBatch.expDate, handlingQty]);
                    }
                }
            }
        }

        return olderBatchLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatches</Name>
				<Source><![CDATA[
    private InventBatch getBatches(InventDim _inventDim)
    {
        InventDim                       inventDim;
        InventBatch                     inventBatch;
        InventBatchExpDate              batchExpDate = this.getMinAllowedExpiryDate();
        PdsBestBeforeDate               batchBestBeforeDate = WhsWorkExecuteDisplay::getMinAllowedBestBeforeDate(workLine);

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(_inventDim);

        boolean isCWItem = PdsGlobal::pdsIsCWItem(workLine.ItemId);
        
        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(workLine.itemId))
        {
            if (InventUseDimOfInventSumToggle::instance().isEnabled() 
                && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
            {
                InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumUnionDeltaPhysicalQtyWithDim;

                select InventBatchId, ExpDate, PdsDispositionCode from inventBatch
                    order by ExpDate asc
                    where inventBatch.ItemId == workLine.ItemId
                        && inventBatch.expDate >= batchExpDate
                        && inventBatch.PdsBestBeforeDate >= batchBestBeforeDate
                    exists join inventSumUnionDeltaPhysicalQtyWithDim
                        where inventSumUnionDeltaPhysicalQtyWithDim.ItemId == inventBatch.ItemId
                            && ((isCWItem && inventSumUnionDeltaPhysicalQtyWithDim.PdsCWPhysicalInvent > 0)
                                || (!isCWItem && inventSumUnionDeltaPhysicalQtyWithDim.PhysicalInvent > 0))
                            && #InventDimFieldsFilter(inventSumUnionDeltaPhysicalQtyWithDim, _inventDim, inventDimParm)
                            && inventSumUnionDeltaPhysicalQtyWithDim.inventBatchId  == inventBatch.inventBatchId;
            }
            else
            {
                InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;
                
                select InventBatchId, ExpDate, PdsDispositionCode from inventBatch
                    order by ExpDate asc
                    where inventBatch.ItemId == workLine.ItemId
                        && inventBatch.expDate >= batchExpDate
                        && inventBatch.PdsBestBeforeDate >= batchBestBeforeDate
                    exists join inventSumUnionDeltaPhysicalQty
                        where inventSumUnionDeltaPhysicalQty.ItemId == inventBatch.ItemId
                            && ((isCWItem
                                && inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent > 0)
                            || (!isCWItem
                                && inventSumUnionDeltaPhysicalQty.PhysicalInvent      > 0))
                    #InventDimExistsJoinNoField(inventSumUnionDeltaPhysicalQty.InventDimId, inventDim, _inventDim, inventDimParm)
                        && inventDim.inventBatchId  == inventBatch.inventBatchId;
            }
        }
        else
        {
            InventSum  inventSum;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                select InventBatchId, ExpDate, PdsDispositionCode from inventBatch
                    order by ExpDate asc
                    where inventBatch.ItemId == workLine.ItemId
                        && inventBatch.expDate >= batchExpDate
                        && inventBatch.PdsBestBeforeDate >= batchBestBeforeDate
                    exists join inventSum
                        where  inventSum.ItemId     == inventBatch.ItemId
                            && inventSum.ClosedQty  == NoYes::No
                            && ((isCWItem
                                && inventSum.PdsCWPhysicalInvent > 0)
                            || (!isCWItem
                                && inventSum.PhysicalInvent      > 0))
                            && #InventDimFieldsFilter(inventSum, _inventDim, inventDimParm)
                            && inventSum.inventBatchId  == inventBatch.inventBatchId;
            }
            else
            {
                select InventBatchId, ExpDate, PdsDispositionCode from inventBatch
                    order by ExpDate asc
                    where inventBatch.ItemId == workLine.ItemId
                        && inventBatch.expDate >= batchExpDate
                        && inventBatch.PdsBestBeforeDate >= batchBestBeforeDate
                    exists join inventSum
                        where  inventSum.ItemId     == inventBatch.ItemId
                            && inventSum.ClosedQty  == NoYes::No
                            && ((isCWItem
                                && inventSum.PdsCWPhysicalInvent > 0)
                            || (!isCWItem
                                && inventSum.PhysicalInvent      > 0))
                    #InventDimExistsJoinNoField(inventSum.InventDimId, inventDim, _inventDim, inventDimParm)
                && inventDim.inventBatchId  == inventBatch.inventBatchId;
            }
        }

        return inventBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOldestBatchSetInLoc</Name>
				<Source><![CDATA[
    private Set getOldestBatchSetInLoc(InventDim _inventDim)
    {
        InventBatch        inventBatch = this.getBatches(_inventDim);
        InventBatchExpDate expDate;
        Set                oldestBatchSet = new Set(Types::String);
        const int		   MaximumBatchSet = 5;
        int				   batchCounter;
        WHSWorkTransType   workTransType = workLine.whsWorkTable().WorkTransType;

        while (inventBatch)
        {
            if (!inventBatch.validateBatchDispCodeForPicking(workTransType))
            {
                next inventBatch;
                continue;
            }

            if (expDate != dateNull() && expDate != inventBatch.expDate)
            {
                // If we have moved to batches with a different expiration date, it means that we have exhausted the oldest batches and we should not get more.
                break;
            }

            if (batchCounter >= MaximumBatchSet)
            {
                break;
            }
            expDate = inventBatch.expDate;

            oldestBatchSet.add(inventBatch.InventBatchId);
            batchCounter++;

            next inventBatch;
        }

        return oldestBatchSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOldestBatchQtyInLocStr</Name>
				<Source><![CDATA[
    private str getOldestBatchQtyInLocStr(InventDim _inventDim)
    {
        InventBatch         inventBatch = this.getBatches(_inventDim);
        InventBatchExpDate  expDate;
        container           batchQtyCon;
        const int		    MaximumBatchInMap = 5;
        int				    batchCounter;
        WHSWorkTransType    workTransType = workLine.whsWorkTable().WorkTransType;
        InventDim           inventDimBatch;
        str                 batchStr;

        while (inventBatch)
        {
            if (!inventBatch.validateBatchDispCodeForPicking(workTransType))
            {
                next inventBatch;
                continue;
            }

            if (expDate != dateNull() && expDate != inventBatch.expDate)
            {
                break;
            }

            if (batchCounter >= MaximumBatchInMap)
            {
                break;
            }
            expDate = inventBatch.expDate;

            inventDimBatch.initFromInventDim(_inventDim);
            inventDimBatch.inventBatchId = inventBatch.inventBatchId;
            inventDimBatch = InventDim::findDim(inventDimBatch);

            batchQtyCon += strFmt('"%1": %2', inventBatch.inventBatchId, WHSInventOnHand::getWorkPhysicalInventHandlingQty(workLine.ItemId, inventDimBatch.InventDimId));
            batchCounter++;

            next inventBatch;
        }

        if (conLen(batchQtyCon))
        {
            batchStr = Global::strReplace(con2Str(batchQtyCon), ',', ', '); 
            batchStr = strFmt('{%1}', batchStr);
        }

        return batchStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInitialPickForFEFOBatch</Name>
				<Source><![CDATA[
    private boolean isInitialPickForFEFOBatch()
    {
        return  workLine.WorkType == WHSWorkType::Pick
                &&  WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).PickOldestBatch != WHSPickOldestBatch::None
                &&  !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
                &&  InventTable::find(workLine.ItemId).isItemBatchActivated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryStatusBeingChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the inventory status is being changed in the current work flow.
    /// </summary>
    /// <param name = "_pass">The map to check.</param>
    /// <returns>true if the inventory status is being changed in the current work execution flow; otherwise, false</returns>
    protected boolean isInventoryStatusBeingChanged(WhsrfPassthrough _pass = pass)
    {
        return _pass.exists(#InventoryStatus)
                && _pass.exists(#FromInventoryStatus)
                && _pass.lookup(#InventoryStatus) != _pass.lookup(#FromInventoryStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOldestBatchFEFOLabel</Name>
				<Source><![CDATA[
    protected container addOldestBatchFEFOLabel()
    {
        container ret;

        if (this.isInitialPickForFEFOBatch())
        {
            InventDim currentDim = workLine.inventDimWithLocation();
            if (pass.exists(#LicensePlateId))
            {
                currentDim.LicensePlateId = pass.lookup(#LicensePlateId);
            }

            ret += [this.buildControl(#RFLabel,
                        WHSWorkExecuteDisplayFEFOBatchLabelControls::FEFOBatchList,
                        strFmt("@WAX:SuggestedFEFOBatches", this.getOldestBatchQtyInLocStr(currentDim)),
                        1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSuggestedGTDsLabel_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add label control before gtd input to suggest user available values
    /// </summary>
    /// <param name = "_inventDim">Operation dimensions to filter available gtds</param>
    /// <returns>Mobile app control</returns>
    protected container addSuggestedGTDsLabel_RU(InventDim _inventDim)
    {
        str controlLabel = WHSSuggestedGTDFormatter_RU::newFromParams(WHSSuggestedGTDGetter_RU::newFromParams(pass.parmItemId(), _inventDim).run()).run();

        return  [this.buildControl(
                    #RFLabel,
                    #SuggestedGTDList_RU,
                    strFmt("@Inventory_Localization:WHSMobileAppSuggestGTDControlLabel", controlLabel),
                    1, '', #WHSRFUndefinedDataType, '', 0)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInitialPickFromSourceLP</Name>
				<Source><![CDATA[
    private boolean isInitialPickFromSourceLP()
    {        
        return this.isPickStepWithLicensePlateIdCaptured() 
            && this.isInboundProcessOrPutBefore();        
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPickStepWithLicensePlateIdCaptured</Name>
				<Source><![CDATA[
    private boolean isPickStepWithLicensePlateIdCaptured()
    {
        if (step == #Pick
            && workLine.WorkType == WHSWorkType::Pick
            && pass.lookupStr(#LicensePlateId) != '')
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInboundProcessOrPutBefore</Name>
				<Source><![CDATA[
    private boolean isInboundProcessOrPutBefore()
    {
        if (!this.clearLicensePlateFieldOnSkipButtonClick()
            || !workTable.TargetLicensePlateId // Unlike other outbound processes, Cross docking work has the TargetLicensePlateId stamped on the work header from the begining of the work creation.
            || pass.lookupStr(#LicensePlateId) != workTable.TargetLicensePlateId // These values can be equal for initial pick if pick line was skipped
            || WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
            || workTable.isInbound())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisplayQuantityConfirmation</Name>
				<Source><![CDATA[
    private boolean shouldDisplayQuantityConfirmation()
    {
        if (this.isPickStepWithLicensePlateIdCaptured() 
            && (this.isInboundProcessOrPutBefore() 
                || workTable.WorkTransType == WHSWorkTransType::CrossDocking)) 
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearLicensePlateFieldOnSkipButtonClick</Name>
				<Source><![CDATA[
    [SysObsolete("This method will not be used in future releases", false, 24\06\2022)]
    protected boolean clearLicensePlateFieldOnSkipButtonClick()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLPControlFromPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build license plate control using form state.
    /// </summary>
    /// <param name = "_useOldValues">Determines whether the old values should be used to build license plate control.</param>
    /// <param name = "_updatePass">Determines whether the pass through map should be updated.</param>
    /// <param name = "_pass">Parameter to store form state during processing RF controls.</param>
    /// <returns>A container containing the state of the license plate control.</returns>
    protected container buildLPControlFromPass(
        boolean             _useOldValues,
        boolean             _updatePass,
        WHSRFPassthrough    _pass)
    {
        container ret = this.addLPOldestBatchLabel();

        if (_updatePass && !_useOldValues)
        {
            if (((pass.exists(#PickQtyConfirmationEnabled) && !_pass.exists(#QtyVerification))
                || (pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation)))
                && this.isInitialPickFromSourceLP())
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, _pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
            }
            else if (workTable.WorkTransType == WHSWorkTransType::CrossDocking)
            {
                InventDim           inventDim;
                WHSWorkInventTrans  workInventTrans;

                select firstOnly LicensePlateId from inventDim
                    exists join workInventTrans
                    where workInventTrans.InventDimIdFrom   == inventDim.inventDimId
                    &&    workInventTrans.WorkId            == workLine.WorkId
                    &&    workInventTrans.LineNum           == workLine.LineNum;

                ret = [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, inventDim.LicensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
            }
            else if (pass.isGroupPickConfirmed()
                && _pass.exists(WHSWorkExecuteDisplayGroupPickControls::GroupPickLP))
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, _pass.lookupStr(WHSWorkExecuteDisplayGroupPickControls::GroupPickLP), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
            }
            else
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
            }
        }
        else
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, _pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildNoYesCombobox</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a pipe-delimited string containing no, yes, and blank values.
    /// </summary>
    /// <returns>
    ///     Returns a pipe-delimited string containing no, yes, and blank values.
    /// </returns>
    protected str buildNoYesCombobox()
    {
        return '||' + enum2str(NoYes::No) + '||' + enum2str(NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAddLPVerificationControl</Name>
				<Source><![CDATA[
    [Hookable(true), Wrappable(true)]
    protected boolean shouldAddLPVerificationControl()
    {
        return workLine.WorkType == WHSWorkType::Pick
            && !pass.exists(WHSWorkExecuteDisplayVerificationControls::SkipLPVerification)
            && WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
            && WHSRFAutoConfirm::isLPConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLPVerificationControl</Name>
				<Source><![CDATA[
    protected container addLPVerificationControl()
    {
        container ret;

        if (this.shouldAddLPVerificationControl())
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayVerificationControls::LPVerification, "@WAX:VerifyLP", 1,
                                        pass.lookupStr(WHSWorkExecuteDisplayVerificationControls::LPVerification), extendedTypeNum(WHSLicensePlateId), '', 0, true)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchVerificationControl</Name>
				<Source><![CDATA[
    protected container addBatchVerificationControl()
    {
        container ret;

        if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
            &&  this.canAddBatchVerificationControlForWorkType()
            &&  workLine.WorkType == WHSWorkType::Pick
            &&  WHSRFAutoConfirm::isBatchConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType)
            &&  !pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation))
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayVerificationControls::BatchVerification, "@WAX:VerifyBatch", 1,
                                          pass.lookupStr(WHSWorkExecuteDisplayVerificationControls::BatchVerification),
                                          extendedTypeNum(WHSBatchVerification), '', 0, true)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSerialVerificationControl</Name>
				<Source><![CDATA[
    private container addSerialVerificationControl()
    {
        container ret;

        if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
            &&  this.canAddSerialVerificationControlForWorkType()
            &&  workLine.WorkType == WHSWorkType::Pick
            &&  WHSRFAutoConfirm::isSerialConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType)
            &&  !pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation))
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayVerificationControls::SerialVerification, "@WAX:VerifySerial", 1,
                                          pass.lookupStr(WHSWorkExecuteDisplayVerificationControls::SerialVerification),
                                          extendedTypeNum(WHSSerialVerification), '', 0, true)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddBatchVerificationControlForWorkType</Name>
				<Source><![CDATA[
    protected boolean canAddBatchVerificationControlForWorkType()
    { 
        return workLine.whsWorkTable().isWorkTransTypeOutbound() || (WHSWorkExecuteDisplayAddBatchVerCtrlFlight::instance().isEnabled() && this.isInternalMovement());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddSerialVerificationControlForWorkType</Name>
				<Source><![CDATA[
    private boolean canAddSerialVerificationControlForWorkType()
    {
        return workLine.whsWorkTable().isWorkTransTypeOutbound();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOldestBatches</Name>
				<Source><![CDATA[
    private container buildOldestBatches(
            container _con,
            Map       _locationQtyMap)
    {
        container       ret = _con;
        ListEnumerator	le = olderBatchLocationList.getEnumerator();
        MapEnumerator   me = _locationQtyMap.getEnumerator();
        int             locationCounter;
            
        // The Session Schema of the WMDP has maxOccurs = 250 for the different controls.
        const int       MaxNumberOfLocations = 240;

        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayFEFOBatchLabelControls::FEFOLocationList, strFmt("@WAX:OldestBatchLocationList", workLine.InventQtyRemain), 1, '', #WHSRFUndefinedDataType, '', 0)];

        while ((locationCounter < MaxNumberOfLocations)
                && le.moveNext())
        {
            WMSLocationId currentLocationId = le.current();
            ret += [this.buildControl(#RFButton, currentLocationId, currentLocationId, 1, '', #WHSRFUndefinedDataType, '', 0)];
            locationCounter++;

            int i;
            container batchDateQty = _locationQtyMap.lookup(currentLocationId);
            for (i = 1; i <= conLen(batchDateQty); i += 3)
            {
                ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayFEFOBatchLabelControls::LocationInformation,
                                              strFmt("@WAX:FEFOLocationInformation", conPeek(batchDateQty, i), conPeek(batchDateQty, i + 1), conPeek(batchDateQty, i + 2)),
                                              1, '', #WHSRFUndefinedDataType, '', 0)];
                locationCounter++;
            }
        }

        ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn, strFmt("@WAX:CurrentWorkLineLocation", workLine.WMSLocationId), 1, '', #WHSRFUndefinedDataType, '', 0)];
            
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areOlderBatchesWithinWarehouseDisplayed</Name>
				<Source><![CDATA[
    private boolean areOlderBatchesWithinWarehouseDisplayed()
    {
        return WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AreOlderBatchesWithinWarehouseDisplayed
                && !pass.exists(WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQualityCheck</Name>
				<Source><![CDATA[
    private container buildQualityCheck(container _con)
    {
        container ret = _con;

        if (!pass.exists(#LicensePlateId))
        {
            pass.insert(#LicensePlateId, workLine.whsWorkTable().TargetLicensePlateId);
        }
    
        ret += [this.buildControl(#RFLabel, #Enter, "@WAX:QualityCheck", 1, '', #WHSRFUndefinedDataType, '', 0)];
    
        ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayQualityCheckControls::Accept, "@WAX1835", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayQualityCheckControls::Reject, "@WAX1836", 1, '', #WHSRFUndefinedDataType, '', 0)];
    
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocOrLPCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for checking Location or License Plate was scanned in the LocOrLP control.
    /// </summary>
    /// <param name = "_con">Container containing the form state before the controls are added.</param>
    /// <returns>Container containing the form state after the controls are added.</returns>
    [Hookable(false)]
    internal container buildLocOrLPCheck(container _con)
    {
        container ret = _con;
    
        ret += [this.buildControl(#RFLabel, #Enter, strFmt("@WAX:ValueEnteredForLocLPIdentifiesBothLPAndLocation", pass.lookup(#LocOrLP)), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayLocOrLPCheckControls::ConfirmInfo, "@WAX:WHSLocOrLPCheckWhichOfTheseToUse", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayLocOrLPCheckControls::ConfirmLocation, "@WAX248", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayLocOrLPCheckControls::ConfirmLicensePlate, "@WAX359", 1, '', #WHSRFUndefinedDataType, '', 0)];
    
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowLocOrLPCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether Location or License Plate confirmation screen should be built and shown for LocOrLP control.
    /// </summary>
    /// <param name = "_locOrLpIdentifier">Location or License Plate identifier.</param>
    /// <returns>true if confirmation screen should be built and shown; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean mustShowLocOrLPCheck(str _locOrLpIdentifier)
    {
        boolean ret = _locOrLpIdentifier
            && !pass.exists(WHSWorkExecuteDisplayLocOrLPCheckControls::LocOrLPCheck)
            && WHSLicensePlate::exist(_locOrLpIdentifier)
            && WMSLocation::whsGetLocationId(_locOrLpIdentifier, pass.lookup(#InventLocationId));

        if (ret)
        {
            WMSLocationId locationId = WhsrfControlData::findLocationByLP(_locOrLpIdentifier, pass.lookup(#InventLocationId), mode == WHSWorkExecuteMode::MaterialConsumption);

            ret = locationId && locationId != _locOrLpIdentifier;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLocOrLPCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays checking Location or License Plate RF form based on conditions.
    /// </summary>
    /// <param name = "_con">Container containing the form state before the controls are added.</param>
    /// <param name = "_locOrLpIdentifier">Location or License Plate identifier.</param>
    /// <returns>Container containing the form state after the controls are added.</returns>
    [Hookable(false)]
    internal container displayLocOrLPCheck(container _con, str _locOrLpIdentifier)
    {
        container ret = _con;

        if (!_locOrLpIdentifier || (pass.lookupStr(#LocOrLP) && _locOrLpIdentifier != pass.lookupStr(#LocOrLP)))
        {
            pass.remove(WHSWorkExecuteDisplayLocOrLPCheckControls::LocOrLPCheck);
        }

        if (this.mustShowLocOrLPCheck(_locOrLpIdentifier))
        {
            pass.insert(#LocOrLP, _locOrLpIdentifier);
            ret = this.buildLocOrLPCheck(conNull());
            step = #LocOrLPCheck;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for picking work.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text, empty string by default.
    /// </param>
    /// <param name="_updatePass">
    /// Determines whether the pass through map should be updated, true by default.
    /// </param>
    /// <param name="_includeActualData">
    /// Determines whether the form just shows label control for pick line, false by default.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    public container buildPick(
        container   _con,
        str         _extraText          = '',
        boolean     _updatePass         = true,
        boolean     _includeActualData  = false)
    {
        container               ret = _con;
        WMSLocation             location;
        WHSLicensePlateId       licensePlateId;
        InventTable             inventTable;
        WHSLicensePlate         licensePlate;
        boolean                 licensePlateControlled;
        boolean                 isPotentialOverPick;
        boolean                 useOldValues;
        boolean                 passLPIsTargetLP = false;

        if (this.areOlderBatchesWithinWarehouseDisplayed())
        {
            Map  locationsWithOldestBatch = this.getOldestBatchLocationsAndQuantities();

            if (locationsWithOldestBatch && locationsWithOldestBatch.elements())
            {
                step = #FEFOWarehouseLocationList;
                return this.buildOldestBatches(ret, locationsWithOldestBatch);
            }
        }

        if (WHSWorkTable::find(workLine.WorkId).isInbound())
        {
            step = #Pick;
        }

        licensePlateId  = workTable.TargetLicensePlateId;
        inventTable     = InventTable::find(workLine.ItemId);

        if (workLine.wmsLocationId) 
        {
            location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
            licensePlateControlled = location.whsLocationIsLPControlled();
        }

        if (!pass.exists(#ItemId))
        {
            pass.insert(#ItemId, workLine.ItemId);
        }

        isPotentialOverPick = WHSWorkExecute::isPotentialOverPick(workTable, workLine, pass.exists(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) : '');

        if (!_includeActualData)
        {
            // If the previous step was a partial full or short pick then we want to use old values from the pass through to populate controls that may have already been entered.
            if (pass.lookupInt64(#prevStep) == #SplitWork
                || pass.lookupInt64(#prevStep) == #ShortPickConf)
            {
                // If we have already picked the LP and then entering full qty don't want to show the same LP again.
                if (workLine.InventQtyRemain == workLine.InventQtyWork
                        && pass.hasValue(#LicensePlateId))
                {
                    useOldValues = true;
                }
                pass.remove(#prevStep);
                pass.remove(#FullQty);
                noFullButton = true;
            }

            if (workLine.wmsLocationId)
            {
                pass.insert(#SystemPopulated, 1);
            }

            // Maybe overPicking, need to pop up pick form again to confirm pick qty
            if ((mode == WHSWorkExecuteMode::UserDirected || mode == WHSWorkExecuteMode::SystemDirected)
                &&  licensePlateControlled
                &&  isPotentialOverPick
                &&  !pass.exists(#LicensePlateId))
            {
                pass.insert(#SelectBestLP, 1);
            }

            if ((WhsWorkExecute::isPotentialStagedMultiSkuOverPick(workTable, workLine)
                ||  this.mustUpdateLPWithTargetLPForNoStopWorkLine())
                &&	pass.exists(#TargetLicensePlateId)
                &&	pass.exists(#LicensePlateId)
                &&	pass.lookup(#TargetLicensePlateId) != pass.lookup(#LicensePlateId))
            {
                pass.insert(#LicensePlateId, pass.lookup(#TargetLicensePlateId));
            }
        }
        if(pass.exists(#GroupingWorkNum))
        {
            if (mode == WHSWorkExecuteMode::SystemGrouping)
            {
                str labelText = strFmt("@WAX2394", pass.lookup(#GroupingWorkNum), pass.lookup(#GroupingWorkTotal));
                ret += [this.buildControl(#RFLabel, #GroupingLabel, labelText, 1, '', extendedTypeNum(WHSMobileAppWorkGroupingNumberField), '', 0)];

            }
            else if (mode == WHSWorkExecuteMode::UserGrouping)
            {
                str labelText = strFmt("@WAX2393", pass.lookup(#GroupingWorkNum));
                ret += [this.buildControl(#RFLabel, #GroupingLabel, labelText, 1, '', extendedTypeNum(WHSMobileAppWorkGroupingNumberField), '', 0)];
            }
        }
        ret += [this.buildControl(#RFLabel, #RFPick, this.getPickHeaderLabel(enum2str(workTable.WorkTransType)), 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (!_includeActualData)
        {
            if (this.shouldHandleByLP())
            {
                ret = this.buildPickHandleByLP(ret, workLine.wmsLocationId);
                return ret;
            }

            ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

            ret += this.addLocationConfirmationControl(WHSWorkType::Pick, location);

            if (this.mustShowTargetLicensePlate())
            {
                if (licensePlateId && !workLine.AskForNewLicensePlate)
                {
                    ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];

                    if (this.mustUpdateLicensePlateWithTargetLP(_updatePass))
                    {
                        pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
                        passLPIsTargetLP = true;
                    }
                }

                if (licensePlateId
                    &&  workLine.isFirstWorkLine()
                    &&  mode != WHSWorkExecuteMode::PickPack)
                {
                    if (!pass.hasValue(#LicensePlateId) 
                     && (pass.lookupNum(#PrevStep) != #OverpickStep))
                    {
                        pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
                        passLPIsTargetLP = true;
                    }

                    if (licensePlateControlled
                        &&  ((workLine.InventQtyRemain != 0
                        &&    workLine.InventQtyRemain != workLine.InventQtyWork)
                        ||   WHSWorkTable::anyPicksBeforeFirstPutCompleted(workLine.WorkId)))
                    {
                        ret += this.buildLPControlFromPass(useOldValues, _updatePass, pass);
                    }
                }
                else if (licensePlateControlled && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum) && !workLine.AskForNewLicensePlate)
                {
                    ret += this.buildLPControlFromPass(useOldValues, _updatePass, pass);
                }
            }
            else
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, this.enabledPickLicensePlateControl())];
            }

            if (!licensePlateId && !licensePlateControlled)
            {
                if ((mode == WHSWorkExecuteMode::UserGrouping
                    ||   mode == WHSWorkExecuteMode::SystemGrouping)
                    &&  pass.exists(#LicensePlateId))
                {
                    pass.remove(#LicensePlateId);
                }

                boolean enableTargetLP = WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP ? WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).OverrideTargetLP : true;

                if (pass.lookupStr(#TargetLicensePlateId)
                    && WhsrfControlData::validateTargetLicensePlateNotOnOpenInProcessWork(pass.lookupStr(#TargetLicensePlateId)))
                {
                    ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, pass.lookupStr(#TargetLicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, enableTargetLP)];
                }
                else if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
                {
                    ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId), extendedTypeNum(WHSLicensePlateId), '', 0, enableTargetLP)];
                }
                else
                {
                    ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
                }
            }
            else if (!licensePlateControlled && pass.exists(#LicensePlateId))
            {
                pass.remove(#LicensePlateId);
            }

            if (workLine.AskForNewLicensePlate)
            {
                if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
                {
                    ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId), extendedTypeNum(WHSLicensePlateId), '', 0)];
                }
                else
                {
                    ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
                }

                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, 0)];
            }

            ret += this.addLPVerificationControl();

            if (pass.exists(#LicensePlateId))
            {
                if (!pass.exists(#DimTrackingDelay))
                {
                    licensePlate = WHSLicensePlate::find(pass.lookup(#LicensePlateId));
                }
                else
                {
                    pass.remove(#DimTrackingDelay);
                }
            }

            if (!workLine.ItemId)
            {
                ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@WAX402", extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            }
            else
            {
                ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            
                // If there is quantity remaining, product confirmation will be handled below
                if (!workLine.QtyRemain
                    && !pass.isGroupPickConfirmed())
                {
                    ret += this.addProductConfirmationControl(WHSWorkType::Pick);
                }
            }
        }
        else
        {
            ExtendedTypeId inputType = extendedTypeNum(InventInventItemSearchItem);

            if (!workLine.ItemId)
            {
                ret += [this.buildControl(#RFLabel, #ItemId, strFmt("@WAX739", "@WAX402" ,'' ,'' ,''), 1, '',  inputType, '', 0)];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #ItemId, strFmt("@WAX739", workLine.ItemId,'' ,'' ,''), 1, '',  inputType, '', 0)];
            }
        }

        WhsWorkExecuteDisplayBuildPickParameters buildPickParameters = WhsWorkExecuteDisplayBuildPickParameters::construct();
        buildPickParameters.IncludeActualData = _includeActualData;
        buildPickParameters.IsPotentialOverPick = isPotentialOverPick;
        buildPickParameters.IsLicensePlateControlled = licensePlateControlled;
        buildPickParameters.PassLicensePlateIsTargetLicensePlate = passLPIsTargetLP;

        ret = this.buildPickForWorkLineWithRemainingQuantity(ret, buildPickParameters);

        ret = this.buildPickForWorkLineItemId(ret);

        // Build label controls for all dimensions specified above location
        if (!pass.isGroupPickConfirmed())
        {
            ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId, !_includeActualData);
            ret = this.buildBelowLocationDimensions(ret, !_includeActualData);
        }
      
        if (!_includeActualData)
        {
            // Build control to capture next dimension
            // No need to prompt for dimension if kanban picking in a license plate controlled location if potential overpick
            if (!this.isWorkLineSerialValidated(workLine) // if we have been through the serial assignment, we don't need to prompt for dimensions
                && ((licensePlateControlled
                &&   licensePlate
                &&   (workTable.WorkTransType != WHSWorkTransType::KanbanPick || !isPotentialOverPick))
                ||  !licensePlateControlled))
            {
                ret = this.buildNextDimensionCaptureControl(ret, workLine.inventDimWithLocation(), workLine.ItemId, workLine.InventQtyRemain, _updatePass);
            }

            if (!this.isWorkLineSerialValidated(workLine))
            {
                if (this.promptForWeight(passLPIsTargetLP, licensePlateControlled))
                {
                    boolean enableWeight = pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::WeightIsReadOnly) == 0;

                    if (pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation))
                    {
                        ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight), extendedTypeNum(Weight), '', 0, false)];
                    }
                    else if (!licensePlateControlled
                        || (pass.hasValue(#LicensePlateId) && !(_updatePass && !useOldValues)))
                    {
                        ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight), extendedTypeNum(Weight), '', 0, enableWeight)];

                        // Make sure we don't process the work line before prompting for weight.
                        if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight) && (!isPotentialOverPick || !pass.exists(#Initiation)))
                        {
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt, 1);
                        }
                    }
                }
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickForWorkLineItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for picking work line item id.
    /// </summary>
    /// <param name = "_con">Container containing the form state before the controls are added.</param>
    /// <returns>Container containing the form state after the controls are added.</returns>
    protected container buildPickForWorkLineItemId(container _con)
    {
        container ret = _con;

        if (workLine.ItemId)
        {
            WHSRFDescription1 description1 = WHSInventTable::find(workLine.ItemId).rfDescription1;
            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(workLine.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            WHSRFDescription2 description2 = WHSInventTable::find(workLine.ItemId).rfDescription2;
            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt('\t        %1', description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickForWorkLineWithRemainingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for picking work line with remaining quantity.
    /// </summary>
    /// <param name = "_con">Container containing the form state before the controls are added.</param>
    /// <param name = "_buildPickParameters">The <c>WhsWorkExecuteDisplayBuildPickParameters</c> object.</param>
    /// <returns>Container containing the form state after the controls are added.</returns>
    protected container buildPickForWorkLineWithRemainingQuantity(
        container   _con,
        WhsWorkExecuteDisplayBuildPickParameters _buildPickParameters)
    {
        container ret = _con;

        if (workLine.QtyRemain)
        {
            Qty                 qtyNum;
            InventQty           inventQtyNum;
            UnitOfMeasureSymbol uom;
            boolean groupPick = pass.isGroupPick();
            if (groupPick)
            {
                WHSGroupPickLineDetails groupPickLineDetails = WHSGroupPickLineDetails::newFromWorkLine(workLine);

                qtyNum          = groupPickLineDetails.lowestUOMOnWorkQty;
                inventQtyNum    = groupPickLineDetails.inventQty;
                uom             = groupPickLineDetails.lowestUOMOnWork;
            }
            else
            {
                qtyNum          = workLine.QtyRemain;
                inventQtyNum    = workLine.InventQtyRemain;
                uom             = workLine.UnitId;
            }

            str                     qty         = WHSWorkExecuteDisplay::num2StrDisplay(qtyNum);
            str                     inventQty   = WHSWorkExecuteDisplay::num2StrDisplay(inventQtyNum);
            InventHandlingUnitID    inventUOM   = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);
            InventDim               inventDim   = InventDim::find(workLine.InventDimId);
            boolean                 qtyConfirmationEnabled = WHSRFAutoConfirm::isVerifyQtyConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Pick);
        
            [inventQtyNum, qtyNum] = this.adjustPickQuantities(inventQtyNum, qtyNum, inventUOM, uom, inventDim, _buildPickParameters.IsLicensePlateControlled, _buildPickParameters.IsPotentialOverPick);
            qty = WHSWorkExecuteDisplay::num2StrDisplay(qtyNum);
            inventQty = WHSWorkExecuteDisplay::num2StrDisplay(inventQtyNum);

            if (!_buildPickParameters.IncludeActualData && workLine.ItemId)
            {
                Qty piecesToConfirm;

                if (inventQtyNum)
                {
                    piecesToConfirm = min(workLine.InventQtyRemain, inventQtyNum);
                }
                else
                {
                    piecesToConfirm = workLine.InventQtyRemain;
                }
                    
                ret += this.addProductConfirmationControl(WHSWorkType::Pick, piecesToConfirm);
            }

            str labelStr;
            if (_buildPickParameters.IsPotentialOverPick)
            {
                labelStr = strFmt("@SYP4881769", qty, uom, inventQty, inventUOM, uomQtySeparator);
            }
            else if (qtyConfirmationEnabled)
            {
                labelStr = this.buildUOMSequenceLabel(inventQtyNum);
            }
            else
            {
                labelStr = this.buildPickQuantityWithWorkUnitLabel("@WAX1283", qty, uom, inventQty, inventUOM, uomQtySeparator);
            }

            if (this.mustShowOverPickRFQtyLabel(_buildPickParameters.IsPotentialOverPick, _buildPickParameters.PassLicensePlateIsTargetLicensePlate))
            {
                Qty overPickQty;
                InventQty overPickInventQty;
                [overPickQty, overPickInventQty] = this.calcQtyOverPicking(pass.lookupStr(#LicensePlateId), workLine, inventUOM);
                qty = WHSWorkExecuteDisplay::num2StrDisplay(overPickQty);
                inventQty = WHSWorkExecuteDisplay::num2StrDisplay(overPickInventQty);
                pass.insert(#ProductionOverPickQty, overPickQty);
                ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1685", qty, uom), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
            }
            else
            {
                pass.remove(#ProductionOverPickQty);
                ret += [this.buildControl(#RFLabel, #RFQtyLabel, labelStr, 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
            }

            if (!_buildPickParameters.IncludeActualData && pass.exists(#MenuItem))
            {
                if (qtyConfirmationEnabled
                    && !pass.isGroupPickConfirmed())
                {
                    if (groupPick)
                    {
                        pass.insert(WHSWorkExecuteDisplayGroupPickControls::GroupPickQty, qty);
                    }

                    if (workLine.ItemId)
                    {
                        str uomsToConfirm = this.buildUOMSequenceGroupString(pass.lookup(#ItemId), false);

                        if (_buildPickParameters.IsLicensePlateControlled && pass.lookupStr(#PickQtyConfirmationEnabled))
                        {
                            if (!pass.exists(#QtyVerification)
                                && this.shouldDisplayQuantityConfirmation())
                            {
                                ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, pass.lookupStr(#QtyVerification), extendedTypeNum(Qty), '', 0)];
                                ret += [this.buildControl(#RFCombobox, #QtyVerifyUOM, "@WAX721", 1, uomsToConfirm, #WHSRFUndefinedDataType, '', 0, true, uom)];
                            }
                        }
                        else
                        {
                            ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, pass.lookupStr(#QtyVerification), extendedTypeNum(Qty), '', 0)];
                            ret += [this.buildControl(#RFCombobox, #QtyVerifyUOM, "@WAX721", 1, uomsToConfirm, #WHSRFUndefinedDataType, '', 0, true, uom)];
                        }
                    }
                    else
                    {
                        // QtyConfirmation is not set up to handle multiple Item ids in a single work step.
                        ret = this.addErrorLabel(conNull(), "@WAX:WarningMixedLPQtyConfirmationSkipped", WHSRFColorText::Warning) + ret;
                        pass.insert(#QtyVerification, workLine.QtyRemain);
                    }
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPickQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the pick quantities.
    /// </summary>
    /// <param name = "_inventQty">The current quantity in inventory unit.</param>
    /// <param name = "_qty">The quantity.</param>
    /// <param name = "_inventUOM">The inventory unit of measure.</param>
    /// <param name = "_uom">The unit of measure.</param>
    /// <param name = "_inventDim">The dimension for the pick.</param>
    /// <param name = "_isLicensePlateControlled">Flag describing if the location is license plate controlled.</param>
    /// <param name = "_isPotentialOverPick">Flag describing is the pick is a potential over pick.</param>
    /// <returns>A container with the adjusted inventory quantity and quantity.</returns>
    protected container adjustPickQuantities(
        InventQty               _inventQty,
        Qty                     _qty,
        UnitOfMeasureSymbol     _inventUOM,
        UnitOfMeasureSymbol     _uom,
        InventDim               _inventDim,
        boolean                 _isLicensePlateControlled,
        boolean                 _isPotentialOverPick)
    {
        InventQty inventQty = _inventQty;
        Qty qty = _qty;
        
        if ((this.isForOutboundShipment() || this.shouldAdjustPickQuantitiesForProdPick())
            && pass.exists(#LicensePlateId)
            && pass.lookupStr(#LicensePlateId) != ''
            && _isLicensePlateControlled
            && !pass.exists(#QtyVerification)
            && !pass.exists(#DetermineStep)
            && !pass.exists(WHSWorkExecuteDisplayPickPackControls::SkipPickQuantityAdjustment)
            && WHSLicensePlate::find(pass.lookupStr(#LicensePlateId)).LicensePlateLevel == 0)
        {
            //set the quantity to the min of the remaining and the quantity on the lp
            //so user is informed of the right qty to pick for scenarios where the lp has less qty than what remains to be picked
            Qty qtyOnLicensePlate = WHSInvent::getQtyOnLicensePlate(pass.lookupStr(#LicensePlateId), workLine.ItemId, _inventDim.inventDimId, workLine.wmsLocationId);
            inventQty = min(inventQty, qtyOnLicensePlate);

            EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
            if (releasedProductUnitConverter.canBeConverted(UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUOM),
                                                            UnitOfMeasure::unitOfMeasureIdBySymbol(_uom),
                                                            workLine.ItemId,
                                                            workLine.InventDimId))
            {
                qtyOnLicensePlate = releasedProductUnitConverter.convert(qtyOnLicensePlate,
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUOM),
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_uom),
                                                                        NoYes::No,
                                                                        workLine.ItemId,
                                                                        workLine.InventDimId,
                                                                        NoYes::No);
                qty = min(qty, qtyOnLicensePlate);
            }
        }

        return [inventQty, qty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForOutboundShipment</Name>
				<Source><![CDATA[
    private boolean isForOutboundShipment()
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType).isForOutboundShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInternalMovement</Name>
				<Source><![CDATA[
    private boolean isInternalMovement()
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType).isInternalMovement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAdjustPickQuantitiesForProdPick</Name>
				<Source><![CDATA[
    private boolean shouldAdjustPickQuantitiesForProdPick()
    {
        // If raw material item is catch weight item and does not allow over picking,
        // pick quantities need to be adjusted after license plate specified, otherwise wrong quantity may appear on picking screen.
        return workTable.WorkTransType == WHSWorkTransType::ProdPick
            && workLine.ItemId
            && PdsGlobal::pdsIsCWItem(workLine.ItemId)
            && WHSInventTable::find(workLine.ItemId).AllowMaterialOverPick == WHSAllowMaterialOverPick::OrderPicking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowOverPickRFQtyLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether RFQtyLabel control should be build and shown for certain over pick conditions.
    /// </summary>
    /// <param name = "_isPotentialOverPick">Boolean value indicating whether it's a potential over pick.</param>
    /// <param name = "_passLPIsTargetLP">Boolean value indicating whether pass license plate is a target license plate.</param>
    /// <returns>true if RFQtyLabel control should be build and shown; otherwise, false.</returns>
    protected boolean mustShowOverPickRFQtyLabel(
        boolean _isPotentialOverPick,
        boolean _passLPIsTargetLP)
    {
        return pass.lookupStr(#LicensePlateId)
            && ((_isPotentialOverPick && pass.exists(#SelectBestLP))
                   || WHSWorkExecute::isPotentialStagedOverPick(workTable, workLine))
               && !_passLPIsTargetLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateLicensePlateWithTargetLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether license plate value should be updated with target license plate.
    /// </summary>
    /// <param name = "_updatePass">Boolean value indicating whether the pass through map should be updated.</param>
    /// <returns>true if license plate value should be updated with target license plate; otherwise, false.</returns>
    private boolean mustUpdateLicensePlateWithTargetLP(boolean _updatePass)
    {
        return _updatePass
                && ((!pass.hasValue(#LicensePlateId)
                        && (mode != WHSWorkExecuteMode::PickPack))
                    || ((mode == WHSWorkExecuteMode::UserGrouping
                            || mode == WHSWorkExecuteMode::SystemGrouping)
                        && (!workLine.isInitialPickLine()
                                || this.isWorTypeUpdateLPwithTargetLP())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorTypeUpdateLPwithTargetLP</Name>
				<Source><![CDATA[
    private boolean isWorTypeUpdateLPwithTargetLP()
    {
        WHSWorkTable workTableLoc = WHSWorkTable::find(workLine.WorkId);
        return workTableLoc.WorkTransType == WHSWorkTransType::CrossDocking ||  workTableLoc.isInbound();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowTargetLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the target license plate must be shown.
    /// </summary>
    /// <returns>true if the target license plate must be shown; otherwise, false.</returns>
    protected boolean mustShowTargetLicensePlate()
    {
        return mode != WHSWorkExecuteMode::KanbanPutAndLocate
                && (mode != WHSWorkExecuteMode::ReportAsFinishedAndLocate
                    || (mode == WHSWorkExecuteMode::ReportAsFinishedAndLocate && workTable.WorkTransType != WHSWorkTransType::ProdPut));
    }

]]></Source>
			</Method>
			<Method>
				<Name>enabledPickLicensePlateControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the license plate control is enabled.
    /// </summary>
    /// <returns>true if the license plate is enabled; otherwise, false.</returns>
    [Replaceable]
    protected boolean enabledPickLicensePlateControl()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickQuantityWithWorkUnitLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build pick quantity label string.
    /// </summary>
    /// <param name = "_lable">Label text.</param>
    /// <param name = "_qty">The pick quantity.</param>
    /// <param name = "_uom">Unit for quantity.</param>
    /// <param name = "_inventQty">Inventory quantity.</param>
    /// <param name = "_inventUOM">Unit for inventory quantity.</param>
    /// <param name = "_uomQtySeparator">Character used to separate quantities in label string.</param>
    /// <returns>Formatted label string.</returns>
    protected str buildPickQuantityWithWorkUnitLabel(str _lable, str _qty, UnitOfMeasureSymbol _uom, str _inventQty, InventHandlingUnitID _inventUOM, str _uomQtySeparator)
    {
        return strFmt(_lable, _qty, _uom, _inventQty, _inventUOM, _uomQtySeparator);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUOMSequenceLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the work quantity for all inventory units on the item's unit of measure sequence group.
    /// </summary>
    /// <param name="_inventQtyWork">
    /// The work quantity in inventory units.
    /// </param>
    /// <returns>
    /// A string with the work quantity in all inventory units.
    /// </returns>
    protected str buildUOMSequenceLabel(Qty _inventQtyWork)
    {
        WHSUOMSeqGroupLine                  uomSeqGroupLine;
        InventHandlingUnitId                inventUOM;
        Qty                                 uomQty;
        str                                 conversionStr;
        WHSInventTable                      whsInventTable = whsInventTable::find(pass.lookup(#ItemId));
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        inventUOM = WHSCatchWeightHelper::inventHandlingUnitId(whsInventTable.ItemId);

        while select UnitId from uomSeqGroupLine
            order by LineNum
            where uomSeqGroupLine.UOMSeqGroupId == whsInventTable.UOMSeqGroupId
        {
            if (releasedProductUnitConverter.canBeConverted(UnitOfMeasure::unitOfMeasureIdBySymbol(inventUOM),
                                                            UnitOfMeasure::unitOfMeasureIdBySymbol(uomSeqGroupLine.UnitId),
                                                            workLine.ItemId,
                                                            workLine.InventDimId))
            {
                uomQty = releasedProductUnitConverter.convert(_inventQtyWork,
                                                              UnitOfMeasure::unitOfMeasureIdBySymbol(inventUOM),
                                                              UnitOfMeasure::unitOfMeasureIdBySymbol(uomSeqGroupLine.UnitId),
                                                              NoYes::No,
                                                              workLine.ItemId,
                                                              workLine.InventDimId,
                                                              NoYes::Yes);

                if (UnitOfMeasure::unitOfMeasureIdBySymbol(inventUOM) != UnitOfMeasure::unitOfMeasureIdBySymbol(uomSeqGroupLine.UnitId))
                {
                    uomQty = decRound(uomQty, UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(uomSeqGroupLine.UnitId)));
                }

                if (conversionStr == '')
                {
                    conversionStr = strFmt("@WAX1685", WHSWorkExecuteDisplay::num2StrDisplay(uomQty), uomSeqGroupLine.UnitId);
                }
                else
                {
                    conversionStr += uomQtySeparator + strFmt("@WAX736", WHSWorkExecuteDisplay::num2StrDisplay(uomQty), uomSeqGroupLine.UnitId);
                }
            }
        }

        return conversionStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPurchaseOrderReceiveSerialDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the serial dimension controls for receiving inbound orders.
    /// </summary>
    /// <param name = "_itemId">The item being received.</param>
    /// <returns>The controls required for capturing serial numbers.</returns>
    protected container buildPurchaseOrderReceiveSerialDimension(ItemId _itemId)
    {
        InventSerialId serialId = pass.lookupStr(#SerialId);

        if (!serialId)
        {
            if (EcoResTrackingDimensionGroup::find(InventTable::find(_itemId).trackingDimensionGroup()).IsSerialNumberControlEnabled)
            {
                int newSerialNumberIndex = pass.lookupNum(IndexOfLastUsedSerialNumber) + 1;
                serialId = pass.lookupStr(strFmt(ListOfSerialNumbersForReceiving, newSerialNumberIndex));
                pass.insert(IndexOfLastUsedSerialNumber, newSerialNumberIndex);
            }
            else
            {
                serialId = this.receivingOrderLine(pass, false).getSerialToReceiveForCurrentLine();
            }
        }

        return [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, serialId, extendedTypeNum(InventSerialId), '', 0, serialId == '')];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPORecTrackingDimensions</Name>
				<Source><![CDATA[
    protected container buildPORecTrackingDimensions(
                                        container               _con,
                                        ItemId                  _itemId,
                                        Qty                     _defaultQty)
    {
        container           ret = _con;
        ListEnumerator      le;
        str                 qtyString;
        Qty                 receivingDimQty = _defaultQty;
        InventBatchId       batchId;

        WHSInventTable      whsInventTable     = WHSInventTable::find(_itemId);
        WHSReceiptOrderLine orderLine          = this.receivingOrderLine(pass, false);
        InventDim           orderLineInventDim = orderLine.inventDim();

        ret += [this.buildControl(#RFLabel, "@WAX5546", "@WAX5546", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (whsInventTable.rfDescription1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (whsInventTable.rfDescription2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];

        InventTable inventTable = InventTable::find(_itemId);
        le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            if (!this.mustShowInventoryDimensionForItem(inventTable, le.current()))
            {
                continue;
            }

            switch (le.current())
            {
                case fieldNum(InventDim, InventBatchId):
                    // If vendor batch details have been entered, all fields should already be populated within the pass.
                    if (pass.exists(#VendBatchInfoEntered))
                    {
                        batchId = pass.lookup(#BatchId);
                    }
                    else if (!pass.lookupStr(#BatchId))
                    {
                        if (orderLineInventDim.InventBatchId)
                        {
                            batchId = orderLineInventDim.InventBatchId;
                            pass.insert(#BatchId, batchId);
                        }
                        else
                        {
                            [batchId, receivingDimQty] =
                                WHSInventBatchReceiptDetails::getDefaultBatchAndQtyToReceiveFromInbound(orderLine, pass.lookup(#ReceiptId), _defaultQty, pass.lookupStr(#DimUOM));
                    
                        }
                    }
                    else if (pass.lookupStr(#BatchId) == orderLineInventDim.InventBatchId)
                    {
                        batchId = orderLineInventDim.InventBatchId;
                    }

                    if (batchId)
                    {
                        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0, false)];
                    }
                    else if (pass.lookupStr(#BatchId) && !this.itemRequiresManualDimTracking(InventTable::find(_itemId), InventTrackingDimType::Batch))
                    {
                        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookup(#BatchId), extendedTypeNum(InventBatchId), '', 0, false)];
                        batchId = pass.lookup(#BatchId);
                    }  
                    else
                    {
                        batchId = pass.lookupStr(#UpdatedBatchId);
                        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0)];
                    }

                    // Build the batch expiration date control.
                    ret = this.buildBatchExpDate(ret, batchId);
                    break;

                case fieldNum(InventDim, InventSerialId):
                    if (this.mustCaptureSerialOnReceipt(_itemId))
                    {
                        ret += this.buildPurchaseOrderReceiveSerialDimension(_itemId);
                        receivingDimQty = this.correctReceivingQtyWhenCaptureSerial(_itemId, receivingDimQty);
                    }
                    break;

                default:
                    // If any dimensions are specified on the inbound order line, default the value and make the control non editable.
                    if (orderLineInventDim.(le.current()))
                    {
                        ret += [this.buildControlForTableField(tableNum(InventDim),
                                                                                le.current(),
                                                                                fieldId2name(tableNum(InventDim), le.current()),
                                                                                1,
                                                                                orderLineInventDim.(le.current()),
                                                                                false)];
                    }
                    else
                    {
                        ret += [this.buildControlForTableField(tableNum(InventDim),
                                                                           le.current(),
                                                                           fieldId2name(tableNum(InventDim), le.current()),
                                                                           1,
                                                                           '',
                                                                           true)];
                    }
                    break;
            }
        }

        ret += this.buildRemainingReceiptQtyCurrentLPLabel(
                                                _itemId,
                                                pass.lookupNum(#DimRunningQty),
                                                WHSCatchWeightHelper::inventHandlingUnitId(_itemId));

        qtyString = (receivingDimQty != 0) ? WHSWorkExecuteDisplay::num2StrDisplay(receivingDimQty) : '';
        ret += [this.buildControl(#RFText, #DimQty, "@SYS105177", 1, qtyString, extendedTypeNum(Qty), '', 0)];
        ret = this.buildTrackingDimReceiptUOM(ret, '', false, false, pass.lookupStr(#DimUOM));
        
        if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
            && !WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId))
            && !WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)))
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, "@WAX:Weight", 1, '', extendedTypeNum(Weight), '', 0)];
        }

        // Build the batch disposition control
        ret = this.buildBatchDisposition(ret);

        // Build potency control
        ret = this.buildGetPotency(ret, batchId);

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctReceivingQtyWhenCaptureSerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Corrects receiving quantity based on serial number settings for an item.
    /// </summary>
    /// <param name = "_itemId">An Item Id to perform receipt of.</param>
    /// <param name = "_receivingDimQty">A receiving quantity.</param>
    /// <returns>A corrected receiving quantity.</returns>
    protected Qty correctReceivingQtyWhenCaptureSerial(ItemId _itemId, Qty _receivingDimQty)
    {
        Qty receivingDimQty = _receivingDimQty;
            
        if (receivingDimQty != 1)
        {
            if (EcoResTrackingDimensionGroup::find(InventTable::find(_itemId).trackingDimensionGroup()).IsSerialNumberControlEnabled)
            {
                receivingDimQty = 1;
            }
            else if (receivingDimQty && this.mustCaptureSerialOnReceiptInCurrentFlow(_itemId))
            {
                //we don't know if we are done with registering on the serial so we need to clear the quantity to avoid registering to much on the serial
                receivingDimQty = 0;
            }
        }
            
        return receivingDimQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildProductDimensionsFromInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds RF text controls for product dimensions based off an inventory dimension record.
    /// </summary>
    /// <param name="_con">
    /// The current RF container we are adding text controls to.
    /// </param>
    /// <param name="_itemId">
    /// The item whose product dimensions we are adding controls for.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimension record we are basing product dimension controls off of.
    /// </param>
    /// <param name="_enableControls">
    /// Boolean to determine whether added text controls should be editable.
    /// </param>
    /// <returns>
    /// An updated RF container which includes text controls for the item's product dimensions.
    /// </returns>
    protected container buildProductDimensionsFromInventDim(
        container   _con,
        ItemId      _itemId,
        InventDim   _inventDim,
        boolean     _enableControls = true)
    {
        container       ret = _con;
        ListEnumerator  le;
        FieldName       inventDimName;

        le = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId).activeFields().getEnumerator();

        while (le.moveNext())
        {
            inventDimName = fieldId2name(tableNum(InventDim), le.current());
            ret += [this.buildControlForTableField(tableNum(InventDim),
                                                   le.current(),
                                                   inventDimName,
                                                   1,
                                                   _inventDim.(le.current()),
                                                   _enableControls)];

            // If pass doesn't contain the inventory dimension, or the value in the pass is empty, 
            // and the field is no longer enabled, we must update pass with the data. 
            if (!pass.exists(inventDimName) 
                || (!_enableControls
                    && !pass.lookupStr(inventDimName)))
            {
                pass.insert(inventDimName, _inventDim.(le.current()));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildProductDimensionsText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds RF text controls for active product dimensions.
    /// </summary>
    /// <param name="_con">
    /// The current RF container we are adding text controls to.
    /// </param>
    /// <param name="_itemId">
    /// The item whose product dimensions we are adding controls for.
    /// </param>
    /// <param name="_populate">
    /// Boolean to determine whether to populate controls with current values in passthrough.
    /// </param>
    /// <param name="_enableControls">
    /// Boolean to determine whether added text controls should be editable.
    /// </param>
    /// <param name="_insertPass">
    /// Boolean to determine whether to add values to the passthrough if they don't exist.
    /// </param>
    /// <returns>
    /// An updated RF container which includes text controls for the item's product dimensions.
    /// </returns>
    protected container buildProductDimensionsText(
        container   _con,
        ItemId      _itemId,
        boolean     _populate = false,
        boolean     _enableControls = true,
        boolean     _insertPass = false)
    {
        container       ret = _con;
        ListEnumerator  le;
        FieldName       fieldName;

        le = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId).activeFields().getEnumerator();

        while (le.moveNext())
        {
            fieldName = fieldId2name(tableNum(InventDim), le.current());

            ret += [this.buildControlForTableField(tableNum(InventDim),
                                                   le.current(),
                                                   fieldName,
                                                   1,
                                                   _populate ? pass.lookupStr(fieldName) : '',
                                                   _enableControls)];

            if (_insertPass && !pass.exists(fieldName))
            {
                pass.insert(fieldName, '');
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFinalPutKanbanAutoComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if current work line is the final put for a kanban that should auto complete.
    /// </summary>
    /// <param name = "_workLine">
    /// The <c>WHSWorkLine</c> record to check.
    /// </param>
    /// <returns>
    /// true if final put and kanban is auto complete; otherwise, false.
    /// </returns>
    public static boolean isFinalPutKanbanAutoComplete(WHSWorkLine _workLine)
    {
        WHSWorkTable work = _workLine.whsWorkTable();

        return work.WorkTransType == WHSWorkTransType::KanbanPick
                && _workLine.isLastWorkLine()
                && Kanban::isKanbanAutoComplete(work.OrderNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildKanbanAutoCompletePutLocation</Name>
				<Source><![CDATA[
    private container buildKanbanAutoCompletePutLocation(container _con)
    {
        container ret = _con;

        PlanActivity planActivity = KanbanRule::find(Kanban::findKanbanId(workTable.OrderNum).KanbanRule).kanbanFlow().firstPlanActivity();

        ret += [this.buildControl(#RFText, #ToWarehouse, "@WAX3297", 1, planActivity.receiptLocation().InventLocationId, extendedTypeNum(InventLocationId), '', 0, false)];
        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, planActivity.receiptLocation().WMSLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddLPOverrideAndSplitButtonOnPut</Name>
				<Source><![CDATA[
    protected boolean canAddLPOverrideAndSplitButtonOnPut(WHSRFAutoConfirm _whsRFAutoConfirmPut)
    {
        return workLine.WMSLocationId
            && controller.canAddSplitAndLPOverrideButtonsForWorkTransType(workTable.WorkTransType)
            && !WHSWorkLine::getNextOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType)
            && !_whsRFAutoConfirmPut.AutoConfirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for putting work.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <param name="_overrideLP">
    /// Determines whether the Override LP control needs to be added or not.
    /// </param>
    /// <param name="_location">
    /// The location ID to set in the location control.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildPut(
                    container           _con,
                    str                 _extraText = '',
                    boolean             _overrideLP = false,
                    WMSLocationId       _location = '')
    {
        container               ret = _con;
        WHSLicensePlateId       licensePlateId;
        WHSLicensePlate         licensePlate;
        InventDim               inventDim;
        str                     qty;
        str                     inventQty;
        UnitOfMeasureSymbol     uom;
        InventHandlingUnitId    inventUOM;
        WHSWorkLine             prePickLine;

        ret += [this.buildControl(#RFLabel, #RFPut, strFmt("@WAX1270", workTable.WorkTransType), 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (this.shouldHandleByLP())
        {
            ret = this.buildPutHandleByLP(ret, workLine.wmsLocationId);
            return ret;
        }

        inventDim       = InventDim::find(workLine.InventDimId);
        qty             = WHSWorkExecuteDisplay::num2StrDisplay(workLine.QtyRemain);
        inventQty       = WHSWorkExecuteDisplay::num2StrDisplay(workLine.InventQtyRemain);
        uom             = workLine.UnitId;
        inventUOM       = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);

        if (workLine.wmsLocationId && !pass.exists(#UserPutLocation))
        {
            pass.insert(#SystemPopulated, 1);
        }

        if (WhsWorkExecuteDisplay::isFinalPutKanbanAutoComplete(workLine))
        {
            ret = this.buildKanbanAutoCompletePutLocation(ret);
        }
        else if (workLine.WMSLocationId)
        {
            ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, _location, extendedTypeNum(WMSLocationId), '', 0, true)];
        }

        WHSRFAutoConfirm whsRFAutoConfirmPut;
        if (pass.exists(#MenuItem))
        {
            whsRFAutoConfirmPut = WHSRFAutoConfirm::find(pass.lookup(#MenuItem), WHSWorkType::Put);
            if (whsRFAutoConfirmPut.LocVerification == NoYes::Yes)
            {
                if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).CheckText)
                {
                    ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, '', extendedTypeNum(WMSCheckText), '', 0)];
                }
                else if (pass.exists(#SystemPopulated))
                {
                    if ((workLine.WMSLocationId || _location)
                            && (!pass.exists(#PrevStep) || pass.lookup(#PrevStep) != WHSWorkExecuteDisplay::num2StrDisplay(#OverrideStep2))
                            && !pass.exists(#GroupPutawayConfirm))
                    {
                        ret += [this.buildControl(#RFText, #LocVerification, "@SYP4980001", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
                    }
                }
            }
        }

        licensePlateId  = workTable.TargetLicensePlateId;
        licensePlate    = WHSLicensePlate::find(licensePlateId);

        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, licensePlateId ? false : true)];

        if (_overrideLP ||
                (workTable.WorkTransType != WHSWorkTransType::ProdPick
                && workTable.WorkTransType != WHSWorkTransType::KanbanPick
                && workLine.ItemId         != ''
                && WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled()
                && WHSLicensePlate::getTotalHandlingQtyOnLicensePlateWithDelta(licensePlateId) > workLine.InventQtyRemain))
        {
            if (pass.exists(#MenuItem) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
            {
                ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1,
                                              WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId),
                                              extendedTypeNum(WHSLicensePlateId), '', 0,
                                              _overrideLP || WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).OverrideTargetLP)];
            }
            else
            {

                ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
            }
            _overrideLP = true;
        }
        else if (pass.exists(#TargetLicensePlateId) && pass.lookup(#TargetLicensePlateId) != workTable.TargetLicensePlateId)
        {
            pass.remove(#TargetLicensePlateId);
        }

        if (!workLine.ItemId)
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@WAX402", extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            ret += this.addProductConfirmationControl(WHSWorkType::Put);
        }

        if (workLine.QtyRemain)
        {
            // Use the previous pick line instead of the current put work line as the put location may non-LP controlled.
            prePickLine = WHSWorkLine::getPrevOppositeWorkLine(workLine.WorkId, workLine.LineNum, WHSWorkType::Put);

            // Fetch overPicking qty from pick line as they may have different inventory dimension
            if (workLine.WorkType == WHSWorkType::Put
                && (WHSWorkExecute::isPotentialOverPick(workTable, prePickLine)
                ||  WHSWorkExecute::isPotentialStagedOverPick(workTable, prePickLine)))
            {
                var overPickingInventQty = workLine.calculateOverPickPutQuantity();

                Qty overPickingQty;
                if (inventUOM != ''
                    && uom != '')
                {
                    // Only calculate converted put qty if both work line UOM and inventory UOM are specified
                    var releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
                    overPickingQty = releasedProductUnitConverter.convert(
                                        overPickingInventQty,
                                        UnitOfMeasure::unitOfMeasureIdBySymbol(inventUom),
                                        UnitOfMeasure::unitOfMeasureIdBySymbol(uom),
                                        NoYes::No,
                                        workLine.ItemId,
                                        workLine.InventDimId);
                }
                else
                {
                    uom = '';
                    overPickingQty = overPickingInventQty;
                }

                qty = WhsWorkExecuteDisplay::num2StrDisplay(overPickingQty);
                inventQty = WhsWorkExecuteDisplay::num2StrDisplay(overPickingInventQty);
                pass.insert(#ProductionOverPickQty, overPickingQty);
            }

            ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1283", qty, uom, inventQty, inventUOM, uomQtySeparator), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];

            if (pass.exists(#MenuItem))
            {
                if (WHSRFAutoConfirm::isVerifyQtyConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Put))
                {
                    ret += this.addQtyVerificationControl(uom);
                }
            }
        }

        if (workLine.ItemId)
        {
            ret += this.buildItemDescription(workLine.ItemId);
        }

        // Build label controls for all dimensions specified above location
        ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId);

        if (this.canAddLPOverrideAndSplitButtonOnPut(whsRFAutoConfirmPut))
        {
            if (workTable.WorkTransType != WHSWorkTransType::Replenishment)
            {
                addSplitButton = true;
            }

            if (WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).AllowLicensePlatePutOverride
                && WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled()
                && !_overrideLP)
            {
                addLPOverride = true;
            }
        }

        if (!workLine.WMSLocationId)
        {
            ret = this.addSuggestLocationButton(ret, true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReceivingExceptions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for selecting receiving exceptions.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_selected">
    /// Selected element from exception type combobox, empty string by default.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildReceivingExceptions(container _con, str _selected = '')
    {
        WHSWorkException        exceptions;
        container               ret = _con;
        boolean                 first = true;
        str                     elements;

        while select exceptions
                where exceptions.ExceptionType == WHSExceptionType::Receiving
        {
            if (first)
            {
                elements = exceptions.WorkExceptionDesc;
                first = false;
            }
            else
            {
                elements = elements + '||' + exceptions.WorkExceptionDesc;
            }
        }

        ret += [this.buildControl(#RFCombobox, #WHSReceivingException, "@WAX494", 1, elements, #WHSRFUndefinedDataType, '', 0, true, _selected, WHSRFColorText::Default, extendedTypeNum(WHSWorkExceptionDesc))];
        ret += [this.buildControl(#RFButton, #RFNextException, "@WAX718", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFSoftCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildShortPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for short picking.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildShortPick(container  _con,
                             str        _extraText = '')
    {
        container               ret = _con;
        WMSLocation             location;
        WHSLicensePlateId       licensePlateId;
        WHSRFDescription1       description1;
        WHSRFDescription2       description2;
        InventDim               inventDim;
        Qty                     qty;
        Qty                     inventQty;
        UnitOfMeasureSymbol     uom;
        InventHandlingUnitId    inventUOM;
        WHSWorkException        shortPickReason;
        boolean                 first = true;
        str                     elements;

        description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        inventDim       = InventDim::find(workLine.InventDimId);
        qty             = workLine.QtyRemain;
        inventQty       = workLine.InventQtyRemain;
        uom             = workLine.UnitId;
        inventUOM       = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);
        licensePlateId  = workTable.TargetLicensePlateId;

        if (workLine.wmsLocationId)
        {
            location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
        }

        ret += [this.buildControl(#RFLabel, #RFShortPick, "@WAX1322", 1, '',#WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        ret += this.addLocationConfirmationControl(WHSWorkType::Pick, location);

        if (licensePlateId)
        {
            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }

        if (location.whsLocationIsLPControlled())
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        }
        else if (!licensePlateId && !location.whsLocationIsLPControlled())
        {
            if (!pass.exists(#TargetLicensePlateId) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
            {
                pass.insert(#TargetLicensePlateId, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId));
            }

            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, pass.lookupStr(#TargetLicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0,
                    !pass.lookupStr(#TargetLicensePlateId) || workLine.AskForNewLicensePlate)];
        }

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (workLine.ItemId)
        {
            ret += this.addProductConfirmationControl(WHSWorkType::Pick);
            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '',#WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(workLine.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        // Build label controls for all dimensions specified above location
        ret = this.buildAboveLocationDimensions(ret, inventDim, workLine.ItemId);
    
        ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookupStr(#QtyToPick), extendedTypeNum(Qty), '', 0, !pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm))];
    
        boolean pieceByPieceEnabled =  this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                           workLine.WorkType,
                                                                           workLine.ItemId);

        ret = this.buildUOM(ret, '', false, false, false, pieceByPieceEnabled ? InventTable::find(workLine.ItemId).inventUnitId() : pass.lookupStr(#SelectedValueUOM), !pieceByPieceEnabled);

        while select shortPickReason
            where shortPickReason.ExceptionType == WHSExceptionType::ShortPick
        {
            if (first)
            {
                elements += shortPickReason.WorkExceptionDesc;
                first = false;
            }
            else
            {
                elements = elements + '||' + shortPickReason.WorkExceptionDesc;
            }
        }

        ret += [this.buildControl(#RFCombobox, #ShortPickReason, "@SYS86426", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookupStr(#SelectedValue), WHSRFColorText::Default, extendedTypeNum(WHSWorkExceptionDesc))];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTORecTrackingDimensions</Name>
				<Source><![CDATA[
    protected container buildTORecTrackingDimensions(
        container               _con,
        ItemId                  _itemId,
        Qty                     _defaultQty,
        UnitOfMeasureSymbol     _defaultUOM = '')
    {
        container           ret = _con;
        InventTransferLine  transferLine;
        WHSInventTable      whsInventTable;
        ListEnumerator      le;
        InventDim           transferLineDim;
        Qty                 qtyToDisplay = 0;
        Qty                 qtyToDisplayInDimUOM = 0;

        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        transferLine = InventTransferLine::find(pass.lookup(#TONum), pass.lookupNum(#TOLineNum));
        whsInventTable = WHSInventTable::find(_itemId);
        transferLineDim = transferLine.inventDim();

        str                  dimUOM    = pass.lookupStr(#DimUOM);
        Qty                  dimQty    = pass.lookupNum(#DimQty);
        InventHandlingUnitId inventUOM = WHSCatchWeightHelper::inventHandlingUnitId(_itemId);

        //If there is a UOM selected or calculated based on the unit sequence group ID, we want to keep it in the display by default.
        UnitOfMeasureSymbol uomToDisplay = dimUOM ? dimUOM : inventUOM;

        ret += [this.buildControl(#RFLabel, "@WAX5546", "@WAX5546", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (whsInventTable.rfDescription1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (whsInventTable.rfDescription2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];

        InventTable inventTable = InventTable::find(_itemId);
        le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            if (!this.mustShowInventoryDimensionForItem(inventTable, le.current()))
            {
                continue;
            }

            switch (le.current())
            {
                case fieldNum(InventDim, InventBatchId):

                    InventBatchId       batchId;
                    boolean             batchEnabled = true;
                    //we do this to handle a scenario where multiple serial numbers exist for multiple batches e.g B1S1, B1S2, B2S3. We don't want to jump to B2 since we don't know when the user is done with B1
                    if (pass.lookupStr(#BatchId))
                    {
                        //if we have a serial number and a batch then we should not allow editing the batch since we expect to get qty as the next
                        batchEnabled = !pass.exists(#SerialId);
                        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookupStr(#BatchId), extendedTypeNum(InventBatchId), '', 0, batchEnabled)];

                        //If the batch ID and the Qty have a value specified in the RF, we want to keep it.
                        if (dimQty != 0)
                        {
                            qtyToDisplay = dimQty;
                        }
                    }
                    else
                    {
                        [batchId, qtyToDisplay] = WHSInventTransferLine::retrieveBatchAndHandlingQtyLeftToReceive(
                                                                                                transferLine,
                                                                                                pass.lookupStr(#ReceiptId),
                                                                                                pass.lookupStr(#LicensePlateId));

                        if (qtyToDisplay)

                        {
                            /*
                            We have to display the minimum quantity between the current remaining to be received on this license plate
                            and the remaining ordered quantity for this batch as calculated by the getWHSBatchAndInventQtyLeftToReceive.
                            */
                            qtyToDisplay = min(qtyToDisplay, WHSCatchWeightHelper::convertInventQuantity(_itemId,
                                                                                                        _defaultUOM,
                                                                                                        _defaultQty,
                                                                                                        transferLine.InventDimId));
                                

                            /*
                            If there is a different unit selected or calculated based on the unit seq. group ID, we want to default the quantity
                            in that unit, if it is a value without any decimals.
                            */
                            if (dimUOM != '' &&  dimUOM != inventUOM)
                            {
                                qtyToDisplayInDimUOM = releasedProductUnitConverter.convert(
                                                                                qtyToDisplay,
                                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(inventUOM),
                                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(dimUOM),
                                                                                NoYes::No,
                                                                                _itemId,
                                                                                transferLine.InventDimId,
                                                                                NoYes::No);

                                if (qtyToDisplayInDimUOM >= 1 && qtyToDisplayInDimUOM == decRound(qtyToDisplayInDimUOM,0))
                                {
                                    qtyToDisplay = qtyToDisplayInDimUOM;
                                    uomToDisplay = dimUOM;
                                }
                                else
                                {
                                    uomToDisplay = inventUOM;
                                }
                            }
                            ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0, batchEnabled)];
                        }
                        //If there is not any batch retrieved, we will default the UOM control to the inventory unit
                        else
                        {
                            batchId = pass.lookupStr(#UpdatedBatchId);
                            ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0, batchEnabled)];
                        }

                        // Build the batch expiration date control.
                        ret = this.buildBatchExpDate(ret, batchId);
                    }
                    break;

                case fieldNum(InventDim, InventSerialId):
                    if (this.mustCaptureSerialOnReceipt(_itemId))
                    {
                        InventSerialId serialId = pass.lookupStr(#SerialId);
                        //allow for override to support scenario where something else than what was on the line was picked
                        boolean serialEnabled = serialId == '';

                        if (!serialId)
                        {
                            serialId = transferLine.inventDim().inventSerialId;
                            serialEnabled = true;
                        }

                        ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, serialId, extendedTypeNum(InventSerialId), '', 0, serialEnabled)];

                        if (EcoResTrackingDimensionGroup::find(InventTable::find(_itemId).trackingDimensionGroup()).IsSerialNumberControlEnabled)
                        {
                            qtyToDisplay = 1;
                            uomToDisplay = inventUOM;
                        }
                        //if the user entered a quantity in the #DimQty control, we want to preserve it
                        else if (dimQty)
                        {
                            qtyToDisplay = dimQty;
                        }
                        else if (_defaultQty == 1)
                        {
                            qtyToDisplay = 1;
                        }
                        //we should not default more than one since we don't know if we are splitting a batch in multiple serial numbers
                        else
                        {
                            qtyToDisplay = 0;
                            uomToDisplay = inventUOM;
                        }
                    }
                    break;

                default:
                    if (transferLineDim.(le.current()))
                    {
                        ret += [this.buildControlForTableField(tableNum(InventDim),
                                                               le.current(),
                                                               fieldId2name(tableNum(InventDim), le.current()),
                                                               1,
                                                               transferLineDim.(le.current()),
                                                               false)];
                    }
                    else
                    {
                        ret += [this.buildControlForTableField(tableNum(InventDim),
                                                               le.current(),
                                                               fieldId2name(tableNum(InventDim), le.current()),
                                                               1,
                                                               '',
                                                               true)];
                    }
                    break;
            }
        }

        ret += this.buildRemainingReceiptQtyCurrentLPLabel(
                                                    _itemId,
                                                    pass.lookupNum(#DimRunningQty),
                                                    inventUOM);

        if (dimUOM != '' &&  dimUOM != inventUOM)
        {
            ret += [this.buildControl(#RFLabel, 'Invent Conversion',
                                    strFmt("1 %1 = %2 %3", dimUOM,
                                                           WHSCatchWeightHelper::convertInventQuantity(_itemId, dimUOM, 1, transferLine.inventDimId),
                                                           inventUOM),
                                         1,'',#WHSRFUndefinedDataType, '', 0)];
        }

        str qtyStrToDisplay = (qtyToDisplay != 0) ? WHSWorkExecuteDisplay::num2StrDisplay(qtyToDisplay) : '';
        ret += [this.buildControl(#RFText, #DimQty, "@SYS105177", 1, qtyStrToDisplay, extendedTypeNum(Qty), '', 0)];
        ret = this.buildTrackingDimReceiptUOM(ret, '', false, false, uomToDisplay, true, false);
        
        if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
            && !WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId))
            && !WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)))
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, "@WAX:Weight", 1, '', extendedTypeNum(Weight), '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTrackingDimensionsText</Name>
				<Source><![CDATA[
    protected container buildTrackingDimensionsText(
        container           _con,
        ItemId              _itemId,
        WMSLocation         _wmsLocation,
        boolean             _outbound = true,
        boolean             _populate = false,
        boolean             _enableControls = true,
        boolean             _displaySerial = false)
    {
        container       ret = _con;
        ListEnumerator  le;

        InventTable inventTable = InventTable::find(_itemId);
        le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            if (!this.mustShowInventoryDimensionForItem(inventTable, le.current()))
            {
                continue;
            }

            switch (le.current())
            {
                case fieldNum(InventDim, InventSerialId):
                    if (_displaySerial
                        || (_outbound && WMSLocation::whsLocationHasSerial(_wmsLocation, _itemId))
                        || (!_outbound && this.mustCaptureSerialOnReceipt(_itemId)))
                    {
                        ret += [this.buildControl(#RFText,
                                                  #SerialId,
                        "@WAX1614",
                                                  1,
                                                  _populate ? pass.lookupStr(#SerialId) : '',
                                                  extendedTypeNum(InventSerialId),
                                                  '',
                                                  0,
                                                  _enableControls)];
                    }
                    break;

                default:
                    ret += [this.buildControlForTableField(tableNum(InventDim),
                                                   le.current(),
                                                   fieldId2name(tableNum(InventDim), le.current()),
                                                   1,
                                                   _populate ? pass.lookupStr(fieldId2name(tableNum(InventDim), le.current())) : '',
                                                   _enableControls)];
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTrackingDimReceiptUOM</Name>
				<Source><![CDATA[
    protected container buildTrackingDimReceiptUOM(
        container   _con,
        str         _label = '',
        boolean     _showBlank = false,
        boolean     _showOK = true,
        str         _selected = '',
        boolean     _enabled = true,
        boolean     _showCancel = false)
    {
        container   ret;
        str         elements;
        ItemId      itemId;

        if (pass.exists(#ItemId))
        {
            itemId = pass.lookup(#ItemId);
        }
        elements = this.buildUOMSequenceGroupString(itemId, _showBlank);

        ret = this.addTrackingDimRecUOMControl(_con, _label, elements, _selected, _enabled);

        if (_showOK)
        {
            ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        }

        if (_showCancel)
        {
            ret = this.addCancelButton(ret, 1, true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for selecting UOM.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_label">
    /// Label text.
    /// </param>
    /// <param name="_showRemove">
    /// Determines whether Remove from Quarantine button should be shown, false by default.
    /// </param>
    /// <param name="_showBlank">
    /// Determines whether UOM combobox should be blank, false by default.
    /// </param>
    /// <param name="_showOK">
    /// Determines whether OK button should be shown, true by default.
    /// </param>
    /// <param name="_selected">
    /// Selected element of the UOM combobox, empty string by default.
    /// </param>
    /// <param name="_enabled">
    /// Determines whether the UOM combobox is enabled, true by default.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildUOM(container    _con,
                       str          _label = '',
                       boolean      _showRemove = false,
                       boolean      _showBlank  = false,
                       boolean      _showOK     = true,
                       str          _selected   = '',
                       boolean      _enabled    = true)
    {
        container           ret = _con;
        str                 elements;
        str                 label = _label ? _label : "@WAX721";      // UOM
        ItemId              itemId;

        if (pass.exists(#ItemId))
        {
            itemId = pass.lookup(#ItemId);
        }

        elements = this.buildUOMSequenceGroupString(itemId, _showBlank);

        ret += [this.buildControl(#RFCombobox, #UOM, label, 1, elements, #WHSRFUndefinedDataType, '', 0, _enabled, _selected ? _selected : '', WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];

        if (_showRemove)
        {
            ret += [this.buildControl(#RFButton, "@SYS26394", "@WAX879", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        if (_showOK)
        {
            ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUOMSequenceGroupString</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a pipe-delimited string containing sequence group unit values.
    /// </summary>
    /// <param name="_itemId">
    ///     An item ID to build the string for.
    /// </param>
    /// <param name="_showBlank">
    ///     A Boolean value to indicate whether a blank value should be included in the list of available options.
    /// </param>
    /// <returns>
    ///     Returns a pipe-delimited string containing sequence group unit values.
    /// </returns>
    protected str buildUOMSequenceGroupString(
            ItemId  _itemId,
        boolean _showBlank)
    {
        return WHSInventTable::find(_itemId).buildUOMSequenceGroupString(_showBlank);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCycleCountUOMSequenceGroupString</Name>
				<Source><![CDATA[
    protected str buildCycleCountUOMSequenceGroupString(ItemId _itemId)
    {
        return WHSInventTable::find(_itemId).buildCycleCountUOMSequenceGroupString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkAuditTemplate</Name>
				<Source><![CDATA[
    container buildWorkAuditTemplate(container  _con)
    {
        container                   ret = _con;
        WHSWorkAuditTemplateTable   workAuditTemplateTable;
        WHSWorkAuditTemplateLine    workAuditTemplateLine;

        workAuditTemplateTable  = WHSWorkAuditTemplateTable::find(pass.lookup(#AuditTemplateId));
        workAuditTemplateLine   = WHSWorkAuditTemplateLine::find(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));

        // Header label referencing audit break field
        ret += [this.buildControl(#RFLabel, #Scan, strFmt("@WAX736",
                                                          workAuditTemplateTable.AuditDisplayLabel,
                                                          workTable.(workAuditTemplateTable.AuditBreakFieldNum)), 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (workAuditTemplateLine.AuditBreakFunction == WHSAuditBreakFunction::CaptureData)
        {
            ret += [this.buildControl(#RFText, #Field, workAuditTemplateLine.AuditRFLabel, 1, '', extendedTypeNum(Description), '', 0)];
        }
        else
        {
            // If not capture data audit function, display function
            ret += [this.buildControl(#RFLabel, #Field, workAuditTemplateLine.AuditRFLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkExceptions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds control to form state for selecting work exception.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the control is added.
    /// </param>
    /// <param name="_selected">
    /// Selected element in work exception combobox, empty string by default.
    /// </param>
    /// <returns>
    /// Container containing the form state after the control is added.
    /// </returns>
    container buildWorkExceptions(container _con, str _selected = '')
    {
        WHSWorkException    exceptions;
        container           ret = _con;
        boolean             first = true;
        str                 elements = '||';

        while select exceptions
            where exceptions.ExceptionType == WHSExceptionType::Work
        {
            if (first)
            {
                elements = exceptions.WorkExceptionDesc;
                first = false;
            }
            else
            {
                elements = elements + '||' + exceptions.WorkExceptionDesc;
            }
        }

        ret += [this.buildControl(#RFCombobox, #WHSWorkException, "@WAX639", 1, elements, #WHSRFUndefinedDataType, '', 0, true, _selected, WHSRFColorText::Default, extendedTypeNum(WHSWorkExceptionDesc))];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capturePotency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether potency must be captured during receiving flows.
    /// </summary>
    /// <param name="_itemId">
    ///     The item ID.
    /// </param>
    /// <returns>
    ///     Returns true if potency must be captured.
    /// </returns>
    protected boolean capturePotency(ItemId _itemId = '')
    {
        InventTable inventTable;
        ItemId      itemId = _itemId;

        if (!itemId)
        {
            itemId = pass.lookupStr(#ItemId);
        }

        inventTable = InventTable::findHavingPotencyAttribute(itemId);

        return inventTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureSerialNumber</Name>
				<Source><![CDATA[
    private boolean mustCaptureSerialNumber(InventTable _inventTable)
    {
        InventNumGroup inventNumGroup = InventNumGroup::find(_inventTable.SerialNumGroupId);
        if (inventNumGroup.PurchActivation && this.isNotInterCompanyPOReceive())
        {
            EcoResTrackingDimensionGroup trackingDimGroup = EcoResTrackingDimensionGroup::find(_inventTable.trackingDimensionGroup());

            if (!this.itemRequiresManualDimTracking(_inventTable, InventTrackingDimType::Serial))
            {
                // we need to allow serials modification if they were pregenerated on PO creation                    
                return !inventNumGroup.PhysicalUpdate;
            }

            return !this.isAllowBlankReceipt(trackingDimGroup)
                ? true
                : !EcoResProductInventoryDimensionGroups::mustCaptureSerialInOutboundProcess(trackingDimGroup);
        }
        return this.mustCaptureSerialOnReceipt(_inventTable.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNotInterCompanyPOReceive</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean isNotInterCompanyPOReceive()
    {
        if (!pass.exists(#PONum))
        {
            return false;
        }

        PurchTable purchOrder = PurchTable::find(pass.lookupStr(#PONum));
        
        return !purchOrder.isInterCompanyOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowBlankReceipt</Name>
				<Source><![CDATA[
    private boolean isAllowBlankReceipt(EcoResTrackingDimensionGroup _trackingDimGroup)
    {
        EcoResTrackingDimensionGroupFldSetup trackingDimensionGroupFldSetup = EcoResTrackingDimensionGroupFldSetup::findByDimensionGroupFieldId(_trackingDimGroup.RecId, fieldNum(InventDim, InventSerialId));
        return trackingDimensionGroupFldSetup.IsAllowBlankReceiptEnabled && trackingDimensionGroupFldSetup.IsPhysicalInventoryEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>captureTrackingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given item needs to have batch or serial numbers specified.
    /// </summary>
    /// <param name="_itemId">
    /// The item currently being transacted via the RF device.
    /// </param>
    /// <returns>
    /// True, if tracking dimensions need to be captured; otherwise False.
    /// </returns>
    /// <remarks>
    /// The capture of the tracking dimensions should only be triggered in case the
    /// <c>InventNumGroup</c> record requires an id to be manually provided, or, during a
    /// physical update.
    /// </remarks>
    protected boolean captureTrackingDimensions(ItemId _itemId)
    {
        boolean         ret;

        InventTable inventTable = InventTable::find(_itemId);
        ListEnumerator le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();
        while (le.moveNext())
        {
            switch (le.current())
            {
                case fieldNum(InventDim, InventSerialId):
                    ret = this.mustCaptureSerialNumber(inventTable);
                    break;
                case fieldNum(InventDim, InventBatchId):
                case fieldNum(InventDim, InventGTDId_RU):
                    ret = true;
                    break;
                default:
                    ret = false;
                    break;
            }

            if (ret)
            {
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTrackingDimensions</Name>
				<Source><![CDATA[
    public static boolean hasTrackingDimensions(WHSWorkExecuteMode _mode, WHSMenuItemName _menuItemName, ItemId _itemId)
    {
        return WhsWorkExecuteDisplay::construct(_mode, _menuItemName).captureTrackingDimensions(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForPickPackWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for picking and packing work.
    /// </summary>
    /// <param name="_sourceWorkId">
    /// Source work id.
    /// </param>
    /// <returns>
    /// true if the pick pack works are valid.
    /// </returns>
    boolean checkForPickPackWork(WHSWorkId  _sourceWorkId)
    {
        boolean         ret;
        WHSWorkTable    newWorkTable;
        WHSWorkTable    sourceWorkTable = WHSWorkTable::find(_sourceWorkId);
        WhsWorkExecute  workExecute = WhsWorkExecute::construct();

        while select newWorkTable
            where newWorkTable.WorkId           != _sourceWorkId                    &&
                  newWorkTable.InventSiteId     == sourceWorkTable.InventSiteId     &&
                  newWorkTable.InventLocationId == sourceWorkTable.InventLocationId &&
                  newWorkTable.OrderNum         == sourceWorkTable.OrderNum         &&
                  newWorkTable.LoadId           == sourceWorkTable.LoadId           &&
                  newWorkTable.Frozen           == NoYes::No                        &&
                  newWorkTable.WorkStatus       <= WHSWorkStatus::Open
        {
            ret = (workExecute.validatePickPackGrouping(_sourceWorkId, newWorkTable.WorkId) == ''  &&
                   WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookup(#MenuItem),
                                                                workExecute.getFirstOpenLine(newWorkTable.WorkId, pass.lookup(#UserId)).WorkClassId));

            if (ret)
            {
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWarehouseAllowsRFReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the warehouse has a default receipt location set that is LP controlled.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse to check for valid receipt location.
    /// </param>
    /// <returns>
    /// true if the warehouse has a LP controlled default receipt location; otherwise, false
    /// </returns>
    protected boolean checkWarehouseAllowsRFReceipt(InventLocationId _inventLocationId)
    {
        InventLocation  inventLocation;
        boolean         ret = true;

        inventLocation = InventLocation::find(_inventLocationId);

        if (!inventLocation.wmsLocationIdDefaultReceipt || !WMSLocation::find(inventLocation.wmsLocationIdDefaultReceipt, _inventLocationId).whsLocationIsLPControlled())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearClickedButtons</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears clicked buttons from form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state.
    /// </param>
    /// <returns>
    /// Container containing the form state after clearing clicked buttons.
    /// </returns>
    container clearClickedButtons(container     _con)
    {
        container   ret = _con;
        int         length = conLen(ret);

        for (int i = #FieldControlStartLoc; i <= length; ++i)
        {
            container controlCon = conPeek(ret, i);
            str controlType = conPeek(controlCon, #controlType);

            if (controlType == #RFButton || controlType == #RFDetourButton)
            {
                ret = conPoke(ret, i, conPoke(controlCon, #data, ''));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears errors from form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state.
    /// </param>
    /// <returns>
    /// Container containing the form state after errors are cleared.
    /// </returns>
    container clearErrors(container     _con)
    {
        container       ret = _con;
        int             i;
        int             length;

        length = conLen(ret);

        for (i = 3; i <= length; ++i)
        {
            ret = conPoke(ret, i, conPoke(conPeek(ret, i), #error, ''));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassBelowLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears out inventory dimension values in the passthrough that are below license plate in the reservation hierarchy.
    /// </summary>
    /// <param name="_itemId">
    /// The Id of the item which determines the reservation hierarchy, thus, determining dimensions below license plate.
    /// </param>
    protected void clearPassBelowLicensePlate(ItemId _itemId)
    {
        WHSReservationHierarchyProvider     reservationHierarchyProvider;
        WHSReservationHierarchyElementData  elementData;
        Enumerator                          enumerator;

        reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();

        enumerator = reservationHierarchyProvider.getDimListBelowLicensePlate(
                            InventTable::find(_itemId),
                            WHSReservationHierarchySortOrder::TopDown)
                        .getEnumerator();

        while (enumerator.moveNext())
        {
            elementData = enumerator.current();
            pass.remove(fieldId2name(tableNum(InventDim), elementData.parmDimensionFieldId()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassBelowLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears out inventory dimension values in the passthrough that are below location in the reservation hierarchy.
    /// </summary>
    /// <param name="_itemId">
    /// The Id of the item which determines the reservation hierarchy, thus, determining dimensions below license plate.
    /// </param>
    protected void clearPassBelowLocation(ItemId _itemId)
    {
        WHSReservationHierarchyProvider     reservationHierarchyProvider;
        WHSReservationHierarchyElementData  elementData;
        Enumerator                          enumerator;

        reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();

        enumerator = reservationHierarchyProvider.getDimListBelowLocation(
                            InventTable::find(_itemId),
                            WHSReservationHierarchySortOrder::TopDown)
                        .getEnumerator();

        while (enumerator.moveNext())
        {
            elementData = enumerator.current();
            pass.remove(fieldId2name(tableNum(InventDim), elementData.parmDimensionFieldId()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetTrackingDimensionsPassValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset values for pass through tracking dimensions.
    /// </summary>
    protected void resetTrackingDimensionsPassValues()
    {
        if (pass.exists(#BatchId))
        {
            pass.insert(#BatchId, '');
        }
        if (pass.exists(#SerialId))
        {
            pass.insert(#SerialId, '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineMaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines pass through maps.
    /// </summary>
    /// <param name="_targetMap">
    /// Target map that source map is combined to.
    /// </param>
    /// <param name="_sourceMap">
    /// Source map that is combined with target map.
    /// </param>
    /// <returns>
    /// Combined pass through map.
    /// </returns>
    /// <remarks>
    /// Overrides existing keys.
    /// </remarks>
    WHSRFPassthrough combineMaps(WHSRFPassthrough _targetMap, WHSRFPassthrough _sourceMap)
    {
        MapEnumerator       me;
        str                 key;
        str                 value;
        WHSRFPassthrough    ret = _targetMap;

        me = _sourceMap.getEnumerator();

        while (me.moveNext())
        {
            key = me.currentKey();
            value = me.currentValue();

            ret.insert(key, value);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countUniqueLPInLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the unique LP in a single location.
    /// </summary>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location.
    /// </param>
    /// <param name="_inventSiteId">
    /// Site id of the location.
    /// </param>
    /// <param name="_locationId">
    /// Location id.
    /// </param>
    /// <returns>
    /// The number of unique LP in the location.
    /// </returns>
    int countUniqueLPInLocation(InventLocationId    _inventLocationId,
                                InventSiteId        _inventSiteId,
                                WMSLocationId       _locationId)
    {
        InventDim inventDim;
        int       licensePlateCount;

        boolean isCWEnabled = WHSCatchWeightConfigurationKeyManager::instance().isEnabled();

        if  (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
        {

            if (isCWEnabled)
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                    while select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSumWithDim
                    group by inventSumWithDim.ItemId, inventSumWithDim.LicensePlateId
                        where inventSumWithDim.InventLocationId == _inventLocationId
                        &&    inventSumWithDim.wMSLocationId    == _locationId
                        &&    inventSumWithDim.LicensePlateId   != ''
                        &&    inventSumWithDim.InventSiteId     == _inventSiteId
                    {
                        boolean isCWItem = PdsGlobal::pdsIsCWItem(inventSumWithDim.ItemId);

                        if (isCWItem
                        && inventSumWithDim.PdsCWPhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                        else if (!isCWItem
                        && inventSumWithDim.PhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                    }
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty sumUnionDeltaPhysicalQty;

                    while select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from sumUnionDeltaPhysicalQty
                        group by sumUnionDeltaPhysicalQty.ItemId, inventDim.LicensePlateId
                    join inventDim
                        where inventDim.InventLocationId == _inventLocationId
                        &&    inventDim.InventSiteId     == _inventSiteId
                        &&    inventDim.wMSLocationId    == _locationId
                        &&    inventDim.LicensePlateId   != ''
                    {
                        boolean isCWItem = PdsGlobal::pdsIsCWItem(sumUnionDeltaPhysicalQty.ItemId);

                        if (isCWItem
                        && sumUnionDeltaPhysicalQty.PdsCWPhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                        else if (!isCWItem
                        && sumUnionDeltaPhysicalQty.PhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                    }
                }
            }
            else
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                    select count(RecId) from inventSumWithDim
                        where inventSumWithDim.InventLocationId == _inventLocationId &&
                              inventSumWithDim.InventSiteId     == _inventSiteId     &&
                              inventSumWithDim.wmsLocationId    == _locationId       &&
                              inventSumWithDim.LicensePlateId   != ''                &&
                              inventSumWithDim.PhysicalInvent   > 0;

                    return int642int(inventSumWithDim.RecId);
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty sumUnionDeltaPhysicalQty;

                    select count(RecId) from inventDim
                        join InventDimId, PhysicalInvent from sumUnionDeltaPhysicalQty
                        where inventDim.InventDimId                     == sumUnionDeltaPhysicalQty.InventDimId &&
                              inventDim.InventLocationId                == _inventLocationId                    &&
                              inventDim.InventSiteId                    == _inventSiteId                        &&
                              inventDim.wmsLocationId                   == _locationId                          &&
                              inventDim.LicensePlateId                  != ''                                   &&
                              sumUnionDeltaPhysicalQty.PhysicalInvent    > 0;

                    return int642int(InventDim.RecId);
                }
            }
        }
        else
        {
            InventSum inventSum;
            
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                if (isCWEnabled)
                {
                    while select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSum
                    group by inventSum.ItemId, inventSum.LicensePlateId
                    where inventSum.ClosedQty == NoYes::No
                        && inventSum.InventLocationId == _inventLocationId
                        && inventSum.wMSLocationId    == _locationId
                        && inventSum.LicensePlateId   != ''
                    {
                        boolean isCWItem = PdsGlobal::pdsIsCWItem(inventSum.ItemId);

                        if (isCWItem
                        && inventSum.PdsCWPhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                        else if (!isCWItem
                        && inventSum.PhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                    }
                }
                else
                {
                    select count(RecId) from inventSum
                    where inventSum.InventLocationId  == _inventLocationId      &&
                          inventSum.wmsLocationId     == _locationId            &&
                          inventSum.LicensePlateId    != ''                     &&
                          inventSum.ClosedQty         == NoYes::No              &&
                          inventSum.PhysicalInvent    > 0;

                    return int642int(inventSum.RecId);
                }
            }
            else
            {
                if (isCWEnabled)
                {
                    while select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSum
                    group by inventSum.ItemId, inventDim.LicensePlateId
                    where inventSum.ClosedQty == NoYes::No
                    join inventDim
                        where inventDim.InventLocationId == _inventLocationId
                        &&    inventDim.wMSLocationId    == _locationId
                        &&    inventDim.LicensePlateId   != ''
                    {
                        boolean isCWItem = PdsGlobal::pdsIsCWItem(inventSum.ItemId);

                        if (isCWItem
                        && inventSum.PdsCWPhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                        else if (!isCWItem
                        && inventSum.PhysicalInvent > 0)
                        {
                            licensePlateCount++;
                        }
                    }
                }
                else
                {
                    select count(RecId) from inventDim
                    join InventDimId, PhysicalInvent from inventSum
                    where inventDim.InventDimId       == inventSum.InventDimId  &&
                          inventDim.InventLocationId  == _inventLocationId      &&
                          inventDim.wmsLocationId     == _locationId            &&
                          inventDim.LicensePlateId    != ''                     &&
                          inventSum.ClosedQty         == NoYes::No              &&
                          inventSum.PhysicalInvent    > 0;

                    return int642int(InventDim.RecId);
                }
            }
        }

        return licensePlateCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkByTargetLicensePlateId</Name>
				<Source><![CDATA[
    protected WHSWorkTable findWorkByTargetLicensePlateId(boolean _findByLocatedLP = false)
    {
        if (WHSBarcodeDataParserFactory::isBarcodeDataParsingEnabled())
        {
            WHSGS1BarcodeEAN128UserDirected barcodeEAN128 = WHSGS1BarcodeEAN128UserDirected::construct(pass);
            barcodeEAN128.decode();
        }

        WHSWorkTable localWorkTable = WHSWorkTable::findByLicensePlate(pass.lookup(#Id), _findByLocatedLP);
                   
        // If work was determined by scanning a license plate, LP confirmation can be skipped.
        if (localWorkTable)
        {
            pass.insert(WHSWorkExecuteDisplayVerificationControls::SkipLPVerification, 1);
        }

        return localWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearVerificationFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears verification fields.
    /// </summary>
    protected void clearVerificationFields()
    {
        pass.remove(#CheckDigit);
        pass.remove(#LocVerification);
        pass.remove(#ProductConfirmation);

        if (!pass.isGroupPick())
        {
            pass.remove(#QtyVerification);
        }

        pass.remove(#FullQty);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm);
        pass.remove(WHSWorkExecuteDisplayVerificationControls::LPVerification);
        pass.remove(WHSWorkExecuteDisplayVerificationControls::BatchVerification);
        pass.remove(WHSWorkExecuteDisplayVerificationControls::SerialVerification);
        pass.remove(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation);
        pass.remove(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmationDisplayed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssignSerialDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WHSDimTracking</c> record in Assign Serial step when processing work line through RF.
    /// </summary>
    /// <param name="_buttonClicked">
    /// Name of the button clicked; optional.
    /// </param>
    public void createAssignSerialDimTracking(str _buttonClicked = '')
    {
        ttsbegin;

        // No dim tracking for WIT with open qty was inserted, if work line is staging pick, create dim tracking for initial WIT
        if (!this.createDimTrackingForFirstOpenWorkInventTrans(_buttonClicked) && WhsWorkExecute::isWorkLineStagingPick(workTable, workLine))
        {
            WHSWorkInventTrans workInventTrans = this.selectFirstWorkInventTrans();

            this.createAssignSerialDimTrackingForWorkInventTrans(workInventTrans, _buttonClicked);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingForFirstOpenWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to find a work inventory transaction for which the sum of quantities of corresponding
    /// dim tracking records is not the same as the WIT's quantity and inserts a dim tracking record
    /// for this WIT.
    /// </summary>
    /// <param name="_buttonClicked">
    /// The button clicked.
    /// </param>
    /// <returns>
    /// True, if a WIT was found and a dim tracking record was inserted; otherwise false.
    /// </returns>
    private boolean createDimTrackingForFirstOpenWorkInventTrans(str _buttonClicked)
    {
        WHSWorkInventTrans workInventTrans;

        while select InventTransIdParent, ItemId, Qty from workInventTrans
            where workInventTrans.WorkId    == workLine.WorkId
            &&    workInventTrans.LineNum   == workLine.LineNum
        {
            // Demanded qty is already fulfilled, try to find another WIT
            if (workInventTrans.Qty == this.getDimTrackedSumQtyForInventTransIdParent(workInventTrans.InventTransIdParent))
            {
                continue;
            }

            this.createAssignSerialDimTrackingForWorkInventTrans(workInventTrans, _buttonClicked);

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimTrackedSumQtyForInventTransIdParent</Name>
				<Source><![CDATA[
    private Qty getDimTrackedSumQtyForInventTransIdParent(InventTransId _inventTransIdParent)
    {
        WHSDimTracking dimTrackingSumQty;

        select sum(Qty) from dimTrackingSumQty
                where   dimTrackingSumQty.WorkId                == workLine.WorkId
                &&      dimTrackingSumQty.LineNum               == workLine.LineNum
                &&      dimTrackingSumQty.InventTransIdParent   == _inventTransIdParent;

        return dimTrackingSumQty.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFirstWorkInventTrans</Name>
				<Source><![CDATA[
    private WHSWorkInventTrans selectFirstWorkInventTrans()
    {
        WHSWorkInventTrans  workInventTrans;

        select firstonly InventTransIdParent, ItemId from workInventTrans
                where workInventTrans.WorkId    == workLine.WorkId
                &&    workInventTrans.LineNum   == workLine.LineNum;

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssignSerialDimTrackingForWorkInventTrans</Name>
				<Source><![CDATA[
    private void createAssignSerialDimTrackingForWorkInventTrans(WHSWorkInventTrans _workInventTrans, str _buttonClicked)
    {
        if (InventTable::find(_workInventTrans.ItemId).isSalesProcessSerialActive())
        {
            InventTrackingRegisterTrans::createFromSerial(pass.lookupStr(#SerialId), _workInventTrans.InventTransIdParent, _buttonClicked == #RFSerialUnreadable);
        }

        InventDim inventDim = workLine.inventDimWithLocation();

        if (pass.exists(#LicensePlateId))
        {
            inventDim.LicensePlateId    = pass.lookup(#LicensePlateId);
        }

        List listDimbelowLicensePlate = WHSReservationHierarchyProvider::construct().getDimListBelowLicensePlate(
            InventTable::find(_workInventTrans.ItemId),
            WHSReservationHierarchySortOrder::TopDown);

        this.initInventDimFromPassDimList(inventDim, WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(listDimbelowLicensePlate));

        inventDim = InventDim::findOrCreate(inventDim);

        WHSDimTracking dimTracking;
        dimTracking.WorkId              = workLine.WorkId;
        dimTracking.LineNum             = workLine.LineNum;
        dimTracking.InventDimId         = inventDim.InventDimId;
        dimTracking.InventTransIdParent = _workInventTrans.InventTransIdParent;
        dimTracking.Qty                 = 1;
        dimTracking.insert();

        // Remove serial from pass through once dimTracking has been created.
        // We don't want to use this serial any further when evaluating dimensions, such as in future loops in method processWorkLine.
        pass.remove(#SerialId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventDimFromPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an inventDim from the current pass through values.
    /// </summary>
    /// <returns>
    /// An inventDim record.
    /// </returns>
    /// <remarks>
    /// This method relies on the keys of the pass through map to match inventDim field names.
    /// </remarks>
    protected InventDim createInventDimFromPass()
    {
        InventDim inventDim;

        this.initInventDimFromPassDimList(inventDim, InventDim::dimFieldsList());

        return InventDim::findOrCreate(inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineRestart</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if current step is restart or first step.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before step is changed.
    /// </param>
    /// <param name="_workLine">
    /// The next work line.
    /// </param>
    /// <returns>
    /// Container containing the form state after step is changed.
    /// </returns>
    public container determineRestart(container _con, WHSWorkLine _workLine = workLine)
    {
        container   data = _con;

        if (_workLine && !_workLine.WorkStop)
        {
            pass = this.resetPassthrough(data);
            pass.insert(#WorkId, _workLine.WorkId);
            pass.parmLineNum(_workLine.LineNum);
            pass.insert(#DimTrackingDelay, 1);
            this.clearPassBelowLicensePlate(_workLine.ItemId);
            data = conPoke(data, 2, pass.pack());
            step = #StepOne;

            if (pass.exists(#GroupPutawayConfirm))
            {
                pass.remove(#GroupPutawayConfirm);
            }
            if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight))
            {
                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight);
            }
            pass.remove(WHSWorkExecuteDisplayCatchWeightControls::WeightIsReadOnly);

            pass.clearGroupPickConfirmation();
        }
        else
        {
            this.blockWorkForWorkLineWithFreezeFlag(_workLine);

            WHSWorkTable::lockUnlockWork(_workLine.WorkId, '');
            pass = this.resetPassthrough(data, false);
            pass.insert(#WorkComplete, 1);
            data = conPoke(data, 2, pass.pack());
            step = #Restart;
        }

        return data;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkBlockingReasonTypeForBlocking</Name>
				<Source><![CDATA[
    protected WHSWorkBlockingReasonType getWorkBlockingReasonTypeForBlocking(WHSWorkLine _workLine)
    {
        return WHSWorkBlockingReasonType::Undefined;
    }

]]></Source>
			</Method>
			<Method>
				<Name>blockWorkForWorkLineWithFreezeFlag</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void blockWorkForWorkLineWithFreezeFlag(WHSWorkLine _workLine)
    {
        if (_workLine.WorkId && WHSWorkTemplateLine::findByRecId(_workLine.WorkTemplateLineRecId).Freeze)
        {
            WHSWorkBlockingReasonType blockingReasonType = this.getWorkBlockingReasonTypeForBlocking(_workLine);

            WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(_workLine.WorkId)
                    .tryBlockWorkWithReasonType(blockingReasonType);           
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBatchDisposition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether batch disposition must be displayed on the RF screen.
    /// </summary>
    /// <returns>
    ///     Returns true if batch disposition must be displayed.
    /// </returns>
    protected boolean displayBatchDisposition()
    {
        boolean             ret;
        InventTable         inventTable;
        WHSRFMenuItemTable  menuItemTable;

        inventTable = InventTable::find(pass.lookupStr(#ItemId));
        menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        if (inventTable.whsBatchActive()
        &&  (menuItemTable.ShowBatchDisposition
        ||   menuItemTable.WorkActivity == WHSWorkActivity::ChangeBatchDisposition))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayContainerTypeDuringRAF</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines whether the container type field should be displayed on the mobile device during RAF.
    /// </summary>
    /// <param name="_generatedLicensePlateId">
    ///  The Id of the generated license plate being reported as finished.
    /// </param>
    /// <returns>
    ///  Returns true if the container type should be displayed; false otherwise.
    /// </returns>
    protected boolean displayContainerTypeDuringRAF(WHSLicensePlateId _generatedLicensePlateId)
    {
        boolean     ret = false;

        // If the generated license plate does not exist, yet a license plate has been entered into the mobile device
        //  by a user, then the container type field will be displayed on the mobile device.
        if (pass.hasValue(#LicensePlateId) && !_generatedLicensePlateId && !pass.hasValue(#Initiation))
        {
            pass.insert(#Initiation, 1);
            ret = true;
        }
        // Otherwise, if a generated license plate has been provided, then the container type will not be displayed.
        else if (pass.hasValue(#Initiation))
        {
            pass.remove(#Initiation);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds form controls to be displayed based on the passed state of the previous form.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the previous form.
    /// </param>
    /// <param name="_buttonClicked">
    /// Clicked button in the previous form, empty string by default.
    /// </param>
    /// <returns>
    /// Container containing the state of the form to be displayed.
    /// </returns>
    abstract container displayForm(container _con, str _buttonClicked = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldValueChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a given field value has changed.
    /// </summary>
    /// <param name="_fieldValues">
    ///     The container of field values.
    /// </param>
    /// <param name="_controlName">
    ///     The name of the RF control to check.
    /// </param>
    /// <returns>
    ///     Returns true if the field value has changed.
    /// </returns>
    protected boolean fieldValueChanged(WHSRFPassthrough _fieldValues, str _controlName)
    {
        boolean             ret;
        WHSRFPassthrough    fieldValues = _fieldValues;

        if (pass.exists(_controlName) && fieldValues.exists(_controlName))
        {
            ret = fieldValues.lookup(_controlName) != pass.lookup(_controlName);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPassFromInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates entries in the pass through map for each field in the inventDim.
    /// </summary>
    /// <param name="_inventDim">
    /// The inventDim record that will be used to fill the pass through.
    /// </param>
    /// <remarks>
    /// This method relies on the keys of the pass through map to match inventDim field names.
    /// </remarks>
    protected void fillPassFromInventDim(InventDim _inventDim)
    {
        List            dimList;
        ListEnumerator  enumerator;
        FieldName       fieldName;

        // Fields might not have been selected on the specified buffers, or might have been updated since selection
        _inventDim.checkInvalidFieldAccess(false);

        dimList = InventDim::dimFieldsList();
        enumerator = dimList ? dimList.getEnumerator() : null;

        while (enumerator.moveNext())
        {
            if (_inventDim.(enumerator.current()))
            {
                fieldName = fieldId2name(_inventDim.TableId, enumerator.current());
                pass.insert(fieldName, _inventDim.(enumerator.current()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDefaultBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default batch id of an inventory item in a specified location.
    /// </summary>
    /// <param name="_inventTable">
    /// Inventory item.
    /// </param>
    /// <param name="_location">
    /// Specified location.
    /// </param>
    /// <returns>
    /// Batch id if all the items in the location have the same batch id, empty string otherwise.
    /// </returns>
    InventBatchId findDefaultBatch(InventTable _inventTable, WMSLocation   _location)
    {
        InventBatchId                           tmpBatchId;

        InventDim                               inventDim;
        InventTable                             inventTable;
        EcoResProduct                           ecoResProduct;

        boolean isCWItem = PdsGlobal::pdsIsCWItem(_inventTable.ItemId);

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_inventTable.ItemId))
        {
            if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
            {
                InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                while select InventBatchId from inventSumWithDim
                    where inventSumWithDim.ItemId       == _inventTable.ItemId                &&
                          ((isCWItem                                                          &&
                          inventSumWithDim.PdsCWPhysicalInvent  >  0)                         ||
                          (!isCWItem                                                          &&
                          inventSumWithDim.PhysicalInvent       >  0))                        &&
                          inventSumWithDim.InventLocationId    == _location.InventLocationId  &&
                          inventSumWithDim.wmsLocationId       == _location.wmsLocationId     &&
                          inventSumWithDim.InventBatchId       != ''
                {
                    if (tmpBatchId && tmpBatchId != inventSumWithDim.InventBatchId)
                    {
                        tmpBatchId = '';
                        break;
                    }
                    tmpBatchId = inventSumWithDim.InventBatchId;
                }
            }
            else
            {
                InventSumUnionDeltaPhysicalQty inventSumUnionDeltaPhysicalQty;

                while select InventDimId, ItemId, PhysicalInvent from inventSumUnionDeltaPhysicalQty
                    join InventBatchId from inventDim
                    where inventSumUnionDeltaPhysicalQty.InventDimId  == inventDim.InventDimId        &&
                          inventSumUnionDeltaPhysicalQty.ItemId       == _inventTable.ItemId          &&
                          ((isCWItem                                                    &&
                          inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent  >  0)     ||
                          (!isCWItem                                                    &&
                          inventSumUnionDeltaPhysicalQty.PhysicalInvent       >  0))    &&
                          inventDim.InventLocationId    == _location.InventLocationId   &&
                          inventDim.wmsLocationId       == _location.wmsLocationId      &&
                          inventDim.InventBatchId       != ''
                {
                    if (tmpBatchId && tmpBatchId != inventDim.InventBatchId)
                    {
                        tmpBatchId = '';
                        break;
                    }
                    tmpBatchId = inventDim.InventBatchId;
                }
            }
        }
        else
        {
            InventSum inventSum;
            
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select InventBatchId from inventSum
                where inventSum.ItemId              == _inventTable.ItemId          &&
                      inventSum.ClosedQty           == NoYes::No                    &&
                      ((isCWItem                                                    &&
                      inventSum.PdsCWPhysicalInvent  >  0)                          ||
                      (!isCWItem                                                    &&
                      inventSum.PhysicalInvent       >  0))                         &&
                      inventSum.InventLocationId    == _location.InventLocationId   &&
                      inventSum.wmsLocationId       == _location.wmsLocationId      &&
                      inventSum.InventBatchId       != ''
                {
                    if (tmpBatchId && tmpBatchId != inventSum.InventBatchId)
                    {
                        tmpBatchId = '';
                        break;
                    }
                    tmpBatchId = inventSum.InventBatchId;
                }
            }
            else
            {
                while select InventDimId, ItemId, PhysicalInvent from inventSum
                join InventBatchId from inventDim
                where inventSum.InventDimId         == inventDim.InventDimId        &&
                      inventSum.ItemId              == _inventTable.ItemId          &&
                      inventSum.ClosedQty           == NoYes::No                    &&
                      ((isCWItem                                                    &&
                      inventSum.PdsCWPhysicalInvent  >  0)                          ||
                      (!isCWItem                                                    &&
                      inventSum.PhysicalInvent       >  0))                         &&
                      inventDim.InventLocationId    == _location.InventLocationId   &&
                      inventDim.wmsLocationId       == _location.wmsLocationId      &&
                      inventDim.InventBatchId       != ''
                {
                    if (tmpBatchId && tmpBatchId != inventDim.InventBatchId)
                    {
                        tmpBatchId = '';
                        break;
                    }
                    tmpBatchId = inventDim.InventBatchId;
                }
            }
        }
        
        return tmpBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateItemDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes inventory dimensions of an item.
    /// </summary>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions id.
    /// </param>
    /// <returns>
    /// String representation of the dimensions.
    /// </returns>
    str generateItemDimension(ItemId _itemId, InventDimId _inventDimId)
    {
        InventDim       inventDim = InventDim::find(_inventDimId);
        List            dimList;
        ListEnumerator  le;
        FieldId         dimFieldId;
        str             ret;

        dimList     = InventDim::dimFieldsList();
        le          = dimList.getEnumerator();

        while (le.moveNext())
        {
            dimFieldId = le.current();

            if (inventDim.(dimFieldId)
                &&  dimFieldId  != fieldNum(InventDim, InventSiteId)
                &&  dimFieldId  != fieldNum(InventDim, InventLocationId)
                &&  dimFieldId  != fieldNum(InventDim, wmsLocationId)
                &&  dimFieldId  != fieldNum(InventDim, LicensePlateId))
            {
                ret += '\n';
                ret += strFmt("@SYS332066", new DictField(tableNum(InventDim), dimFieldId).label(), inventDim.(dimFieldId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateItemInfoForLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates item info for license plate.
    /// </summary>
    /// <param name="_inventSum">
    /// InventSum containing the item info.
    /// </param>
    /// <param name="_locationId">
    /// Item location.
    /// </param>
    /// <returns>
    /// String representation of item info for license plate.
    /// </returns>
    str generateItemInfoForLicensePlate(InventSum _inventSum, WMSLocationId _locationId)
    {
        WHSInventTable      whsInventTable = WHSInventTable::find(_inventSum.ItemId);
        InventTable         inventTable    = InventTable::find(_inventSum.ItemId);
        str                 ret;
        str                 desc1 = '\n        ' + inventTable.productNameWhsWorkExecute();
        str                 desc2;

        if (whsInventTable.rfDescription1)
        {
            desc1 = '\n        ' + whsInventTable.rfDescription1;
        }
        if (whsInventTable.rfDescription2)
        {
            desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        }
        else
        {
            desc1 = desc1 + '\n';
        }

        InventHandlingUnitId unitID     = WHSCatchWeightHelper::inventHandlingUnitId(inventTable.ItemId);
        str                  dimensions = this.generateItemDimension(inventTable.ItemId, _inventSum.InventDimId);

        ret = strFmt("@WAX737" + '\n' + "@WAX744",     // Location: %1\nItem Id: %2%3%4Qty: %5 %6%7
        _locationId,
                     inventTable.ItemId,
                     desc1,
                     desc2,
                     PdsGlobal::pdsIsCWItem(inventTable.ItemId) ? _inventSum.PdsCWPhysicalInvent : _inventSum.PhysicalInvent,
                     unitID,
                     dimensions);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatErrorMessage</Name>
				<Source><![CDATA[
    protected str formatErrorMessage(str _errorString)
    {
        return _errorString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateItemInfoForLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates item info for location.
    /// </summary>
    /// <param name="_inventSum">
    /// InventSum containing item info.
    /// </param>
    /// <param name="_locationId">
    /// Location of the item.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the item.
    /// </param>
    /// <returns>
    /// String representation of the item info for location.
    /// </returns>
    str generateItemInfoForLocation(InventSum _inventSum, WMSLocationId _locationId, WHSLicensePlateId _licensePlateId)
    {
        WHSInventTable      whsInventTable = WHSInventTable::find(_inventSum.ItemId);
        InventTable         inventTable = InventTable::find(_inventSum.ItemId);
        InventHandlingQty   availQty;
        str                 ret;
        str                 desc1 = '\n        ' + inventTable.productNameWhsWorkExecute();
        str                 desc2;
        
        if (whsInventTable.rfDescription1)
        {
            desc1 = '\n        ' + whsInventTable.rfDescription1;
        }
        if (whsInventTable.rfDescription2)
        {
            desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        }
        else
        {
            desc1 = desc1 + '\n';
        }
        
        boolean              cwItem     = PdsGlobal::pdsIsCWItem(inventTable.ItemId);
        InventHandlingUnitId unitID     = WHSCatchWeightHelper::inventHandlingUnitId(inventTable.ItemId);
        str                  dimensions = this.generateItemDimension(inventTable.ItemId, _inventSum.InventDimId);
        
        if (_licensePlateId)
        {
            WMSLocation wmsLocation = WMSLocation::find(_locationId, _inventSum.inventLocationId());

            if (WHSLocationProfile::find(wmsLocation.LocProfileId).DisplayMobileDeviceLocationLicensePlatePositioning)
            {
                ret = strFmt("@WAX740" + '\n' + "@WAX:LPPositionFormat" + '\n' + "@WAX:ItemIdQtyFormat",     // License Plate: %1\nLP Position: %2\nItem Id: %3%4%5Qty: %6 %7%8
                             _licensePlateId,
                             WHSLocationLicensePlatePositioning::find(_licensePlateId).LicensePlatePosition,
                             inventTable.ItemId,
                             desc1,
                             desc2,
                             cwitem ? _inventSum.PdsCWPhysicalInvent : _inventSum.PhysicalInvent,
                             unitID,
                             dimensions);
            }
            else
            {
                ret = strFmt("@WAX741",                     // Item Id: %1%2%3Qty: %4 %5%6
                inventTable.ItemId,
                                 desc1,
                                 desc2,
                                 cwitem ? _inventSum.PdsCWPhysicalInvent : _inventSum.PhysicalInvent,
                                 unitID,
                                 dimensions);
            }

        }
        else
        {
            ret = strFmt("@WAX741",     // Item Id: %1%2%3Qty: %4 %5%6
            inventTable.ItemId,
                             desc1,
                             desc2,
                             cwitem ? _inventSum.PdsCWPhysicalInvent : _inventSum.PhysicalInvent,
                             unitID,
                             dimensions);
        
            availQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(_inventSum.ItemId, _inventSum.InventDimId, true);
        
            if ((!cwItem && (availQty < _inventSum.PhysicalInvent))
            ||  (cwItem  && (availQty < _inventSum.PdsCWPhysicalInvent)))
            {
                ret += strFmt('\n' + "@WAX2726",
                                  cwItem ? _inventSum.PdsCWPhysicalInvent - availQty : _inventSum.PhysicalInvent - availQty,
                                  unitID);
        
                ret += strFmt('\n' + "@WAX2727",
                                  availQty,
                                  unitID);
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateItemInfoForProdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates item info string for production order.
    /// </summary>
    /// <param name="_prodId">
    /// Production order id.
    /// </param>
    /// <returns>
    /// String representation of item info for production order.
    /// </returns>
    str generateItemInfoForProdId(ProdId _prodId)
    {
        ProdTable           prodTable = ProdTable::find(_prodId);
        WHSInventTable      whsInventTable = WHSInventTable::find(prodTable.ItemId);
        str                 ret;
        str                 desc1;
        str                 desc2;
        str                 dimensions;

        if (whsInventTable.rfDescription1)
        {
            desc1 = '\n        ' + whsInventTable.rfDescription1;
        }
        if (whsInventTable.rfDescription2)
        {
            desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        }
        else
        {
            desc1 = desc1 + '\n';
        }

        dimensions = this.generateItemDimension(prodTable.ItemId, prodTable.InventDimId);

        ret = strFmt("@WAX739",     // Item Id: %1%2%3%4
        prodTable.ItemId,
                     desc1,
                     desc2,
                     dimensions);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getButtonClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds clicked button from form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state.
    /// </param>
    /// <returns>
    /// Name of the clicked button.
    /// </returns>
    str getButtonClicked(container _con)
    {
        int controlCount = conLen(_con);
        for (int i = #FieldControlStartLoc; i <= controlCount; i++)
        {
            container conElement = conPeek(_con, i);
            str controlType = conPeek(conElement, #controlType);

            if ((controlType == #RFButton || controlType == #RFDetourButton)
                && conPeek(conElement, #data) == #DataButtonClicked)
            {
                return conPeek(conElement, #name);
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getControlLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the location of the specified RF control.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_controlName">
    ///     The name of the RF control.
    /// </param>
    /// <returns>
    ///     Returns the location of the specified RF control.
    /// </returns>
    protected int getControlLocation(container _con, str _controlName)
    {
        container   ret = _con;
        int         conLength;
        int         i;
        container   controlCon;
        int         controlLoc;
        str         controlName;

        conLength = conLen(ret);

        for (i = #FieldControlStartLoc; i <= conLength; i++)
        {
            controlCon  = conPeek(ret, i);
            controlName = conPeek(controlCon, #name);

            if (controlName == _controlName)
            {
                controlLoc = i;
                break;
            }
        }

        return controlLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getControlLocationInContainer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the location of the specified RF control.
    /// </summary>
    /// <param name="_con">
    ///     The RF container variable.
    /// </param>
    /// <param name="_controlName">
    ///     The name of the RF control.
    /// </param>
    /// <returns>
    ///     Returns the location of the specified RF control.
    /// </returns>
    public int getControlLocationInContainer(container _con, str _controlName)
    {
        return this.getControlLocation(_con, _controlName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultBatchDispositionCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the default batch disposition code.
    /// </summary>
    /// <param name="_itemId">
    ///     The item identifier.
    /// </param>
    /// <returns>
    ///     Returns a container identifying the default batch disposition code, as well as whether a blank value should be included in the element dropdown.
    /// </returns>
    protected container getDefaultBatchDispositionCode(ItemId _itemId)
    {
        PdsBatchDispositionCode defaultValue;
        InventBatchId           inventBatchId;
        boolean                 showBlank;
        WHSReceiptId            receiptId;

        // Determine the inventory batch ID
        inventBatchId = this.getInventBatchId();

        receiptId = pass.lookupStr(#ReceiptId);

        if (WHSInventBatchReceiptDetails::exist(receiptId, _itemId, inventBatchId))
        {
            defaultValue = WHSInventBatchReceiptDetails::find(receiptId, _itemId, inventBatchId).PdsBatchDispositionCode;
        }
        else if (InventBatch::exist(inventBatchId, _itemId))
        {
            defaultValue = InventBatch::find(inventBatchId, _itemId).PdsDispositionCode;
        }
        else
        {
            defaultValue = InventModelGroup::find(InventModelGroupItem::findByItemIdLegalEntity(_itemId).ModelGroupId).PdsDispositionCode;
        }

        // Include a blank value if a batch disposition code could not be defaulted.
        if (!defaultValue)
        {
            showBlank = true;
        }

        pass.insert(#BatchDispositionDefault, defaultValue);

        return [defaultValue, showBlank];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if for specified dim criteria there is more than one value for a inventory dimension field in physical inventory.
    /// </summary>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria.
    /// </param>
    /// <param name="_dimFieldId">
    /// The inventory dimension field being evaluated for multiple values in inventory.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which we are trying determine if inventory allows defaulting of the next dimension.
    /// </param>
    /// <returns>
    /// A container with the values: <c>InventDim</c> record with the _dimFieldId filled if there is only a single value based on the query;
    /// otherwise, it returns a blank inventDim. A boolean value to determine if a prompt is needed.
    /// </returns>
    protected container getDefaultDimValue(
        InventDim   _inventDimCriteria,
        FieldId     _dimFieldId,
        ItemId      _itemId)
    {
        InventDim               inventDim;
        InventDim               returnDim;
        Query                   query;
        QueryBuildDataSource    qbds;
        QueryRun                queryRun;
        Counter                 i;

        query = new Query();
        qbds = query.addDataSource(tableNum(InventDim));
        qbds.addGroupByField(_dimFieldId);
        InventDim::queryAddRangeCriteria(qbds, _inventDimCriteria);

        if (_dimFieldId != fieldNum(InventDim, InventSerialId)
            || _inventDimCriteria.inventSerialId
            || !WhsWorkExecuteDisplay::isBlanksSerialNumberAssignmentAllowed(workLine, pass.lookup(#ItemId)))
        {
            qbds.addRange(_dimFieldId).value(SysQuery::valueNotEmptyString());
        }

        boolean isCW = PdsGlobal::pdsIsCWItem(_itemId);
         
        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId))
        {
            qbds = qbds.addDataSource(tableNum(InventSumUnionDeltaPhysicalQty));
            qbds.addRange(fieldNum(InventSumUnionDeltaPhysicalQty, ItemId)).value(_itemId);
            qbds.relations(true);

            if (isCW)
            {
                qbds.addRange(fieldNum(InventSumUnionDeltaPhysicalQty, PdsCWPhysicalInvent)).value(SysQuery::value('>0'));
            }
            else
            {
                qbds.addRange(fieldNum(InventSumUnionDeltaPhysicalQty, PhysicalInvent)).value(SysQuery::value('>0'));
            }
        }
        else
        {
            qbds = qbds.addDataSource(tableNum(InventSum));
            qbds.addRange(fieldNum(InventSum, ItemId)).value(_itemId);
            qbds.relations(true);
            qbds.addRange(fieldNum(InventSum, ClosedQty)).value(SysQuery::value(NoYes::No));

            if (isCW)
            {
                qbds.addRange(fieldNum(InventSum, PdsCWPhysicalInvent)).value(SysQuery::value('>0'));
            }
            else
            {
                qbds.addRange(fieldNum(InventSum, PhysicalInvent)).value(SysQuery::value('>0'));
            }
        }

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            ++i;
            if (i == 2)
            {
                returnDim.clear();
                inventDim.clear();
                break;
            }
            inventDim = queryRun.get(tableNum(InventDim));
            returnDim.(_dimFieldId) = inventDim.(_dimFieldId);
        }

        return [returnDim, i > 1];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDefaultDimValue</Name>
				<Source><![CDATA[
    private void validateDefaultDimValue(FieldId _fieldId, InventDim _inventDim, ItemId _itemId)
    {
        if (_fieldId == fieldNum(InventDim, inventBatchId)
            && this.isInitialPickForFEFOBatch()
            && _inventDim.LicensePlateId
            && !InventBatch::find(_inventDim.(_fieldId), _itemId).validateBatchDispCodeForPicking(workLine.whsWorkTable().WorkTransType))
        {
            throw error(strFmt("@WAX:Error_LPCannotBePicked", _inventDim.LicensePlateId, _inventDim.(_fieldId)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultTrackDimInventStatusId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds default inventory status of the items with the same serial number in a specified location.
    /// </summary>
    /// <param name="_inventSiteId">
    /// Site id.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_locationId">
    /// Location id.
    /// </param>
    /// <param name="_serialId">
    /// Serial id.
    /// </param>
    /// <param name="_batchId">
    /// Batch id.
    /// </param>
    /// <returns>
    /// The default inventory status.
    /// </returns>
    internal WHSInventStatusId getDefaultTrackDimInventStatusId(
        InventSiteId       _inventSiteId,
        InventLocationId   _inventLocationId,
        WMSLocationId      _locationId,
        WHSSerialId        _serialId,
        InventBatchId      _batchId)
    {
        WHSInventStatusId   inventStatusId;
        InventDim           inventDim;

        boolean	isCWEnabled = WHSCatchWeightConfigurationKeyManager::instance().isEnabled();

        if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
        {
            if (isCWEnabled)
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                    select firstonly InventStatusId from inventSumWithDim
                        where inventSumWithDim.InventSiteId           == _inventSiteId
                        &&    inventSumWithDim.InventLocationId       == _inventLocationId
                        &&    inventSumWithDim.wmsLocationId          == _locationId
                        &&    (!_serialId 
                        ||    (inventSumWithDim.InventSerialId        == _serialId))
                        &&    (!_batchId
                        ||    (inventSumWithDim.InventBatchId         == _batchId))
                        &&    inventSumWithDim.InventStatusId         != ''
                        &&    (inventSumWithDim.PhysicalInvent        > 0
                        ||     inventSumWithDim.PdsCWPhysicalInvent   > 0);

                    inventStatusId = inventSumWithDim.InventStatusId;
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty      inventSumUnionDeltaPhysicalQty;

                    // since we have the serialId or the batchId, or both, we know there will only be one item associated to it
                    // so as long as there is quantity or weight on the sum record, the status will be valid
                    select firstonly InventStatusId from inventDim
                        where inventDim.InventSiteId        == _inventSiteId
                        &&    inventDim.InventLocationId    == _inventLocationId
                        &&    inventDim.wmsLocationId       == _locationId
                        &&    (!_serialId
                        ||    (inventDim.InventSerialId     == _serialId))
                        &&    (!_batchId
                        ||    (inventDim.InventBatchId      == _batchId))
                        &&    inventDim.InventStatusId      != ''
                        exists join inventSumUnionDeltaPhysicalQty
                            where inventDim.InventDimId          == inventSumUnionDeltaPhysicalQty.InventDimId
                            &&    (inventSumUnionDeltaPhysicalQty.PhysicalInvent        > 0
                            ||     inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent   > 0);

                    inventStatusId = inventDim.InventStatusId;
                }
            }
            else
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                    select firstonly InventStatusId from inventSumWithDim
                        where inventSumWithDim.InventSiteId        == _inventSiteId
                        &&    inventSumWithDim.InventLocationId    == _inventLocationId
                        &&    inventSumWithDim.wmsLocationId       == _locationId
                        &&    (!_serialId
                        ||    (inventSumWithDim.InventSerialId     == _serialId))
                        &&    (!_batchId
                        ||    (inventSumWithDim.InventBatchId      == _batchId))
                        &&    inventSumWithDim.InventStatusId      != ''
                        &&    inventSumWithDim.PhysicalInvent      > 0;

                    inventStatusId = inventSumWithDim.InventStatusId;
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty      inventSumUnionDeltaPhysicalQty;

                    select firstonly InventStatusId from inventDim
                        where inventDim.InventSiteId        == _inventSiteId
                        &&    inventDim.InventLocationId    == _inventLocationId
                        &&    inventDim.wmsLocationId       == _locationId
                        &&    (!_serialId
                        ||    (inventDim.InventSerialId     == _serialId))
                        &&    (!_batchId
                        ||    (inventDim.InventBatchId      == _batchId))
                        &&    inventDim.InventStatusId      != ''
                        exists join inventSumUnionDeltaPhysicalQty
                            where inventDim.InventDimId     == inventSumUnionDeltaPhysicalQty.InventDimId
                            &&    inventSumUnionDeltaPhysicalQty.PhysicalInvent   > 0;

                    inventStatusId = inventDim.InventStatusId;
                }
            }
        }
        else
        {
            InventSum inventSum;
            
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                if (isCWEnabled)
                {
                    // since we have the serialId or the batchId, or both, we know there will only be one item associated to it
                    // so as long as there is quantity or weight on the sum record, the status will be valid
                    select firstonly InventStatusId from inventSum
                    where inventSum.InventLocationId    == _inventLocationId
                    &&    inventSum.wmsLocationId       == _locationId
                    &&    (!_serialId
                    ||    (inventSum.InventSerialId     == _serialId))
                    &&    (!_batchId
                    ||    (inventSum.InventBatchId      == _batchId))
                    &&    inventSum.InventStatusId      != ''
                    &&    inventSum.ClosedQty           == NoYes::No
                    &&    (inventSum.PhysicalInvent > 0
                        || inventSum.PdsCWPhysicalInvent   > 0);
                }
                else
                {
                    select firstonly InventStatusId from inventSum
                    where inventSum.InventLocationId    == _inventLocationId
                    &&    inventSum.wmsLocationId       == _locationId
                    &&    (!_serialId
                    ||    (inventSum.InventSerialId     == _serialId))
                    &&    (!_batchId
                    ||    (inventSum.InventBatchId      == _batchId))
                    &&    inventSum.InventStatusId      != ''
                    &&    inventSum.ClosedQty           == NoYes::No
                    &&    inventSum.PhysicalInvent      > 0;
                }

                inventStatusId = inventSum.InventStatusId;
            }
            else
            {
                if (isCWEnabled)
                {
                    // since we have the serialId or the batchId, or both, we know there will only be one item associated to it
                    // so as long as there is quantity or weight on the sum record, the status will be valid
                    select firstonly InventStatusId from inventDim
                    where inventDim.InventLocationId    == _inventLocationId
                    &&    inventDim.wmsLocationId       == _locationId
                    &&    (!_serialId
                    ||    (inventDim.InventSerialId     == _serialId))
                    &&    (!_batchId
                    ||    (inventDim.InventBatchId      == _batchId))
                    &&    inventDim.InventStatusId      != ''
                    exists join inventSum
                        where inventDim.InventDimId     == inventSum.InventDimId
                        &&    inventSum.ClosedQty       == NoYes::No
                        &&    (inventSum.PhysicalInvent        > 0
                        ||     inventSum.PdsCWPhysicalInvent   > 0);
                }
                else
                {
                    select firstonly InventStatusId from inventDim
                    where inventDim.InventLocationId    == _inventLocationId
                    &&    inventDim.wmsLocationId       == _locationId
                    &&    (!_serialId
                    ||    (inventDim.InventSerialId     == _serialId))
                    &&    (!_batchId
                    ||    (inventDim.InventBatchId      == _batchId))
                    &&    inventDim.InventStatusId      != ''
                    exists join inventSum
                        where inventDim.InventDimId     == inventSum.InventDimId
                        &&    inventSum.ClosedQty       == NoYes::No
                        &&    inventSum.PhysicalInvent   > 0;
                }

                inventStatusId = inventDim.InventStatusId;
            }
        }

        return inventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultSerialInventStatusId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds default inventory status of the items with the same serial number in a specified location.
    /// </summary>
    /// <param name="_inventSiteId">
    /// Site id.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_locationId">
    /// Location id.
    /// </param>
    /// <param name="_serialId">
    /// Serial id.
    /// </param>
    /// <returns>
    /// The default inventory status.
    /// </returns>
    public WHSInventStatusId getDefaultSerialInventStatusId(
        InventSiteId       _inventSiteId,
        InventLocationId   _inventLocationId,
        WMSLocationId      _locationId,
        WHSSerialId        _serialId)
    {
        if(WHSCycleCountTrackDimDefaultInventStatusFlight::instance().isEnabled())
        {
            return this.getDefaultTrackDimInventStatusId(_inventSiteId, _inventLocationId, _locationId, _serialId, '');
        }
        else
        {
            WHSInventStatusId   inventStatusId;
            InventDim           inventDim;

            boolean	isCWEnabled = WHSCatchWeightConfigurationKeyManager::instance().isEnabled();

            if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
            {
                if (isCWEnabled)
                {
                    if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                    {
                        InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                        select firstonly InventStatusId from inventSumWithDim
                            where inventSumWithDim.InventSiteId           == _inventSiteId
                            &&    inventSumWithDim.InventLocationId       == _inventLocationId
                            &&    inventSumWithDim.wmsLocationId          == _locationId
                            &&    inventSumWithDim.InventSerialId         == _serialId
                            &&    inventSumWithDim.InventStatusId         != ''
                            &&    (inventSumWithDim.PhysicalInvent        > 0
                            ||     inventSumWithDim.PdsCWPhysicalInvent   > 0);

                        inventStatusId = inventSumWithDim.InventStatusId;
                    }
                    else
                    {
                        InventSumUnionDeltaPhysicalQty      inventSumUnionDeltaPhysicalQty;

                        // since we have the serialId, we know there will only be one item associated to it
                        // so as long as there is quantity or weight on the sum record, the status will be valid
                        select firstonly InventStatusId from inventDim
                            where inventDim.InventSiteId        == _inventSiteId
                            &&    inventDim.InventLocationId    == _inventLocationId
                            &&    inventDim.wmsLocationId       == _locationId
                            &&    inventDim.InventSerialId      == _serialId
                            &&    inventDim.InventStatusId      != ''
                            exists join inventSumUnionDeltaPhysicalQty
                                where inventDim.InventDimId          == inventSumUnionDeltaPhysicalQty.InventDimId
                                &&    (inventSumUnionDeltaPhysicalQty.PhysicalInvent        > 0
                                ||     inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent   > 0);

                        inventStatusId = inventDim.InventStatusId;
                    }
                }
                else
                {
                    if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                    {
                        InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                        select firstonly InventStatusId from inventSumWithDim
                            where inventSumWithDim.InventSiteId        == _inventSiteId
                            &&    inventSumWithDim.InventLocationId    == _inventLocationId
                            &&    inventSumWithDim.wmsLocationId       == _locationId
                            &&    inventSumWithDim.InventSerialId      == _serialId
                            &&    inventSumWithDim.InventStatusId      != ''
                            &&    inventSumWithDim.PhysicalInvent      > 0;

                        inventStatusId = inventSumWithDim.InventStatusId;
                    }
                    else
                    {
                        InventSumUnionDeltaPhysicalQty      inventSumUnionDeltaPhysicalQty;

                        select firstonly InventStatusId from inventDim
                            where inventDim.InventSiteId        == _inventSiteId
                            &&    inventDim.InventLocationId    == _inventLocationId
                            &&    inventDim.wmsLocationId       == _locationId
                            &&    inventDim.InventSerialId      == _serialId
                            &&    inventDim.InventStatusId      != ''
                            exists join inventSumUnionDeltaPhysicalQty
                                where inventDim.InventDimId     == inventSumUnionDeltaPhysicalQty.InventDimId
                                &&    inventSumUnionDeltaPhysicalQty.PhysicalInvent   > 0;

                        inventStatusId = inventDim.InventStatusId;
                    }
                }
            }
            else
            {
                InventSum inventSum;
            
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    if (isCWEnabled)
                    {
                        // since we have the serialId, we know there will only be one item associated to it
                        // so as long as there is quantity or weight on the sum record, the status will be valid
                        select firstonly InventStatusId from inventSum
                            where inventSum.InventLocationId    == _inventLocationId
                            &&    inventSum.wmsLocationId       == _locationId
                            &&    inventSum.InventSerialId      == _serialId
                            &&    inventSum.InventStatusId      != ''
                            &&    inventSum.ClosedQty           == NoYes::No
                            &&    (inventSum.PhysicalInvent > 0
                                || inventSum.PdsCWPhysicalInvent   > 0);
                    }
                    else
                    {
                        select firstonly InventStatusId from inventSum
                            where inventSum.InventLocationId    == _inventLocationId
                            &&    inventSum.wmsLocationId       == _locationId
                            &&    inventSum.InventSerialId      == _serialId
                            &&    inventSum.InventStatusId      != ''
                            &&    inventSum.ClosedQty           == NoYes::No
                            &&    inventSum.PhysicalInvent      > 0;
                    }

                    inventStatusId = inventSum.InventStatusId;
                }
                else
                {
                    if (isCWEnabled)
                    {
                        // since we have the serialId, we know there will only be one item associated to it
                        // so as long as there is quantity or weight on the sum record, the status will be valid
                        select firstonly InventStatusId from inventDim
                            where inventDim.InventLocationId    == _inventLocationId
                            &&    inventDim.wmsLocationId       == _locationId
                            &&    inventDim.InventSerialId      == _serialId
                            &&    inventDim.InventStatusId      != ''
                            exists join inventSum
                                where inventDim.InventDimId     == inventSum.InventDimId
                                &&    inventSum.ClosedQty       == NoYes::No
                                &&    (inventSum.PhysicalInvent        > 0
                                ||     inventSum.PdsCWPhysicalInvent   > 0);
                    }
                    else
                    {
                        select firstonly InventStatusId from inventDim
                            where inventDim.InventLocationId    == _inventLocationId
                            &&    inventDim.wmsLocationId       == _locationId
                            &&    inventDim.InventSerialId      == _serialId
                            &&    inventDim.InventStatusId      != ''
                            exists join inventSum
                                where inventDim.InventDimId     == inventSum.InventDimId
                                &&    inventSum.ClosedQty       == NoYes::No
                                &&    inventSum.PhysicalInvent   > 0;
                    }

                    inventStatusId = inventDim.InventStatusId;
                }
            }

            return inventStatusId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLPInventStatusId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds default status of an inventory item with license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// License plate of the item.
    /// </param>
    /// <returns>
    /// The status of the item.
    /// </returns>
    WHSInventStatusId getDefaultLPInventStatusId(WHSLicensePlateId  _licensePlateId)
    {
        WHSInventStatusId inventStatusId;
        InventDim         inventDim;

        if (_licensePlateId)
        {
            boolean	isCWEnabled = WHSCatchWeightConfigurationKeyManager::instance().isEnabled();

            if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
            {
                if (isCWEnabled)
                {
                    if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                    {
                        InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                        select firstonly InventStatusId from inventSumWithDim
                            where inventSumWithDim.LicensePlateId  == _licensePlateId
                               && inventSumWithDim.InventStatusId  != ''
                               && (inventSumWithDim.PhysicalInvent       > 0
                               || inventSumWithDim.PdsCWPhysicalInvent   > 0);

                        inventStatusId = inventSumWithDim.InventStatusId;
                    }
                    else
                    {
                        InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;

                        select firstonly InventStatusId from inventDim
                            where inventDim.LicensePlateId  == _licensePlateId
                               && inventDim.InventStatusId  != ''
                            exists join inventSumUnionDeltaPhysicalQty
                                where inventDim.InventDimId          == inventSumUnionDeltaPhysicalQty.InventDimId
                                &&    (inventSumUnionDeltaPhysicalQty.PhysicalInvent       > 0
                                ||    inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent   > 0);

                        inventStatusId = inventDim.InventStatusId;
                    }
                }
                else
                {
                    if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                    {
                        InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                        select firstonly InventStatusId from inventSumWithDim
                            where inventSumWithDim.LicensePlateId  == _licensePlateId
                               && inventSumWithDim.InventStatusId  != ''
                               && inventSumWithDim.PhysicalInvent   > 0;

                        inventStatusId = inventSumWithDim.InventStatusId;
                    }
                    else
                    {
                        InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;

                        select firstonly InventStatusId from inventDim
                            where inventDim.LicensePlateId  == _licensePlateId
                               && inventDim.InventStatusId  != ''
                            exists join inventSumUnionDeltaPhysicalQty
                                where inventDim.InventDimId     == inventSumUnionDeltaPhysicalQty.InventDimId
                                &&    inventSumUnionDeltaPhysicalQty.PhysicalInvent   > 0;

                        inventStatusId = inventDim.InventStatusId;
                    }
                }
            }
            else
            {
                InventSum inventSum;
                
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    if (isCWEnabled)
                    {
                        select firstonly InventStatusId from inventSum
                        where inventSum.LicensePlateId  == _licensePlateId
                            && inventSum.InventStatusId != ''
                            && inventSum.ClosedQty		== NoYes::No
                            && (inventSum.PhysicalInvent        > 0
                            ||  inventSum.PdsCWPhysicalInvent   > 0);
                    }
                    else
                    {
                        select firstonly InventStatusId from inventSum
                        where inventSum.LicensePlateId  == _licensePlateId
                            && inventSum.InventStatusId  != ''
                            && inventSum.ClosedQty		== NoYes::No
                            && inventSum.PhysicalInvent   > 0;
                    }

                    inventStatusId = inventSum.InventStatusId;
                }
                else
                {
                    if (isCWEnabled)
                    {
                        select firstonly InventStatusId from inventDim
                        where inventDim.LicensePlateId  == _licensePlateId
                           && inventDim.InventStatusId  != ''
                        exists join inventSum
                            where inventDim.InventDimId          == inventSum.InventDimId
                            &&	  inventsum.ClosedQty			 == NoYes::No
                            &&    (inventSum.PhysicalInvent       > 0
                            ||    inventSum.PdsCWPhysicalInvent   > 0);
                    }
                    else
                    {
                        select firstonly InventStatusId from inventDim
                        where inventDim.LicensePlateId  == _licensePlateId
                           && inventDim.InventStatusId  != ''
                        exists join inventSum
                            where inventDim.InventDimId     == inventSum.InventDimId
                            &&	  inventsum.ClosedQty		== NoYes::No
                            &&    inventSum.PhysicalInvent   > 0;
                    }

                    inventStatusId = inventDim.InventStatusId;
                }
            }
        }

        return inventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUniqueInventStatusWithPhysicalOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the unique Inventory status for a physical on-hand quantity if one is found
    /// </summary>
    /// <param name = "_itemId">The item for which to find the Inventory status for physical on-hand quantity</param>
    /// <param name = "_inventDim">The inventory dimensions which the on-hand quantity must match as a minimum</param>
    /// <returns>
    /// If multiple quantities are found matching the given inventory dimensions, and they have different Inventory statuses, error is thrown;
    /// otherwise returns Inventory status Id if one is found
    /// </returns>
    public static WhsInventStatusId getUniqueInventStatusWithPhysicalOnHand(ItemId _itemId, inventDim _inventDim)
    {
        var statusRetriever = WHSItemAndDimensionsOnHandInventoryStatusRetriever::newFromItemIdAndInventDim(_itemId, _inventDim);

        var throwIfNoUniqueStatusContext = WHSWorkExecuteDisplayGetUniqueInventStatusWithPhysicalOnHandThrowContext::current();
        boolean throwIfNoUniqueStatus = !throwIfNoUniqueStatusContext || throwIfNoUniqueStatusContext.throwIfNoUniqueStatus();

        statusRetriever.parmThrowIfNoUniqueStatus(throwIfNoUniqueStatus);

        return statusRetriever.retrieveInventoryStatusId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventBatchId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the scanned inventory batch ID.
    /// </summary>
    /// <returns>
    ///     Returns the scanned inventory batch ID.
    /// </returns>
    protected InventBatchId getInventBatchId()
    {
        InventBatchId   inventBatchId;
        InventDim       orderLineInventDim;

        orderLineInventDim = this.receivingOrderLine(pass, false).inventDim();

        if (orderLineInventDim.InventBatchId)
        {
            inventBatchId = orderLineInventDim.InventBatchId;
        }
        else if (pass.hasValue(#UpdatedBatchId))
        {
            inventBatchId = pass.lookup(#UpdatedBatchId);
        }
        else
        {
            inventBatchId = pass.lookupStr(#BatchId);
        }

        return inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receivingOrderProvider</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSWorkExecuteDisplayReceivingOrderProvider receivingOrderProvider(boolean _throwOnNonReceiving = true)
    {
        if (!receivingOrderProvider)
        {
            receivingOrderProvider = this.createOrderProvider(_throwOnNonReceiving);
        }

        return receivingOrderProvider;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrderProvider</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSWorkExecuteDisplayReceivingOrderProvider createOrderProvider(boolean _throwOnNonReceiving)
    {
        return pass.receivingOrderProvider(_throwOnNonReceiving);
    }

]]></Source>
			</Method>
			<Method>
				<Name>receivingOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current suggested <c>WHSReceiptOrderLine</c> record that will be processed in the RF.
    /// </summary>
    /// <param name = "_pass">The current pass.</param>
    /// <param name = "_throwOnNonReceiving">Whether to throw an error when the pass contains no receiving information.</param>
    /// <returns>The <c>WHSReceiptOrderLine</c> record to be processed.</returns>
    protected internal WHSReceiptOrderLine receivingOrderLine(WHSRFPassthrough _pass, boolean _throwOnNonReceiving = true)
    {
        WHSReceiptOrderLine orderLine;
        var orderProvider = this.receivingOrderProvider(_throwOnNonReceiving);

        if (orderProvider)
        {
            orderLine = orderProvider.orderLine(_pass);
        }

        return orderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInboundOrderReceiving</Name>
				<Source><![CDATA[
    private boolean isInboundOrderReceiving(InventTransType _inventTransType)
    {
        return WHSWorkExecuteDisplayReceivingOrderProvider::newFromInventTransType(_inventTransType) != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickHeaderLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a header label for picking operation.
    /// </summary>
    /// <param name="_movementStr">
    /// A specified <c>string</c> which should be used as a header.
    /// </param>
    /// <returns>
    /// A header label for picking operation.
    /// </returns>
    public str getPickHeaderLabel(str _movementStr)
    {
        if (pass.exists(#SelectBestLP) && !pass.exists(#LicensePlateId))
        {
            return strFmt("@SYP4881772", _movementStr) + "\n" + "@SYP4881785";
        }
        else
        {
            return strFmt("@WAX1275", _movementStr);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSerializedItemQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines quantity of the serialized item.
    /// </summary>
    /// <param name = "_licensePlateId">ID of the license plate to look for inventory on.</param>
    /// <returns>Item inventory quantity.</returns>
    [Hookable(false)]
    final protected InventQty calculateSerializedItemQuantity(WHSLicensePlateId _licensePlateId = '')
    {
        InventQty                       ret;
        InventDim                       inventDim;

        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), workLine.ItemId);
        
        boolean isPotentialOverPick = WHSWorkExecute::isPotentialOverPick(workTable, workLine);

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(workLine.ItemId))
        {
            InventQty physicalInvent;
            if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
            {
                InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                select sum(PhysicalInvent) from inventSumWithDim
                        where inventSumWithDim.InventLocationId     == workTable.InventLocationId   &&
                              inventSumWithDim.wmsLocationId		== workLine.wmsLocationId       &&
                              inventSumWithDim.LicensePlateId		== _licensePlateId              &&
                              inventSumWithDim.ItemId               == workLine.ItemId              &&
                              inventSumWithDim.PhysicalInvent  > 0;

                physicalInvent = inventSumWithDim.PhysicalInvent;
            }
            else
            {
                InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;

                select sum(PhysicalInvent) from inventSumUnionDeltaPhysicalQty
                    join InventDimId, InventLocationId, wmsLocationId, LicensePlateId from inventDim
                    where inventSumUnionDeltaPhysicalQty.InventDimId	== inventDim.InventDimId        &&
                          inventDim.InventLocationId					== workTable.InventLocationId   &&
                          inventDim.wmsLocationId						== workLine.wmsLocationId       &&
                          inventDim.LicensePlateId					    == _licensePlateId              &&
                          inventSumUnionDeltaPhysicalQty.ItemId         == workLine.ItemId              &&
                          inventSumUnionDeltaPhysicalQty.PhysicalInvent > 0;

                physicalInvent = inventSumUnionDeltaPhysicalQty.PhysicalInvent;
            }
            // Registering all serials for raw material over picking
            if (isPotentialOverPick)
            {
                ret = physicalInvent;
            }
            else
            {
                ret = min(workLine.InventQtyRemain, physicalInvent);
            }
        }
        else
        {
            InventSum inventSum;
            
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                select sum(PhysicalInvent) from inventSum
                where inventSum.InventLocationId    == workTable.InventLocationId   &&
                      inventSum.wmsLocationId       == workLine.wmsLocationId       &&
                      inventSum.LicensePlateId      == _licensePlateId              &&
                      inventSum.ItemId              == workLine.ItemId              &&
                      inventSum.ClosedQty			== NoYes::No					&&
                      inventSum.PhysicalInvent       > 0;
            }
            else
            {
                select sum(PhysicalInvent) from inventSum
                join InventDimId, InventLocationId, wmsLocationId, LicensePlateId from inventDim
                where inventSum.InventDimId         == inventDim.InventDimId        &&
                      inventDim.InventLocationId    == workTable.InventLocationId   &&
                      inventDim.wmsLocationId       == workLine.wmsLocationId       &&
                      inventDim.LicensePlateId      == _licensePlateId              &&
                      inventSum.ItemId              == workLine.ItemId              &&
                      inventSum.ClosedQty			== NoYes::No					&&
                      inventSum.PhysicalInvent       > 0;
            }

            // Registering all serials for raw material over picking
            if (isPotentialOverPick)
            {
                ret =  inventSum.PhysicalInvent;
            }
            else
            {
                ret = min(workLine.InventQtyRemain, inventSum.PhysicalInvent);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the step from pass through data.
    /// </summary>
    /// <param name="_con">
    /// Container containing form state.
    /// </param>
    /// <param name="_mode">
    /// Work execute mode of the work being executed.
    /// </param>
    /// <returns>
    /// Container containing the next form state after step is determined.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Work class is not valid.
    /// </exception>
    container getStep(container _con, WHSWorkExecuteMode _mode)
    {
        WMSLocation                     location;
        container                       ret;
        boolean                         recall;

        location = WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId);
        pass.insert(#WorkId, workLine.WorkId);
        pass.parmLineNum(workLine.LineNum);
        pass.insert(#WMSLocationId, location.wmsLocationId);
        pass.insert(#InventDimId, workLine.InventDimId);
        pass.insert(#ItemId, workLine.ItemId);
        pass.insert(#UOM, workLine.UnitId);
        pass.insert(#QtyLeft, workLine.InventQtyRemain);
        pass.insert(#QtyWork, workLine.QtyWork);
        pass.insert(#InventQtyWork, workLine.InventQtyWork);
        pass.insert(#IsLicensePlateControlled, location.whsLocationIsLPControlled());
        pass.insert(#IsMultiSKU, WHSWorkTable::find(workLine.WorkId).WorkIsMultiSKU);
        pass.insert(#WHSWorkTypeCustomCode, workLine.WorkTypeCustomCode);
        pass.insert(#InventLocationId, workTable.InventLocationId);

        if (pass.exists(#WorkComplete) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected)
        {
            ret = conNull();
            ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
            pass.remove(#WorkComplete);
        }
        ret = this.showWarningFromPass(ret);

        // Keep values of verification fields if previous step was a partial full.
        if (pass.lookupInt64(#prevStep) != #SplitWork)
        {
            if (this.mustCleanVerificationFields(location))
            {
                this.clearVerificationFields();
            }

            if (pass.exists(#QtyVerification))
            {
                pass.remove(#QtyVerification);
                pass.remove(#FullQty);
            }
        }

        // Empty location for certain puts will no longer display no location screen.
        if (!location.wMSLocationId &&
                (controller.canShowGetLocationScreenForWorkType(workLine.WorkType) ||
                (workLine.WorkType == WHSWorkType::Put &&
                 controller.canShowGetLocationScreenForPutForWorkTransType(workTable.WorkTransType))))
        {
            ret = this.buildGetLocation(ret);
            if (workLine.WorkType == WHSWorkType::Pick)
            {
                ret = this.buildPick(ret, '', true, true);
            }
            step = #NoLocation;
        }
        else
        {
            switch (workLine.WorkType)
            {
                case WHSWorkType::Pick:
                    if (this.mustDisplayPickSummary())
                    {
                        ret = this.buildComments(ret);
                        step = #RFPickingComment;
                    }
                    else if (workLine.ReplenDemand)
                    {
                        this.setLicensePlateFieldsOnPass(workTable.TargetLicensePlateId);

                        ret = this.buildBlockedByReplenishment(workLine);
                        step = #Pick;
                    }
                    else
                    {
                        if (this.checkForGroupPick())
                        {
                            if (!pass.isGroupPick())
                            {
                                pass.initializeGroupPick(workTable);
                            }
                            else
                            {
                                pass.initializeGroupPickLicensePlate();

                                pass.initializeGroupPickConfirmation(location);
                            }
                        }

                        ret = this.buildPick(ret, '');

                        if (step != #FEFOWarehouseLocationList)
                        {
                            step = #Pick;
                        }
                    }
                    break;

                case WHSWorkType::Put:
                    if (!pass.exists(#GroupPutawayFail)
                       && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPutaway
                       && (WHSWorkGrouping::validateGroupPutLocations(pass.lookupStr(#WorkGroupingId))
                       || (workLine.WMSLocationId
                       && this.canGroupRemainingIndividualPutWorkLines(workLine, pass.lookup(#MenuItem)))))
                    {
                        ret = this.buildGroupedPutaway(ret);
                        step = #Put;

                        if (!pass.exists(#GroupPutaway))
                        {
                            pass.insert(#GroupPutaway, 1);
                        }
                        else
                        {
                            pass.insert(#GroupPutawayConfirm, 1);
                        }
                    }
                    else
                    {
                        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPutaway)
                        {
                            pass.insert(#GroupPutawayFail, 1);
                        }
                        ret = this.buildPut(ret, '');
                        step = #Put;
                    }
                    break;
                    
                case WHSWorkType::QualityCheck:
                    if (workLine.doesQualityCheckIncludeCatchWeightItem())
                    {
                        WhsWorkExecute workExecute = new WHSWorkExecute();
                        workLine = workExecute.confirmCustomWork(workLine.WorkId, workLine.LineNum, userId);
                        ret = this.addErrorLabel(ret, "@WAX:QualityCheckCatchWeightSkip", WHSRFColorText::Warning);
                        container nextContainer;
                        [nextContainer, recall] = this.getStep(ret, _mode);
                        ret += nextContainer;
                    }
                    else
                    {
                        WHSQualityCheckAcceptancePolicy acceptancePolicy = WHSQualityCheckTemplate::findByWorkLine(workLine).AcceptancePolicy;

                        using (var qualityCheckActivityContext = this.instrumentationLogger().qualityCheckActivities().applyAcceptancePolicy(acceptancePolicy))
                        {
                            this.instrumentationLogger().logRecordInformation(workLine);

                            if (acceptancePolicy == WHSQualityCheckAcceptancePolicy::PromptUser)
                            {
                                ret = this.buildQualityCheck(ret);
                                step = #QualityCheck;
                            }
                            else
                            {
                                this.rejectQualityCheck(workLine, userId);
                                ret = this.determineRestart(_con);
                                recall = true;
                            }
                        }
                    }
                    break;

                default:
                    WhsWorkTypeHandler handler = WhsWorkTypeHandler::singletonFromType(workLine.WorkType);
                        
                    if (handler)
                    {
                        WhsWorkStepContext context = WhsWorkStepContext::construct();
                        context.workLine = workLine;
                        context.workExecuteDisplay = this;
                        context.pass = pass;
                        context.nextForm = ret;
                        context.previousForm = _con;
                        context.step = step;

                        handler.determineStep(context);

                        ret = context.nextForm;
                        step = context.step;
                        workLine = context.workline;
                        recall = context.recall;
                    }
                    if (!handler || ret == conNull())
                    {
                        ret = this.addErrorLabel(ret, "@WAX754");
                        ret = this.buildGetWorkId(ret);
                    }
                    break;
            }
        }

        pass.remove(#DetermineStep);

        return [ret, recall];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCleanVerificationFields</Name>
				<Source><![CDATA[
    private boolean mustCleanVerificationFields(WMSLocation _location)
    {
        if ((pass.exists(#CheckDigit) && pass.lookupStr(#CheckDigit) != _location.checkText)
                || (pass.exists(#LocVerification) && pass.lookupStr(#LocVerification) != _location.wMSLocationId))
        {
            return true;
        }
        else if (pass.exists(#ProductConfirmation))
        {
            var product = pass.lookupStr(#ProductConfirmation);
            if (product == workLine.ItemId)
            {
                // If the user has entered the itemId, then we check if it is the same of the workline
                return false;
            }
            else
            {
                // else we check if the user has entered a barcode instead of the itemId
                InventInventItemSearchResult productByBarcode =  InventInventItemSearch::construct().search(product);
                if (productByBarcode && productByBarcode.parmItemId() != workLine.ItemId)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForGroupPick</Name>
				<Source><![CDATA[
    private boolean checkForGroupPick()
    {
        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPick
            && !pass.hasGroupPickFailed())
        {
            if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
                && (pass.isGroupPick() || this.canPerformGroupPick()))
            {
                return true;
            }
            else
            {
                pass.setGroupPickFailure();
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGroupRemainingIndividualPutWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the remaining individual put work lines can be grouped.
    /// </summary>
    /// <param name="_workLine">
    /// The current workline.
    /// </param>
    /// <param name="_menuItemName">
    /// The current menu item name.
    /// </param>
    /// <returns>
    /// true if none of the next work lines is of an opposite type, if all the put locations are the same and if the quantity confirmation during put is disabled; otherwise, false
    /// </returns>
    private boolean canGroupRemainingIndividualPutWorkLines(WHSWorkLine _workLine, WHSMenuItemName _menuItemName)
    {
        return !WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType)
            && WHSWorkTable::multipleFinalPutsAllLocationsEqual(_workLine.WorkId)
            && (!WHSRFAutoConfirm::isVerifyQtyConfirmationEnabled(_menuItemName, WHSWorkType::Put)
                || WHSWorkTable::multipleFinalPutsWithLocAndUnitsEqualRemainQty(_workLine.WorkId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkExecuteModeFromWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the work executed mode from work transaction type.
    /// </summary>
    /// <param name="_workTransType">
    /// The work transaction type.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The target license plate id.
    /// </param>
    /// <returns>
    /// The work execute mode.
    /// </returns>
    WHSWorkExecuteMode getWorkExecuteModeFromWorkTransType(
            WHSWorkTransType  _workTransType,
            WHSLicensePlateId _targetLicensePlateId)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTransType);

        if (workTransactionType)
        {
            return workTransactionType.workExecuteMode(_targetLicensePlateId != '');
        }

        throw error(strFmt("@WAX1705", _workTransType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasComments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the shipment of the current work line has comments to be shown in RF.
    /// </summary>
    /// <returns>
    /// True if the shipment has comments to be shown in RF.
    /// </returns>
    public boolean hasComments()
    {
        if (!workLine.WorkId)
        {
            return false;
        }

        WHSShipmentTable    shipmentTable;
        DocuRef             docuRef;
        WHSWorkLine         pickLine;
        WHSWorkLineCache    cache = WHSWorkLineCache::newFromWorkId(workLine.WorkId);
        boolean             ret;
        WHSParameters       parameters = WHSParameters::find();

        select firstonly RecId from pickLine
            where pickLine.LineNum      <  cache.parmFirstPutLineNum() &&
                  pickLine.WorkId       == workLine.WorkId
            exists join shipmentTable
                where shipmentTable.ShipmentId == pickLine.ShipmentId
            exists join docuRef
                where docuRef.RefTableId    == shipmentTable.TableId    &&
                      docuRef.RefRecId      == shipmentTable.RecId      &&
                      docuRef.RefCompanyId  == shipmentTable.DataAreaId &&
                      docuRef.TypeId        == parameters.rfNoteType;

        if (pickLine)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the form state contains errors or not.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state.
    /// </param>
    /// <returns>
    /// 1 if the form state has error. 0 otherwise.
    /// </returns>
    int hasError(container _con)
    {
        int     ret;
        int     i = 3;
        int     length = conLen(_con);
        
        while (i <= length)
        {
            if (conPeek(conPeek(_con, i), #controlType) == #RFLabel &&
                    conPeek(conPeek(_con, i), #name) == #RFError)
            {
                ret = 1;
                break;
            }

            ++i;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasClusterSortMessage</Name>
				<Source><![CDATA[
    /// <summary> Checks whether the form state contains ClusterSortMessage or not.</summary>
    /// <param name="_con">Container containing the form state.</param>
    /// <returns> Element number the form state has ClusterSortMessage. 0 otherwise.</returns>
    private int hasClusterSortMessage(container _con)
    {
        int     ret;
        int     i = 3;
        int     length = conLen(_con);
        
        while (i <= length)
        {
            if (conPeek(conPeek(_con, i), #controlType) == #RFText &&
                    conPeek(conPeek(_con, i), #name) == #ClusterSortMessage)
            {
                ret = i;
                break;
            }

            ++i;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimFromPassDimList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an <c>InventDim</c> buffer from the current dimensions list.
    /// </summary>
    /// <param name="_inventDim">
    /// The <c>InventDim</c> buffer that should be initialized.
    /// </param>
    /// <param name="_dimList">
    /// The list of dimension field ID's that should be assigned values.
    /// </param>
    /// <remarks>
    /// This method relies on the keys of the pass through map to match inventDim field names.
    /// </remarks>
    protected void initInventDimFromPassDimList(
        InventDim   _inventDim,
        List        _dimList)
    {
        ListEnumerator  enumerator = _dimList.getEnumerator();

        while (enumerator.moveNext())
        {
            FieldId fieldId = enumerator.current();
            DictField df = new DictField(tableNum(InventDim), fieldId);
            if (pass.hasValue(df.name()))
            {
                str dimValueAsString = pass.lookup(df.name());
                switch (df.baseType())
                {
                    case Types::String:
                        _inventDim.(fieldId) = dimValueAsString;
                        break;

                    case Types::Real:
                        _inventDim.(fieldId) = WhsWorkExecuteDisplay::str2numDisplay(dimValueAsString);
                        break;

                    case Types::UtcDateTime:
                        //  Not supported
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendBatchInfoFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the vendor batch detail fields within the pass.
    /// </summary>
    protected void initVendBatchInfoFields()
    {
        InventBatch                     inventBatch;
        WHSInventBatchReceiptDetails    whsInventBatchReceiptDetails;
        PdsVendBatchDate                vendBatchDate;
        PdsVendExpiryDate               vendExpiryDate;
        str                             useVendBatchDate;
        str                             useVendExpiryDate;
        PdsCountryOfOrigin              countryOfOrigin1;
        PdsCountryOfOrigin1             countryOfOrigin2;
        PdsVendBatchId                  vendBatchId;
        PdsVendBatchInfo                pdsVendBatchInfo;

        whsInventBatchReceiptDetails = WHSInventBatchReceiptDetails::find(pass.lookupStr(#ReceiptId), pass.lookupStr(#ItemId), pass.lookupStr(#BatchId));

        if (whsInventBatchReceiptDetails.RecId > 0)
        {
            vendBatchDate       = whsInventBatchReceiptDetails.PdsVendBatchDate;
            useVendBatchDate    = enum2str(whsInventBatchReceiptDetails.PdsUseVendBatchDate);
            vendExpiryDate      = whsInventBatchReceiptDetails.PdsVendExpiryDate;
            useVendExpiryDate   = enum2str(whsInventBatchReceiptDetails.PdsUseVendBatchExp);
            countryOfOrigin1    = whsInventBatchReceiptDetails.PdsCountryOfOrigin1;
            countryOfOrigin2    = whsInventBatchReceiptDetails.PdsCountryOfOrigin2;
            vendBatchId         = whsInventBatchReceiptDetails.PdsVendBatchId;
        }
        else
        {
            inventBatch = InventBatch::find(pass.lookupStr(#BatchId), pass.lookupStr(#ItemId));

            if (inventBatch.RecId > 0)
            {
                vendBatchDate       = inventBatch.PdsVendBatchDate;
                useVendBatchDate    = enum2str(inventBatch.PdsUseVendBatchDate);
                vendExpiryDate      = inventBatch.PdsVendExpiryDate;
                useVendExpiryDate   = enum2str(inventBatch.PdsUseVendBatchExp);
                countryOfOrigin1    = inventBatch.PdsCountryOfOrigin1;
                countryOfOrigin2    = inventBatch.PdsCountryOfOrigin2;
                vendBatchId         = inventBatch.PdsVendBatchId;
            }
            else if (this.receivingOrderProvider(false))
            {
                WHSReceiptOrderLine orderLine = this.receivingOrderLine(pass);
                pdsVendBatchInfo              = PdsVendBatchInfo::findBySourceRecId(orderLine.vendBatchRefType(), orderLine.RecId);

                if (pdsVendBatchInfo.RecId > 0)
                {
                    vendBatchDate       = pdsVendBatchInfo.VendBatchDate;
                    useVendBatchDate    = enum2str(pdsVendBatchInfo.UseVendBatchDate);
                    vendExpiryDate      = pdsVendBatchInfo.VendExpiryDate;
                    useVendExpiryDate   = enum2str(pdsVendBatchInfo.UseVendBatchExp);
                    countryOfOrigin1    = pdsVendBatchInfo.CountryOfOrigin1;
                    countryOfOrigin2    = pdsVendBatchInfo.CountryOfOrigin2;
                    vendBatchId         = pdsVendBatchInfo.VendBatchId;
                }
            }
        }

        pass.insert(#VendBatchDate, WHSRFControlData::convertDate2DateFormatStrCurrentUserDateCulture(vendBatchDate, pass.lookupStr(#UserId)));
        pass.insert(#UseVendBatchDate, useVendBatchDate);
        pass.insert(#VendExpDate, WHSRFControlData::convertDate2DateFormatStrCurrentUserDateCulture(vendExpiryDate, pass.lookupStr(#UserId)));
        pass.insert(#UseVendExpDate, useVendExpiryDate);
        pass.insert(#CountryOfOrigin1, countryOfOrigin1);
        pass.insert(#CountryOfOrigin2, countryOfOrigin2);
        pass.insert(#VendBatchId, vendBatchId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnHandGreaterThanDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if on hand inventory for specific dimension set is greater than current work demand.
    /// </summary>
    /// <param name="_inventDim">
    /// The dimension set used for finding on hand inventory.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which we are evaluating on hand inventory.
    /// </param>
    /// <param name="_qtyToBePicked">
    /// The quantity remaining to be picked.
    /// </param>
    /// <returns>
    /// True if on hand inventory is greater than work demand; otherwise, false.
    /// </returns>
    protected boolean isOnHandGreaterThanDemand(
        InventDim   _inventDim,
        ItemId      _itemId,
        InventQty   _qtyToBePicked)
    {
        InventDim   inventDim = InventDim::findOrCreate(_inventDim);

        return WHSInventOnHand::getWorkPhysicalInventHandlingQty(_itemId, inventDim.InventDimId) > _qtyToBePicked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPiecePickingOrBatchConfirmation</Name>
				<Source><![CDATA[
    private boolean isPiecePickingOrBatchConfirmation()
    {
        return WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType)
            || WHSRFAutoConfirm::isBatchConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProcessWorkLineOnAutoCompletion</Name>
				<Source><![CDATA[
    private boolean canProcessWorkLineOnAutoCompletion(WHSWOrkLine _previousWorkline)
    {
        if (_previousWorkline.LineNum == 1 && (WHSWorkExecutionMode::newFromMode(mode).isInboundOrderReceivingAndPutaway()
                                            || mode == WHSWorkExecuteMode::TransferOrderItemReceivingAndLocate
                                            || mode == WHSWorkExecuteMode::TransferOrderLineReceivingAndLocate))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateItemBatchReceiptDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the <c>WHSInventBatchReceiptDetails</c> table with details from the received batch.
    /// </summary>
    protected void populateItemBatchReceiptDetails()
    {
        WHSInventBatchReceiptDetails    whsInventBatchReceiptDetails;
        InventTable                     inventTable;

        ttsbegin;

        inventTable = InventTable::find(pass.lookup(#ItemId));

        whsInventBatchReceiptDetails = WHSInventBatchReceiptDetails::find(pass.lookup(#ReceiptId), inventTable.ItemId, pass.lookup(#BatchId), true);

        if (whsInventBatchReceiptDetails.RecId == 0)
        {
            whsInventBatchReceiptDetails.ReceiptId      = pass.lookup(#ReceiptId);
            whsInventBatchReceiptDetails.ItemId         = inventTable.ItemId;
            whsInventBatchReceiptDetails.InventBatchId  = pass.lookup(#BatchId);
        }

        // For shelf life items, the expiration date will be calculated at registration.
        if (!inventTable.isShelfLifeItem())
        {
            // Expiry date is not filled up when batch id has been automatically populated.
            if (pass.exists(#ExpDate))
            {
                whsInventBatchReceiptDetails.ExpDate = WHSRFControlData::convertDateFormatStr2Date(pass.lookup(#ExpDate), pass.lookupStr(#UserId));
            }
        }

        if (pass.exists(#VendBatchInfoEntered))
        {
            whsInventBatchReceiptDetails.PdsVendBatchDate       = WHSRFControlData::convertDateFormatStr2Date(pass.lookup(#VendBatchDate), pass.lookupStr(#UserId));
            whsInventBatchReceiptDetails.PdsUseVendBatchDate    = pass.lookup(#UseVendBatchDate) == enum2str(NoYes::Yes) ? NoYes::Yes : NoYes::No;
            whsInventBatchReceiptDetails.PdsVendExpiryDate      = WHSRFControlData::convertDateFormatStr2Date(pass.lookup(#VendExpDate), pass.lookupStr(#UserId));
            whsInventBatchReceiptDetails.PdsUseVendBatchExp     = pass.lookup(#UseVendExpDate) == enum2str(NoYes::Yes) ? NoYes::Yes : NoYes::No;
            whsInventBatchReceiptDetails.PdsCountryOfOrigin1    = pass.lookup(#CountryOfOrigin1);
            whsInventBatchReceiptDetails.PdsCountryOfOrigin2    = pass.lookup(#CountryOfOrigin2);
            whsInventBatchReceiptDetails.PdsVendBatchId         = pass.lookup(#VendBatchId);
        }

        whsInventBatchReceiptDetails.PdsPotencyBaseValue        = pass.lookupStr(#Potency);
        whsInventBatchReceiptDetails.PdsBatchDispositionCode    = pass.lookupStr(#BatchDisposition);

        whsInventBatchReceiptDetails.write();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFieldValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the field values in the pass through into the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before processing field values.
    /// </param>
    /// <param name="_fieldValues">
    /// Field values stored in a pass through map.
    /// </param>
    /// <returns>
    /// Container containing the form state after processing field values.
    /// </returns>
    container processFieldValues(container _con, WHSRFPassthrough _fieldValues)
    {
        boolean   complete = true;
        container con = _con;
        
        WHSWorkType workLineWorkType;
        if (!workLine)
        {
            workLineWorkType = WHSWorkLine::find(pass.lookupStr(#WorkId), pass.parmLineNum()).WorkType;
        }
        else
        {
            workLineWorkType = workLine.WorkType;
        }

        int length = conLen(con);
        for (int i = 1; i <= length; ++i)
        {
            container subCon = conPeek(con, i);
            str controlType = conPeek(subCon, #controlType);
            str name;
            int enabled;

            if (controlType == #RFText      ||
                controlType == #RFPassword)
            {
                name = conPeek(subCon, #name);

                if (_fieldValues.exists(name))
                {
                    con = conPoke(con, i, conPoke(subCon, #data, _fieldValues.lookup(name)));

                    str value = _fieldValues.lookup(name);
                    enabled = conPeek(subCon, #enabled);

                    if (!value && enabled)
                    {                       
                        if (name == #GtdId_RU
                            && WhsInvent::isGTDNumberOptional(pass.parmItemId()))
                        {
                            continue;
                        }
                        
                        str buttonClicked = this.getButtonClicked(con);
                        if (!WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookupStr(#MenuItem), workLineWorkType)
                            || (buttonClicked != #RFDone)
                            || (buttonClicked == #RFDone
                                && name != #ProductConfirmation
                                && name != WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation))
                        {
                            complete = false;
                        }
                    }
                }
            }
            else if (controlType == #RFComboBox && conPeek(subCon, #data) == '' && conPeek(subCon, #selected) == '')
            {
                name    = conPeek(subCon, #name);
                enabled = conPeek(subCon, #enabled);

                if (name != #Disposition
                    &&  name != #InventoryStatus
                    &&  name != #ContainerType
                    &&  enabled)
                {
                    complete = false;
                }
            }
            else if (controlType == #RFFastValidationIds && conPeek(subCon, #data) == '')
            {
                complete = false;
            }
        }

        return [con, complete];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInitiationForContainer</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines whether or not the container type can be displayed on the mobile device.
    /// </summary>
    protected void setInitiationForContainer()
    {
        WHSLicensePlate     licensePlate;

        if (!pass.hasValue(#Initiation))
        {
            if (pass.hasValue(#TargetLicensePlateId))
            {
                licensePlate = WHSLicensePlate::find(pass.lookupStr(#TargetLicensePlateId));

                if (licensePlate.RecId != 0)
                {
                    pass.insert(#ContainerType, licensePlate.ContainerTypeCode);
                    pass.insert(#AlreadyHaveLP, 1);
                }
                else if (pass.exists(#AlreadyHaveLP))
                {
                    pass.remove(#AlreadyHaveLP);
                }
            }
            else if (!pass.hasValue(#SplittingLP))
            {
                licensePlate = WHSLicensePlate::find(pass.lookupStr(#LicensePlateId));

                if (licensePlate.RecId != 0)
                {
                    pass.insert(#ContainerType, licensePlate.ContainerTypeCode);
                    pass.insert(#AlreadyHaveLP, 1);
                }
            }

            if (!pass.hasValue(#TargetLicensePlateId))
            {
                pass.insert(#Initiation, 1);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessWorkLineForPickOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre-processes the work line for pick operation.
    /// </summary>
    /// <param name = "_state">The state for processing work lines.</param>
    /// <returns>true, if the pre-processing of the work line has been finished; otherwise, false.</returns>
    protected boolean preProcessWorkLineForPickOperation(WhsWorkProcessWorkLineState _state)
    {
        if (step == #Pick)
        {
            if (!this.validateNonSerialInventory(workLine))
            {
                 throw error(strFmt("@WAX:WHSCannotPickSerializedInvetoryFromLP_ErrorMsg", workLine.ItemId));
            }
        }

        str piecesConfirmed = pass.lookupStr(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);
        container tmpFieldValues;
        [_state.previousForm, tmpFieldValues] = WHSRFControlData::processData(_state.previousForm, pass);

        // Re-reading the work line in case it was changed in WHSRFControlData::processData().
        workLine.reread();

        Map fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);
        
        if (fieldValues.exists(#SerialId)
            && !fieldValues.lookup(#SerialId)
            && _state.mode == WHSWorkExecuteMode::Shipping
            && WhsWorkExecuteDisplay::isBlanksSerialNumberAssignmentAllowed(workLine, pass.lookup(#ItemId)))
        {
            fieldValues.remove(#SerialId);
        }

        [_state.nextForm, _state.isFormComplete] = this.processFieldValues(_state.previousForm, fieldValues);

        if (!_state.isFormComplete)
        {
            // Pieces confirmed are counted before the rest of the controls have been checked, so because the complete variable is set
            // based on if all controls are populated with correct values, here they need to be corrected to what they were.
            if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed))
            {
                pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed, piecesConfirmed);
            }

            if (step == #Pick)
            {
                _state.nextForm = this.rebuildDimUOM(_state.nextForm, false, #QtyVerifyUOM);
            }

            if (step != #OverpickStep)
            {
                if (pass.exists(#TargetLicensePlateId) && pass.lookup(#TargetLicensePlateId) == '')
                {
                    pass.remove(#TargetLicensePlateId);
                }

                return true;
            }
        }
        else if (this.serialAssignmentNeeded()
                && step != #FEFOWarehouseLocationList)
        {
            if (WHSAssignSerialUseGroupPickLPFlight::instance().isEnabled())
            {
                pass.initializeGroupPickLicensePlate();
            }

            InventQty existingSerialQty = abs(InventTrackingRegisterTrans::qtyPhysicalIssue(InventTransOrigin::findByInventTransId(workLine.InventTransId).RecId));
            InventQty serialQtyToCapture = this.calculateSerializedItemQuantity(pass.lookupStr(#LicensePlateId));

            WHSWorkTransType workTransType = WHSWorkTable::find(workLine.WorkId).WorkTransType;
            WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(workTransType);

            InventQty expectedSerialNumberQty = workTransactionType.expectedSerialNumberQty(workLine);

            if (workLine.isActiveInSalesSerialProcess() && (existingSerialQty + serialQtyToCapture > expectedSerialNumberQty))
            {
                throw error(strFmt("@WAX:RemoveRegisteredSerialNumbers", existingSerialQty));
            }

            // Over picking license plate, assign serials for full license plate after confirming quantity
            if (WHSWorkExecute::isPotentialOverPick(workTable, workLine))
            {
                step = #Pick;
                // Skip any more prompt for dimensions
                pass.insert(#AssignSerial, 1);
            }
            else
            {
                pass.insert(#AssignSerial, 1);
                pass.insert(#SerialCounter, 1);

                if (step == #ShortPickConf || step == #ManualReallocationListShortPickConf)
                {
                    pass.insert(#SerialQty, pass.lookupNum(#QtyToPick));
                }
                else
                {
                    pass.insert(#SerialQty, this.calculateSerializedItemQuantity(pass.lookupStr(#LicensePlateId)));
                }
                step = #AssignSerialStep;
                _state.nextForm = this.buildAssignSerial(conNull());
                return true;
            }
        }

        if (pass.exists(#PickQtyConfirmationEnabled)
            && step == #Pick
            && workLine.WorkType == WHSWorkType::Pick
            && pass.lookupStr(#IsLicensePlateControlled)
            && pass.exists(#LicensePlateId)
            && !pass.isGroupPickConfirmed()
            && (!pass.exists(#QtyVerification)
            || pass.exists(#FullQty)))
        {
            if (pass.exists(#TargetLicensePlateId)
                && _state.mode == WHSWorkExecuteMode::UserGrouping)
            {
                pass.remove(#TargetLicensePlateId);
            }

            pass.clearGroupPick();

            [_state.nextForm, _state.recall] = this.getStep(_state.previousForm, _state.mode);
            pass.insert(#AutoConfirm, 1);
            return true;
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWorkLineForCustomStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the work line for a custom step.
    /// </summary>
    /// <param name = "_state">The state for processing work lines.</param>
    /// <returns>true, if the processing of the work line has been finished; otherwise, false.</returns>
    [Replaceable]
    protected boolean processWorkLineForCustomStep(WhsWorkProcessWorkLineState _state)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPreProcessWorkLineForPickOperation</Name>
				<Source><![CDATA[
    protected boolean canPreProcessWorkLineForPickOperation(WhsWorkProcessWorkLineState _state)
    {
        return ((step != #OverrideStep1 &&
            step != #OverrideStep2 &&
            step != #NoLocation &&
            step != #ReceivingExceptionStep1 &&
            step != #ReceivingExceptionStep2 &&
            step != #SplitWork &&
            step != #ShortPick &&
            step != #ShortPickConf &&
            step != #RFPickingComment &&
            step != #AssignSerialStep &&
            step != #WorkAuditTemplate &&
            step != #ManualReallocationListShortPickConf &&
            step != #ManualReallocationList &&
            step != #SplitPutWork &&
            _state.buttonClicked != #RFNoLocation &&
            _state.buttonClicked != #RFOverrideLP)
            || ((step == #ShortPickConf || step == #ManualReallocationListShortPickConf) && pass.lookupNum(#QtyToPick) > 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre-processes the work line.
    /// </summary>
    /// <param name = "_state">The state for processing work lines.</param>
    /// <returns>true, if the pre-processing of the work line has been finished; otherwise, false.</returns>
    protected boolean preProcessWorkLine(WhsWorkProcessWorkLineState _state)
    {
        if (this.canPreProcessWorkLineForPickOperation(_state))
        {
            return this.preProcessWorkLineForPickOperation(_state);
        }
        if (step == #AssignSerialStep &&
                 _state.buttonClicked == #RFSerialUnreadable &&
                 InventTable::find(workLine.ItemId).isSalesProcessSerialActive())
        {
            InventQty existingSerialQty = abs(InventTrackingRegisterTrans::qtyPhysicalIssue(InventTransOrigin::findByInventTransId(workLine.InventTransId).RecId));
            InventQty serialQtyToCapture = pass.lookupNum(#SerialQty) - pass.lookupNum(#SerialCounter);
            InventQty currentSerialQty = 1;

            WHSWorkTransType workTransType = WHSWorkTable::find(workLine.WorkId).WorkTransType;
            WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(workTransType);

            InventQty expectedSerialNumberQty = workTransactionType.expectedSerialNumberQty(workLine);

            if (existingSerialQty + currentSerialQty + serialQtyToCapture > expectedSerialNumberQty)
            {
                throw error("@WAX:TooManySerials");
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareDataForPicking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates data for picking.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state.
    /// </param>
    /// <param name="_mode">
    /// Work execution mode.
    /// </param>
    /// <param name = "_targetLicensePlateId">
    /// The target license plate for the picking.
    /// </param>
    protected void prepareDataForPicking(
        container           _con,
        WHSWorkExecuteMode  _mode,
        str                 _targetLicensePlateId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the work line being executed by RF.
    /// </summary>
    /// <param name="_workLine">
    /// Work line being executed by RF.
    /// </param>
    /// <param name="_con">
    /// Container containing the form state.
    /// </param>
    /// <param name="_mode">
    /// Work execution mode.
    /// </param>
    /// <param name="_step">
    /// Step of the work execution.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_newLocationId">
    /// New location id.
    /// </param>
    /// <param name="_buttonClicked">
    /// The clicked button.
    /// </param>
    /// <param name="_looping">
    /// Determines whether the work lines are processed one after another.
    /// </param>
    /// <returns>
    /// The form state after work line is processed.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Unable to capture serial id when it is defined to capture during picking or packing.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The work class is not valid.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Location is not valid.
    /// </exception>
    container processWorkLine(WHSWorkLine           _workLine,
                              container             _con,
                              WHSWorkExecuteMode    _mode,
                              int                   _step,
                              WHSUserId             _userId,
                              WMSLocationId         _newLocationId = '',
                              str                   _buttonClicked = '',
                              boolean               _looping = true)
    {
        WhsWorkProcessWorkLineState state;
        WHSWorkLine                 localWorkLine = _workLine;
        container                   localCon = _con;
        WHSWorkExecuteMode          localMode = _mode;
        int                         localStep = _step;
        WHSUserId                   localUserId = _userId;
        WMSLocationId               localNewLocationId = _newLocationId;
        str                         localButtonClicked = _buttonClicked;
        boolean                     localLooping = _looping;
        const int                   iterationMax = 1000000;

        do
        {
            using (var activityContextProcessWorkLine =  this.instrumentationLogger().processWorkLineActivities().processWorkLine())
            {
                WhsWorkExecute                  workExecute = WhsWorkExecute::construct();
                int                             hasError = 0;
                container                       tmpFieldValues;
                Map                             fieldValues = new Map(Types::String, Types::String);
                WHSWorkId                       tmpWorkId;
                WHSWorkLine                     preWorkLine = workLine;
                WHSAnchor                       anchor;
                WHSAuditSeqNum                  auditSeqNum;
                boolean                         auditComplete;
                boolean                         mustCaptureMoreDims;
                WHSTargetLicensePlateId         targetLicensePlateId;
                int                             startInfologLine;
                WHSOverrideTargetLP             overrideTargetLP;
                WHSRFPassthrough                prevPass;

                iteration++;

                this.instrumentationLogger().logRecordInformation(workLine);
                this.instrumentationLogger().processWorkLineActivities().iterate(activityContextProcessWorkLine, iteration);
                this.instrumentationLogger().processWorkLineActivities().flexibleReservation(activityContextProcessWorkLine, workLine.OrderCommittedInventDimId != '');

                state = WhsWorkProcessWorkLineState::construct();
                state.mode = localMode;
                state.previousForm = localCon;
                state.buttonClicked = localButtonClicked;
            
                Map globalPass = pass;
                pass = WHSRFPassthrough::create(conPeek(state.previousForm, 2));
                pass = this.combineMaps(globalPass, pass);

                if (this.allowShortPickConf(pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess), state.buttonClicked))
                {
                    localStep = #ShortPickConf;
                    pass.insert(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess, WHSItemReallocation::None);
                    this.buildShortPickConf(conNull());
                }
    
                if (pass.exists(#AutoConfirm))
                {
                    pass.remove(#AutoConfirm);
                }
    
                if (pass.exists(#MenuItem))
                {
                    WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
    
                    anchor = menuItemTable.Anchor;
                    overrideTargetLP = menuItemTable.OverrideTargetLP;
    
                    if (WHSRFAutoConfirm::isVerifyQtyConfirmationEnabled(menuItemTable.MenuItemName, WHSWorkType::Pick))
                    {
                        pass.insert(#PickQtyConfirmationEnabled, '1');
                    }
                    else if (pass.exists(#PickQtyConfirmationEnabled))
                    {
                        pass.remove(#PickQtyConfirmationEnabled);
                    }
                }
    
                this.prepareWorkAuditStep(state);
                if (_buttonClicked == #RFSkip
                &&  step == #WorkAuditTemplate)
                {
                    localStep = step;
                }
    
                if (workLine.isFirstWorkLine() && localLooping)
                {
                    workExecute.updateWorkStatus(workLine.WorkId, workLine.LineNum, userId);
                    step = conPeek(conPeek(state.nextForm, 1), 2);
                    pass = new WHSRFPassthrough(Types::String, Types::String);
                    pass = WHSRFPassthrough::create(conPeek(state.nextForm, 2));
                }
                else if (pass.exists(#DetermineStep))
                {
                    workExecute.updateWorkStatus(workLine.WorkId, workLine.LineNum, userId);
                    [state.nextForm, state.recall] = this.getStep(state.previousForm, localMode);
                    pass.insert(#AutoConfirm, 1);
                }
                else
                {
                    hasError = this.hasError(state.previousForm);
    
                    if (step)
                    {
                        if (hasError)
                        {
                            state.previousForm = conDel(state.previousForm, 3, 1);
                            state.previousForm = this.clearErrors(state.previousForm);
                        }

                        WHSWorkBeingSplitValidator::validateWorkTableIsNotBeingSplit(workTable.WorkId);

                        boolean finishedProcessing = this.preProcessWorkLine(state);
    
                        if (finishedProcessing)
                        {
                            return [state.nextForm, step, state.recall, pass.pack()];
                        }
                    }

                    this.instrumentationLogger().processWorkLineActivities().iterationDetails(activityContextProcessWorkLine, localStep, localMode);
    
                    startInfologLine = infologLine() + 1;
                    switch (localStep)
                    {
                        case #ShowPickDetails:
                            pass.remove(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation);
                            pass.insert(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmationDisplayed, 1);
            
                        case #Pick:
                            if (workLine.ReplenDemand)
                            {
                                this.setLicensePlateFieldsOnPass(workTable.TargetLicensePlateId);
    
                                state.nextForm = this.buildBlockedByReplenishment(workLine);
                                break;
                            }
                            
                            InventBatchId inventBatchId = InventDim::find(workLine.InventDimId).inventBatchId;
    
                            if (inventBatchId && WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(InventTable::find(workLine.ItemId))
                                && !InventBatch::find(inventBatchId, workLine.ItemId).validateBatchDispCodeForPicking(workLine.whsWorkTable().WorkTransType))
                            {
                                throw error(strFmt("@WAX5580", inventBatchId));
                            }
    
                            if (pass.isGroupPick()
                            && pass.exists(#DimPrompt))
                            {
                                pass.remove(#DimPrompt);
    
                                if (pass.isGroupPickConfirmed())
                                {
                                    this.maintainDimTracking(workLine);
                                }
                                else
                                {
                                    state.nextForm = this.buildPick(conNull(), '', false);
                                }
                            }
                            else if (pass.exists(#SelectBestLP))
                            {
                                state.nextForm = this.buildPick(conNull(), '', false);
    
                                // When we have a license plate and outbound weight we do not need the flags
                                // to prompt for these again.
                                if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt)
                                || (pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight)
                                &&  pass.hasValue(#LicensePlateId)))
                                {
                                    pass.remove(#SelectBestLP);
                                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt);
                                    break;
                                }
                                break;
                            }
                            else
                            {
                                this.buildPick(state.nextForm, '', false);
                            }
    
                            if (pass.exists(#DimPrompt) || (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt)
                            && (!pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight)
                                || pass.exists(WHSWorkExecuteDisplayCatchWeightControls::WeightIsReadOnly))))
                            {
                                state.nextForm = this.buildPick(conNull(), '', false);
    
                                if (pass.exists(#DimPrompt))
                                {
                                    pass.remove(#DimPrompt);
                                }
                                if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt))
                                {
                                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt);
                                }
                                if (pass.exists(#SelectBestLP))
                                {
                                    pass.remove(#SelectBestLP);
                                }
                                break;
                            }
                            else if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight)
                                &&  PdsGlobal::pdsIsCWItem(workLine.ItemId)
                                &&  (pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::WeightIsReadOnly) == 1))
                            {
                                //License plate has been updated before confirmation, make sure catch weight gets updated
                                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight);

                                state.nextForm = this.buildPick(conNull(), '', false);
                            }
    
                            if (this.captureWeightPerCatchWeightUnit())
                            {
                                WHSCatchWeightTagAutoSelect tagAutoSelect = WHSCatchWeightTagAutoSelectPicking::newFromParams(mode, pass, workLine);
                                if (tagAutoSelect.canUseAutoSelection())
                                {
                                    tagAutoSelect.process();
                                    state.nextForm = this.buildPostWeightCaptureForm();
                                }
                                else
                                {
                                    state.nextForm = this.buildOutboundWeightCapture(conNull());
                                    step = #CWOutboundWeightCapture;
                                }
                                break;
                            }
    
                            if (WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookupStr(#MenuItem), workLine.WorkType)
                            &&  !PdsGlobal::pdsIsCWItem(workLine.ItemId)
                            &&  pass.lookupNum(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed) < pass.lookupNum(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm))
                            {
                                pass.remove(#ProductConfirmation);
                                state.nextForm = this.buildPick(conNull(), '', false);
                                break;
                            }
    
                            // Over picking raw material serials and capturing at picking
                            if (!this.isWorkLineSerialValidated(workLine)
                            &&  InventTable::find(workLine.ItemId).isItemSerialNumberActivated()
                            &&  WHSInventTable::captureSerial(workLine.ItemId) == WHSRFWhenToCapture::Picking
                            &&  WHSWorkExecute::isPotentialOverPick(workTable, workLine))
                            {
                                pass.insert(#SerialCounter, 1);
                                pass.insert(#SerialQty, this.calculateSerializedItemQuantity(pass.lookupStr(#LicensePlateId)));
                                step = #AssignSerialStep;
                                state.nextForm = this.buildAssignSerial(conNull());
                                return [state.nextForm, step, state.recall, pass.pack()];
                            }
    
                            if (this.mustShowPickDetailsConfirmationBeDisplayed()
                            && !pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmationDisplayed))
                            {
                                pass.insert(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation, 1);
                                state.nextForm = this.buildPick(conNull());
                                step = #ShowPickDetails;
                                break;
                            }
                            
                            pass.remove(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation);
    
                            targetLicensePlateId = workLine.whsWorkTable().TargetLicensePlateId;
                            if (!targetLicensePlateId && pass.exists(#TargetLicensePlateId))
                            {
                                targetLicensePlateId = pass.lookupStr(#TargetLicensePlateId);
                            }
    
                            boolean isPutBefore = WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum);
    
                            if (workTable.WorkTransType == WHSWorkTransType::Invent
                                && pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList)
                                && WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId)))
                            {
                                workExecute.parmScannedCatchWeightTags(str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList)));
                            }

                            if (pass.parmLicensePlateId() != '' || isPutBefore) 
                            {
                                this.prepareDataForPicking(localCon, localMode, targetLicensePlateId);
                                WHSLicensePlateId licensePlateId = pass.lookup(#LicensePlateId);
    
                                if (!targetLicensePlateId)
                                {
                                    workExecute.parmIsGroupPickEnabled(pass.isGroupPick());

                                    workLine = workExecute.pickWorkFromLicensePlate(licensePlateId,
                                                                                workLine,
                                                                                userId,
                                                                                this.createInventDimFromPass(),
                                                                                '',
                                                                                pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight),
                                                                                this.assignSerial(workLine),
                                                                                overrideTargetLP,
                                                                                false,
                                                                                this.shouldHandleByLP());
                                }
                                else if (isPutBefore)
                                {
                                    var parmTargetLicensePlate = !pass.exists(#TargetLicensePlateId)
                                        ? targetLicensePlateId
                                        : pass.lookup(#TargetLicensePlateId);

                                    workLine = workExecute.pickWorkFromLicensePlate(licensePlateId,
                                                                                workLine,
                                                                                userId,
                                                                                null,
                                                                                parmTargetLicensePlate,
                                                                                pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight),
                                                                                false,
                                                                                NoYes::No,
                                                                                false,
                                                                                false);
                                }
                                else
                                {
                                    if (!this.shouldHandleByLP() && pass.exists(#TargetLicensePlateId))
                                    {
                                        WHSWorkTable::addTargetLicensePlate(workLine.WorkId, pass.lookup(#TargetLicensePlateId));
                                    }
    
                                    workExecute.parmIsGroupPickEnabled(pass.isGroupPick());

                                    workLine = workExecute.pickWorkFromLicensePlate(licensePlateId,
                                                                            workLine,
                                                                            userId,
                                                                            this.createInventDimFromPass(),
                                                                            pass.lookupStr(#TargetLicensePlateId),
                                                                            pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight),
                                                                            this.assignSerial(workLine),
                                                                            NoYes::No,
                                                                            false,
                                                                            this.shouldHandleByLP());
                                }

                                workLine = this.getNextWorkLineForGroupPicking(preWorkLine, workLine);

                                // When Show work line list is enabled it is possible that we are processing not the first open work line and
                                // if it is not fully picked we want to continue processing it
                                if (WHSWorkExecuteDisplayWorkLineListKeepLineNumFlight::instance().isEnabled() && !pass.isGroupPick()
                                    && pass.exists(#MenuItem) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowWorkLineList)
                                {
                                    WHSWorkLine processedWorkLine = WHSWorkLine::find(preWorkLine.WorkId, preWorkLine.LineNum);

                                    if (processedWorkLine.InventQtyRemain > 0)
                                    {
                                        workLine = processedWorkLine;
                                    }
                                }
    
                                if (workLine.AskForNewLicensePlate)
                                {
                                    state.nextForm = this.buildPick(conNull());
    
                                    if (workTable.WorkTransType == WHSWorkTransType::Invent  &&
                                        pass.exists(#TargetLicensePlateId))
                                    {
                                        pass.remove(#TargetLicensePlateId);
                                    }

                                    if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt))
                                    {
                                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt);
                                    }
    
                                    state.recall = false;
                                }
                            }
                            else
                            {
                                if (WHSWorkExecute::canAutoPickWorkLine(pass.lookup(#MenuItem), workLine, true))
                                {
                                    // If auto confirm is enabled, execute the work for Non-LP controlled items in one go.
                                    [preWorkLine, workLine] = workExecute.multiPicksNonLicensePlateCheckDigit(
                                                                        pass.lookup(#MenuItem),
                                                                        workLine,
                                                                        userId,
                                                                        pass.lookupStr(#TargetLicensePlateId),
                                                                        this.assignSerial(workLine));
                                }
                                else
                                {
                                    workLine = workExecute.pickNonLicensePlateCheckDigitQuantities(workLine.WorkId,
                                                                                                workLine.LineNum,
                                                                                                workLine.ItemId,
                                                                                                workLine.QtyRemain,
                                                                                                pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight),
                                                                                                workLine.UnitId,
                                                                                                userId,
                                                                                                this.createInventDimFromPass(),
                                                                                                pass.lookupStr(#TargetLicensePlateId),
                                                                                                this.assignSerial(workLine));
                                }

                                workLine = this.getNextWorkLineForGroupPicking(preWorkLine, workLine);
    
                                // When Show work line list is enabled it is possible that we are processing not the first open work line and
                                // if it is not fully picked we want to continue processing it
                                if (WHSWorkExecuteDisplayWorkLineListKeepLineNumFlight::instance().isEnabled() && !pass.isGroupPick()
                                    && pass.exists(#MenuItem) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowWorkLineList)
                                {
                                    WHSWorkLine processedWorkLine = WHSWorkLine::find(preWorkLine.WorkId, preWorkLine.LineNum);

                                    if (processedWorkLine.InventQtyRemain > 0)
                                    {
                                        workLine = processedWorkLine;
                                    }
                                }

                                if (pass.exists(#TargetLicensePlateId))
                                {
                                    WHSWorkTable::addTargetLicensePlate(workLine.WorkId, pass.lookup(#TargetLicensePlateId));
                                }
                            }

                            if (!workLine.AskForNewLicensePlate)
                            {
                                boolean groupPickFail;
                                WHSLicensePlateId groupPickLP;
                            
                                if (pass.hasGroupPickFailed())
                                {
                                    groupPickFail = true;
                                }
    
                                if (workLine.WorkType == WHSWorkType::Pick
                                && pass.isGroupPick()
                                && pass.lookupStr(#LicensePlateId))
                                {
                                    groupPickLP = pass.lookupStr(#LicensePlateId);
                                }
    
                                pass.remove(WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn);
                                [state.nextForm, state.recall] = this.completePickStep(state.previousForm, workExecute);
    
                                this.maintainGroupPick(preWorkLine, groupPickFail, groupPickLP);
                                
                                // Flag has been set for stage put, reset for next put group
                                pass.remove(#GroupPutawayFail);
                            }
    
                            if (step != #Restart
                            && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                            {
                                throw error("@WAX1459");
                            }
    
                            // If pick completed and menu item allows, evaluate cycle count thresholds
                            if (!WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DisableCycleCountThreshold && preWorkLine.LineNum != workLine.LineNum &&
                                (!this.delayCycleCountUntilGroupPickCompleted(preWorkLine, workLine)))
                            {
                                WHSCycleCountThresholdId cycleCountThresholdId = WHSCycleCountCreateThreshold::processCycleCountThreshold(preWorkLine.WorkId, preWorkLine.LineNum);
    
                                // Check to see if an immediate count needs to be executed
                                if (WHSCycleCountThreshold::find(cycleCountThresholdId).ImmediateCycleCount)
                                {
                                    // Find open cycle count work for the location
                                    WHSWorkId cycleCountWorkId = WHSWorkTable::findCycleCountByLocation(WHSWorkUserSession::find(userId).InventLocationId, preWorkLine.wmsLocationId);
    
                                    if (cycleCountWorkId)
                                    {
                                        if (step == #StepOne)
                                        {
                                            step = WHSCycleCountThreshold::getImmediateCountStep(WHSRFMenuItemTable::getWHSWorkExecuteMode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem))));
                                            pass.insert(#DetermineStep, 1);
                                            pass.insert(#Recall, 1);
                                        }
    
                                        state.recall = false;
                                        state.nextForm = this.updateDisplayForImmediateCycleCounting(
                                                                        cycleCountWorkId,
                                                                        state.nextForm,
                                                                        step,
                                                                        state.buttonClicked,
                                                                        true);
                                    }
                                }
                            }
    
                            if (preWorkLine.LineNum != workLine.LineNum)
                            {
                                // Remove scanned catch weight tags from the list if we have completed the work line.
                                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList);
    
                                // Clean license plate ID if pick completed and the new work line is also a pick
                                if (workLine.WorkType == WHSWorkType::Pick)
                                {
                                    pass.remove(#LicensePlateId);
                                    pass.remove(WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn);
                                    this.clearVerificationFields();
                                    this.clearPassBelowLicensePlate(preWorkLine.ItemId);
                                }
                                else if (pass.exists(#PrevStep) 
                                     &&  pass.lookup(#PrevStep) == WHSWorkExecuteDisplay::num2StrDisplay(#OverrideStep2))
                                {
                                    pass.remove(#PrevStep);
                                }

                                this.unblockReplenishmentOverflowWorkWithinCapacity(preWorkLine.WMSLocationId);
                            }

                            break;
    
                        case #Put:
                            tmpWorkId =  this.processPutWorkLine(state, workExecute, localButtonClicked, localNewLocationId);
                            break;
    
                        case #CustomConfirmation:     // Custom Work Confirmation
                            WHSWorkTypeCustom workTypeCustom = WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode);
                            WHSData data;
                            if (workTypeCustom.CaptureData)
                            {
                                data = conPeek(conPeek(state.previousForm, 4), #data);
                                if (!data)
                                {
                                    // With CaptureData set to Yes data is required
                                    throw error("@WAX1080");
                                }
                                WHSWorkLineCustom workLineCustom;
                                workLineCustom.WorkId   = workLine.WorkId;
                                workLineCustom.LineNum  = workLine.LineNum;
                                workLineCustom.rfLabel  = WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode).rfLabel;
                                workLineCustom.Data     = data;
                                workLineCustom.insert();
                            }
    
                            // Actual custom method invocation.
                            if (workTypeCustom.WorkTypeCustomMethod)
                            {
                                WhsWorkTypeCustomProcessParameters processParameters = WhsWorkTypeCustomProcessParameters::construct();
                                processParameters.data = data;
                                processParameters.workLine = workLine;
                                processParameters.pass = pass;
                                workTypeCustom.processWorkLine(processParameters);
                            }
    
                            tmpWorkId = workLine.WorkId;
                            workLine = workExecute.confirmCustomWork(pass.lookup(#WorkId), pass.parmLineNum(), userId);
                            state.nextForm = this.determineRestart(state.previousForm);
                            if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                            {
                                throw error("@WAX1459");
                            }
    
                            state.recall = true;
                            break;

                        case #QualityCheck: // Quality check
                            if (_buttonClicked == WHSWorkExecuteDisplayQualityCheckControls::Accept)
                            {
                                this.approveQualityCheck(workLine, _userId);
                            }
                            else if (_buttonClicked == WHSWorkExecuteDisplayQualityCheckControls::Reject)
                            {
                                this.rejectQualityCheck(workLine, _userId);
                            }
                            state.nextForm = this.determineRestart(state.previousForm);
                            state.recall = true;
                            break;

                        case #Print:     // Print
                        if (!pass.exists(#Confirmation))
                            {
                                WHSLicensePlateLabelBuild labelBuild = new WHSLicensePlateLabelBuild(pass.lookup(#WorkId), WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum()), '', pass.lookup(#UserId));
                                labelBuild.buildLicensePlateLabels();
                            }
                            else
                            {
                                pass.remove(#Confirmation);
                            }
                            workLine = workExecute.confirmCustomWork(pass.lookup(#WorkId), pass.parmLineNum(), userId);
                            state.nextForm = this.determineRestart(state.previousForm);
                            if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                            {
                                throw error("@WAX1459");
                            }
                            state.recall = true;
                            break;
    
                        case #NoLocation:     // No Location on Work
                        if (!pass.exists(#NoValidation))
                            {
                                if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
                                {
                                    state.nextForm = this.addErrorLabel(conNull(), "@WAX2962", WHSRFColorText::Error);
                                    state.nextForm = this.buildPut(state.nextForm);
                                    if (pass.exists(#NoOverrideButton))
                                    {
                                        pass.remove(#NoOverrideButton);
                                    }
                                    pass.insert(#WMSLocationId, workLine.wmsLocationId);
                                    step = #Put;
                                    break;
                                }
    
                                if (WHSWorkExecuteNoLocationScanBarcodeLocationFlight::instance().isEnabled())
                                {
                                    str wmsLocationId = this.getControlDataFromContainer(state.previousForm, #WMSLocationId);
 
                                    pass.insert(#WMSLocationId, wmsLocationId);
                                }
                                else
                                {
                                    pass.insert(#WMSLocationId, conPeek(conPeek(state.previousForm, 4), #data));
                                }
    
                                if (pass.lookup(#WMSLocationId) == '')
                                {
                                    pass.insert(#WMSLocationId, workLine.wmsLocationId);
    
                                    if (workLine.WorkType == WHSWorkType::Put && WHSWorkUser::find(userId).AllowLocOverridePut)
                                    {
                                        state.nextForm = this.addErrorLabel(state.nextForm, "@WAX1160", WHSRFColorText::Error);
                                        state.nextForm = this.buildGetLocation(state.nextForm);
                                        pass.insert(#UserPutLocation, 1);
                                        break;
                                    }
                                    else
                                    {
                                        throw error("@WAX1160");
                                    }
                                }
    
                                WMSLocationId locationId = WMSLocation::whsGetLocationId(pass.lookup(#WMSLocationId), WHSWorkUserSession::find(userId).InventLocationId);
    
                                if (!locationId)
                                {
                                    pass.insert(#WMSLocationId, workLine.wmsLocationId);
                                    throw error("@WAX755");
                                }
                                else if (pass.exists(#ContainerType))
                                {
                                    WMSLocation location;
                                    WHSLocationProfile locationProfile;
    
                                    select firstonly WMSLocationId from location
                                    where location.wMSLocationId == locationId
                                    join locationProfile
                                        where locationProfile.LocProfileId == location.LocProfileId;
    
                                    if (!WHSAllowedContainerType::validateContainerTypeOnLocationProfile(locationProfile, pass.lookupStr(#ContainerType)))
                                    {
                                        throw error(strFmt("@WAX:ErrorContainerTypeLPOnLocationProfile",
                                                        pass.lookupStr(#LicensePlateId),
                                                        locationId,
                                                        pass.lookupStr(#ContainerType)));
                                    }
                                }
    
                                pass.insert(#WMSLocationId, locationId);
   
                                //  Location for cluser override will be validated in  workExecute.overrideClusterPut() -> workExecute.updateWorkLineLocation()
                                if (workLine.WorkType == WHSWorkType::Put &&
                                    !pass.exists(WHSWorkExecuteDisplayPutawayClusterControls::ClusterOverride) &&
                                    !workExecute.validateLocationChange(WHSWorkUserSession::find(userId).InventLocationId, pass.lookup(#WMSLocationId), pass.lookup(#ItemId), localWorkLine))
                                {
                                    pass.insert(#WMSLocationId, workLine.wmsLocationId);
                                    throw error("@WAX755");
                                }
    
                                if (pass.exists(#GroupPutaway))
                                {
                                    workExecute.overrideGroupPutaway(pass.lookupStr(#WorkGroupingId),
                                                                    pass.lookup(#WMSLocationId),
                                                                    pass.lookup(#UserId),
                                                                    workLine.WorkId,
                                                                    workLine.LineNum);
    
                                    pass.remove(#GroupPutaway);
                                }
                                else if (pass.exists(WHSWorkExecuteDisplayPutawayClusterControls::ClusterOverride) 
                                    || pass.exists(WHSWorkExecuteDisplayClusterPickingControls::ClusterPickOverridePutLocation))
                                {
                                    workExecute.overrideClusterPut(pass.lookup(#ClusterId), pass.lookup(#WMSLocationId), workLine, pass.lookup(#UserId));
                                }
                                else if (pass.isGroupPick())
                                {
                                    workExecute.overrideGroupPick(workLine, pass.lookup(#WMSLocationId), pass.lookup(#UserId));
    
                                    pass.clearGroupPick();
                                }
                                else
                                {
                                    workExecute.updateWorkLineLocation(pass.lookup(#WorkId), pass.parmLineNum(), pass.lookup(#WMSLocationId), pass.lookup(#UserId));
                                    workLine.reread();
    
                                    // If work line is now closed need to find next work line
                                    if (workLine.WorkStatus == WHSWorkStatus::Closed)
                                    {
                                        workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                                        pass.parmLineNum(workLine.LineNum);
                                        workExecute.updateWorkStatus(workLine.WorkId, workLine.LineNum, userId);
                                    }
                                }
    
                                if (workLine.WorkType == WHSWorkType::Put && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPutaway)
                                {
                                    pass.insert(#PrevStep, #OverrideStep2);
                                }
    
                                // Begin anchoring if needed
                                if (anchor && _workLine.WorkType == WHSWorkType::Put)
                                {
                                    using (var context = new WhsWorkExecuteAnchoringProcessContext())
                                    {
                                        
                                        context.putWorkTemplateLineRecId = _workLine.WorkTemplateLineRecId;                                        

                                        workExecute.anchorWork(pass.lookup(#WorkId),
                                                            pass.lookup(#WMSLocationId),
                                                            pass.lookupStr(#OverrideFromPutLocation),
                                                            WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AnchorBy);
                                    }
                                }
    
                                if (pass.exists(#OverrideFromPutLocation))
                                {
                                    pass.remove(#OverrideFromPutLocation);
                                }
    
                                if (mode == WHSWorkExecuteMode::PickPack)
                                {
                                    pass.insert(#PickPackOverride, 1);
                                }
    
                                if (pass.exists(#SuggestLocation))
                                {
                                    pass.remove(#SuggestLocation);
                                }
    
                                if (workLine.WorkType == WHSWorkType::Pick
                                &&  pass.exists(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight)
                                &&  PdsGlobal::pdsIsCWItem(workLine.ItemId))
                                {
                                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight);
                                }

                                step = #StepOne;
                                state.recall = true;
                            }
                            else
                            {
                                if (workLine.WorkType == WHSWorkType::Pick && !localNewLocationId && pass.exists(#UserPutLocation))
                                {
                                    state.nextForm = this.addErrorLabel(state.nextForm, "@WAX2213", WHSRFColorText::Error);
                                }
                                state.nextForm = this.buildGetLocation(state.nextForm, '', localNewLocationId);
                                pass.remove(#NoValidation);
                                pass.insert(#UserPutLocation, 1);
                            }
                            break;
    
                        case #GetSourceLP:    // Get Source License Plate
                            pass.insert(#SourceLicensePlateId, conPeek(conPeek(state.previousForm, 4 + hasError), #data));
                            if (pass.lookup(#SourceLicensePlateId))
                            {
                                if (!workExecute.validateChildLicensePlate(pass.lookup(#WorkId), pass.parmLineNum(), pass.lookup(#SourceLicensePlateId)))
                                {
                                    throw error("@WAX756");
                                }
                                state.nextForm = conPoke(state.nextForm, 2, pass.pack());
                                step = pass.lookup(#PrevStep);
                                state.recall = true;
                            }
                            else
                            {
                                throw error("@WAX756");
                            }
                            break;
    
                        case #ReceivingExceptionStep1:     // Get Exception
                            pass.remove(#RunningQty);
                            pass.remove(#QtyReceived);
    
                            state.nextForm = this.buildReceivingExceptions(state.nextForm);
                            step = #ReceivingExceptionStep2;
                            break;
    
                        case #ReceivingExceptionStep2:     // Receiving Exception
                            pass.insert(#ReceivingExceptionDesc, conPeek(conPeek(state.previousForm, 3 + hasError), #data));
    
                            if (state.buttonClicked == #RFDone || state.buttonClicked == #RFNextException)
                            {
                                this.createReceivingExceptionLog(workexecute, localUserId);
                            }
    
                            if (state.buttonClicked == #RFSoftCancel || state.buttonClicked == #RFDone)
                            {
                                step = #StepOne;
                                pass.insert(#RebuildForm, '1');
                            }
                            else if (state.buttonClicked == #RFNextException)    // Next Exception
                            {
                                state.nextForm = this.buildReceivingExceptions(state.nextForm);
                            }
                            break;
    
                        case #OverrideStep1:     // Override
                        if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
                            {
                                state.nextForm = this.addErrorLabel(conNull(), "@WAX2962", WHSRFColorText::Error);
                                state.nextForm = this.buildPut(state.nextForm);
                                if (pass.exists(#NoOverrideButton))
                                {
                                    pass.remove(#NoOverrideButton);
                                }
                                pass.insert(#WMSLocationId, workLine.wmsLocationId);
                                step = #Put;
                                break;
                            }
    
                            if (pass.exists(#WriteOverride))
                            {
                                pass.remove(#WriteOverride);
                                pass.insert(#OverrideDesc, conPeek(conPeek(state.previousForm, 3 + hasError), #data));
                                workExecute.createWorkException(pass.lookup(#WorkId), pass.parmLineNum(), userId, pass.lookup(#OverrideDesc), workLine.wmsLocationId);
                            }
                            pass.insert(#NoOverrideButton, 1);
                            state.nextForm = this.buildWorkExceptions(conNull());
                            step = #OverrideStep2;
                            break;
    
                        case #OverrideStep2:     // Override
                            if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
                            {
                                state.nextForm = this.addErrorLabel(conNull(), "@WAX2962", WHSRFColorText::Error);
                                state.nextForm = this.buildPut(state.nextForm);
                                if (pass.exists(#NoOverrideButton))
                                {
                                    pass.remove(#NoOverrideButton);
                                }
                                pass.insert(#WMSLocationId, workLine.wmsLocationId);
                                step = #Put;
                                break;
                            }
    
                            if (!pass.exists(#SuggestLocation))
                            {
                                pass.insert(#OverrideDesc, conPeek(conPeek(state.previousForm, 3 + hasError), #data));
                                workExecute.createWorkException(pass.lookup(#WorkId), pass.parmLineNum(), userId, pass.lookup(#OverrideDesc), workLine.wmsLocationId);
                            }
                            if (pass.exists(#NoOverrideButton))
                            {
                                pass.remove(#NoOverrideButton);
                            }
                            if (workLine.WorkType == WHSWorkType::Pick && 
                                !localNewLocationId && 
                                pass.exists(#PrevStep) &&
                                pass.exists(#SuggestLocation))
                            {
                                state.nextForm = this.addErrorLabel(state.nextForm, "@WAX2213", WHSRFColorText::Error);
                            }
                            state.nextForm = this.buildGetLocation(state.nextForm, '', localNewLocationId);
                            pass.insert(#PrevStep, step);
                            step = #NoLocation;
    
                            if (workLine.WorkType == WHSWorkType::Put)
                            {
                                pass.insert(#OverrideFromPutLocation, workLine.wmsLocationId);
                            }
                            break;
    
                        case #ShortPick:
                            if (!pass.exists(#Initiation))
                            {
                                [state.previousForm, tmpFieldValues] = WHSRFControlData::processData(state.previousForm, pass);
                                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                                pass = this.combineMaps(pass, fieldValues);
                                [state.nextForm, state.isFormComplete] = this.processFieldValues(state.previousForm, fieldValues);
    
                                if (state.isFormComplete
                                &&  (pass.exists(#ShortPickReason) && pass.lookup(#ShortPickReason) == '')
                                ||  (WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType) && state.buttonClicked == #RFOK
                                &&  !PdsGlobal::pdsIsCWItem(pass.lookupStr(#ItemId))))
                                {
                                    state.isFormComplete = false;
    
                                    if (pass.exists(#ProductConfirmation))
                                    {
                                        pass.remove(#ProductConfirmation);
                                    }
                                }
    
                                if (this.hasError(state.previousForm))
                                {
                                    state.nextForm = state.previousForm;
                                    break;
                                }
                            }
                            else
                            {
                                if (pass.exists(#LicensePlateId))
                                {
                                    pass.remove(#LicensePlateId);
                                }
    
                                pass.insert(#SelectedValue, '');
                                pass.insert(#SelectedValueUOM, '');
    
                                state.nextForm = this.buildShortPick(conNull());
                            }
    
                            if (!pass.exists(#Initiation) && state.isFormComplete
                            && pass.lookupNum(#QtyToPick) > 0
                            && this.serialAssignmentNeeded())
                            {
                                pass.insert(#AssignSerialInShortPick, true); // so we know we haven't finished with the short picking and we need to finish it after the serial assignment
                                pass.insert(#AssignSerial, 1);
                                pass.insert(#SerialCounter, 1);
                                pass.insert(#SerialQty, pass.lookupNum(#QtyToPick));
                                step = #AssignSerialStep;
                                state.nextForm = this.buildAssignSerial(conNull());
                            
                                return [state.nextForm, step, state.recall, pass.pack()];
                            }
    
                            if (!pass.exists(#Initiation) && state.isFormComplete)
                            {
                                state.nextForm = this.completeShortPickStep(state.previousForm, workLine);
    
                                // After completion of short pick we do not have to display the pick details again.
                                pass.insert(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmationDisplayed, 1);
    
                                if (pass.lookupNum(#QtyToPick) == 0)
                                {
                                    pass.insert(#LicensePlateId, '');
    
                                    if (workTable.TargetLicensePlateId != ''
                                    && workLine.isFirstPickLineInProgress()
                                    && workLine.InventQtyWork == workLine.InventQtyRemain) // We could have already picked some qty from another license plate in the same location for this work line.
                                    {
                                        pass.insert(#TargetLicensePlateId, '');
                                        workTable = WHSWorkTable::addTargetLicensePlate(workLine.WorkId, '');
                                    }
                                }
                            }
    
                            else if (!pass.exists(#Initiation))
                            {
                                state.nextForm = this.buildShortPick(conNull());
                            }
    
                            if (pass.exists(#Initiation))
                            {
                                pass.remove(#Initiation);
                            }
                            break;
    
                        case #SplitWork:    // Split Work
                            noFullButton = true;
                            
                            WHSWorkLine groupSplitWorkLine;
    
                            var menuItem = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
    
                            if (this.allowSplitOfQuantityWhenFull(menuItem, workLine))
                            {
                                boolean hasSelectedVAlueUOM = pass.lookupStr(#SelectedValueUOM) != '';
    
                                [state.previousForm, tmpFieldValues] = WHSRFControlData::processData(state.previousForm, pass);
                                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                                pass = this.combineMaps(pass, fieldValues);
    
                                if (pass.exists(#FullQty))
                                {
                                    [state.nextForm, state.isFormComplete] = this.processFieldValues(state.previousForm, fieldValues);

                                    str errorText = this.getErrorText(state.previousForm);

                                    if (errorText != '')
                                    {
                                        state.nextForm = this.buildGetFullQtyWithError(conNull(), errorText);
                                        break;
                                    }
    
                                    if (workLine.UnitId != WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId)
                                        && !hasSelectedValueUOM
                                        || !state.isFormComplete)
                                    {
                                        state.nextForm = this.buildGetFullQty(conNull());
                                        break;
                                    }
    
                                    if (pass.isGroupPick())
                                    {
                                        groupSplitWorkLine = this.getSplitWorkLineForGroupPick(pass.lookup(#WorkId), pass.parmLineNum(), pass.lookupNum(#FullQty));
                                    }
                                }
                                else
                                {
                                    str errorText = this.getErrorText(state.previousForm);

                                    if (errorText != '')
                                    {
                                        state.nextForm = this.buildGetFullQtyWithError(conNull(), errorText);
                                        break;
                                    }

                                    if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed))
                                    {
                                        pass.insert(#FullQty, pass.lookup(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed));
                                    }
                                    
                                    state.nextForm = this.buildGetFullQty(state.nextForm);

                                    if (!pass.lookupNum(#FullQty))
                                    {
                                        pass.insert(#FullQty, '');
                                    }

                                    pass.insert(#SelectedValueUOM, '');
                                    // Break because we need user to input the fullQty to process the split.
                                    break;
                                }
                            }
    
                            UnitOfMeasureSymbol selectedUnitId	= pass.lookupStr(#SelectedValueUOM);
                            InventQty			fullInventQty   = pass.lookupNum(WHSWorkExecuteDisplayUserDirectedControls::FullInventQty);
    
                            if (fullInventQty == 0)
                            {
                                fullInventQty = pass.lookupNum(#FullQty);
                            }
    
                            // Check if the target work needs to be updated after the split.
                            boolean updateTargetWorkId = pass.hasValue(#TargetWorkId) && (pass.lookup(#TargetWorkId) == pass.lookup(#WorkId));
                            
                            // Split the work where fullQty is the qty on the current work line to be picked when using allow full split.
                            if (pass.isGroupPick())
                            {
                                pass.insert(#WorkId, WHSWorkTable::splitGroupedWork(pass.lookup(#WorkId),
                                                                                pass.parmLineNum(),
                                                                                groupSplitWorkLine.LineNum,
                                                                                fullInventQty,
                                                                                menuItem.WorkerKeepsOrigWork,
                                                                                userId));
                            }
                            else
                            {
                                Map workLineWithQuantity = this.getInProgressPickLines(fullInventQty);

                                if (workLineWithQuantity.elements() == 1)
                                {
                                    pass.insert(#WorkId, WHSWorkTable::splitWork(pass.lookup(#WorkId),
                                                                            pass.parmLineNum(),
                                                                            fullInventQty,
                                                                            menuItem.WorkerKeepsOrigWork,
                                                                            userId));
                                }
                                else if (workLineWithQuantity.elements() > 1)
                                {
                                    WhsSplitWork splitWork = WhsSplitWork::newFromMultipleWorkLines(pass.lookup(#WorkId),
                                                                                                    workLineWithQuantity, 
                                                                                                    menuItem.WorkerKeepsOrigWork, 
                                                                                                    userId);
                                    pass.insert(#WorkId, splitWork.splitMultipleWorkLines());
                                }                               
                            }
                            
                            // If necessary update the target work, so pick/pack can move forward.
                            if (updateTargetWorkId)
                            {
                                pass.insert(#TargetWorkId, pass.lookup(#WorkId));
                            }
    
                            if (mode == WHSWorkExecuteMode::UserGrouping
                            || mode == WHSWorkExecuteMode::SystemGrouping)
                            {
                                ttsbegin;
                                WHSWorkGrouping workGrouping;
    
                                update_recordset workGrouping
                                    setting WorkId = pass.lookup(#WorkId)
                                    where workGrouping.WorkId == workLine.WorkId
                                        && workGrouping.WorkGroupingId == pass.lookup(#WorkGroupingId);
    
                                ttscommit;
                            }
    
                            workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), pass.lookup(#UserId));
                            if (state.isFormComplete)
                            {
                                // Update the pass being used to build up the pick screen to contain the qty being entered as the new verified qty.
                                prevPass = WHSRFPassthrough::create(conPeek(state.previousForm, 2));
                                prevPass.insert(#PrevStep, #SplitWork);
                                prevPass.insert(#QtyVerification, workLine.QtyRemain);
                                state.previousForm = conPoke(state.previousForm, 2, prevPass.pack());
                            }
    
                            // Remove the fullQty from the pass through as the work has already been split at this point.
                            pass.remove(#FullQty);
    
                            if (mode == WHSWorkExecuteMode::PickPack)
                            {
                                if (pass.exists(#TargetWorkId) && pass.lookup(#TargetWorkId) == workLine.WorkId)
                                {
                                    pass.insert(#TargetWorkId, pass.lookup(#WorkId));
                                }
    
                                pass.insert(#PickPackOverride, 1);
                                pass.remove(#FullQty);
    
                                state.previousForm = conPoke(state.previousForm, 2, pass.pack());
                            }
    
                            if (!this.shouldHandleByLP() && pass.exists(#TargetLicensePlateId))
                            {
                                WHSWorkTable::addTargetLicensePlate(workLine.WorkId, pass.lookup(#TargetLicensePlateId));
                            }
    
                            state.nextForm = this.determineRestart(state.previousForm);
    
                            pass.clearGroupPick();
                            pass.clearGroupPickFail();
    
                            state.nextForm = this.updateModeStepPass(state.nextForm, mode, step, pass);
                        
                            if (step != #CWOutboundWeightCapture)
                            {
                                state.recall = true;
                            }
         
                            break;
    
                        case #ShortPickConf:
                            InventDim inventDimFromPass = this.createInventDimFromPass();
                            mustCaptureMoreDims = this.buildNextDimensionCaptureControl(conNull(), inventDimFromPass, pass.lookupStr(#ItemId), pass.lookupNum(#QtyToPick)) != conNull();
                            WHSWorkLine shortPickedWorkLine = workLine.data();
                            tmpWorkId = shortPickedWorkLine.WorkId;
    
                            WHSItemReallocation reallocationProcess = real2int(pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess));
                            InventQty initialWorkLineInventQty = this.initialShortPickConfirmationWorkLineInventQuantity(shortPickedWorkLine, reallocationProcess);
                            WHSLicensePlateId groupPickLP;
    
                            if (pass.isGroupPick())
                            {
                                workLine = workExecute.executeGroupPickShortPick(pass.lookup(#WorkId),
                                                                                pass.parmLineNum(),
                                                                                pass.lookup(#ShortPickReason),
                                                                                pass.lookupNum(#QtyToPick),
                                                                                pass.lookup(#UOM),
                                                                                userId,
                                                                                pass.exists(#LicensePlateId) ? pass.lookupStr(#LicensePlateId)
                                                                                                            : pass.lookupStr(#TargetLicensePlateId),
                                                                                mustCaptureMoreDims);
    
                                groupPickLP = pass.lookupStr(#LicensePlateId);
                            }
                            else
                            {
                                workLine = workExecute.executeShortPick(pass.lookup(#WorkId),
                                                                    pass.parmLineNum(),
                                                                    pass.lookup(#ShortPickReason),
                                                                    pass.lookupNum(#QtyToPick),
                                                                    pass.lookup(#UOM),
                                                                    userId,
                                                                    pass.exists(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) :
                                                                                                    pass.lookupStr(#TargetLicensePlateId),
                                                                    mustCaptureMoreDims,
                                                                    this.assignSerial(workLine),
                                                                    reallocationProcess != 0);
                            }
    
                            if (pass.exists(#VoidWaveLabel) && pass.lookup(#VoidWaveLabel) == #RFYes
                            && pass.exists(#PrinterName) && pass.lookup(#PrinterName) != '')
                            {
                                this.reprintWaveLabels(pass);
                            }
    
                            prevPass = pass;
    
                            if (workLine.RecId == 0 && pass.lookupNum(#QtyToPick) == 0 && pass.exists(#WorkGroupingId))
                            {
                                workLine = WHSWorkGrouping::getNextGroupingWorkLine(pass.lookup(#WorkGroupingId), userId);
                            }
    
                            // Only rebuild pick screen for additional information if there was a quantity to pick.
                            if (mustCaptureMoreDims || (pass.lookupNum(#QtyToPick) && PdsGlobal::pdsIsCWItem(shortPickedWorkLine.ItemId)))
                            {
                                this.preparePassForCaptureTrackingDimsAfterShortPicking(#ShortPickConf, state, prevPass, shortPickedWorkLine);
                            }

                            this.initializePassItemReallocationValues(initialWorkLineInventQty, shortPickedWorkLine);
                            [state.nextForm, state.recall] = this.completeShortPickConfirmationStep(state.previousForm, workExecute);

                            if (!pass.lookupNum(#QtyToPick) || !workLine)
                            {
                                this.closeContainerForWork(shortPickedWorkLine);
                            }
    
                            if (workLine.WorkId     != preWorkLine.WorkId
                            || workLine.LineNum != preWorkLine.LineNum)
                            {
                                this.clearVerificationFields();
                            }
    
                            this.maintainGroupPickForShortPick(preWorkLine, groupPickLP);
    
                            pass.remove(#AssignSerial);
                            pass.remove(#QtyToPick);
    
                            if (mode == WHSWorkExecuteMode::SystemGrouping
                                && prevPass.exists(#Id)
                                && !pass.exists(#Id)
                                && prevPass.lookupStr(#GroupingWorkTotal) != prevPass.lookupStr(#GroupingWorkNum))
                            {
                                this.restoreDataByKeys(prevPass, [#Id, #SkipWorkId, #GroupingWorkTotal, #GroupingWorkNum, #WorkGroupingId, #InventSiteId, #InventLocationId]);
                                step = #stepMax;
                            }
    
                            break;
    
                        case #ManualReallocationListShortPickConf:
                            // Saving the state of the short pick work line since these values are needed for reallocation
                            // after the executeShortPick. Same pattern is used for #ShortPickConf step.
                            WHSWorkLine manualShortPickedWorkLine = workLine.data();
                            InventQty manualInitialWorkLineInventQty = localWorkLine.InventQtyRemain;

                            prevPass = pass;
    
                            if (WHSWorkExecuteDisplayItemReallocationControls::isItemReallocationControl(_buttonClicked) ||
                                WHSWorkExecuteDisplayItemReallocationControls::isProceedControl(_buttonClicked))
                            {
                                this.executeShortPickManualReallocationConfirmation(
                                    state,
                                    workExecute,
                                    manualInitialWorkLineInventQty,
                                    manualShortPickedWorkLine);
                            }
    
                            if (state.nextForm == conNull())
                            {
                                [state.nextForm, state.recall] = this.cleanupManualReallocationListDisplay(state.previousForm);
                            }
    
                            if (workLine.WorkId     != preWorkLine.WorkId
                            || workLine.LineNum != preWorkLine.LineNum)
                            {
                                this.clearVerificationFields();
                            }
    
                            break;
    
                        case #ManualReallocationList:
                            WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                            WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
                            InventHandlingQty inventQtyToReallocate = workLineReallocationParams.getInventHandlingQtyToReallocate();
                            state.nextForm = conNull();
    
                            if (WHSWorkExecuteDisplayItemReallocationControls::isItemReallocationControl(state.buttonClicked))
                            {
                                WMSLocationId selectedLocationId = WHSWorkExecuteDisplayItemReallocationControls::getLocationIdFromControl(state.buttonClicked);
    
                                if (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabledForItem(workLine.ItemId))
                                {
                                    WHSOrderCommittedReservationFacade::removeAllOrderCommittedReservationsOnInventDim(
                                                workLine.ItemId,
                                                workLine.inventDim(),
                                                WHSAdjustmentType::find(pass.lookup(#ShortPickReason)).RemoveReservation);
                                }

                                InventHandlingQty reallocatedQty = reallocator.reallocateWorkLineHandlingQuantity(selectedLocationId, inventQtyToReallocate);
                                inventQtyToReallocate -= reallocatedQty;
    
                                InventHandlingQty totalReallocatedInventQty = workLineReallocationParams.getTotalReallocatedInventHandlingQty() + reallocatedQty;
    
                                reallocator.runManualWorkLineReallocationPostUpdatesHandlingQty(reallocatedQty);
    
                                if (!reallocatedQty)
                                {
                                    warningLabel = reallocator.parmWarningLabel();
                                }
                                else if (inventQtyToReallocate > 0)
                                {
                                    pass.insert(WHSWorkExecuteDisplayItemReallocationControls::TotalReallocatedQty, totalReallocatedInventQty);
                                    state.nextForm = this.buildManualReallocationList(workLineReallocationParams, inventQtyToReallocate);
                                }
                            }
                            if (state.nextForm == conNull())
                            {
                                [state.nextForm, state.recall] = this.cleanupManualReallocationListDisplay(state.previousForm);
                            }
                            break;
    
                        case #RFPickingComment:
                            step = #StepOne;
                            pass.insert(#CommentsDisplayed, 1);
                            state.recall = true;
                            break;
                        
                        case #AssignSerialStep:
                            [state.previousForm, tmpFieldValues] = WHSRFControlData::processData(state.previousForm, pass);
                            fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                            pass = this.combineMaps(pass, fieldValues);
                            [state.nextForm, state.isFormComplete] = this.processFieldValues(state.previousForm, fieldValues);
    
                            if (this.hasError(state.previousForm))
                            {
                                state.nextForm = state.previousForm;
                                break;
                            }
    
                            if (state.isFormComplete || state.buttonClicked == #RFSerialUnreadable)
                            {
                                this.createAssignSerialDimTracking(state.buttonClicked);
    
                                if (pass.lookupNum(#SerialCounter) < pass.lookupNum(#SerialQty))
                                {
                                    pass.insert(#SerialCounter, pass.lookupNum(#SerialCounter) + 1);
    
                                    state.nextForm = this.buildAssignSerial(conNull());
                                }
                                else
                                {
                                    if (pass.exists(#AssignSerialInShortPick))
                                    {
                                        step = #ShortPick;
                                        pass.remove(#AssignSerialInShortPick);
                                    }
                                    else
                                    {
                                        step = #Pick;
                                    }

                                    if (this.allowMarkSerialAsCompleted())
                                    {
                                        // marks serial as completed, it's used in last build pick step to skip any more prompt for dimensions
                                        this.markWorkLineSerialValidated(workLine);
                                    }

                                    pass.remove(#SerialCounter);
                                    pass.remove(#SerialQty);

                                    state.nextForm = [[mode,step], pass.pack()];
                                    state.nextForm = this.updateModeStepPass(state.nextForm, mode, step, pass);

                                    if (preWorkLine != workLine
                                        || preWorkLine.QtyRemain > workLine.QtyRemain)
                                    {
                                        iteration = 0;
                                    }
                                    else if (iteration >= iterationMax)
                                    {
                                        this.instrumentationLogger().logError('There were more than 1000000 iterations.');
                                        throw error("@WAX:WarehouseOperationInternalErrorType_InfiniteLoop");
                                    }

                                    localWorkLine = workLine;
                                    localCon = state.nextForm;
                                    localMode = mode;
                                    localStep = step;
                                    localUserId = _userId;
                                    localButtonClicked = state.buttonClicked;
                                    continue;
                                }
                            }
                            break;
    
                        case #WorkAuditTemplate:
                            this.populatePassWorkAudit();
                            WHSWorkAuditCaptureData workAuditCaptureData;
    
                            if (!pass.exists(#AuditSeqNum))
                            {
                                pass.insert(#AuditSeqNum, WHSWorkAuditTemplateTable::getNextTemplateLine(pass.lookup(#AuditTemplateId)).AuditSeqNum);
                            }
                            // If Audit Seq Num already exists, previous audit function was Capture Data or Display
                            else
                            {
                                WHSWorkAuditTemplateLine workAuditTemplateLine = WHSWorkAuditTemplateLine::find(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));
    
                                if (workAuditTemplateLine.AuditBreakFunction == WHSAuditBreakFunction::CaptureData)
                                {
                                    pass.insert(#CustomData, conPeek(conPeek(state.previousForm, 4), #data));
    
                                    if (pass.lookup(#CustomData) != '')
                                    {
                                        // Insert data into our audit custom data table
                                        workAuditCaptureData = WHSWorkAuditCaptureData::create(workTable.WorkId,
                                                                                        pass.lookup(#AuditTemplateId),
                                                                                        pass.lookup(#AuditSeqNum),
                                                                                        pass.lookup(#CustomData));
                                    }
                                    else
                                    {
                                        // User did not scan anything
                                        state.nextForm = localCon;
                                        break;
                                    }
                                }
    
                                if (!workAuditTemplateLine.hasCustomMethod())
                                {
                                    // If not using a custom method on captured data, move on to remaining audit functions
                                    workAuditTemplateLine = WHSWorkAuditTemplateTable::getNextTemplateLine(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));
    
                                    if (workAuditTemplateLine.RecId != 0)
                                    {
                                        pass.insert(#AuditSeqNum, workAuditTemplateLine.AuditSeqNum);
                                    }
                                    else
                                    {
                                        pass.insert(#AuditSeqNum, str2int(pass.lookup(#AuditSeqNum)) + 1);
                                    }
                                }
                            }
    
                            // Execute Audit Template functions
                            [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(pass.lookup(#AuditTemplateId),
                                                                                        pass.lookup(#AuditSeqNum),
                                                                                        workTable,
                                                                                        workAuditCaptureData.RecId);
    
                            // If Capture Data or Display Function, screen must be presented to user
                            if (!auditComplete)
                            {
                                pass.insert(#AuditSeqNum, auditSeqNum);
                                state.nextForm = this.buildWorkAuditTemplate(conNull());
                            }
                            else
                            {
                                this.removePassWorkAudit();
    
                                if (WHSWorkAuditTemplateTable::find(pass.lookup(#AuditTemplateId)).AuditBreakEvent == WHSAuditBreakEvent::Prior)
                                {
                                    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).PickPack)
                                    {
                                        pass.insert(#PickPackOverride, 1);
                                    }
                                    step = #StepOne;
                                    state.recall = true;
                                }
                                else
                                {
                                    pass.remove(#AuditWorkId);
                                    step = #Restart;
                                    state.recall = true;
                                }
                            }
                            break;
    
                        case #OverpickStep:
                        if (!pass.exists(#Initiation) || !pass.exists(#QtyToPick) || pass.lookupNum(#QtyToPick) <= 0)
                            {
                                state.nextForm = this.buildOverpickScreen(conNull());
                                pass.insert(#Initiation, 1);
                            }
                            else
                            {
                                if (workExecute.executeOverPick(workLine,
                                                workTable,
                                                WHSWorkExecuteDisplay::str2numDisplay(pass.lookupStr(#QtyToPick)),
                                                pass.lookupStr(#UOM),
                                                userId,
                                                pass.lookupStr(#MenuItem)))
                                {
                                    pass.remove(#Initiation);
                                    pass.remove(#QtyToPick);
                                    pass.remove(#SelectedValueUOM);

                                    step = pass.lookup(#PrevStep);
                                    
                                    pass.insert(#PrevStep, #OverpickStep);

                                    workLine.reread();
                                    // Display pick screen with updated quantities.
                                    state.nextForm = this.buildPick(conNull(), '', false);
                                }
                                else
                                {
                                    // If over pick did not succeed then display the error message and rebuild screen.
                                    state.nextForm = this.addErrorLabelFromInfolog(conNull(), startInfologLine, WHSRFColorText::Error);
                                    state.nextForm = this.buildOverpickScreen(state.nextForm);
                                }
                            }
                            break;
    
                        case #SplitPutWork:
                            InventDim   inventDim;
                            ItemId      itemId;
                        
                            [state.previousForm, tmpFieldValues] = WHSRFControlData::processData(state.previousForm, pass);
                            fieldValues = WHSRFPassthrough::create(tmpFieldValues);

                            boolean ownerIdFieldExistsInPass = pass.exists(#OwnerId_RU);
                            InventOwnerId_RU ownerIdFromPass = pass.parmInventOwnerId();
                            pass = this.combineMaps(pass, fieldValues);
                            // If owner Id existed in the pass before combining maps and now it's blank, restore it.
                            // It should not be restored in case it was not a part of the pass map.
                            if (ownerIdFieldExistsInPass && !pass.lookup(#OwnerId_RU))
                            {
                                pass.insert(#OwnerId_RU, ownerIdFromPass);
                            }
                            [state.nextForm, state.isFormComplete] = this.processFieldValues(state.previousForm, fieldValues);
    
                            if (this.hasError(state.previousForm))
                            {
                                // Pass would have user Id in location if it rebuilt the split put screen
                                // This is needed to verify serial id in the correct location
                                pass.insert(#WMSLocationId, WHSWorkLine::getPrevOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType).UserId);
    
                                state.nextForm = state.previousForm;
                                break;
                            }
    
                            if (state.buttonClicked != #RFSplitPut)
                            {
                                if (pass.exists(#QtyToPut) && pass.lookupNum(#QtyToPut) == pass.lookupNum(#QtyLeft))
                                {
                                    throw error(strFmt("@WAX:SplitPutEntireAvailableQtyNotAllowed", pass.lookup(#QtyLeft)));
                                }
    
                                if (state.isFormComplete)
                                {
                                    inventDim = this.createInventDimFromPass();
                                    inventDim.wMSLocationId = WHSWorkLine::getPrevOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType).UserId;

                                    if (!inventDim.InventBatchId
                                        && !pass.hasValue(#BatchId)
                                        && pass.hasValue(#InventDimId)
                                        && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkCreationProcess == WHSWorkCreationProcess::MovementByTemplate
                                        && WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(InventTable::find(workLine.ItemId)))
                                    {
                                        InventBatchId batchId = inventDim::find(pass.lookup(#InventDimId)).inventBatchId;
                                        if (batchId)
                                        {
                                            inventDim.inventBatchId = batchId;
                                        }
                                    }

                                    inventDim = InventDim::findOrCreate(inventDim);
    
                                    itemId = workLine.ItemId;
    
                                    // Process work
                                    workLine = workExecute.putPartialAwayToLocation(workLine.WorkId,
                                                                            workLine.LineNum,
                                                                            pass.parmQtyToPut(),
                                                                            workLine.WMSLocationId,
                                                                            userId,
                                                                            pass.lookupStr(#TargetLicensePlateId),
                                                                            inventDim.inventDimId);
    
                                    state.recall = true;
    
                                    tmpWorkId = pass.lookupStr(#WorkId);
    
                                    state.nextForm = this.determineRestart(state.previousForm);
    
                                    this.removeTrackingDimensionsFromPass(itemId);
    
                                    pass.insert(#PrevWorkId, tmpWorkId);
                                    pass.remove(#CurrentQty);
                                }
                                else
                                {
                                    state.nextForm = this.buildSplitPut(conNull());
                                }
                            }
                            else
                            {
                                // When entering split screen for first time, these should be blank.
                                pass.insert(#TargetLicensePlateId, '');
                                pass.remove(#QtyToPut);
    
                                state.nextForm = this.buildSplitPut(conNull());
                            }
                            break;
    
                        case #FEFOWarehouseLocationList:
                            if (state.buttonClicked != '')
                            {
                                if (state.buttonClicked == WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn)
                                {
                                    pass.insert(WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn, 1);
                                }
                                else
                                {
                                    workExecute.updateWorkLineLocation(workLine.WorkId, workLine.LineNum, state.buttonClicked, pass.lookupStr(#UserId));
                                    workLine.reread();
                                }
                            }
                           
                            pass.insert(WHSWorkExecuteDisplayFEFOBatchLabelControls::IgnoreLocationFEFOWarn, 1);
                            
                            step = #Pick;
                            state.nextForm = this.buildPick(conNull());
                            break;
    
                        case #CWOutboundWeightCapture:
                            state.nextForm = this.processOutboundWeightCapture(hasError, state.previousForm);
                            break;
         
                        default:
                            boolean finishedProcessing = this.processWorkLineForCustomStep(state);
    
                            if (finishedProcessing)
                            {
                                return [state.nextForm, step, state.recall, pass.pack()];
                            }
                            break;
                    }
                }
    
                this.restartWorkAuditStep(state, auditComplete, tmpWorkId);
    
                if ((WHSRFAutoConfirm::isAutoConfirmationEnabled(pass.lookup(#MenuItem), preWorkLine.WorkType)
                        && pass.exists(#AutoConfirm)
                        && this.canProcessWorkLineOnAutoCompletion(preWorkLine))
                    || (pass.isGroupPick()
                        && state.recall
                        && step != #StepOne))
                {
                    pass.remove(#AutoConfirm);
                    state.nextForm = this.updateModeStepPass(state.nextForm, mode, step, pass);

                    if (preWorkLine != workLine
                        || preWorkLine.QtyRemain > workLine.QtyRemain)
                    {
                        iteration = 0;
                    }
                    else if (iteration >= iterationMax)
                    {
                        this.instrumentationLogger().logError('There were more than 1000000 iterations.');
                        throw error("@WAX:WarehouseOperationInternalErrorType_InfiniteLoop");
                    }

                    localWorkLine = workLine;
                    localCon = state.nextForm;
                    localMode = mode;
                    localStep = step;
                    localUserId = _userId;
                    localButtonClicked = state.buttonClicked;
                    continue;
                }
                else if (pass.exists(#GroupPutawayConfirm)
                        || (pass.isGroupPickConfirmed()
                            && step != #ShortPickConf)
                        || (this.isGroupPickConfirmedAndLocationConfirmationEnabled(preWorkLine)))
                {
                    pass.remove(#AutoConfirm);
                    state.nextForm = this.updateModeStepPass(state.nextForm, mode, step, pass);
                
                    if (preWorkLine != workLine
                        || preWorkLine.QtyRemain > workLine.QtyRemain)
                    {
                        iteration = 0;
                    }
                    else if (iteration >= iterationMax)
                    {
                        this.instrumentationLogger().logError('There were more than 1000000 iterations.');
                        throw error("@WAX:WarehouseOperationInternalErrorType_InfiniteLoop");
                    }
                
                    localWorkLine = workLine;
                    localCon = state.nextForm;
                    localMode = mode;
                    localStep = step;
                    localUserId = _userId;
                    localButtonClicked = state.buttonClicked;
                    continue;
                }
                else if (step == #StepOne && pass.isGroupPick())
                {
                    // Group Pick flag will be re-initialized
                    pass.clearGroupPick();
                }

                break;
            }
        }
        while(true);
        
        return [state.nextForm, step, state.recall, pass.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>delayCycleCountUntilGroupPickCompleted</Name>
				<Source><![CDATA[
    private boolean delayCycleCountUntilGroupPickCompleted(WHSWorkLine _preWorkLine, WHSWorkLine _workLine)
    {
        return pass.isGroupPick() && WhsWorkExecuteDisplay::canWorkLinesBeGrouped(_workLine, _preWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextWorkLineForGroupPicking</Name>
				<Source><![CDATA[
    private WHSWorkLine getNextWorkLineForGroupPicking(WHSWorkLine _preWorkLine, WHSWorkLine _workLine)
    {
        if (pass.isGroupPick()
         && _preWorkLine.LineNum > _workLine.LineNum)
        {
            WHSWorkLine groupPickWorkLine = this.getNextOpenPickWorkLine(_preWorkLine.WorkId, _preWorkLine.LineNum);

            if (_preWorkLine.canWorkLineBeGrouped(groupPickWorkLine))
            {
                return groupPickWorkLine;
            }
        }

        return _workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextOpenPickWorkLine</Name>
				<Source><![CDATA[
    private WHSWorkLine getNextOpenPickWorkLine(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkLine nextWorkLine;

        select firstonly nextWorkLine
            order by LineNum
            where nextWorkLine.WorkId     == _workId
              &&  nextWorkLine.WorkType   == WHSWorkType::Pick
              &&  nextWorkLine.WorkStatus == WHSWorkStatus::Open
              &&  nextWorkLine.LineNum    >  _lineNum
              &&  nextWorkLine.LineNum    <  WHSWorkLine::getNextOppositeWorkLine(_workId, _lineNum, WHSWorkType::Pick);

        return nextWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePassWorkAudit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the work audit from the pass.
    /// </summary>
    protected void removePassWorkAudit()
    {
        pass.remove(#AuditSeqNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePassWorkAudit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the work audit in the pass.
    /// </summary>
    protected void populatePassWorkAudit()
    {
        pass.insert(#AuditTemplateId, WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkAuditTemplateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustIncludeWorkAuditStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work audit step must be included.
    /// </summary>
    /// <returns>true if the work audit step must be included; otherwise, false.</returns>
    protected boolean mustIncludeWorkAuditStep()
    {
        return (workLine.isFirstNonCancelledWorkLine() &&
                pass.lookupStr(#AuditWorkId) != workLine.WorkId   &&
                WHSWorkAuditTemplateTable::evaluateWorkAuditBreak(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkAuditTemplateId,
                                                                    workTable,
                                                                    pass.lookup(#MenuItem),
                                                                    WHSAuditBreakEvent::Prior,
                                                                    pass.lookupStr(#WorkGroupingId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareWorkAuditStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares the work audit step.
    /// </summary>
    /// <param name = "_state">The current state.</param>
    protected void prepareWorkAuditStep(WhsWorkProcessWorkLineState _state)
    {
        if (this.mustIncludeWorkAuditStep())
        {
            if (pass.exists(#DetermineStep))
            {
                pass.remove(#DetermineStep);
            }
            step = #WorkAuditTemplate;
            if (_state.buttonClicked != #RFSkip)
            {
                _state.recall = true;
            }
            pass.insert(#AuditWorkId, workLine.WorkId);

            if (!pass.exists(#WorkId))
            {
                pass.insert(#WorkId, workLine.WorkId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>restartWorkAuditStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restarts the work audit step if required.
    /// </summary>
    /// <param name = "_state">The current state.</param>
    /// <param name = "_auditComplete">Describes if the audit is complete.</param>
    /// <param name = "_workId">The work id being processed.</param>
    protected void restartWorkAuditStep(WhsWorkProcessWorkLineState _state, boolean _auditComplete, WHSWorkId _workId)
    {
        // Evaluate work audit templates after work completion
        if (step == #Restart            &&
            step != #WorkAuditTemplate  &&
            !pass.exists(#AuditWorkId)  &&
            !_auditComplete              &&
            WHSWorkAuditTemplateTable::evaluateWorkAuditBreak(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkAuditTemplateId,
                                                                workTable,
                                                                pass.lookup(#MenuItem),
                                                                WHSAuditBreakEvent::Completion,
                                                                pass.lookupStr(#WorkGroupingId)))
        {
            step  = #WorkAuditTemplate;
            _state.recall = true;
            pass.insert(#AuditWorkId, _workId);
        }
    
        if (step == #WorkAuditTemplate && _state.nextForm == conNull())
        {
            _state.nextForm = _state.previousForm;
        }    
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUseOfDeferredPut</Name>
				<Source><![CDATA[
    protected boolean allowUseOfDeferredPut()
    {
        WHSRFMenuItemTable menuItem = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));

        if (!this.allowUseOfDeferredPutWithAuditTemplate(menuItem.WorkAuditTemplateId))
        {
            return false;
        }
        
        return this.checkDeferredPutProcessingPolicyAllowsDeferredProcessing(menuItem.DeferredPutProcessingPolicy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUseOfDeferredPutWithAuditTemplate</Name>
				<Source><![CDATA[
    private boolean allowUseOfDeferredPutWithAuditTemplate(WHSWorkAuditTemplateId _workAuditTemplateId)
    {
        return !_workAuditTemplateId ||
            WHSWorkAuditTemplateTable::find(_workAuditTemplateId).AuditBreakEvent == WHSAuditBreakEvent::Prior;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDeferredPutProcessingPolicyAllowsDeferredProcessing</Name>
				<Source><![CDATA[
    private boolean checkDeferredPutProcessingPolicyAllowsDeferredProcessing(WHSDeferredPutProcessingMobileDevicePolicy _policy)
    {
        switch (_policy)
        {
            case WHSDeferredPutProcessingMobileDevicePolicy::IgnoreSettings:
                return false;
            default:
                return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerForWork</Name>
				<Source><![CDATA[
    private void closeContainerForWork(WHSWorkLine _workLine)
    {
        // Close work's container
        if (!WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum))
        {
            WHSContainerTable::determineContainerClose(_workLine.WorkId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialShortPickConfirmationWorkLineInventQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the initial work line inventory quantity for short picking confirmation.
    /// If automatic reallocation then we use InventQtyWork; otherwise InventQtyRemain.
    /// </summary>
    /// <param name = "_shortPickWorkLine">The work line record.</param>
    /// <param name = "_reallocationProcess">The item reallocation process type.</param>
    /// <returns>The initial work line inventory quantity.</returns>
    [Hookable(false)]
    internal InventQty initialShortPickConfirmationWorkLineInventQuantity(WHSWorkLine _shortPickWorkLine, WHSItemReallocation _reallocationProcess)
    {
        if (pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired)
            && (_reallocationProcess == WHSItemReallocation::Automatic || _reallocationProcess == WHSItemReallocation::AutomaticAndManual))
        {
            return _shortPickWorkLine.InventQtyWork;
        }
        else
        {
            return _shortPickWorkLine.InventQtyRemain;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForNegativeBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method determines if RF user needs to be prompted for batch Id based on negative inventory setup
    /// </summary>
    /// <param name="_dimField">
    /// The current invent dim field we are evaluating to be built on RF screen
    /// </param>
    /// <param name="_inventDim">
    /// The inventDim holding values predetermined by the work.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which determines if the inventory is allowed to go negative
    /// </param>
    /// <returns>
    /// true if the user needs to be prompted for batch Id; otherwise false
    /// </returns>
    private boolean promptForNegativeBatch(
        FieldId     _dimField,
        InventDim   _inventDim,
        ItemId      _itemId)
    {
        WMSLocation location;
        boolean     ret;

        location = _inventDim.wmsLocation();

        if (_dimField == fieldNum(InventDim, InventBatchId)
        &&  !location.whsLocationIsLPControlled()
        &&  InventTable::find(_itemId).whsAllowPhysNeg()
        &&  location.whsLocationProfile().AllowNegative)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reprintWaveLabels</Name>
				<Source><![CDATA[
    private void reprintWaveLabels(WhsrfPassthrough _pass)
    {
        WHSWaveLabel waveLabel;
        WHSWorkTable workTableLocal = WHSWorkTable::find(_pass.lookup(#WorkId));

        if (workTableLocal.WorkTransType != WHSWorkTransType::Replenishment)
        {
            while select LabelBuildId, maxof(NumberOfLabels) from waveLabel
                group by LabelBuildId
                where waveLabel.WorkId == _pass.lookup(#WorkId)
                    && waveLabel.WorkLineNum == _pass.parmLineNum()
            {
                WHSWaveLabelHistoryPrint::printWHSWaveLabelBuildIdRange(_pass.lookup(#PrinterName), waveLabel.LabelBuildId, 1, waveLabel.NumberOfLabels, true);
            }
        }
        else
        {
            WHSReplenWorkLink replenWorkLink;

            while select LabelBuildId, maxof(NumberOfLabels) from waveLabel
                group by LabelBuildId
                    exists join replenWorkLink
                        where replenWorkLink.DemandWorkId == waveLabel.WorkId
                            && replenWorkLink.DemandLineNum == waveLabel.WorkLineNum
                            && replenWorkLink.ReplenWorkId == _pass.lookup(#WorkId)
                            && replenWorkLink.ReplenLineNum == _pass.parmLineNum()
            {
                WHSWaveLabelHistoryPrint::printWHSWaveLabelBuildIdRange(_pass.lookup(#PrinterName), waveLabel.LabelBuildId, 1, waveLabel.NumberOfLabels, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildBatchDisposition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If an error occurs, rebuild the batch disposition combo box on the RF screen.
    /// </summary>
    /// <param name="_con">
    ///     The current RF container variable.
    /// </param>
    /// <param name="_controlName">
    ///     The name used to identify the RF control.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container rebuildBatchDisposition(container _con, str _controlName = #BatchDisposition)
    {
        container               ret = _con;
        str                     elements;
        container               batchDisposition;
        int                     batchDispLoc;
        PdsBatchDispositionCode defaultValue;
        PdsBatchDispositionCode selectedValue;
        boolean                 showBlank;
        ItemId                  itemId;

        if (this.displayBatchDisposition())
        {
            itemId = pass.lookupStr(#ItemId);

            // Get the default batch disposition code.
            [defaultValue, showBlank] = this.getDefaultBatchDispositionCode(itemId);

            elements = this.buildBatchDispositionElements(showBlank);

            ret = this.updateControlInContainer(ret, _controlName, elements);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildDimUOM</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If an error occurs, rebuild the dim UOM combo box on the RF screen.
    /// </summary>
    /// <param name="_con">
    ///     The current RF container variable.
    /// </param>
    /// <param name="_showBlank">
    ///     A Boolean value to indicate whether a blank value should be included in the list of available options.
    /// </param>
    /// <param name="_controlName">
    ///     The name used to identify the RF control.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container rebuildDimUOM(
        container   _con,
        boolean     _showBlank,
        str         _controlName = #DimUOM)
    {
        return this.rebuildUOM(_con, _showBlank, _controlName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildUOM</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If an error occurs, rebuild the UOM combo box on the RF screen.
    /// </summary>
    /// <param name="_con">
    ///     The current RF container variable.
    /// </param>
    /// <param name="_showBlank">
    ///     A Boolean value to indicate whether a blank value should be included in the list of available options.
    /// </param>
    /// <param name="_controlName">
    ///     The name used to identify the RF control.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    [Hookable(false)]
    protected container rebuildUOM(
        container   _con,
        boolean     _showBlank,
        str         _controlName)
    {
        container           ret = _con;
        str                 elements;
        container           uom;
        int                 uomLoc;
        UnitOfMeasureSymbol selectedValue;
        ItemId              itemId;

        if (pass.exists(#ItemId))
        {
            itemId = pass.lookup(#ItemId);
        }

        elements = this.buildUOMSequenceGroupString(itemId, _showBlank);
        
        ret = this.updateControlInContainer(ret, _controlName, elements);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildUseVendBatchDates</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If an error occurs, rebuild the combo boxes on the RF screen.
    /// </summary>
    /// <param name="_con">
    ///     The current RF container variable.
    /// </param>
    /// <returns>
    ///     Returns the updated RF container variable.
    /// </returns>
    protected container rebuildUseVendBatchDates(container _con)
    {
        container   ret = _con;
        str         elements;
        container   useVendBatchDate;
        container   useVendExpDate;
        int         useVendBatchDateLoc;
        int         useVendExpDateLoc;

        elements = this.buildNoYesCombobox();

        // Get the locations of the combo boxes used to indicate whether vendor batch date and vendor batch expiry date must be utilized.
        useVendBatchDateLoc = this.getControlLocation(ret, #UseVendBatchDate);
        useVendExpDateLoc   = this.getControlLocation(ret, #UseVendExpDate);

        // Remove and reinsert the available selections for the vendor batch date combo box.
        useVendBatchDate    = conPeek(ret, useVendBatchDateLoc);
        useVendBatchDate    = conDel(useVendBatchDate, #data, 1);
        useVendBatchDate    = conIns(useVendBatchDate, #data, elements);

        // Remove and reinsert the available selections for the vendor batch expiry date combo box.
        useVendExpDate  = conPeek(ret, useVendExpDateLoc);
        useVendExpDate  = conDel(useVendExpDate, #data, 1);
        useVendExpDate  = conIns(useVendExpDate, #data, elements);

        ret = conDel(ret, useVendBatchDateLoc, 1);
        ret = conIns(ret, useVendBatchDateLoc, useVendBatchDate);

        ret = conDel(ret, useVendExpDateLoc, 1);
        ret = conIns(ret, useVendExpDateLoc, useVendExpDate);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrackingDimensionsFromPass</Name>
				<Source><![CDATA[
    protected void removeTrackingDimensionsFromPass(ItemId _itemId, InventDimParm _selectedTrackingDimsToRemove = null)
    {
        ListEnumerator          le;
        FieldName               fieldName;
        InventDimParm           trackingDimsToRemove;

        trackingDimsToRemove.setAllTrackingDimensions();

        if (!_selectedTrackingDimsToRemove.isAllFlagNo())
        {
            trackingDimsToRemove = InventDimParm::andParms(trackingDimsToRemove, _selectedTrackingDimsToRemove);
        }

        le = trackingDimsToRemove.selectedDimFields().getEnumerator();

        while (le.moveNext())
        {
            fieldName = fieldId2name(tableNum(InventDim), le.current());

            pass.remove(fieldName);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitWorkLineForGroupPick</Name>
				<Source><![CDATA[
    private WHSWorkLine getSplitWorkLineForGroupPick(
        WHSWorkId   _workId,
        LineNum     _lineNum,
        Qty         _pickQty)
    {
        WHSWorkLine groupWorkLine;
        WHSWorkLine splitWorkLine;
        Qty         runningQty = _pickQty;

        while select RecId, InventQtyRemain, LineNum from groupWorkLine
            order by LineNum
            where groupWorkLine.WorkId == _workId
                && groupWorkLine.LineNum >= _lineNum
        {
            if (groupWorkLine.InventQtyRemain < runningQty)
            {
                runningQty -= groupWorkLine.InventQtyRemain;
            }
            else if (groupWorkLine.InventQtyRemain == runningQty)
            {
                select firstonly splitWorkLine
                    order by LineNum
                    where splitWorkLine.WorkId == _workId
                        && splitWorkLine.LineNum > groupWorkLine.LineNum;

                pass.insert(#FullQty, 0);
                break;
            }
            else
            {
                splitWorkLine = WHSWorkLine::findByRecId(groupWorkLine.RecId);
                pass.insert(#FullQty, runningQty);
                break;
            }
        }

        return splitWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetButtonClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets clicked buttons in the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before buttons are reset.
    /// </param>
    /// <returns>
    /// Container containing the form state after buttons are reset.
    /// </returns>
    container resetButtonClicked(container _con)
    {
        container   con = _con;
        str         controlType;
        int         length;
        int         i;

        length = conLen(con);

        for (i = 1; i <= length; ++i)
        {
            controlType = conPeek(conPeek(con, i), #controlType);

            if (controlType == #RFButton)
            {
                con = conPoke(con, i, conPoke(conPeek(con, i), #data, ''));
            }
        }

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetPassthrough</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets pass through map stored in the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the pass through is reset.
    /// </param>
    /// <param name="_useOld">
    /// Determines whether the old pass through map should be used during reset.
    /// </param>
    /// <returns>
    /// Container containing the form state after the pass through is reset.
    /// </returns>
    WHSRFPassthrough resetPassthrough(container _con, boolean _useOld = true)
    {
        WHSRFPassthrough    ret;

        if (_useOld)
        {
            return WHSRFPassthrough::create(conPeek(_con, 2));
        }

        ret = WHSRFPassthrough::newReset(pass);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGlobals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets values to fields to be used in other methods.
    /// </summary>
    /// <param name="_mode">
    /// The work execution mode.
    /// </param>
    /// <param name="_step">
    /// The step number.
    /// </param>
    /// <param name="_userId">
    /// The work user id.
    /// </param>
    /// <param name="_pass">
    /// The pass through map.
    /// </param>
    /// <param name="_workLine">
    /// The work line.
    /// </param>
    public void setGlobals(WHSWorkExecuteMode  _mode,
                    int                 _step,
                    WHSUserId           _userId,
                    WHSRFPassthrough    _pass,
                    WHSWorkLine         _workLine = null)
    {
        mode        = _mode;
        step        = _step;
        userId      = _userId;
        pass        = _pass;

        if (_workLine)
        {
            workLine = _workLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPreventStackOverflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if stack overflow prevention is active for this instance.
    /// </summary>
    /// <returns>true when active; otherwise, false.</returns>
    protected boolean mustPreventStackOverflow()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModeStepPass</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Updates the mode and step based on the values from the pass.
    /// </summary>
    /// <param name = "_con">A container representing the UI.</param>
    /// <param name = "_mode">The <c>WHSWorkExecuteMode</c> mode.</param>
    /// <param name = "_step">The step.</param>
    /// <param name = "_pass">The pass object.</param>
    /// <returns>The updated container</returns>
    public container updateModeStepPass(container _con, WHSWorkExecuteMode _mode, int _step, WHSRFPassthrough _pass = null)
    {
        container           ret = _con;
        WHSRFPassthrough    tmpPass = _pass;

        if (conLen(conPeek(_con, 1)) != 2)
        {
            if (tmpPass != null)
            {
                ret = conIns(ret, 1, tmpPass.pack());
            }
            else
            {
                ret = conIns(ret, 1, conNull());
            }
            ret = conIns(ret, 1, [_mode, _step]);
        }
        else
        {
            if (tmpPass != null)
            {
                ret = conPoke(ret, 2, tmpPass.pack());
            }
            else
            {
                ret = conPoke(ret, 2, conNull());
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNonSerialInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that there is enough non-serial inventory to complete the work.
    /// </summary>
    /// <param name="_workLine">
    /// The work to be validated.
    /// </param>
    /// <returns>
    /// True if there is enough non-serial inventory; otherwise false.
    /// </returns>
    public boolean validateNonSerialInventory(WHSWorkLine _workLine)
    {
        boolean                             ret = true;
        InventDim                           inventDim;
        InventDim                           inventDimSelect;
        InventDimParm                       inventDimParm;
        WHSRFWhenToCapture                  whenToCapture;

        if (WHSWorkExecute::skipSerialValidation(_workLine.ItemId))
        {
            return true;
        }

        whenToCapture = WHSInventTable::captureSerial(_workLine.ItemId);

        if (!WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum)
            && (whenToCapture == WHSRFWhenToCapture::Picking
            || whenToCapture  == WHSRFWhenToCapture::Packing)
            && _workLine.whsWorkTable().WorkTransType != WHSWorkTransType::ReturnOrder)
        {
            inventDim = InventDim::find(_workLine.InventDimId);
            inventDim.InventSerialId = '';
            inventDimParm.initFromInventDim(inventDim);

            boolean isCWItem = PdsGlobal::pdsIsCWItem(_workLine.ItemId);

            if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_workLine.ItemId))
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() 
                    && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumUnionDeltaPhysicalQtyWithDim;

                    if (isCWItem)
                    {
                        select sum(PdsCWPhysicalInvent) from inventSumUnionDeltaPhysicalQtyWithDim
                            where #InventDimFieldsFilter(inventSumUnionDeltaPhysicalQtyWithDim, inventDim, inventDimParm) &&
                                  inventSumUnionDeltaPhysicalQtyWithDim.ItemId == _workLine.ItemId &&
                                  inventSumUnionDeltaPhysicalQtyWithDim.InventSerialId == '';

                        if (inventSumUnionDeltaPhysicalQtyWithDim.PdsCWPhysicalInvent < _workLine.InventQtyRemain)
                        {
                            ret = false;
                        }
                    }
                    else
                    {
                        select sum(PhysicalInvent) from inventSumUnionDeltaPhysicalQtyWithDim
                            where #InventDimFieldsFilter(inventSumUnionDeltaPhysicalQtyWithDim, inventDim, inventDimParm) &&
                                  inventSumUnionDeltaPhysicalQtyWithDim.ItemId == _workLine.ItemId &&
                                  inventSumUnionDeltaPhysicalQtyWithDim.InventSerialId == '';

                        if (inventSumUnionDeltaPhysicalQtyWithDim.PhysicalInvent < _workLine.InventQtyRemain)
                        {
                            ret = false;
                        }
                    }
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty inventSumUnionDeltaPhysicalQty;

                    if (isCWItem)
                    {
                        select sum(PdsCWPhysicalInvent) from inventSumUnionDeltaPhysicalQty
                            #InventDimExistsJoin(inventSumUnionDeltaPhysicalQty.InventDimId, inventDimSelect, inventDim, inventDimParm) &&
                        inventSumUnionDeltaPhysicalQty.ItemId == _workLine.ItemId &&
                            inventDimSelect.InventSerialId == '';

                        if (inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent < _workLine.InventQtyRemain)
                        {
                            ret = false;
                        }
                    }
                    else
                    {
                        select sum(PhysicalInvent) from inventSumUnionDeltaPhysicalQty
                            #InventDimExistsJoin(inventSumUnionDeltaPhysicalQty.InventDimId, inventDimSelect, inventDim, inventDimParm) &&
                        inventSumUnionDeltaPhysicalQty.ItemId == _workLine.ItemId &&
                            inventDimSelect.InventSerialId == '';

                        if (inventSumUnionDeltaPhysicalQty.PhysicalInvent < _workLine.InventQtyRemain)
                        {
                            ret = false;
                        }
                    }
                }
            }
            else
            {
                InventSum inventSum;

                if (isCWItem)
                {
                    if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
                    {
                        select sum(PdsCWPhysicalInvent) from inventSum
                            where #InventDimFieldsFilter(inventSum, inventDim, inventDimParm) &&
                            inventSum.ItemId               == _workLine.ItemId  &&
                            inventSum.ClosedQty            == NoYes::No         &&
                            inventSum.InventSerialId       == '';
                    }
                    else
                    {
                        select sum(PdsCWPhysicalInvent) from inventSum
                            #InventDimExistsJoin(inventSum.InventDimId, inventDimSelect, inventDim, inventDimParm) &&
                        inventSum.ItemId               == _workLine.ItemId  &&
                            inventSum.ClosedQty            == NoYes::No         &&
                            inventDimSelect.InventSerialId == '';
                    }

                    if (inventSum.PdsCWPhysicalInvent < _workLine.InventQtyRemain)
                    {
                        ret = false;
                    }
                }
                else
                {
                    if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
                    {
                        select sum(PhysicalInvent) from inventSum
                            where #InventDimFieldsFilter(inventSum, inventDim, inventDimParm) &&
                            inventSum.ItemId               == _workLine.ItemId  &&
                            inventSum.ClosedQty            == NoYes::No         &&
                            inventSum.InventSerialId       == '';
                    }
                    else
                    {
                        select sum(PhysicalInvent) from inventSum
                            #InventDimExistsJoin(inventSum.InventDimId, inventDimSelect, inventDim, inventDimParm) &&
                        inventSum.ItemId               == _workLine.ItemId  &&
                            inventSum.ClosedQty            == NoYes::No         &&
                            inventDimSelect.InventSerialId == '';
                    }

                    if (inventSum.PhysicalInvent < _workLine.InventQtyRemain)
                    {
                        ret = false;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSingleTransactionMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if the framework should handle transactions for the class.
    /// </summary>
    /// <returns>true, if the framework handles transactions; otherwise, false.</returns>
    /// <remarks>
    /// When the framework handles the database transaction then data integrity and member state integrity is guaranteed.
    /// Subclasses can use this method to opt-out, and handle transactions themselves.
    /// They must ensure data integrity, i.e. implement compensation logic, to ensure that data committed by previous transactions is cleaned up when the next transaction fails.
    /// They must ensure member state integrity, i.e. all members are reset correctly, such as mode, step, pass and con when any exception is thrown.
    /// </remarks>
    protected boolean useSingleTransactionMode()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callUseSingleTransactionMode</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final boolean callUseSingleTransactionMode()
    {
        return this.useSingleTransactionMode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDataByKeys</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes data of the 'pass' <c>WHSRFPassthrough</c> by keys.
    /// </summary>
    /// <param name="_keys">
    /// The <c>container</c> that contains key list that need to be removed.
    /// </param>
    protected void removeDataByKeys(container _keys)
    {
        List                list;
        ListEnumerator      me;
        str                 key;
        
        if (_keys != conNull()
            && conLen(_keys) > 0)
        
        {
            list = con2List(_keys);
            me   = list.getEnumerator();
            while (me.moveNext())
            {
                key = me.current();
                if (pass.exists(key))
                {
                    pass.remove(key);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeFromPassOnException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a value from the <c>pass</c> member when handling a potential exception.
    /// </summary>
    /// <param name = "_key">The key to remove from <c>pass</c>.</param>
    protected void removeFromPassOnException(str _key)
    {
        if (!passValuesToRemoveOnException)
        {
            passValuesToRemoveOnException = new Set(Types::String);
        }

        passValuesToRemoveOnException.add(_key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>authenticateSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs authentication of the incoming request.
    /// </summary>
    /// <param name="_con">
    /// Inputs received from the remote client.
    /// </param>
    /// <returns>
    /// Input container which passes the validation process or
    /// empty one if validation fails.
    /// </returns>
    public static container authenticateSession(container _con)
    {
        return WhsWorkUserSessionAuthenticator::authenticateSession(_con);
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreDataByKeys</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restores data of the 'pass' <c>WHSRFPassthrough</c> object from source <c>WHSRFPassthrough</c> object.
    /// </summary>
    /// <param name="_sourceMap">
    /// The source <c>WHSRFPassthrough</c> object that contains data for the keys that need to be updated.
    /// </param>
    /// <param name="_keys">
    /// The <c>container</c> that contains key list that need to be restored.
    /// </param>
    protected void restoreDataByKeys(WHSRFPassthrough _sourceMap, container _keys)
    {
        List                list;
        ListEnumerator      me;
        str                 key;
        
        if (_sourceMap
            && _keys != conNull()
            && conLen(_keys) > 0)
        {
            list = con2List(_keys);
            me   = list.getEnumerator();
            while (me.moveNext())
            {
                key = me.current();
                if (_sourceMap.exists(key))
                {
                    pass.insert(key, _sourceMap.lookup(key));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a WorkExecuteDisplay subclass instance based on the work execution mode.
    /// </summary>
    /// <param name="_mode">
    /// The work execution mode.
    /// </param>
    /// <param name="_menuItemName">
    /// The menu item name; optional.
    /// </param>
    /// <returns>
    /// An instance of a subclass of WorkExecuteDisplay class.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Invalid work execution mode.
    /// </exception>
    static WHSWorkExecuteDisplay construct(
        WHSWorkExecuteMode _mode,
        WHSMenuItemName    _menuItemName = '')
    {
        var attr    = new WhsWorkExecuteModeAttribute(_mode, true);
        var factory = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(WHSWorkExecuteDisplayFactory), attr) as WHSWorkExecuteDisplayFactory;

        WhsWorkExecuteDisplay instance = factory.create(_mode, _menuItemName);

        if (!instance)
        {
            throw error("@WAX1238");
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dictTypeForTableField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the type of a table field.
    /// </summary>
    /// <param name="_tableId">
    ///    The table ID of the field.
    /// </param>
    /// <param name="_fieldId">
    ///    The field ID.
    /// </param>
    /// <returns>
    ///    The type of the field; otherwise, null.
    /// </returns>
    /// <remarks>
    ///    The method will return null for fields that are not based on extended data types,
    ///    for example enums.
    /// </remarks>
    protected static DictType dictTypeForTableField(
        TableId _tableId,
        FieldId _fieldId)
    {
        DictTable   dictTable;
        DictField   dictField;
        DictType    dictType;

        if (   _tableId
            && _fieldId)
        {
            dictTable = new DictTable(_tableId);
            if (dictTable)
            {
                dictField = new DictField(dictTable.id(),_fieldId);
                if (dictField)
                {
                    if (dictField.typeId())
                    {
                        dictType = new DictType(dictField.typeId());
                    }
                }
            }
        }

        return dictType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateWorkUserDisplaySettingsXML</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates RF display settings in xml format.
    /// </summary>
    /// <returns>
    /// XML document containing the RF display settings.
    /// </returns>
    [SysObsolete('Warehouse mobile devices portal is no longer supported. Use the warehouse mobile app instead.', true, 15\04\2021)]
    static XML generateWorkUserDisplaySettingsXML()
    {
        XmlDocument                 xmlDocument = XmlDocument::newBlank();
        XmlNode                     xmlNode;
        XmlNode                     settingsNode;
        XmlNode                     settingNode;
        XmlNode                     nameNode;
        XmlNode                     cssFileNode;
        XmlNode                     criteriaNode;
        XmlNode                     defaultNode;
        XmlNode                     viewNode;
        XmlNode                     hotkeysNode;
        WHSWorkUserDisplaySettings  whsWorkUserDisplaySettings;

        xmlNode = xmlDocument.createElement(#Configurations);
        xmlDocument.appendChild(xmlNode);

        settingsNode = xmlDocument.createElement(#DisplaySettings);
        xmlNode.appendChild(settingsNode);

        while select whsWorkUserDisplaySettings
        {
            settingNode = xmlDocument.createElement(#DisplaySetting);
            settingsNode.appendChild(settingNode);

            nameNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Name));
            nameNode.text(whsWorkUserDisplaySettings.Name);
            settingNode.appendChild(nameNode);

            cssFileNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, css));
            cssFileNode.text(whsWorkUserDisplaySettings.css);
            settingNode.appendChild(cssFileNode);

            criteriaNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Criteria));
            criteriaNode.text(whsWorkUserDisplaySettings.Criteria);
            settingNode.appendChild(criteriaNode);

            defaultNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Default));
            defaultNode.text(int2str(whsWorkUserDisplaySettings.Default));
            settingNode.appendChild(defaultNode);

            viewNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, View));
            viewNode.text(whsWorkUserDisplaySettings.View);
            settingNode.appendChild(viewNode);

            hotkeysNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Hotkeys));
            hotkeysNode.text(whsWorkUserDisplaySettings.Hotkeys);
            settingNode.appendChild(hotkeysNode);
        }

        return xmlDocument.xml();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the next form state from a given state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the given form state.
    /// </param>
    /// <returns>
    /// Container containing the next form state.
    /// </returns>
    public static container getNextForm(container _con)
    {
        return conPeek(WHSWorkExecuteDisplay::getNextFormState(_con, WHSServiceXMLTranslator::constructFromXML('')), 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextFormHandHeld</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the next form state XML based on the given form state.
    /// </summary>
    /// <param name="_xml">
    /// The current form state as XML.
    /// </param>
    /// <returns>
    /// The next form state as XML.
    /// </returns>
    [SysObsolete('Warehouse mobile devices portal is no longer supported. Use the warehouse mobile app instead.', true, 15\04\2021)]
    public static str getNextFormHandHeld(str _xml)
    {
        container con = WHSWorkExecuteDisplay::readXML(_xml);
        return WHSWorkExecuteDisplay::getNextFormXML(con, WHSMobileDeviceServiceXMLTranslator::construct());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextFormMobileApp</Name>
				<Source><![CDATA[
    public static str getNextFormMobileApp(str _xml)
    {
        container con = WHSWorkExecuteDisplay::readXML(_xml);
        var translator = WHSMobileAppServiceXMLTranslator::construct();
        translator.parmReceivedContainer(con);
        return WHSWorkExecuteDisplay::getNextFormXML(con, translator);
    }

]]></Source>
			</Method>
			<Method>
				<Name>callCleanupWorkOnCancelOrLogout</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final void callCleanupWorkOnCancelOrLogout(WHSWorkId _workId)
    {
        this.cleanupWorkOnCancelOrLogout(_workId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupWorkOnCancelOrLogout</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up work when the user has cancelled or logged out.
    /// </summary>
    /// <param name = "_workId">The work id.</param>
    protected void cleanupWorkOnCancelOrLogout(WHSWorkId _workId)
    {
        ttsbegin;

        boolean mustCleanupCluster;
        boolean isClusterCreationComplete;
        WHSClusterId clusterId;

        
        mustCleanupCluster = this.mustCleanupWorkCluster(pass);

        if (mustCleanupCluster)
        {
            clusterId = pass.lookup(#ClusterId);
            // Method unlockWorkOnCancelOrLogOut can modify TargetLP of work, so the system should evaluate
            // if all the work related to cluster have target license plate the before any modifications on targetLicensePlate
            isClusterCreationComplete = WHSWorkClusterTable::allNonCancelledWorkHeadersHaveTargetLPSetForCluster(clusterId);
        }
        
                                
        boolean mustPassCluster = this.mustPassCluster(true, mustCleanupCluster, isClusterCreationComplete, clusterId);
        
        if (!mustPassCluster)
        {
            WHSWorkTable::unlockWorkOnCancelOrLogOut(_workId);
        }        

        // If in a work group need unlock all work
        if (pass.hasValue(#WorkGroupingId))
        {
            WHSWorkGrouping workGrouping;

            while select WorkId from workGrouping
                where workGrouping.WorkGroupingId == pass.lookup(#WorkGroupingId)
            {
                WHSWorkTable::unlockWorkOnCancelOrLogOut(workGrouping.WorkId);
                WHSWorkTable::unskipPutLines(workGrouping.WorkId);
            }

            if ((mode == WHSWorkExecuteMode::SystemGrouping    ||
                 mode == WHSWorkExecuteMode::UserGrouping))
            {
                WHSWorkGrouping::cleanupWorkGrouping(pass.lookup(#WorkGroupingId));
            }
        }
        else
        {
            WHSWorkTable::unskipPutLines(_workId);
        }

        if (this.canPassCluster(pass))
        {
            if (mustPassCluster)
            {
                WHSPassCluster::passCluster(clusterId);
            }
            else if (mustCleanupCluster)
            {
                // Cleanup cluster if user cancels during creation
                WHSWorkClusterTable::cleanupCluster(pass.lookup(#ClusterId));
            }
        }
               
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPassCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work cluster could be passed.
    /// </summary>
    /// <param name="_pass">
    /// The <c>WHSRFPassthrough</c> instance.
    /// </param>
    /// <returns>
    /// false if the work cluster has partially recieved work line; otherwise, true.
    /// </returns>
    protected boolean canPassCluster(WHSRFPassthrough _pass)
    {
        if (!_pass.exists(#ClusterId) || mode != WHSWorkExecuteMode::SystemDirectedClusterPicking)
        {
            return true;
        }

        WHSWorkClusterLine workClusterLine;
        WHSWorkTable       workTableLocal;
        WHSWorkLine        workLineLocal;
        WHSWorkTrans       workTrans;
        WHSClusterId       clusterId = _pass.lookup(#ClusterId);
        UserId             userIdLocal = pass.lookup(#UserId);

        select firstonly RecId from workClusterLine
        where workClusterLine.ClusterId == clusterId
        exists join workTableLocal
            where  workTableLocal.WorkId     == workClusterLine.WorkId
            && workTableLocal.WorkStatus != WHSWorkStatus::Cancelled
        exists join workLineLocal
            where  workLineLocal.WorkId == workTableLocal.WorkId
            && (workLineLocal.QtyRemain != 0
            && workLineLocal.QtyRemain != workLineLocal.QtyWork)
        exists join workTrans
            where workTrans.WorkId == workTableLocal.WorkId
            && workTrans.LineNum == workLineLocal.LineNum
            && workTrans.UserId == userIdLocal;

        if (workClusterLine.RecId)
        {
            return false;
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPassCluster</Name>
				<Source><![CDATA[
    private boolean mustPassCluster(       
        boolean _skipDeleteClusterForSystemDirectedIfWorksHaveTargetLPSetFlightEnabled,
        boolean _mustCleanupCluster,
        boolean _isClusterCreationComplete,
        WHSClusterId _clusterId)
    {
        return _skipDeleteClusterForSystemDirectedIfWorksHaveTargetLPSetFlightEnabled
            && _mustCleanupCluster
            && _isClusterCreationComplete
            && mode == WHSWorkExecuteMode::SystemDirectedClusterPicking
            && WHSWorkClusterTable::isClusterTypePicking(_clusterId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextFormState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the next form state based on the given form state.
    /// </summary>
    /// <param name="_con">
    /// A container with the current form state.
    /// </param>
    /// <param name="_xmlTranslator">
    /// A <c>WHSServiceXMLTranslator</c> object used for serialization/deserialization.
    /// </param>
    /// <returns>
    /// A container with a form state container as the first element
    /// and an XML representation of the form state, if it was created,
    /// as the second element.
    /// </returns>
    [Hookable(false)]
    internal static container getNextFormState(container _con, WHSServiceXMLTranslator _xmlTranslator = WHSMobileDeviceServiceXMLTranslator::construct())
    {
        WhsWorkExecuteDisplayProcessor processor = WhsWorkExecuteDisplayProcessor::construct();
        
        processor.parmXmlTranslator(_xmlTranslator);
        processor.parmInitialContainer(_con);

        using (var cache = WHSWorkUserSessionStateCache::construct())
        {
            str xmlState;
            container fromContainer;

            [fromContainer, xmlState] = processor.buildNextFormState();

            if (WHSBarcodeDataParserFactory::isBarcodeDataParsingEnabled()
                && WHSRFPassthrough::create(conPeek(fromContainer, #PassthroughInfo)).exists(WHSBarcodeControlConstants::BarcodeUsedScannedValues))
            {
                return WhsWorkExecuteDisplay::getNextFormStateUsingGS1(processor, fromContainer, xmlState);
            }
        
            return [fromContainer, xmlState];            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextFormStateUsingGS1</Name>
				<Source><![CDATA[
    internal static container getNextFormStateUsingGS1(WhsWorkExecuteDisplayProcessor _processor, container _fromContainer, str _xmlState)
    {
        const int AutoSubmitIterationMax = 1000;
        int autoSubmitCounter = 0;
        WHSInstrumentationLogger instrumentationLogger = WHSInstrumentationLogger::createLogger(classStr(WhsWorkExecuteDisplay));
        using (var gs1ParallelPopulationActivityContext = instrumentationLogger.gs1ParallelPopulation().populateGS1ScannedValues())
        {
            boolean anyControlDefaulted;
            WHSBarcodeControlPopulator gs1ControlPopulator = WHSBarcodeControlPopulator::construct(_fromContainer);
            do
            {
                anyControlDefaulted = gs1ControlPopulator.populateControls();
                _fromContainer = gs1ControlPopulator.parmFromContainer();

                if (!anyControlDefaulted || !gs1ControlPopulator.parmAutoSubmit())
                {
                    if (gs1ControlPopulator.parmAutoSubmit())
                    {
                        var xmlTranslator = _processor.parmXmlTranslator();
                        if (xmlTranslator is WHSMobileAppServiceXMLTranslator)
                        {
                            var translator = xmlTranslator as WHSMobileAppServiceXMLTranslator;
                            translator.parmReceivedContainer(_fromContainer);
                            _processor.parmXmlTranslator(translator);
                        }
                    }
                    [_fromContainer, _xmlState] = _processor.createXmlStateAndUpdateSession(_fromContainer);

                    instrumentationLogger.gs1ParallelPopulation().autoSubmitCounter(gs1ParallelPopulationActivityContext, autoSubmitCounter);
                    break;
                }
                _processor.parmInitialContainer(_fromContainer);
                [_fromContainer, _xmlState] = _processor.buildNextFormState();
                gs1ControlPopulator.initFromContainer(_fromContainer);

                if (autoSubmitCounter >= AutoSubmitIterationMax)
                {
                    instrumentationLogger.logError('There were more than 1000 iterations.');
                    throw error("@WAX:WarehouseOperationInternalErrorType_InfiniteLoop");
                }
                autoSubmitCounter++;
            }
            while (anyControlDefaulted);
        }
        return [_fromContainer, _xmlState];
    }

]]></Source>
			</Method>
			<Method>
				<Name>callUpdateCatchWeightTagsOnCancel</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void callUpdateCatchWeightTagsOnCancel()
    {
        this.updateCatchWeightTagsOnCancel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCatchWeightTagsOnCancel</Name>
				<Source><![CDATA[
    protected void updateCatchWeightTagsOnCancel()
    {
        container cwTagCreatedList = str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList));

        ttsbegin;

        for (int counter = 1; counter <= conLen(cwTagCreatedList); counter++)
        {
            WHSCatchWeightTag catchWeightTag = WHSCatchWeightTag::findByRecId(conPeek(cwTagCreatedList, counter));

            if (!catchWeightTag.IsDeleted)
            {
                WHSCatchWeightTagLastRegistration cwTagLastRegistration = WHSCatchWeightTagLastRegistration::find(catchWeightTag.TagNumber);
                WHSCatchWeightTagEventRegistration eventRegistration;

                switch (cwTagLastRegistration.RegistrationEvent)
                {
                    case WHSCatchWeightTagRegistrationEvent::TagRegistered :
                        
                        if (mode == WHSWorkExecuteMode::ReturnOrder || mode == WHSWorkExecuteMode::ReturnOrderAndLocate)
                        {
                            WHSCatchWeightTagEventRegistration::removeTagLastRegistrationEvent(catchWeightTag.TagNumber);
                        }
                        else
                        {
                            WHSCatchWeightTag::deleteByTagNumber(catchWeightTag.TagNumber);
                        }
                        break;

                    case WHSCatchWeightTagRegistrationEvent::OutboundPickingStarted :
                        eventRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(WHSCatchWeightTagRegistrationEvent::OutboundPickingCancelled);
                        eventRegistration.registerEvent(catchWeightTag);
                        break;

                    case WHSCatchWeightTagRegistrationEvent::PickingStarted :
                        eventRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(WHSCatchWeightTagRegistrationEvent::PickingCancelled);
                        eventRegistration.registerEvent(catchWeightTag);
                        break;
                }
            }
        }

        ttscommit;

        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCapturedWeightOnCancel</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final void removeCapturedWeightOnCancel()
    {
        ttsbegin;

        WHSASNItem asnItem = WHSASNItem::findByRecId(pass.parmASNItemRecId(), true);

        asnItem.CapturedWeight = 0;
        asnItem.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>backClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles back button click.
    /// </summary>
    protected void backClicked()
    {
        mode = WHSWorkExecuteMode::Menu;
        step = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callBackClicked</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void callBackClicked()
    {
        this.backClicked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>callCancelClicked</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void callCancelClicked()
    {
        this.cancelClicked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGoToMenuWhenCancelling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a click on cancel opens the menu.
    /// </summary>
    /// <returns>true if cancelling must open the main menu; otherwise, false.</returns>
    protected boolean mustGoToMenuWhenCancelling()
    {
        return step == 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles cancel button click.
    /// </summary>
    protected void cancelClicked()
    {
        WHSMenuItemName menuItemName = pass.lookupStr(#MenuItem);
        WHSRFMenuItemTable menuItem = WHSRFMenuItemTable::find(menuItemName);

        if (this.mustGoToMenuWhenCancelling() ||
            menuItem.MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected ||
            mode == WHSWorkExecuteMode::CycleCountingReview ||
            (step == 3 && WHSWorkExecutionMode::newFromMode(mode).isInboundOrderLineReceiving() && !WHSWorkExecutionMode::newFromMode(mode).isInboundOrderReceivingAndPutaway()) ||
            (step == 2 && (mode == WHSWorkExecuteMode::MovementLicensePlate) || (mode == WHSWorkExecuteMode::QuarantineLicensePlate)) )
        {
            mode = WHSWorkExecuteMode::Menu;
            step = 0;
        }
        else if (!menuItem.ConfirmCancel)
        {
            step = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCleanupWorkCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work cluster must be cleaned.
    /// </summary>
    /// <param name="_pass">
    /// The <c>WHSRFPassthrough</c> instance.
    /// </param>
    /// <returns>
    /// true if the work cluster must be cleaned; otherwise, false.
    /// </returns>
    protected boolean mustCleanupWorkCluster(WHSRFPassthrough _pass)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeErrorMessage</Name>
				<Source><![CDATA[
    private static container includeErrorMessage(container _con, int _infologLinesStart, WHSWorkExecuteDisplay _workExecuteDisplay)
    {
        if (conLen(_con) >= #FieldControlStartLoc)
        {
            if (_workExecuteDisplay.hasError(_con))
            {
                _con = conDel(_con, #RFErrorLoc, 1);
            }
            container errorCon;
            [errorCon] = _workExecuteDisplay.addErrorLabelFromInfolog(conNull(), _infologlinesStart, WHSRFColorText::Error);
            _con = conIns(_con, #RFErrorLoc, errorCon);
        }
        return _con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkIsEligibleForDirectedFlows</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that he workTable instance variable is eligible for use in any directed mobile device flows.
    /// </summary>
    protected void validateWorkIsEligibleForDirectedFlows()
    {
        if (!workTable)
        {
            throw error("@WAX1081");
        }
        
        if (workTable.InventLocationId != pass.lookup(#InventLocationId))
        {
            throw error("@WAX1239");
        }

        if (!WHSWorkTable::validateWorkInCluster(workTable.WorkId))
        {
            throw error("@WAX3828");
        }

        if (this.shouldHandleByLP() 
            && WHSWorkTable::hasPickLinesWithoutLocatedLP(workTable.WorkId))
        {
            throw error(strFmt("@SYP5070018", workTable.WorkId));
        }

        // Perform checks that are unique for the transport loading directed flow
        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).MenuItemDirectedBy == WHSMenuItemDirectedBy::TransportLoading)
        {
            workTable.validateWorkIsEligibleForTransportLoading(WHSTransportLoad::findByTransportLoadId(pass.lookupStr(WHSWorkExecuteDisplayTransportLoadingControls::TransportLoadId)).RecId);
        }
        else if (!workTable.shouldSkipLoadingStrategyValidation() && !workTable.validateWorkCanBeLoadedWithoutTransportLoad())
        {
            throw error("@WAX:WorkWithoutTransportLoadError");
        }
        
        if (!this.canCompleteWorkWithMultipleLocatedLPs())
        {
            throw error(strFmt("@WAX:WorkWithoutDifferentLocatedLPError", workTable.WorkId));
        }
        
        this.validateWorkIsNotBlocked(workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkIsNotBlocked</Name>
				<Source><![CDATA[
    private void validateWorkIsNotBlocked(WHSWorkTable _workTable)
    {
        if (_workTable.Frozen)
        {
            WHSWorkTable::throwWorkFrozenError(_workTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCompleteWorkWithMultipleLocatedLPs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check that the work can be completed in case if exists multiple located LPs.
    /// </summary>
    /// <returns>True if the work can be completed; otherwise, false.</returns>
    private boolean canCompleteWorkWithMultipleLocatedLPs()
    {
        return workTable.WorkTransType != WHSWorkTransType::TransferIssue ||           
            !this.shouldHandleByLP() ||
            !WHSWorkTable::hasPickLinesWithDifferentLocatedLP(workTable.WorkId) ||
            !WHSWorkTable::hasTransferOrderInventLocationToWHSEnabled(workTable.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextFormXML</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the next form state XML based on the given form state.
    /// </summary>
    /// <param name="_con">
    /// A container with the current form state.
    /// </param>
    /// <param name="_xmlTranslator">
    /// A <c>WHSServiceXMLTranslator</c> object used for serialization/deserialization.
    /// </param>
    /// <returns>
    /// A form state as XML.
    /// </returns>
    public static str getNextFormXML(container _con, WHSServiceXMLTranslator _xmlTranslator = WHSMobileDeviceServiceXMLTranslator::construct())
    {
        container   nextFormStateCon;
        str         ret;

        nextFormStateCon = WHSWorkExecuteDisplay::getNextFormState(_con, _xmlTranslator);

        // if the form state is returned as XML then use it, otherwise create it.
        if (conLen(nextFormStateCon) > 1 && conPeek(nextFormStateCon, 2) != '')
        {
            ret = conPeek(nextFormStateCon, 2);
        }
        else
        {
            ret = _xmlTranslator.createXML(conPeek(nextFormStateCon, 1));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>num2StrDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to convert real number value into a string version to be used during RF processing.
    /// </summary>
    /// <param name="_num">
    /// The real number value that will be converted into a string.
    /// </param>
    /// <returns>
    /// A string representing the passed in real number value.
    /// </returns>
    public static str num2StrDisplay(real _num)
    {
        System.Globalization.CultureInfo culture;
        str                              result;

        culture = System.Globalization.CultureInfo::CreateSpecificCulture(infolog.language());
        result  = System.Convert::ToString(_num, culture);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>value2StrDisplay</Name>
				<Source><![CDATA[
    internal static str value2StrDisplay(anytype _value, InventSiteId _siteId, str _userId)
    {
        switch (typeOf(_value))
        {
            case Types::Enum:
                return enum2Str(_value);
            
            case Types::UtcDateTime:
                return WhsrfControlData::convertDateTime2DateTimeFormatStrCurrentUserDateCulture(
                            DateTimeUtil::applyTimeZoneOffset(_value, InventSite::timeZoneSite(_siteId)),
                            _userId);

            case Types::Integer:
            case Types::Int64:
            case Types::Real:
                return WHSWorkExecuteDisplay::num2StrDisplay(_value);

            default:
                return _value;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareControlData</Name>
				<Source><![CDATA[
    public static str prepareControlData(anytype _data)
    {
        str result = _data;

        switch (typeOf(_data))
        {
            case Types::Integer:
            case Types::Int64:
            case Types::Real:
                result = WHSWorkExecuteDisplay::num2StrDisplay(_data);
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>readXML</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses given XML document into the internal
    /// data container format.
    /// </summary>
    /// <param name="_xmlString">
    /// XML to parse.
    /// </param>
    /// <returns>
    /// If not any exception was thrown a data container with current state information;
    /// otherwise an empty container.
    /// </returns>
    public static container readXML(XML _xmlString)
    {
        container con;

        try
        {
            con = WHSServiceXMLTranslator::constructFromXML(_xmlString).readXMLDoThrow(_xmlString);
        }
        catch (Exception::DuplicateKeyException)
        {
            throw Exception::DuplicateKeyException;
        }
        catch (Exception::UpdateConflict)
        {
            throw Exception::UpdateConflict;
        }
        catch
        {
            // if XML is not valid return empty container this will redirect user to the login screen.
            con = conNull();
        }

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>str2numDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to convert string values representing numbers into real values.
    /// </summary>
    /// <param name="_str">
    /// The string representing a number that will be converted.
    /// </param>
    /// <returns>
    /// A real number value converted from the passed in string.
    /// </returns>
    /// <remarks>
    /// The empty string will be converted to 0.0.
    ///</remarks>
    public static real str2numDisplay(str _str)
    {
        real ret;

        if (_str && !System.Decimal::TryParse(
                _str,
                System.Globalization.NumberStyles::Number,
                System.Globalization.CultureInfo::CreateSpecificCulture(infolog.language()),
                byRef ret))
        {
            throw error(strfmt("@WAX:WAX_Message_Error_CannotConvertValueToType", _str, typeOf(ret)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>str2numDisplayOK</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to validate string values representing real numbers
    /// </summary>
    /// <param name="_str">
    /// The string representing a number that will be validated.
    /// </param>
    /// <returns>
    /// true if the passed string represents a real number according to Worker regional settings; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The empty string is considered as a correct real number (0.0)
    ///</remarks>
    internal static boolean str2numDisplayOK(str _str)
    {
        real dummyReal;

        if (_str && !System.Decimal::TryParse(
                _str,
                System.Globalization.NumberStyles::Number,
                System.Globalization.CultureInfo::CreateSpecificCulture(infolog.language()), 
                byref dummyReal))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkUserSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates data in the given user session
    /// or creates new one if session doesn't exist.
    /// </summary>
    /// <param name="_userId">
    /// Identifier of the user.
    /// </param>
    /// <param name="_con">
    /// Data container.
    /// </param>
    /// <param name="_inventLocationId">
    /// Inventory location value to be set on the session.
    /// </param>
    /// <param name="_xml">
    /// form state XML.
    /// </param>
    /// <param name="_languageId">
    /// The language ID of the user session.
    /// </param>
    /// <param name="_xmlTranslator">
    /// The translator of the xml.
    /// </param>
    /// <returns>
    /// Session that has been updated or created.
    /// </returns>
    protected static WHSWorkUserSession updateWorkUserSession(
                                                        WHSUserId           _userId,
                                                        container           _con,
                                                        InventLocationId    _inventLocationId = '',
                                                        str                 _xml = '',
                                                        LanguageId          _languageId = infolog.language(),
                                                        WHSServiceXMLTranslator _xmlTranslator = WHSMobileDeviceServiceXMLTranslator::construct())
    {
        container stateData = conPeek(_con, #StateInfo);
        WHSWorkUserSessionStateCheck sessionStateCheck = WHSWorkUserSessionStateCheckBuilder::buildFromContainerWithVersionNumber(_con);

        if (_xml == '')
        {
            _xml = _xmlTranslator.createXML(_con);
        }

        return WHSWorkUserSession::createOrUpdate(_userId,
                                                    conPeek(stateData, #StateInfoMode),
                                                    conPeek(stateData, #StateInfoStep),
                                                    conPeek(_con, #PassThroughInfo),
                                                    _languageId,
                                                    _xml,
                                                    sessionStateCheck,
                                                    _inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>callUpdateWorkUserSession</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWorkUserSession callUpdateWorkUserSession(
                                                        WHSUserId           _userId,
                                                        container           _con,
                                                        InventLocationId    _inventLocationId,
                                                        str                 _xml,
                                                        LanguageId          _languageId,
                                                        WHSServiceXMLTranslator _xmlTranslator)

    {
        return WhsWorkExecuteDisplay::updateWorkUserSession(_userId, _con, _inventLocationId, _xml, _languageId, _xmlTranslator);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLocationConfirmationControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the container with the Location Confirmation control.
    /// </summary>
    /// <param name="_whsWorkType">
    /// The current work type
    /// </param>
    /// <param name="_wmsLocation">
    /// The current WMS Location
    /// </param>
    /// <returns>
    /// The container with the data of the control that was built.
    /// </returns>
    protected container addLocationConfirmationControl(WHSWorkType _whsWorkType, WMSLocation _wmsLocation)
    {
        container           ret;

        if (pass.exists(#MenuItem))
        {
            if (WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), _whsWorkType)
                && !pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation))
            {
                if (_wmsLocation.CheckText)
                {
                    ret = [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, pass.lookupStr(#CheckDigit), extendedTypeNum(WMSCheckText), '', 0)];
                }
                else if (pass.exists(#SystemPopulated))
                {
                    ret = [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, pass.lookupStr(#LocVerification), extendedTypeNum(WMSLocationId), '', 0)];
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisplayProductConfirmation</Name>
				<Source><![CDATA[
    internal boolean shouldDisplayProductConfirmation(WHSWorkType _whsWorkType)
    {
        return WHSRFAutoConfirm::isProductConfirmationEnabled(pass.lookup(#MenuItem), _whsWorkType)
                && !pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProductConfirmationControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the container with the Product Confirmation control if the setup requires to have it displayed in the RF.
    /// </summary>
    /// <param name="_whsWorkType">
    /// The current work type.
    /// </param>
    ///<param name="_qty">
    /// The quantity; optional.
    /// </param>
    ///<param name="_itemId">
    /// The item ID; optional.
    /// </param>
    /// <returns>
    /// The container with the data of the control that was built.
    /// </returns>
    protected container addProductConfirmationControl(
        WHSWorkType _whsWorkType,
        Qty         _qty = workLine.InventQtyRemain,
        ItemId      _itemId = workLine.ItemId)
    {
        container   ret;
        
        if (pass.exists(#MenuItem))
        {
            if (this.canAddPieceByPieceConfirmationControl(_whsWorkType, _itemId))
            {
                ret = this.addPieceByPieceConfirmationControl(_whsWorkType, _qty, _itemId);
            }
            else if (this.shouldDisplayProductConfirmation(_whsWorkType))
            {
                if (this.mustPopulateProductConfirmationValue())
                {
                    ret = [this.buildControl(#RFText, #ProductConfirmation, "@SYS14428", 1, pass.lookup(#ProductConfirmation), extendedTypeNum(InventInventItemSearchItem), '', 0)];
                }
                else
                {
                    ret = [this.buildControl(#RFText, #ProductConfirmation, "@SYS14428", 1, '', extendedTypeNum(InventInventItemSearchItem), '', 0)];
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPopulateProductConfirmationValue</Name>
				<Source><![CDATA[
    internal boolean mustPopulateProductConfirmationValue()
    {
        return pass.exists(#ProductConfirmation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddPieceByPieceConfirmationControl</Name>
				<Source><![CDATA[
    private boolean canAddPieceByPieceConfirmationControl(
        WHSWorkType _whsWorkType,
        ItemId      _itemId)
    {
        if (!this.canUsePieceByPieceConfirmation(pass.lookup(#MenuItem), _whsWorkType, _itemId)
            || PdsGlobal::pdsIsCWItem(_itemId))
        {
            return false;
        }

        switch (_whsWorkType)
        {
            case WHSWorkType::Count:
                return true;

            case WHSWorkType::Pick:
                // Only work type pick is associated with over picking and
                if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
                    && !WHSWorkExecute::isPotentialOverPick(workTable, workLine))
                {
                    InventTable inventTable = InventTable::find(_itemId);

                    // item tracking group active serial no and sales process
                    if (!inventTable.isItemSerialNumberActivated()
                     && !inventTable.isSalesProcessSerialActive())
                    {
                        return true;
                    }
                }

                return false;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityAvailableWithAllDimensionValuesKnown</Name>
				<Source><![CDATA[
    protected container quantityAvailableWithAllDimensionValuesKnown(ItemId _itemId)
    {
        boolean allKnown = true;
        
        if (!_itemId)
        {
            return [allKnown, 0];
        }

        InventDim inventDim = pass.createInventDimFromPass();
        InventDim workLineInventDim = workLine.inventDim();
        workLineInventDim.clearLocationAndBelowDim(_itemId);            
        inventDim.mergeUsedDim(InventDimGroupSetup::newItemId(workLine.ItemId), workLineInventDim);
        inventDim = InventDim::findOrCreate(inventDim);

        InventTable inventTable = InventTable::find(_itemId);
        boolean     checkQty;

        // Get List
        WHSReservationHierarchyProvider reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
        ListEnumerator enumerator = reservationHierarchyProvider.getDimListBelowLicensePlate(
                            inventTable,
                            WHSReservationHierarchySortOrder::TopDown)
                        .getEnumerator();

        while (enumerator.moveNext())
        {
            WHSReservationHierarchyElementData elementData = enumerator.current();
            FieldId fieldId = elementData.parmDimensionFieldId();
            FieldName fieldName = fieldId2name(inventDim.TableId, fieldId);
            checkQty = true;

            if (pass.hasValue(fieldName))
            {
                inventDim.(fieldId) = pass.lookup(fieldName);
                continue;
            }
            else
            {
                InventDim tmpInventDim;
                boolean   unknownDimension;

                [tmpInventDim, unknownDimension] = this.getDefaultDimValue(inventDim, fieldId, _itemId);

                if (!unknownDimension)
                {
                    inventDim.(fieldId) = tmpInventDim.(fieldId);
                    continue;
                }
                else
                {
                    allKnown = false;
                    checkQty = false;
                    break;
                }
            }
        }

        InventQty availableQty;

        if (checkQty)
        {
            List reservationHiearchyListAllFields = WHSreservationHierarchyProvider::construct().getDimListAllFromInventTable(
                                                                inventTable,
                                                                WHSReservationHierarchySortOrder::BottomUp);

            WHSReservationHierarchyLevel deepestLevel = WHSReservationHierarchyInventDimUtil::deepestLevelFromInventDimParm(reservationHiearchyListAllFields, inventDim.toDimParm());

            boolean includeDeltaRecords = InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId);

            availableQty = WHSInventOnHand::getAvailPhysicalHandlingQuantityForLevel(_itemId,
                                                                                     inventDim,
                                                                                     deepestLevel,
                                                                                     includeDeltaRecords);
        }

        return [allKnown, availableQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPieceByPieceConfirmationControl</Name>
				<Source><![CDATA[
    protected container addPieceByPieceConfirmationControl(
        WHSWorkType _workType,
        Qty         _qty,
        ItemId      _itemId)
    {
        container ret;
        boolean   dimensionsKnown;
        InventQty dimensionQtyAvailable;

        [dimensionsKnown, dimensionQtyAvailable] = this.quantityAvailableWithAllDimensionValuesKnown(_itemId);

        if (!dimensionsKnown)
        {
            // Used so we know confirmations fields will be needed
            pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation, 0);
            pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm, _qty);

            return ret;
        }

        if (dimensionQtyAvailable == 0)
        {
            dimensionQtyAvailable = realMax();
        }

        if (!pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm)
        ||  pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm) == 0 // Needed for cycle counting case
        ||  pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm) != min(dimensionQtyAvailable, _qty))
        {
            if (_workType == WHSWorkType::Count)
            {
                pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm, realMax());
            }
            else
            {
                pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm, min(dimensionQtyAvailable, _qty));
            }
        }

        if (!pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed))
        {
            pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed, 0);
        }
            
        boolean enabled = true;
        str labelStr;

        Qty maxPieces = WHSRFAutoConfirm::getMaxPieceConfirmation(pass.lookup(#MenuItem), _workType);
        Qty piecesConfirmed = pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);
        Qty totalPiecesToConfirm = pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm);

        if (piecesConfirmed == totalPiecesToConfirm)
        {
            enabled = false;
        }
        
        if (maxPieces
        &&  piecesConfirmed >= maxPieces)
        {
            labelStr = strFmt("@WAX:PieceByPieceRemainConfirm",
                piecesConfirmed,
                totalPiecesToConfirm,
                totalPiecesToConfirm - piecesConfirmed);
        }
        else
        {
            ret += [this.buildControl(#RFText, #ProductConfirmation, "@SYS14428", 1, enabled ? pass.lookupStr(#ProductConfirmation) : '', extendedTypeNum(InventInventItemSearchItem), '', 0, enabled)];
            
            if (maxPieces == 0)
            {
                maxPieces = totalPiecesToConfirm;
            }

            if (_workType == WHSWorkType::Count)
            {
                if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::LastCycleCount))
                {
                    ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayPieceByPieceControls::LastCycleCount,
                            strFmt("@WAX:LastCountedCycleCountAttempt",
                                   pass.lookup(WHSWorkExecuteDisplayPieceByPieceControls::LastCycleCount),
                                   WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId))),
                            1, '', #WHSRFUndefinedDataType, '', 0)];
                }


                if (pass.hasValue(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer))
                {
                    ret += this.addPieceByPieceCycleCount();
                }
                labelStr = "@SYS105177";
            }
            else
            {
                labelStr = strFmt("@WAX:PieceByPieceConfirmedCount", pass.lookupStr(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed), min(pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm), maxPieces));
            }
        }

        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayPieceByPieceControls::ConfirmedPiecePickingQty, labelStr, 1, '', extendedTypeNum(WHSPieceByPieceConfirmation), '', 0, false)];
        ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0, enabled)];

        if (step == #ShortPick)
        {
            pass.insert(#QtyToPick, pass.lookup(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed));
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPieceByPieceCycleCount</Name>
				<Source><![CDATA[
    protected container addPieceByPieceCycleCount()
    {
        container cycleCountContainer = str2con(pass.lookupStr(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer));
        int       length = conLen(cycleCountContainer);
        str currentCount;
        int i;

        for (i = 1; i < length; i += 2)
        {
            if (currentCount)
            {
                currentCount += ' ';
            }

            // Count UOM:
            currentCount += strFmt('%1 %2: ', conPeek(cycleCountContainer, i + 1), conPeek(cycleCountContainer, i));
        }
               
        return [this.buildControl(#RFLabel, WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer, currentCount, 1, '', #WHSRFUndefinedDataType, '', 0)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildControlExistsInContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a build control was found in display container with a given name.
    /// </summary>
    /// <param name="_displayCon">
    /// The container which holds the controls for user display.
    /// </param>
    /// <param name="_controlName">
    /// The name of the build control that needs to be fetched.
    /// </param>
    /// <returns>
    /// True, if control was found in the build container; otherwise, false.
    /// </returns>
    protected int buildControlExistsInContainer(container _displayCon, str _controlName)
    {
        return this.indexOfBuildControlFromContainer(_displayCon, _controlName) != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickHandleByLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds label controls on the RF screen for pick screen when work should use strategy "Handle by license plate".
    /// </summary>
    /// <param name="_con">
    /// A container holding all the current RF screen information.
    /// </param>
    /// <param name="_wmsLocationId">
    /// The location Id.
    /// </param>
    /// <returns>
    /// The container with the updated RF screen information.
    /// </returns>
    protected container buildPickHandleByLP(container _con, WMSLocationId _wmsLocationId)
    {
        container ret = _con;

        if (_wmsLocationId)
        {
            ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, _wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
            pass.insert(#WMSLocationId, _wmsLocationId);
        }
        else
        {
            ret = this.buildGetLocation(ret);
        }

        WHSLicensePlateId locatedLPId = workLine.LocatedLPId;
		
        if (locatedLPId == '')
        {
            locatedLPId = workLine.findLicensePlateFromWorkInventTrans();
        }

        if (locatedLPId)
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, locatedLPId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
            pass.insert(#LicensePlateId, locatedLPId);
        }
        else
        {
            throw error("@WAX691");
        }

        ret = this.addOkButton(ret);
        ret = this.addCancelButton(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPutHandleByLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds label controls on the RF screen for put screen when work should use strategy "Handle by license plate".
    /// </summary>
    /// <param name="_con">
    /// A container holding all the current RF screen information.
    /// </param>
    /// <param name="_wmsLocationId">
    /// The location Id.
    /// </param>
    /// <returns>
    /// The container with the updated RF screen information.
    /// </returns>
    protected container buildPutHandleByLP(container _con, WMSLocationId _wmsLocationId)
    {
        container ret = _con;

        if (_wmsLocationId)
        {
            ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, _wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
            pass.insert(#WMSLocationId, workLine.wmsLocationId);
        }
        else
        {
            ret = this.buildGetLocation(ret);
        }

        ret = this.addOkButton(ret);
        ret = this.addCancelButton(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildShortPickConf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for short pick confirmation.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildShortPickConf(container  _con,
                             str        _extraText = '')
    {
        container            ret = _con;
        WMSLocation          location;
        WHSLicensePlateId    licensePlateId;
        WHSRFDescription1    description1;
        WHSRFDescription2    description2;
        InventDim            inventDim;
        Qty                  qty;
        Qty                  inventQty;
        UnitOfMeasureSymbol  uom;
        InventHandlingUnitId inventUOM;

        description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        inventDim       = InventDim::find(workLine.InventDimId);
        qty             = workLine.QtyRemain;
        inventQty       = workLine.InventQtyRemain;
        uom             = workLine.UnitId;
        inventUOM       = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);
        licensePlateId  = workTable.TargetLicensePlateId;

        if (workLine.wmsLocationId)
        {
            location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
        }

        ret += [this.buildControl(#RFLabel, #RFShortPick, "@WAX1322", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (licensePlateId)
        {
            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }

        if (pass.lookupStr(#LicensePlateId))
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (workLine.ItemId)
        {
            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(workLine.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        // Build label controls for all dimensions specified above location
        ret = this.buildAboveLocationDimensions(ret, inventDim, workLine.ItemId);

        ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookup(#QtyToPick), extendedTypeNum(Qty), '', 0, false)];
        ret += [this.buildControl(#RFText, #QtyShort, "@WAX1333", 1, pass.lookup(#QtyShort), extendedTypeNum(Qty), '', 0, false)];
        ret = this.buildUOM(ret, '', false, false, false, pass.lookupStr(#SelectedValueUOM), false);

        ret += [this.buildControl(#RFText, #ReasonString, "@SYS86426", 1, pass.exists(#ShortPickReason) ? WHSWorkException::find(pass.lookup(#ShortPickReason), WHSExceptionType::ShortPick).WorkExceptionDesc : '', #WHSRFUndefinedDataType, '', 0, false)];

        if (pass.exists(#ShortPickReason)
            && WHSWorkException::find(pass.lookup(#ShortPickReason), WHSExceptionType::ShortPick).WaveLabelReprint
            && this.waveLabelExists())
        {
            ret += [this.buildControl(#RFCombobox, #VoidWaveLabel, "@WAX:VoidWaveLabel", 1, #RFNo + #ListSeparator + #RFYes, extendedTypeNum(NoYesId), '', 0, true, '', WHSRFColorText::Default)];
            ret += [this.buildControl(#RFCombobox, #PrinterName, "@SYS62708", 1, this.getPrinters(), extendedTypeNum(PrinterName), '', 0, true, '', WHSRFColorText::Default)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>waveLabelExists</Name>
				<Source><![CDATA[
    private boolean waveLabelExists()
    {
        WHSWaveLabel waveLabel;
        WHSWorkTable workTableLocal = WHSWorkTable::find(pass.lookup(#WorkId));

        if (workTableLocal.WorkTransType != WHSWorkTransType::Replenishment)
        {
            select firstonly RecId from waveLabel
                where waveLabel.WorkId == pass.lookup(#WorkId)
                   && waveLabel.WorkLineNum == pass.parmLineNum()
                   && waveLabel.Voided == NoYes::No;
        }
        else
        {
            WHSReplenWorkLink replenWorkLink;

            select firstonly RecId from waveLabel
                where waveLabel.Voided == NoYes::No
                    exists join replenWorkLink
                        where replenWorkLink.DemandWorkId == waveLabel.WorkId
                            && replenWorkLink.DemandLineNum == waveLabel.WorkLineNum
                            && replenWorkLink.ReplenWorkId == pass.lookup(#WorkId)
                            && replenWorkLink.ReplenLineNum == pass.parmLineNum();
        }

        return waveLabel.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrinters</Name>
				<Source><![CDATA[
    private str getPrinters()
    {
        str elements;
        Set printers = SrsReportRunUtil::getActivePrinters();
        
        SetEnumerator se = printers.getEnumerator();

        while(se.moveNext())
        {
            SrsReportPrinterContract printer = se.current();

            if (elements)
            {
                elements += #ListSeparator + printer.parmPrinterName();
            }
            else
            {
                elements = printer.parmPrinterName();
            }

        }

        return elements;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcQtyOverPicking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate on-hand inventory qty and over picking qty from license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// License plated Id.
    /// </param>
    /// <param name="_workLine">
    /// The current work line being executed
    /// </param>
    /// <param name="_inventUOM">
    /// A unit of measure symbol for invent unitId.
    /// </param>
    /// <param name="_wmsLocationId">
    /// A location of warehouse for license plate, option.
    /// </param>
    /// <returns>
    /// A container contains on-hand qty and over picking qty of work line.
    /// </returns>
    private container calcQtyOverPicking(WHSLicensePlateId _licensePlateId, WHSWorkLine _workLine, UnitOfMeasureSymbol _inventUOM, WMSLocationId _wmsLocationId = _workLine.wmsLocationId)
    {
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter;
        InventQty                           inventQtyPick;
        Qty                                 qtyPick;
    
        if (_workLine.ItemId)
        {
            inventQtyPick = WHSInvent::getQtyOnLicensePlate(_licensePlateId, _workLine.ItemId, _workLine.InventDimId, _wmsLocationId);
        }
        else
        {
            inventQtyPick = WhsInvent::getTotalQtyOnLicensePlate(_licensePlateId);
        }

        releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        qtyPick = releasedProductUnitConverter.convert(inventQtyPick,
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUOM),
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_workLine.UnitId),
                                                        NoYes::No,
                                                        _workLine.ItemId,
                                                        _workLine.InventDimId);

        return [qtyPick, inventQtyPick];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReceiptAtWarehouseAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that it is possible to receive goods from the source document line at the provided warehouse.
    /// </summary>
    /// <param name="_sourceDocLine">
    /// Source document line table map that is being received.
    /// </param>
    /// <param name="_receiptWarehouse">
    /// The warehouse the goods are received at.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Receipt at the mobile device user warehouse is not allowed.
    /// </exception>
    protected void checkReceiptAtWarehouseAllowed(WHSReceiptOrderLine _sourceDocLine, InventLocationId _receiptWarehouse)
    {
        InventDim inventDim = _sourceDocLine.inventDim();

        if (inventDim.InventLocationId != _receiptWarehouse
            && !InventSite::allowReceiptAtOtherWarehouse(inventDim.InventLocationId, _receiptWarehouse))
        {
            throw error("@WAX1239");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteControlDataFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the control from the container which holds the controls for user display, by its name.
    /// </summary>
    /// <param name="_displayCon">
    /// The container which holds the controls for user display.
    /// </param>
    /// <param name="_controlName">
    /// The name of the build control that needs to be set.
    /// </param>
    /// <returns>
    /// The new container with the changed data.
    /// </returns>
    protected container deleteControlDataFromContainer(container _displayCon, str _controlName)
    {
        int             controlIndex;
        container       ret = _displayCon;

        while (true)
        {
            controlIndex = this.indexOfBuildControlFromContainer(ret, _controlName);
            if (controlIndex == 0)
            {
                break;
            }
            ret = conDel(ret, controlIndex, 1);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTrackingDimForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the RF form to get user input on the tracking dimensions.
    /// </summary>
    /// <param name="_con">
    /// The incoming container of the caller with the controls.
    /// </param>
    /// <param name="_buttonClicked">
    /// The name of the caller menu item.
    /// </param>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> value which can be used to resolve the product variant or distinct product reference.
    /// </param>
    /// <param name="_inventTransType">
    /// The type of order to display the tracking form for; optional.
    /// </param>
    /// <returns>
    /// The container with the processed output of the tracking display form.
    /// </returns>
    /// <remarks>
    /// The calling class should have a case for <c>TrackingDimDetailsStep</c> to handle
    /// the output from the tracking display form.
    /// </remarks>
    protected container displayTrackingDimForm(
        container           _con,
        str                 _buttonClicked,
        InventDimId         _inventDimId        = pass.createInventDimFromPass().InventDimId,
        InventTransType     _inventTransType    = this.receivingOrderProvider(false)
                                                ? this.receivingOrderProvider().inventTransType()
                                                : InventTransType::Purch) // Some customer extensions don't use #PONum for default InventTransType::Purch
    {
        container   ret = conNull();
        int         indx;
        InventTable inventTable = InventTable::find(pass.lookupStr(#ItemId));

        pass.insert(#DimUOM, pass.lookup(#CurrentUOM));

        //if we need to capture the serial in this flow then we will not default since user needs to be able to specify a qty before the flow is considered done
        if (!this.mustCaptureSerialOnReceiptInCurrentFlow(inventTable.ItemId))
        {
            pass.insert(#DimQty, WHSWorkExecuteDisplay::num2StrDisplay(pass.lookupNum(#CurrentQty)));
        }
        else
        {
            pass.insert(#DimQty, '');
        }

        // The container need not have the dimension qty (which may have older value) if it is already present on pass
        if (pass.lookup(#DimQty) != '')
        {
            indx = this.indexOfBuildControlFromContainer(_con, #DimQty);
            if (indx > 0)
            {
                _con = conDel(_con, indx, 1);
            }
        }
        
        pass.insert(#DimRunningQty, WHSCatchWeightHelper::convertInventQuantity(inventTable.ItemId,
                                                                           pass.lookup(#CurrentUOM),
                                                                           pass.lookupNum(#CurrentQty),
                                                                           _inventDimId));

        // The container need not have the license plate (which may have older value) if it is already present on pass
        if (pass.lookup(#LicensePlateId) != '')
        {
            indx = this.indexOfBuildControlFromContainer(_con, #LicensePlateId);
            if (indx > 0)
            {
                _con = conDel(_con, indx, 1);
            }
        }

        // If Dimension unit of measure has been set on the pass above- no conflicting UOM should be present in the container
        indx = this.indexOfBuildControlFromContainer(_con, #DimUOM);
        if (indx > 0)
        {
            _con = conDel(_con, indx, 1);
        }

        // The container need not have the catch weight (which may have an older value).
        indx = this.indexOfBuildControlFromContainer(_con, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
        if (indx > 0)
        {
            _con = conDel(_con, indx, 1);
        }

        step = #TrackingDimDetailsStep;

        /*
        If we have to capture the serial ID, we have to keep the current tracking dim display and execute the
        #TrackingDimDetailsStep once the ID is set. If the item is also batch enabled, we need to call the logic for generating
        or finding the batches before building the tracking dim display.
        */
        if (pass.exists(#CaptureSerial)
            || pass.exists(#CaptureGTDId))
        {
            if (inventTable.whsBatchActive())
            {
                boolean trackingDimHasBeenSet;
                [trackingDimHasBeenSet, _con] = this.setBatchDetails(_con, _inventTransType);
            }
            ret = conNull();
            ret = this.buildTrackingDimensions(ret, _inventTransType, pass.lookupNum(#CurrentQty));
            return ret;
        }

        ret = this.updateModeStepPass(_con, mode, step, pass);
        ret = this.displayForm(ret, _buttonClicked);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTrackingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build tracking dimension for given transaction type and quantity.
    /// </summary>
    /// <param name = "_trackingDimensions">The container to store RF values.</param>
    /// <param name = "_inventTransType">Type of inventory transaction.</param>
    /// <param name = "_qty">Receiving quantity for tracking dimension.</param>
    /// <returns>The updated RF container variable.</returns>
    [Wrappable(false)]
    protected final container buildTrackingDimensions(
        container           _trackingDimensions,
        InventTransType     _inventTransType,
        Qty                 _qty)
    {
        container ret = _trackingDimensions;
        ItemId    itemId = pass.lookup(#ItemId);

        if (_inventTransType == InventTransType::TransferOrderReceive)
        {
            ret = this.buildTORecTrackingDimensions(ret,
                                                    itemId,
                                                    pass.lookupNum(#DimRunningQty),
                                                    WHSCatchWeightHelper::inventHandlingUnitId(itemId));
        }
        else if (this.isInboundOrderReceiving(_inventTransType))
        {
            ret = this.buildPORecTrackingDimensions(ret, itemId, _qty);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalOrderedQtyForBatchFromPass</Name>
				<Source><![CDATA[
    private Qty getTotalOrderedQtyForBatchFromPass(InventTransType _inventTransType, InventBatchId _batchId)
    {
        Qty ret;

        if (_inventTransType == InventTransType::TransferOrderReceive)
        {
            ret = WHSInventBatchReceiptDetails::getQtyToReceiveForBatchFromTransfer(
                InventTransferLine::find(pass.lookup(#TONum), pass.lookupNum(#TOLineNum)),
                pass.lookup(#ReceiptId),
                pass.lookupNum(#DimQty),
                pass.lookupStr(#DimUOM),
                _batchId);
        }
        else if (this.isInboundOrderReceiving(_inventTransType))
        {
            ret = WHSInventBatchReceiptDetails::getQtyToReceiveForBatchFromInbound(
                this.receivingOrderLine(pass),
                pass.lookup(#ReceiptId),
                pass.lookupNum(#DimQty),
                pass.lookupStr(#DimUOM),
                _batchId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContainerTypeCodeFromCon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the container type code on the last mobile device screen if it exists.
    /// </summary>
    /// <param name="_con">
    /// A container of mobile device fields.
    /// </param>
    /// <returns>
    /// The container type value from the mobile device.
    /// </returns>
    private WHSContainerTypeCode getContainerTypeCodeFromCon(container  _con)
    {
        container   con = _con;
        str         data;

        int length = conLen(con);

        for (int i = 3; i <= length; i++)
        {
            str name = conPeek(conPeek(con, i), #name);

            if (name == #ContainerType)
            {
                data = conPeek(conPeek(con, i), #data);
            }
        }

        return data;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultContainerTypeCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Container type code does not have to be displayed on the RF, so if it has not been defined already by a mobile device user,
    ///   set a default value based on the pass.
    /// </summary>
    /// <returns>
    ///  Returns a default container type code.
    /// </returns>
    protected WHSDefaultContainerTypeCode getDefaultContainerTypeCode()
    {
        WHSDefaultContainerTypeCode defaultContainerTypeCode;

        if (pass.exists(#ContainerType))
        {
            defaultContainerTypeCode = pass.lookupStr(#ContainerType);
        }
        // Only default if we are not displaying the container type on the mobile device
        else
        {
            defaultContainerTypeCode = WHSLicensePlate::getDefaultContainerType(pass.lookupStr(#LicensePlateId),
                                                                                pass.lookup(#MenuItem),
                                                                                pass.lookup(#UserId),
                                                                                pass.lookupStr(#InventLocationId),
                                                                                pass.lookupStr(#WMSLocationId),
                                                                                pass.lookupStr(#ItemId),
                                                                                WHSInventTable::find(pass.lookupStr(#ItemId)).UOMSeqGroupId,
                                                                                pass.lookupStr(#UOM));
        }

        return defaultContainerTypeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getControlDataFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the data of the control from the container which holds the controls for user display, by the name of the control.
    /// </summary>
    /// <param name="_displayCon">
    /// The container which holds the controls for user display.
    /// </param>
    /// <param name="_controlName">
    /// The name of the build control that needs to be fetched.
    /// </param>
    /// <returns>
    /// The data of the found control in the build container.
    /// </returns>
    protected str getControlDataFromContainer(container _displayCon, str _controlName)
    {
        int             controlIndex = this.indexOfBuildControlFromContainer(_displayCon, _controlName);
        container       control;
        str             ret = '';

        if (controlIndex > 0)
        {
            control = conPeek(_displayCon, controlIndex);
            ret = conPeek(control, #data);
        }

        if (WHSBarcodeDataParserFactory::isBarcodeDataParsingEnabled())
        {
            WHSGS1BarcodeEAN128Container barcodeEAN128 = WHSGS1BarcodeEAN128Container::construct(_controlName, ret, pass);
            str decodedStr = barcodeEAN128.decodeContainer();

            if (decodedStr)
            {
                ret = decodedStr;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>indexOfBuildControlFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the index of the control from the container which holds the controls for user display, by the name of the control.
    /// </summary>
    /// <param name="_displayCon">
    /// The container which holds the controls for user display.
    /// </param>
    /// <param name="_controlName">
    /// The name of the build control that needs to be fetched.
    /// </param>
    /// <returns>
    /// The index of the found control in the build container.
    /// </returns>
    protected int indexOfBuildControlFromContainer(container _displayCon, str _controlName)
    {
        int             ret;
        int             counter;
        container       control;
        str             value;

        for (counter = 1; counter <= conLen(_displayCon); counter++)
        {
            control = conPeek(_displayCon, counter);
            value = strFmt("%1", conPeek(control, #name));
            if (value == _controlName)
            {
                ret = counter;
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemRequiresManualDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the given item requires the given type of manual dimension tracking.
    /// </summary>
    /// <param name = "_inventTable">The item to check for manual dimension tracking.</param>
    /// <param name = "_type">The type of manual dimension tracking to check.</param>
    /// <returns>true if the item requires the given type of manual dimension tracking; otherwise, false</returns>
    [SysObsolete('Logic has been moved to InventTable.itemRequiresManualDimTracking', false, 24\03\2023)]
    protected internal boolean itemRequiresManualDimTracking(
        InventTable                 _inventTable,
        InventTrackingDimType       _type           = InventTrackingDimType::Batch)
    {
        return _inventTable.itemRequiresManualDimTracking(_type);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateAutoTrackingDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the passthrough variable with an auto-generated batch or serial number.
    /// </summary>
    /// <param name="_type">
    /// The tracking type in the dimension - Batch or Serial.
    /// generated.
    /// </param>
    /// <param name="_itemId">
    /// The item for which the tracking number is to be generated.
    /// </param>
    /// <param name="_transRefId">
    /// The InventTransRefId for which the tracking number is to be generated.
    /// </param>
    /// <param name="_transId">
    /// The InventTransId for which the tracking number is to be generated.
    /// </param>
    /// <param name="_transType">
    /// The <c>InventTransType</c> associated; optional.
    /// </param>
    /// <returns>
    /// True if a new tracking id was set on pass; otherwise, false.
    /// </returns>
    protected boolean populateAutoTrackingDim(
        InventTrackingDimType    _type,
        ItemId                   _itemId,
        InventTransRefId         _transRefId,
        InventTransId            _transId,
        InventTransType          _transType = this.receivingOrderProvider().inventTransType())
    {
        InventTable                 inventTable;
        InventNumGroup              inventNumGroup;
        anytype                     trackingTypeKey;
        ExtendedTypeId              trackingExtType;
        boolean                     generateNewId = false;

        inventTable = InventTable::find(_itemId);
        switch (_type)
        {
            case InventTrackingDimType::Batch:
                inventNumGroup = InventNumGroup::find(inventTable.BatchNumGroupId);
                trackingTypeKey = #BatchId;
                trackingExtType = extendedTypeNum(InventBatchId);
                break;
            case InventTrackingDimType::Serial:
                inventNumGroup = InventNumGroup::find(inventTable.SerialNumGroupId);
                trackingTypeKey = #SerialId;
                trackingExtType = extendedTypeNum(InventSerialId);
                break;
            default:
                return false;
        }

        generateNewId =
            !this.itemRequiresManualDimTracking(inventTable, _type)
            && inventNumGroup.isTransTypeActivated(_transType)
            && inventNumGroup.OnlyInventTransaction ? inventNumGroup.PhysicalUpdate : false;

        if (!generateNewId)
        {
            return false;
        }

        str generatedId = inventNumGroup.buildNumberParameters(DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()),
                                                               _transRefId,
                                                               _transId,
                                                               trackingExtType);

        // generate a tracking number from the number series
        pass.insert(trackingTypeKey, generatedId);
        pass.insert(#AutoGeneratedBatchId, generatedId);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTrackingDimDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes input gathered from the tracking details RF screen.
    /// </summary>
    /// <param name="_nextStep">
    /// The next step to return the caller to, once the processing has been completed.
    /// </param>
    /// <param name="_hasError">
    /// A boolean indicating if an error was passed on from the previous run.
    /// </param>
    /// <param name="_con">
    /// The display container having the input data which was passed to the caller.
    /// </param>
    /// <param name="_fieldValues">
    /// The <c>WHSRFPassthrough</c> instance with the values of the input fields from the first step onwards.
    /// </param>
    /// <param name="_startInfologLine">
    /// The starting line from which to retrieve the infolog message.
    /// </param>
    /// <param name="_addCancel">
    /// The boolean indicating if the Cancel button should be added and has been pre-set by the caller.
    /// </param>
    /// <param name="_inventTransType">
    /// The type of order which is being received through the RF device; optional.
    /// </param>
    /// <returns>
    /// A container having the following fields,
    /// <list>
    /// <item>a Boolean which indicates if an error occurred, </item>
    /// <item>the container having the controls for the next step, </item>
    /// <item>and a Boolean indicating if the Cancel button should be displayed. </item>
    /// </list>
    /// </returns>
    protected container processTrackingDimDetails(
        int                         _nextStep,
        boolean                     _hasError,
        container                   _con,
        WHSRFPassthrough            _fieldValues,
        int                         _startInfologLine,
        boolean                     _addCancel,
        InventTransType             _inventTransType = this.receivingOrderProvider().inventTransType())
    {
        boolean                     hasError = _hasError;
        container                   ret;
        container                   tmpFieldValues;
        boolean                     inventBatchChanged;
        boolean                     complete;
        InventDim                   trackingInventDim;
        InventQty                   dimInventQty;
        boolean                     trackingDimHasBeenSet;
        real                        currentDimQty;

        if (hasError)
        {
            _con = conDel(_con, #IndexOfErrorControlInContainer, 1);
        }
        [_con, tmpFieldValues] = WHSRFControlData::processData(_con, pass);
        _fieldValues = WHSRFPassthrough::create(tmpFieldValues);

        // Check to see whether the batch ID has been changed
        inventBatchChanged = this.fieldValueChanged(_fieldValues, #BatchId);

        pass = this.combineMaps(pass, _fieldValues);
        hasError = this.hasError(_con);

        if (hasError)
        {
            ret = _con;
            ret = this.rebuildDimUOM(ret, false);
            ret = this.rebuildBatchDisposition(ret);
            return [true, ret, _addCancel];
        }

        ItemId               itemId       = pass.lookupStr(#ItemId);
        InventHandlingUnitId inventUnitId = WHSCatchWeightHelper::inventHandlingUnitId(ItemId);

        int prevStep = conPeek(conPeek(_con, #StateInfo), #StateInfoStep);

        currentDimQty = pass.lookupNum(#DimQty);
        _con = this.buildTrackingDimensions(ret, _inventTransType, pass.lookupNum(#DimQty));
        [trackingDimHasBeenSet, _con] = this.setBatchDetails(_con, _inventTransType);
        /*
        do not continue further if the calculated default quantity or the requested to receive
        is less than the current one in the pass
        */
        if (!trackingDimHasBeenSet
            || WHSWorkExecuteDisplay::str2numDisplay(this.getControlDataFromContainer(_con, #DimQty)) < currentDimQty
            || this.getTotalOrderedQtyForBatchFromPass(_inventTransType, pass.lookupStr(#BatchId)) < currentDimQty
            || this.checkItemDispositionCode(itemId, _inventTransType))
        {
            return [false, _con];
        }

        // do not continue further if the potency base value has not been filled
        if (this.needsPotency())
        {
            return [false, _con];
        }

        if (!_fieldValues.empty())
        {
            [ret, complete] = this.processFieldValues(_con, _fieldValues);

            // Check whether or not the batch ID has been changed
            if (inventBatchChanged)
            {
                complete = false;
                pass.remove(#ExpDate);

                /*
                If the batch ID changes while we are on the same tracking dim display, we have to default the
                control with this value until the current display gets completed or the user changes it again.
                */
                pass.insert(#UpdatedBatchId, pass.lookup(#BatchId));

                // If the batch ID changes, remove the default disposition code.
                if (pass.exists(#BatchDispositionDefault))
                {
                    pass.remove(#BatchDispositionDefault);
                }

                ret = conNull();
                // Defaulting the UI to the remaining quantity and picking its unit of measure
                pass.insert(#DimUOM, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)));
                ret = this.buildTrackingDimensions(ret, _inventTransType, pass.lookupNum(#DimRunningQty));
            }

            if (complete
                && this.shouldCaptureWeightDuringDimRegistration(pass.lookup(#ItemId))
                && !pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight))
            {
                ret = this.buildTrackingDimensions(conNull(), _inventTransType, pass.lookupNum(#DimQty));

                complete = false;
            }

            // For transfer receipt, the batch id will not have been populated before showing the screen to the user.
            if (complete
                && (_inventTransType == InventTransType::TransferOrderReceive || !pass.exists(#DisplayBatch))
                && (((mode != WHSWorkExecuteMode::MixedLPReceiving && mode != WHSWorkExecuteMode::MixedLPReceivingAndLocate) || _inventTransType != InventTransType::TransferOrderReceive) || prevStep != 2))
            {
                // Capture vendor batch details, if necessary.
                if (this.isInboundOrderReceiving(_inventTransType)
                    && pass.exists(#BatchId)
                    && !pass.exists(#VendBatchInfoEntered)
                    && this.shouldDisplayVendorBatchDetailsForItemAndBatch(pass.parmItemId(), pass.parmBatchId()))
                {
                    step = #VendBatchDetailsStep;

                    this.initVendBatchInfoFields();

                    pass.insert(#VendBatchAttemptNo, 1);

                    ret = conNull();
                    ret = this.buildGetVendBatchDetails(ret);

                    return [false, ret, _addCancel];
                }

                trackingInventDim = this.initializeTrackingDetailsInventoryDimension(_inventTransType);

                trackingInventDim = InventDim::findOrCreate(trackingInventDim);
                
                dimInventQty = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId),
                                                                     pass.lookup(#DimUOM),
                                                                     pass.lookupNum(#DimQty),
                                                                     trackingInventDim.InventDimId);

                // The system should not allow the user to enter more than the expected quantity per LP
                if ((pass.lookupNum(#DimRunningQty) - dimInventQty) < 0)
                {
                    throw error("@WAX2142"); // Cannot over receive
                }

                // Build the inventory batch receipt details record if capturing batch.
                if (trackingInventDim.InventBatchId)
                {
                    this.populateItemBatchReceiptDetails();
                }

                //insert or update receiving record when we have all dimensions
                //we are only supporting a flow where serial is captured after batch. Other tracking dimensions will have to be handled specifically.
                if (dimInventQty && !this.mustCaptureSerialOnReceiptInCurrentFlow(pass.lookup(#ItemId)))
                {
                    // Insert or update receiving detail record
                    if (!PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId)))
                    {              
                        if (WHSWorkExecuteDisplayPopulateTrackingReceiptDetailsPerBatchQtyFlight::instance().isEnabled())
                        {
                            this.populateTrackingReceiptDetailsPerBatchQty(trackingInventDim, dimInventQty, _inventTransType);
                        }
                        else
                        {
                            this.populateTrackingReceiptDetails(trackingInventDim, dimInventQty);
                        }                        
                    }
                    else
                    {
                        InventQty catchWeight;

                        if (!WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId)))
                        {
                            InventHandlingQty unitsBeingProcessed;
                            if (mode == WHSWorkExecuteMode::MixedLPReceiving || mode == WHSWorkExecuteMode::MixedLPReceivingAndLocate)
                            {
                                unitsBeingProcessed = pass.lookupNum(#CurrentQty);
                            }
                            else
                            {
                                unitsBeingProcessed = pass.lookupNum(#QtyReceived);
                            }

                            catchWeight = WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)) ? WHSCatchWeightHelper::calculateAverageWeight(dimInventQty,
                                                                                                                                                       unitsBeingProcessed - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum),
                                                                                                                                                       pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimWeightSum),
                                                                                                                                                       InventTable::inventDecimals(pass.lookup(#ItemId))) : pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
                            if (mode == WHSWorkExecuteMode::MixedLPReceiving || mode == WHSWorkExecuteMode::MixedLPReceivingAndLocate)
                            {
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::WeightToConsume, catchWeight);
                            }

                            if (dimInventQty != (unitsBeingProcessed - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum)))
                            {
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimWeightSum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimWeightSum) + catchWeight);
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum) + dimInventQty);
                            }
                        }

                        WHSReceiptDetails::createOrUpdateReceiptDetailsHandlingQty(pass.lookup(#ReceiptId), trackingInventDim.InventDimId, dimInventQty, catchWeight, pass.lookup(#ItemId));

                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId, WHSReceiptDetails::find(pass.lookup(#ReceiptId), trackingInventDim.inventDimId).RecId);

                        // Auto create catch weight tag records if auto generating tag Id and capturing aggregate weight
                        if (WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId)) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateCatchWeightTag && WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)))
                        {
                            catchWeight = WHSCatchWeightHelper::calculateAverageWeight(dimInventQty,
                                                                                      pass.lookupNum(#QtyReceived) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum),
                                                                                      pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimWeightSum),
                                                                                      InventTable::inventDecimals(pass.lookup(#ItemId)));

                            WHSReceiptOrderLine orderLine = this.receivingOrderLine(pass);
                            
                            WHSCatchWeightTagCreationSource tagSource = WHSCatchWeightTagCreationSource::instantiateFromSource(orderLine, pass);
                            tagSource.parmReceiptDetailsRecId(pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId));
                            WHSCatchWeightTagCreationMethod tagMethod = WHSCatchWeightTagCreationMethod::newAutoTagCreation(dimInventQty, catchWeight);

                            WHSCatchWeightTagCreator creator = WHSCatchWeightTagCreator::construct();
                            this.trackAutoGeneratedCatchWeightTags(creator.createCatchWeightTags(tagSource, tagMethod));

                            // In case of auto generation of tags update the weight of the receipt details after the tags are generated.
                            WHSReceiptDetails::updateCapturedWeight(pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId), catchWeight);
                                
                            if (dimInventQty != (pass.lookupNum(#QtyReceived) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum)))
                            {
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimWeightSum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimWeightSum) + catchWeight);
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightDimQtySum) + dimInventQty);
                            }
                        }
                    }
                }

                if (dimInventQty
                &&  (mode == WHSWorkExecuteMode::MixedLPReceiving
                ||   mode == WHSWorkExecuteMode::MixedLPReceivingAndLocate)
                &&  (!this.mustCaptureSerialOnReceipt(pass.lookup(#ItemId))
                ||   pass.hasValue(#SerialId)))
                {
                    InventTransId orderTransId;
                    WHSWorkTransType workTransType = WHSWorkTransType::None;
                    if (this.isInboundOrderReceiving(_inventTransType))
                    {
                        WHSReceiptOrderLine orderLine = this.receivingOrderLine(pass);
                        orderTransId  = orderLine.InventTransId;
                        if (WHSWorkExecuteDisplayReceivingRefactoringFlight::instance().isEnabled())
                        {
                            workTransType = orderLine.workTransType();
                        }
                    }
                    else if (_inventTransType == InventTransType::TransferOrderReceive)
                    {
                        orderTransId = InventTransferLine::find(pass.lookup(#TONum), pass.parmTOLineNum()).InventTransId;
                    }
                    // Create mixed LP receiving
                    WHSMixedLicensePlateReceiptLine::mixedLPReceiveLine(trackingInventDim.InventDimId,
                                                                    orderTransId,
                                                                    dimInventQty,
                                                                    pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::WeightToConsume),
                                                                    pass.lookup(#ReceiptId),
                                                                    pass.lookup(#UserId),
                                                                    pass.lookupStr(#MenuItem),
                                                                    pass.lookupStr(#LoadId),
                                                                    pass.lookupStr(#ShipmentId),
                                                                    pass.lookupStr(#ContainerType),
                                                                    workTransType);
                }

                if (!this.skipDimRunningQtyUpdateWithoutSerial())
                {
                    pass.insert(#DimRunningQty, pass.lookupNum(#DimRunningQty) - dimInventQty);
                }

                // Dimensions specified for all license plate qty
                if (pass.lookupNum(#DimRunningQty) == 0)
                {
                    // When moving to the previous step, validate the selected value rather than the element string.
                    if (this.displayBatchDisposition())
                    {
                        pass.insert(#UseSelectedBatchDispCode, 1);
                    }

                    // Skip the potency validation during the next step.
                    if (this.capturePotency())
                    {
                        pass.insert(#SkipPotencyValidation, 1);
                    }

                    // If we captured catch weight for specific tracking dimensions, validate selected UOM rather than generated element string.
                    if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
                    && !WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId))
                    && !WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)))
                    {
                        pass.insert(#UseSelectedDimUOM, 1);
                    }
                    
                    // if item requires manual batch entry, remove entered fields.
                    if (this.itemRequiresManualDimTracking(InventTable::find(pass.lookup(#ItemId))))
                    {
                        pass.remove(#BatchId);
                        ret = this.deleteControlDataFromContainer(ret, #BatchId);

                        pass.remove(#ExpDate);
                        ret = this.deleteControlDataFromContainer(ret, #ExpDate);

                        pass.remove(#VendBatchInfoEntered);
                        ret = this.deleteControlDataFromContainer(ret, #VendBatchInfoEntered);

                        pass.remove(#Potency);
                        ret = this.deleteControlDataFromContainer(ret, #Potency);
                    }

                    if (this.continueTrackingDimCaptureForSameLine())
                    {
                        ret = this.updateModeStepPass(ret, mode, step, pass);
                        return [false, ret, _addCancel];
                    }
                    else
                    {
                        this.removeTrackingDimensionsFromPass(itemId);

                        step = _nextStep;
                        
                        if (WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem)))
                        {
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, dimInventQty);

                            ret = conNull();
                            ret = this.buildCWTagCapture(ret);

                            step = #CatchWeightTagCapture;
                        }

                        ret = this.updateModeStepPass(ret, mode, step, pass);

                        pass.parmTransferOrderReceiveInventDimId(trackingInventDim.InventDimId);

                        ret = this.displayForm(ret);
                    }
                }
                else if (WhsWorkExecuteDisplay::str2numDisplay(pass.lookup(#DimRunningQty)) > 0)
                {
                    if (pass.lookupStr(#DimQty) && !this.mustCaptureSerialOnReceiptInCurrentFlow(itemId))
                    {
                        InventDimParm trackingDimsToRemove;
                        trackingDimsToRemove.setAllTrackingDimensions();

                        //For batch/serial enabled items, it needs to be possible to add more serials on the same batch.
                        //If the batch is auto generated, it can be only one for all the receiving quantity and we need to keep it between the different displays.
                        if (pass.lookupStr(#BatchId)
                        && this.mustCaptureSerialOnReceipt(itemId)
                        && !this.itemRequiresManualDimTracking(InventTable::find(itemId), InventTrackingDimType::Batch))
                        {
                            trackingDimsToRemove.InventBatchIdFlag = NoYes::No;
                        }

                        this.removeTrackingDimensionsFromPass(itemId, trackingDimsToRemove);

                        pass.remove(#DimQty);
                        pass.insert(#DimUOM, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)));

                        if (trackingDimsToRemove.InventBatchIdFlag == NoYes::Yes)
                        {
                            pass.remove(#UpdatedBatchId);

                            // If we are receiving a multi-batch LP, remove the flag indicating that vendor batch details have already been entered prior to moving on to the next batch.
                            pass.remove(#VendBatchInfoEntered);

                            // If we are receiving a multi-batch LP, reset the selected batch disposition code prior to moving on to the next batch.
                            if (this.displayBatchDisposition())
                            {
                                pass.insert(#ResetBatchDisposition, 1);
                            }
                        }
                        
                        if (WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem)))
                        {
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, dimInventQty);

                            ret = conNull();
                            ret = this.buildCWTagCapture(ret);

                            step = #CatchWeightTagCapture;
                        }
                        else
                        {
                            ret = conNull();
                            ret = this.buildTrackingDimensions(ret, _inventTransType, pass.lookupNum(#DimRunningQty));
                        }
                    }
                }
            }

            if (pass.exists(#DisplayBatch))
            {
                pass.remove(#DisplayBatch);
            }
        }

        return [false, ret, _addCancel];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisplayVendorBatchDetailsForItemAndBatch</Name>
				<Source><![CDATA[
    private boolean shouldDisplayVendorBatchDetailsForItemAndBatch(ItemId _itemId, InventBatchId _batchId)
    {
        if (!InventModelGroup::find(InventModelGroupItem::findByItemIdLegalEntity(_itemId).ModelGroupId).PdsReqVendBatchDetail)
        {
            return false;
        }

        if (!WhsBatchDetailsCapturePolicyFlight::instance().isEnabled())
        {
            return true;
        }

        WhsBatchDetailsCapturePolicy batchDetailsCapturePolicy = WhsBatchDetailsCapturePolicy::findByItemid(_itemId);
        if (!batchDetailsCapturePolicy)
        {
            return true;
        }

        if (batchDetailsCapturePolicy.VendBatchDetailDisplayPolicy == WhsVendBatchDetailDisplayPolicy::OnlyForNewBatch)
        {
            return !InventBatch::exist(_batchId, _itemId);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTrackingReceiptDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>WHSReceiptDetails</c> table.
    /// </summary>
    /// <param name="_trackingInventDim">
    /// The <c>InventDim</c> record that contains the tracking details.
    /// </param>
    /// <param name="_dimInventQty">
    /// The inventory quantity used to populate the receipt details.
    /// </param>
    protected void populateTrackingReceiptDetails(InventDim _trackingInventDim, InventQty _dimInventQty)
    {
        WHSReceiptDetails::createOrUpdateReceiptDetailsHandlingQty(
            pass.lookup(#ReceiptId),
            _trackingInventDim.InventDimId,
            _dimInventQty,
            workLine.CapturedWeight,
            workLine.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTrackingDetailsInventoryDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventDim</c> record that contains the tracking details.
    /// </summary>
    /// <param name = "_inventTransType">The type of order which is being received through the RF device</param>
    /// <returns>The <c>InventDim</c> record that contains the tracking details.</returns>
    protected InventDim initializeTrackingDetailsInventoryDimension(InventTransType _inventTransType)
    {
        InventDim trackingInventDim = pass.createInventDimFromPass();

        if (!trackingInventDim.InventStatusId)
        {
            if (this.isInboundOrderReceiving(_inventTransType))
            {
                this.initializeTrackingDetailsInventoryDimensionsFromInboundOrderLine(trackingInventDim);
            }
            else if (_inventTransType == InventTransType::TransferOrderReceive)
            {
                trackingInventDim.InventStatusId = InventTransferLine::find(pass.lookup(#TONum), pass.parmTOLineNum()).inventDim().InventStatusId;
            }
        }

        trackingInventDim.wmsLocationId = InventLocation::find(trackingInventDim.InventLocationId).wmsLocationIdDefaultReceipt;

        return trackingInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTrackingDetailsInventoryDimensionsFromInboundOrderLine</Name>
				<Source><![CDATA[
    private void initializeTrackingDetailsInventoryDimensionsFromInboundOrderLine(InventDim _trackingInventDim)
    {
        WHSReceiptOrderLine orderLine = this.receivingOrderLine(pass);
        InventDim orderLineInventDim = orderLine.inventDim();

        _trackingInventDim.InventStatusId = orderLineInventDim.InventStatusId;

        if (!_trackingInventDim.InventOwnerId_RU)
        {
            _trackingInventDim.InventOwnerId_RU = orderLineInventDim.InventOwnerId_RU;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDetailsAlreadySet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns false if setBatchDetails should set the batch details and true if it should do nothing.
    /// </summary>
    /// <returns>Whether setBatchDetails should do nothing.</returns>
    protected boolean batchDetailsAlreadySet()
    {
        return (pass.exists(#BatchId) || pass.exists(#SerialId) || pass.exists(#GTDId_RU));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBatchDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set batch details for an inventory transaction.
    /// </summary>
    /// <param name = "_displayCon">The container which holds the controls for user display</param>
    /// <param name = "_inventTransType">The inventory transaction associated with batch.</param>
    /// <returns>The container with display controls.</returns>
    protected container setBatchDetails(container _displayCon, InventTransType _inventTransType = this.receivingOrderProvider().inventTransType())
    {
        if (this.batchDetailsAlreadySet())
        {
            return [true, _displayCon];
        }

        if (this.buildControlExistsInContainer(_displayCon, #BatchId))
        {
            InventBatchId batchId = this.getControlDataFromContainer(_displayCon, #BatchId);
            if (batchId != '')
            {
                pass.insert(#BatchId, batchId);

                // Adjust the quantity on the pass in case the container has a reduced quantity.
                if (this.buildControlExistsInContainer(_displayCon, #DimQty))
                {
                    pass.insert(#DimQty, this.getControlDataFromContainer(_displayCon, #DimQty));
                }

                // Adjust the expiry date on the pass in case the expiry date has a different value.
                if (this.buildControlExistsInContainer(_displayCon, #ExpDate))
                {
                    pass.insert(#ExpDate, this.getControlDataFromContainer(_displayCon, #ExpDate));
                }

                return [true, _displayCon];
            }
        }

        InventTransRefId    transRefId;
        InventTransId       transId;
        if (this.isInboundOrderReceiving(_inventTransType))
        {
            transRefId = this.receivingOrderProvider().orderNum(pass);
            transId    = this.receivingOrderLine(pass).InventTransId;
        }
        else if (_inventTransType == InventTransType::TransferOrderReceive)
        {
            transRefId = pass.lookup(#TONum);
            transId    = InventTransferLine::find(pass.lookup(#TONum), pass.parmTOLineNum()).InventTransId;
        }

        if (this.populateAutoTrackingDim(
                InventTrackingDimType::Batch,
                pass.lookup(#ItemId),
                transRefId,
                transId,
                _inventTransType))
        {
            // set the new batch id on the build container
            if (this.buildControlExistsInContainer(_displayCon, #BatchId))
            {
                _displayCon = this.setControlDataFromContainer(_displayCon, #BatchId, pass.lookup(#BatchId));
            }

            // remove the expiration date control as this batch is auto-generated
            _displayCon = conDel(_displayCon, this.indexOfBuildControlFromContainer(_displayCon, #ExpDate), 1);

            return [true, _displayCon];
        }

        return [false, _displayCon];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setControlDataFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the data of the control from the container which holds the controls for user display, by the name of the control.
    /// </summary>
    /// <param name="_displayCon">
    /// The container which holds the controls for user display.
    /// </param>
    /// <param name="_controlName">
    /// The name of the build control that needs to be set.
    /// </param>
    /// <param name="_newValue">
    /// The new value of the build control that needs to be set.
    /// </param>
    /// <returns>
    /// The new container with the changed data.
    /// </returns>
    protected container setControlDataFromContainer(container _displayCon, str _controlName, str _newValue)
    {
        int             controlIndex = this.indexOfBuildControlFromContainer(_displayCon, _controlName);
        container       control;
        container       ret = _displayCon;

        if (controlIndex > 0)
        {
            control =  conPoke(conPeek(_displayCon, controlIndex), #data, _newValue);
            ret = conPoke(_displayCon, controlIndex, control);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCaptureWeightDuringDimRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if weight capture should be done when dimension registration form is shown.
    /// </summary>
    /// <param name="_itemId">
    /// The item Id to check.
    /// </param>
    /// <returns>
    /// true if weight capture is necessary when dimension registration form is shown; otherwise, false.
    /// </returns>
    protected boolean shouldCaptureWeightDuringDimRegistration(ItemId _itemId)
    {
        return PdsGlobal::pdsIsCWItem(_itemId)
                && !WHSInventTable::shouldCaptureAggregateWeight(_itemId)
                && !WHSInventTable::isCatchWeightTagTracked(_itemid);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldHandleByLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks strategy that should be used during pick/put operations for the work.
    /// </summary>
    /// <returns>
    /// true if pick/put should be executed through guided lp locate strategy; otherwise, false.
    /// </returns>
    public boolean shouldHandleByLP()
    {
        return WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).HandleByLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDisplayForImmediateCycleCounting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the current display with the data to start the execution of the cycle count work.
    /// </summary>
    /// <param name = "_cycleCountWorkId">The cycle count work ID to be executed</param>
    /// <param name = "_con">The container with the current form state</param>
    /// <param name = "_prevCountStep">The previous count step ID</param>
    /// <param name = "_buttonClicked">Clicked button in the previous form, empty string by default</param>
    /// <param name = "_updateCon">true if part of the container information needs to be deleted; otherwise false</param>
    /// <returns>
    /// The form state.
    /// </returns>
    protected container updateDisplayForImmediateCycleCounting(
                                                WHSWorkId   _cycleCountWorkId,
                                                container   _con,
                                                int         _prevCountStep,
                                                str         _buttonClicked,
                                                boolean     _updateCon)
    {
        // Store off passthrough to be used after count is complete
        WHSWorkUserSession::setPrevPass(pass.lookup(#UserId), pass.pack());

        pass = this.resetPassthrough(_con, false);
        pass.insert(#WorkId, _cycleCountWorkId);
        pass.parmLineNum(1);
        pass.insert(#PrevCountStep, _prevCountStep);
        step = 0;

        var workExecuteDisplayCycleCount = WHSWorkExecuteDisplay::construct(WhsWorkExecuteMode::CycleCounting);
        if (_updateCon)
        {
            _con = conDel(_con, 1, 2);
        }
        _con = this.updateModeStepPass(_con, mode, step, pass);
        _con = workExecuteDisplayCycleCount.displayForm(_con, _buttonClicked);
        pass = WHSRFPassthrough::create(conPeek(_con, 2));

        return _con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCycleCountThresholdAndUpdateDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the cycle count threshold to identify if it is needed to create cycle count work. If it is set to execute
    /// the cycle count work immediately, the display will be updated.
    /// </summary>
    /// <param name = "_con">The container with the current form state</param>
    /// <param name = "_buttonClicked">Clicked button in the previous form, empty string by default</param>
    /// <param name = "_workLine">The current work line</param>
    /// <param name = "_prevCountStep">The previous count step ID</param>
    /// <param name = "_locationId">The current location ID</param>
    /// <param name = "_itemId">The current item ID</param>
    /// <returns>
    /// A container having the following fields,
    /// <list>
    /// <item>a boolean which indicates if the display is updated with the cycle count work to be executed immediately</item>
    /// <item>and the container having the controls for the next step.</item>
    /// </list>
    /// </returns>
    protected container checkCycleCountThresholdAndUpdateDisplay(
                                                            container       _con,
                                                            str             _buttonClicked,
                                                            WHSWorkLine     _workLine,
                                                            int             _prevCountStep = step,
                                                            WMSLocationId   _locationId = '',
                                                            ItemId          _itemId = '')
    {
        boolean cycleCountDisplayUpdated = false;

        // If menu item allows, evaluate cycle count thresholds
        if (!WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DisableCycleCountThreshold)
        {
            var cycleCountThresholdId = WHSCycleCountCreateThreshold::processCycleCountThreshold(_workLine.WorkId, _workLine.LineNum);

            // Check to see if an immediate count needs to be executed
            if (WHSCycleCountThreshold::find(cycleCountThresholdId).ImmediateCycleCount)
            {
                // Find open cycle count work for the location
                var cycleCountWorkId = WHSWorkTable::findCycleCountByLocation(WHSWorkUserSession::find(userId).InventLocationId, _workLine.wmsLocationId);

                if (cycleCountWorkId)
                {
                    _con = this.updateDisplayForImmediateCycleCounting(
                                                                cycleCountWorkId,
                                                                _con,
                                                                _prevCountStep,
                                                                _buttonClicked,
                                                                false);
                    cycleCountDisplayUpdated = true;
                }
            }
        }

        return [cycleCountDisplayUpdated, _con];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRemainingReceiptQtyCurrentLPLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build remaining quantity label for given item.
    /// </summary>
    /// <param name = "_itemId">Item id.</param>
    /// <param name = "_dimQty">Item quantity.</param>
    /// <param name = "_uomSymbol">Unit used to measure item.</param>
    /// <returns>A container containing the state of the control.</returns>
    [Wrappable(false)]
    protected final container buildRemainingReceiptQtyCurrentLPLabel(
                                                ItemId              _itemId,
                                                Qty                 _dimQty,
                                                UnitOfMeasureSymbol _uomSymbol)
    {
        InventTable         inventTable;
        InventNumGroup      numGroup;
        Qty                 qtyLeft;

        inventTable = InventTable::find(_itemId);
        numGroup = InventNumGroup::find(inventTable.BatchNumGroupId);

        if (numGroup.PerQty != 0)
        {
            qtyLeft = min(_dimQty, numGroup.PerQty);
        }
        else
        {
            qtyLeft = _dimQty;
        }

        return [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX:QtyLeftToReceive", WhsWorkExecuteDisplay::num2StrDisplay(qtyLeft), _uomSymbol), 1, '', extendedTypeNum(String255), '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureSerialOnReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given item needs to have serial numbers specified during receiving.
    /// </summary>
    /// <param name="_itemId">
    /// The item currently being received via the RF device.
    /// </param>
    /// <returns>
    /// True, if the serial number needs to be captured on receipt; otherwise False.
    /// </returns>
    /// <remarks>
    /// The capture of the tracking dimensions should only be triggered in case the
    /// <c>InventNumGroup</c> record requires an id to be manually provided, or, during a
    /// physical update.
    /// </remarks>
    protected boolean mustCaptureSerialOnReceipt(ItemId _itemId)
    {
        return WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving;;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureSerialOnReceiptInCurrentFlow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given item needs to have serial numbers specified during receiving
    /// in case they have not been specified yet in the pass object.
    /// </summary>
    /// <param name="_itemId">
    /// The item currently being received via the RF device.
    /// </param>
    /// <returns>
    /// True, if the serial number has not been set yet and needs to be captured on receipt; otherwise False.
    /// </returns>
    protected boolean mustCaptureSerialOnReceiptInCurrentFlow(ItemId _itemId)
    {
        boolean ret;

        if (!pass.lookupStr(#SerialId))
        {
            ret = this.mustCaptureSerialOnReceipt(_itemId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowInventoryDimensionForItem</Name>
				<Source><![CDATA[
    internal boolean mustShowInventoryDimensionForItem(
        InventTable _inventTable,
        FieldId     _fieldId)
    {
        if (_fieldId == fieldNum(InventDim, InventOwnerId_RU))
        {
            if (_inventTable.whsItemInventoryOwnershipEnabled()
                || this.mustShowInventoryDimension(_fieldId))
            {
                return true;
            }

            return false;
        }
        
        return this.mustShowInventoryDimension(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowInventoryDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given inventory dimension should be shown in the current mobile device flow.
    /// </summary>
    /// <param name="_fieldId">
    /// The inventory dimension's field ID in the <c>InventDim</c> table.
    /// </param>
    /// <returns>
    /// true, if the dimension should be shown; otherwise, false.
    /// </returns>
    protected boolean mustShowInventoryDimension(FieldId _fieldId)
    {
        boolean ret = true;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && _fieldId == fieldNum(InventDim, InventOwnerId_RU))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchExpDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the batch expiration date of the current batch entered in the RF device, either from
    /// the created <c>InventBatch</c> record if there is any or from the <c>WHSInventBatchReceiptDetails</c> record.
    /// </summary>
    /// <param name="_itemId">
    /// The current item ID.
    /// </param>
    /// <param name="_inventBatchId">
    /// The current batch ID.
    /// </param>
    /// <param name="_receiptId">
    /// The current receipt ID.
    /// </param>
    /// <returns>
    /// The expiration date of the current batch if there is any specified and if the batch is already created
    /// or registered in the <c>WHSInventBatchReceiptDetails</c> record.
    /// </returns>
    /// <remarks>
    /// The batches during the RF processing are only registered in the related <c>WHSInventBatchReceiptDetails</c> record
    /// and in case the same batch is scanned (eg. for batch/serial enabled items when receiving different serials on the same batch)
    /// the expiration date should be the same as the one entered the first time.
    /// </remarks>
    public static InventBatchExpDate getBatchExpDate(
                                    ItemId          _itemId,
                                    InventBatchId   _inventBatchId,
                                    WHSReceiptId    _receiptId)
    {
        InventBatchExpDate expDate;
        InventBatch        inventBatch;

        inventBatch = InventBatch::find(_inventBatchId, _itemId);

        if (inventBatch)
        {
            expDate = inventBatch.ExpDate;
        }
        else
        {
            expDate = WHSInventBatchReceiptDetails::find(_receiptId, _itemId, _inventBatchId).ExpDate;
        }

        return expDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOverrideLPButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a button to override an LP to the RF screen
    /// </summary>
    /// <param name="_con">
    /// Current container of the RF controls.
    /// </param>
    /// <param name="_newLine">
    /// To determine if the button should be on a new line.
    /// </param>
    /// <returns>
    /// A container of the RF controls.
    /// </returns>
    container addOverrideLPButton(container _con, int _newLine = 1)
    {
        container   ret = _con;

        if (addLPOverride)
        {
            ret += [this.buildControl(#RFButton, #RFOverrideLP, "@WAX:OverrideLP", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSplitPutButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a button to enter to a split put to the RF screen.
    /// </summary>
    /// <param name="_con">
    /// Current container of the RF controls.
    /// </param>
    /// <param name="_newLine">
    /// To determine if the button should be on a new line.
    /// </param>
    /// <returns>
    /// A container of the RF controls.
    /// </returns>
    container addSplitPutButton(container _con, int _newLine = 1)
    {
        container   ret = _con;

        if (addSplitButton)
        {
            ret += [this.buildControl(#RFButton, #RFSplitPut, "@WAX:SplitPut", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQtyVerificationControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the container with the qty verification control if the setup requires to have it displayed in the RF.
    /// </summary>
    /// <param name="_uom">
    /// The UOM from the workline.
    /// </param>
    /// <returns>
    /// The container with the data of the control that was built.
    /// </returns>
    protected container addQtyVerificationControl(UnitOfMeasureSymbol _uom)
    {
        container ret;

        ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, pass.lookupStr(#QtyVerification), extendedTypeNum(Qty), '', 0)];
        ret += [this.buildControl(#RFLabel, #QtyVerifyUOM, _uom, 0, pass.lookupStr(#QtyVerifyUOM), #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the controls to the mobile device for item description.
    /// </summary>
    /// <param name="_itemId">
    /// The item that needs a description built out.
    /// </param>
    /// <returns>
    /// A container with the controls for the item description.
    /// </returns>
    protected container buildItemDescription(ItemId _itemId)
    {
        WHSRFDescription1   description1;
        WHSRFDescription2   description2;
        container           ret;

        description1    = WHSInventTable::find(_itemId).rfDescription1;
        description2    = WHSInventTable::find(_itemId).rfDescription2;

        if (description1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(_itemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (description2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildNextDimensionControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the appropriate controls for inventory dimension if needed.
    /// </summary>
    /// <param name="_con">
    /// Current container that represents the currently build RF screen.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which determines the reservation hierarchy, thus, determining the next dimensions control.
    /// </param>
    /// <returns>
    /// A container that represents the currently build RF screen including any controls built in this method.
    /// </returns>
    protected container buildNextDimensionControl(container _con, ItemId _itemId)
    {
        ListEnumerator                      enumerator;
        container                           ret = _con;
        InventDim                           inventDim;
        InventDim                           tmpInventDim;
        FieldId                             fieldId;
        FieldName                           fieldName;
        DictField                           dictField;
        InventTable                         inventTable;
        boolean                             prompt;
        WHSReservationHierarchyElementData  elementData;
        WHSReservationHierarchyProvider     reservationHierarchyProvider;

        if (!_itemId)
        {
            return ret;
        }

        inventTable = InventTable::find(_itemId);

        inventDim = this.createInventDimFromPass();
        inventDim = InventDim::findOrCreate(inventDim);

        // Get List
        reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
        enumerator = reservationHierarchyProvider.getDimListBelowLicensePlate(
                        inventTable,
                        WHSReservationHierarchySortOrder::TopDown)
                    .getEnumerator();

        while (enumerator.moveNext())
        {
            elementData = enumerator.current();
            fieldId = elementData.parmDimensionFieldId();
            fieldName = fieldId2name(inventDim.TableId, fieldId);
            dictField = new DictField(tableNum(InventDim), fieldId);

            [tmpInventDim, prompt] = this.getDefaultDimValue(inventDim, fieldId, _itemId);

            if (pass.exists(fieldName) && pass.hasValue(fieldName))
            {
                inventDim.(fieldId) = pass.lookup(fieldName);
                ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0, prompt)];
                continue;
            }

            pass.insert(fieldName, tmpInventDim.(fieldId));

            if (!prompt)
            {
                ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0, false)];
            }
            else
            {
                ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, '', dictField.typeId(), '', 0)];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSplitPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the split put screen for the RF.
    /// </summary>
    /// <param name="_con">
    /// Container holding RF information
    /// </param>
    /// <returns>
    /// Container with new RF information.
    /// </returns>
    container buildSplitPut(container _con)
    {
        container           ret = _con;
        InventDim           inventDim;
        InventDim           workLineDim;

        ret += [this.buildControl(#RFLabel, #RFPut, strFmt("@WAX1270", workTable.WorkTransType), 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (!workLine.ItemId)
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@WAX402", extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            ret += this.addProductConfirmationControl(WHSWorkType::Put);
        }

        workLineDim = workLine.inventDim();

        this.fillPassFromInventDim(workLineDim);

        // For current qty need to look at the user who picked the work as the location.
        pass.insert(#WMSLocationId, WHSWorkLine::getPrevOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType).UserId);

        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];

        ret = this.buildProductDimensionsFromInventDim(ret, workLine.ItemId, workLineDim, false);

        ret = this.buildNextDimensionControl(ret, workLine.ItemId);

        inventDim = this.createInventDimFromPass();
        inventDim = InventDim::findOrCreate(inventDim);

        pass.insert(#CurrentQty, min(workLine.InventQtyRemain, WHSInventOnHand::onHandHandlingQty(workLine.ItemId, inventDim.InventDimId)));

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (pass.exists(#MenuItem))
        {
            if (WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Put))
            {
                if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).CheckText)
                {
                    ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, pass.lookupStr(#CheckDigit), extendedTypeNum(WMSCheckText), '', 0)];
                }
                else if (pass.exists(#SystemPopulated))
                {
                    if ((!pass.exists(#PrevStep) || pass.lookup(#PrevStep) != WHSWorkExecuteDisplay::num2StrDisplay(#OverrideStep2)) && !pass.exists(#GroupPutawayConfirm))
                    {
                        ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, pass.lookupStr(#LocVerification), extendedTypeNum(WMSLocationId), '', 0)];
                    }
                }
            }
        }

        // Show available qty for dimensions given.
        ret += [this.buildControl(#RFText, #CurrentQty, "@WAX1147", 1, pass.lookup(#CurrentQty), extendedTypeNum(Qty), '', 0, false)];

        ret += [this.buildControl(#RFText, #QtyToPut, "@SYS105177", 1, pass.lookupStr(#QtyToPut), extendedTypeNum(Qty), '', 0, true)];

        // Split put will be done in inventory units
        ret += [this.buildControl(#RFText, #QtyUOM, "@WAX721", 1, WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId), #WHSRFUndefinedDataType, '', 0, false)];

        // Split put should be able to change target LP
        if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled())
        {
            if (!pass.lookupStr(#TargetLicensePlateId) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
            {
                pass.insert(#TargetLicensePlateId, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId));
            }

            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, pass.lookupStr(#TargetLicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, true)];
        }

        if (workLine.ItemId)
        {
            ret += this.buildItemDescription(workLine.ItemId);
        }

        // Build label controls for all dimensions specified above location
        ret = this.buildAboveLocationDimensions(ret, workLineDim, workLine.ItemId);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateMultipleItemsInfoForLicensePlate</Name>
				<Source><![CDATA[
    protected str generateMultipleItemsInfoForLicensePlate(
                                Counter             _itemIdCount,
                                ItemId              _itemId,
                                InventQty           _inventQtyOnHand,
                                UnitOfMeasureSymbol _unitSymbol)
    {
        str ret = '';

        if (_itemIdCount > 0)
        {
            if (_itemIdCount > 1)
            {
                ret += strFmt("@WAX:ItemCountOnLP", _itemIdCount);
                ret += '\n';
            }

            str desc1 = '\n';
            str desc2;

            if (_itemIdCount == 1)
            {
                var whsInventTable = WHSInventTable::find(_itemId);

                if (whsInventTable.rfDescription1)
                {
                    desc1 += whsInventTable.rfDescription1;
                }
                else
                {
                    desc1 += InventTable::find(_itemId).productNameWhsWorkExecute();
                }

                desc2 += '\n';
                if (whsInventTable.rfDescription2)
                {
                    desc2 += whsInventTable.rfDescription2;
                    desc2 += '\n';
                }
            }

            // Item Id: %1%2%3Qty: %4 %5%6
            ret += strFmt("@WAX741", _itemId, desc1, desc2, _inventQtyOnHand, _unitSymbol, '');
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProductDimensionsInPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the pass contains all the values needed for an items product dimensions
    /// </summary>
    /// <param name="_itemId">
    /// The item that is being checked.
    /// </param>
    /// <returns>
    /// A boolean, true if all values for a product dimension exist, otherwise false.
    /// </returns>
    protected boolean checkProductDimensionsInPass(ItemId _itemId)
    {
        // Create an InventDimParm for the items product dimensions
        InventDimParm itemInventDimParm = EcoResProductDimGroupSetup::newInventTable(InventTable::find(_itemId)).inventDimParmActiveDimensions();

        // Check the invent dim created from the pass has all the values from item's product dimensions
        return this.createInventDimFromPass().allInventDimParmFieldsHaveValues(itemInventDimParm, InventDim::dimProductDimFieldList());
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassProductDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears out inventory dimension values in the passthrough that are product dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// The item used to find which product dimensions are active.
    /// </param>
    protected void clearPassProductDimensions(ItemId _itemId)
    {
        List dimList = EcoResProductDimGroupSetup::newInventTable(InventTable::find(_itemId)).activeDimensionFields();

        if (dimList)
        {
            ListEnumerator enumerator = dimList.getEnumerator();

            while (enumerator.moveNext())
            {
                pass.remove(fieldId2name(tableNum(InventDim), enumerator.current()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassTrackingDimensionAboveLocation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void clearPassTrackingDimensionAboveLocation(ItemId _itemId)
    {
        InventTable inventTable = InventTable::find(_itemId);

        if (inventTable)
        {       
            List dimList = InventDimGroupSetup::newItemIdTrackingDimensionsOnly(_itemId).activeFields();

            if (dimList)
            {
                ListEnumerator enumerator = dimList.getEnumerator();

                while (enumerator.moveNext())
                {
                    if (WHSReservationHierarchyInventDimUtil::isFieldIdAboveLocation(inventTable, enumerator.current()))
                    {
                        pass.remove(fieldId2name(tableNum(InventDim), enumerator.current()));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassShortPicking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears out short picking values in the passthrough.
    /// </summary>
    protected void clearPassShortPicking()
    {
        pass.remove(#QtyShort);
        pass.remove(#QtyToPick);
        pass.remove(#ReasonString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processUserInput</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the user input.
    /// </summary>
    /// <param name = "_con">Container containing the state of the previous form.</param>
    /// <returns>Container with the result of the processing.</returns>
    protected container processUserInput(container _con)
    {
        container   tmpFieldValues;
        container   ret;
        boolean     complete;

        [_con, tmpFieldValues] = WhsrfControlData::processData(_con, pass);
        Map fieldValues = WhsrfPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);

        boolean hasErrors = this.hasError(_con);
        if (!hasErrors)
        {
            [ret, complete] = this.processFieldValues(_con, fieldValues);
        }

        return [hasErrors, complete, ret, _con];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildManualReallocationList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the manual reallocation list display
    /// </summary>
    /// <param name = "_reallocationParams">The work line reallocation parameters</param>
    /// <param name = "_remainingQtyToReallocate">The remaining inventory quantity to be allocated</param>
    /// <param name = "_reallocator">The manual reallocator</param>
    /// <param name = "_checkReservedQtyAvailForReallocation">Specifies if the reserved quantity available for reallocation needs to be checked</param>
    /// <returns>The container with all the controls of the manual reallocation list, if there are any available locations to reallocate from</returns>
    protected container buildManualReallocationList(
                            WHSWorkLineReallocationParams   _reallocationParams,
                            InventQty                       _remainingQtyToReallocate,
                            WHSWorkLineManualReallocatorBase _reallocator = null,
                            boolean                          _checkReservedQtyAvailForReallocation = false)
    {
        container ret;
        container retLocations;
        InventQty reservedQtyForReallocation = _remainingQtyToReallocate;
        boolean   buildContainerOnlyIfValidLocationsFound = WHSBuildManualReallocationListEmptyContainerIfNoLocationsFoundFlight::instance().isEnabled();

        if (_checkReservedQtyAvailForReallocation)
        {
            /*
            If some of the initial order line has been unreserved, we cannot reallocated it. We want to skip the
            manual reallocation list if the remaining for work creation reserved quantity is 0 and avoid the conflict
            with reservations on the above location level of other orders.
            */
            reservedQtyForReallocation = _reallocator.calculateHandlingQtyAvailForWorkCreationAboveLocationDims();
        }

        if (reservedQtyForReallocation > 0)
        {
            ItemId              itemId = pass.lookupStr(#ItemId);
            WHSWorkLine			shortPickedWorkLine = _reallocationParams.getShortPickedWorkLine();
            InventDim           inventDim = shortPickedWorkLine.inventDim();
            WMSLocationId       locationIdToExclude = _reallocationParams.getShortPickedWorkLine().WMSLocationId;
            WHSLicensePlateId   licensePlateIdToExclude = pass.lookupStr(#LicensePlateId);

            if (shortPickedWorkLine.OrderCommittedInventDimId)
            {
                InventDimId mandatoryInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(
                    itemId,
                    shortPickedWorkLine.OrderCommittedInventDimId);

                inventDim = InventDim::find(mandatoryInventDimId);
            }

            RecordSortedList rsl = WhsInvent::getAvailableOnHandQtySortedList(itemId, inventDim, locationIdToExclude, licensePlateIdToExclude);
            boolean locationFound = false;

            if (rsl.len() > 0)
            {
                if (!buildContainerOnlyIfValidLocationsFound)
                {
                    ret = this.showWarningFromPass(ret);
                    ret += [this.buildControl(#RFLabel,
                                    WHSWorkExecuteDisplayItemReallocationControls::ItemInformationControlName,
                                    WHSWorkExecuteDisplayItemReallocationControls::getItemInformationControlLabel(
                                                                                        itemId,
                                                                                        inventDim,
                                                                                        pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::TotalWorkLineInventQty),
                                                                                        _remainingQtyToReallocate,
                                                                                        reservedQtyForReallocation),
                                    1, '', #WHSRFUndefinedDataType, '', 0)];

                    ret += [this.buildControl(#RFLabel,
                                    WHSWorkExecuteDisplayItemReallocationControls::AvailQtyInLocationsForReallocationControlName,
                                    WHSWorkExecuteDisplayItemReallocationControls::getAvailQtyInLocationsForReallocationControlLabel(),
                                    1, '', #WHSRFUndefinedDataType, '', 0)];
                }

                InventSum   s;
                /*
                The Session Schema of the WMDP has maxOccurs = 250 for the different controls. This means, that the maximum number of different locations to be
                displayed in a form is 123. It has been chosen to set 120 as the maximum number of different locations.
                */
                int         locationCounter = 0;
                const int   MaximumNumberOfLocations = 120;

                while ((locationCounter < MaximumNumberOfLocations) && rsl.next(s))
                {
                    InventDim currentInventDim = InventDim::find(s.InventDimId);

                    if (this.isLocationValidForManualReallocation(currentInventDim.wmsLocation()))
                    {
                        locationFound = true;

                        retLocations += [this.buildControl(#RFButton,
                                            WHSWorkExecuteDisplayItemReallocationControls::getItemReallocationForLocationControlName(currentInventDim.wMSLocationId),
                                            currentInventDim.wMSLocationId,
                                            1, '', #WHSRFUndefinedDataType, '', 0)];

                        retLocations += [this.buildControl(#RFLabel,
                                            WHSWorkExecuteDisplayItemReallocationControls::getLocationOnHandInformationControlName(currentInventDim.wMSLocationId),
                                            WHSWorkExecuteDisplayItemReallocationControls::getLocationOnHandInformationControlLabel(itemId, inventDim.inventDimId, s.AvailPhysical),
                                            1, '', #WHSRFUndefinedDataType, '', 0)];

                        locationCounter ++;
                    }
                }

                if (locationFound)
                {
                    if (buildContainerOnlyIfValidLocationsFound)
                    {
                        ret = this.showWarningFromPass(ret);
                        ret += [this.buildControl(#RFLabel,
                                    WHSWorkExecuteDisplayItemReallocationControls::ItemInformationControlName,
                                    WHSWorkExecuteDisplayItemReallocationControls::getItemInformationControlLabel(
                                                                                        itemId,
                                                                                        inventDim,
                                                                                        pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::TotalWorkLineInventQty),
                                                                                        _remainingQtyToReallocate,
                                                                                        reservedQtyForReallocation),
                                    1, '', #WHSRFUndefinedDataType, '', 0)];

                        ret += [this.buildControl(#RFLabel,
                                    WHSWorkExecuteDisplayItemReallocationControls::AvailQtyInLocationsForReallocationControlName,
                                    WHSWorkExecuteDisplayItemReallocationControls::getAvailQtyInLocationsForReallocationControlLabel(),
                                    1, '', #WHSRFUndefinedDataType, '', 0)];
                    }

                    ret += retLocations;

                    if (locationCounter >= MaximumNumberOfLocations && rsl.next(s))
                    {
                        this.addMaximumNumberOfLocationsToReallocateMessageLog(_reallocationParams.getShortPickedWorkLine());

                        ret += [this.buildControl(#RFLabel,
                                    WHSWorkExecuteDisplayItemReallocationControls::MaximumNumberOfLocationsExceededControlName,
                                    WHSWorkExecuteDisplayItemReallocationControls::getMaximumNumberOfLocationsExceededControlLabel(itemId),
                                    1, '', #WHSRFUndefinedDataType, '', 0)];
                    }

                    ret += [this.buildControl(#RFButton,
                                WHSWorkExecuteDisplayItemReallocationControls::ProceedControlName,
                                WHSWorkExecuteDisplayItemReallocationControls::ProceedControlLabel,
                                1, '', #WHSRFUndefinedDataType, '', 0)];
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocationValidForManualReallocation</Name>
				<Source><![CDATA[
    private boolean isLocationValidForManualReallocation(WMSLocation _location)
    {
        return !_location.isPackingLocation()
            && !_location.isSortingLocation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMaximumNumberOfLocationsToReallocateMessageLog</Name>
				<Source><![CDATA[
    private void addMaximumNumberOfLocationsToReallocateMessageLog(WHSWorkLine _workLineToBeReallocated)
    {
        WHSMobileDeviceActivityLogger::newStandard(pass.lookupStr(#UserId), mode)
            .append(strFmt("@WAX:OnlyTheFirst120LocationsToReallocateAreDisplayed", _workLineToBeReallocated.ItemId), _workLineToBeReallocated.WorkId)
            .save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeItemReallocationKeysFromPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all the keys related to the item reallocation process from the pass object.
    /// </summary>
    protected void removeItemReallocationKeysFromPass()
    {
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::TotalWorkLineInventQty);
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::TotalReallocatedQty);
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired);
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::ShortPickedWorkLineRecId);
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess);
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeShortPickConfirmationStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Completes the short picking confirmation step based on the selected work exception. Runs the automatic reallocation
    /// and the post reallocation updates, if needed, to complete the short picking.
    /// </summary>
    /// <param name = "_con">Container containing the state of the previous form</param>
    /// <param name = "_workExecute">The instance of the <c>WHSWorkExecute</c> class</param>
    /// <returns>Container with a container with the form state after the controls of the next step are added and a boolean
    /// variable indicating if it is necessary to recall or not</returns>
    protected container completeShortPickConfirmationStep(container _con, WhsWorkExecute _workExecute = null)
    {
        WHSItemReallocation reallocationProcess = real2int(pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess));

        container                       ret;
        boolean                         recall;

        if (pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired)
            && (reallocationProcess == WHSItemReallocation::Automatic || reallocationProcess == WHSItemReallocation::AutomaticAndManual))
        {
            WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
            WHSWorkLineAutoReallocatorBase autoReallocator = WHSWorkLineAutoReallocatorBase::newFromParams(workLineReallocationParams);
            if (autoReallocator)
            {
                autoReallocator.reallocateWorkLineHandlingQty();
            }

            [ret, recall] = this.completeAutomaticWorkLineReallocation(_con, workLineReallocationParams, _workExecute);
        }
        else if (reallocationProcess == WHSItemReallocation::Manual || reallocationProcess == WHSItemReallocation::AutomaticAndManual)
        {
            /*
            The manual reallocation list has separate steps to run the reallocation and the needed updates. If it was not possible
            to display the list at all, we continued in the #ShortPickConf step and need to do the updates now.
            */
            WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
            WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
            reallocator.runShortPickConfirmationPostUpdatesHandlingQty(workLineReallocationParams.getInventHandlingQtyToReallocate());
        }

        if (ret == conNull())
        {
            ret = this.determineRestart(_con);

            if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
            {
                throw error("@WAX1459");
            }

            recall = true;
            this.removeItemReallocationKeysFromPass();
        }

        return [ret, recall];
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeShortPickManualReallocationConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to execute short pick and run quantity reallocation.
    /// </summary>
    /// <param name = "_state">The state for processing the work line.</param>
    /// <param name = "_workExecute">An instance of <c>WhsWorkExecute</c>.</param>
    /// <param name = "_manualInitialWorkLineInventQty">The initial inventory quantity of the work line to be short picked.</param>
    /// <param name = "_manualShortPickedWorkLine">The work line to be short picked.</param>
    final protected void executeShortPickManualReallocationConfirmation(
        WhsWorkProcessWorkLineState _state,
        WhsWorkExecute              _workExecute,
        InventQty                   _manualInitialWorkLineInventQty,
        WHSWorkLine                 _manualShortPickedWorkLine)
    {
        boolean mustCaptureMoreDims = this.buildNextDimensionCaptureControl(conNull(), this.createInventDimFromPass(), pass.lookupStr(#ItemId), pass.lookupNum(#QtyToPick)) != conNull();

        workLine = _workExecute.executeShortPick(pass.lookup(#WorkId),
                                            pass.parmLineNum(),
                                            pass.lookup(#ShortPickReason),
                                            pass.lookupNum(#QtyToPick),
                                            pass.lookup(#UOM),
                                            userId,
                                            pass.exists(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) :
                                                                            pass.lookupStr(#TargetLicensePlateId),
                                            mustCaptureMoreDims,
                                            this.assignSerial(workLine),
                                            true);

        if (   pass.exists(#VoidWaveLabel) && pass.lookup(#VoidWaveLabel) == #RFYes
            && pass.exists(#PrinterName) && pass.lookup(#PrinterName) != '')
        {
            this.reprintWaveLabels(pass);
        }
    
        this.initializePassItemReallocationValues(_manualInitialWorkLineInventQty, _manualShortPickedWorkLine);
    
        WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
        WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
        InventHandlingQty inventQtyToReallocate = workLineReallocationParams.getInventHandlingQtyToReallocate();
        _state.nextForm = conNull();
    
        if (WHSWorkExecuteDisplayItemReallocationControls::isItemReallocationControl(_state.buttonClicked))
        {
            WMSLocationId selectedLocationId = WHSWorkExecuteDisplayItemReallocationControls::getLocationIdFromControl(_state.buttonClicked);
    
            InventHandlingQty reallocatedQty = reallocator.reallocateWorkLineHandlingQuantity(selectedLocationId, inventQtyToReallocate);
            warningLabel = reallocator.parmWarningLabel();

            inventQtyToReallocate -= reallocatedQty;
    
            reallocator.runShortPickConfirmationPostUpdatesHandlingQty(inventQtyToReallocate);
    
            if (inventQtyToReallocate > 0)
            {
                pass.insert(WHSWorkExecuteDisplayItemReallocationControls::TotalReallocatedQty, reallocatedQty);
                _state.nextForm = this.buildManualReallocationList(workLineReallocationParams, inventQtyToReallocate, reallocator, true);
                step = #ManualReallocationList;
            }
        }
        else if (WHSWorkExecuteDisplayItemReallocationControls::isProceedControl(_state.buttonClicked))
        {
            reallocator.runShortPickConfirmationPostUpdatesHandlingQty(inventQtyToReallocate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeManualWorkLineReallocationList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the first step of the manual reallocation list; If it is not applicable to display the list
    /// builds the short pick confirmation display
    /// </summary>
    /// <param name = "_reallocationParams">The work line reallocation parameters</param>
    /// <returns>Container with the form state after the controls of the next step are added</returns>
    protected container initializeManualWorkLineReallocationList(WHSWorkLineReallocationParams _reallocationParams)
    {
        container ret = this.buildManualReallocationList(_reallocationParams, _reallocationParams.getInventHandlingQtyToReallocate());

        if (ret == conNull())
        {
            ret = this.buildShortPickConf(conNull());
            step = #ShortPickConf;
        }
        else
        {
            step = #ManualReallocationListShortPickConf;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeAutomaticWorkLineReallocation</Name>
				<Source><![CDATA[
    private container completeAutomaticWorkLineReallocation(
                                                container                       _con,
                                                WHSWorkLineReallocationParams   _reallocationParams = null,
                                                WhsWorkExecute                  _workExecute = null)
    {
        if (!_reallocationParams.getShortPickedWorkLine().InventQtyWork)
        {
            workLine = _workExecute.getFirstOpenLine(_reallocationParams.getShortPickedWorkLine().WorkId, userId);
        }

        if (WHSShortPickDeleteZeroLoadLinesAutoReallocV2Flight::instance().isEnabled())
        {
            WHSLoadLine::deleteZeroLoadLines(_reallocationParams.getShortPickedWorkLine().WorkId);
        }

        container ret = this.determineRestart(_con);
        boolean recall = true;
        this.removeItemReallocationKeysFromPass();

        return [ret, recall];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePassItemReallocationValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the key-values of the pass object which are needed for the item reallocation.
    /// </summary>
    /// <param name = "_initialWorkLineInventQty">The initial inventory quantity of the work line to be short picked</param>
    /// <param name = "_workLineToShortPick">The work line to be short picked</param>
    protected void initializePassItemReallocationValues(InventQty _initialWorkLineInventQty, WHSWorkLine _workLineToShortPick)
    {
        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        InventQty shortPickInventQty = releasedProductUnitConverter.convert(pass.lookupNum(#QtyToPick),
                                                          UnitOfMeasure::unitOfMeasureIdBySymbol(pass.lookup(#UOM)),
                                                          UnitOfMeasure::unitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(_workLineToShortPick.ItemId)),
                                                          NoYes::No,
                                                          _workLineToShortPick.ItemId,
                                                          _workLineToShortPick.InventDimId,
                                                          NoYes::No);

        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::InventPickQtyFromInitialLocation, shortPickInventQty);
        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::TotalWorkLineInventQty, _initialWorkLineInventQty);
        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::TotalReallocatedQty, 0);
        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::ShortPickedWorkLineRecId, _workLineToShortPick.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeShortPickStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Completes the #ShortPick step, determines if automatic or manual reallocation need to be run in the following
    /// steps and updates the display accordingly.
    /// </summary>
    /// <param name = "_con">Container containing the state of the previous form</param>
    /// <param name = "_workLineToShortPick">The work line to be short picked</param>
    /// <returns>Container with the form state after the controls of the next step are added</returns>
    protected container completeShortPickStep(container _con, WHSWorkLine _workLineToShortPick)
    {
        WHSWorkException    workException = WHSWorkException::find(pass.lookup(#ShortPickReason), WHSExceptionType::ShortPick);
        WHSItemReallocation reallocationProcess = WHSWorkLineReallocatorBase::determineItemReallocation(workException, WHSWorkUser::find(pass.lookupStr(#UserId)), WHSWorkTable::find(_workLineToShortPick.WorkId));

        container                       ret;
        WHSWorkLineReallocationParams   workLineReallocationParams;

        // Reallocation is not supported during short picking of grouped work lines.
        if (pass.isGroupPick()
            && reallocationProcess != WHSItemReallocation::None)
        {
            reallocationProcess = WHSItemReallocation::None;
            ret = this.addErrorLabel(ret, "@WAX:ReallocationUnsupportedForGroupPicking", WHSRFColorText::Success);
        }

        // Automatic reallocation is not supported during short picking of work line with order-committed reservation.
        // "Automatic and manual" reallocation is forcefully using Manual reallocation skipping an attempt to automatically reallocate.
        if (_workLineToShortPick.OrderCommittedInventDimId)
        {
            if (reallocationProcess == WHSItemReallocation::Automatic)
            {
                throw error("@WAX:Error_AutomaticReallocationNotSupportedForFlexReservation");
            }

            if (reallocationProcess == WHSItemReallocation::AutomaticAndManual)
            {
                reallocationProcess = WHSItemReallocation::Manual;
            }
        }
        
        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired, 0);
        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess, reallocationProcess);
        
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);

        switch (reallocationProcess)
        {
            case WHSItemReallocation::None:
                ret = this.buildShortPickConf(ret);
                step = #ShortPickConf;

                break;
            case WHSItemReallocation::AutomaticAndManual:
                this.initializePassItemReallocationValues(_workLineToShortPick.InventQtyWork, _workLineToShortPick);
                workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                WHSWorkLineAutoReallocatorBase autoReallocator = WHSWorkLineAutoReallocatorBase::newFromParams(workLineReallocationParams);
                InventHandlingQty qtyThatCanBeAutoReallocated = autoReallocator.calculateHandlingQtyThatCanBeAutoReallocated();
                if (qtyThatCanBeAutoReallocated == workLineReallocationParams.getInventHandlingQtyToReallocate())
                {
                    pass.insert(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired, 1);
                    ret = this.buildShortPickConf(conNull());
                    step = #ShortPickConf;
                }
                else
                {
                    ret = this.initializeManualWorkLineReallocationList(workLineReallocationParams);
                }
                break;
            case WHSItemReallocation::Manual:
                this.initializePassItemReallocationValues(_workLineToShortPick.InventQtyWork, _workLineToShortPick);
                workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                ret = this.initializeManualWorkLineReallocationList(workLineReallocationParams);
                break;
            case WHSItemReallocation::Automatic:
                this.initializePassItemReallocationValues(_workLineToShortPick.InventQtyWork, _workLineToShortPick);
                pass.insert(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired, 1);
                ret = this.buildShortPickConf(conNull());
                step = #ShortPickConf;

                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preparePassForCaptureTrackingDimsAfterShortPicking</Name>
				<Source><![CDATA[
    private void preparePassForCaptureTrackingDimsAfterShortPicking(int _previousStep, WhsWorkProcessWorkLineState _state, WHSRfPassthrough _prevPass, WHSWorkLine _shortPickedWorkLine)
    {
        // Update the pass being used to build up the pick screen so that already entered values are used.
        pass = WHSRFPassthrough::create(conPeek(_state.previousForm, 2));
        pass.insert(#PrevStep, _previousStep);
        pass.remove(#DimTrackingDelay);
        pass.insert(#TargetLicensePlateId, _prevPass.lookupStr(#TargetLicensePlateId));
        pass.insert(#LicensePlateId, _prevPass.lookupStr(#LicensePlateId));
        _state.previousForm = conPoke(_state.previousForm, 2, pass.pack());

        _state.nextForm = this.determineRestart(_state.previousForm);

        if (step != #Restart && _shortPickedWorkLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), _shortPickedWorkLine.WorkClassId))
        {
            throw error("@WAX1459");
        }

        _state.recall = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completePickStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Completes the #Pick step, runs either the automatic reallocation or the manual reallocation if it is
    /// needed and updates the display accordingly.
    /// </summary>
    /// <param name = "_con">Container containing the state of the previous form</param>
    /// <param name = "_workExecute">The instance of the <c>WHSWorkExecute</c> class</param>
    /// <returns>Container with a container with the form state after the controls of the next step are added and a boolean
    /// variable indicating if it is necessary to recall or not</returns>
    protected container completePickStep(container _con, WhsWorkExecute _workExecute)
    {
        container   ret;
        boolean     recall;

        if (pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired))
        {
            [ret, recall] = this.completeShortPickConfirmationStep(_con, _workExecute);
        }
        else
        {
            ret = this.determineRestart(_con);
            recall = true;
            this.removeItemReallocationKeysFromPass();
        }
        pass.remove(#AssignSerial);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);
        pass.remove(WHSWorkExecuteDisplayVerificationControls::BatchVerification);
        pass.remove(WHSWorkExecuteDisplayVerificationControls::SerialVerification);
        pass.remove(WHSWorkExecuteDisplayVerificationControls::SkipLPVerification);
        
        return [ret, recall];
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupManualReallocationListDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up the manual reallocation list display and updates the pass object.
    /// </summary>
    /// <param name = "_con">Container containing the state of the previous form</param>
    /// <returns>Container with a container with the form state after the controls of the next step are added and a boolean
    /// variable indicating if it is necessary to recall or not</returns>
    protected container cleanupManualReallocationListDisplay(container _con = conNull())
    {
        container ret = this.determineRestart(_con);
        boolean recall = true;
        pass.remove(#QtyToPick);
        pass.remove(#AssignSerial);
        this.removeItemReallocationKeysFromPass();

        if (warningLabel)
        {
            pass.insert(WHSWorkExecuteDisplayItemReallocationControls::WarningLabel, warningLabel);
            warningLabel = '';
        }

        return [ret, recall];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreateReceivingWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deprecated method for determining if receiving work can be created. Extenders should move their code to wrap validateCreateReceivingWorkForOrderLine.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line to be received.
    /// </param>
    /// <returns>
    /// True if work can be created, otherwise false.
    /// </returns>
    [SysObsolete('Logic has been moved to validateCreateReceivingWorkForOrderLine', false, 13\07\2022)]
    protected boolean validateCreateReceivingWork(PurchLine _purchLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreateReceivingWorkForOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if receiving work can be created
    /// </summary>
    /// <param name = "_receiptOrderLine"> The inbound order line to be received.</param>
    /// <returns>True if work can be created; otherwise false.</returns>
    protected boolean validateCreateReceivingWorkForOrderLine(WHSReceiptOrderLine _receiptOrderLine)
    {
        boolean ret;

        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (_receiptOrderLine is PurchLine)
        {
            ret = this.validateCreateReceivingWork(_receiptOrderLine as PurchLine);

            // If an extender failed the validation, return now.
            if (!ret)
            {
                return ret;
            }
        }

        // Perform ASN item blocking validation.
        if (pass.exists(#SkipASNItemValidation)
        &&  pass.lookupStr(#SkipASNItemValidation) == _receiptOrderLine.InventTransId)
        {
            ret = true;
        }
        else
        {
            WHSASNItem  asnItem;
            WHSLoadLine loadLine;

            select firstOnly RecId from asnItem
                exists join loadLine
                    where loadLine.RecId         == asnItem.LoadLineRefRecId
                    &&    loadLine.InventTransId == _receiptOrderLine.InventTransId;

            if (asnItem.RecId != 0)
            {
                if (WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).BlockReceivingASNItem == NoYes::Yes)
                {
                    ret = checkFailed("@WAX:MustUseLPReceiving");
                }
                else
                {
                    pass.insert(#SkipASNItemValidation, _receiptOrderLine.InventTransId);
                    ret = checkFailed(strFmt("@WAX:ShouldUseLPReceiving", "@SYS5473"));
                }
            }
            else
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVendorBatchDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes input gathered from the vendor batch details RF screen.
    /// </summary>
    /// <param name="_hasError">
    /// A boolean indicating if an error was passed on from the previous run.
    /// </param>
    /// <param name="_con">
    /// The display container having the input data which was passed to the caller.
    /// </param>
    /// <param name="_fieldValues">
    /// The <c>WHSRFPassthrough</c> instance with the values of the input fields from the first step onwards.
    /// </param>
    /// <returns>
    /// A container having the following fields,
    /// <list>
    /// <item>a boolean which indicates if an error occurred,</item>
    /// <item>and the container having the controls for the next step.</item>
    /// </list>
    /// </returns>
    protected container processVendorBatchDetails(
                            boolean                     _hasError,
                            container                   _con,
                            WHSRFPassthrough            _fieldValues)
    {
        boolean                     hasError = _hasError;
        container                   ret;
        container                   tmpFieldValues;
        int                         attemptNum = 1;
        boolean                     complete;

        if (_hasError)
        {
            _con = conDel(_con, #RFErrorLoc, 1);
        }

        [_con, tmpFieldValues] = WHSRFControlData::processData(_con, pass);
        _fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, _fieldValues);
        hasError = this.hasError(_con);

        if (hasError)
        {
            ret = _con;
            ret = this.rebuildUseVendBatchDates(ret);
            return [true, ret];
        }

        _con = this.buildGetVendBatchDetails(ret);

        if (!_fieldValues.empty())
        {
            attemptNum = pass.lookup(#VendBatchAttemptNo);

            [ret, complete] = this.processFieldValues(_con, _fieldValues);

            // If all vendor batch information has been entered, or the maximum number of attempts has been reached, revert back to step 3.
            if ((complete
                &&   pass.lookup(#UseVendBatchDate) != ''
                &&   pass.lookup(#UseVendExpDate)   != '')
                ||  (!pass.exists(#Initiation)
                &&   attemptNum                     == #MaxVendBatchAttempts))
            {
                pass.insert(#VendBatchInfoEntered, 1);

                // When moving to the previous step, validate the selected value rather than the element string.
                if (this.displayBatchDisposition())
                {
                    pass.insert(#UseSelectedBatchDispCode, 1);
                }

                pass.insert(#UseSelectedDimUOM, 1);

                // Skip the potency validation during the next step.
                if (this.capturePotency())
                {
                    pass.insert(#SkipPotencyValidation, 1);
                }

                step = #TrackingDimDetailsStep;

                ret = conNull();
                ret = this.buildPORecTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimQty));
                ret = this.updateModeStepPass(ret, mode, step, pass);
                ret = this.displayForm(ret);
            }
            // If the vendor batch details form is not complete, but data has been entered, reset the number of attempts and display the form again.
            else if (pass.exists(#Initiation))
            {
                pass.remove(#Initiation);

                if (attemptNum != 1)
                {
                    pass.insert(#VendBatchAttemptNo, 1);
                }
            }
            // If no data has been added or changed, display a warning to the user that fields have been left blank.
            else
            {
                ret = conNull();
                ret = this.addErrorLabel(ret, "@WAX5514", WHSRFColorText::Warning);
                ret = this.buildGetVendBatchDetails(ret);

                attemptNum++;

                pass.insert(#VendBatchAttemptNo, attemptNum);
            }
        }

        return [false, ret];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processItemIdForTransferOrderItemReceiving</Name>
				<Source><![CDATA[
    protected boolean processItemIdForTransferOrderItemReceiving(WhsControl _control)
    {
        var fieldValues = _control.parmContext().fieldValues;
        var controlData = _control.parmContext().controlData;
        
        InventInventItemSearch          localInventItemSearch       = InventInventItemSearch::construct();
        InventInventItemSearchResult    localInventItemSearchResult = localInventItemSearch.search(_control.parmData());
        Qty                             itemQty                     = localInventItemSearchResult.parmQty();
        InventDim                       itemInventDim               = InventDim::find(localInventItemSearchResult.parmInventDimId());
            
        if (!controlData.validateItemOnTOLine(fieldValues.parmItemId(), itemInventDim))
        {
            fieldValues.parmItemId('');
            return _control.fail("@SYP4980009");
        }
                
        if (pass.exists(#TONum) && InventTransferLine::getLineNumberByItemOrdered(pass.lookup(#TONum), fieldValues.parmItemId(), itemInventDim) == 0 && !workLine)
        {
            fieldValues.parmItemId('');
            return _control.fail("@WAX3860");
        }

        if (itemInventDim.anyProductDimensionSpecified())
        {
            pass.insert(#ItemInventDimId, itemInventDim.inventDimId);
        }

        if (itemQty)
        {
            controlData.qtyDefaultedFromScan = true;
            fieldValues.insert(#Qty, itemQty);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processItemIdForLoadItemReceiving</Name>
				<Source><![CDATA[
    protected boolean processItemIdForLoadItemReceiving(WhsControl _control)
    {
        var fieldValues = _control.parmContext().fieldValues;
        var controlData = _control.parmContext().controlData;
        
        InventInventItemSearch          localInventItemSearch       = InventInventItemSearch::construct();
        InventInventItemSearchResult    localInventItemSearchResult = localInventItemSearch.search(_control.parmData());
        Qty                             itemQty                     = localInventItemSearchResult.parmQty();
        InventDim                       itemInventDim               = InventDim::find(localInventItemSearchResult.parmInventDimId());
            
        if (itemInventDim.anyProductDimensionSpecified())
        {
            pass.insert(#ItemInventDimId, itemInventDim.inventDimId);
        }
        if (_control.parmEnabled())
        {
            WHSLoadItemReceivingOrderLineProvider orderLineProvider = controlData.loadItemReceivingOrderLineProvider(pass.lookup(#LoadId), fieldValues.parmItemId(), itemInventDim);
            orderLineProvider.allowLoadOverreceipt = !WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).blockLoadLineQuantityOverreceipt();

            if (!orderLineProvider.itemExistsOnLoad() || !orderLineProvider.isReceiptPossible())
            {
                fieldValues.parmItemId('');

                if (orderLineProvider.allLinesBlockedByLoadOverdelivery())
                {
                    return _control.fail("@WAX:ItemAlreadyReceivedOnAllLoadLines");
                }
                    
                return _control.fail("@WAX3627");
            }

            var purchLine = orderLineProvider.suggestedOrderLine() as PurchLine;
            if (purchLine)
            {
                fieldValues.parmPurchId(purchLine.PurchId);
            }
        }

        if (itemQty)
        {
            controlData.qtyDefaultedFromScan = true;
            fieldValues.insert(#Qty, itemQty);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processItemIdForPurchaseOrderItemReceiving</Name>
				<Source><![CDATA[
    protected boolean processItemIdForPurchaseOrderItemReceiving(WhsControl _control)
    {
        var fieldValues = _control.parmContext().fieldValues;
        var controlData = _control.parmContext().controlData;
        
        InventInventItemSearch          localInventItemSearch       = InventInventItemSearch::construct();
        InventInventItemSearchResult    localInventItemSearchResult = localInventItemSearch.search(_control.parmData());
        Qty                             itemQty                     = localInventItemSearchResult.parmQty();
        InventDim                       itemInventDim               = InventDim::find(localInventItemSearchResult.parmInventDimId());
            
        boolean ret;

        WHSDeferredReceivingPolicyId deferredReceivingPolicyId =  pass.exists(#MenuItem) ? WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).DeferredReceivingPolicyId : '';
        boolean useDeferredReceivingContext = deferredReceivingPolicyId
            && (WHSDeferredReceivingPolicy::find(deferredReceivingPolicyId).DeferredReceivingPolicySelection != WHSDeferredReceivingPolicySelectionEnum::Never);
            
        using (var context = useDeferredReceivingContext ? WHSDeferredReceivingContext::construct() : null)
        {
            ret = this.validateItemIdForInboundOrderItemReceiving(_control, itemInventDim);
        }

        if (ret
            && itemQty)
        {
            controlData.qtyDefaultedFromScan = true;
            fieldValues.insert(#Qty, itemQty);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateItemIdForInboundOrderItemReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the item ID or product variant is valid for inbound order receiving.
    /// </summary>
    /// <param name = "_control">Mobile device control</param>
    /// <param name = "_itemInventDim">An <c>InventDim</c> buffer containing product dimensions.</param>
    /// <returns>true if the item ID or product variant is valid for inbound order receiving; otherwise, false.</returns>
    private boolean validateItemIdForInboundOrderItemReceiving(WhsControl _control, InventDim _itemInventDim)
    {
        boolean ret = true;

        WHSRFPassthrough fieldValues = _control.parmContext().fieldValues;
        WhsrfControlData controlData = _control.parmContext().controlData;

        var orderProvider = this.receivingOrderProvider();
        if (!controlData.validateItemOnReceiptOrderLine(orderProvider.orderNum(pass), fieldValues.parmItemId(), _itemInventDim, orderProvider.inventTransType()))
        {
            fieldValues.parmItemId('');
            ret = _control.fail("@SYP4980009");
        }
        else if (orderProvider.hasOrderNum(pass))
        {
            TradeLineNumber lineNum = controlData.getInboundOrderLineNumByItem(orderProvider.orderNum(pass), fieldValues.parmItemId(), _itemInventDim, orderProvider.inventTransType());

            if (lineNum == 0)
            {
                fieldValues.parmItemId('');
                ret = _control.fail(strFmt("%1\n%2", "@SYP4980046", "@SYP4980047"));
            }
            else
            {
                WHSReceiptOrderLine orderLine = orderProvider.orderLine(pass, lineNum);
                ret = this.validateInboundOrderLineForInboundOrderItemReceiving(_control, orderLine);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInboundOrderLineForInboundOrderItemReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the inbound order line is valid for inbound order receiving.
    /// </summary>
    /// <param name = "_control">Mobile device control.</param>
    /// <param name = "_orderLine">A <c>WHSReceiptOrderLine</c> record.</param>
    /// <returns>true if the inbound line is valid for inbound order receiving; otherwise, false.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal boolean validateInboundOrderLineForInboundOrderItemReceiving(WhsControl _control, WHSReceiptOrderLine _orderLine)
    {
        WhsrfControlData controlData = _control.parmContext().controlData;

        if (controlData.inboundOrderLineHasMoreThanOneLoadLine(_orderLine))
        {
            WHSRFPassthrough fieldValues = _control.parmContext().fieldValues;
            
            fieldValues.parmItemId('');
            return _control.fail(strFmt("%1\n%2", "@WAX:InboundOrderLineOnMoreThanOneLoad", "@SYP4881106"));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processItemIdForReturnOrderReceiving</Name>
				<Source><![CDATA[
    protected boolean processItemIdForReturnOrderReceiving(WhsControl _control)
    {
        var fieldValues = _control.parmContext().fieldValues;
        var controlData = _control.parmContext().controlData;
        
        InventInventItemSearch          localInventItemSearch       = InventInventItemSearch::construct();
        InventInventItemSearchResult    localInventItemSearchResult = localInventItemSearch.search(_control.parmData());
        Qty                             itemQty                     = localInventItemSearchResult.parmQty();
        InventDim                       itemInventDim               = InventDim::find(localInventItemSearchResult.parmInventDimId());
            
        if (!controlData.validateItemOnReturnOrder(fieldValues.parmItemId()))
        {
            fieldValues.parmItemId('');
            return _control.fail("@WAX3272");
        }

        if (itemQty)
        {
            controlData.qtyDefaultedFromScan = true;
            fieldValues.insert(#Qty, itemQty);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkTableToTransportLoad</Name>
				<Source><![CDATA[
    private void addWorkTableToTransportLoad(WHSWorkId _workId)
    {
        if (pass.exists(WHSWorkExecuteDisplayTransportLoadingControls::TransportLoadId))
        {
            WHSTransportLoadCreator transportLoadCreator = WHSTransportLoadCreator::newFromTransportLoadId(pass.lookup(WHSWorkExecuteDisplayTransportLoadingControls::TransportLoadId));
            transportLoadCreator.addWorkTableToNewOrFoundTransportLoad(_workId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQtyForNextLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unitizes quantity of an item for the license plate grouping policy when the license plate generation is generated manually.
    /// </summary>
    /// <param name="_pass">
    /// The map that stores the current data  for the generation of next license plate.
    /// </param>
    /// <param name="_itemId">
    /// The item which is used for unitization.
    /// </param>
    /// <param name="_inventDimId">
    /// Inventory combination of  dimension  for the item which is being used for the unitization for the next license plate.
    /// </param>
    /// <returns>
    /// Container containing the final quantity and unit of measure.
    /// </returns>
    protected container unitizeQtyForNextLicensePlate(
                            WHSRFPassthrough _pass,
                            ItemId  _itemId,
                            InventDimId _inventDimId)
    {
        int                 numLP;
        Qty                 finalQty;
        UnitOfMeasureSymbol finalUnitId;
        
        if (_pass.parmUnitization() == WHSLicensePlateGroupingPolicy::UserDefined)
        {
            finalQty    = 1;
            finalUnitId = _pass.lookup(#UOM);
        }
        else if ((_pass.parmUnitization()   == WHSLicensePlateGroupingPolicy::None)
                || (_pass.parmUnitization() == WHSLicensePlateGroupingPolicy::LicensePlateGrouping))
        {
            [numLP, finalQty, finalUnitId] = WHSWorkCreateReceiving::unitizeQuantity(
                                                                        _itemId,
                                                                        _pass.lookupNum(#RunningQty),
                                                                        WHSRFMenuItemTable::find(_pass.lookup(#MenuItem)).Unitization,
                                                                        _inventDimId);

        }

        return [finalQty, finalUnitId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCountingReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will check if the reason code is mandatory.
    /// </summary>
    /// <param name = "_itemId">
    /// The current item being counted.
    /// </param>
    /// <param name = "_inventDimId">
    /// The inventory dimensions of the item being counted.
    /// </param>
    protected void validateCountingReasonCode(ItemId _itemId, InventDimId _inventDimId)
    {
        WHSMobileDeviceMenuItemCountingReasonCodeValidator::newFromParameters(pass, _inventDimId, mode, _itemId)
            .validateCountingReasonCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeProcessDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for executing the process - to be subscribed by alternate implementations of WHSWorkExecuteDisplay classes.
    /// </summary>
    /// <param name = "_parameters">Parameters required for the process to be executed.</param>
    /// <param name = "_result">
    /// The result of execution of the process.
    /// </param>
    static delegate void executeProcessDelegate(WHSExecuteProcessParameters _parameters, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>callExecuteProcessDelegate</Name>
				<Source><![CDATA[
    static void callExecuteProcessDelegate(WHSExecuteProcessParameters _parameters, EventHandlerResult _result)
    {
        WhsWorkExecuteDisplay::executeProcessDelegate(_parameters, _result);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowPickDetailsConfirmationBeDisplayed</Name>
				<Source><![CDATA[
    protected boolean mustShowPickDetailsConfirmationBeDisplayed()
    {
        boolean showPickDetailsConfirmation;
        WHSRFAutoConfirm rfAutoConfirm = WHSRFAutoConfirm::find(pass.lookup(#MenuItem), WHSWorkType::Pick);

        if (rfAutoConfirm
            && rfAutoConfirm.ShowPickDetails == NoYes::Yes
            && workLine.WorkType == WHSWorkType::Pick
            && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
        {
            showPickDetailsConfirmation = true;

            // Product confirmation is enabled but user has not provided any input.
            if (rfAutoConfirm.ProductConfirmation == NoYes::Yes
                && pass.lookupStr(#ProductConfirmation) == '')
            {
                showPickDetailsConfirmation = false;
            }

            // Location confirmation enabled but user has not provided any input.
            if (showPickDetailsConfirmation
                && rfAutoConfirm.LocVerification == NoYes::Yes
                && pass.lookupStr(#CheckDigit) == ''
                && pass.lookupStr(#LocVerification) == '')
            {
                showPickDetailsConfirmation = false;
            }

            // Batch confirmation is enabled but user has not provided any input.
            if (showPickDetailsConfirmation
                && rfAutoConfirm.BatchVerification == NoYes::Yes
                && WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(InventTable::find(workLine.ItemId))
                && pass.lookupStr(WHSWorkExecuteDisplayVerificationControls::BatchVerification) == '')
            {
                showPickDetailsConfirmation = false;
            }

            // Serial confirmation is enabled but user has not provided any input.
            if (showPickDetailsConfirmation
                && rfAutoConfirm.SerialVerification == NoYes::Yes
                && WHSReservationHierarchyInventDimUtil::isSerialAboveLocation(InventTable::find(workLine.ItemId))
                && pass.lookupStr(WHSWorkExecuteDisplayVerificationControls::SerialVerification) == '')
            {
                showPickDetailsConfirmation = false;
            }
        }

        return showPickDetailsConfirmation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueTrackingDimCaptureForSameLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if tracking dimensions should continue to be captured.
    /// </summary>
    /// <returns>true if tracking dimensions should continue to be captured; otherwise, false</returns>
    protected boolean continueTrackingDimCaptureForSameLine()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsPotency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if potency needs to be captured.
    /// </summary>
    /// <returns>true if potency needs to be captured; otherwise, false</returns>
    protected boolean needsPotency()
    {
        return pass.exists(#BatchId)
            && this.capturePotency(pass.lookup(#ItemId))
            && !pass.exists(#Potency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>serialAssignmentNeeded</Name>
				<Source><![CDATA[
    protected boolean serialAssignmentNeeded()
    {        
        return this.isWorkSerialNumberAssigmentEnabled()
               && workLine.WorkType == WHSWorkType::Pick
               && !pass.exists(#AssignSerial)
               && !this.isWorkLineSerialValidated(workLine)
               && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
               && WHSInventTable::captureSerial(workLine.ItemId) == WHSRFWhenToCapture::Picking
               && (InventTable::find(workLine.ItemId).isItemSerialNumberActivated()
                   || workLine.isActiveInSalesSerialProcess());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkSerialNumberAssigmentEnabled</Name>
				<Source><![CDATA[
    protected boolean isWorkSerialNumberAssigmentEnabled()
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType).isSerialNumberAssignmentEnabled()
            || workLine.isWorkTransTypeSalesCrossDocking(workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCWTagCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the mobile device screen for capturing catch weight tags.
    /// </summary>
    /// <param name = "_con">
    /// The current mobile device container.
    /// </param>
    /// <param name = "_displayCaptureAggregateWeightControl">
    /// Boolean value indicates whether to display the aggregate tag weight control or not.
    /// </param>
    /// <returns>
    /// An updated mobile device container with appropriate mobile device controls.
    /// </returns>
    protected container buildCWTagCapture(container _con, boolean _displayCaptureAggregateWeightControl = true)
    {
        container   ret = _con;

        ret += [this.buildControl(#RFLabel, #Scan, "@WAX:CatchWeightAssignCatchWeightTag", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFLabel,
                                    WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter,
                                    strFmt("@WAX:CatchWeightTagCountOfWhole", pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter), pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty)),
                                    1,
                                    '',
                                    #WHSRFUndefinedDataType,
        '',
                                    0)];

        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateCatchWeightTag)
        {
            if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag))
            {
                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag, NumberSeq::newGetNum(WHSParameters::numRefWHSCatchWeightTagNumber()).num());
            }

            ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag, strFmt("@WAX:MobileDeviceLabelCatchWeightTagX", pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag)), 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        else
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag, "@WAX:MobileDeviceLabelCatchWeightTag", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag), extendedTypeNum(WHSCatchWeightTagNumber), '', 0)];
        }

        if (_displayCaptureAggregateWeightControl && WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)))
        {
            WHSCapturedWeight tagWeight;

            if (mode == WHSWorkExecuteMode::ReturnOrder || mode == WHSWorkExecuteMode::ReturnOrderAndLocate)
            {
                tagWeight = WHSCatchWeightHelper::calculateAverageWeight(1, pass.lookupNum(#Qty), pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight));
            }
            else
            {
                tagWeight = WHSCatchWeightHelper::calculateAverageWeight(1, pass.lookupNum(#QtyReceived), pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight));
            }
            
            ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight, strFmt("@WAX:MobileDeviceLabelCatchWeightTagWeightX", tagWeight), 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        else
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight, "@WAX:CatchWeightTagWeight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight), extendedTypeNum(WHSCapturedWeight), '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineModuleForCWTagCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine functional module in order to create appropriate tags.
    /// </summary>
    /// <param name = "_mode">The work execution type that is running the confirmation.</param>
    /// <returns>The functional module based on the work execution type.</returns>
    private WHSModule determineModuleForCWTagCreation(WHSWorkExecuteMode _mode)
    {
        if (mode    == WHSWorkExecuteMode::TransferOrderItemReceiving
        ||  mode    == WHSWorkExecuteMode::TransferOrderItemReceivingAndLocate
        ||  mode    == WHSWorkExecuteMode::TransferOrderLineReceiving
        ||  mode    == WHSWorkExecuteMode::TransferOrderLineReceivingAndLocate)
        {
            return WHSModule::Transfer;
        }

        return WHSModule::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCWTagCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the catch weight tag capture display step for inbound processes.
    /// </summary>
    /// <param name="_hasError">
    /// True if mobile device screen has an error message; otherwise False.
    /// </param>
    /// <param name="_con">
    /// The current mobile device container being built.
    /// </param>
    /// <returns>
    /// An updated mobile device container.
    /// </returns>
    protected container processCWTagCapture(
        boolean     _hasError,
        container   _con)
    {
        container           ret = _con;
        WHSRFPassthrough    fieldValues = new WHSRFPassthrough(Types::String, Types::String);
        
        if (_hasError)
        {
            ret = conDel(ret, #RFErrorLoc, 1);
        }

        container tmpFieldValues;
        [ret, tmpFieldValues] = WHSRFControlData::processData(ret, pass);
        fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);
        boolean hasError = this.hasError(ret);

        if (hasError)
        {
            return ret;
        }

        if (!fieldValues.empty())
        {
            boolean complete;
            [ret, complete] = this.processFieldValues(ret, fieldValues);

            if (complete)
            {
                WHSReceiptDetails receiptDetails;
                if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId))
                {
                    receiptDetails = WHSReceiptDetails::findByRecId(pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId));
                }

                boolean aggregateWeightCapture = WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId));
                InventQty calcWeight;

                if (aggregateWeightCapture)
                {
                    calcWeight = WHSCatchWeightHelper::calculateAverageWeight(1,
                                                                         pass.lookupNum(#QtyReceived) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQtySum),
                                                                         pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeightSum),
                                                                         InventTable::inventDecimals(pass.lookup(#ItemId)));

                    // In case of Last tag the remainder weight is assigned to the last tag. Else, we need to increase the tag counter and the total weight of registered tags.
                    if (1 != (pass.lookupNum(#QtyReceived) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQtySum)))
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQtySum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQtySum) + 1);
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeightSum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeightSum) + calcWeight);
                    }
                }

                WHSCapturedWeight capturedWeight = aggregateWeightCapture ? calcWeight : pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);

                WHSModule module = this.determineModuleForCWTagCreation(mode);
                Common common;
                WHSCatchWeightTag tag;

                if (module == WHSModule::Purch)
                {
                    common = this.receivingOrderLine(pass);
                }
                else if (module == WHSModule::Transfer)
                {
                    common = InventTransferLine::find(pass.lookup(#TONum),pass.lookupInt64(#TOLineNum));
                    
                    ttsbegin;
                    
                    tag = WHSCatchWeightTag::find(pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag), true);

                    // In case of receiving a transfer order if the captured weight is different from the tags actual weight,
                    // then perform doUpdate and the weight updation will be logged as part of TagRegistration event which is raised later.
                    if (tag.RecId && tag.CapturedWeight != capturedWeight)
                    {
                        tag.CapturedWeight = capturedWeight;
                        tag.doUpdate();
                    }

                    ttscommit;
                }
                
                // In case of transfer receive - if the tag already exists, then register it with the new transfer line reference.
                // This will enable tracking of tags across WHS enabled warehouse and Non-WHS enabled warehouses scenarios.
                WHSCatchWeightTagCollection tagList;

                if (tag.RecId && module == WHSModule::Transfer)
                {
                    InventTransferLine transferLine = common;
                    WHSCatchWeightTagEventRegistration tagRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(
                                                                                        WHSCatchWeightTagRegistrationEvent::TagRegistered);
                    tagRegistration.parmInventTransId(transferLine.InventTransId);
                    tagRegistration.registerEvent(tag);
                }
                else
                {
                    // Create catch weight tag record
                    WHSCatchWeightTagCreationSource tagSource = WHSCatchWeightTagCreationSource::instantiateFromSource(common, pass);
                    tagSource.parmReceiptDetailsRecId(receiptDetails.RecId);
                    WHSCatchWeightTagCreationMethod tagMethod = WHSCatchWeightTagCreationMethod::newSingleTagCreation(
                                        pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag),
                                        capturedWeight);

                    WHSCatchWeightTagCreator tagCreator = WHSCatchWeightTagCreator::construct();
                    tagList = tagCreator.createCatchWeightTags(tagSource, tagMethod);
                    // Expecting only one tag to have been created.
                    tag = tagList.getCollectionIterator().value();
                }

                this.trackScannedCatchWeightTags(tag.RecId);
                WHSReceiptDetails::updateCapturedWeight(receiptDetails.RecId, capturedWeight);
                
                // Remove current Tag Id and increment Tag Counter
                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag);
                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) + 1));

                // Increment total catch weight value if aggregate weight was not captured earlier
                if (!aggregateWeightCapture)
                {
                    if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight))
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight));
                    }
                    else
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, (pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) + pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight)));
                    }
                }

                // Check to see if all tags have been captured
                if (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) > pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                {
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter);

                    if (this.captureTrackingDimensions(pass.lookup(#ItemId)) && (pass.lookupNum(#DimRunningQty) > 0))
                    {
                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);

                        step = #TrackingDimDetailsStep;
                        ret = conNull();

                        if (module == WHSModule::Purch)
                        {
                            ret = this.buildPORecTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));
                        }
                        else if (module == WHSModule::Transfer)
                        {
                            ret = this.buildTORecTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));
                        }
                    }
                    else
                    {
                        step = 2;
                        ret = [this.buildControl(#RFLabel, #Scan, "@WAX:CatchWeightAssignCatchWeightTag", 1, '', #WHSRFUndefinedDataType, '', 0)];
                        ret = this.updateModeStepPass(ret, mode, step, pass);
                        ret = this.displayForm(ret);

                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList);
                    }
                }
                else
                {
                    // Remove tag weight if aggregate weight was not captured
                    if (!aggregateWeightCapture)
                    {
                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);
                    }

                    ret = conNull();
                    ret = this.buildCWTagCapture(ret);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workIncludesCatchWeightItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a catch weight enabled item exists on current work unit.
    /// </summary>
    /// <returns>
    /// true if no catch weight items exist; Otherwise, false.
    /// </returns>
    protected boolean workIncludesCatchWeightItems()
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled()
            && workLine.WorkId)
        {
            WHSWorkLine         cwWorkLine;
            PdsCatchWeightItem  catchWeightItem;

            select firstOnly RecId from cwWorkLine
                where cwWorkLine.WorkId == workLine.WorkId
                    exists join catchWeightItem
                        where catchWeightItem.ItemId == cwWorkLine.ItemId;

            return cwWorkLine.RecId != 0;
        }
  
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOutboundWeightCapture</Name>
				<Source><![CDATA[
    private container buildOutboundWeightCapture(container _con)
    {
        container ret = _con;

        if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
        {
            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, WHSCatchWeightHelper::calculatePickingQuantity(workLine, pass.createInventDimFromPass()));
        }

        if (WHSInventTable::isCatchWeightTagTracked(workLine.ItemId))
        {
            if (this.canUseFastValidationOnCWTag())
            {
                ret = this.buildFastValidationControlsOnCWTagCapture(ret);
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #Scan, "@WAX:CatchWeightAssignCatchWeightTag", 1, '', #WHSRFUndefinedDataType, '', 0)];

                ret += [this.buildControl(#RFLabel,
                                      WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter,
                                      strFmt("@WAX:CatchWeightTagCountOfWhole", pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter), pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty)),
                                      1,
                                      '',
                                      #WHSRFUndefinedDataType,
                                      '',
                                      0)];

                ret += [this.buildControl(#RFLabel, #ItemId, strFmt("@WAX2007", workLine.ItemId), 1, '', #WHSRFUndefinedDataType, '', 0)];

                ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId);

                ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::OutboundCatchWeightTag, "@WAX:CatchWeightTag", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::OutboundCatchWeightTag), extendedTypeNum(WHSCatchWeightTagNumber), '', 0)];        
            }
        }
        else
        {
            // If item is not catch weight tag tracked it means we are capturing weight per catch weight unit
            ret += [this.buildControl(#RFLabel, #Scan, "@WAX:CaptureWeight", 1, '', #WHSRFUndefinedDataType, '', 0)];

            ret += [this.buildControl(#RFLabel,
                                      WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter,
                                      strFmt("@SYS333411", pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter), pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty)),
                                      1,
                                      '',
                                      #WHSRFUndefinedDataType,
            '',
                                      0)];

            ret += [this.buildControl(#RFLabel, #ItemId, strFmt("@WAX2007", workLine.ItemId), 1, '', #WHSRFUndefinedDataType, '', 0)];

            ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId);

            ret += [this.buildControl(#RFLabel, #Qty, strFmt("@WAX736", 1, WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId)), 1, '', #WHSRFUndefinedDataType, '', 0)];
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight), extendedTypeNum(Qty), '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseFastValidationOnCWTag</Name>
				<Source><![CDATA[
    private boolean canUseFastValidationOnCWTag()
    {
        return workTable.WorkTransType == WHSWorkTransType::Sales
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).RFFastValidation
            && WHSInventTable::isCatchWeightTagTracked(workLine.ItemId)
            && WHSInventTable::catchWeightTagDimensionTrackingMethod(workLine.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFastValidationControlsOnCWTagCapture</Name>
				<Source><![CDATA[
    private container buildFastValidationControlsOnCWTagCapture(container _ret)
    {
        container ret = _ret;
        ret += [this.buildControl(#RFLabel, #ItemId, strFmt("@WAX2007", workLine.ItemId), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId);
        container catchWeighttags = WHSCatchWeightTag::getCatchWeightTags(workLine.ItemId, pass.createInventDimFromPass());

        WHSFastValidationControlsBuildParameters fastValidationControlsBuildParameters = WHSFastValidationControlsBuildParameters::newFromParams(#OutboundCatchWeightTags,
                                                                                                                                                     "@WAX:CatchWeightTags",
                                                                                                                                                     extendedTypeNum(WHSCatchWeightTagNumber),
                                                                                                                                                     catchWeighttags,
                                                                                                                                                     "@WAX:FastValidationMsgScanFailPick",
                                                                                                                                                     "@WAX:FastValidationMsgScanSuccessPick",
                                                                                                                                                     "@WAX:FastValidationMsgScanDuplicatedPick",
                                                                                                                                                     "@WAX:FastValidationTitleListScannedPick",
                                                                                                                                                     "@WAX:FastValidationTitleListToScanPick",
                                                                                                                                                     NoYes::Yes,
                                                                                                                                                     NoYes::Yes);
        fastValidationControlsBuildParameters.scanTitle = "@WAX:WHSScan";
        fastValidationControlsBuildParameters.numOfThingsToScan = min(conLen(catchWeighttags), pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty));
        ret = this.buildFastValidationControls(ret, fastValidationControlsBuildParameters);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>captureWeightPerCatchWeightUnit</Name>
				<Source><![CDATA[
    private boolean captureWeightPerCatchWeightUnit()
    {
        boolean ret;

        if (workLine.ItemId &&
            PdsGlobal::pdsIsCWItem(workLine.ItemId) &&
            !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum) &&
            !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight))
        {
            switch (workTable.WorkTransType)
            {
                case WHSWorkTransType::Sales:
                    ret = WHSInventTable::salesOrderWeightCapturingProcess(workLine.ItemId) == WHSSalesOrderWeightCapturingProcess::Picking
                        && (WHSInventTable::outboundWeightCapturingMethod(workLine.ItemId) == WHSOutboundWeightCapturingMethod::PerCatchWeightUnit
                            || WHSInventTable::isCatchWeightTagTracked(workLine.ItemId));
                    break;

                case WHSWorkTransType::TransferIssue:
                    ret = WHSInventTable::transferIssueWeightCapturingProcess(workLine.ItemId) == WHSTransferIssueWeightCapturingProcess::Picking
                        && (WHSInventTable::outboundWeightCapturingMethod(workLine.ItemId) == WHSOutboundWeightCapturingMethod::PerCatchWeightUnit
                            || WHSInventTable::isCatchWeightTagTracked(workLine.ItemId));
                    break;

                case WHSWorkTransType::ProdPick:
                    ret = WHSInventTable::productionPickingWeightCapturingMethod(workLine.ItemId) == WHSProductionPickingWeightCapturingMethod::PerCatchWeightUnit
                        || WHSInventTable::catchWeightTagDimensionTrackingMethod(workLine.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions;
                    break;

                case WHSWorkTransType::Invent:
                    ret = WHSInventTable::movementWeightCapturingMethod(workLine.ItemId) == WHSMovementWeightCapturingMethod::PerCatchWeightUnit
                            || (WHSInventTable::catchWeightTagDimensionTrackingMethod(workLine.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions
                                && (mode != WHSWorkExecuteMode::MovementByTemplate || WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ScheduleMovement == NoYes::No));
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOutboundWeightCapture</Name>
				<Source><![CDATA[
    private container processOutboundWeightCapture(
        boolean     _hasError,
        container   _con)
    {
        container           ret = _con;
        container           tmpFieldValues;
        WHSRFPassthrough    fieldValues = new WHSRFPassthrough(Types::String, Types::String);
        boolean             hasError;
        boolean             complete;

        if (_hasError)
        {
            ret = conDel(ret, #RFErrorLoc, 1);
        }

        [ret, tmpFieldValues] = WHSRFControlData::processData(ret, pass);
        fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);
        hasError = this.hasError(ret);

        if (hasError)
        {
            if (this.canUseFastValidationOnCWTag())
            {
                ret = this.updateFastValidationIds(ret, WHSCatchWeightTag::getCatchWeightTags(workLine.ItemId, pass.createInventDimFromPass()));
            }

            return ret;
        }

        if (!fieldValues.empty())
        {
            [ret, complete] = this.processFieldValues(ret, fieldValues);

            if (complete)
            {
                int	numOfTagsScanned = pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter);

                WHSCapturedWeight capturedWeight = pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight);

                if (WHSInventTable::isCatchWeightTagTracked(workLine.ItemId))
                {
                    [numOfTagsScanned, capturedWeight] = this.processOutboundWeightCaptureWithTag(numOfTagsScanned, capturedWeight);
                }
                else
                {
                    capturedWeight += pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight);

                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight);

                    numOfTagsScanned += 1;
                }

                // Increment total outbound weight for picking quantity
                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight, capturedWeight);

                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, numOfTagsScanned);
                // Check to see if weight has been captured for total quantity
                if (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) > pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                {
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter);
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);

                    ret = this.buildPostWeightCaptureForm();
                }
                else
                {
                    ret = conNull();
                    ret = this.buildOutboundWeightCapture(ret);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOutboundWeightCaptureWithTag</Name>
				<Source><![CDATA[
    private container processOutboundWeightCaptureWithTag(int _numOfTagsScanned, WHSCapturedWeight _capturedWeight)
    {
        if (this.canUseFastValidationOnCWTag())
        {
            container	catchWeightScannedTagsCon = str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::OutboundCatchWeightTags), #FastValidationListSeparator);
            int			len = conLen(catchWeightScannedTagsCon);

            if ((_numOfTagsScanned + len - 1) > pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
            {
                throw error(strFmt("@WAX:CatchWeightTagsMoreThanRequired", (_numOfTagsScanned + len - 1), pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty)));
            }

            for (int i = 1; i <= len; i++)
            {
                _capturedWeight += this.processOutboundCatchWeightTag(conPeek(catchWeightScannedTagsCon, i));
            }

            pass.remove(WHSWorkExecuteDisplayCatchWeightControls::OutboundCatchWeightTags);

            _numOfTagsScanned += len;
        }
        else
        {
            _capturedWeight += this.processOutboundCatchWeightTag(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::OutboundCatchWeightTag));

            pass.remove(WHSWorkExecuteDisplayCatchWeightControls::OutboundCatchWeightTag);

            _numOfTagsScanned += 1;
        }

        return [_numOfTagsScanned, _capturedWeight];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOutboundCatchWeightTag</Name>
				<Source><![CDATA[
    private WHSCapturedWeight processOutboundCatchWeightTag(WHSCatchWeightTagNumber _tagNumber)
    {
        WHSCatchWeightTag tag = WHSCatchWeightTag::find(_tagNumber);
        WHSCatchWeightTagEventRegistration tagRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(WHSCatchWeightTagRegistrationEvent::OutboundPickingStarted);
        tagRegistration.parmWorkLineRecId(workLine.RecId);
        tagRegistration.registerEvent(tag);

        this.trackScannedCatchWeightTags(tag.RecId);

        return tag.CapturedWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFastValidationIds</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected container updateFastValidationIds(container _ret, container _data)
    {
        int i;
        container control;
        for (i = 1; i <= conLen(_ret); i++)
        {
            control = conPeek(_ret, i);
            if (conPeek(control, #controlType) == #RFFastValidationIds)
            {
                control = conPoke(control, #data, con2Str(_data, #FastValidationListSeparator));
                _ret = conPoke(_ret, i, control);
                return _ret;
            }
        }

        return _ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPostWeightCaptureForm</Name>
				<Source><![CDATA[
    private container buildPostWeightCaptureForm()
    {
        step = #Pick;
        container ret = [this.buildControl(#RFLabel, #Scan, "@WAX:CaptureWeight", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret = this.updateModeStepPass(ret, mode, step, pass);
        ret = this.displayForm(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReceivingExceptionLog</Name>
				<Source><![CDATA[
    protected void createReceivingExceptionLog(WhsWorkExecute _workExecute, WHSUserId _localUserId)
    {
        var orderProvider = this.receivingOrderProvider(false);
        if (!orderProvider)
        {
            orderProvider = new WHSWorkExecuteDisplayReceivingPurchOrderProvider();
        }

        _workExecute.createInboundOrderReceivingException(WHSUOMStructure::findFirstByLicensePlateModule(pass.lookupStr(#LicensePlateId), orderProvider.module()),
                                                    pass.lookup(#ReceivingExceptionDesc),
                                                    _localUserId,
                                                    orderProvider.orderNum(pass),
                                                    orderProvider.lineNum(pass),
                                                    orderProvider.workTransType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForAutoGenerateLPWeight</Name>
				<Source><![CDATA[
    protected boolean promptForAutoGenerateLPWeight()
    {
        boolean ret;

        if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
        &&  !WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId))
        &&  !WHSInventTable::outboundWeightCapturingMethod(pass.lookup(#ItemId))
        &&  !this.captureTrackingDimensions(pass.lookup(#ItemId))
        &&  WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restartForCrossDockInbound</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void restartForCrossDockInbound()
    {
        workTable = workLine.whsWorkTable();
        pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
        pass.insert(#InventLocationId, workTable.InventLocationId);
        pass.insert(#InventSiteId, workTable.InventSiteId);
        pass.insert(#DetermineStep, 1);

        // Similar as in determineRestart, clear tracking dimensions from pass
        // determineRestart uses clearPassBelowLicensePlate for outbound, but for inbound, clear them explicitly, as inbound does not rely on res. hierarchy
        pass.remove(#SerialId);
        pass.remove(#BatchId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForWeight</Name>
				<Source><![CDATA[
    private boolean promptForWeight(boolean _passLPIsTargetLP, boolean _licensePlateControlled)
    {
        boolean ret;

        if (workLine.ItemId &&
            PdsGlobal::pdsIsCWItem(workLine.ItemId) &&
            !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
        {
            switch (workTable.WorkTransType)
            {
                case WHSWorkTransType::Sales:
                    ret = WHSInventTable::salesOrderWeightCapturingProcess(workLine.ItemId) == WHSSalesOrderWeightCapturingProcess::Picking
                        && (pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation)
                        ||  WHSInventTable::outboundWeightCapturingMethod(workLine.ItemId) == WHSOutboundWeightCapturingMethod::PerPickingQty)
                        && !WHSInventTable::isCatchWeightTagTracked(workLine.ItemId);
                    break;

                case WHSWorkTransType::TransferIssue:
                    ret = WHSInventTable::transferIssueWeightCapturingProcess(workLine.ItemId) == WHSTransferIssueWeightCapturingProcess::Picking
                        && (pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation)
                        ||  WHSInventTable::outboundWeightCapturingMethod(workLine.ItemId)   == WHSOutboundWeightCapturingMethod::PerPickingQty)
                        && !WHSInventTable::isCatchWeightTagTracked(workLine.ItemId);
                    break;

                case WHSWorkTransType::ProdPick:
                    ret = WHSInventTable::productionPickingWeightCapturingMethod(workLine.ItemId) == WHSProductionPickingWeightCapturingMethod::PerPickingQty
                        || pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation);
                    break;

                case WHSWorkTransType::Invent:
                    ret = (WHSInventTable::movementWeightCapturingMethod(workLine.ItemId) == WHSMovementWeightCapturingMethod::PerPickingQty
                            || pass.exists(WHSWorkExecuteDisplayShowPickDetailsControls::ShowPickDetailsConfirmation))
                        && (mode != WHSWorkExecuteMode::MovementByTemplate || WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ScheduleMovement == NoYes::No);
                    break;
            }

            // When capturing per catch weight unit, if outbound adjustments enabled and the on-hand is less or equal to the demand then just show the on-hand weight; no need to get each individually.
            if (WHSInventTable::outboundWeightVarianceMethod(workLine.ItemId) == WHSOutboundWeightVarianceMethod::Restrict)
            {
                if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight))
                {
                    // Scheduled work now captures work during status change so this needs to be read-only here
                    if (mode == WHSWorkExecuteMode::MovementByTemplate && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ScheduleMovement == NoYes::Yes)
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::WeightIsReadOnly, 1);
                    }

                    ret = true;
                }
                else if (ret || this.captureWeightPerCatchWeightUnit())
                {
                    InventDim inventDim = workLine.inventDim();
                    str licensePlate = pass.exists(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) : '';
                    // If no TargetLicensePlateId in pass and LicensePlateId in pass is target license plate and pick location is lp controlled, then should skip on-hand check.
                    // If DetermineStep exists in pass, that means it is first step, and if item is license plate controlled, then on hand check should be skipped, since license plate is not specified.
                    if (!_licensePlateControlled
                       || (!pass.exists(#DetermineStep) && licensePlate != '' && !_passLPIsTargetLP
                           && (pass.exists(#TargetLicensePlateId) || licensePlate != workTable.TargetLicensePlateId)))
                    {
                        inventDim.mergeUsedDim(InventDimGroupSetup::newItemId(workLine.ItemId), pass.createInventDimFromPass());

                        if (mode == WHSWorkExecuteMode::MovementByTemplate && pass.hasValue(#FromInventoryStatus))
                        {
                            inventDim.InventStatusId = pass.lookupStr(#FromInventoryStatus);
                        }
  
                        if (!this.isOnHandGreaterThanDemand(inventDim, workLine.ItemId, workLine.InventQtyRemain))
                        {
                            WHSCapturedWeight onHandWeight = WHSInventOnHand::getWorkPhysicalInventByInventDim(workLine.ItemId, inventDim);
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::OutboundWeight, onHandWeight);

                            // Make sure we don't process the work line before prompting or showing weight.
                            if (!WHSWorkExecute::isPotentialOverPick(workTable, workLine, pass.lookupStr(#LicensePlateId)) || !pass.exists(#Initiation))
                            {
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::WeightPrompt, 1);
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::WeightIsReadOnly, 1);
                            }

                            ret = true;
                        }
                    }
                    // Do not show the weight field yet as the user needs to enter more dimensions
                    else if (ret && this.needsAdditionalDimensionInput(workLine.ItemId, inventDim))
                    {
                        ret = false;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsAdditionalDimensionInput</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean needsAdditionalDimensionInput(itemId _itemId, InventDim _inventDim)
    {
        InventTable                         inventTable = InventTable::find(_itemId);
        ListEnumerator                      hierarchyEnumerator;
        WHSReservationHierarchyElementData  hierarchyData;
        FieldId                             dimFieldId;
        boolean                             ret = false;

        hierarchyEnumerator = WHSReservationHierarchyProvider::construct().getDimListBelowLicensePlate(inventTable, WHSReservationHierarchySortOrder::TopDown).getEnumerator();
        while (!ret && hierarchyEnumerator.moveNext())
        {
            hierarchyData = hierarchyEnumerator.current();
            dimFieldId    = hierarchyData.parmDimensionFieldId();
   
            if (!_inventDim.(dimFieldId))
            {
                InventDim tmpInventDim;
                boolean unknown;
                [tmpInventDim, unknown] = this.getDefaultDimValue(_inventDim, dimFieldId, _itemId);

                if (unknown)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUsePieceByPieceConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms item is not catch weight and menu item has piece by piece confirmation enabled.
    /// </summary>
    /// <param name = "_menuItem">
    /// Current menu item being used.
    /// </param>
    /// <param name = "_workType">
    /// Type of work being processed.
    /// </param>
    /// <param name = "_itemId">
    /// Item id being processed.
    /// </param>
    /// <returns>
    /// True if item is not catch weight and piece by piece confirmation is enabled, otherwise false.
    /// </returns>
    protected boolean canUsePieceByPieceConfirmation(
        WHSMenuItemName _menuItem,
        WHSWorkType     _workType,
        ItemId          _itemId)
    {
        return WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(_menuItem, _workType)
               && !PdsGlobal::pdsIsCWItem(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInboundCWTags</Name>
				<Source><![CDATA[
    protected void removeInboundCWTags()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCatchWeightTagFromPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a catch weight tag.
    /// </summary>
    protected void createCatchWeightTagFromPass()
    {
        if (PdsGlobal::pdsIsCWItem(pass.lookupStr(#ItemId)))
        {
            WHSCatchWeightTagCreationManual tagSource = WHSCatchWeightTagCreationManual::construct();
            tagSource.initializeFromParameters(pass.lookupStr(#ItemId), pass.createInventDimFromPass());

            WHSCatchWeightTagCreationMethod tagMethod = WHSCatchWeightTagCreationMethod::construct();
            tagMethod.parmUseNumberSeqForTagCreation(false);
            tagMethod.parmTagNumber(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag));
            tagMethod.parmNumberOfTags(1);
            tagMethod.parmTotalCapturedWeight(pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight));

            WHSCatchWeightTagCreator tagCreator = WHSCatchWeightTagCreator::construct();
            tagCreator.createCatchWeightTags(tagSource, tagMethod);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackScannedCatchWeightTags</Name>
				<Source><![CDATA[
    protected void trackScannedCatchWeightTags(WHSCatchWeightTagRecId _catchWeightTagRecId)
    {
        container cwTagScannedList;

        // Add created catch weight tag record Id to the list in the pass.
        if (pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList))
        {
            // Must avoid lookupStr so we don't start the container with an empty value.
            cwTagScannedList = str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList));
        }

        cwTagScannedList += _catchWeightTagRecId;

        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList, con2Str(cwTagScannedList));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCatchWeightTagScanned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the given catch weight tag record id is in the list of scanned tags.
    /// </summary>
    /// <param name = "_catchWeightTagRecId">The record id for the catch weight tag in <c>WHSCatchWeightTag</c> table.</param>
    /// <returns>true if the given catch weight tag record id is found in the already scanned tags list; otherwise, false.</returns>
    protected boolean isCatchWeightTagScanned(WHSCatchWeightTagRecId _catchWeightTagRecId)
    {
        container cwTagScannedList;

        // Must avoid lookupStr so we don't start the container with an empty value.
        if (pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList))
        {
            cwTagScannedList = str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList));
        }

        return conFind(cwTagScannedList, _catchWeightTagRecId) != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackAutoGeneratedCatchWeightTags</Name>
				<Source><![CDATA[
    /// <summary>
    /// Track automatically generated catch weight tags in the mobile device passthrough.
    /// </summary>
    /// <param name = "_catchWeightTagCollection">The collection of catch weight tags that have been auto generated.</param>
    protected void trackAutoGeneratedCatchWeightTags(WHSCatchWeightTagCollection _catchWeightTagCollection)
    {
        ListIterator catchWeightTagIterator = _catchWeightTagCollection.getCollectionIterator();
        container catchWeightTagScannedList;

        // Add created catch weight tag record Id to the list in the pass.
        if (pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList))
        {
            // Must avoid lookupStr so we don't start the container with an empty value.
            catchWeightTagScannedList = str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList));
        }

        while (catchWeightTagIterator.more())
        {
            // List iterator will bring back the full record, however only the recId should be added to the pass
            WHSCatchWeightTag catchWeightTag = catchWeightTagIterator.value();

            catchWeightTagScannedList += catchWeightTag.RecId;
            catchWeightTagIterator.next();
        }

        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList, con2Str(catchWeightTagScannedList));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllCatchWeightTagDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the dimensions of the tags.
    /// </summary>
    /// <param name="_sourceInventDim">An <c>InventDim</c> buffer.</param>
    protected void updateAllCatchWeightTagDimensions(InventDim _sourceInventDim)
    {
        container cwTagCreatedList = str2con(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList));

        ttsbegin;

        for (int counter = 1; counter <= conLen(cwTagCreatedList); counter++)
        {
            WHSCatchWeightTag catchWeightTag = WHSCatchWeightTag::findByRecId(conPeek(cwTagCreatedList, counter), true);
            catchWeightTag.updateCatchWeightTagDimension(_sourceInventDim);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAutoTrackingEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves whether the item is auto tracking enabled.
    /// </summary>
    /// <param name="_itemId">Item ID</param>
    /// <returns>True if the item is auto tracking enabled; otherwise false.</returns>
    [SysObsolete('Logic has been moved to InventTable.isAutoTrackingEnabled', false, 24\03\2023)]
    protected boolean isAutoTrackingEnabled(ItemId _itemId)
    {
        InventTable inventTable = InventTable::find(_itemId);

        if (!this.itemRequiresManualDimTracking(inventTable, InventTrackingDimType::Batch)
            || !this.itemRequiresManualDimTracking(inventTable, InventTrackingDimType::Serial))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    internal WHSInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkLinesBeGrouped</Name>
				<Source><![CDATA[
    private static boolean canWorkLinesBeGrouped(WHSWorkLine _workLine, WHSWorkLine _groupWorkLine)
    {
        return _workLine.WMSLocationId == _groupWorkLine.WMSLocationId
            && _workLine.ItemId == _groupWorkLine.ItemId
            && _workLine.InventDimId == _groupWorkLine.InventDimId
            && _workLine.OrderCommittedInventDimId == _groupWorkLine.OrderCommittedInventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformGroupPick</Name>
				<Source><![CDATA[
    private boolean canPerformGroupPick()
    {
        WHSWorkLine     groupWorkLine;
        ItemId          itemId;
        InventDimId     inventDimId;
        InventDimId     orderCommittedInventDimId;
        int             countGroupWorkLine;
        boolean         ret;

        using (var activityContext = this.instrumentationLogger().groupPickWorkLineActivities().identifyGroupPickWorkLines())
        {
            this.instrumentationLogger().logRecordInformation(workLine);
            
            if (WHSWorkExecuteDifferentSOLineGroupPickWholeLPNotPromptTargetLPFlight::instance().isEnabled())
            {
                while select WorkType, WMSLocationId, LineNum, ItemId, InventDimId, OrderCommittedInventDimId from groupWorkLine
                order by LineNum
                where groupWorkLine.WorkId == workLine.WorkId
                    && groupWorkLine.LineNum >= workLine.LineNum
                    && groupWorkLine.WorkType == WHSWorkType::Pick
                    && groupWorkLine.WorkStatus != WHSWorkStatus::Cancelled
                {
                    if (WHSWorkLine::isPutBefore(workLine.WorkId, groupWorkLine.LineNum))
                    {
                        break;
                    }

                    if (!WhsWorkExecuteDisplay::canWorkLinesBeGrouped(workLine, groupWorkLine))
                    {
                        break;
                    }
    
                    countGroupWorkLine++;
                }
            }
            else
            {
                while select WorkType, WMSLocationId, LineNum, ItemId, InventDimId, OrderCommittedInventDimId from groupWorkLine
                order by LineNum
                where groupWorkLine.WorkId == workLine.WorkId
                    && groupWorkLine.LineNum >= workLine.LineNum
                    && groupWorkLine.WorkType == WHSWorkType::Pick
                {
                    if (WHSWorkLine::isPutBefore(workLine.WorkId, groupWorkLine.LineNum))
                    {
                        break;
                    }

                    if (!WhsWorkExecuteDisplay::canWorkLinesBeGrouped(workLine, groupWorkLine))
                    {
                        break;
                    }
    
                    countGroupWorkLine++;
                }
            }
                
            this.instrumentationLogger().groupPickWorkLineActivities().identifiedGroupPickWorkLines(activityContext, countGroupWorkLine);

            return countGroupWorkLine > 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainDimTracking</Name>
				<Source><![CDATA[
    private void maintainDimTracking(WHSWorkLine _workLine)
    {
        WHSDimTracking                  dimTracking;

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_workLine.ItemId))
        {
            InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;
    
            select firstOnly RecId, InventDimId from dimTracking
                where dimTracking.WorkId == _workLine.WorkId
                    && dimTracking.LineNum == (_workLine.LineNum - 1)
                exists join inventSumUnionDeltaPhysicalQty
                    where inventSumUnionDeltaPhysicalQty.InventDimId == dimTracking.InventDimId
                        && inventSumUnionDeltaPhysicalQty.ItemId == _workLine.ItemId
                        && inventSumUnionDeltaPhysicalQty.PhysicalInvent > 0;
    
            if (dimTracking.RecId)
            {
                this.fillPassFromInventDim(InventDim::find(dimTracking.InventDimId));

                pass.remove(#DimPrompt);
            }
        }
        else
        {
            InventSum inventSum;
    
            select firstOnly RecId, InventDimId from dimTracking
                where dimTracking.WorkId == _workLine.WorkId
                    && dimTracking.LineNum == (_workLine.LineNum - 1)
                exists join inventSum
                    where inventSum.InventDimId == dimTracking.InventDimId
                        && inventSum.ClosedQty == NoYes::No
                        && inventSum.ItemId == _workLine.ItemId
                        && inventSum.PhysicalInvent > 0;
    
            if (dimTracking.RecId)
            {
                this.fillPassFromInventDim(InventDim::find(dimTracking.InventDimId));

                pass.remove(#DimPrompt);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainGroupPick</Name>
				<Source><![CDATA[
    private void maintainGroupPick(
        WHSWorkLine         _preWorkLine,
        boolean             _groupPickFail,
        WHSLicensePlateId   _groupPickLP)
    {
        if (workLine.canClearWorkLinesGrouping(_preWorkLine))
        {
            pass.clearGroupPick();
            pass.clearGroupPickFail();
            pass.clearGroupPickQty();

            if (pass.exists(WHSWorkExecuteDisplayGroupPickControls::GroupPickLP))
            {
                pass.remove(WHSWorkExecuteDisplayGroupPickControls::GroupPickLP);
            }
        }
        else
        {
            if (_groupPickFail)
            {
                pass.setGroupPickFailure();
            }
            else if (pass.isGroupPick())
            {
                step = #Pick;
            }

            if (_groupPickLP)
            {
                pass.insert(WHSWorkExecuteDisplayGroupPickControls::GroupPickLP, _groupPickLP);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainGroupPickForShortPick</Name>
				<Source><![CDATA[
    private void maintainGroupPickForShortPick(WHSWorkLine _preWorkLine, WHSLicensePlateId _groupPickLP)
    {
        if (!workLine.canWorkLineBeGrouped(_preWorkLine))
        {
            pass.clearGroupPick();
            pass.clearGroupPickFail();
        }
        else if (workLine.LineNum != _preWorkLine.LineNum
                 && pass.isGroupPick()
                 && _groupPickLP != '')
        {
            pass.insert(WHSWorkExecuteDisplayGroupPickControls::GroupPickLP, _groupPickLP);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGroupPickConfirmedAndLocationConfirmationEnabled</Name>
				<Source><![CDATA[
    private boolean isGroupPickConfirmedAndLocationConfirmationEnabled(WHSWorkLine _previousWorkLine)
    {
        boolean returnValue = pass.isGroupPick()
            && WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), _previousWorkLine.WorkType)
            && workLine.RecId != _previousWorkLine.RecId
            && workLine.ItemId == _previousWorkLine.ItemId
            && pass.exists(#QtyLeft)
            && !pass.exists(#LocVerification);

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveQualityCheck</Name>
				<Source><![CDATA[
    private void approveQualityCheck(
        WHSWorkLine     _qualityCheckWorkLine,
        UserId          _userId)
    {
        using (var activityContext = this.instrumentationLogger().qualityCheckActivities().approveQualityCheck())
        {
            this.instrumentationLogger().logRecordInformation(_qualityCheckWorkLine);
            workLine = _qualityCheckWorkLine.approveQualityCheck(_userId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectQualityCheck</Name>
				<Source><![CDATA[
    private void rejectQualityCheck(
        WHSWorkLine _qualityCheckWorkLine,
        UserId      _userId)
    {
        using (var activityContext = this.instrumentationLogger().qualityCheckActivities().rejectQualityCheck())
        {
            this.instrumentationLogger().logRecordInformation(_qualityCheckWorkLine);
            workLine = _qualityCheckWorkLine.rejectQualityCheck(_userId, pass.lookup(#LicensePlateId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAssignClusterId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the RF screen for capturing a cluster ID.
    /// </summary>
    /// <param name="_con">
    /// The current RF container we are building on.
    /// </param>
    /// <returns>
    /// An updated RF container with controls for capturing cluster ID.
    /// </returns>
    [Hookable(false)]
    protected container buildAssignClusterId(container _con)
    {
        container ret = _con;
    
        ret += [this.buildControl(#RFLabel, #Scan, "@WAX:AssignClusterId", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #ClusterId, "@WAX3571", 1, '', extendedTypeNum(WHSClusterId), '', 0)];
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeErrorMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes any error label messages from the RF screen.
    /// </summary>
    /// <param name="_con">
    /// The current RF screen container of controls.
    /// </param>
    /// <returns>
    /// An updated RF container with error label controls removed.
    /// </returns>
    protected final container removeErrorMessages(container _con)
    {
        container   ret = _con;
        int         length = conLen(ret);
        int         i = 3;
        int         j;
    
        while (i <= length)
        {
            if (conpeek(conpeek(_con, i), #controlType) == #RFLabel
            &&  conpeek(conpeek(_con, i), #name)        == #RFError)
            {
                ret = conDel(ret, i - j, 1);
                ++j;
            }
    
            ++i;
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assigningPutawayCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the newly created work to a putaway cluster.
    /// </summary>
    /// <param name = "_con">Current container.</param>
    /// <param name = "_workBuildId">Current work build ID.</param>
    /// <param name = "_prevStep">The previous executed step.</param>
    /// <param name = "_menuItemTable">The menu item that is being used.</param>
    /// <returns>Updated container to build the next screen.</returns>
    [Hookable(false)]
    protected final container assigningPutawayCluster(
        container           _con,
        WHSWorkBuildId      _workBuildId,
        int                 _prevStep,
        WHSRFMenuItemTable  _menuItemTable)
    {
        container ret = _con;
        boolean   continueToNextStep;

        if (_menuItemTable.AssignPutawayCluster)
        {
            WHSWorkTable sortWorkTable = WHSWorkTable::findSingleInboundWorkByWorkBuildId(_workBuildId);

            if (sortWorkTable)
            {
                WHSPutawayClusterProfileAssignment putawayClusterProfileAssignment = WHSPutawayClusterProfileAssignment::constructPutawayClusterAssignment(sortWorkTable.WorkId);
                putawayClusterProfileAssignment.assignPutawayClusterProfile();

                // Store RF messages in the passthrough
                if (putawayClusterProfileAssignment.profileAssignmentInfoLog())
                {
                    pass.insert(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage, putawayClusterProfileAssignment.profileAssignmentInfoLog());
                }

                if (putawayClusterProfileAssignment.clusterAssignmentInfoLog())
                {
                    pass.insert(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignMessage, putawayClusterProfileAssignment.clusterAssignmentInfoLog());
                }

                if (putawayClusterProfileAssignment.clusterAssignmentError())
                {
                    pass.insert(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignErrorMessage, putawayClusterProfileAssignment.clusterAssignmentError());
                }

                // May need to prompt for cluster if auto assigning
                if (putawayClusterProfileAssignment.mustPromptForClusterId())
                {
                    pass.insert(#PrevStep, _prevStep);
                    pass.insert(#WorkId, sortWorkTable.WorkId);

                    ret = conNull();    

                    if (pass.exists(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage))
                    {
                        str message = pass.lookup(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage);

                        ret += [this.buildControl(#RFText, #ClusterSortMessage, "@SYS342305", 1, message, extendedTypeNum(Description), '', 0, false)];

                        pass.remove(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage);
                    }

                    ret = this.buildAssignClusterId(ret);
                    step = #SortReceive;
                    continueToNextStep = true;
                }
            }
        }

        return [continueToNextStep, ret];
    }

]]></Source>
			</Method>
			<Method>
				<Name>stepSortReceive</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected container stepSortReceive(
        container _con,
        str       _buttonClicked)
    {
        boolean hasError = this.hasError(_con);

        if (hasError)
        {
            _con = conDel(_con, 3, 1);
        }

        int hasClusterSortMessage = this.hasClusterSortMessage(_con);
        if (hasClusterSortMessage)
        {
            _con = conDel(_con, hasClusterSortMessage, 1);
        }

        pass.insert(#ClusterId, conpeek(conpeek(_con, 4), #data));

        WHSWorkTable sortWorkTable = WHSWorkTable::find(pass.lookup(#WorkId));
        WHSClusterProfile putawayClusterProfile = WHSClusterProfile::find(sortWorkTable.ClusterProfileId);
        WHSWorkClusterTable workClusterTable = WHSWorkClusterTable::find(pass.lookup(#ClusterId));

        if (putawayClusterProfile.PutawayClusterAssignmentRule == WHSPutawayClusterAssignmentRule::Manual)
        {
            if (workClusterTable
                && (workClusterTable.ClusterType != WHSClusterType::Putaway
                    || workClusterTable.WorkClusterStatus != WHSWorkClusterStatus::Open
                    || workClusterTable.ClusterProfileId  != sortWorkTable.ClusterProfileId))
            {
                throw error("@WAX:InvalidCluster");
            }
        }
        else
        {
            if (!workClusterTable
            ||  workClusterTable.ClusterType != WHSClusterType::Putaway
            ||  WHSInvent::getTotalQtyOnLicensePlate(pass.lookup(#ClusterId)))
            {
                throw error("@WAX:InvalidCluster");
            }
        }

        WHSWorkClusterTable::createWorkClusterTable(pass.lookup(#ClusterId), sortWorkTable.ClusterProfileId);
        WHSWorkClusterLine::createWorkClusterLine(pass.lookup(#ClusterId), sortWorkTable.WorkId, sortWorkTable.TargetLicensePlateId);

        step = str2int(pass.lookup(#PrevStep));

        pass.remove(#ClusterId);
        pass.remove(#WorkId);
        pass.remove(#PrevStep);

        container ret = [this.buildControl(#RFLabel, #Scan, "@WAX:AssignClusterId", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret = this.updateModeStepPass(ret, mode, step, pass);
        ret = this.displayForm(ret, _buttonClicked);

        pass = new WHSRFPassthrough(Types::String, Types::String);
        pass = WHSRFPassthrough::create(conpeek(ret, 2));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addClusterMessages</Name>
				<Source><![CDATA[
    protected final container addClusterMessages(container _con)
    {
        container ret = _con;

        if (pass.exists(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage))
        {
            ret = this.addErrorLabel(ret, pass.lookup(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage), WHSRFColorText::Success);
            pass.remove(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage);
        }

        if (pass.exists(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignMessage))
        {
            ret = this.addErrorLabel(ret, pass.lookup(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignMessage), WHSRFColorText::Success);
            pass.remove(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignMessage);
        }

        if (pass.exists(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignErrorMessage))
        {
            ret = this.addErrorLabel(ret, pass.lookup(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignErrorMessage), WHSRFColorText::Warning);
            pass.remove(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignErrorMessage);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWork</Name>
				<Source><![CDATA[
    protected void findWork()
    {
        workTable = WHSWorkTable::find(pass.lookup(#Id));
    
        if (workTable.RecId == 0)
        {
            workTable = WHSWorkTable::findByLicensePlate(pass.lookup(#Id));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowShortPickConf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a short picking confirmation step should be executed.
    /// </summary>
    /// <param name = "_reallocationProcess">The reallocation process being used.</param>
    /// <param name = "_buttonClicked">The button name being clicked.</param>
    /// <returns>True if a short picking confirmation step should be executed; otherwise false.</returns>
    private boolean allowShortPickConf(WHSItemReallocation _reallocationProcess, str _buttonClicked)
    {
        if (pass.lookupNum(#QtyToPick) == 0)
        {
            if ((_buttonClicked == WHSWorkExecuteDisplayItemReallocationControls::ProceedControlName || _buttonClicked == #RFOK)
                && (_reallocationProcess == WHSItemReallocation::Manual
                || (_reallocationProcess == WHSItemReallocation::AutomaticAndManual && !pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired))))
            {
                return true;
            }

            if (_buttonClicked == WHSWorkExecuteDisplayItemReallocationControls::ProceedControlName
                && _reallocationProcess == WHSItemReallocation::Manual)
            {
                return true;
            }
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateLPWithTargetLPForNoStopWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a license plate should be updated with target license plate
    /// when the stop work option is not selected for the second or next pick steps in the work template.
    /// </summary>
    /// <returns>true if a license plate should be update with target license plate; otherwise, false.</returns>
    private boolean mustUpdateLPWithTargetLPForNoStopWorkLine()
    {
        if (WHSWorkTransactionTypeRefacMustUpdateLPWithTargetLPForNoStopWorkLineFlight::instance().isEnabled())
        {
            if (workLine.WorkStop)
            {
                return false;
            }

            if (workTable.WorkTransType == WHSWorkTransType::TransferIssue
                && !WHSShortPickingBuildPickUpdateLPWithTargetLPTransferWorkFlight::instance().isEnabled())
            {
                return false;
            }

            return WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType).mustUpdateLPWithTargetLPForNoStopWorkLine(workLine);
        }
        
        boolean isPackedContainerPicking = workTable.WorkTransType == WHSWorkTransType::PackedContainerPicking;
        boolean isProdPick = workTable.WorkTransType == WHSWorkTransType::ProdPick;
        boolean isSales = workTable.WorkTransType == WHSWorkTransType::Sales;
        boolean isTransferIssue = workTable.WorkTransType == WHSWorkTransType::TransferIssue;
        
        return  !workLine.WorkStop
                && (isPackedContainerPicking
                    || ((isProdPick || isSales || (isTransferIssue && WHSShortPickingBuildPickUpdateLPWithTargetLPTransferWorkFlight::instance().isEnabled()))
                        && WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowMarkSerialAsCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if work line is fully covered by serial numbers.
    /// </summary>
    /// <returns>true if the work line is fully covered by serial numbers; otherwise, false.</returns>
    private boolean allowMarkSerialAsCompleted()
    {
        Qty workLineCompleteQty;

        if (step == #ShortPick && pass.exists(#QtyToPick))
        {
            workLineCompleteQty = pass.lookupNum(#QtyToPick);
        }
        else if (WHSWorkExecute::isPotentialOverPick(workTable, workLine))
        {
            workLineCompleteQty = this.calculateSerializedItemQuantity(pass.lookupStr(#LicensePlateId));
        }
        else if (workLine.InventQtyRemain > 0)
        {
            workLineCompleteQty = workLine.InventQtyRemain;
        }

        return (workLineCompleteQty > 0 && workLineCompleteQty == pass.lookupNum(#SerialQty));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLoadIdForLoadItemReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the Load Id control in load item receiving flows (load item receiving and mixed LP receiving).
    /// </summary>
    /// <param name = "_control">Load ID input control.</param>
    /// <returns>true if the processing is successful; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean processLoadIdForLoadItemReceiving(WhsControl _control)
    {
        if (_control.parmEnabled())
        {
            // Error messages are handled inside validateLoadToBeReceived
            return this.validateLoadToBeReceived(_control);
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadToBeReceived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the load can be received through the current menu item. If not, sets the correct error message.
    /// </summary>
    /// <param name = "_control">Load ID input control.</param>
    /// <returns>true if the load can be received; otherwise, false.</returns>
    private boolean validateLoadToBeReceived(WhsControl _control)
    {
        WHSLoadId loadId = _control.parmData();
        Debug::assert(loadId != '');

        if (WhsLoadReceivingPreventReceivingRecvConfirmedLoadsFlight::instance().isEnabled())
        {
            WHSLoadTable loadTable = WHSLoadTable::find(loadId);   

            if (!loadTable.isReceived())
            {
                return true;
            }

            // At this point, load is verified to be received - either by the presence of the load receiving completed timestamp or the status.
            // Loads that went through the load receiving completed process (marked by the timestamp) cannot be received against under any circumstances.
            // Status isn't enough because loads can get that status from PR posting as well and for backwards compatibility reasons,
            // overreceiving on those is controlled by an option on the mobile device menu item.

            if (loadTable.LoadReceivingCompletedUTCDateTime)
            {
                return _control.fail(strFmt("@WAX:CannotReceiveLoadBecauseLoadReceivedConfirmed", _control.parmData()));
            }

            var rfMenuItem = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

            // Block implies no receipt on closed loads, but there is a different error message for UX reasons
            if (!rfMenuItem.blockLoadLineQuantityOverreceipt())
            {
                return true;
            }

            if (rfMenuItem.LoadLineQuantityOverreceipt == WhsLoadLineQuantityOverreceipt::BlockForClosedLoadsOnly)
            {
                return _control.fail(strFmt("@WAX:CannotReceiveLoadBecauseLoadStatus", _control.parmData(), WHSLoadStatus::Received));
            }

            return _control.fail(strFmt("@WAX:CannotReceiveLoadBecauseNoOverreceipt", _control.parmData()));
        }
        else
        {
            var rfMenuItem = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

            // Block implies no receipt on closed loads, but there is a different error message for UX reasons
            if (!rfMenuItem.blockLoadLineQuantityOverreceipt())
            {
                return true;
            }

            WHSLoadTable loadTable = WHSLoadTable::find(loadId);
            if (!loadTable.isReceived())
            {
                return true;
            }

            if (rfMenuItem.LoadLineQuantityOverreceipt == WhsLoadLineQuantityOverreceipt::BlockForClosedLoadsOnly)
            {
                return _control.fail(strFmt("@WAX:CannotReceiveLoadBecauseLoadStatus", _control.parmData(), WHSLoadStatus::Received));
            }

            return _control.fail(strFmt("@WAX:CannotReceiveLoadBecauseNoOverreceipt", _control.parmData()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSplitPutAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that the work can be split during put process.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Split put is not supported for fully tracked catch weight enabled items.
    /// </exception>
    protected void validateSplitPutAllowed()
    {
        ItemId itemId = pass.lookupStr(#ItemId);

        if (itemId
            && WHSInventTable::isCatchWeightTagTracked(itemId)
            && WHSInventTable::catchWeightItemHandlingPolicy(itemId).CatchWeightTagDimensionTrackingMethod == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions)
        {
            throw error("@WAX:SplitPutCWTagTrackedError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPutWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes put work line
    /// </summary>
    /// <param name = "_state">The instance of the <c>WhsWorkProcessWorkLineState</c> class.</param>
    /// <param name = "_workExecute">The instance of the <c>WHSWorkExecute</c> class.</param>
    /// <param name = "_buttonClicked">The clicked button.</param>
    /// <param name = "_newLocationId">New location id.</param>
    /// <returns>Work Id</returns>
    protected WHSWorkId processPutWorkLine(WhsWorkProcessWorkLineState _state,
                                           WhsWorkExecute              _workExecute,
                                           str                         _buttonClicked,
                                           WMSLocationId               _newLocationId)
    {
        WHSWorkId tmpWorkId;

        if (workLine.WorkType == WHSWorkType::Put && !WhsWorkExecuteDisplay::isFinalPutKanbanAutoComplete(workLine))
        {
            if (pass.lookup(#WMSLocationId) != workLine.wmsLocationId && workLine.WMSLocationId != '')
            {
                _state.nextForm = this.addErrorLabel(conNull(), "@WAX2962", WHSRFColorText::Error);
                _state.nextForm = this.buildPut(_state.nextForm);
                step = #Put;
    
                return tmpWorkId;
            }
            else if (pass.lookup(#WMSLocationId) != '' && workLine.WMSLocationId == '')
            {
                _workExecute.updateWorkLineLocation(pass.lookup(#WorkId), pass.parmLineNum(), pass.lookup(#WMSLocationId), pass.lookup(#UserId));
                workLine.reread();
                _state.nextForm = this.buildPut(conNull());
                                    
                step = #Put;
                return tmpWorkId;
            }
            else if (_buttonClicked == #RFOverrideLP)
            {
                if (pass.exists(#GroupPutaway) && !pass.exists(#GroupPutawayFail))
                {
                    _state.nextForm = this.buildGroupedPutaway(conNull(), true);
                    return tmpWorkId;
                }
    
                _state.nextForm = this.buildPut(conNull(), '', true);
                return tmpWorkId;
            }
            else if (_state.buttonClicked == #RFNoLocation)
            {
                _state.nextForm = this.buildPut(conNull(), '', false, _newLocationId);
                return tmpWorkId;
            }
            // Group putaway for one line, if qty does not match must have been split put first
            else if (pass.exists(#GroupPutawayConfirm) && workLine.InventQtyWork != workLine.InventQtyRemain)
            {
                pass.remove(#GroupPutawayConfirm);
                _state.nextForm = this.buildPut(conNull());
                return tmpWorkId;
            }
        }
    
        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).Anchor && !workLine.IsAnchored)
        {
            using (var context = new WhsWorkExecuteAnchoringProcessContext())
            {
                
                context.putWorkTemplateLineRecId = workLine.WorkTemplateLineRecId;

                _workExecute.anchorWork(pass.lookup(#WorkId), workLine.wmsLocationId, workLine.wmsLocationId, WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AnchorBy);
            }
        }
    
        WHSLicensePlateId   newLicensePlateId;

        using (var activityContext = this.instrumentationLogger().executePutActivities().executePut(mode))
        {
            WHSLicensePlateId  putParmSourceLicensePlateId;
            WHSLicensePlateId  putParmTargetLicensePlateId;
            
            [putParmSourceLicensePlateId, putParmTargetLicensePlateId, newLicensePlateId] = this.initializeSourceAndTargetLicensePlateIds();          

            WHSWorkPutFlow workFlowPut = (WHSWorkLine::getPrevOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType).InventQtyWork > workLine.InventQtyWork ? 
                                          WHSWorkPutFlow::SplitQuantity : 
                                          WHSWorkPutFlow::MoveAll);

            WHSWorkPutOperationParameters putOperationParameters = this.initializeWHSWorkPutOperationParameters(putParmSourceLicensePlateId, putParmTargetLicensePlateId, workFlowPut);

            this.processPutAwayToLocation(workFlowPut, _workExecute, putOperationParameters);

            activityContext.addCustomProperty(this.instrumentationLogger().properties().PutExecuted, 'true');
        }

        if (pass.exists(#WorkId))
        {
            tmpWorkId = pass.lookup(#WorkId);
        }
        WHSWorkGroupingId groupingId;
        if (pass.exists(#WorkGroupingId))
        {
            groupingId = pass.lookup(#WorkGroupingId);
        }
        WHSTargetLicensePlateId targetLicensePlateId;
        boolean                 groupPutawayFail;
        if (pass.exists(#GroupPutawayFail))
        {
            groupPutawayFail = true;
        }
        // If we are in a group put that hasn't failed and overriding the LP need to save it off for next line.
        else if (pass.exists(#GroupPutaway))
        {
            targetLicensePlateId = pass.lookupStr(#TargetLicensePlateId);
        }
    
        this.addWorkTableToTransportLoad(workTable.WorkId);
    
        str validateUserDirectField = pass.lookupStr(#ValidateUserDirectField);
        _state.nextForm = this.determineRestart(_state.previousForm);
        if (pass.lookupStr(#ValidateUserDirectField) == "")
        {
            pass.insert(#ValidateUserDirectField, validateUserDirectField);
        }
    
        if (targetLicensePlateId)
        {
            pass.insert(#TargetLicensePlateId, targetLicensePlateId);
        }
    
        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        {
            throw error("@WAX1459");
        }
    
        _state.recall = true;
    
        pass.insert(#PrevWorkId, tmpWorkId);
    
        if (groupingId)
        {
            pass.insert(#WorkGroupingId, groupingId);
        }
      
        // determineRestart method resets the state of the pass, removing any changes to the #LicensePlateId
        // we needed to set the licensePlate again (if newLicensePlateId was set in initializeSourceAndTargetLicensePlateIds method)
        if (newLicensePlateId && pass.exists(#LicensePlateId) && pass.lookupStr(#LicensePlateId) != newLicensePlateId)
        {
            pass.insert(#LicensePlateId, newLicensePlateId);
        }           

        if (groupPutawayFail)
        {
            pass.insert(#GroupPutawayFail, 1);
        }
    
        // Remove previous step from pass after putting is finished if the previous step was put location overridden.
        // Otherwise, Location confirmation will not be built for the later put line.
        if (pass.lookupNum(#PrevStep) == #OverrideStep2)
        {
            pass.remove(#PrevStep);
        }

        return tmpWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTargetLicensePlateIfToteEnabled</Name>
				<Source><![CDATA[
    private WHSTargetLicensePlateId updateTargetLicensePlateIfToteEnabled(WHSLicensePlateId _currentTargetLicensePlate, str targetLicensePlateKey, WHSWorkLine _workline)
    {
        WHSLicensePlateId toteLicensePlateId = WhsWorkExecute::construct().determineToteReuseLicensePlateId(_currentTargetLicensePlate, _workLine);
        if (toteLicensePlateId)
        {
            pass.insert(targetLicensePlateKey, toteLicensePlateId);
            return toteLicensePlateId;
        }

        return _currentTargetLicensePlate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSourceAndTargetLicensePlateIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the license plates and related information.
    /// </summary>
    /// <returns>Container with the initialized license plate values and related information.</returns>
    private container initializeSourceAndTargetLicensePlateIds()
    {
        boolean targetLicensePlateIdExists = pass.exists(#TargetLicensePlateId);

        str targetLicensePlateKey = targetLicensePlateIdExists ? #TargetLicensePlateId : #LicensePlateId;
        str sourceLicensePlateKey = targetLicensePlateIdExists ? #LicensePlateId       : #SourceLicensePlateId;

        WHSLicensePlateId initialTargetLicensePlateId = pass.lookup(targetLicensePlateKey);
        WHSLicensePlateId finalSourceLicensePlateId   = pass.exists(sourceLicensePlateKey) ? pass.lookupStr(sourceLicensePlateKey) : initialTargetLicensePlateId;
        WHSLicensePlateId finalTargetLicensePlateId   = this.updateTargetLicensePlateIfToteEnabled(initialTargetLicensePlateId, targetLicensePlateKey, workLine);

        WHSLicensePlateId newLicensePlateId = targetLicensePlateIdExists ? '' : finalTargetLicensePlateId;

        return [finalSourceLicensePlateId, finalTargetLicensePlateId, newLicensePlateId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWHSWorkPutOperationParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes parameters for instance of <c>WHSWorkPutOperationParameters</c> class.
    /// </summary>
    /// <param name = "_sourceLicensePlateId">Source license plate Id.</param>
    /// <param name = "_targetLicensePlateId">Target license plate Id.</param>
    /// <param name = "_workFlowPut">Work put flow.</param>
    /// <returns>The instance of <c>WHSWorkPutOperationParameters</c> with initialized parameters.</returns>
    private WHSWorkPutOperationParameters initializeWHSWorkPutOperationParameters(WHSLicensePlateId _sourceLicensePlateId,
                                                                                  WHSLicensePlateId _targetLicensePlateId,
                                                                                  WHSWorkPutFlow    _workFlowPut)
    {
        WHSWorkPutOperationParameters putOperationParameters = WHSWorkPutOperationParameters::construct();

        putOperationParameters.parmWorkId(workLine.WorkId);
        putOperationParameters.parmLineNum(workLine.LineNum);
        putOperationParameters.parmPutWMSlocationId(workLine.wmsLocationId);
        putOperationParameters.parmSourceLicensePlateId(_sourceLicensePlateId);
        putOperationParameters.parmTargetLicensePlateId(_targetLicensePlateId);
        putOperationParameters.parmUserId(userId);
        putOperationParameters.parmWorkPutFlow(_workFlowPut);
        putOperationParameters.parmHandleByLP(this.shouldHandleByLP());

        return putOperationParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPutAwayToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs process of putting away to location.
    /// </summary>
    /// <param name = "_workFlowPut">Work put flow.</param>
    /// <param name = "_workExecute">The instance of the <c>WHSWorkExecute</c> class.</param>
    /// <param name = "_putOperationParameters">The instance of the <c>WHSWorkPutOperationParameters</c> class.</param>
    private void processPutAwayToLocation(WHSWorkPutFlow _workFlowPut, WhsWorkExecute _workExecute, WHSWorkPutOperationParameters _putOperationParameters)
    {
        boolean isAllowUseOfDeferredPut = this.allowUseOfDeferredPut() &&                                            
                                          WHSWorkDeferredPutProcessingRuleEvaluator::newFromWorkLine(workLine).canUseDeferredPutProcessing(_workFlowPut);

        if (isAllowUseOfDeferredPut)
        {
            using (var context = WHSWorkDeferredPutProcessingSkipRuleEvaluationContext::construct())
            {
                using (var CWContext = WHSCatchWeightItemsPutUsesInventQtyContext::instance())
                {
                    CWContext.canCatchWeightItemsPutUseInventQty = this.canCatchWeightItemsPutUseInventQty();
                    workLine = _workExecute.putAwayToLocationConsiderDeferredPut(_putOperationParameters, isAllowUseOfDeferredPut);
                }
            }
        }
        else
        {
            this.closeContainerForWork(workLine);

            using (var CWContext = WHSCatchWeightItemsPutUsesInventQtyContext::instance())
            {
                CWContext.canCatchWeightItemsPutUseInventQty = this.canCatchWeightItemsPutUseInventQty();
                workLine = _workExecute.putAwayToLocationConsiderDeferredPut(_putOperationParameters, isAllowUseOfDeferredPut);
            }
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInProgressPickLines</Name>
				<Source><![CDATA[
    private Map getInProgressPickLines(InventQty _qtyForActiveLine)
    {
        WHSWorkLine         pickWorkLine;
        Map                 workLineWithQuantity = new Map(Types::Real, Types::Real);
        WHSWorkId           currentWorkId = pass.lookup(#WorkId);
        LineNum             activeLineNum = pass.parmLineNum();

        while select LineNum from pickWorkLine
            order by LineNum asc
            where pickWorkLine.WorkId        == currentWorkId
            &&    pickWorkLine.WorkType      == WHSWorkType::Pick
            &&    pickWorkLine.LineNum       != activeLineNum
            &&    pickWorkLine.WorkStatus    == WHSWorkStatus::InProcess
        {
            workLineWithQuantity.insert(pickWorkLine.LineNum, 0);
        }

        workLineWithQuantity.insert(activeLineNum, _qtyForActiveLine);

        return workLineWithQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receivingLocationId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected WMSLocationId receivingLocationId()
    {
        if (pass.exists(#WMSLocationId))
        {
            return pass.lookupStr(#WMSLocationId);
        }

        InventLocationId userWarehouseId = WHSWorkUserSession::find(pass.lookup(#UserId)).InventLocationId;
        
        if (WHSRFDefaultData::exist(pass.lookup(#MenuItem), WHSDefaultDataField::ToLocation))
        {
            WMSLocationId locationId = WHSRFDefaultData::findDefaultValueForWarehouse(pass.lookup(#MenuItem),
                                                            WHSDefaultDataField::ToLocation,
                                                            userWarehouseId);
            if (locationId)
            {
                if (WMSLocation::exist(locationId, userWarehouseId))
                {
                    pass.insert(#WMSLocationId, locationId);
                    return locationId;
                }
                throw error(strFmt("@SYS53781", locationId, userWarehouseId));
            }
        }

        WMSLocationId locationId = InventLocation::find(userWarehouseId).wmsLocationIdDefaultReceipt;
        pass.insert(#WMSLocationId, locationId);
        return locationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetPassWithClusterMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets pass through map stored in the form state, but retains the cluster assignment related messages.
    /// </summary>
    /// <param name = "_pass">Pass through map to reset.</param>
    /// <param name="_con">Container containing the form state before the pass through is reset.</param>
    /// <param name="_useOldPass">Determines whether the old pass through map should be used during reset.</param>
    /// <returns>
    /// Pass through values reset with cluster assignment messages.
    /// </returns>
    [Hookable(false)]
    protected WHSRFPassthrough resetPassWithClusterMessages(WHSRFPassthrough _pass, container _con, boolean _useOldPass = true)
    {
        InfologText clusterSortMessage   = _pass.lookupStr(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage);
        InfologText clusterAssignMessage = _pass.lookupStr(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignMessage);
        InfologText clusterAssignError = _pass.lookupStr(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignErrorMessage);

        _pass = this.resetPassthrough(_con, _useOldPass);

        if (clusterSortMessage)
        {
            _pass.insert(WHSWorkExecuteDisplayPutawayClusterControls::ClusterSortMessage, clusterSortMessage);
        }
        if (clusterAssignMessage)
        {
            _pass.insert(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignMessage, clusterAssignMessage);
        }
        if (clusterAssignError)
        {
            _pass.insert(WHSWorkExecuteDisplayPutawayClusterControls::ClusterAssignErrorMessage, clusterAssignError);
        }

        return _pass;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderControlDataType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the header control's data type based on the passed parameters.
    /// </summary>
    /// <param name = "_tableId">Table id.</param>
    /// <param name = "_fieldId">Field id of the table.</param>
    /// <returns>Header control's data type.</returns>
    protected ExtendedTypeId getHeaderControlDataType(TableId _tableId, FieldId _fieldId)
    {
        SysDictField dictField = new SysDictField(_tableId, _fieldId);
        return this.getDatatype(dictField.baseType());

    }

]]></Source>
			</Method>
			<Method>
				<Name>unblockReplenishmentOverflowWorkWithinCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unblocks replenishment overflow works that are within capacity after pick lines are completed.
    /// </summary>
    /// <param name = "_pickLocationId">The id of the location from where the pick was done.</param>
    protected  void unblockReplenishmentOverflowWorkWithinCapacity(WMSLocationId _pickLocationId)
    {
        WMSLocation wmsLocation = WMSLocation::find(_pickLocationId, WHSWorkUserSession::find(userId).InventLocationId);

        if (wmsLocation.isReplenishmentOverflowEnabled())
        {
            wmsLocation.unblockReplenishmentOverflowWorkWithinCapacity();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal ExtendedTypeId getDataType(Types _type)
    {
        switch (_type)
        {
            case Types::UtcDateTime:
                return extendedTypeNum(TransDateTime);

            case Types::Real:
                return extendedTypeNum(RealBase);

            case Types::Integer:
                return extendedTypeNum(Integer);

            default:
                return #WHSRFUndefinedDataType;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipDimRunningQtyUpdateWithoutSerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if DimRunningQty update can be skipped.
    /// </summary>
    /// <returns>true if DimRunningQty update can be skipped; Otherwise false</returns>
    private boolean skipDimRunningQtyUpdateWithoutSerial()
    {
        return (!pass.exists(#SerialId)
                && this.mustCaptureSerialOnReceipt(pass.lookup(#ItemId))
                && EcoResTrackingDimensionGroup::find(InventTable::find(pass.lookup(#ItemId)).trackingDimensionGroup()).IsSerialNumberControlEnabled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCatchWeightItemsPutUseInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if put can use invent quantity for catch weight items
    /// </summary>
    /// <returns>true if Invent quantity can be used; Otherwise false</returns>
	[Hookable(false)]
	internal boolean canCatchWeightItemsPutUseInventQty()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDisplayPickSummary</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean mustDisplayPickSummary()
    {
        return (this.hasComments()
            || WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfDisplayPickSummary)
            && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum) 
            && !pass.exists(#CommentsDisplayed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemDispositionCode</Name>
				<Source><![CDATA[
    private boolean checkItemDispositionCode(ItemId            _itemId, 
                                             InventTransType   _inventTransType)
    {
        if (this.isInboundOrderReceiving(_inventTransType))
        {
            WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

            return menuItemTable.ShowBatchDisposition
                && (WHSPORecBatchDispositionIfDispositionEnabledFlight::instance().isEnabled()
                || !menuItemTable.ShowDisposition)
                && InventTable::find(_itemId).whsBatchActive()
                && !pass.exists(#BatchDisposition);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTrackingReceiptDetailsPerSerialQty</Name>
				<Source><![CDATA[
    private void populateTrackingReceiptDetailsPerSerialQty(InventDim _trackingInventDim, InventQty _dimInventQty, InventTransType _inventTransType)
    {
        if (_trackingInventDim.inventSerialId)
        {
            this.populateTrackingReceiptDetails(_trackingInventDim, _dimInventQty);
            return;
        }

        InventTable inventTable = InventTable::find(pass.parmItemId());
        InventNumGroup inventNumGroupSerial = InventNumGroup::find(inventTable.SerialNumGroupId);

        if (inventNumGroupSerial
            && inventNumGroupSerial.OnlyInventTransaction ? inventNumGroupSerial.PhysicalUpdate : false
            && inventNumGroupSerial.isTransTypeActivated(_inventTransType)
            && !this.itemRequiresManualDimTracking(inventTable, InventTrackingDimType::Serial))
        {
            InventDim trackingInventDimNew;
            InventTransRefId transRefId;
            InventTransId transId;

            trackingInventDimNew.data(_trackingInventDim);

            if (this.isInboundOrderReceiving(_inventTransType))
            {
                transRefId = this.receivingOrderProvider().orderNum(pass);
                transId    = this.receivingOrderLine(pass).InventTransId;
            }

            while (_dimInventQty > 0)
            {
                trackingInventDimNew.InventSerialId = inventNumGroupSerial.buildNumberParameters(
                                                                DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()),
                                                                transRefId,
                                                                transId,
                                                                extendedTypeNum(InventSerialId));

                trackingInventDimNew = InventDim::findOrCreate(trackingInventDimNew);

                if (inventNumGroupSerial.PerQty > 0)
                {
                    this.populateTrackingReceiptDetails(trackingInventDimNew, min(_dimInventQty, inventNumGroupSerial.PerQty));
                    _dimInventQty -= inventNumGroupSerial.PerQty;
                }
                else
                {
                    this.populateTrackingReceiptDetails(trackingInventDimNew, _dimInventQty);
                    break;
                }
            }
        }
        else
        {
            this.populateTrackingReceiptDetails(_trackingInventDim, _dimInventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTrackingReceiptDetailsPerBatchQty</Name>
				<Source><![CDATA[
    protected void populateTrackingReceiptDetailsPerBatchQty(InventDim _trackingInventDim, InventQty _qtyBatch, InventTransType _inventTransType)
    {        
        InventTable     inventTable = InventTable::find(pass.lookup(#ItemId));
        InventNumGroup  inventNumGroupBatch = InventNumGroup::find(inventTable.BatchNumGroupId);
        boolean         isPopulateTrackingReceiptDetailsPerSerialQtyFlightEnabled = WHSPopulateTrackingReceiptDetailsPerSerialQtyFlight::instance().isEnabled();

        if (inventNumGroupBatch.PerQty > 0
            && _qtyBatch > inventNumGroupBatch.PerQty
            && inventNumGroupBatch.OnlyInventTransaction ? inventNumGroupBatch.PhysicalUpdate : false
            && inventNumGroupBatch.isTransTypeActivated(_inventTransType)
            && !this.itemRequiresManualDimTracking(inventTable, InventTrackingDimType::Batch))
        {
            InventDim           trackingInventDimNew;
            InventTransRefId    transRefId;
            InventTransId       transId;

            trackingInventDimNew.data(_trackingInventDim);

            if (this.isInboundOrderReceiving(_inventTransType))
            {
                transRefId = this.receivingOrderProvider().orderNum(pass);
                transId    = this.receivingOrderLine(pass).InventTransId;
            }
            else if (_inventTransType == InventTransType::TransferOrderReceive)
            {
                transRefId = pass.lookup(#TONum);
                transId    = InventTransferLine::find(pass.lookup(#TONum), pass.parmTOLineNum()).InventTransId;
            }

            while (_qtyBatch > 0)
            {
                trackingInventDimNew.InventBatchId = inventNumGroupBatch.buildNumberParameters(
                                                                DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()),
                                                                transRefId,
                                                                transId,
                                                                extendedTypeNum(InventBatchId));

                trackingInventDimNew = InventDim::findOrCreate(trackingInventDimNew);

                if (isPopulateTrackingReceiptDetailsPerSerialQtyFlightEnabled)
                {
                    this.populateTrackingReceiptDetailsPerSerialQty(trackingInventDimNew, min(_qtyBatch, inventNumGroupBatch.PerQty), _inventTransType);
                }
                else
                {
                    this.populateTrackingReceiptDetails(trackingInventDimNew, min(_qtyBatch, inventNumGroupBatch.PerQty));
                }

                _qtyBatch -= inventNumGroupBatch.PerQty;
            }
        }
        else
        {
            if (isPopulateTrackingReceiptDetailsPerSerialQtyFlightEnabled)
            {
                this.populateTrackingReceiptDetailsPerSerialQty(_trackingInventDim, _qtyBatch, _inventTransType);
            }
            else
            {
                this.populateTrackingReceiptDetails(_trackingInventDim, _qtyBatch);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPassSkipWorkId</Name>
				<Source><![CDATA[
    internal container adjustPassSkipWorkId()
    {
        container skipWorkId;

        if (pass.exists(#SkipWorkId))
        {
            skipWorkId = str2con(pass.lookup(#SkipWorkId), ',', false);
        }

        skipWorkId = conIns(skipWorkId, 1, pass.lookup(#WorkId));

        WHSWorkTable::resetWork(pass.lookup(#WorkId));

        pass.insert(#SkipWorkId, con2Str(skipWorkId, ','));

        return skipWorkId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>