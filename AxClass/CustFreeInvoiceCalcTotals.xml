<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustFreeInvoiceCalcTotals</Name>
	<SourceCode>
		<Declaration><![CDATA[
class CustFreeInvoiceCalcTotals implements 
    PaymCalendarIDerivationSource, 
    PaymCalendarIBankAddress, 
    PaymCalendarIDocumentAddress,
    SysPackable
{
    CustInvoiceTable custInvoiceTable;
    CustInvoiceLine custInvoiceLine;

    AmountCur salesBalance;
    DiscAmount lineDisc;

    MarkupSumSales sumMarkup;
    RoundOff invoiceRoundOff;
    TaxAmountCur sumTax;
    SalesEndDiscAmount endDisc;
    AmountCur invoiceAmount;
    private InvoiceQuantity totalQty;

    CustCashDiscAmount cashDisc;
    CustCashDiscDate cashDiscDate;

    TaxFreeInvoice tax;
    // <GEERU>
    TaxAmount totalTaxAmount_W;
    // </GEERU>
    // <GIN>
    TaxWithhold_IN taxWithhold;
    TaxAmountCur sumTaxWithhold;
    TaxWithholdCalcFreeInvoice_IN taxWithholdCalcFreeInvoice;
    // </GIN>

    // <GBR>
    MarkupAmount markupFreightAmountCur_BR;
    MarkupAmount markupInsuranceAmountCur_BR;
    MarkupAmount markupOthersAmountCur_BR;

    AmountCur productsTotalAmount_BR;
    AmountCur servicesTotalAmount_BR;
    // </GBR>

    // <GTE>
    TaxAmountCur sumTaxGTE;
    TaxAmountCur taxTotalReverseCharge;
    // </GTE>

    private CustInvoiceTableCalcTotals custInvoiceTableCalcTotals;
    private boolean isAllowCustInvoiceTableCalcTotals;
    private boolean isSaveCalcTotalsForPostingInvoice;
    private boolean isCustInvoiceTableCalcTotalsFeatureEnabled;
    private boolean isUsingCustInvoiceTableCalcTotals;

    private CustFreeInvoiceCalcTotalsInstrumentationLogger calcTotalsInstrumentationLogger;

    #DEFINE.CurrentVersion(1)

    #EECountryRegionCodes
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = this.packCustFreeInvoiceCalcTotals([#CurrentVersion]);

        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packCustFreeInvoiceCalcTotals</Name>
				<Source><![CDATA[
    private container packCustFreeInvoiceCalcTotals(container _packedClass)
    {
        _packedClass = this.appendVariableToPack(_packedClass, varStr(custInvoiceTable), custInvoiceTable);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(custInvoiceLine), custInvoiceLine);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(salesBalance), salesBalance);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(lineDisc), lineDisc);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(sumMarkup), sumMarkup);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(invoiceRoundOff), invoiceRoundOff);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(sumTax), sumTax);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(endDisc), endDisc);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(invoiceAmount), invoiceAmount);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(totalTaxAmount_W), totalTaxAmount_W);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(sumTaxWithhold), sumTaxWithhold);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(markupFreightAmountCur_BR), markupFreightAmountCur_BR);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(markupInsuranceAmountCur_BR), markupInsuranceAmountCur_BR);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(markupOthersAmountCur_BR), markupOthersAmountCur_BR);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(productsTotalAmount_BR), productsTotalAmount_BR);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(servicesTotalAmount_BR), servicesTotalAmount_BR);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(sumTaxGTE), taxTotalReverseCharge);
        _packedClass = this.appendVariableToPack(_packedClass, varStr(markupInsuranceAmountCur_BR), markupInsuranceAmountCur_BR);

        return _packedClass;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(CustFreeInvoiceCalcTotals) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        int version = conPeek(packedClass, 1);

        switch (version)
        {
            case #CurrentVersion:
                [version] = packedClass;
                this.unpackCustFreeInvoiceCalcTotals(packedClass);
                return true;
            default :
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackCustFreeInvoiceCalcTotals</Name>
				<Source><![CDATA[
    private void unpackCustFreeInvoiceCalcTotals(container _packedClass)
    {
        custInvoiceTable = this.extractPackedVariable(_packedClass, varStr(custInvoiceTable));
        custInvoiceLine = this.extractPackedVariable(_packedClass, varStr(custInvoiceLine));
        salesBalance = this.extractPackedVariable(_packedClass, varStr(salesBalance));
        lineDisc = this.extractPackedVariable(_packedClass, varStr(lineDisc));
        sumMarkup = this.extractPackedVariable(_packedClass, varStr(sumMarkup));
        invoiceRoundOff = this.extractPackedVariable(_packedClass, varStr(invoiceRoundOff));
        sumTax = this.extractPackedVariable(_packedClass, varStr(sumTax));
        endDisc = this.extractPackedVariable(_packedClass, varStr(endDisc));
        invoiceAmount = this.extractPackedVariable(_packedClass, varStr(invoiceAmount));
        totalTaxAmount_W = this.extractPackedVariable(_packedClass, varStr(totalTaxAmount_W));
        sumTaxWithhold = this.extractPackedVariable(_packedClass, varStr(sumTaxWithhold));
        markupFreightAmountCur_BR = this.extractPackedVariable(_packedClass, varStr(markupFreightAmountCur_BR));
        markupInsuranceAmountCur_BR = this.extractPackedVariable(_packedClass, varStr(markupInsuranceAmountCur_BR));
        markupOthersAmountCur_BR = this.extractPackedVariable(_packedClass, varStr(markupOthersAmountCur_BR));
        productsTotalAmount_BR = this.extractPackedVariable(_packedClass, varStr(productsTotalAmount_BR));
        servicesTotalAmount_BR = this.extractPackedVariable(_packedClass, varStr(servicesTotalAmount_BR));
        sumTaxGTE = this.extractPackedVariable(_packedClass, varStr(sumTaxGTE));
        markupInsuranceAmountCur_BR = this.extractPackedVariable(_packedClass, varStr(markupInsuranceAmountCur_BR));
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    void calc(AmountCur salesBalanceExtra = 0, boolean delayTaxCalculation = false,
        boolean _countryRegion_EEU = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU),
        boolean _countryRegion_BR = BrazilParameters::isEnabled(),
        boolean _countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]),
        boolean _countryRegionConsolidated = SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion(),
        boolean _countryRegion_ES = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
    {
        isCustInvoiceTableCalcTotalsFeatureEnabled = CustInvoiceTableCalcTotalsFeature::isEnabled();

        boolean isCustInvoiceTableCalcTotalsExcludedByCountryRegion = 
            _countryRegion_BR
            || _countryRegion_IN
            || _countryRegion_ES
            || _countryRegionConsolidated;

        isAllowCustInvoiceTableCalcTotals = 
            isCustInvoiceTableCalcTotalsFeatureEnabled
            && isCustInvoiceTableCalcTotalsExcludedByCountryRegion == false
            && delayTaxCalculation == false;

        using (var createCalcTotalsActivityContext = calcTotalsInstrumentationLogger.activityContextWithCustomProperties(CustFreeInvoiceCalcTotalsInstrumentationConstants::CustFreeInvoiceCalcTotalsCalc))
        {
            if (this.useCustInvoiceTableCalcTotals())
            {
                isUsingCustInvoiceTableCalcTotals = true;
            }
            else
            {
                this.calcInternal(
                    salesBalanceExtra,
                    delayTaxCalculation,
                    _countryRegion_EEU,
                    _countryRegion_BR,
                    _countryRegion_IN,
                    _countryRegionConsolidated,
                    _countryRegion_ES);

                this.saveCustInvoiceTableCalcTotals();
            }

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::IsCustInvoiceTableCalcTotalsFeatureInUse,
                isCustInvoiceTableCalcTotalsFeatureEnabled ? 'true' : 'false');

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::IsAllowCustInvoiceTableCalcTotals,
                isAllowCustInvoiceTableCalcTotals ? 'true' : 'false');

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::IsExcludedDelayTaxCalculation,
                delayTaxCalculation ? 'true' : 'false');

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::IsExcludedByCountryRegion,
                isCustInvoiceTableCalcTotalsExcludedByCountryRegion ? 'true' : 'false');

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::IsUsingCustInvoiceTableCalcTotals,
                isUsingCustInvoiceTableCalcTotals ? 'true' : 'false');

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::IsSaveCalcTotalsForPostingInvoice,
                isSaveCalcTotalsForPostingInvoice ? 'true' : 'false');

            createCalcTotalsActivityContext.addCustomProperty(
                CustFreeInvoiceCalcTotalsInstrumentationConstants::CustInvoiceTableCalcTotalsReference,
                int642Str(custInvoiceTable.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useCustInvoiceTableCalcTotals</Name>
				<Source><![CDATA[
    private boolean useCustInvoiceTableCalcTotals()
    {
        boolean canUseCustInvoiceTableCalcTotals = false;

        if (custInvoiceTable)
        {
            custInvoiceTableCalcTotals = CustInvoiceTableCalcTotals::findByCustInvoiceTable(custInvoiceTable);

            if (isAllowCustInvoiceTableCalcTotals
                && !isSaveCalcTotalsForPostingInvoice)
            {
                //
                // Only use existing saved totals when not posting an invoice.
                // This will allow new saved totals to replace any possibly out of date values
                // for the invoice being posted.
                //

                if (custInvoiceTableCalcTotals
                    && custInvoiceTableCalcTotals.PackedCustFreeInvoiceCalcTotals != conNull())
                {
                    this.unpack(custInvoiceTableCalcTotals.PackedCustFreeInvoiceCalcTotals);

                    canUseCustInvoiceTableCalcTotals = true;
                }
            }
        }

        return canUseCustInvoiceTableCalcTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveCustInvoiceTableCalcTotals</Name>
				<Source><![CDATA[
    private void saveCustInvoiceTableCalcTotals()
    {
        if (custInvoiceTable)
        {
            if (custInvoiceTableCalcTotals
                && custInvoiceTableCalcTotals.CustInvoiceTable == custInvoiceTable.RecId)
            {
                // Remove any existing saved totals before saving new values.
                custInvoiceTableCalcTotals.selectForUpdate(true);

                ttsbegin;
                custInvoiceTableCalcTotals.delete();
                ttscommit;
            }

            if (isAllowCustInvoiceTableCalcTotals
                && isSaveCalcTotalsForPostingInvoice)
            {
                custInvoiceTableCalcTotals.clear();
                custInvoiceTableCalcTotals.CustInvoiceTable = custInvoiceTable.RecId;
                custInvoiceTableCalcTotals.PackedCustFreeInvoiceCalcTotals = this.pack();

                custInvoiceTableCalcTotals.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInternal</Name>
				<Source><![CDATA[
    private void calcInternal(
        AmountCur salesBalanceExtra,
        boolean delayTaxCalculation,
        boolean _countryRegion_EEU,
        boolean _countryRegion_BR,
        boolean _countryRegion_IN,
        boolean _countryRegionConsolidated,
        boolean _countryRegion_ES)
    {
        Markup markup;
        CustInvoiceCalcTax_Table custInvoiceCalcTax;
        CustInvoiceLine localCustInvoiceLine;
        CustInvoiceTrans localCustInvoiceTrans;
        CustInvoiceJour localCustInvoiceJour;
        // <GIN>
        TmpTaxWithholdWorkTrans_IN tmpTaxWithholdWorkTrans;
        // </GIN>

        // <GEEU>
        TaxAmountCur markupTax;
        // </GEEU>

        boolean isGTEEnabled = TaxSolutionScopeIntegrationUtil::isCompanyEnabled();
        lineDisc = 0;

        totalQty = (select sum(Quantity) from custInvoiceLine
                        where custInvoiceLine.ParentRecId == custInvoiceTable.RecId).Quantity;

        salesBalance = this.calculateSalesBalance(custInvoiceTable.RecId, salesBalanceExtra);

        markup = new Markup(custInvoiceTable.CurrencyCode);

        if (custInvoiceLine)
        {
            custInvoiceCalcTax = CustInvoiceCalcTax::construct(custInvoiceLine);
        }
        else
        {
            custInvoiceCalcTax = CustInvoiceCalcTax::construct(custInvoiceTable);
        }

        // <GEERU>
        if (!_countryRegion_EEU)
        {
            if (!delayTaxCalculation)
            {
                sumTax = custInvoiceCalcTax.calcTax(salesBalance);
                // Tax on markups on free text invoice -->
                markup.setTax(custInvoiceCalcTax.tax());

                if (isGTEEnabled)
                {
                    this.calcSumTaxGTE();
                }

                this.tax(custInvoiceCalcTax.tax());
            }
            else
            {
                this.tax(null);
            }

            AmountCur salesBalanceForMarkup = this.getSalesBalanceForMarkup(custInvoiceTable.RecId, salesBalanceExtra);

            // </GEERU>
            if (custInvoiceTable.Posted)
            {
                localCustInvoiceJour = custInvoiceTable.custInvoiceJour();
                markup.calc(1, salesBalanceForMarkup, localCustInvoiceJour);
            }
            else
            {
                markup.calc(1, salesBalanceForMarkup, custInvoiceTable);
            }

            sumMarkup = markup.markupCustVend();

            markupTax = markup.markupTaxTotal();
            
            // <GBR>
            if (_countryRegion_BR)
            {
                productsTotalAmount_BR = (select sum(AmountCur)
                                                from custInvoiceLine
                                                   where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
                                                    && custInvoiceLine.ServiceInvoice_BR == false).AmountCur;

                servicesTotalAmount_BR = (select sum(AmountCur)
                                                from custInvoiceLine
                                                   where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
                                                    && custInvoiceLine.ServiceInvoice_BR == true).AmountCur;
            }
            // </GBR>

            endDisc = CurrencyExchangeHelper::amount(salesBalance * this.discPercent() / 100, this.custFreeInvoiceCurrency());

            if (custInvoiceLine)
            {
                if (_countryRegionConsolidated)
                {
                    markup.calc(custInvoiceLine.Quantity, custInvoiceLine.AmountCur, custInvoiceLine);
                    sumMarkup += markup.markupCustVend();
                }
            }
            else
            {
                if (_countryRegionConsolidated)
                {
                    while select localCustInvoiceLine
                        where localCustInvoiceLine.ParentRecId == custInvoiceTable.RecId
                    {
                        markup.calc(localCustInvoiceLine.Quantity, localCustInvoiceLine.AmountCur, localCustInvoiceLine);
                        sumMarkup += markup.markupCustVend();
                    }
                }

            }

            // <GBR>
            if (_countryRegion_BR)
            {
                markupFreightAmountCur_BR = markup.markupFreight_BR();
                markupInsuranceAmountCur_BR = markup.markupInsurance_BR();
                markupOthersAmountCur_BR = markup.markupOther_BR();
            }
            // </GBR>

            // <GIN>
            if (_countryRegion_IN && TaxWithholdParameters_IN::checkTaxParameters()
                && !delayTaxCalculation)
            {
                sumTaxWithhold = custInvoiceCalcTax.calcWithholdTax_IN(salesBalance);
                taxWithhold = new TaxWithhold_IN();
                this.taxWithholdCalcFreeInvoice_IN(custInvoiceCalcTax.taxWithholdCalcFreeInvoice_IN());
                tmpTaxWithholdWorkTrans = taxWithhold.tmpTaxWithholdWorkTrans(taxWithholdCalcFreeInvoice.tmpTaxWithholdWorkTrans());
                taxWithhold.loadTaxWithholdRegulation(tmpTaxWithholdWorkTrans);
            }
            else
            {
                this.taxWithholdCalcFreeInvoice_IN(null);
            }
            // </GIN>
            // <GEERU>
        }
        // </GEERU>
        // <GIN>
        if (_countryRegion_IN && TaxParameters::checkTaxParameters_IN() && !delayTaxCalculation)
        {
            this.getInclTaxAmount_IN();
        }
        // </GIN>
        // <GEERU>
        if (_countryRegion_EEU)
        {
            if (!delayTaxCalculation)
            {
                sumTax = custInvoiceCalcTax.calcTax(salesBalance);

                if (isGTEEnabled)
                {
                    this.calcSumTaxGTE();
                }

                this.tax(custInvoiceCalcTax.tax());

                // Tax on markups on free text invoice -->
                markup.setTax(custInvoiceCalcTax.tax());
                markup.parmInitMarkupTrans_RU(true);
            }
            else
            {
                this.tax(null);
                markup.setTax(null);
                markup.parmInitMarkupTrans_RU(false);
            }

            ttsbegin;
            if (custInvoiceTable.Posted)
            {
                markup.parmInitMarkupTrans_RU(false);
                localCustInvoiceJour = custInvoiceTable.custInvoiceJour();
                markup.calc(1, salesBalance, localCustInvoiceJour);
                sumMarkup = markup.markupCustVend();
                markupTax = markup.markupTax_W();

                if (custInvoiceLine)
                {
                    select localCustInvoiceTrans
                        where localCustInvoiceTrans.SalesId == localCustInvoiceJour.SalesId &&
                            localCustInvoiceTrans.InvoiceId == localCustInvoiceJour.InvoiceId &&
                            localCustInvoiceTrans.InvoiceDate == localCustInvoiceJour.InvoiceDate &&
                            localCustInvoiceTrans.NumberSequenceGroup == localCustInvoiceJour.NumberSequenceGroup &&
                            localCustInvoiceTrans.LineNum == custInvoiceLine.LineNum;

                    markup.calc(localCustInvoiceTrans.Qty, localCustInvoiceTrans.LineAmount, localCustInvoiceTrans);
                    sumMarkup += markup.markupCustVend();
                    markupTax += markup.markupTax_W();
                }
                else
                {
                    while select localCustInvoiceTrans
                        where localCustInvoiceTrans.SalesId == localCustInvoiceJour.SalesId &&
                            localCustInvoiceTrans.InvoiceId == localCustInvoiceJour.InvoiceId &&
                            localCustInvoiceTrans.InvoiceDate == localCustInvoiceJour.InvoiceDate &&
                            localCustInvoiceTrans.NumberSequenceGroup == localCustInvoiceJour.NumberSequenceGroup
                    {
                        markup.calc(localCustInvoiceTrans.Qty, localCustInvoiceTrans.LineAmount, localCustInvoiceTrans);
                        sumMarkup += markup.markupCustVend();
                        markupTax += markup.markupTax_W();
                    }
                }
            }
            else
            {
                markup.calc(1, salesBalance, custInvoiceTable);
                sumMarkup = markup.markupCustVend();
                markupTax = markup.markupTax_W();

                if (custInvoiceLine)
                {
                    markup.calc(custInvoiceLine.Quantity, custInvoiceLine.AmountCur, custInvoiceLine);
                    sumMarkup += markup.markupCustVend();
                    markupTax += markup.markupTax_W();
                }
                else
                {
                    while select localCustInvoiceLine
                        where localCustInvoiceLine.ParentRecId == custInvoiceTable.RecId
                    {
                        markup.calc(localCustInvoiceLine.Quantity, localCustInvoiceLine.AmountCur, localCustInvoiceLine);
                        sumMarkup += markup.markupCustVend();
                        markupTax += markup.markupTax_W();
                    }
                }
            }

            ttscommit;
            // Tax on markups on free text invoice <--

            endDisc = CurrencyExchangeHelper::amount(salesBalance * this.discPercent() / 100, this.custFreeInvoiceCurrency());
        }
        // </GEERU>

        if (!isGTEEnabled)
        {
            invoiceAmount = salesBalance
                            - endDisc
                            + sumMarkup
                            + (custInvoiceTable.InclTax ? 0 : sumTax)
                            + (custInvoiceTable.InclTax ? markupTax : 0);

            if (custInvoiceTable.InclTax)
            {
                salesBalance = 0;
                custInvoiceCalcTax.initCursor();

                while (custInvoiceCalcTax.nextLine())
                {
                    salesBalance += custInvoiceCalcTax.baseAmount();
                }
            }
        }
        else
        {
            salesBalance = 0;
            custInvoiceCalcTax.initCursor();

            while (custInvoiceCalcTax.nextLine())
            {
                salesBalance += custInvoiceCalcTax.baseAmount();
            }

            invoiceAmount = salesBalance
                            - endDisc
                            + sumMarkup
                            + sumTax
                            + markupTax;
        }

        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custInvoiceTable.TableId, custInvoiceTable.RecId))
        {
            if (_countryRegion_ES && TaxParameters::canApplyCashDiscOnInvoice_ES())
            {
                cashDisc = CustParameters::cashDiscAmount(custInvoiceTable.CashDiscCode,
                                                          custInvoiceTable.CurrencyCode,
                                                          invoiceAmount,
                                                          invoiceAmount - sumTax,
                                                          custInvoiceTable.CashDiscPercent);

                invoiceAmount = invoiceAmount - cashDisc;

                if (invoiceAmount)
                {
                    invoiceRoundOff = this.roundedOffTotalAmount(invoiceAmount) - invoiceAmount;
                }
                invoiceAmount += invoiceRoundOff;
            }
            else
            {
                if (invoiceAmount)
                {
                    invoiceRoundOff = this.invoiceAmountRoundOff(invoiceAmount);
                }

                if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled()
                    && custInvoiceTable.TCSGroup_IN != '')
                {
                    invoiceAmount = this.roundedOffTotalAmount(invoiceAmount + sumTaxWithhold)
                        - this.roundedOffTotalAmount(sumTaxWithhold);
                }
                else
                {
                    invoiceAmount += invoiceRoundOff;
                }

                cashDisc = CustParameters::cashDiscAmount(custInvoiceTable.CashDiscCode,
                                                          custInvoiceTable.CurrencyCode,
                                                          invoiceAmount,
                                                          invoiceAmount - sumTax);
            }
        }

        // <GTE>
        if (isGTEEnabled
            && custInvoiceTable.InclTax_W
            && _countryRegion_IN)
        {
            invoiceAmount += sumTax;
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmountRoundOff</Name>
				<Source><![CDATA[
    private AmountCur invoiceAmountRoundOff(AmountCur _invoiceAmount)
    {
        if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled()
            && custInvoiceTable.TCSGroup_IN != '')
        {
            return this.roundedOffTotalAmount(_invoiceAmount + sumTaxWithhold)
                        - _invoiceAmount - sumTaxWithhold;
        }
        else
        {
            return this.roundedOffTotalAmount(invoiceAmount) - invoiceAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAmount</Name>
				<Source><![CDATA[
    AmountCur cashDiscAmount()
    {
        return cashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscCode</Name>
				<Source><![CDATA[
    public CashDiscCode cashDiscCode()
    {
        return custInvoiceTable.CashDiscCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscDate</Name>
				<Source><![CDATA[
    public DiscDate cashDiscDate()
    {
        return CustParameters::cashDiscDate(this.cashDiscCode(), this.documentDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total invoice quantity.
    /// </summary>
    /// <returns>
    /// The total quantity of invoice.
    /// </returns>
    internal UnitQty custFreeInvoiceQty()
    {
        return totalQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceBalance</Name>
				<Source><![CDATA[
    AmountCur custFreeInvoiceBalance()
    {
        return salesBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceCashDisc</Name>
				<Source><![CDATA[
    CustCashDiscAmount custFreeInvoiceCashDisc()
    {
        return cashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceCreditMax</Name>
				<Source><![CDATA[
    AmountMST custFreeInvoiceCreditMax()
    {
        return CustTable::creditMax(this.invoiceAccount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceCurrency</Name>
				<Source><![CDATA[
    CustCurrencyCode custFreeInvoiceCurrency()
    {
        return custInvoiceTable.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceEndDisc</Name>
				<Source><![CDATA[
    SalesEndDiscAmount custFreeInvoiceEndDisc()
    {
        return endDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceExchRate</Name>
				<Source><![CDATA[
    ExchRate custFreeInvoiceExchRate()
    {
        return custInvoiceTable.getExchRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceExchRateSecondary</Name>
				<Source><![CDATA[
    ExchrateSecondary custFreeInvoiceExchRateSecondary()
    {
        return custInvoiceTable.getExchRateSecondary();
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceFreeValue</Name>
				<Source><![CDATA[
    AmountMST custFreeInvoiceFreeValue()
    {
        AmountMST freeValue;
        CustTable custTable = CustTable::find(this.invoiceAccount());

        if (custTable.CreditMax)
        {
            freeValue = custTable.CreditMax -
                          custTable.openBalanceMST() -
                         (custInvoiceTable.InvoiceId ? 0 :
                          CurrencyExchangeHelper::mstAmount(this.custFreeInvoiceInvoiceAmount(), this.custFreeInvoiceCurrency(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Currency::noYes2UnknownNoYes(this.custFreeInvoiceTriangulation()), this.custFreeInvoiceExchRate(), this.custFreeInvoiceExchRateSecondary()));

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoPL])
                && custTable.MandatoryCreditLimit
                && CustParameters::find().CreditMaxCheck !=  TypeOfCreditmaxCheck::None)
            {
                CzCustAdvanceInvoiceTable advanceInvoice;

                select firstonly sum(InvoiceAmount)
                    from advanceInvoice
                    where advanceInvoice.OrderAccount == custTable.AccountNum
                        && (advanceInvoice.Type == AdvanceInvoiceType_W::Common
                            || advanceInvoice.Type == AdvanceInvoiceType_W::Reversal)
                        && advanceInvoice.FreeInvoiceRefRecId == custInvoiceTable.RecId;
                
                freeValue += advanceInvoice.InvoiceAmount;
            }
        }
        else
        {
            freeValue = 0;
        }
        return freeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceInvoiceAmount</Name>
				<Source><![CDATA[
    AmountCur custFreeInvoiceInvoiceAmount()
    {
        return invoiceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceInvoiceAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total amount for the GTE.
    /// </summary>
    /// <returns>
    /// The total amount for the GTE
    /// </returns>
    public AmountCur custFreeInvoiceInvoiceAmountGTE()
    {
        return this.custFreeInvoiceInvoiceAmount() - sumTax + sumTaxGTE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceLineDisc</Name>
				<Source><![CDATA[
    DiscAmount custFreeInvoiceLineDisc()
    {
        return lineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceMarkup</Name>
				<Source><![CDATA[
    MarkupSumSales custFreeInvoiceMarkup()
    {
        return sumMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceRoundOff</Name>
				<Source><![CDATA[
    RoundOff custFreeInvoiceRoundOff()
    {
        return invoiceRoundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceTaxTotal</Name>
				<Source><![CDATA[
    TaxAmountCur custFreeInvoiceTaxTotal()
    {
        return sumTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceTaxTotalGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sum tax for GTE.
    /// </summary>
    /// <returns>
    /// The sum tax for GTE.
    /// </returns>
    TaxAmountCur custFreeInvoiceTaxTotalGTE()
    {
        return sumTaxGTE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceTaxWithholdTotal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total taxWithhold Amount for Free text invoice.
    /// </summary>
    /// <returns>
    /// Returns total taxWithhold Amount for Free text invoice.
    /// </returns>
    public TaxAmountCur custFreeInvoiceTaxWithholdTotal_IN()
    {
        return sumTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custFreeInvoiceTriangulation</Name>
				<Source><![CDATA[
    EUROTriangulation custFreeInvoiceTriangulation()
    {
        return custInvoiceTable.euroTriangulation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDate_ES</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the delivery date for the related goods/services.
    /// </summary>
    /// <returns>
    ///    The delivery date for the related goods/services.
    /// </returns>
    public TransDate deliveryDate_ES()
    {
        return custInvoiceTable.DeliveryDate_ES;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discPercent</Name>
				<Source><![CDATA[
    DiscPct discPercent()
    {
        return custInvoiceTable.discPercent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFields</Name>
				<Source><![CDATA[
    container displayFields(container fields = conNull())
    {
        int maxPos = 13;
        int pos = 1;
        container displayFields;

        pos = 1;

        while (pos <= maxPos)
        {
            displayFields += [pos];
            pos++;
        }

        if (conLen(fields) == 0)
            fields = displayFields;

        pos = 1;

        while (pos <= conLen(fields))
        {
            switch (conPeek(fields, pos))
            {
                case CustFreeInvoiceCalcTotals::posCashDisc() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posCashDisc() , this.custFreeInvoiceCashDisc()); break;
                case CustFreeInvoiceCalcTotals::posCurrency() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posCurrency() , this.custFreeInvoiceCurrency()); break;
                case CustFreeInvoiceCalcTotals::posExchRate() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posExchRate() , this.custFreeInvoiceExchRate()); break;
                case CustFreeInvoiceCalcTotals::posCreditMax() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posCreditMax() , this.custFreeInvoiceCreditMax()); break;
                case CustFreeInvoiceCalcTotals::posFreeValue() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posFreeValue() , this.custFreeInvoiceFreeValue()); break;
                case CustFreeInvoiceCalcTotals::posLineDisc() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posLineDisc() , this.custFreeInvoiceLineDisc()); break;
                case CustFreeInvoiceCalcTotals::posEndDisc() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posEndDisc() , this.custFreeInvoiceEndDisc()); break;
                case CustFreeInvoiceCalcTotals::posBalance() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posBalance() , this.custFreeInvoiceBalance()); break;
                case CustFreeInvoiceCalcTotals::posMarkup() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posMarkup() , this.custFreeInvoiceMarkup()); break;
                case CustFreeInvoiceCalcTotals::posTaxTotal() :
                    // <GTE>
                    if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                    {
                        displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posTaxTotal(), this.custFreeInvoiceTaxTotalGTE());
                    }
                    else
                    {
                        // </GTE>
                        displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posTaxTotal(), this.custFreeInvoiceTaxTotal());
                        // <GTE>
                    }
                    // </GTE>
                    break;
                case CustFreeInvoiceCalcTotals::posWithholdTCSAmount_IN():
                    if (taxWithhold && taxWithhold.taxTCSType())
                    {
                        displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posWithholdTCSAmount_IN(), sumTaxWithhold);
                    }
                    else
                    {
                        displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posWithholdTCSAmount_IN(), 0);
                    }
                    break;
                case CustFreeInvoiceCalcTotals::posRoundOff() : displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posRoundOff() , this.custFreeInvoiceRoundOff()); break;
                case CustFreeInvoiceCalcTotals::posTotalAmount():
                    // <GTE>
                    if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                    {
                        displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posTotalAmount(), this.custFreeInvoiceInvoiceAmountGTE());
                    }
                    else
                    {
                        // </GTE>
                        displayFields = conPoke(displayFields, CustFreeInvoiceCalcTotals::posTotalAmount(), this.custFreeInvoiceInvoiceAmount());
                        // <GTE>
                    }
                    // </GTE>

                    if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled()
                        && custInvoiceTable.TCSGroup_IN != '')
                    {
                        displayFields = conPoke(
                            displayFields,
                            CustFreeInvoiceCalcTotals::posTotalAmount(),
                            conpeek(displayFields, CustFreeInvoiceCalcTotals::posTotalAmount()) + this.roundedOffTotalAmount(sumTaxWithhold));
                    }
                    break;
            }

            pos++;
        }

        return displayFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDate</Name>
				<Source><![CDATA[
    public DocumentDate documentDate()
    {
        DocumentDate documentDate;
        if (custInvoiceTable.CashDiscBaseDate)
        {
            documentDate = custInvoiceTable.CashDiscBaseDate;
        }
        else
        {
            documentDate = this.invoiceDate();
        }
        return documentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the postal address associated with the bank account.
    /// </summary>
    /// <returns>
    /// The <c>LogisticsPostalAddress</c> record that represents the postal address.
    /// </returns>
    public LogisticsPostalAddress getBankPostalAddress()
    {
        CustBankAccount custBankAccount;

        custBankAccount = CustBankAccount::findByCompany(custInvoiceTable.dataAreaId, custInvoiceTable.InvoiceAccount, custInvoiceTable.CustBankAccountId);

        return LogisticsLocationEntity::location2PostalAddress(custBankAccount.Location);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the postal address associated with the document.
    /// </summary>
    /// <returns>
    /// The <c>LogisticsPostalAddress</c> record that represents the postal address.
    /// </returns>
    public LogisticsPostalAddress getDocumentPostalAddress()
    {
        return LogisticsPostalAddress::findRecId(custInvoiceTable.PostalAddress);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// calculate inclusive tax amount and update the salesBalance.
    /// </summary>
    public void getInclTaxAmount_IN()
    {
        TaxAmountCur inclTaxAmount;
        TmpTaxWorkTrans tmpTaxWorkTrans;
        CustInvoiceLine custInvoicelineloc;
        FormulaDesigner_IN formulaDesigner;
        TaxableBasis_IN taxBasis;
        TmpTaxCalc_IN tmpTaxCalc;

        while select TaxItemGroup, TableId, RecId from custInvoicelineloc
            index hint ParentRecIdIdx
            where custInvoicelineloc.ParentRecId == custInvoiceTable.RecId
        {
            if (FormulaDesigner_IN::isPriceInclTaxLine(custInvoicelineloc.TaxItemGroup))
            {
                tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
                tmpTaxCalc = this.tax().tmpTaxCalc_IN();
                while select tmpTaxWorkTrans
                    where tmpTaxWorkTrans.SourceRecId == custInvoicelineloc.RecId &&
                          tmpTaxWorkTrans.SourceTableId == custInvoicelineloc.TableId &&
                          tmpTaxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                          tmpTaxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
                {
                    formulaDesigner = FormulaDesigner_IN::findByTaxCode(tmpTaxWorkTrans.TaxItemGroup, tmpTaxWorkTrans.TaxCode);
                    if (formulaDesigner.PriceInclTax)
                    {
                        select firstonly tmpTaxCalc
                            where tmpTaxCalc.TaxCode == tmpTaxWorkTrans.TaxCode &&
                                   tmpTaxCalc.SourceTableID == custInvoicelineloc.TableId &&
                                   tmpTaxCalc.SourceRecID == custInvoicelineloc.RecId;

                        taxBasis = formulaDesigner.TaxableBasis;
                        if (taxBasis == TaxableBasis_IN::ExclAmount)
                        {
                            taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                        }
                        if (TaxTable::find(tmpTaxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                            && (taxBasis == TaxableBasis_IN::LineAmount
                                || taxBasis == TaxableBasis_IN::Assessable))
                        {
                            if (!tmpTaxWorkTrans.SourceRegulateAmountCur)
                            {
                                inclTaxAmount += tmpTaxWorkTrans.SourceTaxAmountCur;
                            }
                            else
                            {
                                inclTaxAmount += tmpTaxWorkTrans.SourceRegulateAmountCur;
                            }
                            if (inclTaxAmount < 0)
                            {
                                inclTaxAmount += tmpTaxCalc.TaxOnCharges;
                            }
                            else
                            {
                                inclTaxAmount -= tmpTaxCalc.TaxOnCharges;
                            }
                        }
                    }
                }
            }
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            ITaxableDocument taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custInvoiceTable));
            ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
            if (taxDocumentObject)
            {
                inclTaxAmount = taxDocumentObject.getInclTax().amountTransactionCurrency();
            }
        }
        // </GTE>

        if (inclTaxAmount)
        {
            if (salesBalance < 0)
            {
                salesBalance = CurrencyExchangeHelper::amount(abs(salesBalance) - abs(inclTaxAmount)) * -1;
            }
            else
            {
                salesBalance = CurrencyExchangeHelper::amount(salesBalance - abs(inclTaxAmount));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrimaryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the postal address associated with the third-party entity.
    /// </summary>
    /// <returns>
    /// The <c>LogisticsPostalAddress</c> record that represents the postal address.
    /// </returns>
    public LogisticsPostalAddress getPrimaryPostalAddress()
    {
        CustTable custTable;

        custTable = CustTable::findByCompany(custInvoiceTable.dataAreaId, custInvoiceTable.InvoiceAccount);

        return custTable.postalAddress();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invoice due date.
    /// </summary>
    /// <returns>
    /// The due date of invoice.
    /// </returns>
    [Hookable(false)]
    public DueDate getInvoiceDueDate()
    {
        return custInvoiceTable.DueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccount</Name>
				<Source><![CDATA[
    CustAccount invoiceAccount()
    {
        return custInvoiceTable.InvoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceDate</Name>
				<Source><![CDATA[
    protected TransDate invoiceDate()
    {
        return custInvoiceTable.InvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupFreightAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the markup freight amount in the accounting currency
    /// </summary>
    /// <returns>
    /// A real value with the freight
    /// </returns>
    public AmountMST markupFreightAmountMST_BR()
    {
        return CurrencyExchangeHelper::mstAmount(markupFreightAmountCur_BR, this.custFreeInvoiceCurrency(), custInvoiceTable.InvoiceDate, UnknownNoYes::No, this.custFreeInvoiceExchRate(), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupInsuranceAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the markup insurance amount in the accounting currency
    /// </summary>
    /// <returns>
    /// A real value with the insurance
    /// </returns>
    public AmountMST markupInsuranceAmountMST_BR()
    {
        return CurrencyExchangeHelper::mstAmount(markupInsuranceAmountCur_BR, this.custFreeInvoiceCurrency(), custInvoiceTable.InvoiceDate, UnknownNoYes::No, this.custFreeInvoiceExchRate(), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOthersAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the markup others amount in the accounting currency
    /// </summary>
    /// <returns>
    /// A real value with the others amount
    /// </returns>
    public AmountMST markupOthersAmountMST_BR()
    {
        return CurrencyExchangeHelper::mstAmount(markupOthersAmountCur_BR, this.custFreeInvoiceCurrency(), custInvoiceTable.InvoiceDate, UnknownNoYes::No, this.custFreeInvoiceExchRate(), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Common _common)
    {
        switch (_common.TableId)
        {
            case tableNum(CustInvoiceTable) :
                custInvoiceTable = _common;
                break;
            case tableNum(CustInvoiceLine) :
                custInvoiceLine = _common;
                custInvoiceTable = custInvoiceLine.custInvoiceTable();
                break;
        }

        calcTotalsInstrumentationLogger = CustFreeInvoiceCalcTotalsInstrumentationLogger::createLogger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModuleType</Name>
				<Source><![CDATA[
    public PaymCalendarModuleType parmModuleType()
    {
        return PaymCalendarModuleType::Customer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    public PaymMode parmPaymMode()
    {
        return custInvoiceTable.PaymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmPaymTermDataAreaId()
    {
        return custInvoiceTable.dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermId</Name>
				<Source><![CDATA[
    public PaymTermId parmPaymTermId()
    {
        return custInvoiceTable.Payment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymCode</Name>
				<Source><![CDATA[
    public PaymTermId paymCode()
    {
        return custInvoiceTable.Payment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymDayId</Name>
				<Source><![CDATA[
    public PaymDayId paymDayId()
    {
        return custInvoiceTable.paymDayId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>productsTotalAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the products total amount in the accounting currency
    /// </summary>
    /// <returns>
    /// A real value with the products total
    /// </returns>
    public AmountMST productsTotalAmount_BR()
    {
        return CurrencyExchangeHelper::mstAmount(productsTotalAmount_BR, this.custFreeInvoiceCurrency(), custInvoiceTable.InvoiceDate, UnknownNoYes::No, this.custFreeInvoiceExchRate(), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedOffTotalAmount</Name>
				<Source><![CDATA[
    public AmountCur roundedOffTotalAmount(AmountCur _totalAmount)
    {
        return CurrencyExchange::roundWithRuleType(
            _totalAmount,
            custInvoiceTable.CurrencyCode,
            CurrencyRoundingRuleType::SalesOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>servicesTotalAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the services total amount in the accounting currency
    /// </summary>
    /// <returns>
    /// A real value with the services total
    /// </returns>
    public AmountMST servicesTotalAmount_BR()
    {
        return CurrencyExchangeHelper::mstAmount(servicesTotalAmount_BR, this.custFreeInvoiceCurrency(), custInvoiceTable.InvoiceDate, UnknownNoYes::No, this.custFreeInvoiceExchRate(), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendData_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets cust vend data into cust free invoice calculate totals.
    /// </summary>
    /// <param name="_invoiceCompany">
    /// The invoice company information.
    /// </param>
    /// <param name="_paymentCompany">
    /// The payment company information.
    /// </param>
    /// <param name="_accountNumber">
    /// The account number.
    /// </param>
    /// <param name="_taxWithholdCalculation">
    /// The tax withhold calculation method.
    /// </param>
    /// <returns>
    /// The cust vend data information.
    /// </returns>
    protected container setCustVendData_IN( CompanyId _invoiceCompany,
                                            CompanyId _paymentCompany,
                                            CustVendAC _accountNumber,
                                            TaxWithholdCalculation_IN _taxWithholdCalculation)
    {
        container custVendInfo = conNull();

        _taxWithholdCalculation.setInvoiceCompany(_invoiceCompany);
        _taxWithholdCalculation.setPaymentCompany(_paymentCompany);
        custVendInfo += _accountNumber;
        custVendInfo += '';
        custVendInfo += '';
        custVendInfo += '';
        custVendInfo += _invoiceCompany;
        custVendInfo += _paymentCompany;

        return custVendInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax</Name>
				<Source><![CDATA[
    TaxFreeInvoice tax(TaxFreeInvoice _tax = tax)
    {
        tax = _tax;
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTransAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the custTrans amount.
    /// </summary>
    /// <returns>
    ///   The invoiceAmount subtracted of retained tax amount in transactional currency.
    /// </returns>
    public AmountCur custTransAmount_BR()
    {
        return this.custFreeInvoiceInvoiceAmount() - tax.totalTaxAmountRetained_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithhold_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets tax withhold value.
    /// </summary>
    /// <param name="_taxWithhold">
    /// The taxwithhold value.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithhold_IN</c> class.
    /// </returns>
    public TaxWithhold_IN taxWithhold_IN(TaxWithhold_IN _taxWithhold = taxWithhold)
    {
        taxWithhold = _taxWithhold;

        return taxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalcFreeInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets TaxWithholdCalcFreeInvoice_IN class instance.
    /// </summary>
    /// <param name="_taxWithholdCalcFreeInvoice">
    /// The TaxWithholdCalcFreeInvoice_IN class instance.
    /// </param>
    /// <returns>
    /// Returns TaxWithholdCalcFreeInvoice_IN class instance.
    /// </returns>
    public TaxWithholdCalcFreeInvoice_IN taxWithholdCalcFreeInvoice_IN(TaxWithholdCalcFreeInvoice_IN _taxWithholdCalcFreeInvoice = taxWithholdCalcFreeInvoice)
    {
        taxWithholdCalcFreeInvoice = _taxWithholdCalcFreeInvoice;
        return taxWithholdCalcFreeInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        CustInvoiceJour custInvoiceJour = custInvoiceTable.custInvoiceJour();
        if (custInvoiceJour)
        {
            return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custInvoiceJour);
        }

        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custInvoiceTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsAllowCustInvoiceTableCalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>isAllowCustInvoiceTableCalcTotals</c> value.
    /// </summary>
    /// <returns>
    /// true when the <c>calc()</c> method parameters allow a cached <c>CustFreeInvoiceCalcTotals</c> instance to be created for the calculated totals; otherwise, false.
    /// </returns>
    internal boolean getIsAllowCustInvoiceTableCalcTotals()
    {
        return isAllowCustInvoiceTableCalcTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsUsingCustInvoiceTableCalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>isUsingCustInvoiceTableCalcTotals</c> value.
    /// </summary>
    /// <returns>
    /// true when a cached <c>CustFreeInvoiceCalcTotals</c> instance is being used to supplied the calculated totals; otherwise, false.
    /// </returns>
    internal boolean getIsUsingCustInvoiceTableCalcTotals()
    {
        return isUsingCustInvoiceTableCalcTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsSaveCalcTotalsForPostingInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>isSaveCalcTotalsForPostingInvoice</c> value.
    /// </summary>
    /// <returns>
    /// true when the <c>CustFreeInvoiceCalcTotals</c> instance is being used to calculate totals when posting an invoice; otherwise, false.
    /// </returns>
    internal boolean getIsSaveCalcTotalsForPostingInvoice()
    {
        return isSaveCalcTotalsForPostingInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the adjusted due date so that it falls on a business day per calendar rules.
    /// </summary>
    /// <param name="_custInvoiceTable">
    /// The customer invoice table buffer that specifies the due date and the calendar source.
    /// </param>
    /// <returns>
    /// An instance of the <c>PaymCalendarAdjustedDate</c> record which contains the adjusted due date
    /// together with the calendar and rule that was applied when adjusting the date.
    /// </returns>
    /// <remarks>
    /// If no adjustment is needed, the original date is returned. An empty record ID is returned for the
    /// payment calendar and calendar rule whenever a calendar is not found.
    /// </remarks>
    public static PaymCalendarAdjustedDate getAdjustedDate(CustInvoiceTable _custInvoiceTable)
    {
        return CustFreeInvoiceCalcTotals::getAdjustedDatePrivate(_custInvoiceTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedDatePrivate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the adjusted due date so that it falls on a business day per calendar rules.
    /// </summary>
    /// <param name="_custInvoiceTable">
    /// The customer invoice table buffer that specifies the due date and the calendar source.
    /// </param>
    /// <returns>
    /// An instance of the <c>PaymCalendarAdjustedDate</c> record that contains the adjusted due date
    /// together with the calendar and rule that was applied when adjusting the date.
    /// </returns>
    private static PaymCalendarAdjustedDate getAdjustedDatePrivate(CustInvoiceTable _custInvoiceTable)
    {
        PaymTerm paymTerm;
        CustFreeInvoiceCalcTotals custFreeInvoiceCalcTotals;
        PaymCalendarProcessor paymCalendarProcessor;
        PaymCalendarAdjustedDate paymCalendarAdjustedDate;

        paymTerm = PaymTerm::find(_custInvoiceTable.Payment);
        if (paymTerm.CustomerUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            custFreeInvoiceCalcTotals = new CustFreeInvoiceCalcTotals(_custInvoiceTable);
            paymCalendarProcessor = PaymCalendarProcessor::construct();
            paymCalendarAdjustedDate = paymCalendarProcessor.getAdjustedDate(_custInvoiceTable.DueDate, paymTerm.CustomerUpdateDueDate, custFreeInvoiceCalcTotals);
        }
        else
        {
            paymCalendarAdjustedDate = PaymCalendarAdjustedDate::construct(_custInvoiceTable.DueDate);
        }

        return paymCalendarAdjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the adjusted due date so that it falls on a business day per calendar rules.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_custInvoiceTable">
    /// The customer invoice table buffer that specifies the calendar source.
    /// </param>
    /// <returns>
    /// An instance of the <c>PaymCalendarAdjustedDate</c> record that contains the adjusted due date
    /// together with the calendar and rule that was applied when adjusting the date.
    /// </returns>
    /// <remarks>
    /// If no adjustment is needed, the original date is returned. An empty record ID is returned for the
    /// payment calendar and calendar rule whenever a calendar is not found.
    /// </remarks>
    public static PaymCalendarAdjustedDate getAdjustedDueDate(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, CustInvoiceTable _custInvoiceTable)
    {
        return CustFreeInvoiceCalcTotals::getAdjustedDueDatePrivate(_dueDate, _updatePolicy, _custInvoiceTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedDueDatePrivate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the adjusted due date so that it falls on a business day per calendar rules.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_custInvoiceTable">
    /// The customer invoice table buffer that specifies the calendar source.
    /// </param>
    /// <returns>
    /// An instance of the <c>PaymCalendarAdjustedDate</c> record that contains the adjusted due date
    /// together with the calendar and rule that was applied when adjusting the date.
    /// </returns>
    public static PaymCalendarAdjustedDate getAdjustedDueDatePrivate(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, CustInvoiceTable _custInvoiceTable)
    {
        CustFreeInvoiceCalcTotals calendarSource;
        PaymCalendarProcessor paymCalendarProcessor;
        PaymCalendarAdjustedDate paymCalendarAdjustedDate;

        paymCalendarProcessor = PaymCalendarProcessor::construct();
        calendarSource = new CustFreeInvoiceCalcTotals(_custInvoiceTable);
        paymCalendarAdjustedDate = paymCalendarProcessor.getAdjustedDate(_dueDate, _updatePolicy, calendarSource);

        return paymCalendarAdjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posBalance</Name>
				<Source><![CDATA[
    static Integer posBalance()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCashDisc</Name>
				<Source><![CDATA[
    static Integer posCashDisc()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCreditMax</Name>
				<Source><![CDATA[
    static Integer posCreditMax()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCurrency</Name>
				<Source><![CDATA[
    static Integer posCurrency()
    {
        return 4;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posEndDisc</Name>
				<Source><![CDATA[
    static Integer posEndDisc()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posExchRate</Name>
				<Source><![CDATA[
    static Integer posExchRate()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posFreeValue</Name>
				<Source><![CDATA[
    static Integer posFreeValue()
    {
        return 7;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posLineDisc</Name>
				<Source><![CDATA[
    static Integer posLineDisc()
    {
        return 8;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkup</Name>
				<Source><![CDATA[
    static Integer posMarkup()
    {
        return 9;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posRoundOff</Name>
				<Source><![CDATA[
    static Integer posRoundOff()
    {
        return 10;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTaxTotal</Name>
				<Source><![CDATA[
    static Integer posTaxTotal()
    {
        return 11;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTotalAmount</Name>
				<Source><![CDATA[
    static Integer posTotalAmount()
    {
        return 12;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posWithholdTCSAmount_IN</Name>
				<Source><![CDATA[
    static Integer posWithholdTCSAmount_IN()
    {
        return 13;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxReverseCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax reverse charge amount.
    /// </summary>
    /// <returns>The total tax reverse charge amount.</returns>
    public TaxAmountCur totalTaxReverseCharge()
    {
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && this.tax())
        {
            taxTotalReverseCharge = this.tax().reverseChargeAmount_W();
        }
        return taxTotalReverseCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSumTaxGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum tax when gte is enabled.
    /// </summary>
    private void calcSumTaxGTE()
    {
        ITaxableDocument taxableDocument = TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor());

        ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);

        if (taxDocumentObject)
        {
            ITaxDocumentMeasureValue taxMeasureObject = taxDocumentObject.getTotalTax();
            sumTaxGTE = taxMeasureObject.amountTransactionCurrency();

            sumTax = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
            sumTax -= taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
        }
        else
        {
            sumTaxGTE = sumTax;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesBalance</Name>
				<Source><![CDATA[
    private AmountCur calculateSalesBalance(RefRecId _recId, AmountCur salesBalanceExtra)
    {
        salesBalance = (select sum(AmountCur)
                            from custInvoiceLine
                            where custInvoiceLine.ParentRecId == custInvoiceTable.RecId).AmountCur;

        salesBalance += salesBalanceExtra;
        
        return salesBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesBalanceForMarkup</Name>
				<Source><![CDATA[
    private AmountCur getSalesBalanceForMarkup(RefRecId _recId, AmountCur salesBalanceExtra)
    {
        AmountCur salesBalanceForMarkup = salesBalance;

        if (custInvoiceTable.InclTax)
        {
            // Calculate the balance used for Markup exclusive of sales tax
            salesBalanceForMarkup = custInvoiceTable.amountExclTax(custInvoiceTable.RecId) + salesBalanceExtra;
        }

        return salesBalanceForMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSaveWhenPostingInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructor for saving calculating totals to database when posting the Free text invoice.
    /// </summary>
    /// <param name = "_common">The Free text invoice that will be used for calculating totals.</param>
    /// <returns>
    /// A <c>CustFreeInvoiceCalcTotals</c> instance.
    /// </returns>
    /// <remarks>
    /// Using this constructor will set an internal property on the <c>CustFreeInvoiceCalcTotals</c> instance 
    /// that will save the calculated totals for the invoice to the database.
    /// The saved calculated totals will be used to improve performance of the invoice posting process
    /// by preventing the need to re-calculate in subsequent calculate totals requests for the invoice.
    /// This constructor is expected to be used when the totals being calculated are not expected to change afterwards.
    /// </remarks>
    internal static CustFreeInvoiceCalcTotals newForSaveWhenPostingInvoice(Common _common)
    {
        CustFreeInvoiceCalcTotals custFreeInvoiceCalcTotals = new CustFreeInvoiceCalcTotals(_common);
        custFreeInvoiceCalcTotals.isSaveCalcTotalsForPostingInvoice = true;

        return custFreeInvoiceCalcTotals;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>