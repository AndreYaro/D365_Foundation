<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchCreateFromSalesOrder</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>PurchCreateFromSalesOrder</c> class creates purchase orders based on sales orders.
/// </summary>
[TradeLineDlvTypeFactoryAttribute(TradeLineDlvType::None)]
public class PurchCreateFromSalesOrder extends RunBase
{
    TmpPurchLinePrice       tmpPurchLinePrice;
    Common                  callerRecord;
    SalesTable              salesTable;
    SalesLine               salesLine;
    boolean                 transferAddress;
    boolean                 recalculateDlvDates;
    boolean                 executeQuery;
    boolean                 insertMinMaxQty;
    boolean                 dropShipment;
    boolean                 searchForAgreements;
    boolean                 transferDeliveryAddressFromAgreement;
    boolean                 initFields;
    container               packedTable;
    TransDate               poTransDate;

    SalesId                 checkFirstSalesId;
    ProjId                  checkFirstProjId;
    SalesTable              checkPrevSalesTable;
    TradeLineDlvType        tradeLineDlvType;
    Set                     salesLineRecIdSet;

    boolean isPurchCreateFromSalesOrderInitCurrencyFlightEnabled = PurchCreateFromSalesOrderInitCurrencyFlight::instance().isEnabled();

    const int CurrentVersion = 6;
    private PurchInstrumentationLogger instrumentationLogger;

    //UI & Client / Server
    #localmacro.CurrentList
        insertMinMaxQty,
        searchForAgreements,
        transferDeliveryAddressFromAgreement
    #endmacro

    //Client / Server
    //All variables in the CurrentListCS must also be added to the method resetCurrentListCS.
    #localmacro.CurrentListCS
        callerRecord,
        salesTable,
        salesLine,
        transferAddress,
        recalculateDlvDates,
        executeQuery,
        packedTable,
        poTransDate,
        dropShipment,
        tradeLineDlvType
    #endmacro

    #localmacro.CurrentListV5
        callerRecord,
        salesTable,
        salesLine,
        transferAddress,
        executeQuery,
        packedTable,
        poTransDate,
        dropShipment,
        tradeLineDlvType
    #endmacro

    #localmacro.CurrentListV4
        callerRecord,
        salesTable,
        salesLine,
        transferAddress,
        executeQuery,
        packedTable,
        poTransDate,
        dropShipment
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canSwapBetweenCS</Name>
				<Source><![CDATA[
    protected boolean canSwapBetweenCS()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the blocked status of the given vendor account.
    /// </summary>
    /// <param name = "_vendAccount">The current vendor account.</param>
    /// <returns>true if the vendor has a blocked status; otherwise, false.</returns>
    public boolean isVendorBlocked(VendAccount _vendAccount)
    {
        return VendTable::isVendorBlocked(_vendAccount, CustVendorBlocked::PurchOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a record in the <c>TmpPurchLinePrice</c> table.
    /// </summary>
    /// <param name="_tmpPurchLinePrice">
    /// The record to validate.
    /// </param>
    /// <param name="_firstRecord">
    /// A Boolean value that specifies whether it is the first record to be validated.
    /// </param>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    protected boolean checkLine(TmpPurchLinePrice   _tmpPurchLinePrice,
                                boolean             _firstRecord)
    {
        boolean ok = true;

        if (this.parmTransferAddress())
        {
            if (_firstRecord)
            {
                checkFirstSalesId = tmpPurchLinePrice.SalesId;
            }
            else if (checkFirstSalesId != tmpPurchLinePrice.SalesId)
            {
                ok = checkFailed("@SYS54514");
            }
        }

        if (checkPrevSalesTable.SalesId != _tmpPurchLinePrice.SalesId)
        {
            checkPrevSalesTable  = SalesTable::find(_tmpPurchLinePrice.SalesId);
        }

        ProjId projId = checkPrevSalesTable.ProjId;

        if (_firstRecord)
        {
            checkFirstProjId = projId;
        }
        else
        {
            ok = this.validateProjIdForLine(projId) && ok;
        }

        if (!_tmpPurchLinePrice.AccountNum)
        {
            ok = checkFailed("@SYS29057");
        }
        else
        {
            if (!VendTable::exist(_tmpPurchLinePrice.AccountNum))
            {
                ok = checkFailed(strFmt("@SYS11817", _tmpPurchLinePrice.AccountNum));
            }
            else if (this.isVendorBlocked(_tmpPurchLinePrice.AccountNum))
            {
                ok = checkFailed(strFmt("@SYS1138", _tmpPurchLinePrice.AccountNum));
            }
        }

        if (WHSInventEnabled::exist(_tmpPurchLinePrice.ItemId) &&
            !WHSFilter::vendFilterMatch(_tmpPurchLinePrice.AccountNum, _tmpPurchLinePrice.ItemId))
        {
            ok = checkFailed("@WAX1003");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjIdForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the first line's project ID matches the the current line's project ID.
    /// </summary>
    /// <param name = "_projId">
    /// The project ID of the current line.
    /// </param>
    /// <returns>
    /// true if validation passed; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean validateProjIdForLine(ProjId _projId)
    {
        boolean ok = true;
        if (checkFirstProjId != _projId)
        {
            ok = checkFailed("@SYS70684");
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSelectedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates all selected order lines.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean checkSelectedLines()
    {
        boolean firstRecord = true;
        boolean ok = true;
        SalesId prevSalesId = '';
        Counter numberOfCheckedLines;

        setPrefix("@SYS70685");

        using (var activityContext = this.instrumentationLogger().purchCreateFromSalesOrder().checkSelectedLines())
        {
            while select tmpPurchLinePrice
                order by tmpPurchLinePrice.SalesId
                    where tmpPurchLinePrice.Included
            {
                setPrefix(#PreFixField(tmpPurchLinePrice, SalesId));

                if (!prevSalesId || prevSalesId != tmpPurchLinePrice.SalesId)
                {
                    firstRecord = true;
                }
                else
                {
                    firstRecord = false;
                }

                ok = this.checkLine(tmpPurchLinePrice, firstRecord) && ok;

                prevSalesId = tmpPurchLinePrice.SalesId;
                numberOfCheckedLines ++;
            }

            activityContext.addCustomProperty('NumberOfCheckedLines', int2Str(numberOfCheckedLines));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        Args parameters = new Args();
        parameters.name(formStr(purchCreateFromSalesOrder));
        parameters.caller(this);
        parameters.record(salesTable);

        return classfactory.formRunClass(parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyCreateTmpFromLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>tmpPurchLinePrice</c> record for creating an intercompany purchase order.
    /// </summary>
    /// <param name = "_salesLine">The <c>SalesLine</c> to create a <c>tmpPurchLinePrice</c> record for.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> the <c>SalesLine</c> belongs to.</param>
    /// <returns>true if the <c>tmpPurchLinePrice</c> record was created; otherwise, false.</returns>
    public boolean intercompanyCreateTmpFromLine(SalesLine _salesLine, SalesTable _salesTable)
    {
        if (SalesTableType::construct(_salesTable).canCreatePurchOrder()
            && this.validateSalesLine(_salesLine))
        {
            VendAccount vendAccount;

            if (!salesLine.SourcingVendAccount)
            {
                salesLine.SourcingVendAccount = _salesLine.inventTable().primaryVendorId(_salesLine.InventDimId);
            }

            this.insertIntoTmpPurchLinePrice(_salesLine, _salesTable);

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCreateTmpFrmVirtual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>tmpPurchLinePrice</c> records for creating an intercompany purchase order.
    /// </summary>
    /// <returns>
    /// true if <c>tmpPurchLinePrice</c> records were created; otherwise, false.
    /// </returns>
    public boolean interCompanyCreateTmpFrmVirtual()
    {
        SalesLine   salesLineLocal;
        boolean     ret = true;
        boolean     reservationExplosionFound = false;

        QueryRun queryRun = new QueryRun(this.querySalesLine(this.interCompanyQuerySalesLine()));

        while (ret && queryRun.next())
        {
            salesLineLocal = queryRun.get(tableNum(SalesLine));

            if (SalesTableType::construct(salesLineLocal.salesTable()).canCreatePurchOrder()
                    && salesLineLocal.defaultIntercompanyVendor().interCompanyTradingRelationActive())
            {
                ret = this.validateSalesLine(salesLineLocal);

                if (ret && salesLineLocal.Reservation == ItemReservation::Explosion)
                {
                    reservationExplosionFound = true;
                }
            }
        }

        if (ret)
        {
            queryRun.reset();
            while (queryRun.next())
            {
                salesLineLocal  = queryRun.get(tableNum(SalesLine));

                SalesTable salesTableLocal = salesLineLocal.salesTable();
                salesLineLocal.SourcingVendAccount = salesLineLocal.defaultIntercompanyVendorAccountNumber();

                boolean isStocked = salesLineLocal.isStocked();

                if (SalesTableType::construct(salesTableLocal).canCreatePurchOrder()
                        && VendTable::find(salesLineLocal.SourcingVendAccount).interCompanyTradingRelationActive()
                        && salesLineLocal.Reservation != ItemReservation::Explosion
                        && ((!isStocked && this.validateNonStockedItem(salesLineLocal, salesTableLocal)) || this.validateStockedItem(salesLineLocal, salesTableLocal))
                        && !salesLineLocal.interCompanyIsBeingUpdated(false)
                        &&  salesLineLocal.pickedInTotalSalesUnitServer() == 0
                        &&  salesLineLocal.deliveredInTotal()             == 0
                        &&  salesLineLocal.RemainSalesFinancial           == 0
                        &&  salesLineLocal.invoicedInTotal()              == 0)
                {
                    this.insertIntoTmpPurchLinePrice(salesLineLocal, salesTableLocal);
                }
            }

            tmpPurchLinePrice.setTmpData(tmpPurchLinePrice);

            ret = this.checkSelectedLines();
            ret = ret && PurchCreateFromSalesOrder::checkTransferred(tmpPurchLinePrice);

            if (reservationExplosionFound)
            {
                warning("@SYS105403");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoTmpPurchLinePrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the temporary <c>TmpPurchLinePrice</c> for the sales line.
    /// </summary>
    /// <param name = "_salesLine">The sales line.</param>
    /// <param name = "_salesTable">The sales order.</param>
    protected void insertIntoTmpPurchLinePrice(SalesLine _salesLine, SalesTable _salesTable)
    {
        InventTable inventTable             = _salesLine.inventTable();
        tmpPurchLinePrice.SalesId           = _salesLine.SalesId;
        tmpPurchLinePrice.LineNum           = _salesLine.LineNum;
        tmpPurchLinePrice.SalesLineRefRecId = _salesLine.RecId;
        tmpPurchLinePrice.AccountNum        = _salesLine.SourcingVendAccount;

        if (isPurchCreateFromSalesOrderInitCurrencyFlightEnabled)
        {
            tmpPurchLinePrice.CurrencyCode = VendTable::find(tmpPurchLinePrice.AccountNum).Currency;
        }

        tmpPurchLinePrice.Included          = NoYes::Yes;
        tmpPurchLinePrice.ItemId            = _salesLine.ItemId;
        tmpPurchLinePrice.InventDimId       = _salesLine.InventDimId;
        tmpPurchLinePrice.initFromInventTable(inventTable);

        if (_salesTable.SalesType == SalesType::ReturnItem)
        {
            tmpPurchLinePrice.PurchQty  = _salesLine.ExpectedRetQty;
            tmpPurchLinePrice.PdsCWQty  = _salesLine.PdsCWExpectedRetQty;
        }
        else
        {
            tmpPurchLinePrice.PurchQty  = _salesLine.RemainSalesPhysical;
            tmpPurchLinePrice.PdsCWQty  = _salesLine.PdsCWRemainInventPhysical;
        }

        if (this.tradeLineDlvType() == TradeLineDlvType::DropShip)
        {
            tmpPurchLinePrice.PurchUnit = _salesLine.SalesUnit;
        }
        else
        {
            tmpPurchLinePrice.PurchQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(tmpPurchLinePrice.ItemId,
                                                                                                                   tmpPurchLinePrice.InventDimId,
                                                                                                                   tmpPurchLinePrice.PurchQty,
                                                                                                                   _salesLine.SalesUnit,
                                                                                                                   tmpPurchLinePrice.PurchUnit,
                                                                                                                   NoYes::Yes);
        }

        tmpPurchLinePrice.PriceSearched = NoYes::No;

        tmpPurchLinePrice.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a sales line.
    /// </summary>
    /// <param name = "_salesLine">The sales line to validate.</param>
    /// <returns>true if valid; otherwise, false.</returns>
    protected boolean validateSalesLine(SalesLine _salesLine)
    {
        if (_salesLine.interCompanyIsBeingUpdated())
        {
            return false;
        }

        if (_salesLine.ShippingDateRequested < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
        {
            checkFailed(strFmt("@SYS94343",_salesLine.ItemId,_salesLine.ShippingDateRequested));
            error("@SYS96944");
            return false;
        }

        if ((_salesLine.QtyOrdered > 0 && _salesLine.type().canPickingListBeRegistrated())
            ||   _salesLine.pickedInTotalSalesUnitServer() != 0
            ||   _salesLine.deliveredInTotal()             != 0
            ||   _salesLine.RemainSalesFinancial           != 0
            ||   _salesLine.invoicedInTotal()              != 0)
        {
            checkFailed("@Intercompany:ErrorPickPackAlreadyStarted");
            error("@SYS96944");
            return false;
        }

        if (_salesLine.Reservation == ItemReservation::Explosion && _salesLine.isIntercompanyOrigin())
        {
            checkFailed("@Intercompany:ErrorICExplosionLine");
            error("@SYS96944");
            return false;
        }

        if (salesLine.Scrap)
        {
            checkFailed("@Intercompany:ErrorScrapLine");
            error("@SYS96944");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNonStockedItemDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the non-stocked item from the specified sales order line.
    /// </summary>
    /// <param name = "_this">A reference to the current instance of the <c>PurchCreateFromSalesOrder</c> class.</param>
    /// <param name = "_salesLine">A <c>SalesLine</c> record to validate.</param>
    /// <param name = "_salesTable">A <c>SalesTable</c> record used in validation.</param>
    /// <param name = "_validationResult">An instance of <c>EventHandlerRejectResult</c> that subscribers should use for returning a rejection in case the validation fails.</param>
    delegate void validateNonStockedItemDelegate(PurchCreateFromSalesOrder _this, SalesLine _salesLine, salesTable _salesTable, EventHandlerRejectResult _validationResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNonStockedItem</Name>
				<Source><![CDATA[
    private boolean validateNonStockedItem(SalesLine _salesLine, salesTable _salesTable)
    {
        if (_salesTable.SalesType == SalesType::ReturnItem)
        {
            return this.validateReturnItem(_salesLine);
        }

        var validationResult = EventHandlerRejectResult::newDefault();
        this.validateNonStockedItemDelegate(this, _salesLine, _salesTable, validationResult);
        if (validationResult.isRejected())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStockedItemDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the stocked item from the specified sales order line.
    /// </summary>
    /// <param name = "_this">A reference to the current instance of the <c>PurchCreateFromSalesOrder</c> class.</param>
    /// <param name = "_salesLine">A <c>SalesLine</c> record to validate.</param>
    /// <param name = "_salesTable">A <c>SalesTable</c> record used in validation.</param>
    /// <param name = "_validationResult">An instance of <c>EventHandlerRejectResult</c> that subscribers should use for returning a rejection in case the validation fails.</param>
    delegate void validateStockedItemDelegate(PurchCreateFromSalesOrder _this, SalesLine _salesLine, salesTable _salesTable, EventHandlerRejectResult _validationResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStockedItem</Name>
				<Source><![CDATA[
    private boolean validateStockedItem(SalesLine _salesLine, salesTable _salesTable)
    {
        if (_salesTable.SalesType == SalesType::ReturnItem)
        {
            return this.validateReturnItem(_salesLine);
        }

        var validationResult = EventHandlerRejectResult::newDefault();
        this.validateNonStockedItemDelegate(this, _salesLine, _salesTable, validationResult);
        if (validationResult.isRejected())
        {
            return false;
        }

        return _salesLine.QtyOrdered < 0 || (_salesLine.QtyOrdered > 0 && _salesLine.type().canPickingListBeUpdated(true) && !_salesLine.type().canPickingListBeRegistrated(true));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReturnItem</Name>
				<Source><![CDATA[
    private boolean validateReturnItem(SalesLine _salesLine)
    {
        return _salesLine.ExpectedRetQty < 0 && _salesLine.returnDispositionCode().createInterCompany();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyQuerySalesLine</Name>
				<Source><![CDATA[
    protected Query interCompanyQuerySalesLine()
    {
        Query query = new Query();
        query.addDataSource(tableNum(SalesLine));
        query.dataSourceTable(tableNum(SalesLine)).addRange (fieldNum(SalesLine,InventRefTransId)).value(SysQuery::valueEmptyString());
        query.dataSourceTable(tableNum(SalesLine)).findRange(fieldNum(SalesLine,InventRefTransId)).status(RangeStatus::Hidden);
        query.dataSourceTable(tableNum(SalesLine)).addRange (fieldNum(SalesLine,Scrap)           ).value(queryValue(NoYes::No));
        query.dataSourceTable(tableNum(SalesLine)).findRange(fieldNum(SalesLine,Scrap)           ).status(RangeStatus::Hidden);

        if (callerRecord.TableId == tableNum(SalesLine))
        {
            query.dataSourceTable(tableNum(SalesLine)).addRange (fieldNum(SalesLine,RecId)).value(queryValue(callerRecord.RecId));
            query.dataSourceTable(tableNum(SalesLine)).findRange(fieldNum(SalesLine,RecId)).status(RangeStatus::Hidden);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDropShipCreateTmpFrmVirtualKeepTmpPurchLinePrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads <c>TmpFrmVirtual</c> for drop ship sales lines that need corresponding
    /// drop ship purchase orders created.
    /// </summary>
    /// <remarks>
    /// The tmpFrmVirtual table will then be use to drive what PO's
    /// are created in the run method.
    /// The <c>SalesTable</c> record should be set before calling this.
    /// </remarks>
    /// <returns>
    /// true if the validation of the lines created in <c>tmpPurchLinePrice</c> is successful; otherwise, false.
    /// </returns>
    public boolean mcrDropShipCreateTmpFrmVirtualKeepTmpPurchLinePrice()
    {
        InventTable                 inventTable;
        SalesLine                   salesLineLocal;
        MCRSalesLineDropShipment    mcrSalesLineDropShipment;
        Counter numberOfProcessedLines;

        using (var activityContext = this.instrumentationLogger().purchCreateFromSalesOrder().mcrDropShipCreateTmpFrmVirtualKeepTmpPurchLinePrice(salesTable))
        {
            while select SalesId, LineNum, ItemId, SalesQty, SalesUnit, QtyOrdered, RecId, InventDimId from salesLineLocal
                where  salesLineLocal.SalesId           == salesTable.SalesId
                    && salesLineLocal.LineDeliveryType  != LineDeliveryType::OrderLineWithMultipleDeliveries
                    && salesLineLocal.SalesStatus       == SalesStatus::Backorder
                    && salesLineLocal.SalesQty          > 0
                join SalesLine, DropShipment, DropShipStatus from mcrSalesLineDropShipment
                    where mcrSalesLineDropShipment.SalesLine == salesLineLocal.RecId
                        && mcrSalesLineDropShipment.DropShipment
                        && mcrSalesLineDropShipment.DropShipStatus == MCRDropShipStatus::ToBeDropShipped
                join PrimaryVendorId, ItemId from inventTable
                    where inventTable.ItemId            == salesLineLocal.ItemId
            {
                if (salesLineRecIdSet && !salesLineRecIdSet.in(salesLineLocal.RecId))
                {
                    continue;
                }

                this.setPrimaryVendorId(inventTable);

                if (!inventTable.PrimaryVendorId)
                {
                    info(strFmt("@MCR37225", salesLineLocal.ItemId));
                    continue; //skip to next record in while loop - do not insert
                }

                tmpPurchLinePrice.SalesId       = salesLineLocal.SalesId;
                tmpPurchLinePrice.LineNum       = salesLineLocal.LineNum;
                tmpPurchLinePrice.Included      = NoYes::Yes;
                tmpPurchLinePrice.AccountNum    = inventTable.PrimaryVendorId(salesLineLocal.InventDimId);

                if (isPurchCreateFromSalesOrderInitCurrencyFlightEnabled)
                {
                    tmpPurchLinePrice.CurrencyCode = VendTable::find(tmpPurchLinePrice.AccountNum).Currency;
                }

                tmpPurchLinePrice.InventDimId = salesLineLocal.InventDimId;
                tmpPurchLinePrice.ItemId      = salesLineLocal.ItemId;
                tmpPurchLinePrice.initFromInventTable(inventTable);
                // The qtyOrdered field is in the Inventory Unit of measure.
                // The PurchQty field is in the purchase unit of measure.
                tmpPurchLinePrice.PdsCWQty = salesLineLocal.PdsCWQty;

                tmpPurchLinePrice.PurchQty      = salesLineLocal.SalesQty;
                tmpPurchLinePrice.PurchUnit     = salesLineLocal.SalesUnit;

                tmpPurchLinePrice.SalesLineRefRecId = salesLineLocal.RecId;

                tmpPurchLinePrice.insert();
                numberOfProcessedLines ++;
            }

            activityContext.addCustomProperty('NumberOfProcessedLines', int2Str(numberOfProcessedLines));
        }

        return this.checkSelectedLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDropShipCreateTmpFrmVirtual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads <c>TmpFrmVirtual</c> for drop ship sales lines that need corresponding
    /// drop ship purchase orders created.
    /// </summary>
    /// <remarks>
    /// The tmpFrmVirtual table will then be use to drive what PO's
    /// are created in the run method.
    /// The <c>SalesTable</c> record should be set before calling this.
    /// </remarks>
    /// <returns>
    /// true if the validation of the lines created in <c>tmpPurchLinePrice</c> is successful; otherwise, false.
    /// </returns>
    public boolean mcrDropShipCreateTmpFrmVirtual()
    {
        tmpPurchLinePrice = null;
        
        return this.mcrDropShipCreateTmpFrmVirtualKeepTmpPurchLinePrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPrimaryVendorId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the primary vendor ID value.
    /// </summary>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> record.
    /// </param>
    /// <remarks>
    /// This method is an extension point to control the setting of the PrimaryVendorId field.
    /// </remarks>
    protected void setPrimaryVendorId(InventTable _inventTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDropShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and gets whether the purchase order being created is a drop shipment.
    /// </summary>
    /// <param name="_dropShipment">
    /// The value indicating whether the purchase order being created is a drop shipment.
    /// </param>
    /// <returns>
    /// true if the purchase order being created is a drop shipment; otherwise, false.
    /// </returns>
    public boolean mcrDropShipment(boolean    _dropShipment = dropShipment)
    {
        dropShipment = _dropShipment;
        return dropShipment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        List list = new List(Types::Record);

        while select tmpPurchLinePrice
        {
            list.addEnd(tmpPurchLinePrice.data());
        }
        packedTable = list.pack();

        return [CurrentVersion,#CurrentList,#CurrentListCS];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerRecord</Name>
				<Source><![CDATA[
    public Common parmCallerRecord(Common _callerRecord = callerRecord)
    {
        callerRecord = _callerRecord;
        return callerRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExecuteQuery</Name>
				<Source><![CDATA[
    public boolean parmExecuteQuery(boolean _executeQuery = executeQuery)
    {
        executeQuery = _executeQuery;
        return executeQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInitFields</Name>
				<Source><![CDATA[
    public boolean parmInitFields(boolean _initFields = initFields)
    {
        initFields = _initFields;
        return initFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInsertMinMaxQty</Name>
				<Source><![CDATA[
    public boolean parmInsertMinMaxQty(boolean _insertMinMaxQty = insertMinMaxQty)
    {
        insertMinMaxQty = _insertMinMaxQty;

        return insertMinMaxQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPOTransDate</Name>
				<Source><![CDATA[
    public TransDate parmPOTransDate(TransDate _poTransDate = poTransDate)
    {
        poTransDate = _poTransDate;

        return poTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLine</Name>
				<Source><![CDATA[
    public SalesLine parmSalesLine(SalesLine _salesLine = salesLine)
    {
        salesLine = _salesLine;
        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLineRecIdSet</Name>
				<Source><![CDATA[
    public Set parmSalesLineRecIdSet(Set _salesLineRecIdSet = salesLineRecIdSet)
    {
        salesLineRecIdSet = _salesLineRecIdSet;
        return salesLineRecIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTable</Name>
				<Source><![CDATA[
    public SalesTable parmSalesTable(SalesTable _salesTable = salesTable)
    {
        salesTable = _salesTable;
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSearchForAgreements</Name>
				<Source><![CDATA[
    public boolean parmSearchForAgreements(boolean    _searchForAgreements = searchForAgreements)
    {
        searchForAgreements = _searchForAgreements;
        return searchForAgreements;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpPurchLinePrice</Name>
				<Source><![CDATA[
    public TmpPurchLinePrice parmTmpPurchLinePrice(TmpPurchLinePrice _tmpPurchLinePrice = tmpPurchLinePrice)
    {
        tmpPurchLinePrice = _tmpPurchLinePrice;
        return tmpPurchLinePrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferAddress</Name>
				<Source><![CDATA[
    public boolean parmTransferAddress(boolean    _transferAddress = transferAddress)
    {
        transferAddress = _transferAddress;
        return transferAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecalculateDlvDates</Name>
				<Source><![CDATA[
    public boolean parmRecalculateDlvDates(boolean _recalculateDlvDates = recalculateDlvDates)
    {
        recalculateDlvDates = _recalculateDlvDates;
        return recalculateDlvDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferDeliveryAddressFromAgreement</Name>
				<Source><![CDATA[
    public boolean parmTransferDeliveryAddressFromAgreement(boolean    _transferDeliveryAddressFromAgreement = transferDeliveryAddressFromAgreement)
    {
        transferDeliveryAddressFromAgreement = _transferDeliveryAddressFromAgreement;
        return transferDeliveryAddressFromAgreement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preMatchIncludedLinesWithAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Attempts to match agreement lines with the purchase order lines
    /// Updates the information on <c>TmpPurchLinePrice</c> records accordingly.
    /// </summary>
    protected void preMatchIncludedLinesWithAgreements()
    {
        // Avoid perf.expensive operations if no match is requested
        if (!this.parmSearchForAgreements())
        {
            return;
        }

        while select forupdate tmpPurchLinePrice where tmpPurchLinePrice.Included
        {
            PurchLine currentPurchLine = this.purchLineToSearchForAgreementToMatch();
            
            InterCompanyEndpointActionPolicy interCompanyEndpointActionPolicy = VendTable::find(currentPurchLine.VendAccount).interCompanyTradingPartner().interCompanyEndpointActionPolicy();
            if (!interCompanyEndpointActionPolicy.getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal).PriceDiscount)
            {
                // Try to find AgreementLine to match...
                AgreementLine matchingAgreementLine = AgreementLine::findLineForAutoMatch(currentPurchLine, 0, true);
                if (matchingAgreementLine)
                {
                    // Update tmpPurchLinePrice line with matching information.
                    tmpPurchLinePrice.MatchingAgreement = matchingAgreementLine.Agreement;
                    tmpPurchLinePrice.MatchingAgreementLine = matchingAgreementLine.RecId;
                    tmpPurchLinePrice.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLineToSearchForAgreementToMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>PurchLine</c> record to search for matching agreement.
    /// </summary>
    /// <returns>
    /// A <c>PurchLine</c> record.
    /// </returns>
    protected PurchLine purchLineToSearchForAgreementToMatch()
    {
        SalesLine currentSalesLine = SalesLine::findRecId(tmpPurchLinePrice.SalesLineRefRecId);
        InventTable currentInventTable = currentSalesLine.inventTable();

        PurchLine currentPurchLine;
        currentPurchLine.clear();
        currentPurchLine.ItemId = tmpPurchLinePrice.ItemId;
        currentPurchLine.initFromInventTable(currentInventTable);
        currentPurchLine.initFromSalesLine(currentSalesLine);
        currentPurchLine.PurchUnit = tmpPurchLinePrice.PurchUnit;
        currentPurchLine.PurchQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(currentSalesLine.ItemId,
                                                                                                              currentSalesLine.InventDimId,
                                                                                                              currentSalesLine.RemainSalesPhysical,
                                                                                                              currentSalesLine.SalesUnit,
                                                                                                              currentPurchLine.PurchUnit,
                                                                                                              NoYes::Yes);

        InventDim currentInventDim = currentPurchLine.inventDim();
        if (currentInventTable.purchInventSiteId(currentInventDim.InventSiteId, currentInventDim.inventDimId) != currentInventDim.InventSiteId)
        {
            currentInventDim.InventSiteId = currentInventTable.purchInventSiteId(currentInventDim.InventSiteId, currentInventDim.inventDimId);
            currentPurchLine.setInventDimIdFromInventDim(currentInventDim);
        }
        currentInventDim = currentPurchLine.inventDim();

        if (currentInventTable.purchInventLocationId( currentInventDim.InventLocationId,
                                                          currentInventDim.InventDimId,
                                                          currentInventDim.InventSiteId
                                                        ) != currentInventDim.InventLocationId )
        {
            currentInventDim.InventLocationId = currentInventTable.purchInventLocationId(
                                                                            currentInventDim.InventLocationId,
                                                                            currentInventDim.InventDimId,
                                                                            currentInventDim.InventSiteId);
            currentInventDim.initFromInventLocation(currentInventDim.inventLocation());
            currentPurchLine.setInventDimIdFromInventDim(currentInventDim);
        }

        if (tmpPurchLinePrice.PriceSearched)
        {
            currentPurchLine.initFromTmpPurchLinePrice(tmpPurchLinePrice);
        }
        else
        {
            currentPurchLine.setPriceDisc(currentInventDim);
        }

        currentPurchLine.VendAccount  = tmpPurchLinePrice.AccountNum;
        currentPurchLine.CurrencyCode = tmpPurchLinePrice.CurrencyCode;
        currentPurchLine.DeliveryDate = currentSalesLine.ShippingDateRequested;

        return currentPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>querySalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extends a sales lines default query to include additional tables and ranges, such as excluding
    /// sales lines that are related to event kanbans through pegging.
    /// </summary>
    /// <param name="_querySalesLine">
    /// The default sales line query to extend.
    /// </param>
    /// <param name="_probePeggingExclusions">
    /// A Boolean value that specifies whether the sales line set includes sales lines related to event
    /// kanbans.
    /// </param>
    /// <returns>
    /// The updated query with the additional tables and ranges that are required.
    /// </returns>
    public Query querySalesLine(Query _querySalesLine, boolean _probePeggingExclusions = false)
    {
        QueryBuildRange remainQty;

        Query querySalesLine = _querySalesLine;
        QueryBuildDataSource qbdsSalesLine  = querySalesLine.dataSourceTable(tableNum(SalesLine));
        qbdsSalesLine.clearDynalinks();

        if (salesTable &&  salesTable.SalesType == SalesType::ReturnItem)
        {
            remainQty = qbdsSalesLine.addRange(fieldNum(SalesLine, ExpectedRetQty));

            if (salesTable.InterCompanyAutoCreateOrders || salesTable.InterCompanyDirectDelivery)
            {
                remainQty.value('!0');
            }
            else
            {
                QueryBuildDataSource qbsReturnDispositionCode = qbdsSalesLine.addDataSource(tableNum(ReturnDispositionCode));
                qbsReturnDispositionCode.joinMode(JoinMode::ExistsJoin);
                qbsReturnDispositionCode.relations(true);

                QueryBuildRange returnDispositionAction   = qbsReturnDispositionCode.addRange(fieldNum(ReturnDispositionCode, DispositionAction));
                returnDispositionAction.value(strFmt('%1, %2', enum2str(DispositionAction::Credit), enum2str(DispositionAction::ReplaceCredit)));

                remainQty.value('<0');
            }
        }
        else
        {
            QueryBuildRange salesStatus = qbdsSalesLine.addRange(fieldNum(SalesLine, SalesStatus));
            salesStatus.value(queryValue(SalesStatus::Backorder));
            salesStatus.status(RangeStatus::Hidden);

            remainQty   = qbdsSalesLine.addRange(fieldNum(SalesLine, RemainSalesPhysical));
        }

        // Added condition to be able to use datasource functionality when
        // our MCRDropShip flag was set, otherwise, the sales line would not
        // be visible.
        if (this.tradeLineDlvType() != TradeLineDlvType::DropShip)
        {
            // Added DropShip Query range
            QueryBuildDataSource qbdsSalesLineDropShipment = qbdsSalesLine.addDataSource(tableNum(MCRSalesLineDropShipment));
            qbdsSalesLineDropShipment.addLink(fieldNum(SalesLine,RecId),fieldNum(MCRSalesLineDropShipment,SalesLine));
            qbdsSalesLineDropShipment.relations(true);
            qbdsSalesLineDropShipment.joinMode(JoinMode::NoExistsJoin);
            qbdsSalesLineDropShipment.addRange(fieldNum(MCRSalesLineDropShipment, DropShipment)).value(enum2str(NoYes::Yes));
        }

        remainQty.value('!0');

        this.addSalesIdRange(qbdsSalesLine);

        if (salesLine)
        {
            this.addInventTransIdRange(qbdsSalesLine);
        }

        qbdsSalesLine.addRange(fieldNum(SalesLine, ItemId));

        QueryBuildDataSource qbdsInventTable = querySalesLine.dataSourceTable(tableNum(InventTable));
        if (!qbdsInventTable)
        {
            qbdsInventTable = qbdsSalesLine.addDataSource(tableNum(InventTable));
            qbdsInventTable.joinMode(JoinMode::ExistsJoin);
            qbdsInventTable.relations(true);
        }

        // Exclude sales line tied to sales event kanbans. The implementation can be kept optimized
        // as it is as long as ReqPeggingAssignment is only used for event kanban rules.
        QueryBuildDataSource qbdsReqPeggingAssignment = querySalesLine.dataSourceTable(tableNum(ReqPeggingAssignment));
        if (!qbdsReqPeggingAssignment)
        {
            qbdsReqPeggingAssignment = qbdsSalesLine.addDataSource(tableNum(ReqPeggingAssignment));
            qbdsReqPeggingAssignment.addLink(fieldNum(SalesLine, SourceDocumentLine), fieldNum(ReqPeggingAssignment, SourceDocumentLine));
            qbdsReqPeggingAssignment.addRange(fieldNum(ReqPeggingAssignment, ReqPeggingAssignmentType)).value(queryValue(ReqPeggingAssignmentType::Requirement));
        }
        // We may want to know whether records would be skipped due to event kanbans or otherwise exclude them
        qbdsReqPeggingAssignment.joinMode(_probePeggingExclusions? JoinMode::ExistsJoin : JoinMode::NoExistsJoin);

        return querySalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesIdRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds sales ID range criteria.
    /// </summary>
    /// <param name = "_qbdsSalesLine">
    /// The <c>QueryBuildDataSource</c> instance for sales line.
    /// </param>
    /// <returns>
    /// The <c>QueryBuildRange</c> instance.
    /// </returns>
    protected QueryBuildRange addSalesIdRange(QueryBuildDataSource _qbdsSalesLine)
    {
        QueryBuildRange salesId = _qbdsSalesLine.addRange(fieldNum(SalesLine, SalesId));
    
        salesId.value(salesTable ? queryValue(salesTable.SalesId) : '');

        return salesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransIdRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds inventory transaction ID range criteria.
    /// </summary>
    /// <param name = "_qbdsSalesLine">
    /// The <c>QueryBuildDataSource</c> instance for sales line.
    /// </param>
    protected void addInventTransIdRange(QueryBuildDataSource _qbdsSalesLine)
    {
        container inventTransIdFilter = this.retrieveInventTransIdFilterCriterias();
        int conIdx;
        for (conIdx = 1; conIdx <= conLen(inventTransIdFilter); conIdx++)
        {
            _qbdsSalesLine.addRange(fieldNum(SalesLine, InventTransId)).value(queryValue(conPeek(inventTransIdFilter, conIdx)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveInventTransIdFilterCriterias</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory transaction IDs used in filter criterias.
    /// </summary>
    /// <returns>
    /// A container with the inventory transaction IDs.
    /// </returns>
    protected container retrieveInventTransIdFilterCriterias()
    {
        container ret;
        if (FormDataUtil::isFormDataSource(salesLine))
        {
            FormDataSource salesLine_ds = FormDataUtil::getFormDataSource(salesLine);
            SalesLine localSalesLine;

            for (localSalesLine = salesLine_ds.getFirst(true) ? salesLine_ds.getFirst(true) : FormDataUtil::getFormDataSource(salesLine).cursor(); localSalesLine; localSalesLine = salesLine_ds.getNext())
            {
                ret += localSalesLine.InventTransId;
            }
        }
        else
        {
            ret += salesLine.InventTransId;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCurrentListCS</Name>
				<Source><![CDATA[
    public void resetCurrentListCS()
    {
        callerRecord        = null;
        salesTable          = null;
        salesLine           = null;
        transferAddress     = false;
        recalculateDlvDates = false;
        executeQuery        = false;
        packedTable         = conNull();
        tmpPurchLinePrice   = null;
        poTransDate         = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(), DateTimeUtil::getUserPreferredTimeZone()));
        dropShipment        = false;
        tradeLineDlvType    = tradeLineDlvType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPurchaseOrderLinesToCreateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for purchase lines to be created.
    /// </summary>
    /// <returns>A query object.</returns>
    private Query buildPurchaseOrderLinesToCreateQuery()
    {
        Query query = new Query();
        
        QueryBuildDataSource tmpPurchLinePriceDataSource = query.addDataSource(tableNum(TmpPurchLinePrice));
        this.addSortingForPurchaseOrderLinesToCreate(tmpPurchLinePriceDataSource);
        tmpPurchLinePriceDataSource.addRange(fieldNum(TmpPurchLinePrice, Included)).value(queryValue(NoYes::Yes));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSortingForPurchaseOrderLinesToCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds sorting on the <c>TmpPurchLinePrice</c> datasource in the purchase lines query.
    /// </summary>
    /// <param name = "_tmpPurchLinePriceDataSource">A <c>QueryBuildDataSource</c> object for the <c>TmpPurchLinePrice</c>.</param>
    protected void addSortingForPurchaseOrderLinesToCreate(QueryBuildDataSource _tmpPurchLinePriceDataSource)
    {
        _tmpPurchLinePriceDataSource.addOrderByField(fieldNum(TmpPurchLinePrice, AccountNum));
        _tmpPurchLinePriceDataSource.addOrderByField(fieldNum(TmpPurchLinePrice, MatchingAgreement));
        _tmpPurchLinePriceDataSource.addOrderByField(fieldNum(TmpPurchLinePrice, SalesId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates purchase orders.
    /// </summary>
    protected void createPurchaseOrders()
    {
        TmpPurchLinePrice                   collectedTmpPurchLinePrices;
        VendAccount                         prevVendAccount;
        RefRecId                            prevMatchingAgreement;
        CustDlvModeId                       prevCustDlvModeId;
        LogisticsPostalAddress              prevLogisticsPostalAddress;

        Query query = this.buildPurchaseOrderLinesToCreateQuery();

        QueryRun queryRun = new QueryRun(query);
        queryRun.setCursor(tmpPurchLinePrice);

        while (queryRun.next())
        {
            // Deal with multiple shipping addresses for drop ship as well (different PO)
            SalesLine salesLineLocal = SalesLine::findRecId(tmpPurchLinePrice.SalesLineRefRecId);
            SalesTable salesTableLocal = salesLineLocal.salesTable();
            if (this.shouldCreatePurchOrder(prevVendAccount, prevMatchingAgreement, prevCustDlvModeId, prevLogisticsPostalAddress, salesLineLocal))
            {
                this.parmSalesTable(SalesTable::find(collectedTmpPurchLinePrices.SalesId));
                this.autoCreatePurchOrder(collectedTmpPurchLinePrices);

                delete_from collectedTmpPurchLinePrices;
            }
                
            this.validatePurchOrderCreationForInterCompany(salesTableLocal, salesLineLocal);

            // Create a new purchase order for each delivery mode
            prevCustDlvModeId = salesLineLocal.DlvMode;

            this.collectTmpPurchLinePrice(collectedTmpPurchLinePrices, salesTableLocal, salesLineLocal);

            prevVendAccount = collectedTmpPurchLinePrices.AccountNum;
            prevLogisticsPostalAddress = SalesLine::findRecId(collectedTmpPurchLinePrices.SalesLineRefRecId).deliveryAddress();
            prevMatchingAgreement = collectedTmpPurchLinePrices.MatchingAgreement;
        }

        if (prevVendAccount)
        {
            this.parmSalesTable(SalesTable::find(collectedTmpPurchLinePrices.SalesId));
            this.autoCreatePurchOrder(collectedTmpPurchLinePrices);
        }

        this.updateRelatedSalesLineRecords();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        // Execute pre-matching of selected lines with agreements...
        this.preMatchIncludedLinesWithAgreements();

        try
        {
            ttsbegin;

            this.createPurchaseOrders();

            ttscommit;
        }
        catch (Exception::Error)
        {
            throw error("@SYS96944");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreatePurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a purchase order should be created or not, based on the passed arguments.
    /// </summary>
    /// <param name = "_prevVendAccount">
    /// The previous <c>VendAccount</c> value.
    /// </param>
    /// <param name = "_prevMatchingAgreement">
    /// The previous matching agreement value.
    /// </param>
    /// <param name = "_prevCustDlvModeId">
    /// The previous <c>CustDlvModeId</c> value.
    /// </param>
    /// <param name = "_prevLogisticsPostalAddress">
    /// The previous <c>LogisticsPostalAddress</c> value.
    /// </param>
    /// <param name = "_salesLine">
    /// The <c>SalesLine</c> record referenced by the <c>TmpPurchLinePrice</c> record.
    /// </param>
    /// <returns>
    /// true if purchase order should be created; otherwise, false.
    /// </returns>
    protected boolean shouldCreatePurchOrder(VendAccount _prevVendAccount,
                                             RefRecId _prevMatchingAgreement,
                                             CustDlvModeId _prevCustDlvModeId,
                                             LogisticsPostalAddress _prevLogisticsPostalAddress,
                                             SalesLine _salesLine)
    {
        return (_prevVendAccount && _prevVendAccount != tmpPurchLinePrice.AccountNum
                || (_prevVendAccount && _prevMatchingAgreement != tmpPurchLinePrice.MatchingAgreement))
                || (_prevCustDlvModeId
                    && _prevCustDlvModeId != _salesLine.DlvMode
                    && this.mcrDropShipment())
                // Create a new purchase order for each delivery address
                || (_prevLogisticsPostalAddress
                    && _prevLogisticsPostalAddress.RecId != _salesLine.deliveryAddress().RecId
                    && this.mcrDropShipment());
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectTmpPurchLinePrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes and inserts <c>TmpPurchLinePrice</c> record.
    /// </summary>
    /// <param name = "_collectedTmpPurchLinePrices">
    /// The <c>TmpPurchLinePrice</c> record to be inserted.
    /// </param>
    /// <param name = "_salesTable">
    /// A <c>SalesTable</c> record.
    /// </param>
    /// <param name = "_salesLine">
    /// A <c>SalesLine</c> record.
    /// </param>
    protected void collectTmpPurchLinePrice(TmpPurchLinePrice _collectedTmpPurchLinePrices, SalesTable _salesTable, SalesLine _salesLine)
    {
        _collectedTmpPurchLinePrices.clear();
        buf2Buf(tmpPurchLinePrice, _collectedTmpPurchLinePrices);

        if (_salesTable.SalesType == SalesType::ReturnItem && !_salesLine.isAlreadyRegistedAndNotCancelledReturn())
        {
            this.adjustSalesLineQuantities(_salesLine.InventTransId);
            _salesTable.reread();
            _salesLine.reread();
            if (_salesLine.isStocked() && _collectedTmpPurchLinePrices.PurchUnit != _salesLine.SalesUnit)
            {
                _collectedTmpPurchLinePrices.PurchQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_collectedTmpPurchLinePrices.ItemId,
                                                                                                                           _collectedTmpPurchLinePrices.InventDimId,
                                                                                                                           _salesLine.getPurchQty(),
                                                                                                                           _salesLine.SalesUnit,
                                                                                                                           _collectedTmpPurchLinePrices.PurchUnit,
                                                                                                                           NoYes::Yes);
            }
            else
            {
                _collectedTmpPurchLinePrices.PurchQty = _salesLine.RemainSalesPhysical;
            }

            _collectedTmpPurchLinePrices.QtyOrdered = _salesLine.RemainInventPhysical;
        }
        
        _collectedTmpPurchLinePrices.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustSalesLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts sales line quantities.
    /// </summary>
    /// <param name = "_inventTransId">An inventory transaction Id for the sales line to adjust.</param>
    protected void adjustSalesLineQuantities(TradeInventTransId _inventTransId)
    {
        #OCCRetryCount
        try
        {
            ttsbegin;
            SalesLine salesLineToAdjust = SalesLine::findInventTransId(_inventTransId, true);
            salesLineToAdjust.SalesQty               = salesLineToAdjust.ExpectedRetQty;
            salesLineToAdjust.QtyOrdered             = salesLineToAdjust.calcQtyOrdered(salesLine.ExpectedRetQty);
            salesLineToAdjust.RemainInventPhysical   = salesLineToAdjust.QtyOrdered;
            salesLineToAdjust.RemainSalesPhysical    = salesLineToAdjust.SalesQty;
            salesLineToAdjust.LineAmount             = salesLineToAdjust.returnLineAmount();

            salesLineToAdjust.PdsCWQty                  = salesLineToAdjust.PdsCWExpectedRetQty;
            salesLineToAdjust.PdsCWRemainInventPhysical = salesLineToAdjust.PdsCWQty;

            this.updateSalesLine(salesLineToAdjust);

            if (salesLineToAdjust.SalesType != SalesType::ReturnItem)
            {
                SalesTable salesTableToAdjust = salesLineToAdjust.salesTable(true);
                salesTableToAdjust.SalesType = SalesType::ReturnItem;
                salesTableToAdjust.update();
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the sales line.
    /// </summary>
    /// <param name = "_salesLine">A sales line to update.</param>
    protected void updateSalesLine(SalesLine _salesLine)
    {
        if (this.isIntercompanySalesOrder(_salesLine))
        {
            this.updateSalesLineForIntercompany(_salesLine);
        }
        else
        {
            _salesLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineForIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the sales line for intercompany.
    /// </summary>
    /// <param name = "_salesLine">A sales line to update.</param>
    /// <remarks>
    /// Separate sales line update for intercompany is needed to enable intercompany return on direct delivery to work
    /// while ensuring inventory transactions are still correctly created.
    /// </remarks>
    private void updateSalesLineForIntercompany(SalesLine _salesLine)
    {
        InventUpd_Estimated	estimated;

        // For category based lines we do not have an item and inventory transaction may never be created.
        // For non-inventoried items InventUpd should still be invoked since it deletes transactions when QtyOrdered is set to 0.
        if (_salesLine.isStocked())
        {
            estimated = _salesLine.type().instantiateInventUpd_Estimated(null, InventMovSubType::None);
            if (estimated)
            {
                estimated.updateNow();
            }
        }
        
        _salesLine.doUpdate();

        if (estimated)
        {
            estimated.updateReservation();
        }
        
        if (isConfigurationkeyEnabled(configurationKeyNum(TradeBroker)))
        {
            //Reread the record before the next line.
            _salesLine.reread();

            new MCRBrokerOrder().calcBrokerage(_salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompanySalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a sales line belongs to the intercompany sales order.
    /// </summary>
    /// <param name = "_salesLine">A sales line to update.</param>
    /// <returns>true if a sales order is intercompany; otherwise, false.</returns>
    protected boolean isIntercompanySalesOrder(SalesLine _salesLine)
    {
        return _salesLine.SkipUpdate == InterCompanySkipUpdate::No
               && (_salesLine.SourcingOrigin == SalesSourcingOrigin::ExternalVendor || _salesLine.SourcingOrigin == SalesSourcingOrigin::Intercompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoCreatePurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the purchase order.
    /// </summary>
    /// <param name = "_tmpPurchLinePrice">The <c>TmpPurchLinePrice</c> record used to create the <c>PurchAutoCreate</c> instance.</param>
    protected void autoCreatePurchOrder(TmpPurchLinePrice _tmpPurchLinePrice)
    {
        PurchAutoCreate purchAutoCreate = this.instantiatePurchAutoCreate(_tmpPurchLinePrice);
        purchAutoCreate.create();
        if (this.mcrDropShipment())
        {
            // Create drop ship PO order event entry
            MCROrderEventTable mcrOrderEventTable;
            mcrOrderEventTable.insertFromDropShipment(salesTable.SalesId,
                                                    purchAutoCreate.purchId(),
                                                    MCROrderEventType::CreateDropShipPO);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiatePurchAutoCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a <c>PurchAutoCreate</c> object based on the given parameters.
    /// </summary>
    /// <param name = "_tmpPurchLinePrice">
    /// The purchase line price.
    /// </param>
    /// <returns>
    /// A <c>PurchAutoCreate</c> instance.
    /// </returns>
    protected PurchAutoCreate instantiatePurchAutoCreate(TmpPurchLinePrice _tmpPurchLinePrice)
    {
        return PurchAutoCreate::construct(_tmpPurchLinePrice, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePurchOrderCreationForInterCompany</Name>
				<Source><![CDATA[
    private void validatePurchOrderCreationForInterCompany(SalesTable _salesTable, SalesLine _salesLine)
    {
        if (_salesLine)
        {
            if (_salesTable.InterCompanyDirectDelivery
                    &&  SalesTableType::construct(_salesTable).canCreatePurchOrder()
                    &&  VendTable::find(tmpPurchLinePrice.AccountNum).interCompanyTradingRelationActive())
            {
                InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(_salesLine.ItemId);
                InventDimGroupFieldSetup inventDimGroupFieldSetup = inventDimGroupSetup.getFieldSetup(fieldNum(InventDim, wmsLocationId));
                if (this.isWarehouseManagementEnabled(inventDimGroupFieldSetup, _salesLine))
                {
                    warning(strFmt("@SCM:PurchDirectDeliveryLocationWarning", _salesLine.ItemId));
                }                
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWarehouseManagementEnabled</Name>
				<Source><![CDATA[
    private boolean isWarehouseManagementEnabled(InventDimGroupFieldSetup _inventDimGroupFieldSetup, SalesLine _salesLine)
    {
        return _inventDimGroupFieldSetup.isActive()
                    && (!_inventDimGroupFieldSetup.isAllowBlankIssueEnabled() || !_inventDimGroupFieldSetup.isAllowBlankReceiptEnabled())
                    && _salesLine.inventdim().inventLocation().WHSEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedSalesLineRecords</Name>
				<Source><![CDATA[
    private void updateRelatedSalesLineRecords()
    {
        SalesLine relatedSalesLine;
        while select SalesLineRefRecId from tmpPurchLinePrice
                where tmpPurchLinePrice.Included
        {
            relatedSalesLine = SalesLine::findRecId(tmpPurchLinePrice.SalesLineRefRecId, true);
            if (relatedSalesLine.DeliveryType == TradeLineDlvType::DropShip)
            {
                relatedSalesLine.SalesDeliverNow = 0;
                relatedSalesLine.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tradeLineDlvType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the delivery type that is used in the class.
    /// </summary>
    /// <param name="_tradeLineDlvType">
    ///  Delivery Type
    /// </param>
    /// <returns>
    /// Always returns a <c>TradeLineDlvType::None</c> enumeration value.
    /// </returns>
    public TradeLineDlvType tradeLineDlvType(TradeLineDlvType _tradeLineDlvType = tradeLineDlvType)
    {
        tradeLineDlvType = _tradeLineDlvType;
        return tradeLineDlvType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean  ret;
        Integer  version    = conPeek(packedClass,1);
        ListEnumerator le;
        Common    common;

        switch (version)
        {
            case CurrentVersion:
                [version,#CurrentList,#CurrentListCS] = packedClass;

                tmpPurchLinePrice = null;
                le = List::create(packedTable).getEnumerator();
                while (le.moveNext())
                {
                    common = le.current();
                    tmpPurchLinePrice.data(common.data());
                    tmpPurchLinePrice.insert();
                }
                ret = true;
                break;
            case 5:
                [version,#CurrentList,#CurrentListV5] = packedClass;

                tmpPurchLinePrice = null;
                le = List::create(packedTable).getEnumerator();
                while (le.moveNext())
                {
                    common = le.current();
                    tmpPurchLinePrice.data(common.data());
                    tmpPurchLinePrice.insert();
                }
                ret = true;
                break;
            case 4:
                [version,#CurrentList,#CurrentListV4] = packedClass;

                tmpPurchLinePrice = null;
                le = List::create(packedTable).getEnumerator();
                while (le.moveNext())
                {
                    common = le.current();
                    tmpPurchLinePrice.data(common.data());
                    tmpPurchLinePrice.insert();
                }
                ret = true;
                break;

            default:
                ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPOTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the date with the fiscal calendar.
    /// </summary>
    /// <param name="_poTransdate">
    ///    The date to validate with the fiscal calendar.
    /// </param>
    /// <returns>
    ///    true if the date is valid; otherwise, false.
    /// </returns>
    public static boolean checkPOTransDate(TransDate _poTransdate)
    {
        boolean ok = true;

        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdv2BudgetCtrl)))
        {
            if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(CompanyInfoHelper::fiscalCalendarRecId(),_poTransdate ,SysModule::Purch,false))
            {
                ok = checkFailed("@SYS127946");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransferred</Name>
				<Source><![CDATA[
    public static boolean checkTransferred(TmpPurchLinePrice tmpPurchLinePrice)
    {
        SalesLine   salesLine;
        boolean isKittingEnabled = FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance());
        boolean kittingRet = true;

        while select tmpPurchLinePrice where tmpPurchLinePrice.Included
        {
            salesLine = SalesLine::findRecId(tmpPurchLinePrice.SalesLineRefRecId);

            if (salesLine.InventRefId &&
                salesLine.InventRefType == InventRefType::Purch &&
                PurchTable::find(salesLine.InventRefId))
            {
                if (isKittingEnabled)
                {
                    kittingRet = (Box::okCancel(strfmt('%1\n%2?',"@SYS65131","@SYS65145"), DialogButton::Ok, "@SYS26198") == DialogButton::Ok);
                    break;
                }
                else
                {
                    return (Box::okCancel(strFmt('%1\n%2?',"@SYS65131","@SYS65145"), DialogButton::Ok, "@SYS26198") == DialogButton::Ok);
                }
            }
        }

        if (isKittingEnabled)
        {
            return kittingRet && KittingClassDelegateHelper::PurchCreateFromSalesOrder_checkTransferred(tmpPurchLinePrice);
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static PurchCreateFromSalesOrder construct()
    {
        return new PurchCreateFromSalesOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromCallerRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the object state based on the caller record.
    /// </summary>
    /// <param name = "_callerRecord">The record passed into the <c>PurchCreateFromSalesOrder</c> instance.</param>
    public void initializeFromCallerRecord(Common _callerRecord)
    {
        SalesTable salesTableLocal;
        switch (_callerRecord.TableId)
        {
            case tableNum(SalesTable):
                salesTableLocal = _callerRecord;
                
                if (this.tradeLineDlvType() == TradeLineDlvType::DropShip)
                {
                    this.mcrDropShipment(true);
                }
                this.parmSalesTable(salesTableLocal);
                this.parmCallerRecord(salesTableLocal);
                break;
            case tableNum(SalesLine):
                SalesLine salesLineLocal = _callerRecord;

                if (salesLineLocal.SalesType == SalesType::ItemReq)
                {
                    salesTableLocal = salesLineLocal.salesTable();
                    this.parmSalesTable(salesTableLocal);
                    this.parmCallerRecord(salesTableLocal);
                }
                else
                {
                    this.parmSalesLine(salesLineLocal);
                    this.parmCallerRecord(salesLineLocal);
                }
                break;
            case tableNum(PurchTable):
                PurchTable purchTableLocal = _callerRecord;

                this.parmCallerRecord(purchTableLocal);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the object state based on the input arguments.
    /// </summary>
    /// <param name = "args">
    /// The input arguments.
    /// </param>
    public void initializeFromArgs(Args args)
    {
        Common callerRecordLocal;

        if (args.dataset())
        {
            callerRecordLocal = args.record();
        }

        this.initializeFromCallerRecord(callerRecordLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        Common              callerRecord;
        TradeLineDlvType    tradeLineDlvType = args.parmEnum();

        if (args.dataset())
        {
            callerRecord = args.record();
        }

        PurchCreateFromSalesOrder purchCreateFromSalesOrder = PurchCreateFromSalesOrder::newPurchCreateFromSalesOrder(tradeLineDlvType);
        purchCreateFromSalesOrder.getLast();
        purchCreateFromSalesOrder.resetCurrentListCS();
        purchCreateFromSalesOrder.initializeFromArgs(args);
       
        if (purchCreateFromSalesOrder.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {
                purchCreateFromSalesOrder.runOperation();

                purchCreateFromSalesOrder.refreshCallerDataSource(args.caller(), callerRecord);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCallerDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refresh the data displayed in the calling datasource.
    /// </summary>
    /// <param name = "_callerObject">The calling object.</param>
    /// <param name = "_callerRecord">The calling datasource record.</param>
    public void refreshCallerDataSource(Object _callerObject, Common _callerRecord)
    {
        Object callerFormDataSource = FormDataUtil::getFormDataSource(_callerRecord);

        switch (_callerRecord.TableId)
        {
            case tableNum(SalesTable):
                    if (_callerObject && formHasMethod(_callerObject, identifierStr(SalesTable)))
                {
                    _callerObject.doRefresh();
                }
                else if (callerFormDataSource && formDataSourceHasMethod(callerFormDataSource, identifierStr(reReadLines)))
                {
                    callerFormDataSource.reReadLines();
                }
                break;

            case tableNum(SalesLine):
                    if (_callerObject && formHasMethod(_callerObject, identifierStr(SalesTable)))
                {
                    _callerObject.doRefresh();
                }
                else if (callerFormDataSource)
                {
                    callerFormDataSource.executeQuery();
                }
                break;
        
            case tableNum(PurchTable):
                    if (callerFormDataSource)
                {
                    callerFormDataSource.research();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchCreateFromSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes and returns the <c>PurchCreateFromSalesOrder</c> object.
    /// </summary>
    /// <param name="_tradeLineDlvType">
    /// A <c>TradeLineDlvType</c> value that determines which class to instantiate.
    /// </param>
    /// <returns>
    /// The <c>PurchCreateFromSalesOrder</c> object.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The class cannot be instantiated.
    /// </exception>
    public static PurchCreateFromSalesOrder newPurchCreateFromSalesOrder(TradeLineDlvType _tradeLineDlvType)
    {
        TradeLineDlvTypeFactoryAttribute    attribute                   = new TradeLineDlvTypeFactoryAttribute(_tradeLineDlvType);
        PurchCreateFromSalesOrder           purchCreateFromSalesOrder   = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(PurchCreateFromSalesOrder), attribute) as PurchCreateFromSalesOrder;

        if (classIdGet(purchCreateFromSalesOrder) == classNum(PurchCreateFromSalesOrder) && _tradeLineDlvType != TradeLineDlvType::None)
        {
            throw error(strFmt("@SYS19306", funcName()));
        }

        purchCreateFromSalesOrder.resetCurrentListCS();
        return purchCreateFromSalesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal PurchInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = PurchInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>