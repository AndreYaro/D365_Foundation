<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrWorkingTimesCache</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System;
using System.Collections;

/// <summary>
/// Provides functionality to cache working times using ReqMemoryCache.
/// The working times are cached per calendar and in blocks of 3 months.
/// </summary>
class WrkCtrWorkingTimesCache
{
    private static const EffectivityPct DefaultEffectivity = 100;
    private static readonly Map EmptyPropertiesMap = new Map(Types::String, Types::Real);
    private static const int NumberOfMonthsInCacheBlock = 3;
    private static const int CacheBlocksInAYear = 12 div NumberOfMonthsInCacheBlock;
    private static const int WorkingTimeStartIdx = 1;
    private static const int WorkingTimeEndIdx = 2;
    private static Set invalidatedCalendars;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the working times in a calendar, within a time interval.
    /// The returned working times have effectivity multiplied by _effectivityPct
    /// and include _properties. It is possible to specify a maximum number of working
    /// times to return, and if the returned working times should be enumerated forwards
    /// (from the earliest to the latest) or backwards (from the latest to the earliest)
    /// </summary>
    /// <param name="_calendarId">
    ///    The <c>CalendarId</c> value that identifies the calendar for which to fetch the working times
    /// </param>
    /// <param name="_start">
    ///    The date/time value that identifies beginning of the desired time interval
    /// </param>
    /// <param name="_end">
    ///    The date/time value that identifies end of the desired time interval
    /// </param>
    /// <param name="_effectivityPct">
    ///    A percentage value of type <c>EffectivityPct</c> that will be used to compute the effectiveness
    ///    of the resulting working times. This value is multiplied with the efficiency of each working time.
    /// </param>
    /// <param name="_properties">
    ///    A list of properties that should be added to the calendar line property
    /// </param>
    /// <param name="_requestedCount">
    ///    The maximum number of working time records to retrieve
    /// </param>
    /// <param name="_forward">
    ///    The direction to start looking for working times. If true the direction is forward, starting at the
    ///    start date and start time. If false the direction is backwards, starting at the end date and end
    ///    time
    /// </param>
    /// <returns>
    ///    A container that stores the working time records. Each element in the container is another
    ///    container that has the start date time, end date time, effectivity, and property ID, respectively
    /// </returns>
    [Hookable(false)]
    public static container getValues(CalendarId     _calendarId,
                                      utcdatetime    _start,
                                      utcdatetime    _end,
                                      EffectivityPct _effectivity = DefaultEffectivity,
                                      Map            _properties = EmptyPropertiesMap,
                                      int            _requestedCount = maxInt(),
                                      boolean        _forward = true)
    {
        if (   _start >= _end
            || _requestedCount < 1)
        {
            return conNull();
        }

        Generic.List<container> list = WrkCtrWorkingTimesCache::getWorkingTimesInInterval(_calendarId, _start, _end, _requestedCount, _forward);
        if (list == null)
        {
            return conNull();
        }

        int startIndex = WrkCtrWorkingTimesCache::findStartIndex(list, _start);
        if (startIndex == -1)
        {
            return conNull();
        }

        int endIndex = WrkCtrWorkingTimesCache::findEndIndex(list, _end, startIndex);
        if (endIndex == -1)
        {
            return conNull();
        }

        System.Object[] array = WrkCtrWorkingTimesCache::copyToArray(list, startIndex, endIndex, _requestedCount, _effectivity, _properties, _forward);
        WrkCtrWorkingTimesCache::clipFirstAndLastWorkingTime(array, _start, _end);
        return WrkCtrWorkingTimesCache::objectArrayToContainer(array);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCached</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a date is cached for a calendar.
    /// </summary>
    /// <param name="_calendarId">
    /// The ID of the calendar that contains the date to check.
    /// </param>
    /// <param name="_date">
    /// The date/time to check for existence in the cache.
    /// </param>
    /// <returns>True if _date is cached for calendar _calendarId, otherwise false.</returns>
    [Hookable(false)]
    public static boolean isCached(CalendarId _calendarId, utcdatetime _date)
    {
        Map calendar = WrkCtrWorkingTimesCache::getCalendarFromCache(_calendarId);
        utcdatetime d = WrkCtrWorkingTimesCache::getCacheBlockStartDate(_date);
        return calendar != null && calendar.exists(d);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invalidateCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the input calendar from the working times cache.
    /// </summary>
    /// <param name="_calendarId">
    /// The ID of the calendar to invalidate.
    /// </param>
    [Hookable(false)]
    public static void invalidateCalendar(CalendarId _calendarId)
    {
        invalidatedCalendars = new Set (Types::String);
        
        WrkCtrWorkingTimesCache::invalidateCalendarHierarchy(_calendarId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invalidateCalendarHierarchy</Name>
				<Source><![CDATA[
    private static void invalidateCalendarHierarchy(CalendarId _calendarId)
    {
        SysGlobalObjectCache globalCache = new SysGlobalObjectCache();
        globalCache.remove(WrkCtrWorkingTimesCache::getGlobalObjectCacheScope(), [_calendarId]);
        WrkCtrWorkingTimesCache::clearCalendarFromCache(_calendarId);
        invalidatedCalendars.add(_calendarId);
        
        WrkCtrWorkingTimesCache::invalidateDerivedCalendars(_calendarId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invalidateDerivedCalendars</Name>
				<Source><![CDATA[
    private static void invalidateDerivedCalendars(CalendarId _calendarId)
    {
        WorkCalendarTable derivedCalendar;
        while select CalendarId from derivedCalendar
            where derivedCalendar.BasicCalendarId == _calendarId
        {
            if (WrkCtrWorkingTimesCache::hasValidBaseCalendar(derivedCalendar)
                && !invalidatedCalendars.in(derivedCalendar.CalendarId))
            {
                WrkCtrWorkingTimesCache::invalidateCalendarHierarchy(derivedCalendar.CalendarId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>objectArrayToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts an array of System.Object to a container.
    /// </summary>
    /// <param name = "_array">The array to convert to a container.</param>
    /// <returns>A container with the same values as the input array.</returns>
    [Hookable(false)]
    public static container objectArrayToContainer(System.Object[] _array)
    {
        anytype anytypeArray = _array;
        container c = anytypeArray;
        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBlockToCache</Name>
				<Source><![CDATA[
    private static Generic.List<container> addBlockToCache(CalendarId _calendarId, utcdatetime _dateToCache)
    {
        WorkCalendarTable calendar = WorkCalendarTable::find(_calendarId);
        if (calendar.RecId == 0)
        {
            return null;
        }

        if (WrkCtrWorkingTimesCache::hasValidBaseCalendar(calendar))
        {
            WrkCtrWorkingTimesCache::addBlockToCache(calendar.BasicCalendarId, _dateToCache);
        }

        Generic.List<container> list = WrkCtrWorkingTimesCache::getWorkingTimesFromDatabase(calendar, _dateToCache);

        if (list.get_Count() == 0 && !WrkCtrWorkingTimesCacheEmptyFlight::instance().isEnabled())
        {
            return null;
        }

        list.TrimExcess();

        WrkCtrWorkingTimesCache::addListToCache(_calendarId, _dateToCache, list);
        WrkCtrWorkingTimesCache::addCalendarIdToGlobalCache(_calendarId);

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimesFromDatabase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Queries the database and returns the working times in the _calendar that belong to the block containing _blockDate.
    /// Accounts for base calendars.
    /// </summary>
    /// <param name="_calendar">The calendar for which to check the working times block</param>
    /// <param name="_blockDate">The date identifying the block of working dates to fetch from the database</param>
    /// <returns>The list of working times for the block</returns>
    private static Generic.List<container> getWorkingTimesFromDatabase(WorkCalendarTable _calendar, utcdatetime _blockDate)
    {
        utcdatetime blockStartDateTime = WrkCtrWorkingTimesCache::getCacheBlockStartDate(_blockDate);
        utcdatetime blockEndDateTime = WrkCtrWorkingTimesCache::addMonthsInCacheBlock(blockStartDateTime);

        Generic.List<container> workingTimes = WrkCtrWorkingTimesCache::getWorkingTimesBlockFromBaseCalendar(_calendar, 
                                                                                                             blockStartDateTime, 
                                                                                                             blockEndDateTime);
        WrkCtrWorkingTimesCache::queryDatabaseAndAddWorkingTimesForOpenDates(_calendar, blockStartDateTime, blockEndDateTime, workingTimes);
        return workingTimes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimesBlockFromBaseCalendar</Name>
				<Source><![CDATA[
    private static Generic.List<container> getWorkingTimesBlockFromBaseCalendar(WorkCalendarTable _calendar, 
                                                                                utcdatetime _blockStartDate, 
                                                                                utcdatetime _blockEndDate)
    {
        Generic.List<container> baseCalendarWorkingTimesExceptOpenClosedDates = new Generic.List<container>();
        
        if (WrkCtrWorkingTimesCache::hasValidBaseCalendar(_calendar))
        {
            Generic.List<container> baseCalendarList = WrkCtrWorkingTimesCache::getBlockFromCache(_calendar.BasicCalendarId, _blockStartDate);
            if (baseCalendarList)
            {
                Generic.HashSet<date> nonBasicDates = WrkCtrWorkingTimesCache::getNonBasicDates(_calendar.CalendarId,
                                                                                                _blockStartDate, 
                                                                                                _blockEndDate);
                baseCalendarWorkingTimesExceptOpenClosedDates = WrkCtrWorkingTimesCache::excludeWorkingTimes(baseCalendarList, nonBasicDates);
            }
        }

        return baseCalendarWorkingTimesExceptOpenClosedDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasValidBaseCalendar</Name>
				<Source><![CDATA[
    private static boolean hasValidBaseCalendar(WorkCalendarTable _calendar)
    {
        return    _calendar.BasicCalendarId
               && _calendar.BasicCalendarId != _calendar.CalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonBasicDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the set of dates within a start and an end that are not inherited from the base calendar.
    /// </summary>
    /// <param name="_calendarId">The ID of the calendar for which non basic dates are found</param>
    /// <param name="_start">The beginning of the interval to consider</param>
    /// <param name="_end">The end of the interval to consider</param>
    /// <returns>A set with the dates in the calendar that are not basic in the interval</returns>
    private static Generic.HashSet<date> getNonBasicDates(CalendarId _calendarId, 
                                                          utcdatetime _start, 
                                                          utcdatetime _end)
    {
        Generic.HashSet<date> set = new Generic.HashSet<date>();
        WorkCalendarDate workDate;
        while select CalendarId, TransDate from workDate 
            where workDate.CalendarId == _calendarId
                && workDate.TransDate >= DateTimeUtil::date(_start)
                && workDate.TransDate <  DateTimeUtil::date(_end)
                && workDate.WorkTimeControl != WorkTimeControl::UseBasic
        {
            set.Add(workDate.TransDate);
        }

        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeWorkingTimes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list with the working times in _baseCalendarWorkingTimes that are not in a date
    /// contained in _datesToExclude.
    /// </summary>
    /// <param name="_baseCalendarWorkingTimes">
    /// The working times list from which to remove dates contained in _datesToExclude
    /// </param>
    /// <param name="_datesToExclude">
    /// The set of dates to exclude from _baseCalendarWorkingTimes
    /// </param>
    /// <returns>
    /// A list with the working times in _baseCalendarWorkingTimes that are not in a date
    /// contained in _datesToExclude
    /// </returns>
    private static Generic.List<container> excludeWorkingTimes(Generic.List<container> _baseCalendarWorkingTimes,
                                                               Generic.HashSet<date> _datesToExclude)
    {
        Generic.List<container> _baseCalendarWorkingTimesWithoutOpenClosedDates = new Generic.List<container>();

        int baseCalendarWorkingTimesCount = _baseCalendarWorkingTimes.get_Count();
        for (int i = 0; i < baseCalendarWorkingTimesCount; ++i)
        {
            container c = _baseCalendarWorkingTimes.get_Item(i);
            utcdatetime start = conPeek(c, WorkingTimeStartIdx);
            date startDate = DateTimeUtil::date(start);
            if (!_datesToExclude.Contains(startDate))
            {
                _baseCalendarWorkingTimesWithoutOpenClosedDates.Add(c);
            }
        }

        return _baseCalendarWorkingTimesWithoutOpenClosedDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryDatabaseAndAddWorkingTimesForOpenDates</Name>
				<Source><![CDATA[
    private static void queryDatabaseAndAddWorkingTimesForOpenDates(WorkCalendarTable _calendar, 
                                                                    utcdatetime _blockStartDateTime, 
                                                                    utcdatetime _blockEndDateTime, 
                                                                    Generic.List<container> _workingTimesFromBaseCalendar)
    {
        int insertIndex = 0;
        WorkCalendarDate workDate;
        WorkCalendarDateLine dateLine;
        while select CalendarId, TransDate, FromTime, ToTime, Effectivity, PropertyId from dateLine
            order by dateLine.TransDate asc,
                     dateLine.FromTime asc
            where dateLine.CalendarId == _calendar.CalendarId
               && dateLine.TransDate >= DateTimeUtil::date(_blockStartDateTime)
               && dateLine.TransDate <  DateTimeUtil::date(_blockEndDateTime)
            exists join workDate 
                where workDate.CalendarId == _calendar.CalendarId
                   && workDate.TransDate >= DateTimeUtil::date(_blockStartDateTime)
                   && workDate.TransDate <  DateTimeUtil::date(_blockEndDateTime)
                   && workDate.TransDate == dateLine.TransDate
                   && workDate.WorkTimeControl == WorkTimeControl::Open
        {
            container workingTime = WrkCtrWorkingTimesCache::packWorkingTimeContainer(dateLine);
            insertIndex = WrkCtrWorkingTimesCache::insertWorkingTimeInList(_workingTimesFromBaseCalendar, insertIndex, workingTime);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>packWorkingTimeContainer</Name>
				<Source><![CDATA[
    private static container packWorkingTimeContainer(WorkCalendarDateLine _dateLine)
    {
        utcdatetime start = DateTimeUtil::newDateTime(_dateLine.TransDate, _dateLine.FromTime);
        utcdatetime end   = DateTimeUtil::newDateTime(_dateLine.TransDate, _dateLine.ToTime);
        container properties = _dateLine.PropertyId ? [WrkCtrSchedulingProperty::propertySchedulingProperty(_dateLine.PropertyId), 0.0]
                                                    : conNull();

        return [start, end, _dateLine.Effectivity / DefaultEffectivity, properties];
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkingTimeInList</Name>
				<Source><![CDATA[
    private static int insertWorkingTimeInList(Generic.List<container> _list, int _searchStartIndex, container _valueToAdd)
    {
        utcdatetime workingTimeStart = conPeek(_valueToAdd, WorkingTimeStartIdx);
        int insertIndex = WrkCtrWorkingTimesCache::findDatePositionInList(_list, workingTimeStart, max(_searchStartIndex, 0));

        if (insertIndex == -1)
        {
            _list.Add(_valueToAdd);
        }
        else
        {
            _list.Insert(insertIndex, _valueToAdd);
        }

        return insertIndex;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDatePositionInList</Name>
				<Source><![CDATA[
    private static int findDatePositionInList(Generic.List<container> _list, utcdatetime _dateTime, int _offset = 0)
    {
        int listLength = _list.get_Count();

        for (int i = _offset; i < listLength; ++i)
        {
            container c = _list.get_Item(i);
            utcdatetime worktime_start = conPeek(c, WorkingTimeStartIdx);
            if (_dateTime < worktime_start)
            {
                return i;
            }
        }

        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addListToCache</Name>
				<Source><![CDATA[
    private static void addListToCache(CalendarId _calendarId, utcdatetime _blockDate, Generic.List<container> _list)
    {
        str key = WrkCtrWorkingTimesCache::generateCacheKey(_calendarId);
        ReqMemoryCacheCrossSessionScope scope = WrkCtrWorkingTimesCache::getScope();

        Map calendarMap = ReqMemoryCache::getFromCrossSessionScope(key, scope);
        if (calendarMap == null)
        {
            calendarMap = new Map(Types::UtcDateTime, Types::Class);
        }
        else if(calendarMap.exists(_blockDate) && WrkCtrWorkingTimesCacheCachedLIstCheckFlight::instance().isEnabled())
        {
            var logger = ProdInstrumentationLogger::createLogger(classStr(WrkCtrWorkingTimesCache));

            using(SysInstrumentationActivityContext activityContext = logger.WrkCtrWorkingTimesCache().addListToCache())
            {
                calendarMap.remove(_blockDate);

                logger.logInformation(
                    strFmt('The cross-session cache already contains a record for calendar %1 and date %2. The record has been deleted.',
                           _calendarId, _blockDate)); 
                logger.logInformation(strFmt('GlobalKey=%1,\n _calendarId=%2,\n _blockDate=%3,\n _list.get_Count=%4,\n CallStack=%5',
                    scope.scopeKeyToGlobalKey(key), 
                    _calendarId,
                    DateTimeUtil::toStr(_blockDate),
                    int2Str(_list.get_Count()),
                    con2Str(xSession::xppCallStack())));
            }
        }

        calendarMap.insert(_blockDate, _list);

        ReqMemoryCache::addToCrossSessionScope(key, calendarMap, scope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalendarIdToGlobalCache</Name>
				<Source><![CDATA[
    private static void addCalendarIdToGlobalCache(CalendarId _calendarId)
    {
        SysGlobalObjectCache globalCache = new SysGlobalObjectCache();
        globalCache.insert(WrkCtrWorkingTimesCache::getGlobalObjectCacheScope(), [_calendarId], [_calendarId]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGlobalObjectCacheScope</Name>
				<Source><![CDATA[
    private static GlobalObjectCacheScope getGlobalObjectCacheScope()
    {
        return classStr(WrkCtrWorkingTimesCache) + getcurrentpartition() + curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimesInInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the working times for a calendar within a certain [_start, _end] interval, up to the requested count and in
    /// the requested direction (forward/backward).
    /// If any of the working times included in the interval are not cached, they are loaded into the cache in blocks of
    /// 3 months (a quarter). The working times of all the blocks touched by the interval are concatenated in a List of
    /// container, which is then returned.
    /// </summary>
    /// <returns>
    /// A list of all the working times included from _start to _end in the calendar _calendarId
    /// up to the requested count and in the requested direction (forward/backward).
    /// </returns>
    private static Generic.List<container> getWorkingTimesInInterval(CalendarId _calendarId, 
                                                                     utcdatetime _start, 
                                                                     utcdatetime _end,
                                                                     int _requestedCount,
                                                                     boolean _forward)
    {
        WrkCtrWorkingTimesCache::clearCacheIfCalendarInvalidated(_calendarId);
        return WrkCtrWorkingTimesCache::getWorkingTimesInIntervalFromCacheBlocks(_calendarId, _start, _end, _requestedCount, _forward);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimesInIntervalFromCacheBlocks</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Return the working times in a calendar, included in a sequence of cache blocks.
    ///   The number of returned values is at most the requested count.
    /// </summary>
    /// <param name = "_calendarId">The calendar for which to fetch the working times.</param>
    /// <param name = "_start">The beginning of the requested interval.</param>
    /// <param name = "_end">The end of the requested interval.</param>
    /// <param name = "_requestedCount">The requested number of working times.</param>
    /// <param name = "_forward">The direction in which the working times should be enumerated; forward if true, false otherwise.</param>
    /// <returns>A list with the requested working times.</returns>
    private static Generic.List<container> getWorkingTimesInIntervalFromCacheBlocks(CalendarId _calendarId, 
                                                                                    utcdatetime _start, 
                                                                                    utcdatetime _end,
                                                                                    int _requestedCount,
                                                                                    boolean _forward)
    {
        utcdatetime start = WrkCtrWorkingTimesCache::clipToFirstDateOfCalendarIfMinValue(_calendarId, _start, _forward);
        utcdatetime end = WrkCtrWorkingTimesCache::clipToLastDateOfCalendarIfMaxValue(_calendarId, _end, _forward);
        utcdatetime startBlockDate = WrkCtrWorkingTimesCache::getCacheBlockStartDate(start);
        utcdatetime endBlockDate = WrkCtrWorkingTimesCache::getCacheBlockStartDate(end);

        Generic.List<container> workingTimesInInterval;

        if (_forward)
        {
            workingTimesInInterval = WrkCtrWorkingTimesCache::getWorkingTimesInIntervalFromCacheBlocksForward(_calendarId, startBlockDate, endBlockDate, _requestedCount);
        }
        else
        {
            workingTimesInInterval = WrkCtrWorkingTimesCache::getWorkingTimesInIntervalFromCacheBlocksBackward(_calendarId, startBlockDate, endBlockDate, _requestedCount);
        }

        workingTimesInInterval.TrimExcess();

        return workingTimesInInterval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimesInIntervalFromCacheBlocksForward</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get working times from a sequence of cache blocks included within _startBlockDate and _endBlockDate;
    /// returns a number of working times up to the requested count, in the forward direction.
    /// </summary>
    /// <param name="_calendarId">The ID of the calendar for which to get the working times</param>
    /// <param name="_startBlockDate">The beginning date of the first cache block</param>
    /// <param name="_endBlockDate">The beginning date of the last cache block</param>
    /// <param name="_requestedCount">The maximum number of working times to return</param>
    /// <returns>
    /// The sequence of working times within _startBlockDate and _endBlockDate, up to 
    /// _requestedCount, in the forward direction.
    /// </returns>
    private static Generic.List<container> getWorkingTimesInIntervalFromCacheBlocksForward(CalendarId _calendarId,
                                                                                           utcdatetime _startBlockDate,
                                                                                           utcdatetime _endBlockDate,
                                                                                           int _requestedCount)
    {
        Map cachedCalendar = WrkCtrWorkingTimesCache::getCalendarFromCache(_calendarId);
        Generic.List<container> timeIntervalWorkingTimes = new Generic.List<container>();

        int workingTimesCountOffset = 0;
        utcdatetime previousBlockDate;
        utcdatetime currentBlockDate = _startBlockDate;
        while (currentBlockDate <= _endBlockDate)
        {
            Generic.List<container> blockWorkingTimes = WrkCtrWorkingTimesCache::getBlockFromCalendarAndAddToCacheIfNotFound(cachedCalendar, _calendarId, currentBlockDate);
            WrkCtrWorkingTimesCache::appendList(timeIntervalWorkingTimes, blockWorkingTimes);

            // Exclude the first block from the count of retrieved working times.
            // This makes sure that the number of working times added to timeIntervalWorkingTimes
            // is always sufficient to satisfy _requestedCount.
            if (currentBlockDate == _startBlockDate)
            {
                workingTimesCountOffset = timeIntervalWorkingTimes.get_Count();
            }
            
            // Stop once there are enough working times.
            if (timeIntervalWorkingTimes.get_Count() - workingTimesCountOffset >= _requestedCount)
            {
                break;
            }

            previousBlockDate = currentBlockDate;
            currentBlockDate = WrkCtrWorkingTimesCache::addMonthsInCacheBlock(currentBlockDate);
            if (previousBlockDate == currentBlockDate)
            {
                break;
            }
        }

        return timeIntervalWorkingTimes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimesInIntervalFromCacheBlocksBackward</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get working times from a sequence of cache blocks included within _startBlockDate and _endBlockDate;
    /// returns a number of working times up to the requested count, in the backward direction.
    /// </summary>
    /// <param name="_calendarId">The ID of the calendar for which to get the working times</param>
    /// <param name="_startBlockDate">The beginning date of the first cache block</param>
    /// <param name="_endBlockDate">The beginning date of the last cache block</param>
    /// <param name="_requestedCount">The maximum number of working times to return</param>
    /// <returns>
    /// The sequence of working times within _startBlockDate and _endBlockDate, up to
    /// _requestedCount, in the backward direction.
    /// </returns>
    private static Generic.List<container> getWorkingTimesInIntervalFromCacheBlocksBackward(CalendarId _calendarId,
                                                                                            utcdatetime _startBlockDate,
                                                                                            utcdatetime _endBlockDate,
                                                                                            int _requestedCount)
    {
        Map cachedCalendar = WrkCtrWorkingTimesCache::getCalendarFromCache(_calendarId);
        Generic.List<Generic.List<container>> cacheBlocks = new Generic.List<Generic.List<container>>();

        int countOfWorkingTimesInBlocks = 0;
        utcdatetime previousBlockDate;
        utcdatetime currentBlockDate = _endBlockDate;
        while (currentBlockDate >= _startBlockDate)
        {
            Generic.List<container> blockWorkingTimes = WrkCtrWorkingTimesCache::getBlockFromCalendarAndAddToCacheIfNotFound(cachedCalendar, _calendarId, currentBlockDate);
            cacheBlocks.Add(blockWorkingTimes);

            // Exclude the last block from the count of retrieved working times.
            // This makes sure that the number of working times added to timeIntervalWorkingTimes
            // is always sufficient to satisfy _requestedCount.
            if (currentBlockDate != _endBlockDate)
            {
                countOfWorkingTimesInBlocks += blockWorkingTimes == null ? 0 : blockWorkingTimes.get_Count();
            }

            // Stop once there are enough working times.
            if (countOfWorkingTimesInBlocks >= _requestedCount)
            {
                break;
            }

            previousBlockDate = currentBlockDate;
            currentBlockDate = WrkCtrWorkingTimesCache::subtractMonthsInCacheBlock(currentBlockDate);
            if (currentBlockDate == previousBlockDate)
            {
                break;
            }
        }

        Generic.List<container> timeIntervalWorkingTimes = new Generic.List<container>();

        // Append all the cache blocks in reverse order
        for (int i = cacheBlocks.get_Count() - 1; i >= 0; --i)
        {
            WrkCtrWorkingTimesCache::appendList(timeIntervalWorkingTimes, cacheBlocks.get_Item(i));
        }

        return timeIntervalWorkingTimes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheIfCalendarInvalidated</Name>
				<Source><![CDATA[
    private static void clearCacheIfCalendarInvalidated(CalendarId _calendarId)
    {
        SysGlobalObjectCache globalCache = new SysGlobalObjectCache();
        container cachedCalendarBlockId = globalCache.find(WrkCtrWorkingTimesCache::getGlobalObjectCacheScope(), [_calendarId]);
        if (cachedCalendarBlockId == conNull())
        {
            WrkCtrWorkingTimesCache::clearCalendarFromCache(_calendarId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendarFromCache</Name>
				<Source><![CDATA[
    private static Map getCalendarFromCache(CalendarId _calendarId)
    {
        str key = WrkCtrWorkingTimesCache::generateCacheKey(_calendarId);
        ReqMemoryCacheCrossSessionScope scope = WrkCtrWorkingTimesCache::getScope();
        return ReqMemoryCache::getFromCrossSessionScope(key, scope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBlockFromCache</Name>
				<Source><![CDATA[
    private static Generic.List<container> getBlockFromCache(CalendarId _calendarId, utcdatetime _datetime)
    {
        Map calendar = WrkCtrWorkingTimesCache::getCalendarFromCache(_calendarId);
        if (   calendar != null
            && calendar.exists(_datetime))
        {
            return calendar.lookup(_dateTime);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBlockFromCalendarAndAddToCacheIfNotFound</Name>
				<Source><![CDATA[
    private static Generic.List<container> getBlockFromCalendarAndAddToCacheIfNotFound(Map _cachedCalendar,
                                                                                       CalendarId _calendarId,
                                                                                       utcdatetime _blockDate)
    {
        if (   _cachedCalendar == null
            || !_cachedCalendar.exists(_blockDate))
        {
            return WrkCtrWorkingTimesCache::addBlockToCache(_calendarId, _blockDate);
        }
        else
        {
            return _cachedCalendar.lookup(_blockDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCalendarFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears a given calendar from the cache.
    /// </summary>
    /// <param name="_calendarId">The ID of the calendar to clear from the cache.</param>
    private static void clearCalendarFromCache(CalendarId _calendarId)
    {
        str key = WrkCtrWorkingTimesCache::generateCacheKey(_calendarId);
        ReqMemoryCacheCrossSessionScope scope = WrkCtrWorkingTimesCache::getScope();
        ReqMemoryCache::removeFromCrossSessionScope(key, scope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMonthsInCacheBlock</Name>
				<Source><![CDATA[
    private static utcdatetime addMonthsInCacheBlock(utcdatetime _date)
    {
        if (_date > DateTimeUtil::addMonths(DateTimeUtil::maxValue(), -NumberOfMonthsInCacheBlock))
        {
            return DateTimeUtil::maxValue();
        }

        return DateTimeUtil::addMonths(_date, NumberOfMonthsInCacheBlock);
    }

]]></Source>
			</Method>
			<Method>
				<Name>subtractMonthsInCacheBlock</Name>
				<Source><![CDATA[
    private static utcdatetime subtractMonthsInCacheBlock(utcdatetime _date)
    {
        if (_date < DateTimeUtil::addMonths(DateTimeUtil::minValue(), NumberOfMonthsInCacheBlock))
        {
            return DateTimeUtil::minValue();
        }

        return DateTimeUtil::addMonths(_date, -NumberOfMonthsInCacheBlock);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clipToFirstDateOfCalendarIfMinValue</Name>
				<Source><![CDATA[
    private static utcdatetime clipToFirstDateOfCalendarIfMinValue(CalendarId _calendarId, utcdatetime _datetime, boolean _forward)
    {
        if (_forward && _datetime == DateTimeUtil::minValue())
        {
            return WrkCtrWorkingTimesCache::getFirstDateOfCalendar(_calendarId);
        }

        return _datetime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstDateOfCalendar</Name>
				<Source><![CDATA[
    private static utcdatetime getFirstDateOfCalendar(CalendarId _calendarId)
    {
        WorkCalendarDate startDate;
        select minof(TransDate) from startDate
            where startDate.CalendarId == _calendarId;

        if (!startDate.TransDate)
        {
            return DateTimeUtil::minValue();
        }

        return DateTimeUtil::newDateTime(startDate.TransDate, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clipToLastDateOfCalendarIfMaxValue</Name>
				<Source><![CDATA[
    private static utcdatetime clipToLastDateOfCalendarIfMaxValue(CalendarId _calendarId, utcdatetime _datetime, boolean _forward)
    {
        if (!_forward &&_datetime == DateTimeUtil::maxValue())
        {
            return WrkCtrWorkingTimesCache::getLastDateOfCalendar(_calendarId);
        }

        return _datetime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastDateOfCalendar</Name>
				<Source><![CDATA[
    private static utcdatetime getLastDateOfCalendar(CalendarId _calendarId)
    {
        WorkCalendarDate endDate;
        select maxof(TransDate) from endDate
            where endDate.CalendarId == _calendarId;

        if (!endDate.TransDate)
        {
            return DateTimeUtil::maxValue();
        }

        return DateTimeUtil::newDateTime(endDate.TransDate, 0);

    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheBlockStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the first date of the cache block that includes _dateTime.
    /// It is used as unique identifier within the calendar.
    /// </summary>
    private static utcdatetime getCacheBlockStartDate(utcdatetime _datetime)
    {
        int year = DateTimeUtil::year(_datetime);
        int month = ((DateTimeUtil::month(_datetime) - 1) div NumberOfMonthsInCacheBlock) * NumberOfMonthsInCacheBlock + 1;
        return DateTimeUtil::newDateTime(mkDate(1, month, year), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateCacheKey</Name>
				<Source><![CDATA[
    private static str generateCacheKey(CalendarId _calendarId)
    {
        return strFmt('WrkCtrWorkingTimesCache#%1', _calendarId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getScope</Name>
				<Source><![CDATA[
    private static ReqMemoryCacheCrossSessionScope getScope()
    {
        return ReqMemoryCacheCrossSessionScope::newDataAreaScope(classstr(WrkCtrWorkingTimesCache));
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendList</Name>
				<Source><![CDATA[
    private static void appendList(Generic.List<container> _list, Generic.List<container> _listToAppend)
    {
        if (_listToAppend != null)
        {
            _list.AddRange(_listToAppend);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findStartIndex</Name>
				<Source><![CDATA[
    ///<summary>
    /// Finds the index of the first working time covered by the start of a time interval, represented by _datetime.
    ///</summary>
    private static int findStartIndex(Generic.List<container> _list, utcdatetime _dateTime, int _offset = 0)
    {
        int idx = -1;
        int listLength = _list.get_Count();

        for (int i = _offset; i < listLength; ++i)
        {
            container c = _list.get_Item(i);
            utcdatetime worktime_end = conPeek(c, WorkingTimeEndIdx);
            if (_dateTime < worktime_end)
            {
                return i;
            }
        }

        return idx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findEndIndex</Name>
				<Source><![CDATA[
    ///<summary>
    /// Finds the index of the last working time covered by the end of a time interval, represented by _datetime.
    ///</summary>
    private static int findEndIndex(Generic.List<container> _list, utcdatetime _dateTime, int _offset = 0)
    {
        int idx = -1;
        int listLength = _list.get_Count();

        for (int i = listLength - 1; i >= _offset; --i)
        {
            container c = _list.get_Item(i);
            utcdatetime worktime_start = conPeek(c, WorkingTimeStartIdx);
            if (_dateTime > worktime_start)
            {
                return i;
            }
        }

        return idx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyToArray</Name>
				<Source><![CDATA[
    private static System.Object[] copyToArray(Generic.List<container> _list,
                                               int _startIndex,
                                               int _endIndex,
                                               int _requestedCount,
                                               EffectivityPct _effectivityPct,
                                               Map _properties,
                                               boolean _forward)
    {
        int itemsFromStartToEnd = _endIndex - _startIndex + 1;
        int arrayLength = min(itemsFromStartToEnd, _requestedCount);
        System.Object[] array = new System.Object[arrayLength]();

        if (_forward)
        {
            WrkCtrWorkingTimesCache::copyToArrayForward(_list, _startIndex, _effectivityPct, _properties, array);
        }
        else
        {
            WrkCtrWorkingTimesCache::copyToArrayBackward(_list, _endIndex, _effectivityPct, _properties, array);
        }

        return array;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyToArrayForward</Name>
				<Source><![CDATA[
    private static void copyToArrayForward(Generic.List<container> _list, 
                                           int _startIndex, 
                                           EffectivityPct _effectivityPct, 
                                           Map _properties, 
                                           System.Object[] _array)
    {
        int arrayLength = _array.Length;
        if (WrkCtrWorkingTimesCache::mustAdjustForEffectivityAndProperties(_effectivityPct, _properties))
        {
            var normalizedEffectivity = _effectivityPct/100;
            container propertiesContainer = WrkCtrWorkingTimesCache::propertiesMap2Container(_properties);

            for (int i = 0; i < arrayLength; ++i)
            {
                container item = _list.get_Item(_startIndex + i);
                item = WrkCtrWorkingTimesCache::adjustForEffectivityAndProperties(item, normalizedEffectivity, propertiesContainer);
                _array.set_Item(i, item);
            }
        }
        else
        {
            _list.CopyTo(_startIndex, _array, 0, arrayLength);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyToArrayBackward</Name>
				<Source><![CDATA[
    private static void copyToArrayBackward(Generic.List<container> _list, 
                                            int _endIndex, 
                                            EffectivityPct _effectivityPct, 
                                            Map _properties, 
                                            System.Object[] _array)
    {
        int arrayLength = _array.Length;
        if (WrkCtrWorkingTimesCache::mustAdjustForEffectivityAndProperties(_effectivityPct, _properties))
        {
            var normalizedEffectivity = _effectivityPct/100;
            container propertiesContainer = WrkCtrWorkingTimesCache::propertiesMap2Container(_properties);

            for (int i = 0; i < arrayLength; ++i)
            {
                container item = _list.get_Item(_endIndex - i);
                item = WrkCtrWorkingTimesCache::adjustForEffectivityAndProperties(item, normalizedEffectivity, propertiesContainer);
                _array.set_Item(i, item);
            }
        }
        else
        {
            for (int i = 0; i < arrayLength; ++i)
            {
                container item = _list.get_Item(_endIndex - i);
                _array.set_Item(i, item);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAdjustForEffectivityAndProperties</Name>
				<Source><![CDATA[
    /// <summary>
    ///   True if the effectivity and properties of the cached values need to be modified.
    /// </summary>
    private static boolean mustAdjustForEffectivityAndProperties(EffectivityPct _effectivity, Map _properties)
    {
        return    _effectivity != WrkCtrWorkingTimesCache::DefaultEffectivity
               || _properties.elements() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>propertiesMap2Container</Name>
				<Source><![CDATA[
    private static container propertiesMap2Container(Map _properties)
    {
        MapEnumerator   mapEnumerator;
        container       result;
    
        mapEnumerator = _properties.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            result += [mapEnumerator.currentKey(), mapEnumerator.currentValue()];
        }
    
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustForEffectivityAndProperties</Name>
				<Source><![CDATA[
    private static container adjustForEffectivityAndProperties(container _value, 
                                                               EffectivityPct _normalizedEffectivity,
                                                               container _properties)
    {
        utcdatetime start, end;
        EffectivityPct workingTimeEffectivity;
        container cachedProperties;

        [start, end, workingTimeEffectivity, cachedProperties] = _value;
        return [start, end, workingTimeEffectivity * _normalizedEffectivity, _properties + cachedProperties];
    }

]]></Source>
			</Method>
			<Method>
				<Name>clipFirstAndLastWorkingTime</Name>
				<Source><![CDATA[
    private static void clipFirstAndLastWorkingTime(System.Object[] _workingTimes, utcdatetime _start, utcdatetime _end)
    {
        container firstWorkingTime = _workingTimes.get_Item(0);
        container firstWorkingTimeClipped = WrkCtrWorkingTimesCache::clipToInvervalBoundaries(firstWorkingTime, _start, _end);
        _workingTimes.set_Item(0, firstWorkingTimeClipped);

        int length = _workingTimes.get_Count();
        if (length > 1)
        {
            container lastWorkingTime = _workingTimes.get_Item(length-1);
            container lastWorkingTimeClipped = WrkCtrWorkingTimesCache::clipToInvervalBoundaries(lastWorkingTime, _start, _end);
            _workingTimes.set_Item(length-1, lastWorkingTimeClipped);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clipToInvervalBoundaries</Name>
				<Source><![CDATA[
    private static container clipToInvervalBoundaries(container _workingTime, utcdatetime _start, utcdatetime _end)
    {
        utcdatetime startNonClipped, endNonClipped;
        EffectivityPct effectivity;
        container properties;

        [startNonClipped, endNonClipped, effectivity, properties] = _workingTime;

        utcdatetime startClipped = max(startNonClipped, _start);
        utcdatetime endClipped   = min(endNonClipped,   _end);

        return [startClipped, endClipped, effectivity, properties];
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>