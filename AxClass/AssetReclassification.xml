<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetReclassification</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Reclassifies asset with new Fixed Asset group and date.
/// </summary>
public class AssetReclassification extends RunBase
{
    AssetGroupId           oldAssetGroupId;
    AssetId                oldAssetId;
    AssetGroupId           newAssetGroupId;
    AssetId                newAssetId;
    AssetId                allocatedAssetId;
    AssetTransDate         reclassificationDate;
    NumberSequenceCode     numberSequenceCode;
    container              generalJournalAccountEntryClosestRecIds;

    LedgerPostingController ledgerPostingController;
    LedgerVoucher           ledgerPostingJournal;

    NumberSeq              assetIdNumberSeq;

    boolean                transferTransactionsExist;
    protected AmountMST amountLedgerTransactionsSum;
    protected AmountMST amountLedgerTransactionsMax;
    private Set transferredBooks = new Set(Types::String);
    private AssetBook assetBookNewDerogatory;

    #ISOCountryRegionCodes

    boolean countryRegion_DEAT = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoDE, #isoAT]);

    const int CurrentVersion = 2;
    const int Version1 = 1;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>abortNewAssetId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clean up new asset id
    /// </summary>
    public void abortNewAssetId()
    {
        if (assetIdNumberSeq)
        {
            assetIdNumberSeq.abort();
        }

        newAssetId = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        Args     args = new  Args();
        FormRun  assetReclassification;

        args.name(formStr(AssetReclassification));
        args.caller(this);

        assetReclassification = classfactory.formRunClass(args);

        assetReclassification.init();

        return assetReclassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetLedgerAccounts</Name>
				<Source><![CDATA[
    private void checkAssetLedgerAccounts()
    {
        AssetBook assetBook;
        AssetLedgerAccounts assetLedgerAccounts;
        LedgerDimensionAccount assetLedgerDimension;

        while select assetBook
            where assetBook.AssetId == oldAssetId
        {
            while select TransType from assetLedgerAccounts
                group by TransType
                where assetLedgerAccounts.BookId         == assetBook.BookId         &&
                      assetLedgerAccounts.PostingProfile == assetBook.PostingProfile
            {
                assetLedgerDimension = this.findNewAssetLedgerAccount(
                    assetBook.BookId,
                    assetLedgerAccounts.TransType,
                    assetBook.PostingProfile);

                if (! assetLedgerDimension)
                {
                    throw error(strFmt("@FixedAssets:FA_MessageError_AccountDoesNotExistForTransactionType",assetLedgerAccounts.TransType, assetBook.BookId, newAssetId));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNewAssetLedgerAccount</Name>
				<Source><![CDATA[
    protected LedgerDimensionAccount findNewAssetLedgerAccount(
        AssetBookId         _assetBookId,
        AssetTransType      _assetTransType,
        AssetPostingProfile _assetPostingProfile = "")
    {
        AssetLedgerAccounts assetLedgerAccounts;
        AssetPostingProfile assetPostingProfile = _assetPostingProfile;

        if (!assetPostingProfile)
        {
            assetPostingProfile = AssetParameters::find().PostingProfile;
        }

        if (!assetPostingProfile)
        {
            throw error("@SYS67359");
        }

        select firstonly LedgerDimension from assetLedgerAccounts
            where assetLedgerAccounts.PostingProfile   == assetPostingProfile     &&
                  assetLedgerAccounts.BookId           == _assetBookId            &&
                  assetLedgerAccounts.TransType        == _assetTransType         &&
                  assetLedgerAccounts.AccountCode      == TableGroupAll::GroupId  &&
                  assetLedgerAccounts.AccountRelation  == newAssetGroupId;

        if (! assetLedgerAccounts.LedgerDimension)
        {
            select firstonly LedgerDimension from assetLedgerAccounts
                where assetLedgerAccounts.PostingProfile  == assetPostingProfile  &&
                      assetLedgerAccounts.BookId          == _assetBookId         &&
                      assetLedgerAccounts.TransType       == _assetTransType      &&
                      assetLedgerAccounts.AccountCode     == TableGroupAll::All;
        }

        if (! assetLedgerAccounts.LedgerDimension)
        {
            throw error(strFmt("@FixedAssets:FA_MessageError_AccountDoesNotExistForTransactionType", _assetTransType, _assetBookId, newAssetId));
        }

        return assetLedgerAccounts.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewAssetId</Name>
				<Source><![CDATA[
    public boolean initNewAssetId()
    {
        AssetTable assetTable;

        this.abortNewAssetId();

        assetIdNumberSeq = assetTable.initAssetNumberSeq(newAssetGroupId);

        if (assetIdNumberSeq)
        {
            newAssetId = assetIdNumberSeq.num();
            allocatedAssetId = newAssetId;
            return NumberSequenceTable::findByNaturalKey(assetIdNumberSeq.parmNumberSequenceCode()).numAllowEdit();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewAssetGroupId</Name>
				<Source><![CDATA[
    public AssetGroupId parmNewAssetGroupId(AssetGroupId _newAssetGroupId = newAssetGroupId)
    {
        newAssetGroupId = _newAssetGroupId;

        return newAssetGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewAssetId</Name>
				<Source><![CDATA[
    public AssetId parmNewAssetId(AssetId _newAssetId = newAssetId)
    {
        newAssetId = _newAssetId;

        return newAssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberSequenceCode</Name>
				<Source><![CDATA[
    public NumberSequenceCode parmNumberSequenceCode(NumberSequenceCode _numberSequenceCode = numberSequenceCode)
    {
        numberSequenceCode = _numberSequenceCode;

        return numberSequenceCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOldAssetGroupId</Name>
				<Source><![CDATA[
    public AssetGroupId parmOldAssetGroupId(AssetGroupId _oldAssetGroupId = oldAssetGroupId)
    {
        oldAssetGroupId = _oldAssetGroupId;

        return oldAssetGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOldAssetId</Name>
				<Source><![CDATA[
    public AssetId parmOldAssetId(AssetId _oldAssetId = oldAssetId)
    {
        oldAssetId = _oldAssetId;

        return oldAssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReclassificationDate</Name>
				<Source><![CDATA[
    public TransDate parmReclassificationDate(TransDate _reclassificationDate = reclassificationDate)
    {
        reclassificationDate = _reclassificationDate;

        return reclassificationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processValueModels</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates new value models records and asset transaction that are based on the original depreciation
    ///   books during the reclassification process.
    /// </summary>
    /// <param name="_assetId">
    ///   The ID of the asset for which the reclassification is performed.
    /// </param>
    /// <param name="_assetTableNew">
    ///   The asset table buffer for which the reclassification is performed.
    /// </param>
    private void processValueModels(AssetId _assetId, AssetTable _assetTableNew)
    {
        boolean processed;

        ledgerPostingController = LedgerPostingController::construct();

        AssetBook assetBook;
        while select forupdate assetBook
            where assetBook.AssetId == _assetId
                && assetBook.Status == AssetStatus::Open
                && !assetBook.IsDerogatoryBook_FR
        {
            AssetBook assetBookNew = this.initNewAssetBook(assetBook, _assetTableNew);            
            AssetBook assetBookOldDerogatory = this.initNewAssetBookDerogatory_FR(assetBook, _assetTableNew);

            processed = this.processAssetBookTransactions(assetBook, assetBookNew) || processed;

            this.updateAssetBookAfterTransactionsProcessed(assetBookNew, assetBook);

            if (assetBook.AssetDerogatoryModel_FR)
            {
                assetBookOldDerogatory.reread();
                this.updateAssetBookAfterTransactionsProcessed(assetBookNewDerogatory, assetBookOldDerogatory);
            }
        }

        // use one ledger posting journal to post everything to the ledger
        ledgerPostingController.post();

        if (transferTransactionsExist)
        {
            this.processAssetBookTransferTransactions();
        }

        if (processed)
        {
            TransactionLog::create(TransactionLogType::AssetReclassification, strFmt("@SYS54524", oldAssetId, newAssetId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewAssetBook</Name>
				<Source><![CDATA[
    protected AssetBook initNewAssetBook(AssetBook _assetBook, AssetTable _assetTableNew)
    {
        AssetBook assetBookNew;
        buf2Buf(_assetBook, assetBookNew);
        assetBookNew.AssetId = _assetTableNew.AssetId;
        assetBookNew.AssetGroup = _assetTableNew.AssetGroup;

        AssetDefaultDimensionHelper::copyDefaultDimensions(_assetBook, assetBookNew);

        return assetBookNew;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewAssetBookDerogatory_FR</Name>
				<Source><![CDATA[
    private AssetBook initNewAssetBookDerogatory_FR(AssetBook _assetBook, AssetTable _assetTableNew)
    {
        AssetBook assetBookOldDerogatory;

        if (_assetBook.AssetDerogatoryModel_FR)
        {
            assetBookOldDerogatory = AssetBook::find(_assetBook.AssetId, _assetBook.AssetDerogatoryModel_FR, true);
            if (assetBookOldDerogatory.RecId)
            {
                assetBookNewDerogatory = this.initNewAssetBook(assetBookOldDerogatory, _assetTableNew);
            }
        }

        return assetBookOldDerogatory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAssetBookTransactions</Name>
				<Source><![CDATA[
    private boolean processAssetBookTransactions(AssetBook _assetBookOld, AssetBook _assetBookNew)
    {
        AssetTrans                  assetTransOld;
        AssetTrans                  assetTransNew;
        TransactionReversalTrans    transactionReversalTrans;

        Voucher                     voucher;
        TransDate                   acquisitionDate;
        CurrentOperationsTax        postingLayer = _assetBookOld.currentOperationsTax();

        RecordSortedList recordSortedList = new RecordSortedList(tableNum(AssetTrans));
        recordSortedList.sortOrder(fieldNum(AssetTrans, RecId));

        while select assetTransOld
            where assetTransOld.AssetId == _assetBookOld.AssetId
               && assetTransOld.BookId  == _assetBookOld.BookId
        {
            recordSortedList.ins(assetTransOld);
        }

        for (boolean isRecordExist = recordSortedList.first(assetTransOld);
            isRecordExist;
            isRecordExist = recordSortedList.next(assetTransOld))
        {
            
            AssetTrans assetTransOldDerogatory = this.getAssetTransOldDerogatory(_assetBookOld, assetTransOld);

            if (assetTransOld.TransType == AssetTransType::AssetTransfer)
            {
                transferTransactionsExist = true;
                
                if (!transferredBooks.in(_assetBookNew.BookId))
                {
                    transferredBooks.add(_assetBookNew.BookId);
                }

                if (assetTransOldDerogatory.RecId
                    && !transferredBooks.in(assetBookNewDerogatory.BookId))
                {
                    transferredBooks.add(assetBookNewDerogatory.BookId);
                }
            }

            // new voucher number for each reclassified asset transaction
            voucher = NumberSeq::newGetVoucherFromCode(numberSequenceCode, NumberSeqScopeFactory::createDefaultScope(), false).voucher();
                        
            AssetTrans assetTransNewDerogatory;
            // Don't create a transfer transaction for the new asset because it is not
            // possible to identify the original transaction and the account from the
            // posting profile for a new asset.
            if (assetTransOld.TransType != AssetTransType::AssetTransfer)
            {
                // new asset transaction for the new asset
                assetTransNew = this.initAssetTransForNewAsset(assetTransOld, _assetBookNew, voucher);
                assetTransNew.insert();

                if (_assetBookOld.AssetDerogatoryModel_FR
                    && assetTransOldDerogatory.RecId)
                {
                    assetTransNewDerogatory = this.initAssetTransForNewAsset(assetTransOldDerogatory, assetBookNewDerogatory, voucher);
                    assetTransNewDerogatory.insert();
                }
            }

            // new asset transaction for the old asset with reversed amount
            this.initAssetTransForOldAsset(assetTransNew, assetTransOld, voucher);
            assetTransNew.insert();

            if (_assetBookOld.AssetDerogatoryModel_FR
                && assetTransOldDerogatory.RecId)
            {
                this.initAssetTransForOldAsset(assetTransNewDerogatory, assetTransOldDerogatory, voucher);
                assetTransNewDerogatory.insert();
            }

            if (_assetBookNew.assetBookTable().postToGeneralLedger())
            {
                RecordSortedList generalJournalAccountEntryList = this.selectLedgerTransactionsForAssetTransaction(assetTransOld, postingLayer);

                LedgerDimensionAccount accountNew = 0;

                // Can't define ledger account in case of asset transfers
                if (assetTransOld.TransType != AssetTransType::AssetTransfer)
                {
                    accountNew = LedgerDimensionFacade::serviceCreateLedgerDimension(
                    this.findNewAssetLedgerAccount(
                        _assetBookNew.BookId,
                        assetTransOld.TransType,
                        _assetBookNew.PostingProfile),
                    _assetBookNew.DefaultDimension);
                }

                this.postLedgerTransactions(
                generalJournalAccountEntryList,
                voucher,
                postingLayer,
                accountNew,
                _assetBookOld.exchangeRateDate(),
                assetTransOld.TransType == AssetTransType::AssetTransfer);
            }
        }

        return voucher != "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetTransOldDerogatory</Name>
				<Source><![CDATA[
    private AssetTrans getAssetTransOldDerogatory(AssetBook _assetBookOld, AssetTrans _assetTransOld)
    {
        AssetTrans assetTransOldDerogatory;

        if (_assetBookOld.AssetDerogatoryModel_FR)
        {
            select assetTransOldDerogatory
                where assetTransOldDerogatory.Voucher == _assetTransOld.Voucher
                    && assetTransOldDerogatory.TransDate == _assetTransOld.TransDate
                    && assetTransOldDerogatory.AssetId == _assetTransOld.AssetId
                    && assetTransOldDerogatory.BookId == _assetBookOld.AssetDerogatoryModel_FR
                    && assetTransOldDerogatory.TransType == _assetTransOld.TransType;
        }

        return assetTransOldDerogatory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetBookAfterTransactionsProcessed</Name>
				<Source><![CDATA[
    private void updateAssetBookAfterTransactionsProcessed(AssetBook _assetBookNew, AssetBook _assetBookOld)
    {
        _assetBookNew.AcquisitionDate  = reclassificationDate;
        if (_assetBookNew.LastDepreciationDate)
        {
            _assetBookNew.LastDepreciationDate = reclassificationDate;
        }
        if (_assetBookNew.LastDepreciationDateExtraOrd)
        {
            _assetBookNew.LastDepreciationDateExtraOrd = reclassificationDate;
        }

        _assetBookNew.AcquisitionPrice = AssetTrans::acquisitionAmount(
            _assetBookNew.AssetId,
            _assetBookNew.AcquisitionDate,
            _assetBookNew.BookId);

        // If the provision type of the new value model is filled,
        // it is emptied and a message is displayed
        if (_assetBookNew.ReserveTypeId)
        {
            _assetBookNew.ReserveTypeId = '';
            info(strFmt("@FixedAssets:FA_MessageNotification_AssignProvisionType", _assetBookNew.AssetId, _assetBookNew.BookId));
        }

        _assetBookNew.insert();

        this.updateOldValueModel(_assetBookOld);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOldValueModel</Name>
				<Source><![CDATA[
    private void updateOldValueModel(AssetBook _assetBookOld)
    {
        _assetBookOld.Status = AssetStatus::Closed;
        _assetBookOld.AcquisitionPrice = AssetTrans::acquisitionAmount(
                _assetBookOld.AssetId,
                reclassificationDate,
                _assetBookOld.BookId);

        _assetBookOld.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAssetBookTransferTransactions</Name>
				<Source><![CDATA[
    private void processAssetBookTransferTransactions()
    {
        SetEnumerator transferredBooksEnumerator = transferredBooks.getEnumerator();

        while (transferredBooksEnumerator.moveNext())
        {
            AssetBook assetBook;
            select forupdate assetBook
                where assetBook.AssetId == newAssetId
                    && assetBook.BookId == transferredBooksEnumerator.current();

            DimensionDefault toDimension = assetBook.DefaultDimension;

            this.cleanUpDefaultDimension(assetBook);
            this.postingAssetBookTransferTransactions(assetBook, toDimension);
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpDefaultDimension</Name>
				<Source><![CDATA[
    private void cleanUpDefaultDimension(AssetBook _assetBookNew)
    {
        _assetBookNew.DefaultDimension = 0;
        _assetBookNew.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingAssetBookTransferTransactions</Name>
				<Source><![CDATA[
    private void postingAssetBookTransferTransactions(AssetBook _assetBookNew, DimensionDefault _toDimension)
    {
        RecordSortedList recordSortedList = new RecordSortedList(tableNum(AssetBook));
        recordSortedList.sortOrder(fieldNum(AssetBook, RecId));
        recordSortedList.ins(_assetBookNew);

        AssetTransfer assetTransfer = AssetTransfer::construct();
        assetTransfer.transferAsset(recordSortedList, _toDimension, reclassificationDate, '@SYS75424');
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAssetTransForNewAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>AssetTrans</c> table for new asset.
    /// </summary>
    /// <param name = "_assetTransOld">
    /// The table <c>AssetTrans</c> buffer.
    /// </param>
    /// <param name = "_assetBookNew">
    /// The table <c>AssetBook</c> buffer.
    /// </param>
    /// <param name = "_voucher">
    /// Voucher number for the asset transaction.
    /// </param>
    /// <returns>
    /// The initialized <c>AssetTrans</c> table buffer.
    /// </returns>
    protected AssetTrans initAssetTransForNewAsset(
        AssetTrans _assetTransOld,
        AssetBook _assetBookNew,
        Voucher _voucher)
    {
        AssetTrans assetTrans;
        buf2Buf(_assetTransOld, assetTrans);
        assetTrans.AssetId = _assetBookNew.AssetId;
        assetTrans.AssetGroup = _assetBookNew.AssetGroup;
        assetTrans.Voucher = _voucher;
        assetTrans.TransDate = reclassificationDate;
        assetTrans.Txt = strFmt("@SYS79505", oldAssetId);
        assetTrans.DefaultDimension = _assetBookNew.DefaultDimension;

        if (assetTrans.TransType == AssetTransType::Acquisition
            || assetTrans.TransType == AssetTransType::AcquisitionAdj
            || countryRegion_DEAT)
        {
            assetTrans.Reclassification = NoYes::Yes;
        }

        if (assetTrans.AssetGroup != _assetTransOld.AssetGroup)
        {
            if (_assetBookNew.assetBookTable().postToGeneralLedger()
                && !_assetBookNew.IsDerogatoryBook_FR)
            {
                assetTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                this.findNewAssetLedgerAccount(
                    assetTrans.BookId,
                    assetTrans.TransType,
                    assetTrans.PostingProfile),
                    assetTrans.DefaultDimension);
            }
            else
            {
                assetTrans.LedgerDimension = 0;
            }
        }

        return assetTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAssetTransForOldAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>AssetTrans</c> table for old asset.
    /// </summary>
    /// <param name = "_assetTrans">
    /// The table <c>AssetTrans</c> buffer.
    /// </param>
    /// <param name = "_assetTransOld">
    /// The table <c>AssetTrans</c> buffer.
    /// </param>
    /// <param name = "_voucher">
    /// Voucher number for the asset transaction.
    /// </param>
    protected void initAssetTransForOldAsset(
        AssetTrans _assetTrans,
        AssetTrans _assetTransOld,
        Voucher _voucher)
    {
        buf2Buf(_assetTransOld, _assetTrans);
        _assetTrans.Voucher = _voucher;
        _assetTrans.TransDate = reclassificationDate;
        _assetTrans.Txt = strFmt("@SYS79506", newAssetId);
        _assetTrans.AmountMST = -_assetTrans.AmountMST;
        _assetTrans.AmountCur = -_assetTrans.AmountCur;
        _assetTrans.ReportingCurrencyAmount = -_assetTrans.ReportingCurrencyAmount;

        if (_assetTrans.TransType == AssetTransType::Acquisition
            || _assetTrans.TransType == AssetTransType::AcquisitionAdj)
        {
            _assetTrans.Reclassification = NoYes::Yes;
        }

        if (countryRegion_DEAT)
        {
            _assetTrans.InterestAmount = -_assetTrans.InterestAmount;
            _assetTrans.Reclassification = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectLedgerTransactionsForAssetTransaction</Name>
				<Source><![CDATA[
    private RecordSortedList selectLedgerTransactionsForAssetTransaction(AssetTrans _assetTransOld, CurrentOperationsTax _postingLayer)
    {
        RecordSortedList generalJournalAccountEntryList = new RecordSortedList(tableNum(GeneralJournalAccountEntry));
        generalJournalAccountEntryList.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));
        
        generalJournalAccountEntryList = this.getFixedAssetRelatedGeneralJournalEntries(
                _assetTransOld,
                _postingLayer,
                generalJournalAccountEntryList);

        if (generalJournalAccountEntryList.len() == 0)
        {
            return generalJournalAccountEntryList;
        }

        // Transfers should be processed separately because we only need to reverse such transactions.
        // Balance of transfer ledger transactions found should be 0.
        if (_assetTransOld.TransType != AssetTransType::AssetTransfer)
        {
            if (amountLedgerTransactionsSum != _assetTransOld.AmountMST)
            {
                GeneralJournalAccountEntry generalJournalAccountEntry;

                // find the transaction with the closest amount and update amounts in it
                AmountMST amountDiff = amountLedgerTransactionsMax;
                generalJournalAccountEntry generalJournalAccountEntryClosest;

                for (boolean recordExists = generalJournalAccountEntryList.first(generalJournalAccountEntry);
                recordExists;
                recordExists = generalJournalAccountEntryList.next(generalJournalAccountEntry))
                {
                    if (generalJournalAccountEntryClosestRecIds && sign(generalJournalAccountEntry.AccountingCurrencyAmount) == sign(_assetTransOld.AmountMST) &&
                            amountDiff >= abs(_assetTransOld.AmountMST - generalJournalAccountEntry.AccountingCurrencyAmount) &&
                            conFind(generalJournalAccountEntryClosestRecIds,generalJournalAccountEntry.RecId) == 0)
                    {
                        amountDiff = abs(_assetTransOld.AmountMST - generalJournalAccountEntry.AccountingCurrencyAmount);
                        generalJournalAccountEntryClosest.data(generalJournalAccountEntry);
                    }
                    else
                    {
                        if (sign(generalJournalAccountEntry.AccountingCurrencyAmount) == sign(_assetTransOld.AmountMST) &&
                                amountDiff >= abs(_assetTransOld.AmountMST - generalJournalAccountEntry.AccountingCurrencyAmount))
                        {
                            amountDiff = abs(_assetTransOld.AmountMST - generalJournalAccountEntry.AccountingCurrencyAmount);
                            generalJournalAccountEntryClosest.data(generalJournalAccountEntry);
                        }
                    }
                }
                generalJournalAccountEntryClosestRecIds += generalJournalAccountEntryClosest.RecId;
                generalJournalAccountEntryList = new RecordSortedList(tableNum(generalJournalAccountEntry));
                if (generalJournalAccountEntryClosest)
                {
                    if (amountDiff)
                    {
                        generalJournalAccountEntryClosest.TransactionCurrencyAmount = _assetTransOld.AmountCur;
                        generalJournalAccountEntryClosest.AccountingCurrencyAmount = _assetTransOld.AmountMST;
                        generalJournalAccountEntryClosest.ReportingCurrencyAmount = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::current(),
                            reclassificationDate)
                                .calculateTransactionCurrencyToReportingCurrency(
                                    _assetTransOld.CurrencyCode,
                                    _assetTransOld.AmountCur);
                    }
                    generalJournalAccountEntryList.ins(generalJournalAccountEntryClosest);
                }
            }
        }
        else
        {
            // Asset transfer transactions should have 0 balance for asset accounts
            Debug::assert(amountLedgerTransactionsSum == 0);
        }

        return generalJournalAccountEntryList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFixedAssetRelatedGeneralJournalEntries</Name>
				<Source><![CDATA[
    /// <summary>
    ///  The selected ledger transaction of asset will be inserted to RecordSortedlist of <c>GeneralJournalAccountEntry</c>.
    /// </summary>
    /// <param name = "_assetTransOld">The table <c>AssetTrans</c> buffer.</param>
    /// <param name = "_postingLayer">The posting layer value.</param>
    /// <param name = "_generalJournalAccountEntryList">The record sorted list of <c>GeneralJournalAccountEntry</c> table.</param>
    /// <returns>returns the record sorted list of <c>GeneralJournalAccountEntry</c></returns>
    protected RecordSortedList getFixedAssetRelatedGeneralJournalEntries(
        AssetTrans _assetTransOld,
        CurrentOperationsTax _postingLayer,
        RecordSortedList _generalJournalAccountEntryList)
    {
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        // select ledger transactions from the asset side, which belongs to the asset transaction
        // create new and new/reversing ledger transactions
        while select generalJournalAccountEntry
                where (generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                   || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsCredit
                   // These types are used for transactions orginated from AP.
                   || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump
                   || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense)
                   && generalJournalAccountEntry.LedgerDimension == _assetTransOld.LedgerDimension
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                   && subledgerVoucherGeneralJournalEntry.Voucher == _assetTransOld.Voucher
                   && subledgerVoucherGeneralJournalEntry.AccountingDate == _assetTransOld.TransDate
                   && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _assetTransOld.DataAreaId
            exists join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                   && generalJournalEntry.Ledger == Ledger::current()
                   && generalJournalEntry.PostingLayer == _postingLayer
        {
            [amountLedgerTransactionsSum, amountLedgerTransactionsMax] = this.processGeneralJournalAccountEntryRecord(
                    amountLedgerTransactionsSum,
                    amountLedgerTransactionsMax,
                    _generalJournalAccountEntryList,
                    generalJournalAccountEntry);
        }
        if (_generalJournalAccountEntryList.len() == 0)
        {
            while select generalJournalAccountEntry
                where (generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsCredit
                    // These types are used for transactions orginated from AP.
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense)
                exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                    && subledgerVoucherGeneralJournalEntry.Voucher == _assetTransOld.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == _assetTransOld.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _assetTransOld.DataAreaId
                exists join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.PostingLayer == _postingLayer
            {
                [amountLedgerTransactionsSum, amountLedgerTransactionsMax] = this.processGeneralJournalAccountEntryRecord(
                        amountLedgerTransactionsSum,
                        amountLedgerTransactionsMax,
                        _generalJournalAccountEntryList,
                        generalJournalAccountEntry);
            }
        }
        return _generalJournalAccountEntryList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLedgerTransactions</Name>
				<Source><![CDATA[
    private void postLedgerTransactions(
        RecordSortedList        _generalJournalAccountEntryList,
        Voucher                 _voucher,
        CurrentOperationsTax    _postingLayer,
        LedgerDimensionAccount  _accountNew,
        TransDate               _acquisitionDate,
        boolean                 _postReversalsOnly = false)
    {
        if (ledgerPostingJournal == null)
        {
            // multiple reference numbers can be included in one ledger posting journal
            ledgerPostingJournal = LedgerVoucher::newLedgerPost(
                DetailSummary::Detail,
                SysModule::Ledger,
                numberSequenceCode);

            ledgerPostingController.setJournal(ledgerPostingJournal);
        }

        LedgerVoucherObject ledgerPostingReference = LedgerVoucherObject::newReference(_voucher, reclassificationDate, SysModule::Ledger);
        ledgerPostingReference.parmPostingLayer(_postingLayer);

        ledgerPostingController.addReference(ledgerPostingReference);

        // <GEERU>
        LedgerBondClient_RU ledgerBondClient = ledgerPostingReference.ledgerBondClient_RU();
        // </GEERU>

        GeneralJournalAccountEntry  generalJournalAccountEntry;

        int len = _generalJournalAccountEntryList.len();

        for (boolean recordExists = _generalJournalAccountEntryList.first(generalJournalAccountEntry);
        recordExists;
        recordExists = _generalJournalAccountEntryList.next(generalJournalAccountEntry))
        {
            LedgerVoucherTransObject    ledgerPostingTransaction;
            LedgerEntry ledgerEntry = LedgerEntry::findByGeneralJournalAccountEntry(generalJournalAccountEntry.RecId);

            // Don't create a transfer transaction for the new asset because it is not
            // possible to identify the original transaction and the account from the
            // posting profile for a new asset.
            if (!_postReversalsOnly)
            {
                // new ledger transaction for the new asset
                ledgerPostingTransaction = LedgerVoucherTransObject::newGeneralJournal(
                        generalJournalAccountEntry,
                        ledgerEntry);

                // clear so the LPF knows we aren't doing a custom transfer level
                ledgerPostingTransaction.parmCustomTransferLevel(0);

                ledgerPostingTransaction.parmText(strFmt("@SYS79505", oldAssetId));
                ledgerPostingTransaction.parmLedgerDimensionId(_accountNew);

                ledgerPostingTransaction.parmHistoricalExchangeRateDate(reclassificationDate);

                ledgerPostingController.addTrans(ledgerPostingTransaction);
            }

            // new ledger transaction for the old asset with reversed amount
            ledgerPostingTransaction = LedgerVoucherTransObject::newGeneralJournal(
                        generalJournalAccountEntry,
                        ledgerEntry);

            // clear so the LPF knows we aren't doing a custom transfer level
            ledgerPostingTransaction.parmCustomTransferLevel(0);

            ledgerPostingTransaction.parmText(strFmt("@SYS79506", newAssetId));
            ledgerPostingTransaction.invertAmounts();

            if (_acquisitionDate)
            {
                ledgerPostingTransaction.parmHistoricalExchangeRateDate(_acquisitionDate);
            }
            else
            {
                ledgerPostingTransaction.parmHistoricalExchangeRateDate(reclassificationDate);
            }

            ledgerPostingTransaction.parmSkipDimensionValidation(true);
            ledgerPostingController.addTrans(ledgerPostingTransaction);

            // <GEERU>
            if (ledgerBondClient)
            {
                ledgerBondClient.bondLast2();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUsedAssetId</Name>
				<Source><![CDATA[
    private void markUsedAssetId()
    {
        if (assetIdNumberSeq && allocatedAssetId)
        {
            assetIdNumberSeq.onNumberUsed(newAssetId, allocatedAssetId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        AssetTable                  assetTable;
        AssetTable                  assetTableNew;
        #OCCRetryCount

        try
        {
            this.checkAssetLedgerAccounts();

            ttsbegin;

            // new asset
            assetTable = AssetTable::find(oldAssetId);
            assetTableNew.data(assetTable);
            assetTableNew.AssetId    = newAssetId;
            assetTableNew.AssetGroup = newAssetGroupId;
            assetTableNew.insert(true);

            this.markUsedAssetId();

            // Process value model reclassification
            this.processValueModels(assetTable.AssetId, assetTableNew);

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                this.abortNewAssetId();
                throw Exception::Deadlock;
            }
            else
            {
                this.initNewAssetId();
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    this.abortNewAssetId();
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // If appears that when the exception is thrown the status in NumberSequenceList
                    // is changed to free (0). Need to call initNewAssetId, which with set the status
                    // in NumberSequenceList to active (1).
                    this.initNewAssetId();
                    retry;
                }
            }
            else
            {
                this.abortNewAssetId();
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            this.abortNewAssetId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the asset recclassification.
    /// </summary>
    /// <param name="_calledFrom">
    /// Default 'null'.
    /// </param>
    /// <returns>
    /// Returns 'True' if check succeed.
    /// </returns>
    public boolean validate(Object _calledFrom = null)
    {
        boolean     ret = true;

        // <GIN>
        AssetGroupInformation_IN    assetInformationLoc;
        // </GIN>

        if (!oldAssetGroupId)
        {
            ret = checkFailed(strFmt("@SYS26332", "@SYS67417"));
        }
        else
        {
            if (!AssetGroup::exist(oldAssetGroupId))
            {
                ret = checkFailed(strFmt("@SYS71124",oldAssetGroupId));
            }
        }

        if (!oldAssetId)
        {
            ret = checkFailed(strFmt("@SYS26332", "@SYS67376"));
        }
        else
        {
            if (!AssetTable::exist(oldAssetId))
            {
                ret = checkFailed(strFmt("@SYS67413",oldAssetId));
            }
        }

        if (!newAssetGroupId)
        {
            ret = checkFailed(strFmt("@SYS26332", "@SYS78867"));
        }
        else
        {
            if (!AssetGroup::exist(newAssetGroupId))
            {
                ret = checkFailed(strFmt("@SYS71124",newAssetGroupId));
            }
        }

        if (!newAssetId)
        {
            ret = checkFailed(strFmt("@SYS26332", "@SYS67468"));
        }
        else
        {
            if (AssetTable::exist(newAssetId))
            {
                ret = checkFailed(strFmt("@SYS67761",newAssetId));
            }
        }

        if (!reclassificationDate)
        {
            ret = checkFailed(strFmt("@SYS26332", "@SYS78868"));
        }

        AssetBook assetBook;

        select maxof(AcquisitionDate) from assetBook
            where assetBook.AssetId == oldAssetId;

        if (assetBook.AcquisitionDate > reclassificationDate)
        {
            ret = checkFailed("@FixedAssets:FA_ErrorMessage_InvalidReclassificationDateRange");
        }

        if (!numberSequenceCode)
        {
            ret = checkFailed(strFmt("@SYS26332", "@SYS22059"));
        }

        // <GIN>
        if (AssetParameters::isDepreciationIncomeTaxActEnable_IN())
        {
            select assetInformationLoc
                where (assetInformationLoc.AssetGroup   == oldAssetGroupId
                ||  assetInformationLoc.AssetGroup   == newAssetGroupId)
                &&  assetInformationLoc.TransType    == AssetTransType::Depreciation;

            if (assetInformationLoc)
            {
                ret = checkFailed("@GLS5980");
            }
        }
        // </GIN>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS75424";
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryNumberSequenceCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a query for the number sequence related to the asset journal.
    /// </summary>
    /// <returns>
    /// A <c>Query</c> instance for the number sequence related to the asset journal.
    /// </returns>
    public static Query queryNumberSequenceCode()
    {
        Query                   query = new Query();
        QueryBuildDataSource    qB;
        QueryBuildDataSource    qb2;

        qB  = query.addDataSource(tableNum(NumberSequenceTable));
        qb2 = qB.addDataSource(tableNum(LedgerJournalName));
        qb2.addLink(fieldNum(NumberSequenceTable, RecId), fieldNum(LedgerJournalName, NumberSequenceTable));
        qb2.addRange(fieldNum(LedgerJournalName,JournalType)).value(enum2Value(LedgerJournalType::Assets));
        qb2.joinMode(JoinMode::ExistsJoin);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupNumberSequenceCode</Name>
				<Source><![CDATA[
    public static void lookupNumberSequenceCode(FormStringControl   _ctrl)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(NumberSequenceTable),_ctrl);

        sysTableLookup.addLookupfield(fieldNum(NumberSequenceTable,NumberSequence));
        sysTableLookup.addLookupfield(fieldNum(NumberSequenceTable,Txt));
        sysTableLookup.parmQuery(AssetReclassification::queryNumberSequenceCode());
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryOldAssetId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a query for the original asset, asset group, and value model.
    /// </summary>
    /// <param name = "_assetGroupId">The old or original asset group.</param>
    /// <returns>
    /// A <c>Query</c> instance for the original asset, asset group, and value model.
    /// </returns>
    public static Query queryOldAssetId(AssetGroupId _assetGroupId)
    {
        Query                   query = new Query();
        QueryBuildDataSource    qB;
        QueryBuildDataSource    qb2;

        qB  = query.addDataSource(tableNum(AssetTable));
        if (_assetGroupId)
        {
            qB.addRange(fieldNum(AssetTable,AssetGroup)).value(_assetGroupId);
        }

        qb2 = qB.addDataSource(tableNum(AssetBook));
        qb2.addLink(fieldNum(AssetTable,AssetId),fieldNum(AssetBook,AssetId));
        qb2.addRange(fieldNum(AssetBook,Status)).value(enum2Value(AssetStatus::Open));
        qb2.joinMode(JoinMode::ExistsJoin);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupOldAssetId</Name>
				<Source><![CDATA[
    public static void lookupOldAssetId(FormStringControl _ctrl, AssetGroupId _assetGroupId)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(AssetTable), _ctrl);

        sysTableLookup.addLookupfield(fieldNum(AssetTable,AssetId));
        sysTableLookup.addLookupfield(fieldNum(AssetTable,Name));
        sysTableLookup.addLookupfield(fieldNum(AssetTable,AssetGroup));

        sysTableLookup.parmQuery(AssetReclassification::queryOldAssetId(_assetGroupId));
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        AssetReclassification  assetReclassification = new AssetReclassification();

        if (assetReclassification.prompt())
        {
            assetReclassification.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container assetIdNumberSeqcontainer = assetIdNumberSeq ? assetIdNumberSeq.pack() : connull();
 
        // Pack all class fields. assetIdNumberSeq must be packed because it is created on the client version of the class and
        // must be moved back across to the server tier.
        return [CurrentVersion,
                [oldAssetGroupId,
                oldAssetId,
                newAssetGroupId,
                newAssetId,
                reclassificationDate,
                numberSequenceCode,
                assetIdNumberSeqcontainer,
                allocatedAssetId]];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer version = conPeek(_packedClass, 1);
        container packedValues, packedAssetIdNumberSequence;

        switch (version)
        {
            case CurrentVersion:
                // Extract the version and values from the packed class.
                [version, packedValues] = _packedClass;

                [oldAssetGroupId,
                oldAssetId,
                newAssetGroupId,
                newAssetId,
                reclassificationDate,
                numberSequenceCode,
                packedAssetIdNumberSequence,
                allocatedAssetId] = packedValues;
                break;

            case Version1:
                [version, packedValues] = _packedClass;

                [oldAssetGroupId,
                oldAssetId,
                newAssetGroupId,
                newAssetId,
                reclassificationDate,
                numberSequenceCode,
                packedAssetIdNumberSequence] = packedValues;
                break;

            default :
                return false;
        }

        if (packedAssetIdNumberSequence)
        {
            // Restore the instance of AssetIdNumberSeq, so that it can be moved across tiers.
            assetIdNumberSeq = NumberSeq::create(packedAssetIdNumberSequence);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overriden base class method to avoid saving last values.
    /// </summary>
    public void saveLast()
    {
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overriden base class method to avoid restoring last values.
    /// </summary>
    public void getLast()
    {
        getLastCalled   = true;
        inGetSaveLast   = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processGeneralJournalAccountEntryRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Calculates the maximum and total accounting currency amount.
    /// </summary>
    /// <param name = "_amountLedgerTransactionsSum">total accounting currency amount.</param>
    /// <param name = "_amountLedgerTransactionsMax">Maximum accounting currency amount.</param>
    /// <param name = "_generalJournalAccountEntryList">The record insert list of <c>GeneralJournalAccountEntry</c> table.</param>
    /// <param name = "_generalJournalAccountEntry">The <c>GeneralJournalAccountEntry</c> table.</param>
    /// <returns> Returns maximum and total accounting currency amount.</returns>
    protected container  processGeneralJournalAccountEntryRecord(
            AmountMST _amountLedgerTransactionsSum, 
            AmountMST _amountLedgerTransactionsMax, 
            RecordSortedList _generalJournalAccountEntryList, 
            GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        _generalJournalAccountEntryList.ins(_generalJournalAccountEntry);

        _amountLedgerTransactionsSum += _generalJournalAccountEntry.AccountingCurrencyAmount;

        if (abs(_generalJournalAccountEntry.AccountingCurrencyAmount) > _amountLedgerTransactionsMax)
        {
            _amountLedgerTransactionsMax = abs(_generalJournalAccountEntry.AccountingCurrencyAmount);
        }
        return [_amountLedgerTransactionsSum, _amountLedgerTransactionsMax];
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>