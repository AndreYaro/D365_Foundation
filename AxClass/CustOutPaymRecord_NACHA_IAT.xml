<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustOutPaymRecord_NACHA_IAT</Name>
	<SourceCode>
		<Declaration><![CDATA[
class CustOutPaymRecord_NACHA_IAT extends CustOutPaymRecord_NACHA
{
    //***** NACHA IAT Record Layout *****
    //
    //      Field                          Offset     Value
    //--    ------------------------------- -------  -----------
    //01    recordTypeCode                  01 - 01   6
    //02    transactionCode                 02 - 03   22
    //03    receivingDFI_Identification     04 - 11
    //04    checkDigit                      12 - 12
    //05    addendaRecord                   13 - 16
    //06    reserved                        17 - 29
    //07    amount                          30 - 39
    //08    foreignReceiverAccountNumber    40 - 74
    //09    reservedSecond                  75 - 76
    //10    gatewayOperatorIndicator        77 - 77
    //11    secondryOFACIndicatorOffset     78 - 78
    //12    addendaRecordIndicator          79 - 79 1 (One)
    //13    traceNumber                     80 - 94


    //Offsets:
    #define.addendaRecordOffset(13)
    #define.reservedOffset(17)
    #define.amountOffset(30)
    #define.foreignReceiverAccountNumberOffset(40)
    #define.reservedSecondOffset(75)
    #define.gatewayOperatorIndicatorOffset(77)
    #define.secondryOFACIndicatorOffset(78)
    #define.addendaRecordIndicatorOffset(79)

    //Field Lengths:
    #define.addendaLength(4)
    #define.reservedLength(13)
    #define.foreignReceiverAccountNumberLength(35)
    #define.reservedSecondlength(2)
    #define.gatewayOperatorIndicatorLength(1)
    #define.secondryOFACIndicatorLenth(1)
    #define.traceNumAddendaLenth(7)
    #define.traceLenth(15)

    container               nacha_iat_Record;
    CompanyInfo             companyInfo;
    CustTable               custTable;
    int                     noAddendaRecord;
    str #traceLenth         traceNumber;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addIATFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds debug field information to the output file.
    /// </summary>
    private void addIATFieldPositions()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCDEEEEFFFFFFFFFFFFFGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHIIJKLMMMMMMMMMMMMMMM - iAT PAYABLES RECORD')
        #define.iATTraceNumber                      ('                                                                               MMMMMMMMMMMMMMM - Trace Number [Journal ID + Line Number]')
        #define.iATAddendaIndicator                 ('                                                                              L - Addenda Record Indicator = "0"')
        #define.iATSecondryOFACIndicator            ('                                                                             K - SECONDARY OFAC SCREENING INDICATOR')
        #define.iATGatewayOperatorIndicator         ('                                                                            J - GATEWAY OPERATOR OFAC SCREENING INDICATOR')
        #define.iATreservedSecond                   ('                                                                          II - IAT reseved ')
        #define.iATforeignReceiverAccountNumber     ('                                       HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH -foreign receiver account number/DFI acount number]')
        #define.iATAmount                           ('                             GGGGGGGGGG - Amount [$$$$$$$$cc]')
        #define.iATreserved                         ('                FFFFFFFFFFFFF - IAT reseved ')
        #define.iATaddenda                          ('            EEEE - Number of Addenda record')
        #define.iATCheckDigit                       ('           D - Check Digit')
        #define.iATreceivingDFI_Identification      ('   CCCCCCCC - Receiving DFI Identification')
        #define.iATTransactionCode                  (' BB - Transaction Code = "27" for AR Checking, "37" for AR Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "6"')

        file.write(#iATRecordLayout);
        file.write(#iATTraceNumber);
        file.write(#iATAddendaIndicator);
        file.write(#iATSecondryOFACIndicator);
        file.write(#iATGatewayOperatorIndicator);
        file.write(#iATreservedSecond);
        file.write(#iATforeignReceiverAccountNumber);
        file.write(#iATAmount);
        file.write(#iATreserved);
        file.write(#iATaddenda);
        file.write(#iATCheckDigit);
        file.write(#iATreceivingDFI_Identification);
        file.write(#iATTransactionCode);
        file.write(#iATRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks for mandatory field values.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> transaction buffer.
    /// </param>
    /// <param name="_progress">
    ///    A <c>RunbaseProgress</c> object. Not used in this method.
    /// </param>
    /// <returns>
    ///    true if validation is successful; otherwise, false.
    /// </returns>

    public boolean checkValues(LedgerJournalTrans  _ledgerJournalTrans = null,
                               RunbaseProgress     _progress           = null)

    {
        boolean ok = true;
        #ISOCountryRegionCodes

        if (CustPaymMethodVal::exist(_ledgerJournalTrans.PaymMode, CustPaymentValidate::PaymReference)
            && !_ledgerJournalTrans.PaymReference)
        {
            ok = checkFailed("@SYS24523");
        }

        if (ok)
        {
            // Only transactions with Credit Amounts can be used from Accounts Receivable
            if (custVendPaym.paymAmountInSendersCurrency() >= 0)
            {
                // Payment must be a credit amount greater than zero.
                ok = checkFailed(strFmt("@SYS98766", custVendPaym.ledgerJournalTrans().parmAccount()));
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                custBankAccount = CustBankAccount::find(custVendPaym.ledgerJournalTrans().parmAccount(),
                                        CustTable::find(custVendPaym.ledgerJournalTrans().parmAccount()).BankAccount);
                if (!custBankAccount)
                {
                    // A bank account has not been setup for the customer '%1'.
                    ok = checkFailed(strFmt("@SYS98117", custVendPaym.ledgerJournalTrans().parmAccount()));
                }
                else
                {
                    unchecked (Uncheck::TableSecurityPermission)
                    {
                        if (!custBankAccount.AccountNum)
                        {
                            // Bank account number on account '%1' for customer '%2' is missing.
                            ok = checkFailed(strFmt("@SYS98697", custBankAccount.AccountID,
                                        custVendPaym.ledgerJournalTrans().parmAccount()));
                        }
                    }

                    if (SysCountryRegionCode::isLocationInCountryRegion(custBankAccount.Location, [#isoUS]))
                    {
                        // "Method of payment - %1: Export format requires the bank account for vendor %2 to have a country/region that doesn’t have an ISO code of ‘US’."
                        ok = checkFailed(strFmt("@SYS330063", _ledgerJournalTrans.PaymMode, custVendPaym.ledgerJournalTrans().parmAccount()));
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correspondenceIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Fist Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The Fist Addenda record.
    /// </returns>

    container  correspondenceIATAddendaRecord()
    {
        container   correspondenceITAddendaRecord                =   conNull();

        #define.recTypeCode('7')
        #define.addendaCode('18')
        #define.zero('0')
        #define.spc(' ')
        #define.correspoBankNameLen(35)
        #define.correspoBankINumQualifierLen(2)
        #define.correspoBankIdentificationNumLen(34)
        #define.correspoBankBranchCountryCodeLen(3)
        #define.addendaSequenceNumLength(4)

                                                                                    // Offset          Hardcoded       Value
        str 1       recordTypeCode                  =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                     =   #AddendaCode;               // 02 - 03          18              The code to identify 1st IAT Addenda records is 10
        str 35      correspoBankName                =   strRep(#spc,35);            // 04 - 38
        str 2       correspoBankINumQualifier       =   strRep(#spc,2);             // 39 - 40
        str 34      correspoBankIdentificationNum   =   strRep(#spc,34);            // 41 - 74
        str 3       correspoBankBranchCountryCode   =   strRep(#spc,3);             // 75 - 77
        str 6       reserve                         =   strRep(#spc,6);             // 78 - 83          BLANK
        str 4       addendaSequenceNum              =   strRep(#zero,4);            // 84 - 87
        str 7       entryDetailseqNumber            =   strRep(#zero,7);            // 88 - 94

        correspoBankName                  =   strLFix(custBankAccount.Name,#correspoBankNameLen,#spc);
        correspoBankINumQualifier         =   strLFix(enum2str(custVendPaym.parmCustVendNACHAIATInfoTable().OriginatingDFIQualifier),#correspoBankINumQualifierLen,#spc);

        if (custVendPaym.parmCustVendNACHAIATInfoTable().OriginatingDFIQualifier == CustVendOriginatingDFIQualifier_US::One     ||
           custVendPaym.parmCustVendNACHAIATInfoTable().OriginatingDFIQualifier == CustVendOriginatingDFIQualifier_US::Two)
        {
            correspoBankIdentificationNum = strLFix(custBankAccount.RegistrationNum,#correspoBankIdentificationNumLen,#spc);
        }
        else
        {
            unchecked (Uncheck::TableSecurityPermission)
            {
                correspoBankIdentificationNum = strLFix(custBankAccount.BankIBAN,#correspoBankIdentificationNumLen,#spc);
            }
        }

        correspoBankBranchCountryCode     = strLFix(LogisticsLocationEntity::location2PostalAddress(custBankAccount.Location).CountryRegionId,
                                            #correspoBankBranchCountryCodeLen, #spc);
        addendaSequenceNum                = strRFix(int2str(custVendOutPaym.getAddendaSequence()), #addendaSequenceNumLength, #spc);
        entryDetailseqNumber              = this.entryDetailSequenceNumber();

        correspondenceITAddendaRecord     = conIns(correspondenceITAddendaRecord, 1, recordTypeCode + addendaCode + correspoBankName + correspoBankINumQualifier +
                                            correspoBankIdentificationNum  + correspoBankBranchCountryCode + reserve +addendaSequenceNum + entryDetailseqNumber );

        return correspondenceITAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correspondenceIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Print the Addenda record.
    /// </summary>
    void  correspondenceIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFGGGGGGHHHHIIIIIII - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       IIIIIII -Entry detail equence number')
        #define.iATAddendaSequenceNum               ('                                                                                   HHHH -Entry detail equence number')
        #define.iATreserved                         ('                                                                             GGGGGG - IAT reseved ')
        #define.iATCorrespoBankBranchCountryCode    ('                                                                          FFF -Receiving company name /Indivisual name')
        #define.iATCorrespoBankIdentificationNum    ('                                        EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE - RECEIVING DFI IDENTIFICATION')
        #define.iATCorrespoBankINumQualifier        ('                                      DD  RECEIVING DFI IDENTIFICATION NUMBER QUALIFIER')
        #define.iATCorrespoBankName                 ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC - RECEIVING DFI NAME')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "13" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "7"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATCorrespoBankBranchCountryCode);
        file.write(#iATCorrespoBankIdentificationNum);
        file.write(#iATCorrespoBankINumQualifier);
        file.write(#iATCorrespoBankName);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>entryDetailSequenceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the last seven digits of the original trace number.
    /// </summary>
    /// <returns>Last seven digits of the trace number.</returns>
    str 7 entryDetailSequenceNumber()
    {
        return subStr(traceNumber,strLen(traceNumber)-#traceNumAddendaLenth +1,#traceNumAddendaLenth);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fifthIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Fist Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The Fist Addenda record.
    /// </returns>
    container fifthIATAddendaRecord()
    {
        container   fifthITAddendaRecord                =   conNull();

        #define.recTypeCode('7')
        #define.AddendaCode('14')
        #define.zero('0')
        #define.spc(' ')
        #define.bankNameLength(35)
        #define.receivingDFIQualifierLength(2)
        #define.receivingDFIIdentificationLegth(34)
        #define.receivingDFIBranchLength(3)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03         14              The code to identify 1st IAT Addenda records is 10
        str 35      receivingDFIName            =   strRep(#spc,35);            // 04 - 38
        str 2       receivingDFIQualifier       =   strRep(#spc,2);             // 39 - 40
        str 34      receivingDFIIdentification  =   strRep(#spc,34);            // 41 - 74
        str 3       receivingDFIBranch          =   strRep(#spc,3);             // 75 - 77
        str 10      reserve                     =   strRep(#spc,10);            // 78 - 87        BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero,7);            // 88 - 94

        receivingDFIName        = strLFix(custVendPaym.recieversBankName(), #bankNameLength, #spc);
        receivingDFIQualifier   = strLFix(enum2str(custVendPaym.parmCustVendNACHAIATInfoTable().ReceivingDFIQualifier), #receivingDFIQualifierLength,#spc);

        if (custVendPaym.parmCustVendNACHAIATInfoTable().ReceivingDFIQualifier == CustVendReceivingDFIQualifier_US ::One ||
           custVendPaym.parmCustVendNACHAIATInfoTable().ReceivingDFIQualifier == CustVendReceivingDFIQualifier_US::Two)
        {
            receivingDFIIdentification = strLFix(custVendPaym.recieversBankRegistrationNumber(),
                                                #receivingDFIIdentificationLegth,
                                                #spc);
        }
        else
        {
            unchecked (Uncheck::TableSecurityPermission)
            {
                receivingDFIIdentification = strLFix(custBankAccount.BankIBAN,#receivingDFIIdentificationLegth,#spc);
            }
        }

        receivingDFIBranch      = strLFix(LogisticsLocationEntity::location2PostalAddress(custBankAccount.Location).CountryRegionId,
                                            #receivingDFIBranchLength,#spc);
        entryDetailseqNumber    = this.entryDetailSequenceNumber();

        fifthITAddendaRecord    = conIns(fifthITAddendaRecord, 1, recordTypeCode + addendaCode + receivingDFIName + receivingDFIQualifier +
                                  receivingDFIIdentification  + receivingDFIBranch + reserve + entryDetailseqNumber );

        return fifthITAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fifthIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    //
    /// <summary>
    ///    Writes field value and alignment information to the output file to aid in verifying the data.
    /// </summary>
    /// <remarks>
    ///   The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void fifthIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFGGGGGGHHHHHHH - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                     HHHHHHH -Entry detail equence number')
        #define.iATreserved                         ('                                                                           GGGGGGGGGG - IAT reseved ')
        #define.iATReceivingDFIBranch               ('                                                                        FFF -Receiving company name /Indivisual name')
        #define.iATReceivingDFIIdentification       ('                                      EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE - RECEIVING DFI IDENTIFICATION')
        #define.iATReceivingDFIQualifier            ('                                    DD  RECEIVING DFI IDENTIFICATION NUMBER QUALIFIER')
        #define.iATReceivingDFIName                 ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC - RECEIVING DFI NAME')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "13" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "7"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATReceivingDFIBranch);
        file.write(#iATReceivingDFIIdentification);
        file.write(#iATReceivingDFIQualifier);
        file.write(#iATReceivingDFIName);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField05</Name>
				<Source><![CDATA[
    //
    /// <summary>
    /// Fills number of addenda records
    /// </summary>
    protected void fillField05()
    {
        str 4 noOfAddendaRecords;
        #define.zero('0')

        noOfAddendaRecords = strRFix(int2str(noAddendaRecord), #addendaLength, #zero);
        this.strInsert(noOfAddendaRecords, #addendaRecordOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField06</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills blank spaces.
    /// </summary>

    protected void fillField06()
    {
        #define.spc('')
        str blankSpace;

        blankSpace = strRep(#spc, #reservedLength);
        this.strInsert(blankSpace, #reservedOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField07</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the amount.
    /// </summary>

    protected void fillField07()
    {
        transactionAmount = custVendPaym.paymAmountInSendersCurrency();
        this.strInsert(custVendOutPaym.num2StrNACHA(transactionAmount, 10), #amountOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField08</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the account number and DFI account number of the foreign receiver.
    /// </summary>
    protected void fillField08()
    {
        unchecked (Uncheck::TableSecurityPermission)
        {
            this.strInsert(subStr(custBankAccount.AccountNum, 1, #foreignReceiverAccountNumberLength), #foreignReceiverAccountNumberOffset);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField09</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills spaces.
    /// </summary>

    protected void fillField09()
    {
        #define.spc('')
        str blankSpace;

        blankSpace = strRep(#spc,#reservedSecondlength);
        this.strInsert(blankSpace,#reservedSecondOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField10</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the information about gateway operator OFAC indicator.
    /// </summary>

    protected void fillField10()
    {
        this.strInsert(subStr(enum2str(custVendPaym.parmCustVendNACHAIATInfoTable().GatewayOperatorOFACIndicator),
                             1, #gatewayOperatorIndicatorLength),#gatewayOperatorIndicatorOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField11</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the information about the secondary OFAC screening indicator.
    /// </summary>

    protected void fillField11()
    {
        this.strInsert(subStr(enum2str(custVendPaym.parmCustVendNACHAIATInfoTable().SecondaryOFACIndicator), 1, #secondryOFACIndicatorLenth),
                      #secondryOFACIndicatorOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillField12</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the information about the addenda record indicator, always 1.
    /// </summary>
    protected void fillField12()
    {
        #define.addendaIndicator('1')

        this.strInsert(#addendaIndicator, #addendaRecordIndicatorOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls each <c>fillFieldXX</c> method to populate the whole IAT payment record.
    /// </summary>
    protected void fillRecord()
    {
        this.fillField01();
        this.fillField02();
        this.fillField03();
        this.fillField04();
        this.fillField05();
        this.fillField06();
        this.fillField07();
        this.fillField08();
        this.fillField09();
        this.fillField10();
        this.fillField11();
        this.fillField12();
        this.fillField13();
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Fist Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The Fist Addenda record.
    /// </returns>
    container firstIATAddendaRecord()
    {
        container   firstAddendaRecord                =   conNull();

        #define.recTypeCode('7')
        #define.AddendaCode('10')
        #define.zero('0')
        #define.spc(' ')
        #define.foreignPaymentAmountLen(18)
        #define.receivingComppanyNameLength(35)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03         10              The code to identify 1st IAT Addenda records is 10
        str 3       transactionTypeCode         =   strRep(#spc,3);             // 04 - 06                         This field contains a three-character code used to identify the type of transaction.
        str 18      foreignPaymentAmount        =   strRep(#spc,18);            // 07 - 24                         trnsaactionAmount
        str 22      foreignTraceNumber          =   strRep(#spc,22);            // 25 - 46        BLANK
        str 35      receivingComppanyName       =   strRep(#spc,35);            // 47 - 81
        str 6       reserve                     =   strRep(#spc,6);             // 82 - 87        BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero,7);            // 88 - 94

        foreignPaymentAmount  = custVendOutPaym.num2StrNACHA(transactionAmount,#foreignPaymentAmountLen);
        receivingComppanyName = strLFix(custVendPaym.recieversCompanyName(),#receivingComppanyNameLength,#spc);
        entryDetailseqNumber  = this.entryDetailSequenceNumber();

        firstAddendaRecord = conIns(firstAddendaRecord, 1, recordTypeCode + addendaCode     +   transactionTypeCode     +
                             foreignPaymentAmount + foreignTraceNumber+  receivingComppanyName + reserve + entryDetailseqNumber );

        return firstAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes field value and alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    /// The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    /// <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void firstIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFGGGGGGHHHHHHH - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       HHHHHHH -Entry detail equence number')
        #define.iATreserved                         ('                                                                                 GGGGGG - IAT reseved ')
        #define.iATReceivingComppanyName            ('                                              FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF -Receiving company name /Indivisual name')
        #define.iAForeignTraceNumber                ('                        EEEEEEEEEEEEEEEEEEEEEE - Foreign trace number')
        #define.iAtForeignPaymentAmount             ('      DDDDDDDDDDDDDDDDDD -  Foreign payment amount')
        #define.iATtransactionTypeCode              ('   CCC - Transaction type code')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "22" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "6"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATReceivingComppanyName);
        file.write(#iAForeignTraceNumber);
        file.write(#iAtForeignPaymentAmount);
        file.write(#iATtransactionTypeCode);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fourthIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the fourth Addenda record to output file.
    /// </summary>
    /// <returns>
    ///    The fourth addenda record.
    /// </returns>
    container fourthIATAddendaRecord()
    {
        container   fourthITAddendaRecord                =   conNull();

        #define.recTypeCode('7')
        #define.AddendaCode('13')
        #define.zero('0')
        #define.spc(' ')
        #define.bankNameLength(35)
        #define.OriginatingDFIQualifierLength(2)
        #define.origDFIIdentificationLegth(34)
        #define.origDFIBranchLength(3)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03          13              The code to identify 1st IAT Addenda records is 10
        str 35      orignatorDFIName            =   strRep(#spc,35);            // 04 - 38
        str 2       origDFIIdentificationNum    =   strRep(#spc,2);             // 39 - 40
        str 34      origDFIIdentification       =   strRep(#spc,34);            // 41 - 74
        str 3       origDFIBranch               =   strRep(#spc,3);             // 75 - 77
        str 10      reserve                     =   strRep(#spc,10);            // 78 - 87          BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero,7);            // 88 - 94

        orignatorDFIName           =   strLFix(custVendPaym.sendersBankName(),#bankNameLength,#spc);
        origDFIIdentificationNum   =   strLFix(enum2str(custVendPaym.parmCustVendNACHAIATInfoTable().OriginatingDFIQualifier),#OriginatingDFIQualifierLength,#spc);

        if (custVendPaym.parmCustVendNACHAIATInfoTable().OriginatingDFIQualifier == CustVendOriginatingDFIQualifier_US::One    ||
           custVendPaym.parmCustVendNACHAIATInfoTable().OriginatingDFIQualifier == CustVendOriginatingDFIQualifier_US::Two)
        {
            origDFIIdentification = strLFix(custVendPaym.sendersBankRegistrationNumber(),#origDFIIdentificationLegth,#spc);
        }
        else
        {
            origDFIIdentification = strLFix(custVendPaym.bankAccountTable().iban,#origDFIIdentificationLegth,#spc);
        }
        origDFIBranch             = strLFix(custVendPaym.bankAccountTable().postalAddress().CountryRegionId, #origDFIBranchLength,#spc);
        entryDetailseqNumber      = this.entryDetailSequenceNumber();

        fourthITAddendaRecord     = conIns(fourthITAddendaRecord, 1, recordTypeCode + addendaCode + orignatorDFIName + origDFIIdentificationNum +
                                     origDFIIdentification  + origDFIBranch + reserve + entryDetailseqNumber );

        return fourthITAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fourthIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the field value and alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    /// The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    /// <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void fourthIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFGGGGGGGGGGHHHHHHH- iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       HHHHHHH -Entry detail equence number')
        #define.iATreserved                         ('                                                                             GGGGGGGGGG - IAT reseved ')
        #define.iATOrigDFIBranch                    ('                                                                          FFF -Receiving company name /Indivisual name')
        #define.iATOrigDFIIdentification            ('                                        EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE - ORIGINATINGDFI IDENTIFICATION')
        #define.iATOrigDFIIdentificationNum         ('                                      DD  ORIGINATING DFIIDENTIFICATION NUMBER')
        #define.iATOrignatorDFIName                 ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC - Bank name')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "13" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "7"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATOrigDFIBranch);
        file.write(#iATOrigDFIIdentification);
        file.write(#iATOrigDFIIdentificationNum);
        file.write(#iATOrignatorDFIName);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the IAT payment output record.
    /// </summary>
    protected void initRecord()
    {
        #define.blankRoutingNumber('0')
        #define.blank(' ')

        nacha_iat_Record    = conNull();
        bankRoutingNumber   = strRep(#blankRoutingNumber, 8);
        outputRecord        = strRep(#blank, 94);
        transactionAmount   = 0;
        noAddendaRecord     = 7;

        custBankAccount     = CustBankAccount::find(custVendPaym.ledgerJournalTrans().parmAccount(),
                                    CustTable::findByCompany(custVendPaym.ledgerJournalTrans().Company,
                                        custVendPaym.ledgerJournalTrans().parmAccount()).BankAccount);
        companyInfo         = CompanyInfo::find();
        custTable           = CustTable::find(custVendPaym.custVendTable().AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>output</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the information into the output file.
    /// </summary>
    public void output()
    {
        this.initRecord();
        this.fillRecord();

        custVendOutPaym.addIATDetailRecord(custVendPaym.ledgerJournalTrans().Voucher,
                                           bankRoutingNumber,
                                           transactionAmount,
                                           0,
                                           custVendPaym.parmCustVendNACHAIATInfoTable(),
                                           custVendPaym.custVendTable());

        nacha_iat_Record = conIns(nacha_iat_Record, 1, outputRecord);
        file.writeExp(nacha_iat_Record);
        if (custVendOutPaym.isDebug())
        {
            this.addIATFieldPositions();
        }
        this.printAddendaRecords();
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAddendaRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the field value and alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    /// The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    /// <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void printAddendaRecords()
    {
        file.writeExp(this.firstIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.firstIATAddendaRecordPosition();
        }
        file.writeExp(this.secondIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.secondIATAddendaRecordPosition();
        }
        file.writeExp(this.thirdIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.thirdIATAddendaRecordPosition();
        }
        file.writeExp(this.fourthIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.fourthIATAddendaRecordPosition();
        }
        file.writeExp(this.fifthIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.fifthIATAddendaRecordPosition();
        }
        file.writeExp(this.sixthIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.sixthIATAddendaRecordPosition();
        }
        file.writeExp(this.seventhIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.seventhIATAddendaRecordPosition();
        }
        file.writeExp(this.remittanceIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.remittanceIATAddendaRecordPosition();
        }
        file.writeExp(this.correspondenceIATAddendaRecord());
        if (custVendOutPaym.isDebug())
        {
            this.correspondenceIATAddendaRecordPosition();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>remittanceIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the remittance Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The remittance Addenda record.
    /// </returns>
    container remittanceIATAddendaRecord()
    {
        container   seventhITAddendaRecord                =   conNull();
        #define.addendaSequenceNumLength(4)

        #define.recTypeCode('7')
        #define.AddendaCode('17')
        #define.zero('0')
        #define.spc(' ')
        #define.paymentRelatedInformationLength(80)
        #define.receivingDFIBranchLength(3)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03         17              The code to identify 1st IAT Addenda records is 10
        str 80      paymentRelatedInformation   =   strRep(#spc,80);            // 04 - 83                         LedgerJournalTrans.Tran
        str 4       addendaSequenceNum          =   strRep(#zero,4);            // 84 - 87
        str 7       entryDetailseqNumber        =   strRep(#zero,7);            // 88 - 94

        paymentRelatedInformation    = strLFix(custVendPaym.ledgerJournalTrans().Txt ,#paymentRelatedInformationLength,#spc);
        entryDetailseqNumber         = this.entryDetailSequenceNumber();
        addendaSequenceNum           = strRFix(int2str(custVendOutPaym.getAddendaSequence()),#addendaSequenceNumLength,#spc);
        seventhITAddendaRecord       = conIns(seventhITAddendaRecord, 1, recordTypeCode + addendaCode + paymentRelatedInformation + addendaSequenceNum + entryDetailseqNumber );

        return seventhITAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remittanceIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    //
    /// <summary>
    ///    Writes field value and alignment information to the output file to aid in verifying the data.
    /// </summary>
    /// <remarks>
    ///   The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void remittanceIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEE - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       EEEEEEE -Entry detail equence number')
        #define.iATAddendaSequenceNum               ('                                                                                   DDDD   ADDENDA SEQUENCE NUMBER ')
        #define.iATPaymentRelatedInformation        ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC - PAYMENT RELATED INFROMATION')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "22" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "6"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATAddendaSequenceNum);
        file.write(#iATPaymentRelatedInformation);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>secondIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the second Addenda record to output file.
    /// </summary>
    /// <returns>
    ///    The second Addenda record.
    /// </returns>

    container secondIATAddendaRecord()
    {
        container   secondATAddendaRecord                =   conNull();

        #define.recTypeCode('7')
        #define.AddendaCode('11')
        #define.zero('0')
        #define.spc(' ')
        #define.orignatorNameLength(35)
        #define.orignatorAddress(35)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          5
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03         11              The code to identify 1st IAT Addenda records is 10
        str 35      orignatorName               =   strRep(#spc, 35);           // 04 - 38
        str 35      orignatorAddress            =   strRep(#spc, 35);           // 39 - 73
        str 14      reserve                     =   strRep(#spc, 14);           // 74 - 87         BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero, 7);           // 88 - 94

        orignatorName           = strLFix(custVendPaym.sendersCompanyName(), #orignatorNameLength, #spc);
        orignatorAddress        = strLFix(custVendPaym.textLine(companyInfo.postalAddress().Address,1), #orignatorAddress, #spc);
        entryDetailseqNumber    = this.entryDetailSequenceNumber();

        secondATAddendaRecord   = conIns(secondATAddendaRecord, 1, recordTypeCode + addendaCode + orignatorName +
                                         orignatorAddress  + reserve + entryDetailseqNumber );

        return secondATAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>secondIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    //
    /// <summary>
    ///    Writes field value and alignment information to the output file to aid in verifying the data.
    /// </summary>
    /// <remarks>
    ///   The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void secondIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEFFFFFFF - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       FFFFFFF -Entry detail equence number')
        #define.iATreserved                         ('                                                                         EEEEEEEEEEEEEE - IAT reseved ')
        #define.iATOrignatorAddress                 ('                                      DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD -  Orignator address')
        #define.iATOrignatorName                    ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC -Orignator name')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "11" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "7"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATOrignatorAddress);
        file.write(#iATOrignatorName);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>seventhIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the seventh Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The seventh Addenda record.
    /// </returns>
    container seventhIATAddendaRecord()
    {
        container seventhITAddendaRecord = conNull();
        LogisticsPostalAddress custLogisticsPostalAddress;

        #define.recTypeCode('7')
        #define.AddendaCode('16')
        #define.zero('0')
        #define.spc(' ')
        #define.receiverCityStateLength(35)
        #define.receiverCountryIdLegth(35)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03         16              The code to identify 1st IAT Addenda records is 10
        str 35      receiverCityState           =   strRep(#spc,35);            // 04 - 18
        str 35      receiverCountryId           =   strRep(#spc,35);            // 19 - 53
        str 14      reserve                     =   strRep(#spc,14);            // 54 - 87        BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero,7);            // 88 - 94
        str 1       slash                       =   #spc;

        custLogisticsPostalAddress = custTable.postalAddress();
        if (custLogisticsPostalAddress.Street && custLogisticsPostalAddress.State)
        {
            slash = '/';
        }

        receiverCityState          = strLFix(custLogisticsPostalAddress.Street + slash + custLogisticsPostalAddress.State,
                                                #receiverCityStateLength, #spc);
        receiverCountryId          = strLFix(custLogisticsPostalAddress.CountryRegionId, #receiverCountryIdLegth, #spc);
        entryDetailseqNumber       = this.entryDetailSequenceNumber();

        seventhITAddendaRecord     = conIns(seventhITAddendaRecord, 1, recordTypeCode + addendaCode +
                                       receiverCityState + receiverCountryId + reserve + entryDetailseqNumber );

        return seventhITAddendaRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>seventhIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes field value and alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    /// The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    /// <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void seventhIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                    ('ABBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       FFFFFFF -Entry detail equence number')
        #define.iATreserved                         ('                                                                         EEEEEEEEEEEEEE - IAT reseved ')
        #define.iATReceiverCountryId                ('                                      DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD -  RECEIVER COUNTRY & POSTAL CODE')
        #define.iATReceiverCityState                ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC -RECEIVER CITY & STATE/PROVINCE')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "11" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "7"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATReceiverCountryId);
        file.write(#iATReceiverCityState);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sixthIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the sixth Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The sixth Addenda record.
    /// </returns>
    container sixthIATAddendaRecord()
    {
        container   sixthITAddendaRecord                =   conNull();

        #define.recTypeCode('7')
        #define.AddendaCode('15')
        #define.zero('0')
        #define.spc(' ')
        #define.receiverIndentificationNumLength(15)
        #define.receiverStreetNumberLength(35)
        #define.receivingDFIIdentificationLegth(34)
        #define.receivingDFIBranchLength(3)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          7
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03         15              The code to identify 1st IAT Addenda records is 10
        str 15      receiverIndentificationNum  =   strRep(#spc, 15);           // 04 - 18
        str 35      receiverStreetNumber        =   strRep(#spc, 35);           // 19 - 53
        str 34      reserve                     =   strRep(#spc, 34);           // 54 - 87        BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero, 7);           // 88 - 94

        receiverIndentificationNum    = strLFix(VendTable::find(custVendPaym.custVendTable().AccountNum).Tax1099RegNum,
                                        #receiverIndentificationNumLength, #spc);
        receiverStreetNumber          = strLFix(DirParty::primaryPostalAddress(custVendPaym.custVendTable().Party).Street,
                                        #receiverStreetNumberLength, #spc);
        entryDetailseqNumber          = this.entryDetailSequenceNumber();

        sixthITAddendaRecord          = conIns(sixthITAddendaRecord, 1, recordTypeCode + addendaCode + receiverIndentificationNum
                                        + receiverStreetNumber +  reserve + entryDetailseqNumber );

        return sixthITAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sixthIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes field value and alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    /// The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    /// <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void sixthIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFF - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       FFFFFFF -Entry detail equence number')
        #define.iATreserved                         ('                                                     EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE - IAT reseved ')
        #define.iATReceiverStreetNumber             ('                  DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD -  RECEIVER STREET NUMBER')
        #define.iATReceiverIndentificationNum       ('   CCCCCCCCCCCCCCC -RECEIVER IDENTIFICATION NUMBER')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "22" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "6"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATReceiverStreetNumber);
        file.write(#iATReceiverIndentificationNum);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>thirdIATAddendaRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the third Addenda record to the output file.
    /// </summary>
    /// <returns>
    ///    The Fist Addenda record.
    /// </returns>
    container thirdIATAddendaRecord()
    {
        container thirdITAddendaRecord = conNull();
        LogisticsPostalAddress localPostalAddress;

        #define.recTypeCode('7')
        #define.AddendaCode('12')
        #define.zero('0')
        #define.spc(' ')
        #define.orignatorNameLength(35)
        #define.orignatorAddress(35)
                                                                                // Offset          Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;               // 01 - 01          5
        str 2       addendaCode                 =   #AddendaCode;               // 02 - 03          12              The code to identify 1st IAT Addenda records is 10
        str 35      orignatorCity               =   strRep(#spc,35);            // 04 - 38
        str 35      origCountryCountry          =   strRep(#spc,35);            // 39 - 73
        str 14      reserve                     =   strRep(#spc,14);            // 82 - 87          BLANK
        str 7       entryDetailseqNumber        =   strRep(#zero,7);            // 88 - 94
        str         slash                       =   #spc;

        localPostalAddress = companyInfo.postalAddress();
        if (localPostalAddress.City && localPostalAddress.State)
        {
            slash = '/';
        }

        orignatorCity           = strLFix(localPostalAddress.City + slash + localPostalAddress.State,
                                            #orignatorNameLength, #spc);
        slash                   = #spc;
        if (localPostalAddress.CountryRegionId && companyInfo.postalAddress().ZipCode)
        {
            slash = '/';
        }
        origCountryCountry      = strLFix(localPostalAddress.CountryRegionId + slash + localPostalAddress.ZipCode,
                                            #orignatorAddress, #spc);
        entryDetailseqNumber    = this.entryDetailSequenceNumber();

        thirdITAddendaRecord     = conIns(thirdITAddendaRecord, 1, recordTypeCode + addendaCode + orignatorCity +
                                   origCountryCountry  + reserve + entryDetailseqNumber );

        return thirdITAddendaRecord ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>thirdIATAddendaRecordPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the field value and alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    /// The alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    /// <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    void thirdIATAddendaRecordPosition()
    {
        #define.iATRecordLayout                     ('ABBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEFFFFFFF - iAT PAYABLES RECORD')
        #define.iATEntryDetailseqNumber             ('                                                                                       FFFFFFF -Entry detail sequence number')
        #define.iATreserved                         ('                                                                         EEEEEEEEEEEEEE - IAT reseved ')
        #define.iATOrigCountryCountry               ('                                      DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD -  Originator country/region & POSTAL CODE')
        #define.iATorignatorCity                    ('   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC Originator city & STATE/PROVINCE')
        #define.iATAddedTypeCode                    (' BB - Transaction Code = "11" for AP Checking, "32" for AP Savings')
        #define.iATRecordTypeCode                   ('A - Record Type Code = "7"')

        file.write(#iATRecordLayout);
        file.write(#iATEntryDetailseqNumber);
        file.write(#iATreserved);
        file.write(#iATOrigCountryCountry);
        file.write(#iATorignatorCity);
        file.write(#iATAddedTypeCode);
        file.write(#iATRecordTypeCode);

        file.write();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>