<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjRevRecHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Helper class used in revenue recognition to get different setup values associated with the project.
/// The helper class takes into account the multiple contract lines feature flag to decide whether to use <c>ProjGroup</c> or <c>ProjRevenueProfile</c> setup.
/// </summary>
public class ProjRevRecHelper
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getCompletePrincipleForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets complete principle setup for given project ID.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_defaultToNoWIP">Whether to default the result to NoWIP principle if no revenue profile is found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjCompletePrincip</c> value on the project.</returns>
    public static ProjCompletePrincip getCompletePrincipleForProject(ProjId _projId, boolean _failOnMissingProfile = true, boolean _defaultToNoWIP = false, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjTable projTable = ProjTable::find(_projId);
        return ProjRevRecHelper::getCompletePrincipleForProjTable(projTable, _failOnMissingProfile, _defaultToNoWIP, _billingMethod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompletePrincipleForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets complete principle setup for given project.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_defaultToNoWIP">Whether to default the result to NoWIP principle if no revenue profile is found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjCompletePrincip</c> value on the project.</returns>
    public static ProjCompletePrincip getCompletePrincipleForProjTable(ProjTable _projTable, boolean _failOnMissingProfile = true, boolean _defaultToNoWIP = false, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile projRevProfile = ProjRevRecHelper::getProfileForRevRecProject(_projTable, _billingMethod, _failOnMissingProfile);
            if (!projRevProfile && _defaultToNoWIP)
            {
                return ProjCompletePrincip::NoWIP;
            }
            return projRevProfile.CompletePrinciple;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).CompletePrincip;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompletePrincipleContractLine</Name>
				<Source><![CDATA[
    public static ProjCompletePrincip getCompletePrincipleContractLine(ProjWIPTable _projWIPTable, boolean _defaultToNoWIP = false, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        boolean isContractLineUsed = _projWIPTable.IsContractLineUsed;
        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() || !isContractLineUsed)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }
        ProjRevenueProfile projRevProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(_projWIPTable);
        if (!projRevProfile && _defaultToNoWIP)
        {
            return ProjCompletePrincip::NoWIP;
        }
        return projRevProfile.CompletePrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchingPrincipleForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets matching principle setup for given project ID.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjMatchingPrincip</c> value on the project.</returns>
    public static ProjMatchingPrincip getMatchingPrincipleForProject(ProjId _projId, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjTable projTable = ProjTable::find(_projId);
        return ProjRevRecHelper::getMatchingPrincipleForProjTable(projTable, _failOnMissingProfile, _billingMethod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchingPrincipleForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets matching principle setup for given project.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjMatchingPrincip</c> value on the project.</returns>
    public static ProjMatchingPrincip getMatchingPrincipleForProjTable(ProjTable _projTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getProfileForRevRecProject(_projTable, _billingMethod, _failOnMissingProfile).MatchingPrinciple;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).MatchingPrincip;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForeseeableLossesActivatedForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets if foreseeable losses are enabled on a project.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns>true if foreseeable losses are enabled; false otherwise.</returns>
    public static NoYes isForeseeableLossesActivatedForProject(ProjId _projId, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjTable projTable = ProjTable::find(_projId);
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getProfileForRevRecProject(projTable, _billingMethod, _failOnMissingProfile).ForeseeableLosses;
        }
        else
        {
            return ProjGroup::find(projTable.ProjGroupId).ForeseablesLosses;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompletePrincipleForProjControlPeriodTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets complete principle setup on the project associated with the given <c>ProjControlPeriodTable</c> record.
    /// </summary>
    /// <param name = "_projControlPeriodTable"><c>ProjControlPeriodTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjCompletePrincip</c> value for <c>ProjControlPeriodTable</c> record.</returns>
    public static ProjCompletePrincip getCompletePrincipleForProjControlPeriodTable(ProjControlPeriodTable _projControlPeriodTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjWIPTable wipProject = ProjWIPTable::find(_projControlPeriodTable.ProjId);
        if(ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed)
        {
            return ProjRevenueProfile::findByRevenueProfileId(wipProject.ProjRevenueProfileId).CompletePrinciple;
        }
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjTable projTable = ProjTable::find(_projControlPeriodTable.ProjId);
            return ProjRevRecHelper::getProfileForRevRecProject(projTable, _billingMethod, _failOnMissingProfile).CompletePrinciple;
        }
        else
        {
            return _projControlPeriodTable.projGroup().CompletePrincip;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchingPrincipleForProjControlPeriodTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets matching principle setup on the project associated with the given <c>ProjControlPeriodTable</c> record.
    /// </summary>
    /// <param name = "_projControlPeriodTable"><c>ProjControlPeriodTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjMatchingPrincip</c> value for <c>ProjControlPeriodTable</c> record.</returns>
    public static ProjMatchingPrincip getMatchingPrincipleForProjControlPeriodTable(ProjControlPeriodTable _projControlPeriodTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjWIPTable wipProject = ProjWIPTable::find(_projControlPeriodTable.ProjId);
        if(ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed)
        {
            return ProjRevenueProfile::findByRevenueProfileId(wipProject.ProjRevenueProfileId).MatchingPrinciple;
        }
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjTable projTable = ProjTable::find(_projControlPeriodTable.ProjId);
            return ProjRevRecHelper::getProfileForRevRecProject(projTable, _billingMethod, _failOnMissingProfile).MatchingPrinciple;
        }
        else
        {
            return _projControlPeriodTable.projGroup().MatchingPrincip;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForeseeableLossesActivatedForProjControlPeriodTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets if foreseeable losses are enabled on the project associated with the given <c>ProjControlPeriodTable</c> record.
    /// </summary>
    /// <param name = "_projControlPeriodTable"><c>ProjControlPeriodTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns>true if foreseeable losses are enabled; false otherwise.</returns>
    public static NoYes isForeseeableLossesActivatedForProjControlPeriodTable(ProjControlPeriodTable _projControlPeriodTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjWIPTable wipProject = ProjWIPTable::find(_projControlPeriodTable.ProjId);
        if(ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed)
        {
            return ProjRevenueProfile::findByRevenueProfileId(wipProject.ProjRevenueProfileId).ForeseeableLosses;
        }
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjTable projTable = ProjTable::find(_projControlPeriodTable.ProjId);
            return ProjRevRecHelper::getProfileForRevRecProject(projTable, _billingMethod, _failOnMissingProfile).ForeseeableLosses;
        }
        else
        {
            return _projControlPeriodTable.projGroup().ForeseablesLosses;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPriceMatchingPrincipleForProjControlPeriodTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get sales price matching principle on the project associated with the given <c>ProjControlPeriodTable</c> record.
    /// </summary>
    /// <param name = "_projControlPeriodTable"><c>ProjControlPeriodTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjSalesPriceMatchingPrincip</c> value for the given params.</returns>
    public static ProjSalesPriceMatchingPrincip getSalesPriceMatchingPrincipleForProjControlPeriodTable(ProjControlPeriodTable _projControlPeriodTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjWIPTable wipProject = ProjWIPTable::find(_projControlPeriodTable.ProjId);
        if(ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed)
        {
            return ProjRevenueProfile::findByRevenueProfileId(wipProject.ProjRevenueProfileId).SalesPriceMatchingPrinciple;
        }
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjTable projTable = ProjTable::find(_projControlPeriodTable.ProjId);
            return ProjRevRecHelper::getProfileForRevRecProject(projTable, _billingMethod, _failOnMissingProfile).SalesPriceMatchingPrinciple;
        }
        else
        {
            return _projControlPeriodTable.projGroup().SalesPriceMatchingPrincip;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPriceMatchingPrincipleForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get sales price matching principle on the project given project ID.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjSalesPriceMatchingPrincip</c> value for the given params.</returns>
    public static ProjSalesPriceMatchingPrincip getSalesPriceMatchingPrincipleForProject(ProjId _projId, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjTable projTable = ProjTable::find(_projId);
        return ProjRevRecHelper::getSalesPriceMatchingPrincipleForProjTable(projTable, _failOnMissingProfile, _billingMethod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPriceMatchingPrincipleForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get sales price matching principle for the given <c>ProjTable</c> record.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>ProjSalesPriceMatchingPrincip</c> value for the given params.</returns>
    public static ProjSalesPriceMatchingPrincip getSalesPriceMatchingPrincipleForProjTable(ProjTable _projTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getProfileForRevRecProject(_projTable, _billingMethod, _failOnMissingProfile).SalesPriceMatchingPrinciple;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).SalesPriceMatchingPrincip;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccruedCostCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get accrued cost category id for the project associated with the given <c>ProjControlPeriodTable</c> record.
    /// </summary>
    /// <param name = "_projControlPeriodTable"><c>ProjControlPeriodTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns><c>PorjCategoryCostId</c> value for the given params.</returns>
    public static ProjCategoryCostId getAccruedCostCategoryId(ProjControlPeriodTable _projControlPeriodTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjWIPTable wipProject = ProjWIPTable::find(_projControlPeriodTable.ProjId);
        if(ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed)
        {
            return ProjRevenueProfile::findByRevenueProfileId(wipProject.ProjRevenueProfileId).AccruedLossCategoryId;
        }
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjTable projTable = ProjTable::find(_projControlPeriodTable.ProjId);
            return ProjRevRecHelper::getProfileForRevRecProject(projTable, _billingMethod, _failOnMissingProfile).AccruedLossCategoryId;
        }
        else
        {
            return _projControlPeriodTable.projGroup().AccruedCostCategoryId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOnAccLedgerStatusForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets on-account invoicing status for given project and billing method.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>On-account invoicing status.</returns>
    public static ProjLedgerStatusOnAcc getOnAccLedgerStatusForProjTable(ProjTable _projTable, ProjContractBillingMethod _billingMethod, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfile(_projTable, _billingMethod, _failOnMissingProfile).OnAccLedgerStatus;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).InvoicePosting;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOnAccLedgerStatusForProposalOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets on-account invoicing status for given project and billing method.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_projProposalOnAcc">The project on-account proposal transaction.</param>
    /// <param name = "_projOnAccTrans">The project on-account transaction.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>On-account invoicing status.</returns>
    public static ProjLedgerStatusOnAcc getOnAccLedgerStatusForProposalOnAcc(ProjTable _projTable, ProjProposalOnAcc _projProposalOnAcc, ProjOnAccTrans _projOnAccTrans, boolean _failOnMissingProfile = true)
    {
        ProjLedgerStatusOnAcc onAccLedgerStatus;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            if (!_projOnAccTrans)
            {
                _projOnAccTrans = _projProposalOnAcc.projOnAccTrans();
            }

            ProjContractBillingMethod billingMethod = _projProposalOnAcc.PSAContractLineNum ?
                ProjMultipleContractLinesForProjectFeatureHelper::getBillingMethodForProjContractLine(_projProposalOnAcc.PSAContractLineNum) :
                (_projOnAccTrans.TransactionOrigin == ProjOrigin::Milestone ? ProjContractBillingMethod::FixedPrice : ProjContractBillingMethod::TimeMaterial);

            onAccLedgerStatus = ProjRevRecHelper::getRevProfile(_projTable, billingMethod, _failOnMissingProfile).OnAccLedgerStatus;
        }
        else
        {
            onAccLedgerStatus = ProjGroup::find(_projTable.ProjGroupId).InvoicePosting;
        }

        return onAccLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getControlIdPeriodIdForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets Control ID and Period code for revenue recognition.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <returns>A container including the Control Id and Period code from the revenue profile.</returns>
    public static container getControlIdPeriodIdForProjTable(ProjTable _projTable, boolean _failOnMissingProfile = true, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjControlId controlId;
        ProjPeriodId periodId;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile projRevProfile = ProjRevRecHelper::getProfileForRevRecProject(_projTable, _billingMethod, _failOnMissingProfile);

            controlId = projRevProfile.CostTemplate;
            periodId = projRevProfile.PeriodId;
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(_projTable.ProjGroupId);
            controlId = projGroup.ControlId;
            periodId = projGroup.PeriodId;
        }

        return [controlId, periodId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductionCategoryIdForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ProductionCategoryId for estimates
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns></returns>
    public static ProjCategoryId getProductionCategoryIdForProjTable(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfile(_projTable, ProjContractBillingMethod::FixedPrice, _failOnMissingProfile).ProductionCategoryId;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).ProductionCategoryId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfitCategoryIdForProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ProfitCategoryId for estimates
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns></returns>
    public static ProjCategoryId getProfitCategoryIdForProjTable(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfile(_projTable, ProjContractBillingMethod::FixedPrice, _failOnMissingProfile).ProfitCategoryId;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).ProfitCategoryId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>ProjRevenueProfile</c> record for the given project matching the <c>ProjRevenueProfileRule</c> in associated WIPProject if it exists or as per setup.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns><c>ProjRevenueProfile</c> record.</returns>
    public static ProjRevenueProfile getRevProfile(ProjTable _projTable, ProjContractBillingMethod _billingMethod, boolean _failOnMissingProfile = true)
    {
        ProjRevenueProfile revProfile;
        if (ProjPrioritizeGivenRevenueProfileFlight::instance().isEnabled())
        {
            revProfile = ProjRevRecHelper::getProfileForRevRecProject(_projTable, _billingMethod, _failOnMissingProfile);
        }
        else
        {
            revProfile = ProjRevRecHelper::getRevProfileHelper(_projTable, _billingMethod, _failOnMissingProfile);
        }
        return revProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevProfileHelper</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>ProjRevenueProfile</c> record for the given project matching the <c>ProjRevenueProfileRule</c> setup.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns><c>ProjRevenueProfile</c> record.</returns>
    private static ProjRevenueProfile getRevProfileHelper(ProjTable _projTable, ProjContractBillingMethod _billingMethod, boolean _failOnMissingProfile = true)
    {      
        ProjRevenueProfileRule revProfileRule = ProjRevenueProfileRule::matchProfileRule(_projTable.ProjInvoiceProjId, _projTable.ProjId, _projTable.ProjGroupId, _billingMethod);
        ProjRevenueProfile revProfile = ProjRevenueProfile::findByRevenueProfileId(revProfileRule.ProjRevenueProfileId);

        if (_failOnMissingProfile && (!revProfileRule || !revProfile))
        {
            throw error(strFmt("@Proj:RevenueProfileRule_MissingRuleError", _projTable.ProjInvoiceProjId, _projTable.ProjId, 
                                _projTable.ProjGroupId, _billingMethod));
        }

        if (revProfile && _billingMethod == ProjContractBillingMethod::FixedPrice && _projTable.WIPProject)
        {
            ProjRevRecHelper::updateFixedPriceRevRecProjectWithRevProfile(_projTable.fixedPriceRevRecProject());
        }

        return revProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevProfileContractLineGroup</Name>
				<Source><![CDATA[
    public static ProjRevenueProfile getRevProfileContractLineGroup(ProjTable _projTable, ProjContractBillingMethod _billingMethod, boolean _failOnMissingProfile = true, RecId _contractLineGroupRefRecId = 0)
    {
        ProjRevenueProfileRule revProfileRule = ProjRevenueProfileRule::matchProfileRule(_projTable.ProjInvoiceProjId, _projTable.ProjId, _projTable.ProjGroupId, _billingMethod, _contractLineGroupRefRecId);
        ProjRevenueProfile revProfile;
        if (revProfileRule)
        {
            revProfile = ProjRevenueProfile::findByRevenueProfileId(revProfileRule.ProjRevenueProfileId);
        }

        if (_failOnMissingProfile && (!revProfileRule || !revProfile))
        {
            throw error(strFmt("@Proj:RevenueProfileRule_MissingRuleError", _projTable.ProjInvoiceProjId, _projTable.ProjId,
                                _projTable.ProjGroupId, _billingMethod));
        }

        return revProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevProfileV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>ProjRevenueProfile</c> record for the given project matching the <c>ProjRevenueProfileRule</c> setup.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_contactLine"><c> Contract line </c> to get billing method and Contract line group RecId.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns><c>ProjRevenueProfile</c> record.</returns>
    public static ProjRevenueProfile getRevProfileV2(ProjTable _projTable, PSAContractLineItems _contactLine, boolean _failOnMissingProfile = true)
    {
        ProjRevRecInstrumentationLogger  logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlCalc));

        using (var activityContext = logger.revRecActivity().postContractLineBasedRevRec())
        {
            logger.logInformation(strFmt(@"getRevProfileV2::%1 done for
                ProjId: %2
                ContractLine: %3
                ContractLineGroupId: %4
                Billing method: %5",
                ProjRevRecInstrumentationActivities::ContractLineBasedRevRec,
                _projTable.ProjId,
                _contactLine,
                _contactLine.ContractLineGroupRefRecId,
                _contactLine.BillingMethod));
        }


        if (_contactLine.ContractLineGroupRefRecId)
        {
            return ProjRevRecHelper::getRevProfileContractLineGroup(_projTable, _contactLine.BillingMethod, _failOnMissingProfile, _contactLine.ContractLineGroupRefRecId);
        }
        else
        {
            return ProjRevRecHelper::getRevProfile(_projTable, _contactLine.BillingMethod, _failOnMissingProfile);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfileForRevRecProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>ProjRevenueProfile</c> for the project used in revenue recognition for the given <c>ProjTable</c> record.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_billingMethod">Project billing method.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns><c>ProjRevenueProfile</c> record.</returns>
    public static ProjRevenueProfile getProfileForRevRecProject(ProjTable _projTable, ProjContractBillingMethod _billingMethod, boolean _failOnMissingProfile = true)
    {
        
        if (!_projTable.WIPProject || 
                ( 
                  _billingMethod == ProjContractBillingMethod::TimeMaterial &&
                  ProjWIPPostingAndReversalFlight::instance().isEnabled()
                )
            )
        {
            // Find revenue profile the normal way by looking at the rules.
            return ProjRevRecHelper::getRevProfileHelper(_projTable, _billingMethod, _failOnMissingProfile);
        }

        ProjWIPTable estimateProject = ProjWIPTable::find(_projTable.WIPProject);
        ProjRevenueProfile projRevProfile;

        if (estimateProject.ProjRevenueProfileId)
        {
            projRevProfile = ProjRevenueProfile::findByRevenueProfileId(estimateProject.ProjRevenueProfileId);
        }
        else
        {
            // Find revenue profile the normal way by looking at the rules.
            return ProjRevRecHelper::getRevProfileHelper(_projTable, _billingMethod, _failOnMissingProfile);
        }
        
        if (!projRevProfile && _failOnMissingProfile)
        {
            throw error(strFmt("@Proj:EstimateProjectRevenueProfileMissingError", _projTable.WIPProject));
        }

        return projRevProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfileForRevRecProjectContractLine</Name>
				<Source><![CDATA[
    public static ProjRevenueProfile getProfileForRevRecProjectContractLine(ProjWIPTable _projWIPTable)
    {
        boolean isContractLineUsed = _projWIPTable.IsContractLineUsed;
        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() || !isContractLineUsed)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        ProjRevenueProfile revProfile;
        if(_projWIPTable.ProjRevenueProfileId)
        {
            revProfile = ProjRevenueProfile::findByRevenueProfileId(_projWIPTable.ProjRevenueProfileId);
        }
        else
        {
            throw error(strFmt("@Proj:WIPNoProfileRule",_projWIPTable.ProjId));
        }
    
        return revProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cost2LedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ProjLedgerStatus</c> enumeration value that is based on a post costs minus expense
    /// enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatusCost">
    /// The value of post costs minus expense.
    /// </param>
    /// <returns>
    /// The ledger status value that corresponds to the post costs minus expense value.
    /// </returns>
    /// <remarks>
    /// If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    public static ProjLedgerStatus cost2LedgerStatus(ProjLedgerStatusCost _projLedgerStatusCost)
    {
        ProjLedgerStatus projLedgerStatus;

        switch (_projLedgerStatusCost)
        {
            case ProjLedgerStatusCost::BalanceSheet:
                projLedgerStatus = ProjLedgerStatus::BalanceSheet;
                break;

            case ProjLedgerStatusCost::Operations:
                projLedgerStatus = ProjLedgerStatus::Operations;
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>item2LedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ProjLedgerStatus</c> enumeration value that is based on the post costs minus the item
    /// enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatusItem">
    /// A post costs minus item value.
    /// </param>
    /// <returns>
    /// The ledger status value that corresponds to the post costs minus item value.
    /// </returns>
    /// <remarks>
    /// If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    public static ProjLedgerStatus item2LedgerStatus(ProjLedgerStatusItem  _projLedgerStatusItem)
    {
        ProjLedgerStatus projLedgerStatus;

        switch (_projLedgerStatusItem)
        {
            case ProjLedgerStatusItem::BalanceSheet:
                projLedgerStatus = ProjLedgerStatus::BalanceSheet;
                break;

            case ProjLedgerStatusItem::Operations:
                projLedgerStatus = ProjLedgerStatus::Operations;
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatus2Item</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a post costs minus the item enumeration data type value based on a ledger status enumeration
    /// value.
    /// </summary>
    /// <param name="_projLedgerStatus">
    /// A Ledger status value.
    /// </param>
    /// <returns>
    /// The post costs minus item value that corresponds to the ledger status value.
    /// </returns>
    public static ProjLedgerStatusItem ledgerStatus2Item(ProjLedgerStatus  _projLedgerStatus)
    {
        ProjLedgerStatusItem projLedgerStatusItem;

        switch (_projLedgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                projLedgerStatusItem = ProjLedgerStatusItem::BalanceSheet;
                break;

            case ProjLedgerStatus::Operations:
                projLedgerStatusItem = ProjLedgerStatusItem::Operations;
                break;
        }

        return projLedgerStatusItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatus2cost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a post costs minus expense enumeration value, depending on a ledger status enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatus">
    ///    A ledger status value.
    /// </param>
    /// <returns>
    ///    The post costs minus expense value that corresponds to the ledger status value.
    /// </returns>
    public static ProjLedgerStatusCost ledgerStatus2cost(ProjLedgerStatus  _projLedgerStatus)
    {
        ProjLedgerStatusCost projLedgerStatusCost;

        switch (_projLedgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                projLedgerStatusCost = ProjLedgerStatusCost::BalanceSheet;
                break;

            case ProjLedgerStatus::Operations:
                projLedgerStatusCost = ProjLedgerStatusCost::Operations;
                break;
        }

        return projLedgerStatusCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmplLedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger status for hour transactions.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Ledger status to be used for hour transaction.</returns>
    public static ProjLedgerStatus getEmplLedgerStatus(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Hour, _failOnMissingProfile).EmplLedgerStatus;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).EmplTransCost;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostLedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger status for expense transactions.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Ledger status to be used for expense transaction.</returns>
    public static ProjLedgerStatus getCostLedgerStatus(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Cost, _failOnMissingProfile);
            return ProjRevRecHelper::cost2LedgerStatus(revProfile.CostLedgerStatus);
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).CostTransCost;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemLedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger status for item transactions.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Ledger status to be used for item transaction.</returns>
    public static ProjLedgerStatus getItemLedgerStatus(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Item, _failOnMissingProfile);
            return ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).ItemTransCost;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWIPEmplForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the setting whether to post revenue for hour transaction.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Setup value to post revenue for hour transaction.</returns>
    public static NoYes postWIPEmplForProject(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Hour, _failOnMissingProfile).PostWIPEmpl;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).EmplTransTurnover;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWIPItemForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the setting whether to post revenue for item transaction.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Setup value to post revenue for item transaction.</returns>
    public static NoYes postWIPItemForProject(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Item, _failOnMissingProfile).PostWIPItem;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).ItemTransTurnover;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWIPCostForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the setting whether to post revenue for expense transaction.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Setup value to post revenue for expense transaction.</returns>
    public static NoYes postWIPCostForProject(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Cost, _failOnMissingProfile).PostWIPCost;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).CostTransTurnover;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWIPFeeForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the setting whether to post revenue for fee transaction.
    /// </summary>
    /// <param name = "_projTable">Project record.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <returns>Setup value to post revenue for fee transaction.</returns>
    public static NoYes postWIPFeeForProject(ProjTable _projTable, boolean _failOnMissingProfile = true)
    {
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            return ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Revenue, _failOnMissingProfile).PostWIPFee;
        }
        else
        {
            return ProjGroup::find(_projTable.ProjGroupId).RevenueTransTurnover;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevProfileForTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>ProjRevenueProfile</c> record for the given project and transaction type.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_projTransType">Transaction type for which revenue profile is needed.</param>
    /// <param name = "_failOnMissingProfile">true if error should be thrown when <c>ProjRevenueProfile</c> record is not found.</param>
    /// <remarks>Call to this method assumes the feature key is turned on.</remarks>
    /// <returns><c>ProjRevenueProfile</c> record.</returns>
    protected internal static ProjRevenueProfile getRevProfileForTransactionType(ProjTable _projTable, ProjTransType _projTransType, boolean _failOnMissingProfile = true)
    {
        if (!ProjRevRecHelper::isTransTypeValid(_projTransType))
        {
            throw error(strFmt("@Proj:ContractLine_WrongTransactionType", _projTransType));
        }

        ProjRevenueProfile projProfile;
        PSAContractLineItems contractLine = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(_projTable.ProjId, _projTable.ProjInvoiceProjId, _projTransType);

        if (contractLine)
        {
            projProfile = ProjRevRecHelper::getRevProfileV2(_projTable, contractLine, _failOnMissingProfile);
        }
        else if (_failOnMissingProfile)
        {
            throw Error(strFmt("@Proj:ProjNoContractLineForTransType", enum2Str(_projTransType), _projTable.ProjInvoiceProjId, _projTable.ProjId));
        }

        return projProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransTypeValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if provided transaction type is valid to lookup revenue profile.
    /// </summary>
    /// <param name = "_projTransType">Transaction type for which revenue profile is needed.</param>
    /// <returns>true if transtype is valid, false otherwise.</returns>
    public static boolean isTransTypeValid(ProjTransType _projTransType)
    {
        return _projTransType == ProjTransType::Cost || _projTransType == ProjTransType::Item || _projTransType == ProjTransType::Hour || _projTransType == ProjTransType::Revenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBillingMethodForTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get billing method from contract lines for given transaction type and project.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <returns>The billing method associated with the contract line for given params. Defaults to T&M for internal project.</returns>
    protected internal static ProjContractBillingMethod getBillingMethodForTransactionType(ProjTable _projTable, ProjTransType _projTransType)
    {
        if (_projTable.ProjInvoiceProjId == '')
        {
            return ProjContractBillingMethod::TimeMaterial;
        }
        else
        {
            return ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(_projTable.ProjId, _projTable.ProjInvoiceProjId, _projTransType).BillingMethod;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFixedPriceEstimateProjectForContractLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates a new fixed price revenue estimate project for a contract line and a newly created WIP Project.
    /// </summary>
    /// <param name = "_psaContractLineNum"><c>PSAContractLineNum</c> of the contract line.</param>
    /// <returns>Revenue estimate project record referenced by the specified revenue recognition contract line number.</returns>
    protected internal static ProjWIPTable createFixedPriceEstimateProjectForContractLine(PSAContractLineNum _psaContractLineNum)
    {
        boolean ret = false;

        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled())
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        PSAContractLineItems psaContractLineItems = PSAContractLineItems::find(_psaContractLineNum);

        if(!psaContractLineItems.RecId)
        {
            throw error("@PSA3119");
        }

        ProjRevRecContractLine projRevRecContractLine = ProjRevRecContractLine::findByContractLineNum(_psaContractLineNum);
        
        if(projRevRecContractLine)
        {
            return ProjWIPTable::find(projRevRecContractLine.RevenueRecognitionId);
        }

        ProjInvoiceTable projInvoiceTable = ProjInvoiceTable::find(psaContractLineItems.ProjInvoiceProjId);
        if (!projInvoiceTable.RecId)
        {
            throw Global::error(strFmt("@Proj:ContractDoesNotExist", psaContractLineItems.ProjInvoiceProjId));
        }

        // As per spec, we should create description in the format : <Contract name-Contract line name>.
        str description = strFmt("@Proj:ProjWIPTableDescContractLine",  projInvoiceTable.Description , psaContractLineItems.LineDesc);
        ProjWIPId projWipId = ProjParameters::newRevenueRecognitionProjectId();
        if (projWIPId == '')
        {
            throw Global::error(strFmt("@Proj:ProjWIPIdEmpty"));
        }
        
        ProjWIPTable projWIPTable = ProjRevRecHelper::findOrCreateWIPProject(projWipId, description);
       
        if (!projWIPTable)
        {
            throw Exception::Error;
        }

        ProjTable projTable;
        PSAContractLineItemsSetup contractLineSetup;
        select firstonly ProjId from projTable
            exists join contractLineSetup
            where projTable.ProjId == contractLineSetup.ProjId
                && contractLineSetup.ContractLineNum == _psaContractLineNum;

        projWIPTable.selectForUpdate(true);
        projWIPTable.DefaultContractLineNum = _psaContractLineNum;
        projWIPTable.DefaultProject = projTable.ProjId;
        if (projWIPTable.validateWrite(false))
        {
            ttsbegin;
            projWIPTable.update();
            ttscommit;
        }

        ProjRevRecHelper::insertIntoProjRevRecContractLine(_psaContractLineNum, projWipId);

        ProjRevRecInstrumentationLogger  logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjRevRecHelper));

        using (var activityContext = logger.revRecActivity().postContractLineBasedRevRec())
        {
            logger.logInformation(strFmt(@"createFixedPriceEstimateProjectForContractLine::%1 done for
                WipProjId: %2
                DefaultProject: %3
                DefaultContractLineNum: %4
                ProjRevenueProfileId: %5
                ControlId: %6
                PeriodId: %7",
                ProjRevRecInstrumentationActivities::ContractLineBasedRevRec,
                projWipId,
                projWIPTable.DefaultProject,
                projWIPTable.DefaultContractLineNum));
        }

        return projWIPTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateFixedPriceEstimateProjectForContractLineAndWIPId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if exists or creates a fixed price revenue estimate project for a contract line and WIP Id.
    /// </summary>
    /// <param name = "_psaContractLineNum"><c>PSAContractLineNum</c> of the contract line.</param>
    /// <param name = "_projWIPId"><c>ProjWIPTable</c> record ID.</param>
    /// <returns>Revenue estimate project record referenced by the specified revenue recognition contract line number.</returns>
    /// <remarks>
    /// It expects _psaContractLineNum to exist and _projWIPId to be non-empty.
    /// </remarks>
    protected internal static ProjWIPTable findOrCreateFixedPriceEstimateProjectForContractLineAndWIPId(PSAContractLineNum _psaContractLineNum , ProjWIPId _projWIPId)
    {
        boolean ret = false;

        // If ProjContractLineBasedRevenueRecognitionFeature is enabled, projId would not have WIPProject.
        // If new ProjWIPTable is created, it would be based on the specified revenue recognition contract line number
        // and its projId would be a naturally generated number.

        // This method can not be called when ProjContractLineBasedRevenueRecognitionFeature is not enabled.
        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled())
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if(_projWipId == '')
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        PSAContractLineItems psaContractLineItems = PSAContractLineItems::find(_psaContractLineNum);

        if(!psaContractLineItems.RecId)
        {
            throw error("@PSA3119");
        }

        // We need to see if a ProjWIPTable is created for the contract line no psaContractLineNum
        // If not, then create it.

        // Step 1 : Check whether some entry exists in ProjRevRecContractLine with same _psaContractLineNum and _projWIPId.
        // If its found, we should use that.
        ProjRevRecContractLine projRevRecContractLine = ProjRevRecContractLine::findByRevenueRecognitionIdContractLineNum(_psaContractLineNum, _projWIPId);
       
        // Step 2: If it does, then return it.
        if (projRevRecContractLine)
        {
            // If the corresponding WIPProject does not exist, error out.
            ProjWIPTable projWIPTable = ProjWIPTable::find(projRevRecContractLine.RevenueRecognitionId);

            if(!projWIPTable.RecId)
            {
                throw Global::error(strFmt("@Proj:REPDoesNotExist",  _projWIPId));
            }
            return projWIPTable;
        }

        // If there's no entry in ProjRevRecContractLine with same _projWIPId and _psaContractLineNum, then
        // check if theres any entry in ProjRevRecContractLine with ONLY same _psaContractLineNum.
        // If it does, then it means the existing ProjRevRecContractLine is associated with some other REP.
        // In this case if
        //  1. _projWIPId was non-empty, we would error out.
        //  2. Otherwise, we would return existing projWIPId.
        // Otherwise, create an entry in both ProjRevRecContractLine and ProjWipTable.

        projRevRecContractLine = ProjRevRecContractLine::findByContractLineNum(_psaContractLineNum);
        
        if(projRevRecContractLine)
        {
            throw Global::error(strFmt("@Proj:ProjREPAlreadyExistsForContractLine", projRevRecContractLine.RevenueRecognitionId, projRevRecContractLine.ContractLineNum));
        }

        ProjInvoiceTable projInvoiceTable = ProjInvoiceTable::find(psaContractLineItems.ProjInvoiceProjId);
        if (!projInvoiceTable.RecId)
        {
            throw Global::error(strFmt("@Proj:ContractDoesNotExist", psaContractLineItems.ProjInvoiceProjId));
        }

        // As per spec, we should create description in the format : <Contract name-Contract line name>.
        str description = strFmt("@Proj:ProjWIPTableDescContractLine",  projInvoiceTable.Description , psaContractLineItems.LineDesc);
        ProjWIPTable projWIPTable = ProjRevRecHelper::findOrCreateWIPProject(_projWipId, description);
       
        if (!projWIPTable)
        {
            throw Exception::Error;
        }

        ProjTable projTable;
        PSAContractLineItemsSetup contractLineSetup;
        select firstonly projTable
            join contractLineSetup
            where projTable.ProjId == contractLineSetup.ProjId
            && contractLineSetup.ContractLineNum == _psaContractLineNum;

        projWIPTable.selectForUpdate(true);
        projWIPTable.DefaultContractLineNum = _psaContractLineNum;
        projWIPTable.DefaultProject = projTable.ProjId;
        if (projWIPTable.validateWrite(false))
        {
            ttsbegin;
            projWIPTable.update();
            ttscommit;
        }

        // If control reaches this point, it means projRevRecContractLine is empty.
        ProjRevRecHelper::insertIntoProjRevRecContractLine(_psaContractLineNum, _projWipId);

        ProjRevRecInstrumentationLogger  logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjRevRecHelper));

        using (var activityContext = logger.revRecActivity().postContractLineBasedRevRec())
        {
            logger.logInformation(strFmt(@"findOrCreateFixedPriceEstimateProjectForContractLineAndWIPId::%1 done for
                WipProjId: %2
                DefaultProject: %3
                DefaultContractLineNum: %4
                ProjRevenueProfileId: %5
                ControlId: %6
                PeriodId: %7",
                ProjRevRecInstrumentationActivities::ContractLineBasedRevRec,
                _projWipId,
                projWIPTable.DefaultProject,
                projWIPTable.DefaultContractLineNum));
        }

        return projWIPTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoProjRevRecContractLine</Name>
				<Source><![CDATA[
    private static void insertIntoProjRevRecContractLine(PSAContractLineNum _psaContractLineNum, ProjWipId _projWIPId)
    {
        ProjRevRecContractLine projRevRecContractLine;

        ProjWIPTable projWIPTable = ProjWIPTable::find(_projWIPId);

        if(!projWIPTable.RecId)
        {
            throw Global::error(strFmt("@Proj:REPDoesNotExist",  _projWIPId));
        }

        PSAContractLineItems psaContractLineItems = PSAContractLineItems::find(_psaContractLineNum);

        if(!psaContractLineItems.RecId)
        {
            throw error("@PSA3119");
        }

        projRevRecContractLine = ProjRevRecContractLine::findByRevenueRecognitionIdContractLineNum(_psaContractLineNum, _projWIPId);

        if (projRevRecContractLine)
        {
            throw Global::error(strFmt("@Proj:ProjREPAlreadyExistsForContractLine", _projWIPId, _psaContractLineNum));
        }

        projRevRecContractLine.ContractLineNum = _psaContractLineNum;
        projRevRecContractLine.RevenueRecognitionId = _projWIPId;
        if(!projRevRecContractLine.validateWrite())
        {
            throw Global::error(strFmt("@SYS67205", tablePName(ProjRevRecContractLine)));
        }
        ttsbegin;
        projRevRecContractLine.insert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateWIPProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates a revenue estimate project with provided revenue estimate project ID.
    /// </summary>
    /// <param name = "_projWipId"><c>ProjWIPTable</c> record id.</param>
    /// <param name = "_description"><c>ProjWIPTable</c> description.</param>
    /// <returns>Revenue estimate project record referenced by the specified revenue recognition contract line number.</returns>
    protected internal static ProjWIPTable findOrCreateWIPProject(ProjWIPId _projWipId, str _description = '')
    {
        if(_projWipId == '')
        {
            throw error(strFmt("@SYS22828",funcName()));
        }
        ProjWIPTable projWIPTable = ProjWIPTable::find(_projWipId, true);

        if(!projWIPTable)
        {
            projWIPTable.clear();
            projWIPTable.ProjId = _projWipId;
            projWIPTable.Description = _description;
            projWIPTable.IsContractLineUsed = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();
            if(!projWIPTable.validateWrite(false))
            {
                throw Global::error(strFmt("@SYS67205", tablePName(ProjWIPTable)));
            }
            ttsbegin;
            projWIPTable.insert();
            ttscommit;
        }

        return projWIPTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefaultFixedPriceRevRecProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a fixed price estimate project and associates it to revenue profile if the setup is valid.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <returns>true if operation was successful; otherwise false.</returns>
    protected internal static boolean createDefaultFixedPriceRevRecProject(ProjTable _projTable)
    {
        boolean ret = true;

        // Get the <c>ProjTable</c> record for the project to be used in revenue recognition.
        ProjTable projTableForFixedPriceRevRec = _projTable;
        
        if (_projTable.WIPProject && _projTable.ProjId != _projTable.WIPProject)
        {
            projTableForFixedPriceRevRec = ProjTable::find(_projTable.WIPProject);
        }

        ProjWIPTable projWIPTable;
        select forupdate projWIPTable where projWIPTable.ProjId == projTableForFixedPriceRevRec.ProjId;
            
        // Only description can be updated.
        projWIPTable.Description = projTableForFixedPriceRevRec.Name;
            
        ttsbegin;
        if (!projWIPTable.RecId)
        {
            projWIPTable.ProjId = projTableForFixedPriceRevRec.ProjId;

            if (!projWIPTable.ProjRevenueProfileId
                && ProjRevRecDefaultRevProfileFixedPriceProjFlight::instance().isEnabled())
            {
                // Get revenue profile for the project used for revenue recognition.
                ProjRevenueProfileRule revProfileRule = ProjRevenueProfileRule::matchProfileRule(projTableForFixedPriceRevRec.ProjInvoiceProjId, projTableForFixedPriceRevRec.ProjId, projTableForFixedPriceRevRec.ProjGroupId, ProjContractBillingMethod::FixedPrice);
                ProjRevenueProfile revProfile = ProjRevenueProfile::findByRevenueProfileId(revProfileRule.ProjRevenueProfileId);

                // Update revenue profile on the fixed-price rev rec project if valid revenue profile is found
                if (revProfile && revProfile.CompletePrinciple != ProjCompletePrincip::NoWIP && revProfile.CostTemplate != '' && revProfile.PeriodId != '')
                {
                    projWIPTable.ControlId = revProfile.CostTemplate;
                    projWIPTable.PeriodId = revProfile.PeriodId;
                    projWIPTable.ProjRevenueProfileId = revProfile.ProjRevenueProfileId;
                }   
            }

            ret = projWIPTable.validateWrite(false);
            if(ret)
            {
                projWIPTable.insert();
            }
        }
        else
        {
            projWIPTable.update();
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFixedPriceRevRecProjectWithRevProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates revenue profile on the given fixed price rev rec project.
    /// </summary>
    /// <param name = "_fixedPriceRevRecProject"><c>ProjWIPTable</c> record.</param>
    /// <param name = "_throwErrorOnMissingRevProf">true if error should be thrown for missing revenue profile.</param>
    /// <returns>true if operation was successful; otherwise false.</returns>
    protected internal static boolean updateFixedPriceRevRecProjectWithRevProfile(ProjWIPTable _fixedPriceRevRecProject, boolean _throwErrorOnMissingRevProf = false)
    {
        boolean ret = false;

        // Return false if estimate project is already associated with a revenue profile.
        if (_fixedPriceRevRecProject.ProjRevenueProfileId)
        {
            return ret;
        }

        // Get the <c>ProjTable</c> record for the project to be used in revenue recognition.
        ProjTable projTableForFixedPriceRevRec = ProjTable::find(_fixedPriceRevRecProject.ProjId);

        // Get revenue profile for the project used for revenue recognition.
        ProjRevenueProfileRule revProfileRule = ProjRevenueProfileRule::matchProfileRule(projTableForFixedPriceRevRec.ProjInvoiceProjId, projTableForFixedPriceRevRec.ProjId, projTableForFixedPriceRevRec.ProjGroupId, ProjContractBillingMethod::FixedPrice);
        ProjRevenueProfile revProfile = ProjRevenueProfile::findByRevenueProfileId(revProfileRule.ProjRevenueProfileId);

        if (revProfile && revProfile.CompletePrinciple != ProjCompletePrincip::NoWIP)
        {
            if (revProfile.CostTemplate == '' || revProfile.PeriodId == '')
            {
                return checkFailed(strFmt("@Proj:RevProfileMissingControlIdOrPeriodId", _fixedPriceRevRecProject.ProjId));
            }

            ttsbegin;
            _fixedPriceRevRecProject.selectForUpdate(true);
            _fixedPriceRevRecProject.ControlId = revProfile.CostTemplate;
            _fixedPriceRevRecProject.PeriodId = revProfile.PeriodId;
            _fixedPriceRevRecProject.ProjRevenueProfileId = revProfile.ProjRevenueProfileId;

            if(_fixedPriceRevRecProject.validateWrite(false))
            {
                _fixedPriceRevRecProject.update();
                ret = true;
            }
            ttscommit;
        }
        else if (_throwErrorOnMissingRevProf)
        {
            return checkFailed(strFmt("@Proj:FPRevRecProjectRevProfileAssociationFailure", projTableForFixedPriceRevRec.ProjId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareFixedPriceRevRecProjectWithRevProfileContractLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates revenue profile on the given fixed price contract line based rev rec project
    /// </summary>
    /// <param name = "_fixedPriceRevRecProject"><c>ProjWIPTable</c> record.</param>
    protected internal static void prepareFixedPriceRevRecProjectWithRevProfileContractLine( ProjWIPTable _fixedPriceRevRecProject)
    {
        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() || !_fixedPriceRevRecProject || !_fixedPriceRevRecProject.IsContractLineUsed)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }
        if (!_fixedPriceRevRecProject.DefaultProject)
        {
            throw error(strFmt("@Proj:FPRevRecProjectDefaultProjectAssocationFailure", _fixedPriceRevRecProject.ProjId));
        }
        if (!_fixedPriceRevRecProject.DefaultContractLineNum)
        {
            throw error(strFmt("@Proj:FPRevRecProjectDefaultContractLineAssocationFailure", _fixedPriceRevRecProject.ProjId));
        }
        if (!_fixedPriceRevRecProject.ProjRevenueProfileId || _fixedPriceRevRecProject.ControlId == '' || _fixedPriceRevRecProject.PeriodId == '')
        {
            boolean updatedSuccessfully = ProjRevRecHelper::updateFixedPriceRevRecProjectWithRevProfileContractLine(_fixedPriceRevRecProject);

            if (!updatedSuccessfully)
            {
                throw error(strFmt("@Proj:FPRevRecProjectRevProfileAssociationFailure", _fixedPriceRevRecProject.ProjId));
            }
        }
        ProjRevRecInstrumentationLogger  logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlCalc));

        using (var activityContext = logger.revRecActivity().postContractLineBasedRevRec())
        {
            logger.logInformation(strFmt(@"prepareFixedPriceRevRecProjectWithRevProfileContractLine::%1 done for
                WipProjId: %2
                DefaultProject: %3
                DefaultContractLineNum: %4
                ProjRevenueProfileId: %5
                ControlId: %6
                PeriodId: %7",
                ProjRevRecInstrumentationActivities::ContractLineBasedRevRec,
                _fixedPriceRevRecProject.ProjId,
                _fixedPriceRevRecProject.DefaultProject,
                _fixedPriceRevRecProject.DefaultContractLineNum,
                _fixedPriceRevRecProject.ProjRevenueProfileId,
                _fixedPriceRevRecProject.ControlId,
                _fixedPriceRevRecProject.PeriodId));
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFixedPriceRevRecProjectWithRevProfileContractLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates revenue profile on the given fixed price contract line based rev rec project
    /// </summary>
    /// <param name = "_fixedPriceRevRecProject"><c>ProjWIPTable</c> record.</param>
    /// <param name = "_throwErrorOnMissingRevProf">true if error should be thrown for missing revenue profile.</param>
    /// <returns>true if operation was successful; otherwise false.</returns>
    protected internal static boolean updateFixedPriceRevRecProjectWithRevProfileContractLine(ProjWIPTable _fixedPriceRevRecProject, boolean _throwErrorOnMissingRevProf = false)
    {
        boolean ret = false;

        if(!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() || !_fixedPriceRevRecProject || !_fixedPriceRevRecProject.IsContractLineUsed || _fixedPriceRevRecProject.DefaultProject == '' || _fixedPriceRevRecProject.DefaultContractLineNum == '')
        {
            throw error(strFmt("@SYS22828",funcName()));           
        }
       
        // Lookup ProjRevenueProfileRule only if the field is empty.
        ProjRevenueProfile revProfile;
        if (!_fixedPriceRevRecProject.ProjRevenueProfileId)
        {
            ProjTable projTable = ProjTable::find(_fixedPriceRevRecProject.DefaultProject);
            PSAContractLineItems contractLine = PSAContractLineItems::find(_fixedPriceRevRecProject.DefaultContractLineNum);

            ProjRevenueProfileRule revProfileRule = ProjRevenueProfileRule::matchProfileRule(contractLine.ProjInvoiceProjId,
                                                                                        projTable.ProjId,
                                                                                        projTable.ProjGroupId,
                                                                                        contractLine.BillingMethod,
                                                                                        contractLine.ContractLineGroupRefRecId);
            if (!revProfileRule)
            {
                return  checkFailed(strFmt("@Proj:RevenueProfileRule_MissingRuleErrorContractLine", _fixedPriceRevRecProject.ProjId, any2Str(ProjContractBillingMethod::FixedPrice), ProjContractLineGroup::findByRecId(contractLine.ContractLineGroupRefRecId).Name));
            }
            revProfile = ProjRevenueProfile::findByRevenueProfileId(revProfileRule.ProjRevenueProfileId);
        }
        else
        {
            revProfile = ProjRevenueProfile::findByRevenueProfileId(_fixedPriceRevRecProject.ProjRevenueProfileId);
        }

        if (revProfile && revProfile.CompletePrinciple != ProjCompletePrincip::NoWIP)
        {
            if (revProfile.CostTemplate == '' || revProfile.PeriodId == '')
            {
                return checkFailed(strFmt("@Proj:RevProfileMissingControlIdOrPeriodId", _fixedPriceRevRecProject.ProjId));
            }

            ttsbegin;
            _fixedPriceRevRecProject.selectForUpdate(true);
            _fixedPriceRevRecProject.ControlId = revProfile.CostTemplate;
            _fixedPriceRevRecProject.PeriodId = revProfile.PeriodId;
            _fixedPriceRevRecProject.ProjRevenueProfileId = revProfile.ProjRevenueProfileId;

            if(_fixedPriceRevRecProject.validateWrite(false))
            {
                _fixedPriceRevRecProject.update();
                ret = true;
            }
            ttscommit;
        }
        else if (_throwErrorOnMissingRevProf)
        {
            return checkFailed(strFmt("@Proj:FPRevRecProjectRevProfileAssociationFailure", _fixedPriceRevRecProject.ProjId));
        }
        

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeFixedPriceRevRecProjectIfValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the fixed price revenue recognition project for the given <c>ProjTable</c> record if the operation is valid.
    /// </summary>
    /// <param name = "_projTable">Project for which wip project needs to be deleted.</param>
    protected internal static void removeFixedPriceRevRecProjectIfValid(ProjTable _projTable)
    {
        if (_projTable.WIPProject && !ProjMultipleContractLinesForProjectFeatureHelper::projectContainsFixedPriceComponent(_projTable.ProjId))
        {
            ttsbegin;
            ProjWIPTable wipProj = ProjWIPTable::find(_projTable.WIPProject, true);

            // If no other projects are associated with the Revenue Project, the Revenue Project can be deleted
            if (wipProj && !wipProj.getAnotherAssociatedProject(_projTable.ProjId))
            {
                if (ProjRevRecContractValidationFlight::instance().isEnabled()
                    && !ProjRevRecHelper::allowRevRecProjectChange(_projTable.WIPProject, _projTable.ProjId))
                {
                    warning(strFmt("@Proj:ProjRevProjectChangeError", _projTable.WIPProject, _projTable.ProjId));
                }
                else
                {
                    wipProj.delete();
                }
            }
            // If the last milestone is removed, revert the project back to the state before milestones were added by removing WIPProject value
            else
            {
                if (ProjRevRecContractValidationFlight::instance().isEnabled()
                    && !ProjRevRecHelper::allowRevRecProjectChange(_projTable.WIPProject, _projTable.ProjId))
                {
                    warning(strFmt("@Proj:ProjRevProjectChangeError", _projTable.WIPProject, _projTable.ProjId));
                }
                else
                {
                    _projTable.selectForUpdate(true);
                    _projTable.WIPProject = '';
                    _projTable.update();
                }
            }
            ttscommit;
        }
	}

]]></Source>
			</Method>
			<Method>
				<Name>removeFixedPriceRevRecProjectContractLine</Name>
				<Source><![CDATA[
    protected internal static void removeFixedPriceRevRecProjectContractLine(PSAContractLineNum _psaContractLineNum)
    {
        boolean ret = false;

        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled())
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        PSAContractLineItems psaContractLineItems = PSAContractLineItems::find(_psaContractLineNum);

        if(!psaContractLineItems.RecId)
        {
            throw error("@PSA3119");
        }
        ProjRevRecContractLine projRevRecContractLine = ProjRevRecContractLine::findByContractLineNum(_psaContractLineNum);
        
        if(!projRevRecContractLine)
        {
            throw Global::error(strFmt("@Proj::ProjREPDoesntExistForContractLine", projRevRecContractLine.ContractLineNum));
        }

        ProjWipId wipId = projRevRecContractLine.RevenueRecognitionId;
        ProjWIPTable wipProject = ProjWIPTable::find(wipId, true);

        if(!wipProject.IsContractLineUsed)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        // Delete the associattion if possible.
        ProjRevRecContractLine::deleteByContractLineNum(_psaContractLineNum);

        // If _psaContractLineNum is associated to other WIP Project, throw error : unexpected state.
        select firstonly projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId != wipId
            && projRevRecContractLine.ContractLineNum == _psaContractLineNum;

        if(projRevRecContractLine.RecId)
        {
            throw error(strFmt("@Proj::ProjAnotherREPExistsForContractLine",projRevRecContractLine.RevenueRecognitionId,_psaContractLineNum));
        }

        // If no other contract lines are associated to this WIP project, delete the WIP Project.
        select firstonly projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == wipId;
        if(!projRevRecContractLine.RecId)
        {
            wipProject.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonDeductionOrNotAdjustedDeductionInvoicedWithMilestone</Name>
				<Source><![CDATA[
    protected internal static boolean isNonDeductionOrNotAdjustedDeductionInvoicedWithMilestone(ProjOnAccTransSale _projOnAccTransSale)
    {
        ProjInvoiceOnAcc projInvoiceOnAcc;
        ProjInvoiceOnAccDetail projInvoiceOnAccDetail;
        ProjOnAccTrans projOnAccTrans;
        ProjOnAccTransSale projOnAccTransSale;
        boolean ret = false;

        select firstonly ProjId, TransactionOrigin from projOnAccTrans
            where projOnAccTrans.TransId == _projOnAccTransSale.TransId;

        ProjId projIdLocal = projOnAccTrans.ProjId;
        if (projOnAccTrans.TransactionOrigin != ProjOrigin::Deduction)
        {
            ret = true;
        }
        else
        {
            // Step 1:  find ProjInvoiceId of _projOnAccTransSale.
            select firstonly RecId from projInvoiceOnAccDetail
                    where projInvoiceOnAccDetail.SaleRefRecId == _projOnAccTransSale.RecId
                join ProjInvoiceId from projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId;

            ProjInvoiceId projInvoiceId = projInvoiceOnAcc.ProjInvoiceId;
            projInvoiceOnAcc.clear();
            projInvoiceOnAccDetail.clear();

            // Step 2: Find if any other milestone, UnitOfDelivery or Progress type billingmehtod is invoiced together with same deduction
            if (projInvoiceId)
            {
                select firstonly RecId from projOnAccTrans
                    where projOnAccTrans.ProjID == projIdLocal
                        && (projOnAccTrans.TransactionOrigin == ProjOrigin::Milestone
                            || projOnAccTrans.TransactionOrigin == ProjOrigin::UnitOfDeliveryBillingRule
                            || projOnAccTrans.TransactionOrigin == ProjOrigin::ProgressBillingRule)
                    join RecId from projOnAccTransSale
                        where projOnAccTransSale.TransId == projOnAccTrans.TransId
                    join RecId from projInvoiceOnAccDetail
                        where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                    join RecId from projInvoiceOnAcc
                        where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId
                            && projInvoiceOnAcc.ProjInvoiceId == projInvoiceId;
            }
            

            ret = (projInvoiceOnAcc.RecId) ? false : true;
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowRevRecProjectChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether to allow changing the Revenue Project for a given Project. There must not be any estimates for a project's assigned Revenue Project in a
    /// Created, Posted, or Eliminated state before being able to unassign the revenue project. Also, no estimates in a Created or Eliminated state can exist
    /// for the targeted Revenue Project.
    /// </summary>
    /// <param name = "_currentProjWIP">Project's assigned Revenue Project from which you are wanting to change the Revenue Project.</param>
    /// <param name = "_toWIPProject">Revenue Project you are wanting to change the project to be assigned to.</param>
    /// <returns>true if the project can be changed to a Revenue project, otherwise, false.</returns>
    public static boolean allowRevRecProjectChange(ProjWIPId _currentProjWIP, ProjWipId _toWIPProject)
    {
        ProjControlPeriodTable fromWIPProj_ProjControlPeriodTable;
        ProjControlPeriodTable toWIPProj_ProjControlPeriodTable;

        select firstonly RecId from fromWIPProj_ProjControlPeriodTable
            where fromWIPProj_ProjControlPeriodTable.ProjId == _currentProjWIP
                && (fromWIPProj_ProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Created
                    || fromWIPProj_ProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted
                    || fromWIPProj_ProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Eliminate);

        select firstonly RecId from toWIPProj_ProjControlPeriodTable
            where toWIPProj_ProjControlPeriodTable.ProjId == _toWIPProject
                && (toWIPProj_ProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Created
                    || toWIPProj_ProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Eliminate);

        return (!fromWIPProj_ProjControlPeriodTable.RecId && !toWIPProj_ProjControlPeriodTable.RecId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>