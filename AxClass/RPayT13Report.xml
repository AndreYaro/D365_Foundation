<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RPayT13Report</Name>
	<SourceCode>
		<Declaration><![CDATA[
final class RPayT13Report extends XmlExcelReport_RU implements BatchRetryable
{
    RPayTblJournal                  rPayTblJournal;
    RPayTblTrans                    rPayTblTrans;
    DocumentDate                    documentDate;
    boolean                         printCorrections;
    RHRMEmplTable                   emplTable;

    DialogField                     dialogDocumentDate;
    DialogField                     dialogPrintCorrections;

    int                             lastMthDay;
    QueryRun                        queryRun;

    boolean                         correction;
    RPayCalendarTable               rPayCalendarTable;
    int                             stateCurrent;
    int                             rowNumber;

    #define.Holidays("Ð’")

    #define.CurrentVersion(2)
    #localmacro.CurrentList
        documentDate,
        printCorrections
    #endmacro

    #RpayTblConstants

    #define.StateStart              (1)
    #define.StateStartFromNewPage   (2)
    #define.StatePrint              (3)
    #define.StateEnd                (4)

    #define.MaxPayTypes(8)
    #define.MaxAbsences(8)

    #define.FileName('RPayT13Report')

    #define.WidthPage(256)

    #define.NewPage("NewPage") //pseudo section used to define new page action
    #define.ReportHeader('ReportHeader')
    #define.PageHeader('PageHeader')
    #define.Body('Body')
    #define.ReportFooter('ReportFooter')

    #define.CompanyName('CompanyName')
    #define.CompanyOKPO('CompanyOKPO')
    #define.DocumentNum('DocumentNum')
    #define.DocumentDate('DocumentDate')
    #define.HRMOrganization('HRMOrganization')
    #define.StartPeriodDate('StartPeriodDate')
    #define.EndPeriodDate('EndPeriodDate')

    #define.ResponsibleTitle('ResponsibleTitle')
    #define.ResponsibleName('ResponsibleName')
    #define.OrganizationLeadTitle('OrganizationLeadTitle')
    #define.OrganizationLeadName('OrganizationLeadName')
    #define.PersonnelServiceEmployeeTitle('PersonnelServiceEmployeeTitle')
    #define.PersonnelServiceEmployeeName('PersonnelServiceEmployeeName')

    #define.EmplNo('EmplNo')
    #define.EmplNameTitle('EmplNameTitle')
    #define.EmplId('EmplId')

    #define.TimeCodeName('TimeCodeName_')
    #define.Time('Time_')

    #define.HalfTotalDays1('HalfTotalDays1')
    #define.HalfTotalHours1('HalfTotalHours1')
    #define.HalfTotalDays2('HalfTotalDays2')
    #define.HalfTotalHours2('HalfTotalHours2')
    #define.TotalDays('TotalDays')
    #define.TotalHours('TotalHours')

    #define.PayType('PayType_')
    #define.MainAccount('MainAccount_')
    #define.DayHour('DayHour_')

    #define.AbsenceName('AbsenceName_')
    #define.AbsenceDayHour('AbsenceDayHour_')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the absence days/hours.
    /// </summary>
    /// <param name="_tblTimeCode">
    /// The time code.
    /// </param>
    /// <param name="_rPayTblTrans">
    /// The timesheet.
    /// </param>
    /// <param name="_tmpCont">
    /// The temporary container.
    /// </param>
    /// <param name="_absenceAddDayHourMap">
    /// The map containing time codes to add.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    void calcAbsence(
        RPayTblTimeCode _tblTimeCode,
        RPayTblTrans    _rPayTblTrans,
        container       _tmpCont,
        Map             _absenceAddDayHourMap)
    {
        int                     j;
        RPayTblTimeTable        rPayTblTimeTable;
        RPayTblSpecTimeTable    rPayTblSpecTimeTable;
        RPayTblSpecTimeTrans    rPayTblSpecTimeTrans;
        container               specTimeIntervals;
        TransDate               eventStartDate;
        TransDate               eventEndDate;
        RPayTblDayHour          dayHours;
        TransDate               dayDate;
        RPayCalendarTable       rPayCalendarTable7days = RPayCalendarTable::findCalendarType(RPayCalendarType::SevenDays);
        RPayCalendarDate        rPayCalendarDate7days;
        Days                    days;

        rPayTblSpecTimeTable = RPayTblSpecTimeTable::findTimeCode(_tblTimeCode);

        if (rPayTblSpecTimeTable)
        {
            rPayTblSpecTimeTrans = RPayTblSpecTimeTrans::construct(
                rPayTblSpecTimeTable.RpayTblSpecTimeType,
                RHRMEmplTable::find(_rPayTblTrans.EmplId),
                dateStartMth(_rPayTblTrans.SourceDate),
                dateEndMth(_rPayTblTrans.SourceDate),
                rPayTblSpecTimeTable.RpayCalendarTimeCode);

            if (rPayTblSpecTimeTrans.isDefaultJournal(_rPayTblTrans))
            {
                specTimeIntervals = rPayTblSpecTimeTrans.getPeriodIntervals();

                rPayTblTimeTable = RPayTblTimeTable::find(RPayTblJournal.PayFormType, rPayTblSpecTimeTable.RpayCalendarTimeCode);

                for (j = 1; j <= conlen(specTimeIntervals); j ++)
                {
                    [eventStartDate, eventEndDate] = conpeek(specTimeIntervals, j);

                    for (dayDate = eventStartDate; dayDate <= eventEndDate; dayDate ++)
                    {
                        dayHours = conpeek(_tmpCont, dayOfMth(dayDate));

                        if (! dayHours)
                        {
                            rPayCalendarDate7days = RPayCalendarDate::find(rPayCalendarTable7days.CalendarId, dayDate);

                            if (rPayCalendarDate7days)
                            {
                                if (rPayCalendarDate7days.PayDayType == RPayDayType::WorkDay) // not a holiday
                                {
                                    _tmpCont = conpoke(_tmpCont, dayOfMth(dayDate), rPayCalendarTable.T13HoursPerDay);

                                    if (_absenceAddDayHourMap.exists(rPayTblTimeTable.PayTblTimeCode))
                                    {
                                        [days, dayHours] =  _absenceAddDayHourMap.lookup(rPayTblTimeTable.PayTblTimeCode);
                                        days             += 1;
                                        dayHours         += rPayCalendarTable.T13HoursPerDay;
                                    }
                                    else
                                    {
                                        [days, dayHours] = [1, rPayCalendarTable.T13HoursPerDay];
                                    }

                                    _absenceAddDayHourMap.insert(rPayTblTimeTable.PayTblTimeCode, [days, dayHours]);
                                }
                            }
                            else
                            {
                                warning(strFmt("@RUP2689", dayDate, rPayCalendarTable7days.CalendarId));
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRangeHeight</Name>
				<Source><![CDATA[
    protected real calcRangeHeight(Bookmark _bookmark)
    {
        #define.minHeight(14.4)

        return #minHeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReport</Name>
				<Source><![CDATA[
    protected void createReport()
    {
        boolean         dataExists = false;
        RPayTblJournal  rPayTblJournalOrig;

        rPayTblJournalOrig.data(rPayTblJournal);

        this.initSectionMap();

        this.setCurrentWorksheetNum(1, #WidthPage);

        this.initData();

        while (queryRun.next())
        {
            if (!dataExists)
            {
                stateCurrent = #StateStart;
                dataExists = true;
            }

            rPayTblTrans = queryRun.get(tablenum(RPayTblTrans));

            this.handleAction(this.defineActionSeq());
        }

        if (dataExists)
        {
            stateCurrent = #StateEnd;
            this.handleAction(this.defineActionSeq());
        }

        if (printCorrections)
        {
            this.printCorrections(dataExists, rPayTblJournalOrig);
        }

        this.setPrintArea();
    }

]]></Source>
			</Method>
			<Method>
				<Name>defineActionSeq</Name>
				<Source><![CDATA[
    private container defineActionSeq()
    {
        container   con;

        if (stateCurrent == #StateStart ||
            stateCurrent == #StateStartFromNewPage)
        {
            rowNumber = 1;

            if (stateCurrent == #StateStartFromNewPage)
            {
                con = [#NewPage];
            }

            con += [#ReportHeader, #PageHeader, #Body];

            stateCurrent = #StatePrint;
        }
        else if (stateCurrent == #StatePrint)
        {
            if (this.mustCreateNewPage())
            {
                con = [#NewPage, #PageHeader];
            }

            con += [#Body];
        }
        else if (stateCurrent == #StateEnd)
        {
            con = [#ReportFooter];
        }

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase dialog;

        dialog = super();

        dialogDocumentDate = dialog.addFieldValue(extendedTypeStr(DocumentDate), documentDate, "@GLS106243");

        dialogPrintCorrections = dialog.addField(extendedTypeStr(NoYesId), "@RUP6214", "@RUP6215");

        if (!this.existsCorrectedTblTrans())
        {
            printCorrections = false;
            dialogPrintCorrections.allowEdit(false);
        }

        dialogPrintCorrections.value(printCorrections);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsCorrectedTblTrans</Name>
				<Source><![CDATA[
    private boolean existsCorrectedTblTrans()
    {
        RPayTblTrans rPayTblTransLoc;

        select firstOnly RecId from rPayTblTransLoc
            where rPayTblTransLoc.PayTblNum == rPayTblJournal.TblNum &&
                  rPayTblTransLoc.SourceDate != rPayTblJournal.TblDate;
        return rPayTblTransLoc.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileName</Name>
				<Source><![CDATA[
    protected Filename fileName()
    {
        return #FileName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileNamePostfix</Name>
				<Source><![CDATA[
    protected Filename fileNamePostfix()
    {
        return '_' + curUserId() + '_' + strRem(DateTimeUtil::toStr(DateTimeUtil::utcNow()), ':');
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the report body.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Calendar field should be filled in.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void fillBody()
    {
        RPayParameters          rPayParameters = RPayParameters::find();

        Map                     absenceAddDayHourMap;

        this.parmProgress().setText(strfmt("@SYS76758", "@RUP166",
                    rPayTblTrans.EmplId, RHRMEmplTable::find(rPayTblTrans.EmplId).name()));

        rPayCalendarTable = RPayCalendarTable::find(rPayTblTrans.PayCalendarId);

        if (! rPayCalendarTable.T13HoursPerDay)
        {
            throw error(strFmt("@RUP2690", rPayTblTrans.PayCalendarId, fieldpname(RPayCalendarTable, T13HoursPerDay)));
        }

        absenceAddDayHourMap = new Map(Types::String, Types::Container);

        this.insertValueToSection(#EmplNo, rowNumber);
        rowNumber++;

        this.insertValueToSection(#EmplNameTitle, RHRMEmplTable::emplId2Name(rPayTblTrans.EmplId) + '\n' + rPayTblTrans.titleId());
        this.insertValueToSection(#EmplId, rPayTblTrans.EmplId);

        if (rPayTblJournal.PayTblType == RPayTblType::EveryDay)
        {
            this.fillDataPerDays(absenceAddDayHourMap);
        }

        this.fillPayTypesAbsences();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillData</Name>
				<Source><![CDATA[
    protected void fillData(MSOfficeBookMark_RU _bookmark)
    {
        switch (_bookmark)
        {
            case #ReportHeader:
                this.fillReportHeader();
                break;

            case #Body:
                this.fillBody();
                break;

            case #ReportFooter:
                this.fillReportFooter();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDataPerDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the report data per days.
    /// </summary>
    /// <param name="_absenceAddDayHourMap">
    /// The absence days/hours map.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void fillDataPerDays(Map _absenceAddDayHourMap)
    {
        RPayTblJournal          rPayTblJournalLocal;
        RPayTblTrans            rPayTblTransLocal;
        RPayTblDayHourTrans     rPayTblDayHourTrans;
        RPayTblTimeTable        rPayTblTimeTable;
        int                     i;
        container               dayCont;
        container               tmpCont, cont = connull();
        Map                     dayMap;
        MapEnumerator           en;
        boolean                 oneRec;
        SysOperationProgress    op = new SysOperationProgress();
        str                     strDayTime;
        str                     strDayHour;
        str                     tmpStr, tmpStr1;
        int                     half_1_days;
        int                     half_1_hours;
        int                     half_2_days;
        int                     half_2_hours;
        container               halfDayCont;
        boolean                 isAbs;
        RPayParameters          rPayParameters = RPayParameters::find();

        void prepareHalfDay()
        {
            halfDayCont = conNull();
            for (i = 1; i <= lastMthDay; i++)
            {
                halfDayCont += false;
            }
        }

        void fillDayHour(real _mul)
        {
            fieldId tmpFieldId;

            for (i = 1; i <= lastMthDay; i++)
            {
                tmpFieldId = fieldname2id(tablenum(RPayTblDayHourTrans), #DayHourTransFieldPrefix + int2str(i));

                if (! this.isAbsence(rPayTblDayHourTrans.PayTblTimeCode))
                {
                    if (i <= 15)
                    {
                        half_1_hours += rPayTblDayHourTrans.(tmpFieldId);
                        half_1_days++;
                    }
                    else
                    {
                        half_2_hours += rPayTblDayHourTrans.(tmpFieldId);
                        half_2_days++;
                    }
                }

                tmpCont = conins(tmpCont, i, rPayTblDayHourTrans.(tmpFieldId) + _mul*conpeek(cont, i));
            }
        }

        dayMap = new Map(Types::String, Types::Container);

        oneRec = true;

        half_1_hours = 0;
        half_2_hours = 0;

        while select rPayTblTransLocal
            where rPayTblTransLocal.EmplId        == rPayTblTrans.EmplId        &&
                  rPayTblTransLocal.PayCalendarId == rPayTblTrans.PayCalendarId &&
                  rPayTblTransLocal.HcmTitle      == rPayTblTrans.HcmTitle      &&
                  rPayTblTransLocal.SourceDate    == rPayTblTrans.SourceDate
        join rPayTblDayHourTrans
            where rPayTblDayHourTrans.TblTransRecId == rPayTblTransLocal.RecId
        exists join rPayTblJournalLocal
            where ((rPayTblJournalLocal.TblNum            == rPayTblTransLocal.PayTblNum &&
                    rPayTblJournalLocal.HrmOrganizationId == rPayTblJournal.HrmOrganizationId &&
                    rPayTblJournalLocal.PayFormType       == rPayTblJournal.PayFormType &&
                    rPayTblJournalLocal.TblDate           >= rPayTblJournal.TblDate &&
                    rPayTblJournalLocal.TblDate           <= max(rPayTblJournal.TblDate, endmth(documentDate))) || correction)
        {
            tmpCont = conNull();

            if (dayMap.exists(rPayTblDayHourTrans.PayTblTimeCode))
            {
                cont = conNull();
                cont = dayMap.lookup(rPayTblDayHourTrans.PayTblTimeCode);
                dayMap.remove(rPayTblDayHourTrans.PayTblTimeCode);
                fillDayHour(1);
            }
            else
            {
                fillDayHour(0);
            }

            if (this.isAbsence(rPayTblDayHourTrans.PayTblTimeCode))
            {
                this.calcAbsence(
                    rPayTblDayHourTrans.PayTblTimeCode,
                    rPayTblTransLocal,
                    tmpCont,
                    _absenceAddDayHourMap);
            }

            dayMap.insert(rPayTblDayHourTrans.PayTblTimeCode, tmpCont);

            oneRec = false;
        }

        oneRec = true;
        prepareHalfDay();
        en     = dayMap.getEnumerator();

        while (en.moveNext())
        {
            rPayTblTimeTable = RPayTblTimeTable::find(rPayTblJournal.PayFormType, en.currentKey());
            tmpStr = '';
            tmpStr = strfmt("@GLS106745", rPayTblTimeTable.T13TimeCodeName);

            tmpCont = en.currentValue();

            isAbs = this.isAbsence(en.currentKey());

            if (oneRec)
            {
                for (i = 1; i <= lastMthDay; i++)
                {
                    if (conpeek(tmpCont,i))
                    {
                        dayCont = conins(dayCont, 2*i - 1, tmpStr);
                        dayCont = conins(dayCont, 2*i, num2str(conpeek(tmpCont, i), 1, 0, 1, 0));

                        if (! isAbs)
                        {
                            halfDayCont = conpoke(halfDayCont, i, true);
                        }
                    }
                    else
                    {
                        dayCont = conins(dayCont, 2*i - 1, #Holidays);
                        dayCont = conins(dayCont, 2*i, '');
                    }
                }
            }
            else
            {
                for (i = 1; i <= lastMthDay; i++)
                {
                    if (conpeek(tmpCont,i))
                    {
                        strDayTime = conpeek(dayCont, 2*i - 1);
                        strDayHour = conpeek(dayCont,  2*i);

                        if (strDayTime != #Holidays)
                        {
                            tmpStr1    = strfmt("@GLS110628", strDayTime, tmpStr);
                            strDayHour = strfmt("@GLS110628",strDayHour, num2str(conpeek(tmpCont, i), 1, 0, 1, 0));
                        }
                        else
                        {
                            tmpStr1    = strfmt("@GLS106745", tmpStr);
                            strDayHour = strfmt("@GLS106745", num2str(conpeek(tmpCont, i), 1, 0, 1, 0));
                        }
                        dayCont = conpoke(dayCont, 2*i - 1, tmpStr1);
                        dayCont = conpoke(dayCont, 2*i, strDayHour);
                        strDayTime  = '';
                        strDayHour  = '';
                        tmpStr1     = '';

                        if ((!isAbs) && (!conpeek(halfDayCont, i)))
                        {
                            halfDayCont = conpoke(halfDayCont, i, true);
                        }
                    }
                }
            }
            oneRec = false;
        }

        half_1_days  = 0;
        half_2_days  = 0;
        for (i = 1; i <= 15; i++)
        {
            if (conpeek(halfDayCont, i))
            {
                half_1_days++;
            }
        }

        for (i = 16; i <= lastMthDay; i++)
        {
            if (conpeek(halfDayCont, i))
            {
                half_2_days++;
            }
        }
        dayCont = conins(dayCont, 2*lastMthDay+1, num2str(half_1_days,1,0,1,0));
        dayCont = conins(dayCont, 2*lastMthDay+2, num2str(half_1_hours,1,0,1,0));
        dayCont = conins(dayCont, 2*lastMthDay+3, num2str(half_2_days,1,0,1,0));
        dayCont = conins(dayCont, 2*lastMthDay+4, num2str(half_2_hours,1,0,1,0));
        dayCont = conins(dayCont, 2*lastMthDay+5, num2str(half_1_days+half_2_days,1,0,1,0));
        dayCont = conins(dayCont, 2*lastMthDay+6, num2str(half_1_hours + half_2_hours,1,0,1,0));

        this.fillDays(rowNumber, dayCont);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDays</Name>
				<Source><![CDATA[
    #define.MaxDays(31)
    private void fillDays(int _rowNumber, container _daysContent)
    {
        int     cnt, gbl;
        str     timeCodeNameValue, timeValue;

        gbl = 4;

        for (cnt = 1; cnt <= #MaxDays; cnt++)
        {
            if (cnt <= lastMthDay)
            {
                timeCodeNameValue = conpeek(_daysContent, 2*cnt - 1);
                timeValue = conpeek(_daysContent, 2*cnt);
            }
            else
            {
                timeCodeNameValue = '';
                timeValue = '';
            }

            this.insertValueToSection(#TimeCodeName + int2str(cnt), timeCodeNameValue);
            this.insertValueToSection(#Time + int2str(cnt), timeValue);
        }

        gbl = 2 * lastMthDay + 1;

        this.insertValueToSection(#HalfTotalDays1, conpeek(_daysContent, gbl));
        gbl++;
        this.insertValueToSection(#HalfTotalHours1, conpeek(_daysContent, gbl));
        gbl++;
        this.insertValueToSection(#HalfTotalDays2, conpeek(_daysContent, gbl));
        gbl++;
        this.insertValueToSection(#HalfTotalHours2, conpeek(_daysContent, gbl));
        gbl++;

        this.insertValueToSection(#TotalDays, conpeek(_daysContent, gbl));
        gbl++;
        this.insertValueToSection(#TotalHours, conpeek(_daysContent, gbl));
        gbl++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillEmloyeeLine</Name>
				<Source><![CDATA[
    private void fillEmloyeeLine(KeySum _payTypesKeySum, KeySum _absencesKeySum)
    {
        int             i;
        container       key, value;
        str             dayHourStr;
        RPayCostType    payCostType;
        str             ledgerAccount, absenceName;

        for (i = 1; i <= #MaxPayTypes; i++)
        {
            if (i > _payTypesKeySum.numOfTrans())
            {
                payCostType = '';
                ledgerAccount = '';
                dayHourStr = '';
            }
            else
            {
                key = _payTypesKeySum.index2Key(i);
                value = _payTypesKeySum.index2Data(i);

                payCostType = conPeek(key, 1);
                ledgerAccount = conPeek(key, 2);
                dayHourStr = strFmt(
                                "@GLS110629",
                                num2str(conPeek(value, 1), 1, 0, 1, 0),
                                num2str(conPeek(value, 2), 1, 0, 1, 0));
            }

            this.insertValueToSection(#PayType + int2str(i), payCostType);
            this.insertValueToSection(#MainAccount + int2str(i), ledgerAccount);

            this.insertValueToSection(#DayHour + int2str(i), dayHourStr);
        }

        for (i = 1; i <= #MaxAbsences; i++)
        {
            if (i > _absencesKeySum.numOfTrans())
            {
                absenceName = '';
                dayHourStr = '';
            }
            else
            {
                key = _absencesKeySum.index2Key(i);
                value = _absencesKeySum.index2Data(i);
                absenceName = conPeek(key, 1);
                dayHourStr = strFmt(
                                "@GLS110629",
                                num2str(conPeek(value, 1), 1, 0, 1, 0),
                                num2str(conPeek(value, 2), 1, 0, 1, 0));
            }

            this.insertValueToSection(#AbsenceName + int2str(i), absenceName);

            this.insertValueToSection(#AbsenceDayHour + int2str(i), dayHourStr);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPayTypesAbsences</Name>
				<Source><![CDATA[
    private void fillPayTypesAbsences()
    {
        RPayCalendarTimeTrans   rPayCalendarTimeTrans;
        RPayTblTimeTable        rPayTblTimeTable;
        RPayTblJournal          rPayTblJournalLoc, rPayTblJournalLoc2;
        RPayTblTrans            rPayTblTransLoc, rPayTblTransLoc2;
        RPayTblTimeCode         rPayTblTimeCode;
        container               tmpCont;
        int                     payTypesQnt, absenceQnt;
        container               payTypesKey;
        RPayTblDayHour          dayHours;
        Days                    days;
        RPayCostType            rPayCostType;
        RPayTrans               rPayTrans;
        LedgerJournalACType     ledgerJournalACType;
        DimensionDynamicAccount ledgerDimension;
        RPaytitleposting        rPaytitleposting;
        KeySum                  payTypesKeySum = KeySum::construct(2, 2),
                                absencesKeySum = KeySum::construct(1, 2);
        Map                     absenceAddDayHourMap = new Map(Types::String, Types::Container);

        while select sum(Day), sum(Hour) from rPayCalendarTimeTrans
            group by PayCalendarTimeCode
        exists join rPayTblTransLoc
            where rPayTblTransLoc.RecId         == rPayCalendarTimeTrans.TblTransRecId &&
                  rPayTblTransLoc.EmplId        == rPayTblTrans.EmplId &&
                  rPayTblTransLoc.SourceDate    == rPayTblTrans.SourceDate &&
                  rPayTblTransLoc.HcmTitle      == rPayTblTrans.HcmTitle &&
                  rPayTblTransLoc.PayCalendarId == rPayTblTrans.PayCalendarId
        exists join rPayTblJournalLoc
            where ((rPayTblJournalLoc.TblNum            == rPayTblTransLoc.PayTblNum &&
                    rPayTblJournalLoc.HrmOrganizationId == rPayTblJournal.HrmOrganizationId &&
                    rPayTblJournalLoc.PayFormType       == rPayTblJournal.PayFormType &&
                    rPayTblJournalLoc.TblDate           >= rPayTblJournal.TblDate &&
                    rPayTblJournalLoc.TblDate           <= max(rPayTblJournal.TblDate, endmth(documentDate))) || correction)
        {
            if (rPayCalendarTimeTrans.Hour != 0 || rPayCalendarTimeTrans.Day != 0)
            {
                rPayTblTimeCode = rPayCalendarTimeTrans.PayCalendarTimeCode;

                if (this.isAbsence(rPayTblTimeCode))
                {
                    if (rPayTblJournal.PayTblType != RPayTblType::EveryDay)
                    {
                        tmpCont = connull();
                        this.calcAbsence(rPayTblTimeCode, rPayTblTrans, tmpCont, absenceAddDayHourMap);
                    }

                    if (absenceQnt <= #MaxAbsences)
                    {
                        rPayTblTimeTable = RPayTblTimeTable::find(RPayTblJournal.PayFormType, rPayTblTimeCode);

                        if (absenceAddDayHourMap.exists(rPayTblTimeTable.PayTblTimeCode))
                        {
                            [days, dayHours] = absenceAddDayHourMap.lookup(rPayTblTimeTable.PayTblTimeCode);
                        }
                        else
                        {
                            [days, dayHours] = [0, 0];
                        }

                        absencesKeySum.updateNow([rPayTblTimeTable.T13TimeCodeName], [(rPayTblJournal.PayTblType == RPayTblType::EveryDay ? rPayCalendarTimeTrans.Day  : 0) + days,
                                                                                      (rPayTblJournal.PayTblType == RPayTblType::EveryDay ? rPayCalendarTimeTrans.Hour : 0) + dayHours]);
                        absenceQnt++;
                    }
                }
                else
                {
                    if (payTypesQnt <= #MaxPayTypes)
                    {
                        rPayCostType = this.getCostType(rPayTblTimeCode);
                        payTypesKey  = [rPayCostType];

                        while select RecId From rPayTblTransLoc2
                            where rPayTblTransLoc2.EmplId        == rPayTblTrans.EmplId        &&
                                  rPayTblTransLoc2.PayCalendarId == rPayTblTrans.PayCalendarId &&
                                  rPayTblTransLoc2.HcmTitle      == rPayTblTrans.HcmTitle      &&
                                  rPayTblTransLoc2.SourceDate    == rPayTblTrans.SourceDate
                        exists join rPayTblJournalLoc2
                            where ((rPayTblJournalLoc2.TblNum            == rPayTblTransLoc2.PayTblNum &&
                                    rPayTblJournalLoc2.HrmOrganizationId == rPayTblJournal.HrmOrganizationId &&
                                    rPayTblJournalLoc2.PayFormType       == rPayTblJournal.PayFormType &&
                                    rPayTblJournalLoc2.TblDate           >= rPayTblJournal.TblDate &&
                                    rPayTblJournalLoc2.TblDate           <= max(rPayTblJournal.TblDate, endmth(documentDate))) || correction)
                        {
                            select firstonly rPayTrans
                                where rPayTrans.SourceRecId == rPayTblTransLoc2.RecId &&
                                      rPayTrans.PayCtype    == rPayCostType;

                            if (rPayTrans)
                            {
                                ledgerJournalACType = rPayTrans.accountTypeDisplay();
                                ledgerDimension     = rPayTrans.ledgerDimensionDisplay();
                            }
                            else
                            {
                                rPayTitlePosting = RPayTitlePosting::findAccount(RPayParameters::find().AccountPostingProfile,
                                                                                 rPayCostType,
                                                                                 rPayTblTrans.EmplId,
                                                                                 rPayTblJournal.HrmOrganizationId,
                                                                                 rPayTblTrans.HcmTitle);
                                ledgerJournalACType = rPaytitleposting.AccountType;
                                ledgerDimension     = rPaytitleposting.LedgerDimension;
                            }

                            if (rPaytitleposting.AccountType == ledgerJournalACType && rPaytitleposting.LedgerDimension == ledgerDimension)
                            {
                                break;
                            }
                        }

                        payTypesKey += this.getLedgerAccount(ledgerDimension, ledgerJournalACType);
                        payTypesKeySum.updateNow(payTypesKey, [rPayCalendarTimeTrans.Day, rPayCalendarTimeTrans.Hour]);
                        payTypesQnt++;
                    }
                }
            }
        }

        this.fillEmloyeeLine(payTypesKeySum, absencesKeySum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillReportFooter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the report footer.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void fillReportFooter()
    {
        RHRMEmplTable   emplTableLocal;

        emplTableLocal = RHRMEmplTable::find(rPayTblJournal.Responsible);
        this.insertValueToSection(#ResponsibleTitle, emplTableLocal.titleId());
        this.insertValueToSection(#ResponsibleName, emplTableLocal.name());

        emplTableLocal = RHRMEmplTable::find(rPayTblJournal.OrganizationLead);
        this.insertValueToSection(#OrganizationLeadTitle, emplTableLocal.titleId());
        this.insertValueToSection(#OrganizationLeadName, emplTableLocal.name());

        emplTableLocal = RHRMEmplTable::find(rPayTblJournal.PersonnelServiceEmployee);
        this.insertValueToSection(#PersonnelServiceEmployeeTitle, emplTableLocal.titleId());
        this.insertValueToSection(#PersonnelServiceEmployeeName, emplTableLocal.name());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillReportHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the report header.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void fillReportHeader()
    {
        CompanyInfo companyInfo = CompanyInfo::find();

        this.insertValueToSection(#CompanyName, companyInfo.Name);
        this.insertValueToSection(#CompanyOKPO, CompanyInfoHelper::partyOKPOasOfDate_RU(companyInfo, documentDate));
        this.insertValueToSection(#DocumentNum, rPayTblJournal.TblNum);
        this.insertValueToSection(#DocumentDate, date2str(documentDate, 123, 2, 2, 2, 2, 4, DateFlags::None));
        this.insertValueToSection(#HRMOrganization, rPayTblJournal.organizationDescription());

        this.insertValueToSection(#StartPeriodDate, date2StrUsr(dateStartMth(rPayTblJournal.TblDate), DateFlags::None));
        this.insertValueToSection(#EndPeriodDate, date2StrUsr(rPayTblJournal.TblDate, DateFlags::None));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostType</Name>
				<Source><![CDATA[
    private RPayCostType getCostType(RPayTblTimeCode _rPayTblTimeCode)
    {
        RPayTblTimeTable    rPayTblTimeTable;
        RPaySeqTable        rPaySeqTable;
        RPayCounterTable    rPayCounterTable;

        select firstonly rPayTblTimeTable
            where rPayTblTimeTable.PayFormType    == rPayTblJournal.PayFormType &&
                  rPayTblTimeTable.PayTblTimeCode == _rPayTblTimeCode;

        if (! rPayTblTimeTable)
        {
            return '';
        }

        select firstonly rPaySeqTable
            where rPaySeqTable.Scanning == rPayTblTimeTable.PaySequence;

        if (! rPaySeqTable)
        {
            return '';
        }

        select firstonly rPayCounterTable
            where rPayCounterTable.Scanning == rPaySeqTable.Scanning;

        if (! rPayCounterTable)
        {
            return '';
        }

        return rPayCounterTable.Output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            documentDate = dialogDocumentDate.value();
            printCorrections = dialogPrintCorrections.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerAccount</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public LedgerJournalAC getLedgerAccount(DimensionDynamicAccount _ledgerDimension, LedgerJournalACType _accountType)
    {
        LedgerDimensionDefaultAccount   defaultAccount;

        try
        {
            switch (_accountType)
            {
                case LedgerJournalACType::Ledger :
                    defaultAccount = _ledgerDimension;
                    break;

                case LedgerJournalACType::Cust :
                    defaultAccount  = CustLedgerAccounts::summaryLedgerDimension(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension), '', false);
                    break;

                case LedgerJournalACType::Vend :
                    defaultAccount = VendLedgerAccounts::summaryLedgerDimension(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension), '', false);
                    break;

                case LedgerJournalACType::Bank :
                    defaultAccount = BankAccountTable::findLedgerDimension(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension));
                    break;

                case LedgerJournalACType::Employee_RU :
                    defaultAccount = EmplLedgerAccounts_RU::summaryLedgerDimension(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension), '', false);
                    break;

                case LedgerJournalACType::RCash :
                    defaultAccount = RCashLedgerAccount::summaryLedgerDimension(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension), '');
                    break;

                default:
                    defaultAccount = 0;
            }
        }
        catch (Exception::Error)
        {
            defaultAccount = 0;
        }

        if (defaultAccount)
        {
            return LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(defaultAccount);
        }
        else
        {
            return LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleAction</Name>
				<Source><![CDATA[
    private void handleAction(container _actions)
    {
        int i;

        for (i = 1; i <= conLen(_actions); ++i)
        {
            if (conPeek(_actions, i) == #NewPage)
            {
                this.newPage();
            }
            else
            {
                this.execute(conPeek(_actions, i));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initData</Name>
				<Source><![CDATA[
    private void initData()
    {
        lastMthDay = dayofmth(endmth(rPayTblJournal.TblDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryRun</Name>
				<Source><![CDATA[
    private void initQueryRun(boolean _correction = false)
    {
        QueryBuildDataSource    qbdsRPayTblTrans, qbdsRPayTblJournal;
        DictTable               dictTable = new DictTable(tablenum(RPayTblTrans));
        Query                   query;

        query = new Query();
        qbdsRPayTblTrans = query.addDataSource(tablenum(RPayTblTrans));

        qbdsRPayTblTrans.orderMode(OrderMode::GroupBy);
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, EmplId));
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, PayCalendarId));
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, HcmTitle));
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, SourceDate));

        if (!_correction)
        {
            qbdsRPayTblTrans.addRange(fieldnum(RPayTblTrans, SourceDate)).value(
                queryValue(endmth(rPayTblJournal.TblDate)));

            qbdsRPayTblJournal = qbdsRPayTblTrans.addDataSource(tableNum(RPayTblJournal));
            qbdsRPayTblJournal.addLink(fieldNum(RPayTblTrans, PayTblNum), fieldNum(RPayTblJournal, TblNum));
            qbdsRPayTblJournal.joinMode(JoinMode::ExistsJoin);

            qbdsRPayTblJournal.addRange(fieldNum(RPayTblJournal, HrmOrganizationId)).value(
                queryValue(rPayTblJournal.HrmOrganizationId));
            qbdsRPayTblJournal.addRange(fieldNum(RPayTblJournal, PayFormType)).value(
                queryValue(rPayTblJournal.PayFormType));
            qbdsRPayTblJournal.addRange(fieldNum(RPayTblJournal, TblDate)).value(
                SysQuery::range(rPayTblJournal.TblDate, max(rPayTblJournal.TblDate, endmth(documentDate))));
        }
        else
        {
            qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, PayTblNum));
            qbdsRPayTblTrans.addRange(fieldnum(RPayTblTrans, PayTblNum)).value(
                rPayTblJournal.TblNum);
            qbdsRPayTblTrans.addRange(fieldnum(RPayTblTrans, SourceDate)).value(
                SysQuery::valueNot(endmth(rPayTblJournal.TblDate)));
        }

        queryRun = new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryRunCorrection</Name>
				<Source><![CDATA[
    private QueryRun initQueryRunCorrection(container _packedEmplsData, RPayTblJournal _rPayTblJournalOrig, ReportPeriod_RU _sourceDate)
    {
        QueryBuildDataSource    qbdsRPayTblJournal, qbdsRPayTblTrans;
        DictTable               dictTable = new DictTable(tablenum(RPayTblTrans));
        Query                   query;
        RHRMEmplId              emplId;
        RPayCalendarId          rPayCalendarId;
        RHRMTitleRecId          hcmTitleId;
        Set                     emplsDataSet = Set::create(_packedEmplsData);
        SetEnumerator           se = emplsDataSet.getEnumerator();
        str                     range;

        query = new Query();
        qbdsRPayTblTrans = query.addDataSource(tablenum(RPayTblTrans));

        qbdsRPayTblTrans.orderMode(OrderMode::GroupBy);
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, EmplId));
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, PayCalendarId));
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, HcmTitle));
        qbdsRPayTblTrans.addSortField(fieldnum(RPayTblTrans, SourceDate));

        while (se.moveNext())
        {
            [emplId, rPayCalendarId, hcmTitleId] = se.current();

            if (range)
            {
                range += '||';
            }

            range += strFmt('((%1 == \"%2\") && (%3 == \"%4\") && (%5 == %6))',
                fieldstr(RPayTblTrans, EmplId),
                queryValue(emplId),
                fieldstr(RPayTblTrans, PayCalendarId),
                queryValue(rPayCalendarId),
                fieldstr(RPayTblTrans, HcmTitle),
                queryValue(hcmTitleId)
                );
        }

        qbdsRPayTblTrans.addRange(fieldnum(RPayTblTrans, EmplId)).value(range);
        qbdsRPayTblTrans.addRange(fieldnum(RPayTblTrans, SourceDate)).value(queryValue(_sourceDate));

        qbdsRPayTblJournal = qbdsRPayTblTrans.addDataSource(tableNum(RPayTblJournal));
        qbdsRPayTblJournal.addLink(fieldNum(RPayTblTrans, PayTblNum), fieldNum(RPayTblJournal, TblNum));
        qbdsRPayTblJournal.joinMode(JoinMode::ExistsJoin);

        qbdsRPayTblJournal.addRange(fieldNum(RPayTblJournal, HrmOrganizationId)).value(queryValue(_rPayTblJournalOrig.HrmOrganizationId));
        qbdsRPayTblJournal.addRange(fieldNum(RPayTblJournal, PayFormType)).value(queryValue(_rPayTblJournalOrig.PayFormType));

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSectionMap</Name>
				<Source><![CDATA[
    protected void initSectionMap()
    {
        this.addSection(#ReportHeader);
        this.addSection(#PageHeader);
        this.addSection(#Body);
        this.addSection(#ReportFooter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAbsence</Name>
				<Source><![CDATA[
    private boolean isAbsence(RPayCalendarTimeCode _rPayCalendarTimeCode)
    {
        RPayTimeGroupMember rPayTimeGroupMember;

        select firstonly RecId from rPayTimeGroupMember
            where rPayTimeGroupMember.TimeGroup           == rPayTblJournal.NonAppearenceGroupCode &&
                  rPayTimeGroupMember.PayCalendarTimeCode == _rPayCalendarTimeCode;

        return (rPayTimeGroupMember.RecId ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateNewPage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicator if new page should be created.
    /// </summary>
    /// <returns>
    /// True if new page should be created.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean mustCreateNewPage()
    {
        real        requiredHeight;

        requiredHeight = conPeek(mapSections.lookup(#Body), #posSectionHeight);
        requiredHeight += conPeek(mapSections.lookup(#ReportFooter), #posSectionHeight);

        return pageHeight - currentHeight < requiredHeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPage</Name>
				<Source><![CDATA[
    private void newPage()
    {
        document.insertPageBreak(currentRow);
        currentHeight = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRPayTblJournal</Name>
				<Source><![CDATA[
    private RPayTblJournal parmRPayTblJournal(RPayTblJournal _rPayTblJournal = rPayTblJournal)
    {
        rPayTblJournal.data(_rPayTblJournal);
        return rPayTblJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareDataForCorrection</Name>
				<Source><![CDATA[
    private Map prepareDataForCorrection()
    {
        Map         dataForCorrectionMap = new Map(Types::Date, Types::Class);//Map contains data like this SourcePeriod -> set of [EmplId, PayCalendarId, HCMTitle]
        Set         emplsData;
        container   emplsDataCon;

        this.initQueryRun(true);

        while (queryRun.next())
        {
            rPayTblTrans = queryRun.get(tablenum(RPayTblTrans));

            if (dataForCorrectionMap.exists(rPayTblTrans.SourceDate))
            {
                emplsData = dataForCorrectionMap.lookup(rPayTblTrans.SourceDate);
            }
            else
            {
                emplsData = new Set(Types::Container);
            }

            emplsDataCon = [rPayTblTrans.EmplId, rPayTblTrans.PayCalendarId, rPayTblTrans.HcmTitle];
            emplsData.add(emplsDataCon);

            dataForCorrectionMap.insert(rPayTblTrans.SourceDate, emplsData);
        }

        return dataForCorrectionMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printCorrections</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints corrections to the report.
    /// </summary>
    /// <param name="_dataExists">
    /// Original data exists - start new page.
    /// </param>
    /// <param name="_rPayTblJournalOrig">
    /// The timesheet journal table record.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void printCorrections(boolean _dataExists, RPayTblJournal _rPayTblJournalOrig)
    {
        boolean         dataExists = false;
        Map             correctionDataMap;
        MapEnumerator   me;
        TransDate       sourceDate;
        QueryRun        queryRunCorrection;
        boolean         originDataExists;
        Set             emplsDataSet;

        correction = true;
        correctionDataMap = this.prepareDataForCorrection();
        me = correctionDataMap.getEnumerator();
        originDataExists = _dataExists;

        while (me.moveNext())
        {
            sourceDate = me.currentKey();

            select firstOnly rPayTblJournal
                where rPayTblJournal.TblDate            == sourceDate &&
                      rPayTblJournal.HrmOrganizationId  == _rPayTblJournalOrig.HrmOrganizationId &&
                      rPayTblJournal.PayFormType        == _rPayTblJournalOrig.PayFormType;

            this.initData();

            emplsDataSet = me.currentValue();
            queryRunCorrection = this.initQueryRunCorrection(emplsDataSet.pack(), _rPayTblJournalOrig, sourceDate);
            dataExists = false;

            while (queryRunCorrection.next())
            {
                if (!dataExists)
                {
                    stateCurrent        = originDataExists ? #StateStartFromNewPage : #StateStart;
                    dataExists          = true;
                    originDataExists    = true;
                }

                rPayTblTrans = queryRunCorrection.get(tablenum(RPayTblTrans));

                this.handleAction(this.defineActionSeq());
            }

            if (dataExists)
            {
                stateCurrent = #StateEnd;
                this.handleAction(this.defineActionSeq());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    // can not be run on server because displays ms office report
    public boolean runsImpersonated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateName</Name>
				<Source><![CDATA[
    protected Filename templateName()
    {
        return resourceStr(RPayT13Report);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCells</Name>
				<Source><![CDATA[
    #define.ColsInTable(113)
    #define.Other(13)
    protected Counter totalCells()
    {
        return SysQuery::countLoops(queryRun) * #ColsInTable + #Other;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer     version     = conpeek(_packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static RPayT13Report construct(RPayTblJournal _rPayTblJournal)
    {
        RPayT13Report rPayT13Report;

        rPayT13Report = new RPayT13Report();

        rPayT13Report.parmRPayTblJournal(_rPayTblJournal);

        return rPayT13Report;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static ClassDescription description()
    {
        return "@RUP2096";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        RPayT13Report  rPayT13Report;

        if (! _args.record() || _args.record().TableId != tablenum(RPayTblJournal))
        {
            throw error("@GLS105816");
        }

        if (! RPayCalendarTable::findCalendarType(RPayCalendarType::SevenDays))
        {
            throw error(strFmt("@GLS106104", enum2str(RpayCalendarType::SevenDays)));
        }

        rPayT13Report = RPayT13Report::construct(_args.record());

        if (rPayT13Report.prompt())
        {
            rPayT13Report.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        this.initQueryRun();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }
]]></Source>
			</Method>
		<Method><Name>isRetryable</Name><Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }
]]></Source></Method></Methods>
	</SourceCode>
</AxClass>