<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjCostControl</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjCostControl extends RunBase
{
    ProjTransDate           projTransDateFrom;
    ProjTransDate           projTransDateTo;
    TransDate               ledgerTransDateFrom;
    TransDate               ledgerTransDateTo;

    boolean                 hour;
    boolean                 expenses;
    boolean                 item;

    boolean                 fixedPrice;
    boolean                 timeMaterial;
    boolean                 internalCost;
    boolean                 investment;
    boolean                 time;

    boolean                 projTree;

    ProjForecastModelId     projTotalForecastModelId;
    ProjForecastModelId     projOriginalForecastModelId;
    ProjForecastModelId     projRemainingForecastModelId;

    ProjRowDisplayType      showBy;
    ProjControlId           projCostTemplateId;

    Counter                 progressTotal;
    Counter                 progressCounter;
    boolean                 recordsFound;
    AmountCur               totalCostHourAmount;
    AmountCur               originalBudgetHourAmount;
    AmountCur               remainingBudgetHourAmount;
    AmountCur               committedHourAmount;
    AmountCur               actualHourAmount;
    AmountCur               totalHourQty;
    AmountCur               originalBudgetHourQty;
    AmountCur               remainingBudgetHourQty;
    AmountCur               committedHourQty;
    AmountCur               actualHourQty;

    int                     modelType;

    ProjTransType           projTransType;

    boolean                 parmSalesLine;

    Counter                 numberOfRecords;

    ProjId                  projId;
    ProjGroupId             projGroupId;
    ProjInvoiceProjId       projInvoiceProjId;
    ProjWipId               projWipId;
    ResourceRecId           resourceRecId;
    ResourceCategoryRecId   resourceCategoryRecId;
    SMASubscriptionId       subscriptionId;
    ProjEmplItemId          itemId;
    ProjCategoryId          projCategoryId;
    ProjCategoryGroupId     projCategoryGroupId;
    boolean                 createEmpty;
    ProjSort                projSorting1;
    ProjSort                projSorting2;
    ProjSort                projSorting3;
    CustAccount             custAccount;

    TmpProjCostControl              tmpProjCostControl;
    ProjCostControlMethod           projCostControlMethod;
    TmpProjCostControlExcelPivot    tmpExcelExport;

    private boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        createEmpty
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>computeVarianceDeviationForRemaining</Name>
				<Source><![CDATA[
    private void computeVarianceDeviationForRemaining()
    {
        AmountCur   deviationQty;
        AmountCur   originalAveragePrice;

        deviationQty = totalHourQty - actualHourQty - committedHourQty;

        ttsbegin;
        while select forupdate tmpProjCostControl
        {
            if (tmpProjCostControl.LineNum != 2)
            {
                tmpProjCostControl.TotalCost_Remaining=tmpProjCostControl.RemainingBudget_Remaining+tmpProjCostControl.CommittedCost + tmpProjCostControl.ActualCost;
            }
            tmpProjCostControl.DeviationCost_Remaining = tmpProjCostControl.OriginalBudgetCost - tmpProjCostControl.TotalCost_Remaining;
            if (tmpProjCostControl.LineNum == 2)
            {
                tmpProjCostControl.DeviationPrice_Remaining = totalHourQty * tmpProjCostControl.DeviationCost_Remaining;
            }
            tmpProjCostControl.update();
        }
        ttscommit;

        // Compute Qty Deviation
        select tmpProjCostControl where tmpProjCostControl.LineNum == 2;
        originalAveragePrice = tmpProjCostControl.OriginalBudgetCost;

        ttsbegin;
        select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 1;
        tmpProjCostControl.DeviationQty_Remaining = originalAveragePrice * tmpProjCostControl.DeviationCost_Remaining;
        tmpProjCostControl.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeVarianceDeviationForTotal</Name>
				<Source><![CDATA[
    private void computeVarianceDeviationForTotal()
    {
        AmountCur   deviationQty;
        AmountCur   originalAveragePrice;

        deviationQty = totalHourQty - actualHourQty - committedHourQty;

        ttsbegin;
        while select forupdate tmpProjCostControl
        {
            tmpProjCostControl.RemainingCost_Total = tmpProjCostControl.TotalCost_Total - tmpProjCostControl.CommittedCost - tmpProjCostControl.ActualCost;
            tmpProjCostControl.DeviationCost_Total = tmpProjCostControl.OriginalBudgetCost - tmpProjCostControl.TotalCost_Total;
            if (tmpProjCostControl.LineNum == 2)
            {
                tmpProjCostControl.DeviationPrice_Total = totalHourQty * tmpProjCostControl.DeviationCost_Total;
            }
            tmpProjCostControl.update();
        }
        ttscommit;

        // Compute Qty Deviation
        select tmpProjCostControl where tmpProjCostControl.LineNum == 2;
        originalAveragePrice = tmpProjCostControl.OriginalBudgetCost;

        ttsbegin;
        select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 1;
        tmpProjCostControl.DeviationQty_Total = originalAveragePrice * tmpProjCostControl.DeviationCost_Total;
        tmpProjCostControl.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createActualCosts</Name>
				<Source><![CDATA[
    protected void createActualCosts()
    {
        if (this.parmHour() && (isConfigurationkeyEnabled(configurationKeyNum(Project))))
        {
            this.createEmpl();
        }

        if (this.parmExpenses() && (isConfigurationkeyEnabled(configurationKeyNum(Project))))
        {
            this.createCost();
        }

        if (this.parmItem() && (isConfigurationkeyEnabled(configurationKeyNum(LogisticsBasic))))
        {
            this.createItem();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createActuals</Name>
				<Source><![CDATA[
    protected void createActuals( Query   query,
                            ProjTransType  _projTransType)
    {
        QueryRun            queryRun  = new QueryRun(query);
        ProjTransPosting    projTransPosting;
        ProjCostGroupId     projCostGroupId;
        ProjTable           projTable;

        while (queryRun.next())
        {
            recordsFound        = true;
            projTransPosting    =  queryRun.get(tableNum(ProjTransPosting));
            projTable           =  queryRun.get(tableNum(ProjTable));

            //
            // Skip when ProjTable.Proj != ProjTransPosting.ProjId
            // Invalid Query record returned
            //
            if (projTable.ProjId != projTransPosting.ProjId)
            {
                continue;
            }

            if (this.shouldCalculateAmountAndQuantity(_projTransType))
            {
                // If it is neverledger/no ledger and StatementConsumpHourCost is false, should not calculate the amount
                // If it is neverledger/no ledger and StatementConsumpHourQty is false, should not calculate the qty
                if (projTransPosting.PostingType==LedgerPostingType::ProjNeverLedger || projTransPosting.PostingType==LedgerPostingType::ProjNoLedger)
                {
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        projTransPosting.AmountMst = 0;
                    }
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        projTransPosting.Qty = 0;
                    }
                }

                // Keep running sum for Price Ave calculations
                actualHourAmount = actualHourAmount + projTransPosting.AmountMst;
                actualHourQty = actualHourQty + projTransPosting.Qty;

                // complete for Hour - Qty
                ttsbegin;
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 1;
                tmpProjCostControl.ActualCost = tmpProjCostControl.ActualCost + projTransPosting.Qty;
                tmpProjCostControl.update();
                ttscommit;

                // Export to Excel
                this.updateTmpExcelExport(
                    projTransPosting,
                    ProjCostControlMeasurement::ActualCost,
                    projTransPosting.Qty,
                    ProjShowHour::Qty);
            }

            switch (showBy)
            {
                case ProjRowDisplayType::TransactionType :
                    ttsbegin;
                    tmpProjCostControl = this.getTmpProjCostControlForActuals(_projTransType);
                    tmpProjCostControl.ActualCost = tmpProjCostControl.ActualCost + projTransPosting.AmountMst;
                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::CostTemplate :
                    ttsbegin;
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projTransPosting.company()).RecId),
                        projTransPosting.ProjTransDate);
                    
                    projCostGroupId = ProjControlCategory::findCategoryGroup(projCostTemplateId, projTransPosting.CategoryId);
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostGroupId == projCostGroupId;
                    tmpProjCostControl.ActualCost += currencyExchangeHelper.calculateAccountingToTransaction(projTable.currencyId(), projTransPosting.AmountMst, false);
                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::Categories :
                    ttsbegin;
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostLine == projTransPosting.CategoryId;
                    tmpProjCostControl.ActualCost = tmpProjCostControl.ActualCost +  projTransPosting.AmountMst;
                    if (tmpProjCostControl)
                    {
                        tmpProjCostControl.update();
                    }
                    else
                    {
                        tmpProjCostControl.CostLine = projTransPosting.CategoryId;
                        tmpProjCostControl.LineDescription = ProjCategory::find(projTransPosting.CategoryId).Name;
                        tmpProjCostControl.LineNum = numberOfRecords;
                        tmpProjCostControl.insert();

                        numberOfRecords++;
                    }
                    ttscommit;
                    break;
            }

            // Export to Excel
            this.updateTmpExcelExport(
                projTransPosting,
                ProjCostControlMeasurement::ActualCost,
                projTransPosting.AmountMst,
                ProjShowHour::Amount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculateAmountAndQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if amount and quantity should be calculated for the specified transaction type.
    /// </summary>
    /// <param name = "_projTransType">
    /// The <c>ProjTransType</c> enumeration value.
    /// </param>
    /// <returns>
    /// true if amount and quantity should be calculated for the specified transaction type; otherwise, false.
    /// </returns>
    protected boolean shouldCalculateAmountAndQuantity(ProjTransType _projTransType)
    {
        return (_projTransType == ProjTransType::Hour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjCostControlForActuals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>TmpProjCostControl</c> table buffer for a transaction type.
    /// </summary>
    /// <param name = "_projTransType">
    /// A <c>ProjTransType</c> enumeration value.
    /// </param>
    /// <returns>
    /// A <c>TmpProjCostControl</c> table buffer.
    /// </returns>
    protected TmpProjCostControl getTmpProjCostControlForActuals(ProjTransType _projTransType)
    {
        switch (_projTransType)
        {
            case ProjTransType::Hour :
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 3;
                break;

            case ProjTransType::Cost :
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 4;
                break;

            case ProjTransType::Item :
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 5;
                break;
        }

        return tmpProjCostControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAverageForRemaining</Name>
				<Source><![CDATA[
    protected void createAverageForRemaining()
    {
        ProjControlCostGroup    projControlCostGroup;
        ProjCategory            projCategory;

        progressCounter++;

        // Price average
        this.progressUpdate("@SYS86457");

        select tmpProjCostControl where tmpProjCostControl.LineNum == 1;
        totalHourQty=remainingBudgetHourQty+tmpProjCostControl.ActualCost+tmpProjCostControl.CommittedCost;

        switch (showBy)
        {
            case ProjRowDisplayType::TransactionType:
                select tmpProjCostControl where tmpProjCostControl.CostLine == "@SYS5269";
                break;

            case ProjRowDisplayType::CostTemplate:
                select sum(ActualCost), sum(CommittedCost) from tmpProjCostControl
                    exists join projControlCostGroup where
                        tmpProjCostControl.ControlId == projControlCostGroup.ControlId &&
                        tmpProjCostControl.CostGroupId == projControlCostGroup.CostGroupId &&
                        projControlCostGroup.CostType == ProjCostType::Hour;
                break;

            case ProjRowDisplayType::Categories:
                select sum(ActualCost), sum(CommittedCost) from tmpProjCostControl where
                        tmpProjCostControl.LineNum > 2
                    exists join projCategory where
                        tmpProjCostControl.CostLine == projCategory.CategoryId &&
                        projCategory.CategoryType == ProjCategoryType::Hour;
                break;
        }

        totalCostHourAmount = this.calculateTotalCostHourAmount(tmpProjCostControl);

        ttsbegin;
        select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 2;
        if (totalHourQty != 0)
        {
            tmpProjCostControl.TotalCost_Remaining = totalCostHourAmount / totalHourQty;
        }

        if (remainingBudgetHourQty != 0)
        {
            tmpProjCostControl.RemainingBudget_Remaining = remainingBudgetHourAmount / remainingBudgetHourQty;
        }

        if (actualHourQty != 0)
        {
            tmpProjCostControl.ActualCost = actualHourAmount / actualHourQty;
        }

        if (committedHourQty != 0)
        {
            tmpProjCostControl.CommittedCost = committedHourAmount / committedHourQty;
        }

        if (originalBudgetHourQty != 0)
        {
            tmpProjCostControl.OriginalBudgetCost = originalBudgetHourAmount / originalBudgetHourQty;
        }

        tmpProjCostControl.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotalCostHourAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total cost amount for Hour.
    /// </summary>
    /// <param name = "_tmpProjCostControl">
    /// A <c>TmpProjCostControl</c> table buffer.
    /// </param>
    /// <returns>
    /// An amount.
    /// </returns>
    protected AmountCur calculateTotalCostHourAmount(TmpProjCostControl _tmpProjCostControl)
    {
        return remainingBudgetHourAmount + _tmpProjCostControl.ActualCost + _tmpProjCostControl.CommittedCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAverageForTotal</Name>
				<Source><![CDATA[
    private void createAverageForTotal()
    {
        progressCounter++;

        // Price average
        this.progressUpdate("@SYS86457");

        ttsbegin;
        select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 2;
        if (totalHourQty != 0)
        {
            tmpProjCostControl.TotalCost_Total = totalCostHourAmount / totalHourQty;
        }

        if (actualHourQty != 0)
        {
            tmpProjCostControl.ActualCost = actualHourAmount / actualHourQty;
        }

        if (committedHourQty != 0)
        {
            tmpProjCostControl.CommittedCost = committedHourAmount / committedHourQty;
        }

        if (originalBudgetHourQty != 0)
        {
            tmpProjCostControl.OriginalBudgetCost = originalBudgetHourAmount / originalBudgetHourQty;
        }

        tmpProjCostControl.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCommittedCosts</Name>
				<Source><![CDATA[
    protected void createCommittedCosts()
    {
        QueryRun                            queryRun;
        CostControlTransCommittedCost       costControlTransCommittedCost;
        ProjCostGroupId                     projCostGroupId;

        progressCounter++;
        this.progressUpdate("@SYS73512");

        queryRun  = new QueryRun(this.queryCommittedCosts());
        while (queryRun.next())
        {
            costControlTransCommittedCost = queryRun.get(tableNum(CostControlTransCommittedCost));

            // Keep running sum for Price Ave calculations
            if (costControlTransCommittedCost.ProjTransType == ProjTransType::Hour)
            {
                committedHourAmount = committedHourAmount + costControlTransCommittedCost.AmountMst;
                committedHourQty = committedHourQty + costControlTransCommittedCost.Qty;

                // complete for Hour - Qty
                ttsbegin;
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 1;
                tmpProjCostControl.CommittedCost = tmpProjCostControl.CommittedCost + costControlTransCommittedCost.Qty;
                tmpProjCostControl.update();
                ttscommit;

                // Export to Excel
                this.updateTmpExcelExport(
                    costControlTransCommittedCost,
                    ProjCostControlMeasurement::CommittedCost,
                    costControlTransCommittedCost.Qty,
                    ProjShowHour::Qty);
            }

            switch (showBy)
            {
                case ProjRowDisplayType::TransactionType :
                    this.createCommittedCostsForTransactionType(costControlTransCommittedCost);
                    break;

                case ProjRowDisplayType::CostTemplate :
                    ttsbegin;
                    projCostGroupId = ProjControlCategory::findCategoryGroup(projCostTemplateId, costControlTransCommittedCost.CategoryId);
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostGroupId == projCostGroupId;
                    tmpProjCostControl.CommittedCost = tmpProjCostControl.CommittedCost + costControlTransCommittedCost.AmountMst;
                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::Categories :
                    ttsbegin;
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostLine == costControlTransCommittedCost.CategoryId;
                    tmpProjCostControl.CommittedCost = tmpProjCostControl.CommittedCost + costControlTransCommittedCost.AmountMst;
                    if (tmpProjCostControl)
                    {
                        tmpProjCostControl.update();
                    }
                    else
                    {
                        tmpProjCostControl.CostLine = costControlTransCommittedCost.CategoryId;
                        tmpProjCostControl.LineDescription = ProjCategory::find(costControlTransCommittedCost.CategoryId).Name;
                        tmpProjCostControl.LineNum = numberOfRecords;
                        tmpProjCostControl.insert();

                        numberOfRecords++;
                    }
                    ttscommit;
                    break;
            }

            // Export to Excel
            this.updateTmpExcelExport(
                costControlTransCommittedCost,
                ProjCostControlMeasurement::CommittedCost,
                costControlTransCommittedCost.AmountMst,
                ProjShowHour::Amount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCommittedCostsForTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the committed costs for a transaction type.
    /// </summary>
    /// <param name = "_costControlTransCommittedCost">
    /// A <c>CostControlTransCommittedCost</c> table buffer.
    /// </param>
    protected void createCommittedCostsForTransactionType(CostControlTransCommittedCost _costControlTransCommittedCost)
    {
        ttsbegin;
        tmpProjCostControl = this.getTmpProjCostControlForCommittedCosts(_costControlTransCommittedCost);
        tmpProjCostControl.CommittedCost = tmpProjCostControl.CommittedCost + _costControlTransCommittedCost.AmountMst;
        tmpProjCostControl.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjCostControlForCommittedCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>TmpProjCostControl</c> table buffer for a transaction type.
    /// </summary>
    /// <param name = "_costControlTransCommittedCost">
    /// A <c>CostControlTransCommittedCost</c> table buffer.
    /// </param>
    /// <returns>
    /// A <c>TmpProjCostControl</c> table buffer.
    /// </returns>
    protected TmpProjCostControl getTmpProjCostControlForCommittedCosts(CostControlTransCommittedCost _costControlTransCommittedCost)
    {
        switch (_costControlTransCommittedCost.ProjTransType)
        {
            case ProjTransType::Hour:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 3;
                break;

            case ProjTransType::Cost:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 4;
                break;

            case ProjTransType::Item:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 5;
                break;
        }

        return tmpProjCostControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCost</Name>
				<Source><![CDATA[
    private void createCost()
    {
        progressCounter++;
        this.progressUpdate("@SYS4249");

        this.createActuals(this.queryProjTransPosting(ProjTransType::Cost),ProjTransType::Cost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEmpl</Name>
				<Source><![CDATA[
    private void createEmpl()
    {
        progressCounter++;
        this.progressUpdate("@SYS4705");

        this.createActuals(this.queryProjTransPosting(ProjTransType::Hour),ProjTransType::Hour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEmptyCategory</Name>
				<Source><![CDATA[
    private void createEmptyCategory()
    {
        int i;

        #DEFINE.NumberOfLines(2)

        numberOfRecords = 1;

        //Create the Hour Qty and Hour Ave lines
        ttsbegin;
        for ( i = 1; i <= #NumberOfLines; i+=1)
        {
            tmpProjCostControl.LineNum = i;

            switch (i)
            {
                // Hour - Qty
                case 1:
                    tmpProjCostControl.CostLine = "@SYS78376";
                    break;

                // Hour - Price average
                case 2:
                    tmpProjCostControl.CostLine = "@SYS86449";
                    break;
            }

            tmpProjCostControl.insert();
            numberOfRecords ++;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEmptyCostTemplate</Name>
				<Source><![CDATA[
    private void createEmptyCostTemplate()
    {
        int i;
        ProjControlCostGroup    projControlCostGroup;

        #DEFINE.NumberOfLines(2)

        //Create the Hour Qty and Hour Ave lines
        ttsbegin;
        for ( i = 1; i <= #NumberOfLines; i+=1)
        {
            tmpProjCostControl.LineNum = i;

            switch (i)
            {
                // Hour - Qty
                case 1:
                    tmpProjCostControl.CostLine = "@SYS78376";
                    break;

                // Hour - Price average
                case 2:
                    tmpProjCostControl.CostLine = "@SYS86449";
                    break;
            }

            tmpProjCostControl.insert();
        }

        numberOfRecords = #NumberOfLines + 1;

        //Create lines based on the template;
        while select CostGroupId from projControlCostGroup
        where projControlCostGroup.ControlId == projCostTemplateId
        {
            tmpProjCostControl.LineNum = numberOfRecords;
            tmpProjCostControl.ControlId = projCostTemplateId;
            tmpProjCostControl.CostGroupId = projControlCostGroup.CostGroupId;
            tmpProjCostControl.CostLine = projControlCostGroup.CostGroupId;
            tmpProjCostControl.insert();
            numberOfRecords ++;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEmptyTransactionType</Name>
				<Source><![CDATA[
    private void createEmptyTransactionType()
    {
        Map mapTransactionTypes = this.getTransactionTypesMap();
        MapEnumerator mapEnum = mapTransactionTypes.getEnumerator();

        ttsbegin;

        while (mapEnum.moveNext())
        {
            tmpProjCostControl.LineNum = mapEnum.currentKey();
            tmpProjCostControl.CostLine = mapEnum.currentValue();
            tmpProjCostControl.insert();
        }

        ttscommit;

        numberOfRecords = mapTransactionTypes.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionTypesMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>Map</c> that contains transaction types used in <c>ProjCostControl</c>.
    /// </summary>
    /// <returns>A <c>Map</c> with transactions types.</returns>
    protected Map getTransactionTypesMap()
    {
        Map mapTransactionType = new Map(Types::Integer, Types::String);

        mapTransactionType.insert(1, "@SYS78376");
        mapTransactionType.insert(2, "@SYS86449");
        mapTransactionType.insert(3, "@SYS5269");
        mapTransactionType.insert(4, "@SYP4882014");
        mapTransactionType.insert(5, "@SYS7407");

        return mapTransactionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createForecastCosts</Name>
				<Source><![CDATA[
    protected void createForecastCosts()
    {
        QueryRun                        queryRun;
        ProjTransBudget                 projTransBudget;
        ProjCostGroupId                 projCostGroupId;

        progressCounter++;
        this.progressUpdate("@SYS73512");

        // Original Forecast Model
        queryRun  = new QueryRun(this.queryForecastModel(projOriginalForecastModelId));

        while (queryRun.next())
        {
            projTransBudget = queryRun.get(tableNum(ProjTransBudget));

            // Keep running sum for Price Ave calculations
            if (projTransBudget.ProjTransType == ProjTransType::Hour)
            {
                // If it is neverledger/no ledger and StatementConsumpHourCost is false, should not calculate the amount
                // If it is neverledger/no ledger and StatementConsumpHourQty is false, should not calculate the qty
                if (projTransBudget.PostingType==LedgerPostingType::ProjNeverLedger || projTransBudget.PostingType==LedgerPostingType::ProjNoLedger)
                {
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        projTransBudget.AmountMst = 0;
                    }
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        projTransBudget.Qty = 0;
                    }
                }

                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(projTransBudget.company()).RecId),
																										projTransBudget.ProjTransDate);

                originalBudgetHourAmount += currencyExchangeHelper.calculateAccountingToTransaction(ProjTable::find(projTransBudget.ProjId).currencyId(),
                                                                                                    projTransBudget.AmountMst,
																									false);
                originalBudgetHourQty = originalBudgetHourQty + projTransBudget.Qty;

                // complete for Hour - Qty
                ttsbegin;
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 1;
                tmpProjCostControl.OriginalBudgetCost = tmpProjCostControl.OriginalBudgetCost + projTransBudget.Qty;

                tmpProjCostControl.update();
                ttscommit;

                // Export to Excel
                this.updateTmpExcelExport(
                    projTransBudget,
                    ProjCostControlMeasurement::OriginalBudget,
                    projTransBudget.Qty,
                    ProjShowHour::Qty);
            }
            switch (showBy)
            {
                case ProjRowDisplayType::TransactionType :
                    ttsbegin;
                    tmpProjCostControl = this.getTmpProjCostControlForOriginalForecastModel(projTransBudget);
                    tmpProjCostControl.OriginalBudgetCost = tmpProjCostControl.OriginalBudgetCost + projTransBudget.AmountMst;
                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::CostTemplate :
                    ttsbegin;
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(projTransBudget.company()).RecId),
																											projTransBudget.ProjTransDate);

                    projCostGroupId = ProjControlCategory::findCategoryGroup(projCostTemplateId, projTransBudget.CategoryId);
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostGroupId == projCostGroupId;
                    tmpProjCostControl.OriginalBudgetCost += currencyExchangeHelper.calculateAccountingToTransaction(ProjTable::find(projTransBudget.ProjId).currencyId(),
                                                                                                                     projTransBudget.AmountMst, 
																													 false);
                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::Categories :
                    ttsbegin;
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostLine == projTransBudget.CategoryId;
                    tmpProjCostControl.OriginalBudgetCost = tmpProjCostControl.OriginalBudgetCost + projTransBudget.AmountMst;
                    if (tmpProjCostControl)
                    {
                        tmpProjCostControl.update();
                    }
                    else
                    {
                        tmpProjCostControl.CostLine = projTransBudget.CategoryId;
                        tmpProjCostControl.LineDescription = ProjCategory::find(projTransBudget.CategoryId).Name;
                        tmpProjCostControl.LineNum = numberOfRecords;
                        tmpProjCostControl.insert();

                        numberOfRecords++;
                    }
                    ttscommit;
                    break;
            }

            // Export to Excel
            this.updateTmpExcelExport(
            projTransBudget,
            ProjCostControlMeasurement::OriginalBudget,
            projTransBudget.AmountMst,
            ProjShowHour::Amount);
        }

        // Total Forecast Model or Remaining Forecast Model
        if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
        {
            queryRun  = new QueryRun(this.queryForecastModel(projRemainingForecastModelId));
        }
        else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
        {
            queryRun  = new QueryRun(this.queryForecastModel(projTotalForecastModelId));
        }

        while (queryRun.next())
        {
            projTransBudget = queryRun.get(tableNum(ProjTransBudget));

            // Keep running sum for Price Ave calculations
            if (projTransBudget.ProjTransType == ProjTransType::Hour)
            {
                // If it is neverledger/no ledger and StatementConsumpHourCost is false, should not calculate the amount
                // If it is neverledger/no ledger and StatementConsumpHourQty is false, should not calculate the qty
                if (projTransBudget.PostingType==LedgerPostingType::ProjNeverLedger || projTransBudget.PostingType==LedgerPostingType::ProjNoLedger)
                {
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        projTransBudget.AmountMst = 0;
                    }
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        projTransBudget.Qty = 0;
                    }
                }

                if (this.parmProjCostControlMethod() == ProjCostControlMethod::RemainingBudget)
                {
                    remainingBudgetHourAmount = remainingBudgetHourAmount + projTransBudget.AmountMst;
                    remainingBudgetHourQty = remainingBudgetHourQty + projTransBudget.Qty;
                }
                else if (this.parmProjCostControlMethod() == ProjCostControlMethod::TotalBudget)
                {
                    totalCostHourAmount = totalCostHourAmount + projTransBudget.AmountMst;
                    totalHourQty = totalHourQty + projTransBudget.Qty;
                }

                // complete for Hour - Qty
                ttsbegin;
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 1;
                if (this.parmProjCostControlMethod() == ProjCostControlMethod::RemainingBudget)
                {
                    tmpProjCostControl.RemainingBudget_Remaining=tmpProjCostControl.RemainingBudget_Remaining + projTransBudget.Qty;

                    // Export to Excel
                    this.updateTmpExcelExport(
                    projTransBudget,
                    ProjCostControlMeasurement::RemainingBudget,
                    projTransBudget.Qty,
                    ProjShowHour::Qty);
                }
                else if (this.parmProjCostControlMethod() == ProjCostControlMethod::TotalBudget)
                {
                    tmpProjCostControl.TotalCost_Total = tmpProjCostControl.TotalCost_Total + projTransBudget.Qty;

                    // Export to Excel
                    this.updateTmpExcelExport(
                    projTransBudget,
                    ProjCostControlMeasurement::TotalBudgetCost,
                    projTransBudget.Qty,
                    ProjShowHour::Qty);
                }

                tmpProjCostControl.update();
                ttscommit;
            }

            switch (showBy)
            {
                case ProjRowDisplayType::TransactionType :
                    ttsbegin;
                    tmpProjCostControl = this.getTmpProjCostControlForTotalOrRemainingForecastModel(projTransBudget);

                    if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
                    {
                        tmpProjCostControl.RemainingBudget_Remaining=tmpProjCostControl.RemainingBudget_Remaining + projTransBudget.AmountMst;
                    }
                    else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
                    {
                        tmpProjCostControl.TotalCost_Total = tmpProjCostControl.TotalCost_Total + projTransBudget.AmountMst;
                    }

                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::CostTemplate :
                    ttsbegin;
                    projCostGroupId = ProjControlCategory::findCategoryGroup(projCostTemplateId, projTransBudget.CategoryId);
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostGroupId == projCostGroupId;
                    if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
                    {
                        tmpProjCostControl.RemainingBudget_Remaining=tmpProjCostControl.RemainingBudget_Remaining + projTransBudget.AmountMst;
                    }
                    else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
                    {
                        tmpProjCostControl.TotalCost_Total = tmpProjCostControl.TotalCost_Total + projTransBudget.AmountMst;
                    }
                    tmpProjCostControl.update();
                    ttscommit;
                    break;

                case ProjRowDisplayType::Categories :
                    ttsbegin;
                    select forupdate tmpProjCostControl where tmpProjCostControl.CostLine == projTransBudget.CategoryId;
                    if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
                    {
                        tmpProjCostControl.RemainingBudget_Remaining=tmpProjCostControl.RemainingBudget_Remaining + projTransBudget.AmountMst;
                    }
                    else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
                    {
                        tmpProjCostControl.TotalCost_Total = tmpProjCostControl.TotalCost_Total + projTransBudget.AmountMst;
                    }
                    if (tmpProjCostControl)
                    {
                        tmpProjCostControl.update();
                    }
                    else
                    {
                        tmpProjCostControl.CostLine = projTransBudget.CategoryId;
                        tmpProjCostControl.LineDescription = ProjCategory::find(projTransBudget.CategoryId).Name;
                        tmpProjCostControl.LineNum = numberOfRecords;
                        tmpProjCostControl.insert();

                        numberOfRecords++;
                    }
                    ttscommit;
                    break;
            }

            // Export to Excel
            if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
            {
                this.updateTmpExcelExport(
                    projTransBudget,
                    ProjCostControlMeasurement::RemainingBudget,
                    projTransBudget.AmountMst,
                    ProjShowHour::Amount);
            }
            else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
            {
                this.updateTmpExcelExport(
                    projTransBudget,
                    ProjCostControlMeasurement::TotalBudgetCost,
                    projTransBudget.AmountMst,
                    ProjShowHour::Amount);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjCostControlForOriginalForecastModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>TmpProjCostControl</c> table buffer for a transaction type.
    /// </summary>
    /// <param name = "_projTransBudget">
    /// A <c>ProjTransBudget</c> table buffer.
    /// </param>
    /// <returns>
    /// A <c>TmpProjCostControl</c> table buffer.
    /// </returns>
    protected TmpProjCostControl getTmpProjCostControlForOriginalForecastModel(ProjTransBudget _projTransBudget)
    {
        switch (_projTransBudget.ProjTransType)
        {
            case ProjTransType::Hour:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 3;
                break;

            case ProjTransType::Cost:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 4;
                break;

            case ProjTransType::Item:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 5;
                break;
        }

        return tmpProjCostControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjCostControlForTotalOrRemainingForecastModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>TmpProjCostControl</c> table buffer for a transaction type.
    /// </summary>
    /// <param name = "_projTransBudget">
    /// A <c>ProjTransBudget</c> table buffer.
    /// </param>
    /// <returns>
    /// A <c>TmpProjCostControl</c> table buffer.
    /// </returns>
    protected TmpProjCostControl getTmpProjCostControlForTotalOrRemainingForecastModel(ProjTransBudget _projTransBudget)
    {
        switch (_projTransBudget.ProjTransType)
        {
            case ProjTransType::Hour :
                // complete for lines 1 & 2
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 3;
                break;

            case ProjTransType::Cost :
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 4;
                break;

            case ProjTransType::Item:
                select forupdate tmpProjCostControl where tmpProjCostControl.LineNum == 5;
                break;
        }

        return tmpProjCostControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createItem</Name>
				<Source><![CDATA[
    private void createItem()
    {
        progressCounter++;
        this.progressUpdate("@SYS50258");

        this.createActuals(this.queryProjTransPosting(ProjTransType::Item),ProjTransType::Item);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTotalRow</Name>
				<Source><![CDATA[
    private void createTotalRow()
    {
        ttsbegin;
        tmpProjCostControl.clear();
        tmpProjCostControl.LineNum = numberOfRecords;
        tmpProjCostControl.CostLine = "@SYS809";
        tmpProjCostControl.TotalLine = NoYes::Yes;
        tmpProjCostControl.insert();
        ttscommit;

        this.createTotals();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTotals</Name>
				<Source><![CDATA[
    private void createTotals()
    {
        TmpProjCostControl      tmpProjCostControl_Totals;

        progressCounter++;
        this.progressUpdate("@SYS14107");

        tmpProjCostControl_Totals.setTmpData(tmpProjCostControl);

        if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
        {
            select sum(ActualCost), sum(CommittedCost), sum(TotalCost_Remaining), sum(RemainingCost_Total), sum(RemainingBudget_Remaining),sum(OriginalBudgetCost), sum(DeviationCost_Remaining) from tmpProjCostControl_Totals
            where tmpProjCostControl_Totals.LineNum      > 2
            &&    tmpProjCostControl_Totals.TotalLine    == NoYes::No;   // qty lines

            ttsbegin;
            select forupdate tmpProjCostControl where tmpProjCostControl.TotalLine == NoYes::Yes;

            tmpProjCostControl.ActualCost           = tmpProjCostControl_Totals.ActualCost;
            tmpProjCostControl.CommittedCost        = tmpProjCostControl_Totals.CommittedCost;
            tmpProjCostControl.TotalCost_Remaining            = tmpProjCostControl_Totals.TotalCost_Remaining;
            tmpProjCostControl.RemainingCost_Total        = tmpProjCostControl_Totals.RemainingCost_Total;
            tmpProjCostControl.RemainingBudget_Remaining        = tmpProjCostControl_Totals.RemainingBudget_Remaining;

            tmpProjCostControl.DeviationCost_Remaining        = tmpProjCostControl_Totals.DeviationCost_Remaining;
            tmpProjCostControl.OriginalBudgetCost   = tmpProjCostControl_Totals.OriginalBudgetCost;

            // update values based on Hour - Qty and Hour - Price Ave lines
            select tmpProjCostControl_Totals where tmpProjCostControl_Totals.LineNum == 1;
            tmpProjCostControl.DeviationQty_Remaining     = tmpProjCostControl_Totals.DeviationQty_Remaining;

            select tmpProjCostControl_Totals where tmpProjCostControl_Totals.LineNum == 2;
            tmpProjCostControl.DeviationPrice_Remaining   = tmpProjCostControl_Totals.DeviationPrice_Remaining;
            tmpProjCostControl.update();

            ttscommit;
        }
        else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
        {
            select sum(ActualCost), sum(CommittedCost), sum(TotalCost_Total), sum(RemainingCost_Total), sum(OriginalBudgetCost), sum(DeviationCost_Total) from tmpProjCostControl_Totals
            where tmpProjCostControl_Totals.LineNum      > 2
            &&    tmpProjCostControl_Totals.TotalLine    == NoYes::No;   // qty lines

            ttsbegin;
            select forupdate tmpProjCostControl where tmpProjCostControl.TotalLine == NoYes::Yes;

            tmpProjCostControl.ActualCost           = tmpProjCostControl_Totals.ActualCost;
            tmpProjCostControl.CommittedCost        = tmpProjCostControl_Totals.CommittedCost;
            tmpProjCostControl.TotalCost_Total            = tmpProjCostControl_Totals.TotalCost_Total;
            tmpProjCostControl.RemainingCost_Total        = tmpProjCostControl_Totals.RemainingCost_Total;
            tmpProjCostControl.DeviationCost_Total        = tmpProjCostControl_Totals.DeviationCost_Total;
            tmpProjCostControl.OriginalBudgetCost   = tmpProjCostControl_Totals.OriginalBudgetCost;

            // update values based on Hour - Qty and Hour - Price Ave lines
            select tmpProjCostControl_Totals where tmpProjCostControl_Totals.LineNum == 1;
            tmpProjCostControl.DeviationQty_Total     = tmpProjCostControl_Totals.DeviationQty_Total;

            select tmpProjCostControl_Totals where tmpProjCostControl_Totals.LineNum == 2;
            tmpProjCostControl.DeviationPrice_Total   = tmpProjCostControl_Totals.DeviationPrice_Total;
            tmpProjCostControl.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProgress</Name>
				<Source><![CDATA[
    public void initProgress()
    {
        progress = RunbaseProgress::construct(1,null);
        progress.setCaption("@SYS58374");
        progress.setTotal(any2int(this.parmProgressTotal()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        recordsFound        = false;
        numberOfRecords     = 0;

        // Accumulator variables;
        totalCostHourAmount = 0;
        originalBudgetHourAmount = 0;
        committedHourAmount = 0;
        actualHourAmount = 0;
        totalHourQty = 0;
        originalBudgetHourQty = 0;
        committedHourQty = 0;
        actualHourQty = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,#CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryGroupId</Name>
				<Source><![CDATA[
    public ProjCategoryGroupId parmCategoryGroupId(ProjCategoryGroupId _projCategoryGrouplId  = projCategoryGroupId)
    {
        projCategoryGroupId    = _projCategoryGrouplId;

        return projCategoryGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomerAccount</Name>
				<Source><![CDATA[
    public CustAccount parmCustomerAccount(CustAccount _custAccount  = custAccount)
    {
        custAccount    = _custAccount;

        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExpenses</Name>
				<Source><![CDATA[
    public boolean parmExpenses(
    boolean _expenses  = expenses)
    {
        expenses    = _expenses;

        return expenses;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFixedPrice</Name>
				<Source><![CDATA[
    public boolean parmFixedPrice(boolean _fixedPrice = fixedPrice)
    {
        fixedPrice = _fixedPrice;

        return fixedPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHour</Name>
				<Source><![CDATA[
    public boolean parmHour(
    boolean _hour  = hour)
    {
        hour    = _hour;

        return hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInternalCost</Name>
				<Source><![CDATA[
    public boolean parmInternalCost(boolean _internalCost = internalCost)
    {
        internalCost = _internalCost;

        return internalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvestment</Name>
				<Source><![CDATA[
    public boolean parmInvestment(boolean _investment = investment)
    {
        investment = _investment;

        return investment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItem</Name>
				<Source><![CDATA[
    public boolean parmItem(
    boolean _item  = item)
    {
        item    = _item;

        return item;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId(ItemId _itemId  = itemId)
    {
        itemId    = _itemId;

        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransDateFrom</Name>
				<Source><![CDATA[
    public TransDate parmLedgerTransDateFrom(TransDate _ledgerTransDateFrom  = ledgerTransDateFrom)
    {
        ledgerTransDateFrom = _ledgerTransDateFrom;

        return ledgerTransDateFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransDateTo</Name>
				<Source><![CDATA[
    public TransDate parmLedgerTransDateTo(
    TransDate _ledgerTransDateTo = ledgerTransDateTo)
    {
        ledgerTransDateTo  = _ledgerTransDateTo;

        return ledgerTransDateTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModelType</Name>
				<Source><![CDATA[
    public ProjForecastModelType parmModelType(ProjForecastModelType _modelType  = modelType)
    {
        modelType    = _modelType;

        return modelType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberOfRecords</Name>
				<Source><![CDATA[
    public Counter parmNumberOfRecords(Counter _numberOfRecords  = numberOfRecords)
    {
        numberOfRecords    = _numberOfRecords;

        return numberOfRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalForecastModelId</Name>
				<Source><![CDATA[
    public ProjForecastModelId parmOriginalForecastModelId(ProjForecastModelId _projOriginalForecastModelId  = projOriginalForecastModelId)
    {
        projOriginalForecastModelId    = _projOriginalForecastModelId;

        return projOriginalForecastModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProgressTotal</Name>
				<Source><![CDATA[
    public Total parmProgressTotal(Total _progressTotal = progressTotal)
    {
        progressTotal  = any2int(_progressTotal);

        return progressTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId parmProjCategoryId(ProjCategoryId _projCategoryId  = projCategoryId)
    {
        projCategoryId    = _projCategoryId;

        return projCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCostControlMethod</Name>
				<Source><![CDATA[
    public ProjCostControlMethod parmProjCostControlMethod(ProjCostControlMethod _projCostControlMethod=projCostControlMethod)
    {
        projCostControlMethod=_projCostControlMethod;

        return projCostControlMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCostTemplateId</Name>
				<Source><![CDATA[
    public ProjControlId parmProjCostTemplateId(
    ProjControlId _projCostTemplateId  = projCostTemplateId)
    {
        projCostTemplateId    = _projCostTemplateId;

        return projCostTemplateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjGroupId</Name>
				<Source><![CDATA[
    public ProjGroupId parmProjGroupId(ProjGroupId _projGroupId  = projGroupId)
    {
        projGroupId    = _projGroupId;

        return projGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjId</Name>
				<Source><![CDATA[
    public ProjId parmProjId(
    ProjId _projId  = projId)
    {
        projId    = _projId;

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjInvoiceProjId</Name>
				<Source><![CDATA[
    public ProjInvoiceProjId parmProjInvoiceProjId(
    ProjInvoiceProjId _projInvoiceProjId  = projInvoiceProjId)
    {
        projInvoiceProjId    = _projInvoiceProjId;

        return projInvoiceProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjSorting1</Name>
				<Source><![CDATA[
    public ProjSort parmProjSorting1(ProjSort _projSorting1  = projSorting1)
    {
        projSorting1 = _projSorting1;

        return projSorting1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjSorting2</Name>
				<Source><![CDATA[
    public ProjSort parmProjSorting2(ProjSort _projSorting2  = projSorting2)
    {
        projSorting2 = _projSorting2;

        return projSorting2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjSorting3</Name>
				<Source><![CDATA[
    public ProjSort parmProjSorting3(ProjSort _projSorting3  = projSorting3)
    {
        projSorting3 = _projSorting3;

        return projSorting3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDateFrom</Name>
				<Source><![CDATA[
    public ProjTransDate parmProjTransDateFrom(ProjTransDate _projTransDateFrom  = projTransDateFrom)
    {
        projTransDateFrom = _projTransDateFrom;

        return projTransDateFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDateTo</Name>
				<Source><![CDATA[
    public ProjTransDate parmProjTransDateTo(
    ProjTransDate _projTransDateTo = projTransDateTo)
    {
        projTransDateTo  = _projTransDateTo;

        return projTransDateTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransType</Name>
				<Source><![CDATA[
    public ProjTransType parmProjTransType(ProjTransType _projTransType  = projTransType)
    {
        projTransType    = _projTransType;

        return     projTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTree</Name>
				<Source><![CDATA[
    public boolean parmProjTree(boolean _projTree = projTree)
    {
        projTree    = _projTree;

        return projTree;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjWIPId</Name>
				<Source><![CDATA[
    public ProjWipId parmProjWIPId(
    ProjWipId _projWipId  = projWipId)
    {
        projWipId    = _projWipId;

        return projWipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainingForecastModelId</Name>
				<Source><![CDATA[
    public ProjForecastModelId parmRemainingForecastModelId(ProjForecastModelId _projRemainingForecastModelId  = projRemainingForecastModelId)
    {
        projRemainingForecastModelId    = _projRemainingForecastModelId;

        return projRemainingForecastModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of the <c>resourceRecId</c> variable.
    /// </summary>
    /// <param name="_resourceRecId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>resourceRecId</c> variable.
    /// </returns>
    public ResourceRecId parmResource(ResourceRecId  _resourceRecId  = resourceRecId)
    {
        resourceRecId = _resourceRecId;
        return resourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResourceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of the <c>resourceCategoryRecId</c> variable.
    /// </summary>
    /// <param name="_resourceCategoryRecId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>resourceCategoryRecId</c> variable.
    /// </returns>
    public ResourceCategoryRecId parmResourceCategory(ResourceCategoryRecId  _resourceCategoryRecId  = resourceCategoryRecId)
    {
        resourceCategoryRecId = _resourceCategoryRecId;
        return resourceCategoryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowby</Name>
				<Source><![CDATA[
    public ProjRowDisplayType parmShowby(
    ProjRowDisplayType _showBy  = showBy)
    {
        showBy    = _showBy;

        return showBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubscriptionId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of the <c>subscriptionId</c> variable.
    /// </summary>
    /// <param name="_subscriptionId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>subscriptionId</c> variable.
    /// </returns>
    public SMASubscriptionId parmSubscriptionId(SMASubscriptionId _subscriptionId  = subscriptionId)
    {
        subscriptionId = _subscriptionId;

        return subscriptionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTime</Name>
				<Source><![CDATA[
    public boolean parmTime(boolean _time = time)
    {
        time = _time;

        return time;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTimeMaterial</Name>
				<Source><![CDATA[
    public boolean parmTimeMaterial(boolean _timeMaterial = timeMaterial)
    {
        timeMaterial = _timeMaterial;

        return timeMaterial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTotalForecastModelId</Name>
				<Source><![CDATA[
    public ProjForecastModelId parmTotalForecastModelId(ProjForecastModelId _projTotalForecastModelId  = projTotalForecastModelId)
    {
        projTotalForecastModelId    = _projTotalForecastModelId;

        return projTotalForecastModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    protected void progressUpdate(str text)
    {
        progressCounter++;
        progress.setCount(progressCounter);
        progress.setText(text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryCommittedCosts</Name>
				<Source><![CDATA[
    protected Query queryCommittedCosts()
    {
        QueryBuildDataSource        qb_tranCommittedCost;
        QueryBuildDataSource        qb_projTable;
        QueryBuildDataSource        qb_projCategoryTable;
        Query                       queryCC = new Query();

        qb_tranCommittedCost = queryCC.addDataSource(tableNum(CostControlTransCommittedCost));

        if (this.parmProjId())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost,ProjId)).value(queryValue(this.parmProjId()));
        }

        if (this.parmProjCategoryId())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost,CategoryId)).value(this.parmProjCategoryId());
        }

        if (this.parmResource())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost, Resource)).value(queryValue(this.parmResource()));
        }

        if (this.parmResourceCategory())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost, ResourceCategory)).value(queryValue(this.parmResourceCategory()));
        }

        if (this.parmItemId())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost,EmplItemId)).value(this.parmItemId());
        }

        if (this.parmItem())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost, ProjTransType)).value(queryValue(ProjTransType::Item));
        }

        if (this.parmHour())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost, ProjTransType)).value(queryValue(ProjTransType::Hour));
        }

        if (this.parmExpenses())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost, ProjTransType)).value(queryValue(ProjTransType::Cost));
        }

        if (this.parmProjTree())
        {
            qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost,ProjId)).value(this.parmProjId()+'*');
        }

        qb_tranCommittedCost.addRange(fieldNum(CostControlTransCommittedCost, CommittedDate)).value(this.queryFromLedgerDate()+'..'+this.queryToLedgerDate());

        if (this.parmCategoryGroupId())
        {
            qb_projCategoryTable = qb_tranCommittedCost.addDataSource(tableNum(ProjCategory));
            qb_projCategoryTable.addLink(fieldNum(CostControlTransCommittedCost, CategoryId), fieldNum(ProjCategory, CategoryId));
            qb_projCategoryTable.fetchMode(0);
            qb_projCategoryTable.joinMode(JoinMode::ExistsJoin);

            qb_projCategoryTable.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(this.parmCategoryGroupId());
        }

        qb_projTable = qb_tranCommittedCost.addDataSource(tableNum(ProjTable));
        qb_projTable.addLink(fieldNum(CostControlTransCommittedCost, ProjId), fieldNum(ProjTable, ProjId));
        qb_projTable.fetchMode(0);
        qb_projTable.joinMode(JoinMode::ExistsJoin);

        if (this.parmProjInvoiceProjId())
        {
            qb_projTable.addRange(fieldNum(ProjTable, ProjInvoiceProjId)).value(this.parmProjInvoiceProjId());
        }

        if (this.parmProjWIPId())
        {
            qb_projTable.addRange(fieldNum(ProjTable, wipProject)).value(this.parmProjWIPId());
        }

        if (!this.enableProjMultipleContractLinesForProjectFeature)
        {
            if (this.parmTimeMaterial())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::TimeMaterial));
            }

            if (this.parmFixedPrice())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::FixedPrice));
            }

            if (this.parmTime())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Time));
            }

            if (this.parmInvestment())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Investment));
            }

            if (this.parmInternalCost())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Cost));
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Internal));
            }
        }

        if (this.parmProjSorting1())
        {
            qb_projTable.addRange(fieldNum(ProjTable, SortingId), 1).value(this.parmProjSorting1());
        }

        if (this.parmProjSorting2())
        {
            qb_projTable.addRange(fieldNum(ProjTable, SortingId), 2).value(this.parmProjSorting2());
        }

        if (this.parmProjSorting3())
        {
            qb_projTable.addRange(fieldNum(ProjTable, SortingId), 3).value(this.parmProjSorting3());
        }

        if (this.parmProjGroupId())
        {
            qb_projTable.addRange(fieldNum(ProjTable, ProjGroupId)).value(this.parmProjGroupId());
        }

        if (this.parmCustomerAccount())
        {
            qb_projTable.addRange(fieldNum(ProjTable, CustAccount)).value(this.parmCustomerAccount());
        }

        return queryCC;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryForecastModel</Name>
				<Source><![CDATA[
    protected Query queryForecastModel(ProjForecastModelId    forecastModelId)
    {
        QueryBuildDataSource        qb_projForecastModel;
        QueryBuildDataSource        qb_projTable;
        QueryBuildDataSource        qb_projCategoryTable;
        Query                       queryForecast = new Query();
        str                         itemPostingTypeCondition;
        str                         expPostingTypeCondition;
        str                         hourPostingTypeCondition;

        qb_projForecastModel    = queryForecast.addDataSource(tableNum(ProjTransBudget));
        qb_projForecastModel.addRange(fieldNum(ProjTransBudget, ModelId)).value(queryValue(forecastModelId));
        qb_projForecastModel.addRange(fieldNum(ProjTransBudget, CostSales)).value(queryValue(ProjCostSales::Cost));

        // For Item forecast: (PostingType in (LedgerPostingType::ProjStatusAccountItem, ProjCost, ProjOffsetAccountItem) &&Elimination=No)
        //   OR PostingType==ProjNeverLedger(depends on projParameter.ItemNeverLedgerConsum)
        if (ProjParameters::find().ItemNeverLedgerConsum)
        {
            itemPostingTypeCondition =strFmt('((%1==%2) && ((((%3==%4) || (%3==%5) || (%3==%6)) && (%7==%8)) || (%3==%9)))',
        fieldStr(ProjTransBudget, ProjTransType),          //1
        enum2int(ProjTransType::Item),                     //2
        fieldStr(ProjTransBudget, PostingType),            //3
        enum2int(LedgerPostingType::ProjStatusAccountItem),//4
        enum2int(LedgerPostingType::ProjCost),             //5
        enum2int(LedgerPostingType::ProjOffsetAccountItem),//6
        fieldStr(ProjTransBudget, Elimination),            //7
        enum2int(NoYes::No),                               //8
        enum2int(LedgerPostingType::ProjNeverLedger));     //9
        }
        else
        {
            itemPostingTypeCondition =strFmt('((%1==%2) && ((((%3==%4) || (%3==%5) || (%3==%6)) && (%7==%8))))',
        fieldStr(ProjTransBudget, ProjTransType),          //1
        enum2int(ProjTransType::Item),                     //2
        fieldStr(ProjTransBudget, PostingType),            //3
        enum2int(LedgerPostingType::ProjStatusAccountItem),//4
        enum2int(LedgerPostingType::ProjCost),             //5
        enum2int(LedgerPostingType::ProjOffsetAccountItem),//6
        fieldStr(ProjTransBudget, Elimination),            //7
        enum2int(NoYes::No));                              //8
        }

        // For Expense forecast: PostingType in (LedgerPostingType::ProjWIPCostvalue, ProjCost) && elimination==no
        expPostingTypeCondition = strFmt('((%1==%2) && ((%3==%4) || (%3==%5)) && (%6==%7))',
    fieldStr(ProjTransBudget, ProjTransType),          //1
    enum2int(ProjTransType::Cost),                     //2
    fieldStr(ProjTransBudget, PostingType),            //3
    enum2int(LedgerPostingType::ProjWIPCostvalue),     //4
    enum2int(LedgerPostingType::ProjCost),             //5
    fieldStr(ProjTransBudget, Elimination),            //6
    enum2int(NoYes::No));                              //7

        // For Hour forecast: PostingType in (LedgerPostingType::ProjWIPCostvalue,ProjCost) && elimination==no
        //   OR postingType IN (ProjNeverLedger,ProjNoLedger) (depends on projParameter.statementConsumpHourCost)
        hourPostingTypeCondition = strFmt('((%1==%2) && ((%3==%4) || (%3==%5) || (%3==%6) || (%3==%7)) && (%8==%9))',
    fieldStr(ProjTransBudget, ProjTransType),          //1
    enum2int(ProjTransType::Hour),                     //2
    fieldStr(ProjTransBudget, PostingType),            //3
    enum2int(LedgerPostingType::ProjWIPCostvalue),     //4
    enum2int(LedgerPostingType::ProjCost),             //5
    enum2int(LedgerPostingType::ProjNoLedger),         //6
    enum2int(LedgerPostingType::ProjNeverLedger),      //7
    fieldStr(ProjTransBudget, Elimination),            //8
    enum2int(NoYes::No));                              //9

        qb_projForecastModel.addRange(fieldNum(ProjTransBudget, PostingType)).value(strFmt('(%1 || %2 || %3)',
    itemPostingTypeCondition,
    expPostingTypeCondition,
    hourPostingTypeCondition));

        if (this.parmProjId())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget,ProjId)).value(queryValue(this.parmProjId()));
        }

        if (this.parmProjTree())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget,ProjId)).value(this.parmProjId()+'*');
        }

        if (this.parmProjCategoryId())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget,CategoryId)).value(this.parmProjCategoryId());
        }

        if (this.parmResource())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget, Resource)).value(queryValue(this.parmResource()));
        }

        if (this.parmResourceCategory())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget, ResourceCategory)).value(queryValue(this.parmResourceCategory()));
        }

        if (this.parmSubscriptionId())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget, SubscriptionId)).value(queryValue(this.parmSubscriptionId()));
        }

        if (this.parmItemId())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget,EmplItemId)).value(this.parmItemId());
        }

        if (this.parmItem())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
        }

        if (this.parmHour())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
        }

        if (this.parmExpenses())
        {
            qb_projForecastModel.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
        }

        qb_projForecastModel.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(this.queryFromProjDate()+'..'+this.queryToProjDate());
        qb_projForecastModel.addRange(fieldNum(ProjTransBudget, LedgerTransDate)).value(this.queryFromLedgerDate()+'..'+this.queryToLedgerDate());

        if (this.parmCategoryGroupId())
        {
            qb_projCategoryTable = qb_projForecastModel.addDataSource(tableNum(ProjCategory));
            qb_projCategoryTable.addLink(fieldNum(ProjTransBudget, CategoryId), fieldNum(ProjCategory, CategoryId));
            qb_projCategoryTable.fetchMode(0);
            qb_projCategoryTable.joinMode(JoinMode::ExistsJoin);

            qb_projCategoryTable.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(this.parmCategoryGroupId());
        }

        qb_projTable = qb_projForecastModel.addDataSource(tableNum(ProjTable));
        qb_projTable.addLink(fieldNum(ProjTransBudget, ProjId), fieldNum(ProjTable, ProjId));
        qb_projTable.fetchMode(0);
        qb_projTable.joinMode(JoinMode::ExistsJoin);

        if (this.parmProjInvoiceProjId())
        {
            qb_projTable.addRange(fieldNum(ProjTable, ProjInvoiceProjId)).value(this.parmProjInvoiceProjId());
        }

        if (this.parmProjWIPId())
        {
            qb_projTable.addRange(fieldNum(ProjTable, wipProject)).value(this.parmProjWIPId());
        }

        if (!this.enableProjMultipleContractLinesForProjectFeature)
        {
            if (this.parmTimeMaterial())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::TimeMaterial));
            }

            if (this.parmFixedPrice())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::FixedPrice));
            }

            if (this.parmTime())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Time));
            }

            if (this.parmInvestment())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Investment));
            }

            if (this.parmInternalCost())
            {
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Cost));
                qb_projTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Internal));
            }
        }

        if (this.parmProjSorting1())
        {
            qb_projTable.addRange(fieldNum(ProjTable, SortingId), 1).value(this.parmProjSorting1());
        }

        if (this.parmProjSorting2())
        {
            qb_projTable.addRange(fieldNum(ProjTable, SortingId), 2).value(this.parmProjSorting2());
        }

        if (this.parmProjSorting3())
        {
            qb_projTable.addRange(fieldNum(ProjTable, SortingId), 3).value(this.parmProjSorting3());
        }

        if (this.parmProjGroupId())
        {
            qb_projTable.addRange(fieldNum(ProjTable, ProjGroupId)).value(this.parmProjGroupId());
        }

        if (this.parmCustomerAccount())
        {
            qb_projTable.addRange(fieldNum(ProjTable, CustAccount)).value(this.parmCustomerAccount());
        }

        return queryForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryFromLedgerDate</Name>
				<Source><![CDATA[
    private str queryFromLedgerDate()
    {
        return queryValue(this.parmLedgerTransDateFrom() ? this.parmLedgerTransDateFrom() : dateNull());
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryFromProjDate</Name>
				<Source><![CDATA[
    private str queryFromProjDate()
    {
        return queryValue(this.parmProjTransDateFrom() ? this.parmProjTransDateFrom() : dateNull());
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryProjTable</Name>
				<Source><![CDATA[
    private QueryBuildDataSource queryProjTable(QueryBuildDataSource buildDataSource)
    {
        QueryBuildDataSource queryProjTable;

        queryProjTable  = buildDataSource.addDataSource(tableNum(ProjTable));
        queryProjTable.relations(true);

        if (this.parmProjInvoiceProjId())
        {
            queryProjTable.addRange(fieldNum(ProjTable,ProjInvoiceProjId)).value(queryValue(this.parmProjInvoiceProjId()));
        }

        if (this.parmProjWIPId())
        {
            queryProjTable.addRange(fieldNum(ProjTable,wipProject)).value(queryValue(this.parmProjWIPId()));
        }

        if (!this.enableProjMultipleContractLinesForProjectFeature)
        {
            if (this.parmTimeMaterial())
            {
                queryProjTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::TimeMaterial));
            }

            if (this.parmFixedPrice())
            {
                queryProjTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::FixedPrice));
            }

            if (this.parmTime())
            {
                queryProjTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Time));
            }

            if (this.parmInvestment())
            {
                queryProjTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Investment));
            }

            if (this.parmInternalCost())
            {
                queryProjTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Cost));
                queryProjTable.addRange(fieldNum(ProjTable,Type)).value(queryValue(ProjType::Internal));
            }
        }

        if (this.parmProjSorting1())
        {
            queryProjTable.addRange(fieldNum(ProjTable, SortingId), 1).value(this.parmProjSorting1());
        }

        if (this.parmProjSorting2())
        {
            queryProjTable.addRange(fieldNum(ProjTable, SortingId), 2).value(this.parmProjSorting2());
        }

        if (this.parmProjSorting3())
        {
            queryProjTable.addRange(fieldNum(ProjTable, SortingId), 3).value(this.parmProjSorting3());
        }

        if (this.parmProjGroupId())
        {
            queryProjTable.addRange(fieldNum(ProjTable, ProjGroupId)).value(this.parmProjGroupId());
        }

        if (this.parmCustomerAccount())
        {
            queryProjTable.addRange(fieldNum(ProjTable, CustAccount)).value(this.parmCustomerAccount());
        }

        return buildDataSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryProjTransPosting</Name>
				<Source><![CDATA[
    protected Query queryProjTransPosting(ProjTransType _projTransType)
    {
        QueryBuildDataSource    projTransPosting;
        QueryBuildDataSource    projCategoryGroup;
        Query                   queryProjTransPosting = new Query();
        str                     itemPostingTypeCondition;
        str                     expPostingTypeCondition;
        str                     hourPostingTypeCondition;
        RecId                   legalEntity;

        projTransPosting  = queryProjTransPosting.addDataSource(tableNum(ProjTransPosting));
        projTransPosting.addRange(fieldNum(ProjTransPosting, CostSales)).value(queryValue(ProjCostSales::Cost));
        projTransPosting.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(_projTransType));

        switch (_projTransType)
        {
            case ProjTransType::Item:
                // For Item actual cost: (PostingType in (LedgerPostingType::ProjStatusAccountItem, ProjCost, ProjOffsetAccountItem) &&Elimination=No)
                //   OR PostingType==ProjNeverLedger(depends on projParameter.ItemNeverLedgerConsum)
                if (ProjParameters::find().ItemNeverLedgerConsum)
                {
                    itemPostingTypeCondition =strFmt('((%1==%2) && ((((%3==%4) || (%3==%5) || (%3==%6)) && ((%7 != %8) && (%7 != %9))) || (%3==%10)))',
                        fieldStr(ProjTransPosting, ProjTransType),         //1
                        enum2int(ProjTransType::Item),                     //2
                        fieldStr(ProjTransPosting, PostingType),           //3
                        enum2int(LedgerPostingType::ProjStatusAccountItem),//4
                        enum2int(LedgerPostingType::ProjCost),             //5
                        enum2int(LedgerPostingType::ProjOffsetAccountItem),//6
                        fieldStr(ProjTransPosting, LedgerOrigin),          //7
                        enum2int(ProjOrigin::EliminateEstimate),           //8
                        enum2int(ProjOrigin::ReverseElimination),          //9
                        enum2int(LedgerPostingType::ProjNeverLedger));     //10
                }
                else
                {
                    itemPostingTypeCondition =strFmt('((%1==%2) && ((((%3==%4) || (%3==%5) || (%3==%6)) && ((%7 != %8) && (%7 != %9)))))',
                        fieldStr(ProjTransPosting, ProjTransType),         //1
                        enum2int(ProjTransType::Item),                     //2
                        fieldStr(ProjTransPosting, PostingType),           //3
                        enum2int(LedgerPostingType::ProjStatusAccountItem),//4
                        enum2int(LedgerPostingType::ProjCost),             //5
                        enum2int(LedgerPostingType::ProjOffsetAccountItem),//6
                        fieldStr(ProjTransPosting, LedgerOrigin),          //7
                        enum2int(ProjOrigin::EliminateEstimate),           //8
                        enum2int(ProjOrigin::ReverseElimination));         //9
                }
                projTransPosting.addRange(fieldNum(ProjTransPosting, PostingType)).value(itemPostingTypeCondition);
                break;
            case ProjTransType::Cost:
                // For Expense actual cost: PostingType in (LedgerPostingType::ProjWIPCostvalue, ProjCost) && elimination==no
                expPostingTypeCondition = strFmt('((%1==%2) && ((%3==%4) || (%3==%5)) && ((%6 != %7) && (%6 != %8)))',
                    fieldStr(ProjTransPosting, ProjTransType),         //1
                    enum2int(ProjTransType::Cost),                     //2
                    fieldStr(ProjTransPosting, PostingType),           //3
                    enum2int(LedgerPostingType::ProjWIPCostvalue),     //4
                    enum2int(LedgerPostingType::ProjCost),             //5
                    fieldStr(ProjTransPosting, LedgerOrigin),          //6
                    enum2int(ProjOrigin::EliminateEstimate),           //7
                    enum2int(ProjOrigin::ReverseElimination));         //8

                projTransPosting.addRange(fieldNum(ProjTransPosting, PostingType)).value(expPostingTypeCondition);
                break;
            case ProjTransType::Hour:
                // For Hour actual cost: PostingType in (LedgerPostingType::ProjWIPCostvalue,ProjCost) && elimination==no
                //   OR postingType IN (ProjNeverLedger,ProjNoLedger) (depends on projParameter.statementConsumpHourCost)
                hourPostingTypeCondition = strFmt('((%1==%2) && ((%3==%4) || (%3==%5) || (%3==%6) || (%3==%7)) && ((%8 != %9) && (%8 != %10)))',
                    fieldStr(ProjTransPosting, ProjTransType),         //1
                    enum2int(ProjTransType::Hour),                     //2
                    fieldStr(ProjTransPosting, PostingType),           //3
                    enum2int(LedgerPostingType::ProjWIPCostvalue),     //4
                    enum2int(LedgerPostingType::ProjCost),             //5
                    enum2int(LedgerPostingType::ProjNoLedger),         //6
                    enum2int(LedgerPostingType::ProjNeverLedger),      //7
                    fieldStr(ProjTransPosting, LedgerOrigin),          //8
                    enum2int(ProjOrigin::EliminateEstimate),           //9
                    enum2int(ProjOrigin::ReverseElimination));         //10

                projTransPosting.addRange(fieldNum(ProjTransPosting, PostingType)).value(hourPostingTypeCondition);
                break;
        }
        if (this.parmProjId())
        {
            projTransPosting.addRange(fieldNum(ProjTransPosting,ProjId)).value(queryValue(this.parmProjId()));
        }

        if (this.parmProjTree())
        {
            projTransPosting.addRange(fieldNum(ProjTransPosting,ProjId)).value(this.parmProjId()+'*');
        }

        if (this.parmProjCategoryId())
        {
            projTransPosting.addRange(fieldNum(ProjTransPosting,CategoryId)).value(this.parmProjCategoryId());
        }

        if (this.parmResource())
        {
            legalEntity = CompanyInfo::findDataArea(curext()).RecId;

            projTransPosting.addRange(fieldNum(ProjTransPosting, Resource)).value(queryValue(this.parmResource()));
        }

        if (this.parmResourceCategory())
        {
            projTransPosting.addRange(fieldNum(ProjTransPosting, ResourceCategory)).value(queryValue(this.parmResourceCategory()));
        }

        if (this.parmSubscriptionId())
        {
            projTransPosting.addRange(fieldNum(ProjTransPosting, SubscriptionId)).value(queryValue(this.parmSubscriptionId()));
        }

        if (this.parmItemId())
        {
            projTransPosting.addRange(fieldNum(ProjTransPosting,EmplItemId)).value(this.parmItemId());
        }

        projTransPosting.addRange(fieldNum(ProjTransPosting,ProjTransDate)).value(this.queryFromProjDate()+'..'+this.queryToProjDate());
        projTransPosting.addRange(fieldNum(ProjTransPosting,LedgerTransDate)).value(this.queryFromLedgerDate()+'..'+this.queryToLedgerDate());

        projTransPosting    = this.queryProjTable(projTransPosting);

        if (this.parmCategoryGroupId())
        {
            projCategoryGroup = projTransPosting.addDataSource(tableNum(ProjCategory));
            projCategoryGroup.addLink(fieldNum(ProjTransPosting, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroup.fetchMode(0);
            projCategoryGroup.joinMode(JoinMode::ExistsJoin);

            projCategoryGroup.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(this.parmCategoryGroupId());
        }

        return queryProjTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryToLedgerDate</Name>
				<Source><![CDATA[
    private str queryToLedgerDate()
    {
        return queryValue(this.parmLedgerTransDateTo() ? this.parmLedgerTransDateTo() : dateMax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryToProjDate</Name>
				<Source><![CDATA[
    private str queryToProjDate()
    {
        return queryValue(this.parmProjTransDateTo() ? this.parmProjTransDateTo() : dateMax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        if (! this.validate())
        {
            throw error("@SYS18738");
        }

        this.initProgress();

        delete_from tmpProjCostControl;

        switch (this.parmShowby())
        {
            case ProjRowDisplayType::Categories :
                this.createEmptyCategory();
                break;

            case ProjRowDisplayType::CostTemplate :
                this.createEmptyCostTemplate();
                break;

            default :
                this.createEmptyTransactionType();
                break;
        }

        this.createCommittedCosts();
        this.createForecastCosts();
        this.createActualCosts();

        // Compute Hour - Price Average
        if (this.shouldCalculatePriceAverage())
        {
            if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
            {
                this.createAverageForRemaining();
            }
            else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
            {
                this.createAverageForTotal();
            }
        }

        // Calculated Variance and Deviation
        if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
        {
            this.computeVarianceDeviationForRemaining();
        }
        else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
        {
            this.computeVarianceDeviationForTotal();
        }

        this.createTotalRow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculatePriceAverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the price average should be calculated.
    /// </summary>
    /// <returns>
    /// true if the price average should be calculated; otherwise, false.
    /// </returns>
    protected boolean shouldCalculatePriceAverage()
    {
        return hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountExcelExport</Name>
				<Source><![CDATA[
    public TmpProjCostControlExcelPivot setAmountExcelExport(
        TmpProjCostControlExcelPivot    _tmpExcelExport,
        ProjCostControlMeasurement      _measurement,
        AmountMST                       _costControlAmount)
    {
        switch (_measurement)
        {
            case ProjCostControlMeasurement::ActualCost:
                _tmpExcelExport.ActualCost += _costControlAmount;
                break;
            case ProjCostControlMeasurement::CommittedCost:
                _tmpExcelExport.CommittedCost += _costControlAmount;
                break;
            case ProjCostControlMeasurement::OriginalBudget:
                _tmpExcelExport.OriginalBudget += _costControlAmount;
                break;
            case ProjCostControlMeasurement::RemainingBudget:
                _tmpExcelExport.RemainingBudget += _costControlAmount;
                break;
            case ProjCostControlMeasurement::TotalBudgetCost:
                _tmpExcelExport.TotalBudgetCost += _costControlAmount;
                break;
        }

        return _tmpExcelExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeviationVarianceExcelExport</Name>
				<Source><![CDATA[
    public TmpProjCostControlExcelPivot setDeviationVarianceExcelExport(TmpProjCostControlExcelPivot _tmpExcelExport)
    {
        if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
        {
            _tmpExcelExport.TotalCost = _tmpExcelExport.RemainingBudget +
                                    _tmpExcelExport.CommittedCost +
                                    _tmpExcelExport.ActualCost;

            _tmpExcelExport.Deviation = _tmpExcelExport.OriginalBudget - _tmpExcelExport.TotalCost;
        }
        else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
        {
            _tmpExcelExport.Variance = _tmpExcelExport.TotalBudgetCost -
                                   _tmpExcelExport.CommittedCost -
                                   _tmpExcelExport.ActualCost;

            _tmpExcelExport.Deviation = _tmpExcelExport.OriginalBudget - _tmpExcelExport.TotalBudgetCost;
        }

        return _tmpExcelExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpExcelExport</Name>
				<Source><![CDATA[
    public TmpProjCostControlExcelPivot tmpExcelExport()
    {
        return tmpExcelExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpProjCostControl</Name>
				<Source><![CDATA[
    public TmpProjCostControl tmpProjCostControl()
    {
        return tmpProjCostControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer     version     = conPeek(_packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = _packedClass;
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpExcelExport</Name>
				<Source><![CDATA[
    public void updateTmpExcelExport(
    Common _dataSource,
    ProjCostControlMeasurement _measurement,
    AmountMST _costControlAmount,
    ProjShowHour _showAmountQty)
    {
        ProjTransPosting                actual;
        ProjTransBudget                 budget;
        CostControlTransCommittedCost   committed;
        PurchLine                       purchLine;
        ProjItemTrans                   projItemTrans;
        VendInvoiceInfoLine_Project     vendInvoiceInfoLine_Project;
        VendInvoiceInfoLine             vendInvoiceInfoLine;
        VendInvoiceInfoTable            vendInvoiceInfoTable;

        ttsbegin;

        switch (_dataSource.TableId)
        {
            case tableNum(ProjTransPosting):
                actual = _dataSource;

                tmpExcelExport.clear();
                tmpExcelExport.StatementType        = ProjExportToExcelWorksheet::CostControl;
                tmpExcelExport.ShowAmountQty        = _showAmountQty;
                tmpExcelExport.TransId              = actual.TransId;
                tmpExcelExport.ProjId               = actual.ProjId;
                tmpExcelExport.CategoryId           = actual.CategoryId;
                tmpExcelExport.Resource             = actual.Resource;
                tmpExcelExport.ResourceCategory     = actual.ResourceCategory;
                tmpExcelExport.SubscriptionId       = actual.SubscriptionId;
                tmpExcelExport.EmplItemId           = actual.EmplItemId;
                tmpExcelExport.ActivityNumber       = actual.ActivityNumber;
                tmpExcelExport.ProjType             = actual.ProjType;
                tmpExcelExport.ProjTransType        = actual.ProjTransType;
                tmpExcelExport.PostingType          = actual.PostingType;
                tmpExcelExport.LedgerDimension      = actual.LedgerDimension;
                tmpExcelExport.DefaultDimension     = actual.DefaultDimension;
                tmpExcelExport.Voucher              = actual.Voucher;
                tmpExcelExport.ProjTransDate        = actual.ProjTransDate;
                tmpExcelExport.LedgerTransDate      = actual.LedgerTransDate;
                tmpExcelExport.TransactionOrigin    = actual.TransactionOrigin;
                tmpExcelExport.LedgerOrigin         = actual.LedgerOrigin;
                tmpExcelExport.ProjFundingSourceId  = ProjFundingSource::find(actual.ProjFundingSource).FundingSourceId;

                tmpExcelExport.initFromProjTable(ProjTable::find(tmpExcelExport.ProjId));
                tmpExcelExport.initFromProjCategory(ProjCategory::find(tmpExcelExport.CategoryId));

                // Set Order Number and Vendor
                if (actual.ProjTransType == ProjTransType::Item)
                {
                    if ((actual.TransactionOrigin == ProjOrigin::SalesOrder)         ||
                    (actual.TransactionOrigin == ProjOrigin::ItemRequirement)    ||
                    (actual.TransactionOrigin == ProjOrigin::PurchaseOrder)      ||
                    (actual.TransactionOrigin == ProjOrigin::VendorInvoice)      ||
                    (actual.TransactionOrigin == ProjOrigin::ProductionFinished) ||
                    (actual.TransactionOrigin == ProjOrigin::ProductionConsumed) ||
                    (actual.TransactionOrigin == ProjOrigin::BeginningBalance))
                    {
                        projItemTrans = ProjItemTrans::find(actual.TransId);
                        tmpExcelExport.OrderNumber = ProjInvoiceItem::findTransId(projItemTrans.ProjTransId).SalesId;

                        if (actual.TransactionOrigin == ProjOrigin::PurchaseOrder)
                        {
                            select firstonly purchLine
                            where purchLine.ProjTransId     == actual.TransId;
                            tmpExcelExport.Vendor = purchLine.purchTable().vendTable_OrderAccount().AccountNum;
                        }
                        else if (actual.TransactionOrigin == ProjOrigin::VendorInvoice)
                        {
                            select firstonly RecId
                            from vendInvoiceInfoLine_Project
                                where vendInvoiceInfoLine_Project.ProjTransId == actual.TransId
                            join RecId from vendInvoiceInfoLine
                                where vendInvoiceInfoLine.RecId == vendInvoiceInfoLine_Project.VendInvoiceInfoLineRefRecId
                            join OrderAccount from vendInvoiceInfoTable
                                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId &&
                                    vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId;
                            tmpExcelExport.Vendor = vendInvoiceInfoTable.OrderAccount;
                        }
                    }
                }

                this.setAmountExcelExport(tmpExcelExport, _measurement, _costControlAmount);
                this.setDeviationVarianceExcelExport(tmpExcelExport);

                tmpExcelExport.insert();

                break;

            case tableNum(ProjTransBudget):
                budget = _dataSource;

                tmpExcelExport.clear();
                tmpExcelExport.StatementType        = ProjExportToExcelWorksheet::CostControl;
                tmpExcelExport.ShowAmountQty        = _showAmountQty;
                tmpExcelExport.TransId              = budget.TransId;
                tmpExcelExport.ProjId               = budget.ProjId;
                tmpExcelExport.CategoryId           = budget.CategoryId;
                tmpExcelExport.SubscriptionId       = budget.SubscriptionId;
                tmpExcelExport.EmplItemId           = budget.EmplItemId;
                tmpExcelExport.ActivityNumber       = budget.ActivityNumber;
                tmpExcelExport.ProjType             = budget.ProjType;
                tmpExcelExport.ProjTransType        = budget.ProjTransType;
                tmpExcelExport.PostingType          = budget.PostingType;
                tmpExcelExport.LedgerDimension      = budget.LedgerDimension;
                tmpExcelExport.DefaultDimension     = budget.DefaultDimension;
                tmpExcelExport.Voucher              = budget.Voucher;
                tmpExcelExport.ProjTransDate        = budget.ProjTransDate;
                tmpExcelExport.LedgerTransDate      = budget.LedgerTransDate;
                tmpExcelExport.ProjFundingSourceId  = ProjFundingSource::find(budget.ProjFundingSource).FundingSourceId;

                tmpExcelExport.initFromProjTable(ProjTable::find(tmpExcelExport.ProjId));
                tmpExcelExport.initFromProjCategory(ProjCategory::find(tmpExcelExport.CategoryId));

                this.setAmountExcelExport(tmpExcelExport, _measurement, _costControlAmount);
                this.setDeviationVarianceExcelExport(tmpExcelExport);

                tmpExcelExport.insert();

                break;

            case tableNum(CostControlTransCommittedCost):
                committed = _dataSource;

                tmpExcelExport.clear();
                tmpExcelExport.StatementType    = ProjExportToExcelWorksheet::CostControl;
                tmpExcelExport.ShowAmountQty    = _showAmountQty;
                tmpExcelExport.TransId          = committed.ProjTransId;
                tmpExcelExport.ProjId           = committed.ProjId;
                tmpExcelExport.CategoryId       = committed.CategoryId;
                tmpExcelExport.EmplItemId       = committed.EmplItemId;
                tmpExcelExport.ActivityNumber   = committed.ActivityNumber;
                tmpExcelExport.ProjType         = committed.ProjType;
                tmpExcelExport.ProjTransType    = committed.ProjTransType;
                tmpExcelExport.PostingType      = LedgerPostingType::ProjCost;
                tmpExcelExport.LedgerDimension  = committed.LedgerDimension;
                tmpExcelExport.DefaultDimension = committed.DefaultDimension;
                tmpExcelExport.Voucher          = committed.Voucher;
                tmpExcelExport.ProjTransDate    = committed.CommittedDate;
                tmpExcelExport.OrderNumber      = committed.RefId;
                tmpExcelExport.Vendor           = committed.VendAccount;

                tmpExcelExport.initFromProjTable(ProjTable::find(tmpExcelExport.ProjId));
                tmpExcelExport.initFromProjCategory(ProjCategory::find(tmpExcelExport.CategoryId));

                this.setAmountExcelExport(tmpExcelExport, _measurement, _costControlAmount);
                this.setDeviationVarianceExcelExport(tmpExcelExport);

                tmpExcelExport.insert();

                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (!this.isTransactionTypeSelected())
            {
                ret = checkFailed("@SYS91027");
            }

            if (!this.enableProjMultipleContractLinesForProjectFeature && !this.isProjectTypeSelected())
            {
                ret = checkFailed("@SYS91026");
            }

            if (this.parmProjTransDateFrom() && this.parmProjTransDateTo())
            {
                if (this.parmProjTransDateFrom() > this.parmProjTransDateTo())
                {
                    ret = checkFailed("@SYS91020");
                }
            }

            if (this.parmLedgerTransDateFrom() && this.parmLedgerTransDateTo())
            {
                if (this.parmLedgerTransDateFrom() > this.parmLedgerTransDateTo())
                {
                    ret = checkFailed("@SYS91020");
                }
            }

            if (this.parmShowby() == ProjRowDisplayType::CostTemplate)
            {
                if (!this.parmProjCostTemplateId())
                {
                    ret = checkFailed("@SYS104042");
                }
            }

            if (this.parmProjCostControlMethod()==ProjCostControlMethod::RemainingBudget)
            {
                if (!this.parmOriginalForecastModelId() || !this.parmRemainingForecastModelId())
                {
                    ret = checkFailed("@SYS87707");
                }
                if (this.parmRemainingForecastModelId() && this.parmRemainingForecastModelId() == this.parmOriginalForecastModelId())
                {
                    warning("@SYS110432");
                }
            }
            else if (this.parmProjCostControlMethod()==ProjCostControlMethod::TotalBudget)
            {
                if (!this.parmOriginalForecastModelId() || !this.parmTotalForecastModelId())
                {
                    ret = checkFailed("@SYS87707");
                }
                if  (this.parmTotalForecastModelId() == this.parmOriginalForecastModelId())
                {
                    warning("@SYS110431");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionTypeSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a transaction type is selected.
    /// </summary>
    /// <returns>
    /// true if a transaction type is selected; otherwise, false.
    /// </returns>
    protected boolean isTransactionTypeSelected()
    {
        return (this.parmHour() || this.parmExpenses() || this.parmItem());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectTypeSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a project type is selected.
    /// </summary>
    /// <returns>
    /// true if a project type is selected; otherwise, false.
    /// </returns>
    protected boolean isProjectTypeSelected()
    {
        return (this.parmTimeMaterial() || this.parmFixedPrice() || this.parmInternalCost() || this.parmInvestment() || this.parmTime());
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    protected static ClassDescription description()
    {
        return "@SYS103369";
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>