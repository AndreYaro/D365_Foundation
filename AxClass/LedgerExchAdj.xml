<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerExchAdj</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerExchAdj</c> class performs ledger foreign currency revaluation.
/// </summary>
class LedgerExchAdj extends RunBaseBatch implements BatchRetryable
{
    DialogField dialogFromDate;
    DialogField dialogToDate;
    DialogField dialogExchangeRateDate;
    DialogField accountSelection;
    DialogField dialogExcludeReportingCurrencyAdjustment;

    // Currency lookup controls
    FormStringControl dialogCurrencySelection;
    FormStringControl dialogCurrencySelectionId;
    FormStringControl dialogCurrencySelectionString;
    int dialogCurrencyLookupId;
    SysLookupMultiSelectGrid currencySelectionLookup;

    DialogField dialogPreviewBeforePost;
    DialogField dialogShowAllCurrencies;

    QueryRun queryRun;

    // Legal entity lookup controls
    FormStringControl dialogLegalEntitySelection;
    LedgerLegalEntityLookup legalEntityLookup;
    int dialogLegalEntityLookupId;

    TransDate fromDate;
    TransDate toDate;
    TransDate exchangeRateData;
    LedgerExchAdjMainAccountOptions mainAccountOptions;
    container currencyOptions;
    container legalEntityOptions;
    boolean previewBeforePost;
    private boolean showAllCurrencies;
    str userLegalEntityRange;
    private boolean excludeReportingCurrencyAdjustment;

    LedgerExchAdjRunMode runMode = LedgerExchAdjRunMode::CalculateAndPost;

    // Obsolete fields
    DialogField         dialogFromAccount;
    DialogField         dialogToAccount;
    DialogField         dialogFromCur;
    DialogField         dialogToCur;
    DialogField         dialogProfitLossAccounts;
    DialogField         dialogStatusAccounts;

    MainAccountRecId    fromAccountRecId;
    MainAccountRecId    toAccountRecId;
    MainAccountNum      fromAccount;
    MainAccountNum      toAccount;
    CurrencyCode        fromCur;
    CurrencyCode        toCur;
    TransDate           postingDate;
    NoYes               profitLossAccounts;
    NoYes               statusAccounts;
    GovernmentExchRate  governmentExchRate;
    // End obsolete fields

    TableName exchangeAdjustmentTempTable;

    LedgerIExchAdjHist historyForm;
    Voucher            voucher;

    const int CurrentVersion = 6;

    private readonly boolean isLedgerExchAdjAggregateDimensionsFlightEnabled =
        FeatureStateProvider::isFeatureEnabled(LedgerExchAdjAggregateDimensionsV2Flight::instance());

    #LOCALMACRO.CurrentList
        fromDate,
        toDate,
        currencyOptions,
        mainAccountOptions,
        runMode,
        exchangeAdjustmentTempTable,
        previewBeforePost,
        showAllCurrencies,
        exchangeRateData,
        legalEntityOptions,
        excludeReportingCurrencyAdjustment
    #ENDMACRO

    #LOCALMACRO.CurrentList_v5
        fromDate,
        toDate,
        currencyOptions,
        mainAccountOptions,
        runMode,
        exchangeAdjustmentTempTable,
        previewBeforePost,
        showAllCurrencies,
        exchangeRateData,
        legalEntityOptions
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    public TransDate parmFromDate (TransDate _fromDate = fromDate)
    {
        fromDate = _fromDate;

        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    public TransDate parmToDate (TransDate _toDate = toDate)
    {
        toDate = _toDate;

        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    public TransDate parmExchangeRateDate (TransDate _exchangeRateDate = exchangeRateData)
    {
        exchangeRateData = _exchangeRateDate;

        return exchangeRateData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeReportingCurrencyAdjustment</Name>
				<Source><![CDATA[
    public NoYes parmExcludeReportingCurrencyAdjustment (NoYes _excludeReportingCurrencyAdjustment = excludeReportingCurrencyAdjustment)
    {
        excludeReportingCurrencyAdjustment = _excludeReportingCurrencyAdjustment;

        return excludeReportingCurrencyAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMainAccountOptions</Name>
				<Source><![CDATA[
    public LedgerExchAdjMainAccountOptions parmMainAccountOptions(LedgerExchAdjMainAccountOptions _mainAccountOptions = mainAccountOptions)
    {
        mainAccountOptions = _mainAccountOptions;

        return mainAccountOptions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyOptions</Name>
				<Source><![CDATA[
    public container parmCurrencyOptions(container _currencyOptions = currencyOptions)
    {
        currencyOptions = _currencyOptions;

        return currencyOptions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLegalEntityOptions</Name>
				<Source><![CDATA[
    public container parmLegalEntityOptions(container _legalEntityOptions = legalEntityOptions)
    {
        legalEntityOptions = _legalEntityOptions;

        return legalEntityOptions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun(QueryRun _queryRun = queryRun)
    {
        queryRun = _queryRun;
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRunMode</Name>
				<Source><![CDATA[
    public LedgerExchAdjRunMode parmRunMode(LedgerExchAdjRunMode _runMode = runMode)
    {
        runMode = _runMode;
        return runMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeAdjustmentTempTable</Name>
				<Source><![CDATA[
    public TableName parmExchangeAdjustmentTempTable(TableName _tmpTable = exchangeAdjustmentTempTable)
    {
        exchangeAdjustmentTempTable = _tmpTable;
        return exchangeAdjustmentTempTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreviewBeforePost</Name>
				<Source><![CDATA[
    public boolean parmPreviewBeforePost(boolean _preview = previewBeforePost)
    {
        previewBeforePost = _preview;
        return previewBeforePost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoryForm</Name>
				<Source><![CDATA[
    public LedgerIExchAdjHist parmHistoryForm(LedgerIExchAdjHist _historyForm = historyForm)
    {
        historyForm = _historyForm;
        return historyForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeBalanceSheetAccounts</Name>
				<Source><![CDATA[
    private boolean includeBalanceSheetAccounts()
    {
        return (mainAccountOptions == LedgerExchAdjMainAccountOptions::All ||
            mainAccountOptions == LedgerExchAdjMainAccountOptions::BalanceSheet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeProfitAndLossAccounts</Name>
				<Source><![CDATA[
    private boolean includeProfitAndLossAccounts()
    {
        return (mainAccountOptions == LedgerExchAdjMainAccountOptions::All ||
            mainAccountOptions == LedgerExchAdjMainAccountOptions::ProfitAndLoss);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAndPostAdjustments</Name>
				<Source><![CDATA[
    private boolean calculateAndPostAdjustments(
        LedgerVoucher _ledgerVoucher,
        Voucher _voucher,
        LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp,
        CompanyInfoRecId _companyInfoRecId)
    {
        boolean found = this.calculateAdjustments(_ledgerExchangeAdjustmentTmp, _companyInfoRecId);

        if (found)
        {
            this.postAdjustments(_ledgerVoucher, _voucher, _ledgerExchangeAdjustmentTmp, _companyInfoRecId);
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAdjustments</Name>
				<Source><![CDATA[
    protected boolean calculateAdjustments(
        LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp,
        CompanyInfoRecId _companyInfoRecId)
    {
        if (exchangeRateData == dateNull())
        {
            exchangeRateData = toDate;
        }

        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(_companyInfoRecId),
            exchangeRateData);

        boolean foundDiff = false;

        ttsbegin;

        while select forupdate * from _ledgerExchangeAdjustmentTmp
            order by PostingLayer, TransactionCurrencyCode, LedgerDimension
                where _ledgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
        {
            currencyExchangeHelper.parmExchangeRateTypeRecId(this.getExchangeRateType(_ledgerExchangeAdjustmentTmp));

            // Accounting and reporting adjustments are considered and posted separately since they can
            // vary independently. (e.g. One could be a gain, and the other a loss.)
            AmountMST accountingCurrencyNow = currencyExchangeHelper.calculateTransactionToAccounting(
                _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode,
                _ledgerExchangeAdjustmentTmp.TransactionCurrencyAmount,
                true);

            AmountMST accountingCurrencyAdjustment = this.calcAccountingCurrencyAdjustment(accountingCurrencyNow,
                                                                                        _ledgerExchangeAdjustmentTmp,
                                                                                        currencyExchangeHelper);

            if (accountingCurrencyAdjustment != 0)
            {
                _ledgerExchangeAdjustmentTmp.AccountingCurrencyAdjustmentAmount = accountingCurrencyAdjustment;
                foundDiff = true;
            }

            currencyExchangeHelper.parmReportingExchangeRateTypeRecId(this.getReportingCurrencyExchangeRateType(_ledgerExchangeAdjustmentTmp));
                
            AmountMST reportingCurrencyNow = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode,
                _ledgerExchangeAdjustmentTmp.TransactionCurrencyAmount);
                
            AmountMST reportingCurrencyAdjustment = CurrencyExchange::round(reportingCurrencyNow - _ledgerExchangeAdjustmentTmp.ReportingCurrencyAmount, Ledger::reportingCurrency());
                
            if (reportingCurrencyAdjustment != 0)
            {
                _ledgerExchangeAdjustmentTmp.ReportingCurrencyAdjustmentAmount = reportingCurrencyAdjustment;
                foundDiff = true;
            }

            //This is for an extension request
            _ledgerExchangeAdjustmentTmp.ExchangeRateType = this.getExchangeRateType(_ledgerExchangeAdjustmentTmp);
            _ledgerExchangeAdjustmentTmp.ReportingCurrencyExchangeRateType = this.getReportingCurrencyExchangeRateType(_ledgerExchangeAdjustmentTmp);

            _ledgerExchangeAdjustmentTmp.update();
        }

        delete_from _ledgerExchangeAdjustmentTmp
            where _ledgerExchangeAdjustmentTmp.AccountingCurrencyAdjustmentAmount == 0
                && _ledgerExchangeAdjustmentTmp.ReportingCurrencyAdjustmentAmount == 0
                && _ledgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId;

        CurrencyCode accountingCurrencyCode = Ledger::accountingCurrency(_companyInfoRecId);
        CurrencyCode reportingCurrencyCode = Ledger::reportingCurrency(_companyInfoRecId);

        ExchangeRateEffectiveView exchangeRates;

        update_recordset _ledgerExchangeAdjustmentTmp
            setting AccountingCurrencyCrossRate = exchangeRates.CrossRate
            where _ledgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
        join exchangeRates
            where exchangeRates.ExchangeRateType == _ledgerExchangeAdjustmentTmp.ExchangeRateType
                && exchangeRates.FromCurrencyCode == _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode
                && exchangeRates.ToCurrencyCode == accountingCurrencyCode
                && exchangeRates.ValidFrom <= exchangeRateData
                && exchangeRates.ValidTo >= exchangeRateData;

        update_recordset _ledgerExchangeAdjustmentTmp
            setting ReportingCurrencyCrossRate = exchangeRates.CrossRate
                where _ledgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
        join exchangeRates
            where exchangeRates.ExchangeRateType == _ledgerExchangeAdjustmentTmp.ReportingCurrencyExchangeRateType
                && exchangeRates.FromCurrencyCode == _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode
                && exchangeRates.ToCurrencyCode == reportingCurrencyCode
                && exchangeRates.ValidFrom <= exchangeRateData
                && exchangeRates.ValidTo >= exchangeRateData;

        ttscommit;

        return foundDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAccountingCurrencyAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the Accounting currency adjustment from the Accounting currency amount.
    /// </summary>
    /// <param name = "_accountingCurrencyNow">
    /// The Accounting currency amount that is used to calculate the Accounting currency adjustment.
    /// </param>
    /// <param name = "_ledgerExchangeAdjustmentTmp">
    /// The <c>LedgerExchangeAdjustmentTmp</c> record.
    /// </param>
    /// <param name = "_currencyExchangeHelper">
    /// The <c>CurrencyExchangeHelper</c> class.
    /// </param>
    /// <returns>
    /// The Accounting currency adjustment.
    /// </returns>
    protected AmountMST calcAccountingCurrencyAdjustment(AmountMST _accountingCurrencyNow,
                                                         LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp,
                                                         CurrencyExchangeHelper _currencyExchangeHelper)
    {
        AmountMST accountingCurrencyAdjustment = CurrencyExchange::round(_accountingCurrencyNow - _ledgerExchangeAdjustmentTmp.AccountingCurrencyAmount, Ledger::accountingCurrency());

        return accountingCurrencyAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeRateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exchange rate type for a given exchange adjustment record.
    /// </summary>
    /// <param name="_ledgerExchangeAdjustmentTmp">
    /// The <c>LedgerExchangeAdjustmentTmp</c> record.
    /// </param>
    /// <returns>
    /// The Exchange rate type record id.
    /// </returns>
    protected ExchangeRateTypeRecId getExchangeRateType(
        LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp)
    {
        return _ledgerExchangeAdjustmentTmp.ExchangeRateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyExchangeRateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reporting currency exchange rate type for a given exchange adjustment record.
    /// </summary>
    /// <param name="_ledgerExchangeAdjustmentTmp">
    /// The <c>LedgerExchangeAdjustmentTmp</c> record.
    /// </param>
    /// <returns>
    /// The Exchange rate type record id.
    /// </returns>
    protected ExchangeRateTypeRecId getReportingCurrencyExchangeRateType(
        LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp)
    {
        return _ledgerExchangeAdjustmentTmp.ReportingCurrencyExchangeRateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAdjustments</Name>
				<Source><![CDATA[
    private boolean postAdjustments(
        LedgerVoucher _ledgerVoucher,
        Voucher _voucher,
        LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp,
        CompanyInfoRecId _companyInfoRecId)
    {
        boolean foundDiff = false;

        while select * from _ledgerExchangeAdjustmentTmp
            order by PostingLayer, TransactionCurrencyCode, LedgerDimension
                where _ledgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
        {
            if (_ledgerExchangeAdjustmentTmp.AccountingCurrencyAdjustmentAmount != 0)
            {
                foundDiff = true;

                this.postAdjustment(
                    _ledgerVoucher,
                    _voucher,
                    _ledgerExchangeAdjustmentTmp,
                    _ledgerExchangeAdjustmentTmp.AccountingCurrencyAdjustmentAmount,
                    _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode,
                    true,
                    _companyInfoRecId);
            }

            if (_ledgerExchangeAdjustmentTmp.ReportingCurrencyAdjustmentAmount != 0)
            {
                foundDiff = true;

                this.postAdjustment(
                    _ledgerVoucher,
                    _voucher,
                    _ledgerExchangeAdjustmentTmp,
                    _ledgerExchangeAdjustmentTmp.ReportingCurrencyAdjustmentAmount,
                    _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode,
                    false,
                    _companyInfoRecId);
            }
        }

        return foundDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class twice with the
    ///    same parameters is not always possible. If the return value from the <see
    ///    cref="M:RunBaseBatch.canGoBatch" /> method is false this method will not have any effect.
    /// </remarks>
    protected boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be built by using the <c>Dialog</c> class or by using a class that is created in the
    ///    Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog = super();

        date currentDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        TransDate periodStartDate = LedgerFiscalCalendar::findFirstDayofPeriod(Ledger::fiscalCalendar(), currentDate);

        dialog.addGroup("@GeneralLedger:ForeignCurrencyRevaluationInformation").columns(2);

        dialogFromDate = dialog.addFieldValue(extendedtypestr(TransDate), periodStartDate, "@GeneralLedger:ForeignCurrencyRevaluationFromDate");

        dialogToDate = dialog.addFieldValue(extendedtypestr(TransDate), currentDate, "@GeneralLedger:ForeignCurrencyRevaluationToDate");

        this.setInternalDateRange();

        dialogExchangeRateDate = dialog.addFieldValue(extendedTypeStr(TransDate), currentDate, "@GeneralLedger:ForeignCurrencyRevalDateOfRate");

        dialog.addGroup('');
        accountSelection = dialog.addFieldValue(enumstr(LedgerExchAdjMainAccountOptions), mainAccountOptions, "@GeneralLedger:ForeignCurrencyRevaluationMainAccountsToRevalue");

        this.constructLegalEntityControl(dialog);

        dialogShowAllCurrencies = dialog.addFieldValue(extendedTypeStr(NoYesId), showAllCurrencies, "@GeneralLedger:ForeignCurrencyRevalShowAllCurrencies");

        this.constructCurrencyControl(dialog);

        dialogPreviewBeforePost = dialog.addFieldValue(extendedTypeStr(NoYesId), previewBeforePost, "@GeneralLedger:ForeignCurrencyRevalPreviewBeforePosting");

        dialogExcludeReportingCurrencyAdjustment = dialog.addFieldValue(
            extendedTypeStr(NoYesId), 
            excludeReportingCurrencyAdjustment,
            "@GeneralLedger:ReportingCurrencyAdjustmentExcluded",
            "@GeneralLedger:ReportingCurrencyAdjustmentExcludedHelper");

        Set userLegalEntitySet = LedgerSecurityHelper::ledgersWithMinimumSecurityAccess(menuItemActionStr(LedgerExchAdj), AccessRight::Edit, MenuItemType::Action);
        userLegalEntityRange = LedgerLegalEntityLookup::getLegalEntityRangeFromLegalEntitySet(userLegalEntitySet);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase dialog)
    {
        super(dialog);

        this.constructLegalEntityLookup(dialog);
        this.constructCurrencyLookup(dialog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        fromDate = dialogFromDate.value();
        toDate = dialogToDate.value();
        exchangeRateData = dialogExchangeRateDate.value();

        mainAccountOptions = accountSelection.value();

        if (currencySelectionLookup.parmCallingControlStr().valueStr())
        {
            currencyOptions = this.getCurrencySelection();
        }

        legalEntityOptions = legalEntityLookup.getLegalEntitySelection();

        previewBeforePost = dialogPreviewBeforePost.value();

        showAllCurrencies = dialogShowAllCurrencies.value();

        excludeReportingCurrencyAdjustment = dialogExcludeReportingCurrencyAdjustment.value();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencySelection</Name>
				<Source><![CDATA[
    private container getCurrencySelection()
    {
        container currencySelectedRecIds = currencySelectionLookup.getSelected();
        container currencySelection;

        for (int counter = 1; counter <= conLen(currencySelectedRecIds); counter++)
        {
            RecId currencyOption = conPeek(currencySelectedRecIds, counter);

            Currency currency = Currency::findRecId(currencyOption);

            currencySelection += currency.CurrencyCode;
        }

        return currencySelection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCurrencyControl</Name>
				<Source><![CDATA[
    private void constructCurrencyControl(DialogRunbase _dialog)
    {
        FormBuildGroupControl currentGroup = _dialog.form().design().control(_dialog.curFormGroup().name());
        FormBuildStringControl dialogCurrencyLookup = currentGroup.addControl(FormControlType::String, 'CurrencyLookup');
        dialogCurrencyLookup.extendedDataType(extendedTypeNum(LedgerExchAdjCurrencySelection));
        dialogCurrencyLookup.lookupOnly(true);
        dialogCurrencyLookupId = dialogCurrencyLookup.id();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructLegalEntityControl</Name>
				<Source><![CDATA[
    private void constructLegalEntityControl(DialogRunbase _dialog)
    {
        FormBuildGroupControl currentGroup = _dialog.form().design().control(_dialog.curFormGroup().name());
        FormBuildStringControl dialogLegalEntityLookup = currentGroup.addControl(FormControlType::String, 'LegalEntityLookup');
        dialogLegalEntityLookup.extendedDataType(extendedTypeNum(LedgerLegalEntitySelection));
        dialogLegalEntityLookup.lookupOnly(true);
        dialogLegalEntityLookupId = dialogLegalEntityLookup.id();
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the lookup for the currency selection.
    /// </summary>
    /// <param name = "_control">The <c>FormStringControl</c> object.</param>
    private void currencyLookup(FormStringControl _control)
    {
        showAllCurrencies = dialogShowAllCurrencies.value();
        currencySelectionLookup.parmQuery(this.constructCurrencySelectionQuery());

        if (!showAllCurrencies)
        {
            // The currency codes displayed are restricted by the transactions for the date range,
            // the query date range needs to be updated.
            this.setInternalDateRange();

            legalEntityOptions = legalEntityLookup.getLegalEntitySelection();

            TransDate periodStartDate = this.getFromDateForCurrencyLookup();

            SysQuery::findOrCreateRange(
                 currencySelectionLookup.parmQuery().dataSourceTable(tableNum(GeneralJournalEntry)),
                 fieldNum(GeneralJournalEntry, AccountingDate))
                 .value(SysQuery::range(periodStartDate, toDate));

            str ledgerRange = legalEntityLookup.getLedgerRangeFromLegalEntitySelection();

            SysQuery::findOrCreateRange(
                 currencySelectionLookup.parmQuery().dataSourceTable(tableNum(GeneralJournalEntry)),
                 fieldNum(GeneralJournalEntry, Ledger))
                 .value(SysQuery::value(ledgerRange));
        }

        currencySelectionLookup.run();

        // Update the display text with the selected values
        dialogCurrencySelection.text(dialogCurrencySelectionString.text());
    }

]]></Source>
			</Method>
			<Method>
				<Name>legalEntityLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the lookup for the legal entity selection.
    /// </summary>
    /// <param name = "_control">The <c>FormStringControl</c> object.</param>
    private void legalEntityLookup(FormStringControl _control)
    {
        legalEntityLookup.lookup(_control.text(), userLegalEntityRange);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCurrencyLookup</Name>
				<Source><![CDATA[
    private void constructCurrencyLookup(DialogRunbase _dialog)
    {
        TableId multiSelectTableNum = tableNum(Currency);
        Query query = this.constructCurrencySelectionQuery();
        container selectedFields = [multiSelectTableNum, fieldName2id(multiSelectTableNum, fieldStr(Currency, CurrencyCode))];

        dialogCurrencySelection = _dialog.formRun().design().control(dialogCurrencyLookupId);
        dialogCurrencySelection.registerOverrideMethod(
            methodstr(FormStringControl, lookup),
            methodstr(LedgerExchAdj, currencyLookup),
            this);

        // Construct required internal controls for multi-select lookup selection tracking
        dialogCurrencySelectionId = _dialog.formRun().design().addControl(FormControlType::String, dialogCurrencySelection.name() + 'Id');
        dialogCurrencySelectionId.extendedDataType(dialogCurrencySelection.extendedDataType());
        dialogCurrencySelectionId.visible(false);

        dialogCurrencySelectionString = _dialog.formRun().design().addControl(FormControlType::String, dialogCurrencySelection.name() + 'String');
        dialogCurrencySelectionString.extendedDataType(dialogCurrencySelection.extendedDataType());
        dialogCurrencySelectionString.visible(false);

        currencySelectionLookup = new SysLookupMultiSelectGrid();
        currencySelectionLookup.parmCallingControl(dialogCurrencySelection);
        currencySelectionLookup.parmQuery(query);
        currencySelectionLookup.parmSelectField(selectedFields);
        currencySelectionLookup.parmCallingControlId(dialogCurrencySelectionId);
        currencySelectionLookup.parmCallingControlStr(dialogCurrencySelectionString);

        // Reset the internal currency selection container so it does not retain values from previous runs
        currencyOptions = conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructLegalEntityLookup</Name>
				<Source><![CDATA[
    private void constructLegalEntityLookup(DialogRunbase _dialog)
    {
        dialoglegalEntitySelection = _dialog.formRun().design().control(dialogLegalEntityLookupId);
        legalEntityLookup = LedgerLegalEntityLookup::construct(_dialog.formRun(), dialoglegalEntitySelection);
        legalEntityLookup.setSelection([curExt()]);

        dialoglegalEntitySelection.registerOverrideMethod(
            methodstr(FormStringControl, lookup),
            methodstr(LedgerExchAdj, legalEntityLookup),
            this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCurrencySelectionQuery</Name>
				<Source><![CDATA[
    private Query constructCurrencySelectionQuery()
    {
        Query query = new Query();
        QueryBuildDataSource qbdsCurrency;

        this.setInternalDateRange();
        if (!showAllCurrencies)
        {
            qbdsCurrency = query.addDataSource(tableNum(Currency));
            qbdsCurrency.addGroupByField(fieldNum(Currency, CurrencyCode));
            qbdsCurrency.addGroupByField(fieldNum(Currency, RecId));
            qbdsCurrency.addSortField(fieldNum(Currency, CurrencyCode));

            QueryBuildDataSource qbds = qbdsCurrency.addDataSource(tableNum(GeneralJournalAccountEntry));
            qbds.joinMode(JoinMode::ExistsJoin);
            qbds.addLink(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode), fieldNum(Currency, CurrencyCode));

            QueryBuildDataSource qbdsHeader = qbds.addDataSource(tableNum(GeneralJournalEntry));
            qbdsHeader.joinMode(JoinMode::ExistsJoin);
            qbdsHeader.addLink(fieldNum(GeneralJournalAccountEntry, GeneralJournalEntry), fieldNum(GeneralJournalEntry, RecId));
            qbdsHeader.addRange(fieldNum(GeneralJournalEntry, Ledger)).value(SysQuery::value(Ledger::current()));

            QueryBuildRange qbr = qbdsHeader.addRange(fieldNum(GeneralJournalEntry, AccountingDate));
            qbr.value(SysQuery::range(fromDate, toDate));
        }
        else
        {
            qbdsCurrency = query.addDataSource(tableNum(Currency));
            qbdsCurrency.addGroupByField(fieldNum(Currency, CurrencyCode));
            qbdsCurrency.addGroupByField(fieldNum(Currency, RecId));
            qbdsCurrency.addSortField(fieldNum(Currency, CurrencyCode));
        }

        query.clearAllFields();
        qbdsCurrency.addSelectionField(fieldNum(Currency, CurrencyCode));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDateForCurrencyLookup</Name>
				<Source><![CDATA[
    private TransDate getFromDateForCurrencyLookup()
    {
        TransDate periodStartDate = fromDate;
        mainAccountOptions = accountSelection.value();

        // If balance sheet accounts are being revalued - the affected transaction currency lookup must consider transactions
        // from the opening period start date, not the from date specified
        if (this.includeBalanceSheetAccounts() && conLen(legalEntityOptions) > 0)
        {
            List legalEntityList = con2List(legalEntityOptions);
            ListEnumerator legalEntityListEnumerator = legalEntityList.getEnumerator();

            while (legalEntityListEnumerator.moveNext())
            {
                changecompany(legalEntityListEnumerator.current())
                {
                    TransDate openingPeriodStartDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(Ledger::fiscalCalendar(), fromDate);

                    if (periodStartDate > openingPeriodStartDate)
                    {
                        periodStartDate = openingPeriodStartDate;
                    }
                }
            }
        }

        return periodStartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructMainAccountSelectionQuery</Name>
				<Source><![CDATA[
    private Query constructMainAccountSelectionQuery()
    {
        Query userDefinedQuery = new Query();
        QueryBuildDataSource mainAccountDS;

        mainAccountDS = userDefinedQuery.addDataSource(tableNum(MainAccount));
        mainAccountDS.addRange(fieldNum(MainAccount, MainAccountId));
        mainAccountDS.allowAdd(QueryAllowAdd::NoFields);
        mainAccountDS.relations(false);

        return userDefinedQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInternalDateRange</Name>
				<Source><![CDATA[
    private void setInternalDateRange()
    {
        fromDate = dialogFromDate.value();
        toDate = dialogToDate.value();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustmentCurrencyAccountTypeGain</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>CurrencyGainLossAccountType</c> enumeration value for gain adjustment.
    /// </summary>
    /// <param name = "_ledgerExchangeAdjustmentTmp">The <c>LedgerExchangeAdjustmentTmp</c> record to use to determine account type.</param>
    /// <returns>The <c>CurrencyGainLossAccountType</c> enumeration value for gain.</returns>
    protected CurrencyGainLossAccountType getAdjustmentCurrencyAccountTypeGain(LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp)
    {
        return CurrencyGainLossAccountType::UnrealizedGain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustmentCurrencyAccountTypeLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>CurrencyGainLossAccountType</c> enumeration value for loss adjustment.
    /// </summary>
    /// <param name = "_ledgerExchangeAdjustmentTmp">The <c>LedgerExchangeAdjustmentTmp</c> record to use to determine account type.</param>
    /// <returns>The <c>CurrencyGainLossAccountType</c> enumeration value for loss.</returns>
    protected CurrencyGainLossAccountType getAdjustmentCurrencyAccountTypeLoss(LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp)
    {
        return CurrencyGainLossAccountType::UnrealizedLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAdjustment</Name>
				<Source><![CDATA[
    protected void postAdjustment(
        LedgerVoucher _ledgerVoucher,
        Voucher _voucher,
        LedgerExchangeAdjustmentTmp _ledgerExchangeAdjustmentTmp,
        AmountMST _adjustmentAmount,
        CurrencyCode _adjustmentGainLossCurrencyCode,
        boolean _isAccountingCurrencyAdjustment,
        CompanyInfoRecId _companyInfoRecId = CompanyInfo::current())
    {
        LedgerPostingType               posting;
        CurrencyGainLossAccountType     currencyAccountType;

        #ISOCountryRegionCodes
        boolean countryRegion_EE = this.isCurrentLegalEntityInCountryRegion([#isoEE]);

        boolean isBalanceSheet = _ledgerExchangeAdjustmentTmp.IsBalanceSheet;

        if ((isBalanceSheet && _adjustmentAmount > 0) || (!isBalanceSheet && _adjustmentAmount <= 0))
        {
            posting             = LedgerPostingType::ExchRateGain;
            currencyAccountType = this.getAdjustmentCurrencyAccountTypeGain(_ledgerExchangeAdjustmentTmp);

            // <GEEEE>
            if (countryRegion_EE)
            {
                currencyAccountType = CurrencyGainLossAccountType::FinancialGain;
            }
            // </GEEEE>
        }
        else
        {
            posting             = LedgerPostingType::ExchRateLoss;
            currencyAccountType = this.getAdjustmentCurrencyAccountTypeLoss(_ledgerExchangeAdjustmentTmp);

            // <GEEEE>
            if (countryRegion_EE)
            {
                currencyAccountType = CurrencyGainLossAccountType::FinancialLoss;
            }
            // </GEEEE>
        }

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        LedgerDimensionAccount revaluedAccountDimension = _ledgerExchangeAdjustmentTmp.LedgerDimension;

        CurrencyCode transactionCurrencyCode = _ledgerExchangeAdjustmentTmp.TransactionCurrencyCode;

        if (countryRegion_RU)
        {
            RTax25ExchAdjDimension exchAdjDimension = new RTax25ExchAdjDimension();
            LedgerCurrencyParameters_RU ledgerCurrencyParameters = LedgerCurrencyParameters_RU::findParameters(Ledger::current(), transactionCurrencyCode);
            exchAdjDimension.setProfitIds(ledgerCurrencyParameters.rTax25ProfitTableProfit, ledgerCurrencyParameters.rTax25ProfitTableLoss);
            exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(posting));
            revaluedAccountDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(revaluedAccountDimension, exchAdjDimension.getDefaultDimension(LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(revaluedAccountDimension)));
        }
        // </GEERU>

        AmountMST accountingCurrencyAdjustment;
        AmountMSTSecondary reportingCurrencyAdjustment;

        // Accounting currency and reporting currency adjustments will always be posted
        // separately since they can vary independently.
        if (_isAccountingCurrencyAdjustment)
        {
            accountingCurrencyAdjustment = _adjustmentAmount;
            reportingCurrencyAdjustment = 0;
        }
        else
        {
            accountingCurrencyAdjustment = 0;
            reportingCurrencyAdjustment = _adjustmentAmount;
        }

        CurrentOperationsTax postingLayer = _ledgerExchangeAdjustmentTmp.PostingLayer;

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject(
            _voucher,
            toDate,
            postingLayer);

        if (ledgerVoucherObject == null)
        {
            ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                _voucher,
                toDate,
                SysModule::Ledger,
                LedgerTransType::ExchAdjustment);

            ledgerVoucherObject.parmPostingLayer(postingLayer);

            TransactionTextLarge transactionTxt = this.getTransactionTxt(_ledgerVoucher, _voucher, ledgerVoucherObject);

            ledgerVoucherObject.lastTransTxt(transactionTxt);

            _ledgerVoucher.addVoucher(ledgerVoucherObject);
        }

        // Method used for extensibility to update transaction text
        ledgerVoucherObject.lastTransTxt(this.updateTransTxt(_ledgerVoucher, _voucher, ledgerVoucherObject));

        // Post to the account being adjusted
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
            ledgerVoucherObject,
            posting,
            // <GEERU>
            revaluedAccountDimension,
            // </GEERU>
            transactionCurrencyCode,
            accountingCurrencyAdjustment,
            reportingCurrencyAdjustment);

        // The dimensions associated with this account being revalued may no longer be valid
        // according to current account rules, so skip dimension validation. For this process,
        // posting is more important than validating dimensions.
        ledgerVoucherTransObject.parmSkipDimensionValidation(true);

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        // Post to the gain/loss account
        LedgerDimensionDefaultAccount regLedgerDimension;
        
        regLedgerDimension = this.getGainLossAccountFromPostingProfile(
            _adjustmentGainLossCurrencyCode,
            currencyAccountType,
            LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(revaluedAccountDimension));

        if (regLedgerDimension == 0)
        {
            regLedgerDimension = this.getGainLossAccount(_companyInfoRecId, _adjustmentGainLossCurrencyCode, currencyAccountType);
        }

        LedgerDimensionAccount ledgerDimensionMerged = this.getMergedLedgerDim(regLedgerDimension, revaluedAccountDimension);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
            ledgerVoucherObject,
            posting,
            ledgerDimensionMerged,
            transactionCurrencyCode,
            -accountingCurrencyAdjustment,
            -reportingCurrencyAdjustment);

        // The default dimensions used with this account were taken from the account being
        // revalued. Since it could have dimensions that are no longer valid according to
        // the current rules, skip dimension validation. For this process, posting is more
        // important than validating dimensions.
        ledgerVoucherTransObject.parmSkipDimensionValidation(true);

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        // <GEERU>
        _ledgerVoucher.bondLast2_RU();
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrentLegalEntityInCountryRegion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the current legal entity has any of the specified country codes.
    /// </summary>
    /// <param name="_isoCountryCodes">
    /// A container that contains a list of ISO country codes.
    /// </param>
    /// <returns>
    /// True if match is found; otherwise, false.
    /// </returns>
    protected boolean isCurrentLegalEntityInCountryRegion(container _isoCountryCodes)
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion(_isoCountryCodes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// To update the transaction text.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> record.
    /// </param>
    /// <param name="_voucher">
    /// The Voucher.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> object.
    /// </param>
    /// <returns>
    /// The Last transaction text.
    /// </returns>
    protected TransTxt updateTransTxt(
        LedgerVoucher _ledgerVoucher,
        Voucher _voucher,
        LedgerVoucherObject _ledgerVoucherObject)
    {
        return _ledgerVoucherObject.lastTransTxt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGainLossAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Adjustment gain and loss account.
    /// </summary>
    /// <param name = "_companyInfoRecId">
    /// The Company info record id.
    /// </param>
    /// <param name = "_adjustmentGainLossCurrencyCode">
    /// The Adjustment gain loss currency code.
    /// </param>
    /// <param name = "_currencyAccountType">
    /// The Currency account type.
    /// </param>
    /// <returns>
    /// The Ledger dimension account.
    /// </returns>
    protected LedgerDimensionDefaultAccount getGainLossAccount(CompanyInfoRecId _companyInfoRecId, CurrencyCode _adjustmentGainLossCurrencyCode, CurrencyGainLossAccountType _currencyAccountType)
    {
        LedgerDimensionDefaultAccount registerLedgerDimension = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(_companyInfoRecId),
            _adjustmentGainLossCurrencyCode,
            _currencyAccountType);

        return registerLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGainLossAccountFromPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Adjustment gain and loss account from posting profile.
    /// </summary>
    /// <param name = "_currencyCode">
    /// The Adjustment gain loss currency code.
    /// </param>
    /// <param name = "_accountType">
    /// The Currency account type.
    /// </param>
    /// <param name = "_accountNum">
    /// The account number.
    /// </param>
    /// <returns>
    /// The Ledger dimension account.
    /// </returns>
    protected LedgerDimensionDefaultAccount getGainLossAccountFromPostingProfile(
        CurrencyCode _currencyCode,
        CurrencyGainLossAccountType _accountType,
        MainAccountNum _accountNum)
    {
        LedgerDimensionDefaultAccount registerLedgerDimension = LedgerExchAdjPosting::getLedgerDimensionFromParameters(
                LedgerExchAdjPostingSearchParameters::newFromParameters(
                    LedgerExchAdjPostingModule::GeneralLedger,
                    _accountType,
                    _currencyCode,
                    _accountNum));

        return registerLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMergedLedgerDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Merged ledger dimension account.
    /// </summary>
    /// <param name = "_regLedgerDimension">
    /// The Register ledger dimension.
    /// </param>
    /// <param name = "_revaluedAccountDimension">
    /// The Revalued account dimension.
    /// </param>
    /// <returns>
    /// The Merged ledger dimension account.
    /// </returns>
    protected LedgerDimensionAccount getMergedLedgerDim(LedgerDimensionDefaultAccount _regLedgerDimension, LedgerDimensionAccount _revaluedAccountDimension)
    {
        LedgerDimensionAccount ledgerDimMerged = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
            _regLedgerDimension,
            _revaluedAccountDimension);

        return ledgerDimMerged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction text for the exchange adjustment.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> record.
    /// </param>
    /// <param name="_voucher">
    /// The Voucher.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> object.
    /// </param>
    /// <returns>
    /// The Adjustment transaction text.
    /// </returns>
    protected TransactionTextLarge getTransactionTxt(LedgerVoucher _ledgerVoucher, Voucher _voucher, ledgerVoucherObject _ledgerVoucherObject)
    {
        TransactionTxt transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::LedgerExchAdj);
        transactionTxt.setVoucher(_voucher);

        return transactionTxt.txt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount

        boolean foundDiff;

        // Save a copy of the original user-provided query for the history table, before we add our additional tables and ranges.
        SysQueryablePacked originalUserQueryPacked = queryRun.query().pack();

        #ISOCountryRegionCodes

        GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes([
            [#isoEE, GlobalizationConstants::FeatureReferenceEE00002] ],
            funcName()
        );

        try
        {
            MainAccount                         mainAccount;
            FiscalCalendarPeriod                fiscalCalendarPeriod;
            GeneralJournalEntry                 generalJournalEntry;
            GeneralJournalAccountEntry          generalJournalAccountEntry;
            LedgerExchangeAdjustmentTmp         ledgerExchangeAdjustmentTmp;
            LedgerExchangeAdjustmentTmp         ledgerExchangeAdjustmentTmpUpdate;
            LedgerTransSettlement               ledgerTransSettlement;

            // Use a local instance since using the form's buffer directly can cause performance degradation.
            if (exchangeAdjustmentTempTable != '')
            {
                ledgerExchangeAdjustmentTmp.useExistingTempDBTable(exchangeAdjustmentTempTable);
            }

            ttsbegin;

            List legalEntityList = con2List(legalEntityOptions);
            ListEnumerator legalEntityListEnumerator = legalEntityList.getEnumerator();

            while (legalEntityListEnumerator.moveNext())
            {
                changecompany(legalEntityListEnumerator.current())
                {
                    CompanyInfo companyInfo = CompanyInfo::findDataArea(legalEntityListEnumerator.current());

                    if (runMode == LedgerExchAdjRunMode::CalculateOnly || runMode == LedgerExchAdjRunMode::CalculateAndPost)
                    {
                        TransDate periodStartDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(Ledger::fiscalCalendar(), fromDate);
                        LedgerChartOfAccountsRecId ledgerChartOfAccounts = LedgerChartOfAccounts::current();
                        LedgerRecId ledgerRecId = Ledger::current();
                        boolean isBalanceSheet = false;

                        // Create a query template that each processing option can duplicate so that balance sheet criteria doesn't interfere with profit loss criteria
                        Query processQueryTemplate = new Query(queryRun.query());

                        this.constructProcessQuery(processQueryTemplate);

                        Map targetToSourceMap = this.constructTargetToSourceMap(processQueryTemplate);

                        if (this.includeBalanceSheetAccounts())
                        {
                            isBalanceSheet = true;

                            // Create a copy for balance sheet accounts
                            Query balanceSheetProcessQuery = new Query(processQueryTemplate);

                            // Apply balance sheet account specific filters
                            QueryBuildDataSource generalJournalEntryDS = balanceSheetProcessQuery.dataSourceTable(tableNum(GeneralJournalEntry));
                            generalJournalEntryDS.clearRange(fieldNum(GeneralJournalEntry, AccountingDate));

                            SysQuery::findOrCreateRange(
                                generalJournalEntryDS,
                                fieldNum(GeneralJournalEntry, AccountingDate))
                                .value(SysQuery::range(periodStartDate, toDate, true)
                            );

                            QueryBuildDataSource mainAccountDS = balanceSheetProcessQuery.dataSourceTable(tableNum(MainAccount));
                            mainAccountDS.clearRange(fieldNum(MainAccount, Type));

                            SysQuery::findOrCreateRange(
                                mainAccountDS,
                                fieldNum(MainAccount, Type))
                                .value(SysQuery::value(DimensionLedgerAccountType::BalanceSheet)
                            );

                            mainAccountDS.addRange(fieldNum(MainAccount, Type)).value(queryValue(DimensionLedgerAccountType::Equity));
                            mainAccountDS.addRange(fieldNum(MainAccount, Type)).value(queryValue(DimensionLedgerAccountType::Asset));
                            mainAccountDS.addRange(fieldNum(MainAccount, Type)).value(queryValue(DimensionLedgerAccountType::Liability));

                            if (LedgerParameters::isCommonAccountType_CN())
                            {
                                mainAccountDS.addRange(fieldNum(MainAccount, Type)).value(queryValue(DimensionLedgerAccountType::Common_CN));
                            }

                            Query::insert_recordset(ledgerExchangeAdjustmentTmp, targetToSourceMap, balanceSheetProcessQuery);

                            update_recordset ledgerExchangeAdjustmentTmp
                                setting IsBalanceSheet = NoYes::Yes
                                where ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId;
                        }

                        if (this.includeProfitAndLossAccounts())
                        {
                            // Create a copy for profit loss accounts
                            Query profitLossProcessQuery = new Query(processQueryTemplate);

                            // Apply profit loss account specific filters
                            QueryBuildDataSource generalJournalEntryDS = profitLossProcessQuery.dataSourceTable(tableNum(GeneralJournalEntry));
                            generalJournalEntryDS.clearRange(fieldNum(GeneralJournalEntry, AccountingDate));

                            SysQuery::findOrCreateRange(
                                generalJournalEntryDS,
                                fieldNum(GeneralJournalEntry, AccountingDate))
                                .value(SysQuery::range(fromDate, toDate, true)
                            );

                            QueryBuildDataSource mainAccountDS = profitLossProcessQuery.dataSourceTable(tableNum(MainAccount));
                            mainAccountDS.clearRange(fieldNum(MainAccount, Type));

                            SysQuery::findOrCreateRange(
                                mainAccountDS,
                                fieldNum(MainAccount, Type))
                                .value(SysQuery::value(DimensionLedgerAccountType::ProfitAndLoss)
                            );

                            mainAccountDS.addRange(fieldNum(MainAccount, Type)).value(queryValue(DimensionLedgerAccountType::Revenue));
                            mainAccountDS.addRange(fieldNum(MainAccount, Type)).value(queryValue(DimensionLedgerAccountType::Expense));

                            Query::insert_recordset(ledgerExchangeAdjustmentTmp, targetToSourceMap, profitLossProcessQuery);
                        }

                        // Update the exchange rate type for the main account to reflect any company level overrides
                        MainAccountLegalEntity mainAccountLegalEntity;

                        update_recordSet ledgerExchangeAdjustmentTmp
                            setting ExchangeRateType = mainAccountLegalEntity.ExchangeAdjustmentRateType
                            where ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId
                            join mainAccountLegalEntity where mainAccountLegalEntity.MainAccount == ledgerExchangeAdjustmentTmp.MainAccount &&
                                mainAccountLegalEntity.LegalEntity == companyInfo.RecId &&
                                mainAccountLegalEntity.ExchangeAdjustmentRateType != 0;

                        update_recordSet ledgerExchangeAdjustmentTmp
                            setting ReportingCurrencyExchangeRateType = mainAccountLegalEntity.ReportingExchangeAdjustmentRateType
                            where ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId
                            join mainAccountLegalEntity where mainAccountLegalEntity.MainAccount == ledgerExchangeAdjustmentTmp.MainAccount &&
                                mainAccountLegalEntity.LegalEntity == companyInfo.RecId &&
                                mainAccountLegalEntity.ReportingExchangeAdjustmentRateType != 0;

                        // Any adjustment records that don't have an ExchangeRateType get the default Ledger exchange rate type
                        ExchangeRateTypeRecId ledgerDefaultExchangeRateType = Ledger::find(Ledger::current()).DefaultExchangeRateType;

                        update_recordset ledgerExchangeAdjustmentTmp
                            setting ExchangeRateType = ledgerDefaultExchangeRateType
                                where ledgerExchangeAdjustmentTmp.ExchangeRateType == 0 &&
                                    ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId;

                        ExchangeRateTypeRecId reportingExchangeRateType = Ledger::reportingCurrencyExchangeRateType();
                        
                        if (!reportingExchangeRateType)
                        {
                            // default back to ledger exchange rate
                            reportingExchangeRateType = ledgerDefaultExchangeRateType;
                        }

                        // Set reporting currency
                        update_recordset ledgerExchangeAdjustmentTmp
                            setting ReportingCurrencyExchangeRateType = reportingExchangeRateType
                                where ledgerExchangeAdjustmentTmp.ReportingCurrencyExchangeRateType == 0 &&
                                    ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId;

                        // <GEERU>
                        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

                        if (countryRegion_RU)
                        {
                            try
                            {
                                RTax25ExchAdjDimension exchAdjDimension = new RTax25ExchAdjDimension();
                                exchAdjDimension.setProfitIds(0, 0);
                                exchAdjDimension.parmExchAdjType(RTax25ExchAdjType::Gain);

                                ledgerExchangeAdjustmentTmp.takeOwnershipOfTempDBTable(true);
                                ledgerExchangeAdjustmentTmpUpdate.takeOwnershipOfTempDBTable(true);
                                ledgerExchangeAdjustmentTmpUpdate.linkPhysicalTableInstance(ledgerExchangeAdjustmentTmp);

                                while select LedgerDimension from ledgerExchangeAdjustmentTmp
                                    group by ledgerExchangeAdjustmentTmp.LedgerDimension
                                    where ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId
                                {
                                    DimensionDefault defaultDimension = exchAdjDimension.getDefaultDimension(
                                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerExchangeAdjustmentTmp.LedgerDimension));
                                    LedgerDimensionAccount ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerExchangeAdjustmentTmp.LedgerDimension, defaultDimension);

                                    if (ledgerExchangeAdjustmentTmp.LedgerDimension != ledgerDimension)
                                    {
                                        update_recordSet ledgerExchangeAdjustmentTmpUpdate
                                            setting LedgerDimension = ledgerDimension
                                            where ledgerExchangeAdjustmentTmpUpdate.LedgerDimension == ledgerExchangeAdjustmentTmp.LedgerDimension &&
                                                ledgerExchangeAdjustmentTmp.LegalEntity == companyInfo.RecId;
                                    }
                                }
                            }
                            finally
                            {
                                if (FeatureStateProvider::isFeatureEnabled(LedgerExchangeAdjustmentTmpReleaseOwnershipFlight::instance()))
                                {
                                    // As ledgerExchangeAdjustmentTmp and ledgerExchangeAdjustmentTmpUpdate are the same temp table,
                                    // only one time releasing ownership for the temp table is needed. 
                                    ledgerExchangeAdjustmentTmp.takeOwnershipOfTempDBTable(false);
                                }
                            }
                        }
                        // </GEERU>

                        if (isLedgerExchAdjAggregateDimensionsFlightEnabled)
                        {
                            // The following method will combine records in the ledgerExchangeAdjustmentTmp table based on
                            // their LedgerDimension values.  There could be 2 or more ledger dimensions pointing to the same account.
                            // These multiple dimensions are due to the dimensions getting re-hashed to version 2
                            //
                            // In short, the following process does the following:
                            // 1) Updates each record in the LedgerExchangeAdjustmentTmp table with a valide DisplayValue (from DAVC table)
                            // 2) Gather a list of all records in the ledgerExchangeAdjustmentTmp table that have multiple instance of the same DisplayValue
                            // 3) Run these records through the dimensionStorage.save() method to record the correct logical LedgerDimension
                            // 4) Update so all "duplicate" records have the same LedgerDimension value
                            // 5) Insert back into the LedgerExchangeAdjustmentTmp the aggregated result set, based on LedgerDimension (and TransactionCurrencyCode)
                            this.aggregateAccountsWithDuplicateLedgerDimensions(ledgerExchangeAdjustmentTmp, companyInfo.RecId);
                        }

                        foundDiff = this.calculateAdjustments(ledgerExchangeAdjustmentTmp, companyInfo.RecId);
                    }

                    if ((runMode == LedgerExchAdjRunMode::CalculateAndPost && foundDiff) || runMode == LedgerExchAdjRunMode::PostOnly)
                    {
                        NumberSeq numberSeq = NumberSeq::newGetVoucher(LedgerParameters::numRefLedgerExchAdjVoucher(), false);
                        this.parmVoucher(numberSeq.voucher());

                        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(
                            DetailSummary::Summary,
                            SysModule::Ledger,
                            numberSeq.parmVoucherSequenceCode());

                        foundDiff = false;

                        if (ledgerVoucher)
                        {
                            ledgerVoucher.parmCheckBlockedDimensions(false);

                            foundDiff = this.postAdjustments(ledgerVoucher, voucher, ledgerExchangeAdjustmentTmp, companyInfo.RecId);

                            ledgerVoucher.end();
                        }

                        if (foundDiff)
                        {
                            LedgerExchAdjHist exchangeAdjustmentHistory;
                            exchangeAdjustmentHistory.FromDate = fromDate;
                            exchangeAdjustmentHistory.ToDate = toDate;
                            exchangeAdjustmentHistory.ExchangeRateDate = exchangeRateData;
                            exchangeAdjustmentHistory.MainAccountOptions = mainAccountOptions;
                            exchangeAdjustmentHistory.CurrencySelection = con2Str(this.parmCurrencyOptions(), ',');
                            exchangeAdjustmentHistory.LegalEntity = curExt();
                            exchangeAdjustmentHistory.QueryPacked = originalUserQueryPacked;
                            exchangeAdjustmentHistory.AccountingDate = toDate;
                            exchangeAdjustmentHistory.SubledgerVoucher = voucher;
                            exchangeAdjustmentHistory.Ledger = Ledger::current();
                            exchangeAdjustmentHistory.insert();
                        }
                        else
                        {
                            numberSeq.abort();
                        }

                        TransactionLog::create(TransactionLogType::LedgerExchAdj, voucher);
                    }
                }
            }

            if (foundDiff)
            {
                info("@GeneralLedger:ForeignCurrencyRevalComplete");
            }
            else
            {
                info("@GeneralLedger:ForeignCurrencyRevalCompleteNoAdjustments");
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregateAccountsWithDuplicateLedgerDimensions</Name>
				<Source><![CDATA[
    private void aggregateAccountsWithDuplicateLedgerDimensions(
        LedgerExchangeAdjustmentTmp _sourceLedgerExchangeAdjustmentTmp,
        RecId _companyInfoRecId)
    {
        // Update the records with the corresponding DisplayValue from DAVC table
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        update_recordset _sourceLedgerExchangeAdjustmentTmp
            setting DisplayValue = dimensionAttributeValueCombination.DisplayValue
            where _sourceLedgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == _sourceLedgerExchangeAdjustmentTmp.LedgerDimension;
        
        LedgerExchangeAdjustmentWorkTmp duplicateLedgerDimensions;
        LedgerExchangeAdjustmentWorkTmp duplicateCounts;

        // Get a count of how many ledger dimensions have the same Display Value
        insert_recordset duplicateCounts
        (
            DuplicateCount,
            DisplayValue,
            TransactionCurrencyCode
        )
        select count(RecId), DisplayValue, TransactionCurrencyCode from _sourceLedgerExchangeAdjustmentTmp
            group by _sourceLedgerExchangeAdjustmentTmp.DisplayValue,
                _sourceLedgerExchangeAdjustmentTmp.TransactionCurrencyCode
            where _sourceLedgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId;

        // Update with the corresponding LedgerDimension values
        insert_recordset duplicateLedgerDimensions
        (
            DuplicateCount,
            DisplayValue,
            TransactionCurrencyCode,
            LedgerDimension
         )
        select DuplicateCount,DisplayValue,TransactionCurrencyCode from duplicateCounts
        join LedgerDimension from _sourceLedgerExchangeAdjustmentTmp
            where duplicateCounts.DisplayValue == _sourceLedgerExchangeAdjustmentTmp.DisplayValue
                && duplicateCounts.TransactionCurrencyCode == _sourceLedgerExchangeAdjustmentTmp.TransactionCurrencyCode
                && _sourceLedgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
                && duplicateCounts.DuplicateCount > 1;

        int affectedRows = int642int(duplicateLedgerDimensions.RowCount());

        // if no duplicates found, no sense in running the rest of this code
        if (affectedRows > 0)
        {
            const str className = classStr(LedgerExchAdj);

            SysInstrumentationLogger instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(className);
            instrumentationLogger.logInformation(
                    strFmt('%1 duplicate records found in foreign currency revaluation process for company %2',
                    affectedRows,
                    _companyInfoRecId));
            
            while select forupdate * from duplicateLedgerDimensions
            {
                // This will update the LogicalLedgerDimension value for each record with the "true" LedgerDimension
                // i.e.  What the system now interprets the LedgerDimension should be (same as the LedgerDimensionFacade.AreEqual() method
                DimensionStorage dimensionStorage = dimensionStorage::findById(duplicateLedgerDimensions.LedgerDimension);
                duplicateLedgerDimensions.LogicalLedgerDimension = dimensionStorage.save();
                duplicateLedgerDimensions.update();
            }

            LedgerExchangeAdjustmentTmp destinationLedgerExchangeAdjustmentTmp;
            this.moveResultsToDestinationTempTable(
                _sourceLedgerExchangeAdjustmentTmp,
                destinationLedgerExchangeAdjustmentTmp,
                duplicateLedgerDimensions,
                _companyInfoRecId);
        
            // Make sure the records determined to belong to the same LedgerDimension all have the same LedgerDimension value
            update_recordset destinationLedgerExchangeAdjustmentTmp
                setting LedgerDimension = duplicateLedgerDimensions.LogicalLedgerDimension
            join duplicateLedgerDimensions
                where destinationLedgerExchangeAdjustmentTmp.LedgerDimension == duplicateLedgerDimensions.LedgerDimension
                    && destinationLedgerExchangeAdjustmentTmp.TransactionCurrencyCode == duplicateLedgerDimensions.TransactionCurrencyCode;

            // Aggregate the duplicate LedgerDimension records into the source temp table
            this.finalizeTempTableResults(_sourceLedgerExchangeAdjustmentTmp, destinationLedgerExchangeAdjustmentTmp, _companyInfoRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveResultsToDestinationTempTable</Name>
				<Source><![CDATA[
    private void moveResultsToDestinationTempTable(
        LedgerExchangeAdjustmentTmp _sourceLedgerExchangeAdjustmentTmp,
        LedgerExchangeAdjustmentTmp _destinationLedgerExchangeAdjustmentTmp,
        LedgerExchangeAdjustmentWorkTmp _duplicateLedgerDimensions,
        RecId _companyInfoRecId)
    {
        insert_recordset _destinationLedgerExchangeAdjustmentTmp
        (
            AccountingCurrencyAmount,
            IsBalanceSheet,
            LedgerDimension,
            DisplayValue,
            PostingLayer,
            ReportingCurrencyAmount,
            TransactionCurrencyAmount,
            TransactionCurrencyCode,
            ExchangeRateType,
            MainAccount,
            AccountingCurrencyAdjustmentAmount,
            ReportingCurrencyAdjustmentAmount,
            AccountingCurrencyCrossRate,
            ReportingCurrencyCrossRate,
            LegalEntity,
            ReportingCurrencyExchangeRateType
        )
        select AccountingCurrencyAmount,
            IsBalanceSheet,
            LedgerDimension,
            DisplayValue,
            PostingLayer,
            ReportingCurrencyAmount,
            TransactionCurrencyAmount,
            TransactionCurrencyCode,
            ExchangeRateType,
            MainAccount,
            AccountingCurrencyAdjustmentAmount,
            ReportingCurrencyAdjustmentAmount,
            AccountingCurrencyCrossRate,
            ReportingCurrencyCrossRate,
            LegalEntity,
            ReportingCurrencyExchangeRateType
        from _sourceLedgerExchangeAdjustmentTmp
        exists join _duplicateLedgerDimensions
            where _sourceLedgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
            && _sourceLedgerExchangeAdjustmentTmp.LedgerDimension == _duplicateLedgerDimensions.LedgerDimension
            && _sourceLedgerExchangeAdjustmentTmp.TransactionCurrencyCode == _duplicateLedgerDimensions.TransactionCurrencyCode;

        delete_from _sourceLedgerExchangeAdjustmentTmp
        exists join _duplicateLedgerDimensions
            where _sourceLedgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId
            && _sourceLedgerExchangeAdjustmentTmp.LedgerDimension == _duplicateLedgerDimensions.LedgerDimension
            && _sourceLedgerExchangeAdjustmentTmp.TransactionCurrencyCode == _duplicateLedgerDimensions.TransactionCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeTempTableResults</Name>
				<Source><![CDATA[
    private void finalizeTempTableResults(
        LedgerExchangeAdjustmentTmp _sourceLedgerExchangeAdjustmentTmp,
        LedgerExchangeAdjustmentTmp _destinationLedgerExchangeAdjustmentTmp,
        RecId _companyInfoRecId)
    {
        insert_recordset _sourceLedgerExchangeAdjustmentTmp
        (
            PostingLayer,
            LedgerDimension,
            TransactionCurrencyCode,
            AccountingCurrencyAmount,
            IsBalanceSheet,
            DisplayValue,
            ReportingCurrencyAmount,
            TransactionCurrencyAmount,
            ExchangeRateType,
            MainAccount,
            AccountingCurrencyAdjustmentAmount,
            ReportingCurrencyAdjustmentAmount,
            AccountingCurrencyCrossRate,
            ReportingCurrencyCrossRate,
            LegalEntity,
            ReportingCurrencyExchangeRateType
        )
        select
            PostingLayer,
            LedgerDimension,
            TransactionCurrencyCode,
            sum(AccountingCurrencyAmount),
            minof(IsBalanceSheet),
            maxof(DisplayValue),
            sum(ReportingCurrencyAmount),
            sum(TransactionCurrencyAmount),
            maxof(ExchangeRateType),
            maxof(MainAccount),
            sum(AccountingCurrencyAdjustmentAmount),
            sum(ReportingCurrencyAdjustmentAmount),
            maxof(AccountingCurrencyCrossRate),
            maxof(ReportingCurrencyCrossRate),
            maxof(LegalEntity),
            maxof(ReportingCurrencyExchangeRateType)
        from _destinationLedgerExchangeAdjustmentTmp
        group by
            _destinationLedgerExchangeAdjustmentTmp.PostingLayer,
            _destinationLedgerExchangeAdjustmentTmp.LedgerDimension,
            _destinationLedgerExchangeAdjustmentTmp.TransactionCurrencyCode
        where _destinationLedgerExchangeAdjustmentTmp.LegalEntity == _companyInfoRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructProcessQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the query used when processing exchange rate adjustments.
    /// </summary>
    /// <param name = "_query">The initial query used to construct the process query.</param>
    protected void constructProcessQuery(Query _query)
    {
        // Main account as the root data source, which will pick up any user specific filters
        QueryBuildDataSource qbdsMA = _query.dataSourceTable(tableNum(MainAccount));
        qbdsMA.addRange(fieldNum(MainAccount, ExchangeAdjusted)).value(SysQuery::value(NoYes::Yes));
        qbdsMA.addGroupByField(fieldNum(MainAccount, RecId));
        qbdsMA.addGroupByField(fieldNum(MainAccount, ExchangeAdjustmentRateType));
        qbdsMA.addGroupByField(fieldNum(MainAccount, ReportingExchangeAdjustmentRateType));
        qbdsMA.fields().dynamic(QueryFieldListDynamic::No);

        QueryBuildDataSource qbdsGJAE = qbdsMA.addDataSource(tableNum(GeneralJournalAccountEntry));
        qbdsGJAE.fetchMode(QueryFetchMode::One2One);
        qbdsGJAE.joinMode(JoinMode::InnerJoin);
        qbdsGJAE.addLink(fieldnum(MainAccount, RecId), fieldNum(GeneralJournalAccountEntry, MainAccount));
        qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));
        qbdsGJAE.fields().dynamic(QueryFieldListDynamic::No);

        SysQuery::findOrCreateRange(qbdsGJAE, fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode)).value(con2Str(currencyOptions, ','));

        // Filter General journal entry to the current date range
        QueryBuildDataSource qbdsGJE = qbdsGJAE.addDataSource(tableNum(GeneralJournalEntry));
        qbdsGJE.fetchMode(QueryFetchMode::One2One);
        qbdsGJE.joinMode(JoinMode::InnerJoin);
        qbdsGJE.addLink(fieldNum(GeneralJournalAccountEntry, GeneralJournalEntry), fieldNum(GeneralJournalEntry, RecId));

        // When excludeReportingCurrencyAdjustment is true,
        // the account balance query for the reporting currency amount excludes amounts 
        // entered in the reporting currency adjustment journal.
        // These amounts are excluded as they are intended to be fixed adjustments to
        // the reporting currency account balance for the company/ledger's defined reporting currency.
        if (excludeReportingCurrencyAdjustment)
        {
            QueryBuildRange qbrJournalCategory = qbdsGJE.addRange(fieldNum(GeneralJournalEntry, JournalCategory));
            qbrJournalCategory.value(SysQuery::valueNot(queryValue(LedgerTransType::ReportingCurrencyAdjustment)));
        }

        GeneralJournalEntry::addSecureRangeForLedger(qbdsGJE);
        qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntry, PostingLayer));
        qbdsGJE.fields().dynamic(QueryFieldListDynamic::No);

        // Add Ledger to obtain legal entity reference
        QueryBuildDataSource qbdsLedger = qbdsGJE.addDataSource(tableNum(Ledger));
        qbdsLedger.fetchMode(QueryFetchMode::One2One);
        qbdsLedger.joinMode(JoinMode::InnerJoin);
        qbdsLedger.addLink(fieldNum(GeneralJournalEntry, Ledger), fieldnum(Ledger, RecId));
        qbdsLedger.fields().dynamic(QueryFieldListDynamic::No);
        qbdsLedger.addGroupByField(fieldNum(Ledger, PrimaryForLegalEntity));

        // Verify fiscal period
        QueryBuildDataSource qbdsFCP = qbdsGJE.addDataSource(tableNum(FiscalCalendarPeriod));
        qbdsFCP.fetchMode(QueryFetchMode::One2One);
        qbdsFCP.joinMode(JoinMode::ExistsJoin);
        qbdsFCP.addLink(fieldNum(GeneralJournalEntry, FiscalCalendarPeriod), fieldnum(FiscalCalendarPeriod, RecId));
        qbdsFCP.fields().dynamic(QueryFieldListDynamic::No);
        qbdsFCP.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(SysQuery::valueNot(FiscalPeriodType::Closing));

        if (LedgerTransSettlement::isLedgerSettlementsEnabled())
        {
            // Exclude records with LedgerTransSettlement link
            QueryBuildDataSource qbdsSettlement = qbdsGJAE.addDataSource(tableNum(LedgerTransSettlement));
            qbdsSettlement.joinMode(JoinMode::NoExistsJoin);
            qbdsSettlement.addLink(fieldNum(GeneralJournalAccountEntry, RecId), fieldnum(LedgerTransSettlement, TransRecId));
            qbdsSettlement.fields().dynamic(QueryFieldListDynamic::No);
            qbdsSettlement.addRange(fieldnum(LedgerTransSettlement, SettleDate)).value(queryRange(null, toDate));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructTargetToSourceMap</Name>
				<Source><![CDATA[
    protected Map constructTargetToSourceMap(Query _query)
    {
        _query.clearAllFields();

        Map insertRecordsetMap = new Map(Types::String, Types::Container);

        // General journal entry fields
        QueryBuildDataSource gjeDS = _query.dataSourceTable(tableNum(GeneralJournalEntry));
        int gjeUniqueId = gjeDS.uniqueId();
        QueryBuildFieldList gjeFL = gjeDS.fields();

        gjeFL.addField(fieldNum(GeneralJournalEntry, PostingLayer));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, PostingLayer), [gjeUniqueId, fieldStr(GeneralJournalEntry, PostingLayer)]);

        // General journal account entry fields
        QueryBuildDataSource gjaeDS = _query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        int gjaeUniqueId = gjaeDS.uniqueId();
        QueryBuildFieldList gjaeFL = gjaeDS.fields();

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, LedgerDimension), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, LedgerDimension)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, TransactionCurrencyCode), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, TransactionCurrencyCode)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, AccountingCurrencyAmount), SelectionField::Sum);
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, AccountingCurrencyAmount), [gjaeUniqueId, SysComputedColumn::sum(fieldStr(GeneralJournalAccountEntry, AccountingCurrencyAmount))]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, ReportingCurrencyAmount), SelectionField::Sum);
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, ReportingCurrencyAmount), [gjaeUniqueId, SysComputedColumn::sum(fieldStr(GeneralJournalAccountEntry, ReportingCurrencyAmount))]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyAmount), SelectionField::Sum);
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, TransactionCurrencyAmount), [gjaeUniqueId, SysComputedColumn::sum(fieldStr(GeneralJournalAccountEntry, TransactionCurrencyAmount))]);

        // Main account fields
        QueryBuildDataSource mainAccountDS = _query.dataSourceTable(tableNum(MainAccount));
        int mainAccountUniqueId = mainAccountDS.uniqueId();
        QueryBuildFieldList mainAccountFL = mainAccountDS.fields();

        mainAccountFL.addField(fieldNum(MainAccount, RecId));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, MainAccount), [mainAccountUniqueId, fieldStr(MainAccount, RecId)]);

        mainAccountFL.addField(fieldNum(MainAccount, ExchangeAdjustmentRateType));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, ExchangeRateType), [mainAccountUniqueId, fieldStr(MainAccount, ExchangeAdjustmentRateType)]);

        mainAccountFL.addField(fieldNum(MainAccount, ReportingExchangeAdjustmentRateType));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, ReportingCurrencyExchangeRateType), [mainAccountUniqueId, fieldStr(MainAccount, ReportingExchangeAdjustmentRateType)]);

        // Ledger fields
        QueryBuildDataSource ledgerDS = _query.dataSourceTable(tableNum(Ledger));
        int ledgerUniqueId = ledgerDS.uniqueId();
        QueryBuildFieldList ledgerFL = ledgerDS.fields();

        ledgerFL.addField(fieldNum(Ledger, PrimaryForLegalEntity));
        insertRecordsetMap.insert(fieldStr(LedgerExchangeAdjustmentTmp, LegalEntity), [ledgerUniqueId, fieldStr(Ledger, PrimaryForLegalEntity)]);

        return insertRecordsetMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend this class must override the <c>runsImpersonated</c> method and return
    ///    false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a select button to the dialog.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> object.  If you change the return value to false the button will no
    /// longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);
        container packedQuery;

        #LOCALMACRO.CurrentList_v4
            fromDate,
            toDate,
            currencyOptions,
            mainAccountOptions,
            runMode,
            exchangeAdjustmentTempTable,
            previewBeforePost,
            exchangeRateData,
            legalEntityOptions
        #ENDMACRO

        #LOCALMACRO.CurrentList_v3
            fromAccountRecId,
            toAccountRecId,
            fromCur,
            toCur,
            fromDate,
            toDate,
            profitLossAccounts,
            statusAccounts
        #ENDMACRO

        #LOCALMACRO.CurrentList_v2
            fromAccount,
            toAccount,
            fromCur,
            toCur,
            fromDate,
            toDate,
            postingDate,
            governmentExchRate,
            profitLossAccounts,
            statusAccounts
        #ENDMACRO

        switch (version)
        {
            case CurrentVersion:
                [version, #CurrentList, packedQuery] = packedClass;

                break;

            case 5:
                [version, #CurrentList_v5] = packedClass;

                break;

            case 4:
                [version, #CurrentList_v4] = packedClass;

                break;

            case 3:
                [version, #CurrentList_v3] = packedClass;

                if (fromAccountRecId)
                {
                    fromAccount = MainAccount::find(fromAccountRecId).MainAccountId;
                }
                if (toAccountRecId)
                {
                    toAccount = MainAccount::find(toAccountRecId).MainAccountId;
                }
                break;

            case 2:
                [version, #CurrentList_v2] = packedClass;

                break;

            default :
                return false;
        }

        if (packedQuery)
        {
            queryRun = new QueryRun(packedQuery);
        }

        // Default current company if there were no company specifications provided to the API.
        if (legalEntityOptions == conNull())
        {
            legalEntityOptions = [curExt()];
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        boolean ok = true;

        if (conLen(legalEntityOptions) == 0)
        {
            ok = ok && checkFailed("@GeneralLedger:ForeignCurrencyRevaluationLegalEntityRequired");
        }

        ok = ok && this.validateDates();

        if (conLen(currencyOptions) == 0)
        {
            ok = ok && checkFailed("@GeneralLedger:ForeignCurrencyRevaluationCurrencyRequired");
        }

        for (int counter = 1; counter <= conLen(currencyOptions); counter++)
        {
            str currencyOption = conPeek(currencyOptions, counter);

            if (!Currency::exist(currencyOption))
            {
                ok = ok && checkFailed(strfmt("@SYS16745", currencyOption));
            }
        }

        if (previewBeforePost && this.batchInfo().parmBatchExecute())
        {
            warning("@GeneralLedger:ForeignCurrencyRevalBatchWithPreviewWarning");
            this.batchInfo().parmBatchExecute(NoYes::No);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDates</Name>
				<Source><![CDATA[
    private boolean validateDates()
    {
        boolean ok = true;

        if (this.parmFromDate() > this.parmToDate())
        {
            ok = checkFailed("@SYS16982");
        }

        if (ok)
        {
            List legalEntityList = con2List(legalEntityOptions);
            ListEnumerator legalEntityListEnumerator = legalEntityList.getEnumerator();

            while (legalEntityListEnumerator.moveNext())
            {
                changecompany(legalEntityListEnumerator.current())
                {
                    RecId calendarRecId = Ledger::fiscalCalendar();

                    if (calendarRecId == 0)
                    {
                        ok = checkFailed(strFmt("@Ledger:ErrorMessageFiscalCalendarMissingForLedger", curExt()));
                    }
                    else
                    {
                        // Validate the dates fall in the same fiscal year, they must to evaluate the correct balances
                        if (LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, fromDate) != LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, toDate))
                        {
                            ok = checkFailed(strFmt("@GeneralLedger:ForeignCurrencyRevaluationInvalidFiscalYearDates", curExt()));
                        }
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS10991";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        LedgerExchAdj ledgerExchAdj = new LedgerExchAdj();

        if (ledgerExchAdj.prompt())
        {
            if (ledgerExchAdj.parmPreviewBeforePost())
            {
                if (args.caller() && args.caller() is LedgerIExchAdjHist)
                {
                    ledgerExchAdj.parmHistoryForm(args.caller());
                }

                // wrap self up into an args and call the simulation form
                Args newArgs = new Args();
                newArgs.caller(ledgerExchAdj);
                MenuFunction previewForm = new MenuFunction(menuItemDisplayStr(LedgerExchAdjPreview), MenuItemType::Display);
                previewForm.run(newArgs);
            }
            else
            {
                ledgerExchAdj.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        queryRun = new QueryRun(this.constructMainAccountSelectionQuery());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkingLedgerPostingTypeApplicableEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Event handler for reversal of ledger exchange adjustment transactions.
    /// </summary>
    /// <param name = "_generalJournalAccountEntry">The <c>GeneralJournalAccountEntry</c> table source record checked for reversal.</param>
    /// <param name = "_generalJournalEntry">The <c>GeneralJournalEntry</c> table source record checked for reversal.</param>
    /// <param name = "_originatingRecord">The table record from which the process was invoked from.</param>
    /// <param name = "_eventHandlerResult">The <c>EventHandlerResult</c> class instance.</param>
    [SubscribesTo(classStr(TransactionReversal), delegateStr(TransactionReversal, checkingLedgerPostingTypeApplicable))]
    public static void checkingLedgerPostingTypeApplicableEventHandler(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalEntry _generalJournalEntry,
        Common _originatingRecord,
        EventHandlerResult _eventHandlerResult)
    {
        if (_eventHandlerResult.result())
        {
            if (LedgerExchAdjTransactionReversal::validateEligibleForReverse(
                _generalJournalEntry,
                _originatingRecord))
            {
                // Instruct the validation not to provide any prompts during execution
                boolean suppressPrompts = true;
                if (!LedgerExchAdjTransactionReversal::validateFutureForeignCurrencyRevaluationTransactionsExist(_generalJournalEntry, suppressPrompts))
                {
                    _eventHandlerResult.result(false);

                    // The event handler will treat the result as "cancelled" by passing hasResult(false), rather than throwing a validation error
                    _eventHandlerResult.hasResult(false);
                }
                else
                {
                    _eventHandlerResult.result(true);
                }
            }
            else
            {
                _eventHandlerResult.result(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>futureForeignCurrencyRevaluationTransactionsExist</Name>
				<Source><![CDATA[
    internal static boolean futureForeignCurrencyRevaluationTransactionsExist(TransDate _transDate, LedgerRecId _ledgerRecId)
    {
        GeneralJournalEntry generalJournalEntry;

        select firstonly RecId from generalJournalEntry
            where generalJournalEntry.JournalCategory == LedgerTransType::ExchAdjustment &&
                generalJournalEntry.AccountingDate > _transDate &&
                generalJournalEntry.Ledger == _ledgerRecId;

        return (generalJournalEntry.RecId > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>