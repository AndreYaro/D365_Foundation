<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMov_Prod</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventMov_Prod</c> class is used when it works with production orders in the
///    <c>ProdTable</c> production module.
/// </summary>
class InventMov_Prod extends InventMovement
{
    ProdTable prodTable;
    Set       inventDimensionsToIgnore;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountBalanceSheet()
    {
        if (! cacheAccountBalanceSheet)
        {
            if (prodTable.ProdPostingType   == ProdPostingType::ProdGroup)
            {
                cacheAccountBalanceSheet = ProdGroup::find(prodTable.ProdGroupId).ReceiptLedgerDimension;
            }
            else
            {
                if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                {
                    cacheAccountBalanceSheet = InventPosting::itemExtendParm_CN(
                        InventAccountType::ProdReceipt,
                        InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                        prodTable.ItemId,
                        this.inventTable().itemGroupId());
                }
                else
                {
                    cacheAccountBalanceSheet = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdReceipt));
                }
            }
        }

        return cacheAccountBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventPostingItemLedgerDimensionParameters</Name>
				<Source><![CDATA[
    public InventPostingItemLedgerDimensionParameters createInventPostingItemLedgerDimensionParameters(
        InventAccountType   _inventAccountType,
        ItemGroupId         _itemGroupId = this.inventTable().itemGroupId())
    {
        InventPostingItemLedgerDimensionParameters searchParameters = super(_inventAccountType, _itemGroupId);

        searchParameters.ItemId = prodTable.ItemId;

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperations()
    {
        if (! cacheAccountOperations)
        {
            if (prodTable.isProjMethodConsumed())
            {
                if (prodTable.ProjLinkedToOrder
                    || (this.isProjConsumedPostingTypeInventReferenceTypeNone()
                        && ProjPostVarianceToProjCostForEndingProdOrderFlight::instance().isEnabled()))
                {
                    cacheAccountOperations = ProjPosting::getInventLedgerDimension(ProjAccountType::CostAccount,
                                                                     this.projId(),
                                                                     this.projCategoryId());
                }
                else
                {
                    cacheAccountOperations = this.accountBalanceSheet();
                }
            }
            else
            {
                if (prodTable.ProdPostingType   == ProdPostingType::ProdGroup)
                {
                    cacheAccountOperations = ProdGroup::find(prodTable.ProdGroupId).ReceiptOffsetLedgerDimension;
                }
                else
                {
                    cacheAccountOperations = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdReceiptOffsetAccount));
                }
            }
        }

        return cacheAccountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperationsAutoLossProfit</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperationsAutoLossProfit(InventQty _qty)
    {
        return (prodTable.isProjMethodFinished() ?
            ProjPosting::getInventLedgerDimension(
                ProjAccountType::CostAccount,
                this.projId(),
                this.projCategoryId()) :
            super(_qty));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysical()
    {
        if (! cacheAccountPhysical)
        {
            if (prodTable.ProdPostingType   == ProdPostingType::ProdGroup)
            {
                cacheAccountPhysical = ProdGroup::find(prodTable.ProdGroupId).ReportLedgerDimension;
            }
            else
            {
                if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                {
                    cacheAccountPhysical = InventPosting::itemExtendParm_CN(
                        InventAccountType::ProdReportFinished,
                        InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                        prodTable.ItemId,
                        this.inventTable().itemGroupId());
                }
                else
                {
                    cacheAccountPhysical = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdReportFinished));
                }
            }
        }

        return cacheAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return ((prodTable.isProjMethodFinished() || prodTable.isProjMethodConsumed()) ? prodTable.ActivityNumber : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    public void addRemainPhysical(InventQty  _inventQty)
    {
        prodTable.RemainInventPhysical += _inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoLossProfitInventMovVirtuel</Name>
				<Source><![CDATA[
    protected InventMov_Virtuel autoLossProfitInventMovVirtuel(
        InventUpd_Financial     _financial,
        InventTrans             _inventTrans,
        InventTransId           _inventTransId)
    {
        InventMov_Virtuel ret = super(_financial, _inventTrans, _inventTransId);

        if (ProdTable::find(_financial.movement().transRefId()).isProjMethodConsumed())
        {
            ret.parmPostingOperations(ret.postingBalanceSheet());
            ret.parmAccountOperations(ret.accountBalanceSheet());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchProdDate</Name>
				<Source><![CDATA[
    public InventBatchProdDate batchProdDate(InventTrans _inventTrans = null)
    {
        InventTransOriginProdTable  inventTransOriginProdTable;

        if (!_inventTrans)
        {
            select firstonly TableId from inventTransOriginProdTable
                where inventTransOriginProdTable.ProdOrderDataAreaId    == prodTable.DataAreaId
                   && inventTransOriginProdTable.ProdOrderId            == prodTable.ProdId
                join DatePhysical, DateInvent from _inventTrans
                    where _inventTrans.InventTransOrigin                == inventTransOriginProdTable.InventTransOrigin
                       && _inventTrans.InventDimId                      == prodTable.InventDimId
                       && (_inventTrans.DatePhysical || _inventTrans.DateInvent);
        }

        if (_inventTrans.DatePhysical)
        {
            return _inventTrans.DatePhysical;
        }

        if (_inventTrans.DateInvent)
        {
            return _inventTrans.DateInvent;
        }

        return prodTable.DlvDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeReserved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the movement can be reserved.
    /// </summary>
    /// <returns>
    /// true if the movement can be reserved; otherwise, false .
    /// </returns>
    public boolean canBeReserved()
    {
        boolean ret = super();

        if (ret && #PmfReworkBatchEnabled)
        {
            ret = !prodTable.PmfReworkBatch;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowManualMarking</Name>
				<Source><![CDATA[
    public boolean checkAllowManualMarking()
    {
        boolean canUpdate = super();

        if (canUpdate)
        {
            if (prodTable.isProjMethodConsumed() && prodTable.ProjLinkedToOrder)
            {
                return checkFailed("@SYS116368");
            }
        }

        return canUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotSubDelivery</Name>
				<Source><![CDATA[
    protected boolean checkNotSubDelivery(
        InventQty       _physicalNow,
        InventQty       _remainPhysicalNow,
        boolean         _isPhysicalUpdate
        , PdsCWInventQty  _pdsCWPhysicalNow
        , PdsCWInventQty  _pdsCWRemainPhysicalNow
        )
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimated</Name>
				<Source><![CDATA[
    public boolean checkUpdateEstimated(
        InventUpd_Estimated     _updateNow,
        InventMovement          _this_orig)
    {
        if (this.transQty() <= 0)
        {
            return checkFailed("@SYS18731");
        }

        if  (! prodTable.status().inventCheckUpdEst())
        {
            return false;
        }

        return super(_updateNow, _this_orig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    public void createOriginOwnerRelationship()
    {
        InventTransOriginId originId = this.inventTransOriginId();

        if (originId && prodTable.RecId)
        {
            InventTransOriginProdTable::writeOriginOwnerRelationship(prodTable.DataAreaId, prodTable.ProdId, originId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault defaultDimension()
    {
        return prodTable.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the relationship between the inventory transactions originator and the owner that
    ///    corresponds.
    /// </summary>
    public void deleteOriginOwnerRelationship()
    {
        if (prodTable.RecId)
        {
            InventTransOriginProdTable::deleteOwnerRelationship(prodTable.DataAreaId, prodTable.ProdId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    /// An <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// An <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    /// The estimated physical value for the inventory transaction.
    /// </returns>
    protected CostAmount estimatedPhysicalValue(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        ProdParametersDim prodParametersDim = prodTable.prodParametersDim();

        if (_inventTrans.Qty > 0 && !this.inventModelGroup().inventModelType().stdCostBased() && !this.inventModelGroup().StandardCost && prodParametersDim.SpecifyCalc && prodParametersDim.PhyValueUseCalcPrice )
        {
            CostAmount estimatedValue = CurrencyExchangeHelper::amount(prodTable.prodCalcTrans().costPricePcs() * _inventTrans.Qty);
            if (estimatedValue)
            {
                return estimatedValue;
            }
        }

        return super(_inventTrans, _inventOnhand, _updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        return prodTable.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The new value of the ID of the inventory transaction originator.
    /// </param>
    /// <returns>
    ///    The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginId(InventTransOriginId _inventTransOriginId = inventTransOriginId)
    {
        if (_inventTransOriginId != inventTransOriginId)
        {
            inventTransOriginId = _inventTransOriginId;
        }
        else
        {
            if (!inventTransOriginId)
            {
                inventTransOriginId = InventTransOriginProdTable::findInventTransOriginId(prodTable.DataAreaId, prodTable.ProdId);
            }
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId  itemId()
    {
        return prodTable.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    ///    zero if the whole movement is not marked; otherwise, the ID of the transaction origin.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        return InventTransOrigin::findByInventTransId(prodTable.InventRefTransId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean  mustBeBookedPhysically()
    {
        if (prodTable.isProjMethodConsumed())
        {
            return false;
        }

        if (this.inventModelType().mustAlwaysBeBookedPhysically() || prodTable.prodParametersDim().PostReportedFinished)
        {
            return super();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCostControlled</Name>
				<Source><![CDATA[
    public boolean mustBeCostControlled()
    {
        if (this.projId()!='' && prodTable.isProjMethodFinished() && ProjParameters::find().TrackCommittedCostProduction)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the model group that is associated with the current <c>InventMovement</c> object
    ///    requires a mandatory deduct.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the model group that is associated with the current
    ///    <c>InventMovement</c> object requires a mandatory deduct.
    /// </returns>
    public boolean mustBeDeducted()
    {
        return this.inventModelGroup().MandatoryDeduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeReceived</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the model group that is associated with the current <c>InventMovement</c> object
    ///    requires a mandatory receive.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the model group that is associated with the current
    ///    <c>InventMovement</c> object requires a mandatory receive.
    /// </returns>
    public boolean mustBeReceived()
    {
        return this.inventModelGroup().MandatoryReceive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRemainControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeRemainControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitEstimate</Name>
				<Source><![CDATA[
    public boolean mustDoAutoLossProfitEstimate()
    {
        //Production order from master planning would be linked with a solid movement
        if (prodTable.isProjMethodConsumed() &&
            prodTable.ReqPOId)
        {
            return super();
        }

        // If it is a project production order and not linked with solid movement yet
        if ((prodTable.isProjMethodFinished()   ||
             (prodTable.isProjMethodConsumed()   &&
             !prodTable.ProjLinkedToOrder))      &&
             !(select firstonly inventTransOrigin
             where inventTransOrigin.RecId == this.markingRefInventTransOrigin()
                && inventTransOrigin.ReferenceId !='').RecId)
        {
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPosting</Name>
				<Source><![CDATA[
    protected boolean mustDoProjPosting()
    {
        return (prodTable.isProjMethodFinished() ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjRefInventTrans()
    {
        return ((prodTable.isProjMethodFinished() || prodTable.isProjMethodConsumed()) ? true : super());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateBatchAttribValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the movement should update the batch attributes on the related quality orders.
    /// </summary>
    /// <returns>
    /// true if attributes should be updated; otherwise, false.
    /// </returns>
    public boolean mustUpdateBatchAttribValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(
        ProdTable       _prodTable,
        InventType      _inventType = ProdTableType::construct(_prodTable))
    {
        prodTable       = _prodTable;

        super(prodTable,_inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    public InventMovement newMovement_Orig()
    {
        if (!prodTable.RecId)
        {
            return null;
        }

        return new InventMov_Prod(prodTable.orig(),inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount offsetAccountPhysical()
    {
        if (! cacheOffsetAccountPhysical)
        {
            if (prodTable.ProdPostingType == ProdPostingType::ProdGroup)
            {
                cacheOffsetAccountPhysical = ProdGroup::find(prodTable.ProdGroupId).ReportOffsetLedgerDimension;
            }
            else
            {
                cacheOffsetAccountPhysical = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdReportFinishedOffsetAccount));
            }
        }

        return cacheOffsetAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the transaction quantity value.
    /// </summary>
    /// <param name="_qty">
    /// The value to set.
    /// </param>
    public void pdsCWSetTransQty(PdsCWInventQty _qty)
    {
        prodTable.PdsCWBatchSched = _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTransQty</Name>
				<Source><![CDATA[
    public PdsCWInventQty pdsCWTransQty()
    {
        return prodTable.PdsCWBatchSched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuantityValidator</Name>
				<Source><![CDATA[
    protected InventMovementQuantityValidator createQuantityValidator(
        InventItemOrderSetupMap                       _orderSetup,
        InventMovementQuantityErrorCorrectionMethods  _errorCorrectionMethods)
    {
        if (prodTable.ProdType == ProdType::Process)
        {
            BOMVersion bomVersion;
            if (!prodTable.RecId && prodTable.BOMId && prodTable.ReqPlanIdSched)
            {
                bomVersion = prodTable.bomVersion();
            }

            if (!bomVersion)
            {
                bomVersion = BOMVersion::findActive( prodTable.ItemId, prodTable.bomDate, prodTable.QtySched, this.inventdim());
            }

            return PmfBatchOrderQuantityValidator::newFromErrorCorrectionMethods(_orderSetup, bomVersion, _errorCorrectionMethods);
        }

        return super(_orderSetup, _errorCorrectionMethods);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerPostingType postingBalanceSheet()
    {
        return LedgerPostingType::ProdReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOffsetPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOffsetPhysical()
    {
        return LedgerPostingType::ProdReportFinishedOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOperations()
    {
        if (prodTable.isProjMethodConsumed())
        {
            if (prodTable.ProjLinkedToOrder
                || (this.isProjConsumedPostingTypeInventReferenceTypeNone()
                    && ProjPostVarianceToProjCostForEndingProdOrderFlight::instance().isEnabled()))
            {
                return LedgerPostingType::ProjCost;
            }
            else
            {
                return this.postingBalanceSheet();
            }
        }

        return LedgerPostingType::ProdReceiptOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysical()
    {
        return LedgerPostingType::ProdReportFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId projCategoryId()
    {
        return ((prodTable.isProjMethodFinished() || prodTable.isProjMethodConsumed()) ? prodTable.ProjCategoryId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    public ProjId projId()
    {
        return ((prodTable.isProjMethodFinished() || prodTable.isProjMethodConsumed()) ? prodTable.ProjId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedgerOrigin</Name>
				<Source><![CDATA[
    public ProjLedgerOrigin projLedgerOrigin()
    {
        if (prodTable.isProjMethodFinished())
        {
            return ProjOrigin::ProductionFinished;
        }

        if (prodTable.isProjMethodConsumed())
        {
            return ProjOrigin::ProductionConsumed;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    public ProjLinePropertyId projLinePropertyId()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjLinePropertyId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesCurrencyId</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode projSalesCurrencyId()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjSalesCurrencyId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesPrice</Name>
				<Source><![CDATA[
    public ProjSalesPriceCost projSalesPrice()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjSalesPrice : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxGroupId</Name>
				<Source><![CDATA[
    public ProjTaxGroup projTaxGroupId()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjTaxGroupId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxItemGroupId</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup projTaxItemGroupId()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjTaxItemGroupId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin projTransactionOrigin()
    {
        if (prodTable.isProjMethodFinished())
        {
            return ProjOrigin::ProductionFinished;
        }

        if (prodTable.isProjMethodConsumed())
        {
            return ProjOrigin::ProductionConsumed;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransId</Name>
				<Source><![CDATA[
    public ProjTransIdBase projTransId()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjTransId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    public InventQty   remainPhysical()
    {
        return prodTable.RemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serialProdDate</Name>
				<Source><![CDATA[
    public InventSerialProdDate serialProdDate(InventTrans _inventTrans = null)
    {
        InventTransOriginProdTable  inventTransOriginProdTable;

        if (!_inventTrans)
        {
            select firstonly TableId from inventTransOriginProdTable
                where inventTransOriginProdTable.ProdOrderDataAreaId    == prodTable.DataAreaId
                   && inventTransOriginProdTable.ProdOrderId            == prodTable.ProdId
                join DatePhysical, DateInvent from _inventTrans
                    where _inventTrans.InventTransOrigin                == inventTransOriginProdTable.InventTransOrigin
                       && _inventTrans.InventDimId                      == prodTable.InventDimId
                       && (_inventTrans.DatePhysical || _inventTrans.DateInvent);
        }

        if (_inventTrans.DatePhysical)
        {
            return _inventTrans.DatePhysical;
        }

        if (_inventTrans.DateInvent)
        {
            return _inventTrans.DateInvent;
        }

        return prodTable.DlvDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    public void setInventDimId(InventDimId _dimId)
    {
        prodTable.setInventDimId(_dimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventRefFields</Name>
				<Source><![CDATA[
    public boolean setInventRefFields(
        InventRefType           _inventRefType,
        InventRefId             _inventRefId,
        InventTransOriginId     _markingRefInventTransOrigin
        )
    {
        InventTransId   markingRefInventTransId = InventTransOrigin::find(_markingRefInventTransOrigin).InventTransId;

        if (prodTable.status().isBefore(ProdStatus::Completed))
        {
            if (_inventRefType          != prodTable.InventRefType  ||
                _inventRefId            != prodTable.InventRefId    ||
                markingRefInventTransId != prodTable.InventRefTransId)
            {
                if (prodTable.isProjMethodConsumed() &&
                    prodTable.InventRefType == InventRefType::ProdLine &&
                    prodTable.InventRefTransId &&
                    markingRefInventTransId == '')
                {
                    ProdJournalProd prodJournalProd;
                    select firstOnly QtyGood, ProdFinished from prodJournalProd
                        where prodJournalProd.ProdId == prodTable.ProdId;
                    if (!prodJournalProd.QtyGood && prodJournalProd.ProdFinished)
                    {
                        this.parmMustDoAutoLossProfitForbid(NoYes::Yes);
                    }
                }
                prodTable.InventRefType       = _inventRefType;
                prodTable.InventRefId         = _inventRefId;
                prodTable.InventRefTransId    = markingRefInventTransId;

                prodTable.CollectRefProdId    = prodTable.ProdId;
                prodTable.CollectRefLevel     = 0;

                if (prodTable.InventRefType == InventRefType::ProdLine)
                {
                    ProdBOM prodBOM = ProdBOM::findTransId(prodTable.InventRefTransId);

                    if (prodBOM.InventRefTransId == prodTable.InventTransId   &&
                        prodBOM.InventRefType    == InventRefType::Production &&
                        (prodBOM.ProdLineType    == BOMType::PeggedSupply || (prodBOM.ProdLineType == BOMType::Item && CostTakeMarkedItemAsPeggedSupplyFlight::instance().isEnabled())))
                    {
                        ProdTable prodTableParent = ProdTable::find(prodTable.InventRefId,true);
                        if (prodTableParent.RecId)
                        {
                            prodTable.CollectRefLevel     = prodTableParent.CollectRefLevel  + 1;
                            prodTable.CollectRefProdId    = prodTableParent.CollectRefProdId;
                        }
                    }
                }

                if (! prodTable.RecId                                                     ||
                      prodTable.CollectRefLevel   != prodTable.orig().CollectRefLevel     ||
                      prodTable.CollectRefProdId  != prodTable.orig().CollectRefProdId)
                {
                    prodTable.updateCollectRefProdId();
                }

                if (prodTable.InventRefId && prodTable.InventRefType == InventRefType::Sales && !prodTable.ProjId)
                {
                    SalesTable salesTable = SalesTable::find(prodTable.InventRefId);
                    
                    if (salesTable.ProjId)
                    {
                        prodTable.ProjId = salesTable.ProjId;

                        if (salesTable.SalesType == SalesType::ItemReq)
                        {
                            prodTable.ProjPostingType = ProjParameters::prodPostingType();
                        }
                        else
                        {
                            prodTable.ProjPostingType = ProjProdPostingType::FinishedItemMethod;
                        }

                        prodTable.ProjLinkedToOrder = NoYes::Yes;
                    }
                }
            }

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjAdjustRefId</Name>
				<Source><![CDATA[
    public void setProjAdjustRefId(InventTrans _inventTrans)
    {
        if (_inventTrans.ProjAdjustRefId)
        {
            projAdjustRefId = _inventTrans.ProjAdjustRefId;
            return;
        }

        if (!_inventTrans.ProjId)
        {
            return;
        }

        if (!projAdjustRefId)
        {
            projAdjustRefId = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        }

        _inventTrans.ProjAdjustRefId = projAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the remaining physical CW quantity.
    /// </summary>
    /// <param name="_qty">
    /// CW quantity.
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _qty)
    {
        prodTable.PdsCWRemainInventPhysical = _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds quantity to the remaining physical CW quantity.
    /// </summary>
    /// <param name="_qty">
    /// CW quantity.
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty _qty)
    {
        prodTable.PdsCWRemainInventPhysical += _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves remaining  physical CW quantity.
    /// </summary>
    /// <returns>
    /// Remaining  physical CW quantity.
    /// </returns>
    public PdsCWInventQty pdsCWRemainPhysical()
    {
        return prodTable.PdsCWRemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    public void setRemainPhysical(InventQty _inventQty)
    {
        prodTable.RemainInventPhysical = _inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQty</Name>
				<Source><![CDATA[
    public void setTransQty(InventQty _qtyInvent)
    {
        prodTable.QtySched = _qtyInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate()
    {
        return prodTable.transDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    public InventTransId transId()
    {
        return prodTable.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transInventRefType</Name>
				<Source><![CDATA[
    public InventRefType transInventRefType()
    {
        return InventRefType::Production;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    public InventQty   transQty()
    {
        return prodTable.QtySched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRefId</Name>
				<Source><![CDATA[
    public InventTransRefId transRefId()
    {
        return prodTable.ProdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSchedTime</Name>
				<Source><![CDATA[
    public SchedTime transSchedTime()
    {
        return prodTable.transSchedTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSign</Name>
				<Source><![CDATA[
    public Integer transSign()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    public InventTransType transType()
    {
        return InventTransType::Production;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transUnitId</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol transUnitId()
    {
        return (prodTable.isProjMethodFinished() ? prodTable.ProjSalesUnitId : super());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInheritedBatchesPostRegistration</Name>
				<Source><![CDATA[
    public void updateInheritedBatchesPostRegistration(InventTrans _inventTrans)
    {
        if (this.pdsCanHaveBatchInheritance() && (_inventTrans.orig().StatusReceipt == StatusReceipt::Registered))
        {
            InventBatchId inventBatchId = _inventTrans.inventBatchId();
            if (inventBatchId)
            {
                InventBatch inventbatch = InventBatch::find(inventBatchId, _inventTrans.ItemId, true);
                this.pdsInheritBatchData(inventBatch, _inventTrans);
                inventbatch.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventMov_Prod</c> class by using the specified record.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> record for which the class is created and initialized.
    /// </param>
    /// <param name="_inventType">
    /// The <c>InventType</c> class that is associated.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventMov_Prod</c> class.
    /// </returns>
    public static InventMov_Prod newFromProdTable(
        ProdTable       _prodTable,
        InventType      _inventType = ProdTableType::construct(_prodTable))
    {
        if (_prodTable.ProdType == ProdType::Process)
        {
            return InventMov_Process::construct(_prodTable, _inventType);
        }

        return new InventMov_Prod(_prodTable, _inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimForInventDimField</Name>
				<Source><![CDATA[
    protected boolean checkInventDimForInventDimField(
        InventQty                   _qty,
        InventDim                   _inventDim,
        InventDimGroupFieldSetup    _inventDimGroupFieldSetup,
        boolean                     _finalCheck,
        boolean                     _showError)
    {
        boolean ret;

        if (inventDimensionsToIgnore == null || !inventDimensionsToIgnore.in(_inventDimGroupFieldSetup.dimFieldId()))
        {
            ret = super(_qty, _inventDim, _inventDimGroupFieldSetup, _finalCheck, _showError);
        }
        else
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimToIgnore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Receives a set of <c>InventDim</c> table fields to ignore.
    /// </summary>
    /// <param name="_inventDimensionsToIgnore">
    /// A set of <c>InventDim</c> table fields that will be ignored.
    /// </param>
    public void setInventDimToIgnore(Set _inventDimensionsToIgnore)
    {
        inventDimensionsToIgnore = _inventDimensionsToIgnore;
    }

]]></Source>
			</Method>
			<Method>
				<Name>componentInventTransOriginIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the IDs of the component inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <returns>
    ///    The IDs of the component inventory transaction originator that corresponds to the movement.
    /// </returns>
    public Set componentInventTransOriginIds()
    {
        Set                    componentInventTransOriginIds = new Set(Types::Int64);
        InventTransOrigin      inventTransOriginProdBOM;

        while select RecId from inventTransOriginProdBOM
            where inventTransOriginProdBOM.ReferenceCategory == InventTransType::ProdLine
               && inventTransOriginProdBOM.ReferenceId       == prodTable.ProdId
        {
            componentInventTransOriginIds.add(inventTransOriginProdBOM.RecId);
        }

        return componentInventTransOriginIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanDepreciateMarkedTransactionUpdate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void validateCanDepreciateMarkedTransactionUpdate(InventTrans _inventTrans)
    {
        this.whsCheckCrossDockLoadInventTransUpdated(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanDeleteMarkedTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void validateCanDeleteMarkedTransaction()
    {
        this.whsCheckCrossDockLoadInventTransDeleted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransOriginBeDeleted</Name>
				<Source><![CDATA[
    private boolean canInventTransOriginBeDeleted()
    {
        return prodTable.validateDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventTransOriginAndReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the inventory transaction originator and related relationship references.
    /// </summary>
    /// <remarks>
    ///    If this method is invoked it means the production origin has no transactions and can be deleted
    ///    The only exception when an origin has to be retained is a scenario when a production order's LOT quantity is scrapped 100% with Scrap account method => will reuse the origin for scrap transactions when ending production order
    ///    Therefore add a constraint to validate the status of the production order and delete the origin only if the production order has status Created.
    /// </remarks>
    [Hookable(false)]
    internal void deleteInventTransOriginAndReferences()
    {
        if (this.canInventTransOriginBeDeleted())
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjConsumedPostingTypeInventReferenceTypeNone</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the project is referenced directly as a consumed posting type to a production order without creating item requirement or sales order.
    /// </summary>
    /// <returns>
    ///     true if there is no order linked to the production order; otherwise, false.
    /// </returns>
    private boolean isProjConsumedPostingTypeInventReferenceTypeNone()
    {
        return prodTable.ProjId
            && prodTable.ProjPostingType == ProjProdPostingType::ConsumedMethod
            && !prodTable.InventRefId
            && prodTable.InventRefType == InventRefType::None;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>