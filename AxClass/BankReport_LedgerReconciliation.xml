<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankReport_LedgerReconciliation</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class BankReport_LedgerReconciliation extends LedgerReconciliation
{
    BankLedgerReconciliationTmp bankLedgerReconciliationTmp;
    private BankLedgerReconciliationCurrencyTmp bankTransCurrencyTmp;
    private BankLedgerReconciliationCurrencyTmp bankLedgerReconciliationCurrencyTmp;
    private LedgerReconciliationLedgerCurrencyTmp ledgerReconciliationLedgerCurrencyTmp;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcCurrencyBalanceDifference</Name>
				<Source><![CDATA[
    private void calcCurrencyBalanceDifference()
    {
        update_recordset bankLedgerReconciliationCurrencyTmp setting
            CurrencyBalanceDifference =
                bankLedgerReconciliationCurrencyTmp.BankAmountCurrency -
                bankLedgerReconciliationCurrencyTmp.LedgerAmountCurrency
            where bankLedgerReconciliationCurrencyTmp.LedgerAmountCurrency != bankLedgerReconciliationCurrencyTmp.BankAmountCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerReconcileAccountsTmp</Name>
				<Source><![CDATA[
    protected void createLedgerReconcileAccountsTmp()
    {
        MainAccount defaultToMainAccount;
        if (fromMainAccount || toMainAccount)
        {
            if (!toMainAccount)
            {
                select firstonly MainAccountId from defaultToMainAccount
                    order by MainAccountId desc
                    where defaultToMainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current();

                toMainAccount = defaultToMainAccount.MainAccountId;
            }

            insert_recordset ledgerReconcileAccountsTmp
            (
                MainAccount
            )
            select RecId from defaultToMainAccount
                where defaultToMainAccount.MainAccountId >= fromMainAccount
                    && defaultToMainAccount.MainAccountId <= toMainAccount
                    && defaultToMainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current();
        }
        else
        {
            BankAccountTable bankAccountTable;
            DimensionAttributeValueCombination davc;

            // Insert MainAccounts for Bank Accounts.
            insert_recordset ledgerReconcileAccountsTmp
            (
                MainAccount
            )
            select bankAccountTable
            join MainAccount from davc
                group by MainAccount
                    where davc.RecId == bankAccountTable.LedgerDimension
            join defaultToMainAccount
                where defaultToMainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
                    && davc.MainAccount == defaultToMainAccount.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankTransForAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the bank transaction records and insert them into the <c>BankLedgerReconciliationCurrencyTmp</c> table for accounting currency.
    /// </summary>
    private final void getBankTransForAccountingCurrency()
    {
        // Get all the transaction from BankAccountTrans and BankDepositDetails for accounting currency
        this.getNotExchAdjBankTransactionsForAccountingCurrency();
        this.getExchAdjBankTransactionsForAccountingCurrency();

        this.getBankDepositDetailsForAccountingCurrency();
        this.getBankTransSummarizationDetailsForAccountingCurrency();

        if (BankLedgerReconReportConsiderStatementsDistributedOnSameDimensionFlight::instance().isEnabled())
        {
            this.getNewBankTransHavingDistributionForAccountingCurrency();
        }

        // Process summarized vouchers and other vouchers for reconciliation process for accounting currency
        this.processBankTransToGroupSummarizedVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankTransForReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the bank transaction records and insert them into the <c>BankLedgerReconciliationCurrencyTmp</c> table for reporting currency.
    /// </summary>
    private final void getBankTransForReportingCurrency()
    {
        // Get all the transaction from BankAccountTrans and BankDepositDetails for reporting currency
        this.getNotExchAdjBankTransactionsForReportingCurrency();
        this.getExchAdjBankTransactionsForReportingCurrency();

        this.getBankDepositDetailsForReportingCurrency();
        this.getBankTransSummarizationDetailsForReportingCurrency();

        if (BankLedgerReconReportConsiderStatementsDistributedOnSameDimensionFlight::instance().isEnabled())
        {
            this.getNewBankTransHavingDistributionForReportingCurrency();
        }

        // Process summarized vouchers and other vouchers for reconciliation process for reporting currency
        this.processBankTransToGroupSummarizedVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBankTransThatCannotBeReconciled</Name>
				<Source><![CDATA[
    private void insertBankTransThatCannotBeReconciled()
    {
        insert_recordset bankLedgerReconciliationCurrencyTmp
        (
            BankAmountCurrency,
            CustVendAC,
            BankAccountName,
            LedgerJournalId,
            AccountingDate,
            Voucher,
            MainAccount,
            MainAccountId,
            MainAccountName
         )
         select
             BankAmountCurrency,
             CustVendAC,
             BankAccountName,
             LedgerJournalId,
             AccountingDate,
             Voucher,
             MainAccount,
             MainAccountId,
             MainAccountName
         from bankTransCurrencyTmp
         notexists join ledgerReconciliationLedgerCurrencyTmp
            where ledgerReconciliationLedgerCurrencyTmp.MainAccountId == bankTransCurrencyTmp.MainAccountId
                && ledgerReconciliationLedgerCurrencyTmp.AccountingDate == bankTransCurrencyTmp.AccountingDate
                && ledgerReconciliationLedgerCurrencyTmp.Voucher == bankTransCurrencyTmp.Voucher
                && ledgerReconciliationLedgerCurrencyTmp.JournalNumber == bankTransCurrencyTmp.LedgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerTransThatCannotBeReconciled</Name>
				<Source><![CDATA[
    private void insertLedgerTransThatCannotBeReconciled()
    {
        bankLedgerReconciliationCurrencyTmp.clear();

        insert_recordset bankLedgerReconciliationCurrencyTmp
        (
            LedgerAmountCurrency,
            AccountingDate,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            Voucher
        )
        select CurrencyAmount,
            AccountingDate,
            JournalNumber,
            MainAccount,
            MainAccountId,
            MainAccountName,
            Voucher
        from ledgerReconciliationLedgerCurrencyTmp
        notexists join bankTransCurrencyTmp
            where bankTransCurrencyTmp.AccountingDate == ledgerReconciliationLedgerCurrencyTmp.AccountingDate
                && bankTransCurrencyTmp.Voucher == ledgerReconciliationLedgerCurrencyTmp.Voucher
                && bankTransCurrencyTmp.MainAccount == ledgerReconciliationLedgerCurrencyTmp.MainAccount
                && bankTransCurrencyTmp.LedgerJournalId == ledgerReconciliationLedgerCurrencyTmp.JournalNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReconciledBankLedgerTransactions</Name>
				<Source><![CDATA[
    private void insertReconciledBankLedgerTransactions()
    {
        insert_recordset bankLedgerReconciliationCurrencyTmp
        (
            BankAmountCurrency,
            CustVendAC,
            BankAccountName,
            LedgerAmountCurrency,
            LedgerJournalId,
            AccountingDate,
            Voucher,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select
            BankAmountCurrency,
            CustVendAC,
            BankAccountName
        from bankTransCurrencyTmp
        join
            CurrencyAmount,
            JournalNumber,
            AccountingDate,
            Voucher,
            MainAccount,
            MainAccountId,
            MainAccountName
        from ledgerReconciliationLedgerCurrencyTmp
            where ledgerReconciliationLedgerCurrencyTmp.MainAccountId == bankTransCurrencyTmp.MainAccountId
                && ledgerReconciliationLedgerCurrencyTmp.AccountingDate == bankTransCurrencyTmp.AccountingDate
                && ledgerReconciliationLedgerCurrencyTmp.Voucher == bankTransCurrencyTmp.Voucher
                && ledgerReconciliationLedgerCurrencyTmp.JournalNumber == bankTransCurrencyTmp.LedgerJournalId;
        
        if (showDifferencesOnly)
        {
            delete_from bankLedgerReconciliationCurrencyTmp where
            bankLedgerReconciliationCurrencyTmp.BankAmountCurrency == bankLedgerReconciliationCurrencyTmp.LedgerAmountCurrency;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>BankReport_LedgerReconciliation</c> class.
    /// </summary>
    /// <param name="_bankLedgerReconciliationTmp">
    /// <c>BankLedgerReconciliationTmp</c> table record which represents report data; optional.
    /// </param>
    public void new(BankLedgerReconciliationTmp _bankLedgerReconciliationTmp = null)
    {
        bankLedgerReconciliationTmp = _bankLedgerReconciliationTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBankLedgerReconciliationAccountingCurrencyResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the result <c>BankLedgerReconciliationTmp</c> record with <c>BankLedgerReconciliationCurrencyTmp</c> for accounting currency.
    /// </summary>
    private void populateBankLedgerReconciliationAccountingCurrencyResult()
    {
        insert_recordset bankLedgerReconciliationTmp
        (
            AccountingCurrencyBalanceDifference,
            AccountingDate,
            BankAccountingCurrencyBalance,
            BankAccountName,
            BankAccountTransRecId,
            BankAmountMST,
            BankdepositRecId,
            BankLedgerAccount,
            CancelTransaction,
            CustVendAC,
            DepositNum,
            LedgerAccount,
            LedgerAccountingCurrencyBalance,
            LedgerAccountName,
            LedgerAmountMST,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            SumAggregate,
            Voucher
        )
        select CurrencyBalanceDifference,
            AccountingDate,
            BankCurrencyBalance,
            BankAccountName,
            BankAccountTransRecId,
            BankAmountCurrency,
            BankdepositRecId,
            BankLedgerAccount,
            CancelTransaction,
            CustVendAC,
            DepositNum,
            LedgerAccount,
            LedgerCurrencyBalance,
            LedgerAccountName,
            LedgerAmountCurrency,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            SumAggregate,
            Voucher
        from bankLedgerReconciliationCurrencyTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBankLedgerReconciliationReportingCurrencyResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the result <c>BankLedgerReconciliationTmp</c> record with <c>BankLedgerReconciliationCurrencyTmp</c> for reporting currency.
    /// </summary>
    private void populateBankLedgerReconciliationReportingCurrencyResult()
    {
        insert_recordset bankLedgerReconciliationTmp
        (
            ReportingCurrencyBalanceDifference,
            AccountingDate,
            BankAccountName,
            BankAccountTransRecId,
            BankAmountMSTSecond,
            BankdepositRecId,
            BankLedgerAccount,
            CancelTransaction,
            CustVendAC,
            DepositNum,
            LedgerAccount,
            LedgerAccountingCurrencyBalance,
            LedgerAccountName,
            LedgerAmountMSTSecond,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            SumAggregate,
            Voucher
        )
        select CurrencyBalanceDifference,
            AccountingDate,
            BankAccountName,
            BankAccountTransRecId,
            BankAmountCurrency,
            BankdepositRecId,
            BankLedgerAccount,
            CancelTransaction,
            CustVendAC,
            DepositNum,
            LedgerAccount,
            LedgerCurrencyBalance,
            LedgerAccountName,
            LedgerAmountCurrency,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            SumAggregate,
            Voucher
        from bankLedgerReconciliationCurrencyTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBankLedgerReconciliation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Perform reconciliation between the ledger entries and bank transactions.
    /// </summary>
    /// <param name="_userConnection">
    ///     <c>UserConnection</c> to be used with the temporary tables; optional.
    /// </param>
    /// <returns>
    ///     The <c>BankLedgerReconciliationTmp</c> record with reconcilied records.
    /// </returns>
    public BankLedgerReconciliationTmp processBankLedgerReconciliation(UserConnection _userConnection = null)
    {
        if (_userConnection)
        {
            bankLedgerReconciliationTmp.setConnection(_userConnection);
            bankLedgerReconciliationCurrencyTmp.setConnection(_userConnection);
            ledgerReconciliationLedgerTmp.setConnection(_userConnection);
            ledgerReconciliationLedgerCurrencyTmp.setConnection(_userConnection);
            ledgerReconciliationLedgerTmpSummary.setConnection(_userConnection);
            ledgerReconcileAccountsTmp.setConnection(_userConnection);
            bankTransCurrencyTmp.setConnection(_userConnection);
        }

        this.createLedgerReconciliationLedgerTmp();

        // Populate bankLedgerReconciliationCurrencyTmp and ledgerReconciliationLedgerCurrencyTmp based on ledger currency selection.
        if (this.ledgerCurrencySelection == LedgerCurrencySelection::Accounting)
        {
            this.populateLedgerReconciliationAccountingCurrencyTmp(ledgerReconciliationLedgerTmp, ledgerReconciliationLedgerCurrencyTmp);
            this.getBankTransForAccountingCurrency();
        }
        else if (this.ledgerCurrencySelection == LedgerCurrencySelection::Reporting)
        {
            this.populateLedgerReconciliationReportingCurrencyTmp(ledgerReconciliationLedgerTmp, ledgerReconciliationLedgerCurrencyTmp);
            this.getBankTransForReportingCurrency();
        }

        this.insertReconciledBankLedgerTransactions();
        
        this.insertLedgerTransThatCannotBeReconciled();

        this.insertBankTransThatCannotBeReconciled();

        this.calcCurrencyBalanceDifference();

        this.updateMainAccountsName();

        // Populate result bankLedgerReconciliationTmp based on ledger currency selection.
        if (this.ledgerCurrencySelection == LedgerCurrencySelection::Accounting)
        {
            this.populateBankLedgerReconciliationAccountingCurrencyResult();
        }
        else if (this.ledgerCurrencySelection == LedgerCurrencySelection::Reporting)
        {
            this.populateBankLedgerReconciliationReportingCurrencyResult();
        }

        if (SsrsPreProcessReportSkipDefaultDatabaseTrxScope::instance().isEnabled())
        {
            bankLedgerReconciliationCurrencyTmp.dispose();
            ledgerReconciliationLedgerTmp.dispose();
            ledgerReconciliationLedgerCurrencyTmp.dispose();
            ledgerReconciliationLedgerTmpSummary.dispose();
            ledgerReconcileAccountsTmp.dispose();
            bankTransCurrencyTmp.dispose();
        }

        return bankLedgerReconciliationTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMainAccountsName</Name>
				<Source><![CDATA[
    private void updateMainAccountsName()
    {
        MainAccountTranslation mainAccountTranslation;
        LanguageId languageId;

        languageId = DimensionCache::currentDimensionValueLanguageId();

        if (languageId)
        {
            update_recordSet bankLedgerReconciliationCurrencyTmp setting
                MainAccountName = mainAccountTranslation.Name
            join Name from mainAccountTranslation
                where mainAccountTranslation.MainAccount == bankLedgerReconciliationCurrencyTmp.MainAccount
                    && mainAccountTranslation.LanguageId == languageId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankDepositDetailsForAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the bank deposit detail records from <c>BankDepositDetails</c> insert them into the <c>BankLedgerReconciliationCurrencyTmp</c> table for accounting currency.
    /// </summary>
    private void getBankDepositDetailsForAccountingCurrency()
    {
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        BankDeposit bankDepositDetails;
        NoYes isAggregate = NoYes::Yes;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            CancelTransaction,
            BankDepositRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select
            TransDate,
            Voucher,
            AccountId,
            AmountMST,
            DepositNum,
            Canceled,
            RecId,
            isAggregate
        from bankDepositDetails
            where bankDepositDetails.TransDate >= fromDate
                && bankDepositDetails.TransDate <= toDate
                && bankDepositDetails.Voucher >= fromVoucher
                && bankDepositDetails.Voucher <= toVoucher
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankDepositDetails.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankDepositDetails.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankDepositDetails.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankDepositDetails.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.AccountingCurrencyAmount == bankDepositDetails.AmountMST
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankTransSummarizationDetailsForAccountingCurrency</Name>
				<Source><![CDATA[
    private void getBankTransSummarizationDetailsForAccountingCurrency()
    {
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        BankTransSummarizationLine bankTransSummarizationLine;
        NoYes isAggregate = NoYes::Yes;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            BankDepositRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select
            TransDate,
            Voucher,
            AccountId,
            AccountingCurrencyAmount,
            SummarizationId,
            RecId,
            isAggregate
        from bankTransSummarizationLine
            where bankTransSummarizationLine.TransDate >= fromDate
                && bankTransSummarizationLine.TransDate <= toDate
                && bankTransSummarizationLine.Voucher >= fromVoucher
                && bankTransSummarizationLine.Voucher <= toVoucher
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankTransSummarizationLine.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankTransSummarizationLine.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankTransSummarizationLine.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankTransSummarizationLine.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.AccountingCurrencyAmount == bankTransSummarizationLine.AccountingCurrencyAmount
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankDepositDetailsForReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the bank deposit detail records from <c>BankDepositDetails</c> and insert them into the <c>BankLedgerReconciliationCurrencyTmp</c> table for reporting currency.
    /// </summary>
    private void getBankDepositDetailsForReportingCurrency()
    {
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        BankDeposit bankDepositDetails;
        NoYes isAggregate = NoYes::Yes;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            CancelTransaction,
            BankDepositRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select
            TransDate,
            Voucher,
            AccountId,
            AmountReportingCurrency,
            DepositNum,
            Canceled,
            RecId,
            isAggregate
        from bankDepositDetails
            where bankDepositDetails.TransDate >= fromDate
                && bankDepositDetails.TransDate <= toDate
                && bankDepositDetails.Voucher >= fromVoucher
                && bankDepositDetails.Voucher <= toVoucher
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankDepositDetails.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankDepositDetails.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankDepositDetails.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankDepositDetails.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.ReportingCurrencyAmount == bankDepositDetails.AmountReportingCurrency
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankTransSummarizationDetailsForReportingCurrency</Name>
				<Source><![CDATA[
    private void getBankTransSummarizationDetailsForReportingCurrency()
    {
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        BankTransSummarizationLine bankTransSummarizationLine;
        NoYes isAggregate = NoYes::Yes;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            BankDepositRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select
            TransDate,
            Voucher,
            AccountId,
            ReportingCurrencyAmount,
            SummarizationId,
            RecId,
            isAggregate
        from bankTransSummarizationLine
            where bankTransSummarizationLine.TransDate >= fromDate
                && bankTransSummarizationLine.TransDate <= toDate
                && bankTransSummarizationLine.Voucher >= fromVoucher
                && bankTransSummarizationLine.Voucher <= toVoucher
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankTransSummarizationLine.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankTransSummarizationLine.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankTransSummarizationLine.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankTransSummarizationLine.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.ReportingCurrencyAmount == bankTransSummarizationLine.ReportingCurrencyAmount
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewBankTransHavingDistributionForAccountingCurrency</Name>
				<Source><![CDATA[
    private void getNewBankTransHavingDistributionForAccountingCurrency()
    {
        NoYes isAggregate = NoYes::Yes;

        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        BankStmtISOReportEntry statementLine;
        BankStmtISOAccountStatement statementHeader;
        AccountingDistribution accountingDistribution;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, sum(AmountMST), isAggregate from bankAccountTrans
            group by bankAccountTrans.TransDate, bankAccountTrans.Voucher, bankAccountTrans.AccountId, bankAccountTable.Name,
                generalJournalEntry.JournalNumber, mainAccount.RecId, mainAccount.MainAccountId, mainAccount.Name
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.SourceTableId == tableNum(BankStmtISOReportEntry)
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
        exists join statementLine
            where statementLine.IsNewBankDocument == NoYes::Yes
                && statementLine.Voucher == bankAccountTrans.Voucher
        exists join statementHeader
            where statementLine.BankStmtISOAccountStatement == statementHeader.RecId
                && statementHeader.BankAccountTable == bankAccountTrans.AccountId
        exists join accountingDistribution
            where accountingDistribution.SourceDocumentLine == statementLine.SourceDocumentLine
                && accountingDistribution.AllocationFactor < 1
        notexists join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.PostingType == LedgerPostingType::Bank
                && generalJournalAccountEntry.AccountingCurrencyAmount == bankAccountTrans.AmountMST
                && generalJournalAccountEntry.MainAccount == mainAccount.RecId
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewBankTransHavingDistributionForReportingCurrency</Name>
				<Source><![CDATA[
    private void getNewBankTransHavingDistributionForReportingCurrency()
    {
        NoYes isAggregate = NoYes::Yes;

        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        BankStmtISOReportEntry statementLine;
        BankStmtISOAccountStatement statementHeader;
        AccountingDistribution accountingDistribution;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, sum(AmountReportingCurrency), isAggregate from bankAccountTrans
            group by bankAccountTrans.TransDate, bankAccountTrans.Voucher, bankAccountTrans.AccountId, bankAccountTable.Name,
                generalJournalEntry.JournalNumber, mainAccount.RecId, mainAccount.MainAccountId, mainAccount.Name
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.SourceTableId == tableNum(BankStmtISOReportEntry)
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
        exists join statementLine
            where statementLine.IsNewBankDocument == NoYes::Yes
                && statementLine.Voucher == bankAccountTrans.Voucher
        exists join statementHeader
            where statementLine.BankStmtISOAccountStatement == statementHeader.RecId
                && statementHeader.BankAccountTable == bankAccountTrans.AccountId
        exists join accountingDistribution
            where accountingDistribution.SourceDocumentLine == statementLine.SourceDocumentLine
                && accountingDistribution.AllocationFactor < 1
        notexists join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.PostingType == LedgerPostingType::Bank
                && generalJournalAccountEntry.ReportingCurrencyAmount == bankAccountTrans.AmountReportingCurrency
                && generalJournalAccountEntry.MainAccount == mainAccount.RecId
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNotExchAdjBankTransactionsForAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the bank transaction records from <c>BankAccountTrans</c> and insert them into the <c>BankLedgerReconciliationCurrencyTmp</c> table for accounting currency.
    /// </summary>
    private void getNotExchAdjBankTransactionsForAccountingCurrency()
    {
        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable;
        BankDeposit bankDepositDetails;
        BankTransSummarizationLine bankTransSummarizationLine;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        NoYes isAggregate = NoYes::Yes;

        // Insert bank transactions with no correction
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, AmountMST, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect == 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.AccountingCurrencyAmount == bankAccountTrans.AmountMST
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;

        // Insert bank transactions with correction
        FieldId transactionCurrencyField = BankLedgerReconciliationReportDisplayTransWithCorrectionAndDiffCurrencyFlight::instance().isEnabled() ?
            fieldNum(BankAccountTrans, BankTransAmountCur) :
            fieldNum(BankAccountTrans, AmountCur);
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            BankAmountCurrency,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect != 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                && generalJournalEntry.JournalCategory != LedgerTransType::Bank
        join AccountingCurrencyAmount from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.TransactionCurrencyAmount == bankAccountTrans.(transactionCurrencyField)
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;

        // Insert bank transaction corrections having the same vouhcer as the bank transaction
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            BankAmountCurrency,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect != 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                && generalJournalEntry.JournalCategory == LedgerTransType::Bank
        join AccountingCurrencyAmount from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.TransactionCurrencyAmount == bankAccountTrans.AmountCorrect
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;

        BankTransCorrectionVoucherHistory correctionHistory;

        // Insert bank transaction corrections having different vouhcer from the bank transaction
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            CustVendAC,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            Voucher,
            LedgerJournalId,
            BankAmountCurrency,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, AccountId, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect != 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join CorrectionAmountVoucher from correctionHistory
            where correctionHistory.OriginalVoucher == bankAccountTrans.Voucher
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.SubledgerVoucher == correctionHistory.CorrectionAmountVoucher
                && generalJournalEntry.JournalCategory == LedgerTransType::Bank
        join AccountingCurrencyAmount from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.TransactionCurrencyAmount == bankAccountTrans.AmountCorrect
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchAdjBankTransactionsForAccountingCurrency</Name>
				<Source><![CDATA[
    private void getExchAdjBankTransactionsForAccountingCurrency()
    {
        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable;
        BankDeposit bankDepositDetails;
        BankTransSummarizationLine bankTransSummarizationLine;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        NoYes isAggregate = NoYes::Yes;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, AmountMST, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNotExchAdjBankTransactionsForReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the bank transaction records from <c>BankAccountTrans</c> and insert them into the <c>BankLedgerReconciliationCurrencyTmp</c> table for reporting currency.
    /// </summary>
    private void getNotExchAdjBankTransactionsForReportingCurrency()
    {
        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable;
        BankDeposit bankDepositDetails;
        BankTransSummarizationLine bankTransSummarizationLine;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        NoYes isAggregate = NoYes::Yes;

        // Insert bank transactions with no correction
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, AmountReportingCurrency, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect == 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.ReportingCurrencyAmount == bankAccountTrans.AmountReportingCurrency
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;

        // Insert bank transactions with correction
        FieldId transactionCurrencyField = BankLedgerReconciliationReportDisplayTransWithCorrectionAndDiffCurrencyFlight::instance().isEnabled() ?
            fieldNum(BankAccountTrans, BankTransAmountCur) :
            fieldNum(BankAccountTrans, AmountCur);
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            BankAmountCurrency,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect != 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                && generalJournalEntry.JournalCategory != LedgerTransType::Bank
        join ReportingCurrencyAmount from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.TransactionCurrencyAmount == bankAccountTrans.(transactionCurrencyField)
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;

        // Insert bank transaction corrections having the same vouhcer as the bank transaction
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            BankAmountCurrency,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect != 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                && generalJournalEntry.JournalCategory == LedgerTransType::Bank
        join ReportingCurrencyAmount from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.TransactionCurrencyAmount == bankAccountTrans.AmountCorrect
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;

        BankTransCorrectionVoucherHistory correctionHistory;

        // Insert bank transaction corrections having different vouhcer from the bank transaction
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            CustVendAC,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            Voucher,
            LedgerJournalId,
            BankAmountCurrency,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, AccountId, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.AmountCorrect != 0
                && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join CorrectionAmountVoucher from correctionHistory
            where correctionHistory.OriginalVoucher == bankAccountTrans.Voucher
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.SubledgerVoucher == correctionHistory.CorrectionAmountVoucher
                && generalJournalEntry.JournalCategory == LedgerTransType::Bank
        join ReportingCurrencyAmount from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalAccountEntry.TransactionCurrencyAmount == bankAccountTrans.AmountCorrect
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchAdjBankTransactionsForReportingCurrency</Name>
				<Source><![CDATA[
    private void getExchAdjBankTransactionsForReportingCurrency()
    {
        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable;
        BankDeposit bankDepositDetails;
        BankTransSummarizationLine bankTransSummarizationLine;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        MainAccount mainAccount;
        NoYes isAggregate = NoYes::Yes;

        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAmountCurrency,
            DepositNum,
            CancelTransaction,
            BankAccountTransRecId,
            SumAggregate,
            BankAccountName,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName
        )
        select TransDate, Voucher, AccountId, AmountReportingCurrency, DepositNum, Cancel, RecId, isAggregate from bankAccountTrans
            where bankAccountTrans.TransDate >= fromDate
                && bankAccountTrans.TransDate <= toDate
                && bankAccountTrans.Voucher >= fromVoucher
                && bankAccountTrans.Voucher <= toVoucher
                && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment
        join Name from bankAccountTable
            where bankAccountTable.AccountId == bankAccountTrans.AccountId
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == bankAccountTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == bankAccountTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == bankAccountTrans.DataAreaId
        join JournalNumber from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
        join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == bankAccountTable.LedgerDimension
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
        exists join LedgerReconcileAccountsTmp
            where LedgerReconcileAccountsTmp.MainAccount == mainAccount.RecId
        notexists join bankDepositDetails
            where bankAccountTrans.TransDate == bankDepositDetails.TransDate
                && bankAccountTrans.Voucher == bankDepositDetails.Voucher
                && bankAccountTrans.AccountId == bankDepositDetails.AccountId
                && bankAccountTrans.DepositNum == bankDepositDetails.DepositNum
        notexists join bankTransSummarizationLine
            where bankAccountTrans.TransDate == bankTransSummarizationLine.TransDate
                && bankAccountTrans.Voucher == bankTransSummarizationLine.Voucher
                && bankAccountTrans.AccountId == bankTransSummarizationLine.AccountId
                && bankAccountTrans.SummarizationId == bankTransSummarizationLine.SummarizationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBankTransToGroupSummarizedVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process summarized vouchers and other vouchers for reconciliation process.
    /// </summary>
    private void processBankTransToGroupSummarizedVoucher()
    {
        BankLedgerReconciliationCurrencyTmp localTempBankLedgerReconciliationCurrencyTmp;
        NoYes isAggregate = NoYes::Yes;

        localTempBankLedgerReconciliationCurrencyTmp.linkPhysicalTableInstance(bankTransCurrencyTmp);

        // Process the scenario in which you have summarized voucher posting to same Bank Account and same amount
        insert_recordset bankTransCurrencyTmp
        (
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAccountName,
            BankAmountCurrency,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            BankAccountTransRecId,
            BankDepositRecId
        )
        select
            AccountingDate,
            Voucher,
            CustVendAC,
            BankAccountName,
            BankAmountCurrency,
            LedgerJournalId,
            MainAccount,
            MainAccountId,
            MainAccountName,
            BankAccountTransRecId,
            BankDepositRecId
        from localTempBankLedgerReconciliationCurrencyTmp
            group by
                AccountingDate,
                Voucher,
                CustVendAC,
                BankAccountName,
                BankAmountCurrency,
                LedgerJournalId,
                MainAccount,
                MainAccountId,
                MainAccountName,
                BankAccountTransRecId,
                BankDepositRecId;

        delete_from bankTransCurrencyTmp
            where bankTransCurrencyTmp.SumAggregate == NoYes::Yes;

        // Prepare the Bank transaction table for reconciliation process
        if (includeDetails)
        {
            insert_recordset bankTransCurrencyTmp
            (
                AccountingDate,
                Voucher,
                CustVendAC,
                BankAmountCurrency,
                BankAccountName,
                LedgerJournalId,
                MainAccount,
                MainAccountId,
                MainAccountName,
                SumAggregate
            )
            select
                AccountingDate,
                Voucher,
                CustVendAC,
                sum(BankAmountCurrency),
                BankAccountName,
                LedgerJournalId,
                MainAccount,
                MainAccountId,
                MainAccountName,
                isAggregate
            from localTempBankLedgerReconciliationCurrencyTmp
                group by
                    AccountingDate,
                    Voucher,
                    CustVendAC,
                    BankAccountName,
                    LedgerJournalId,
                    MainAccount,
                    MainAccountId,
                    MainAccountName;
        }
        else
        {
            insert_recordset bankTransCurrencyTmp
            (
                BankAmountCurrency,
                MainAccount,
                MainAccountId,
                MainAccountName,
                SumAggregate
            )
            select
                sum(BankAmountCurrency),
                MainAccount,
                MainAccountId,
                MainAccountName,
                isAggregate
            from localTempBankLedgerReconciliationCurrencyTmp
                group by
                    MainAccount,
                    MainAccountId,
                    MainAccountName;
        }

        // Delete all non-aggregated records to avoid double-counting.
        delete_from bankTransCurrencyTmp
            where bankTransCurrencyTmp.SumAggregate == NoYes::No;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>