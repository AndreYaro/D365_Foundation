<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSOrderCommittedReservationFacade</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WHSOrderCommittedReservationFacade</c> class contains the utility methods for order-committed reservations.
/// </summary>
public abstract class WHSOrderCommittedReservationFacade
{
    public const boolean ExecuteNow = true;
    public const boolean RegisterInBalance = false;

    public const boolean AllowReserveReduction = true;
    public const boolean DoNotAllowReserveReduction = false;

    public const boolean UpdateTransferReservation = true;
    public const boolean DoNotUpdateTransferReservation = false;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>beforeMovementUpdateReserveMore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increases reserved quantity of related entities if necessary.
    /// </summary>
    /// <param name = "_inventUpdate">An <c>InventUpd_Reservation</c> instance.</param>
    [Hookable(false)]
	internal static void beforeMovementUpdateReserveMore(InventUpd_Reservation _inventUpdate)
    {
        InventMov_WHSOrderCommittedReservation flexibleMovement = _inventUpdate.movement() as InventMov_WHSOrderCommittedReservation;

        if (!flexibleMovement)
        {
            return;
        }

        InventMovement parentMovement = flexibleMovement.orderCommittedReservationParentMovement();

        InventQty      reservedFlexible = flexibleMovement.transIdSum(true).reservPhysical();
        InventQty      reservedParent = parentMovement.transIdSum(true).reservPhysical();

        InventQty      releasedWithOpenWork = -WHSOrderCommittedReservationFacade::getReleasedWithOpenWorkQty(parentMovement);
        InventQty      reservedOrderCommitted = reservedFlexible + releasedWithOpenWork + _inventUpdate.parmReservation();
        InventQty      qtyLeftToReserve;

        if (reservedOrderCommitted < reservedParent) // If reservation for Order committed reservation entity more than for Committing origin entity (e.g. sales order line)
        {
            InventQty   totalNeedToReserve  = reservedOrderCommitted - reservedParent;
            InventTable inventTable         = flexibleMovement.inventTable();

            MapEnumerator onHandDimQty = WHSOrderCommittedReservationFacade::findDimQtyMapEnumerator(_inventUpdate, inventTable);

            while (onHandDimQty.moveNext() && totalNeedToReserve < 0)
            {
                InventDimId inventDimId     = onHandDimQty.currentKey();
                InventQty   inventSumQty    = onHandDimQty.currentValue();

                InventQty reserveQty = max(totalNeedToReserve, -inventSumQty);
                totalNeedToReserve -= reserveQty;

                InventUpd_WHSReservation inventUpd_Reservation = InventUpd_Reservation::newMovement(
                    parentMovement,
                    reserveQty,
                    false);

                InventDim inventSumInventDim = InventDim::find(inventDimId);
                inventUpd_Reservation.parmInventDimCriteria(inventSumInventDim);

                inventUpd_Reservation.parmAllowReserveReduction(_inventUpdate.parmAllowReserveReduction());
                inventUpd_Reservation.parmThrowOnInsufficientOnHand(_inventUpdate.parmThrowOnInsufficientOnHand());
                inventUpd_Reservation.updateNow();

                qtyLeftToReserve += inventUpd_Reservation.getQtyLeftToReserve();
            }

            if (qtyLeftToReserve)
            {
                qtyLeftToReserve = _inventUpdate.parmReservation() - qtyLeftToReserve;

                if (qtyLeftToReserve > 0)
                {
                    throw error("@SYS6144");
                }

                _inventUpdate.parmReservation(qtyLeftToReserve);
            }
        }
       

        setPrefix(tablePName(WHSOrderCommittedReservation));

        WHSOrderCommittedReservation orderCommittedReservationLocal = WHSOrderCommittedReservation::find(flexibleMovement.buffer().RecId, true);

        orderCommittedReservationLocal.QtyRemain -= _inventUpdate.parmReservation();
        orderCommittedReservationLocal.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDimQtyMapEnumerator</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static MapEnumerator findDimQtyMapEnumerator(InventUpd_Reservation _inventUpdateOrderCommitted, InventTable _inventTable)
    {
        Map                 onHandQuantities        = new Map(Types::String, Types::Real);
        InventDim           inventDimReservation    = _inventUpdateOrderCommitted.parmInventDimCriteria();
        InventDimParm       inventDimParm;
        InventDimGroupSetup inventDimGroupSetup     = InventDimGroupSetup::newItemId(_inventTable.ItemId);
        InventDimParm       dimAboveLocation        = WhsReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(_inventTable);
        InventDim           InventDim;
        InventSum           inventSum;
   
        inventDimParm.initFromInventDim(inventDimReservation);

        while select inventSum
            where inventSum.ItemId == _inventTable.ItemId
            && inventSum.AvailPhysical > 0
            #InventDimExistsJoin(inventSum.InventDimId, InventDim, inventDimReservation, inventDimParm)
        {
            InventDim tmpInventDim;
            
            tmpInventDim.copyDimParmDim(inventDimGroupSetup, inventSum.inventDim(), dimAboveLocation);
            tmpInventDim = InventDim::findOrCreate(tmpInventDim);

            real oldQty = onHandQuantities.exists(tmpInventDim.inventDimId) ? onHandQuantities.lookup(tmpInventDim.inventDimId) : 0;
            onHandQuantities.insert(tmpInventDim.inventDimId, inventSum.AvailPhysical + oldQty);
        }

        return onHandQuantities.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterMovementUpdateReserveMore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increases reserved quantity of related entities if necessary.
    /// </summary>
    /// <param name = "_inventUpdate">An <c>InventUpd_Reservation</c> instance.</param>
    [Hookable(false)]
    internal static void afterMovementUpdateReserveMore(InventUpd_Reservation _inventUpdate)
    {
        InventMov_WHSOrderCommittedReservation flexibleMovement = _inventUpdate.movement() as InventMov_WHSOrderCommittedReservation;

        if (!flexibleMovement)
        {
            return;
        }

        InventMovement parentMovement = flexibleMovement.orderCommittedReservationParentMovement();
        InventQty      reservedFlexible = flexibleMovement.transIdSum(true).reserved();
        InventQty      reservedParent = parentMovement.transIdSum(true).reserved();
        InventQty      releasedWithOpenWork = -WHSOrderCommittedReservationFacade::getReleasedWithOpenWorkQty(parentMovement);

        if (reservedFlexible + releasedWithOpenWork < reservedParent) // If order Committed reservation entity reserved more than Committing origin entity (e.g. sales order line)
        {
            InventUpd_Reservation inventUpd_Reservation = InventUpd_Reservation::newMovement(
                parentMovement,
                reservedFlexible + releasedWithOpenWork - reservedParent,
                false);

            inventUpd_Reservation.parmAllowReserveReduction(false);
            inventUpd_Reservation.parmThrowOnInsufficientOnHand(true);
            inventUpd_Reservation.updateNow();
        }

        WHSOrderCommittedReservation orderCommittedReservationLocal = WHSOrderCommittedReservation::find(flexibleMovement.buffer().RecId, true);

        if (orderCommittedReservationLocal.QtyRemain != -reservedFlexible)
        {
            setPrefix(tablePName(WHSOrderCommittedReservation));

            orderCommittedReservationLocal.QtyRemain = -reservedFlexible;
            orderCommittedReservationLocal.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterMovementUpdateReserveLess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decreases reserved quantity of related entities if necessary.
    /// </summary>
    /// <param name = "_inventUpdate">An <c>InventUpd_Reservation</c> instance.</param>
    [Hookable(false)]
    internal static void afterMovementUpdateReserveLess(InventUpd_Reservation _inventUpdate)
    {
        InventMovement inventMovement = _inventUpdate.movement();

        if (inventMovement is InventMov_WHSOrderCommittedReservation)
        {
            setPrefix(tablePName(WHSOrderCommittedReservation));

            InventQty reservedFlexible = inventMovement.transIdSum(true).reserved();
            WHSOrderCommittedReservation orderCommittedReservationLocal = WHSOrderCommittedReservation::find(inventMovement.buffer().RecId, true);

            orderCommittedReservationLocal.QtyRemain = -reservedFlexible;
            orderCommittedReservationLocal.update();

            return;
        }

        WHSOrderCommittedReservationFacade::syncRemainWithReserveQty(inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncRemainWithReserveQty</Name>
				<Source><![CDATA[
    private static void syncRemainWithReserveQty(InventMovement _inventMovement)
    {
        if (_inventMovement is InventMov_WHSOrderCommittedReservation || !_inventMovement.canUseFlexibleWarehouseLevelDimensionReservation())
        {
            return;
        }

        InventMov_WHSOrderCommittedReservation flexibleMovement = _inventMovement.whsOrderCommittedReservationMovement();

        if (flexibleMovement)
        {
            InventQty reservedFlexible = flexibleMovement.transIdSum(true).reserved();
            InventQty reservedParent = _inventMovement.transIdSum(true).reserved();
            InventQty releasedWithOpenWork = -WHSOrderCommittedReservationFacade::getReleasedWithOpenWorkQty(_inventMovement);

            if (reservedFlexible + releasedWithOpenWork < reservedParent) // If order Committed reservation entity reserved more than Committing origin entity (e.g. sales order line)
            {
                setPrefix(tablePName(WHSOrderCommittedReservation));

                // If specific inventory dimensions are provided through the context we should use them when order-committed reservations are decreased.
                // For example, the WHSReservation entity passes the inventory dimensions to be used here.
                // Having decreased reserved quantity on specific dimension we can safely decrease the QtyRemain field without touching reserved quantity.
                // If specific inventory dimensions are not provided, any dimensions will be used for decreasing reserved quantity when QtyRemain is decreased below.
                if (WHSOrderCommittedReservationRemoveInventDimContext::instance())
                {
                    WHSOrderCommittedReservationFacade::updateInventoryReservation(
                        flexibleMovement.buffer().RecId,
                        reservedFlexible + releasedWithOpenWork - reservedParent,
                        InventDim::find(WHSOrderCommittedReservationRemoveInventDimContext::instance().InventDimId),
                        false);
                }

                WHSOrderCommittedReservation orderCommittedReservationLocal = WHSOrderCommittedReservation::find(flexibleMovement.buffer().RecId, true);

                orderCommittedReservationLocal.QtyRemain = releasedWithOpenWork - reservedParent;
                orderCommittedReservationLocal.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterMovementUpdateDepreciateIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decreases reserved quantity of related entities if necessary.
    /// </summary>
    /// <param name = "_inventUpdate">An <c>InventUpd</c> instance.</param>
    [Hookable(false)]
    internal static void afterMovementUpdateDepreciateIssue(InventUpdate _inventUpdate)
    {
        WHSOrderCommittedReservationFacade::syncRemainWithReserveQty(_inventUpdate.movement());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReleasedWithOpenWorkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the released open quantity for ALL works related to this sales line.
    /// It includes both - work lines with specific batch reservation and normal batch-below lines.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> instance.
    /// </param>
    /// <returns>
    /// The released open quantity.
    /// </returns>
    /// <remarks>
    /// When order-committed reservation balance is used, we are making actual adjustments to the reservations
    /// in the end of the transaction. By that time load lines have correct values and we can use that.
    /// When balance is not used, this code may be executed when load lines are lagging behind
    /// actual changes on work lines. In that case our best bet is to rely on inventory transactions, but it raises numerous
    /// problems in scenarios like: packing, reduce picked qty, short-pick.
    /// </remarks>
    [Hookable(false)]
    internal static InventQty getReleasedWithOpenWorkQty(InventMovement _inventMovement)
    {
        WHSLoadLine loadLine;

        select sum(WorkCreatedQty), sum(PickedQty)
            from loadLine
            where loadLine.InventTransId == _inventMovement.transId();

        return loadLine.WorkCreatedQty - loadLine.PickedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates reserved quantity based on parameters.
    /// </summary>
    /// <param name = "_orderCommittedReservationRecId">The Record ID of the <c>WHSOrderCommittedReservation</c> record.</param>
    /// <param name = "_reserveQty">Quantity to reserve.</param>
    /// <param name = "_inventDim">An <c>InventDim</c> buffer.</param>
    /// <param name = "_allowReserveReduction">Determines if requested qantity must be reserved or it is possible to reserve less in case of not enough on-hand.</param>
    /// <returns>Quantity reserved.</returns>
    [Hookable(false)]
    internal static InventQty updateInventoryReservation(
        RecId     _orderCommittedReservationRecId,
        InventQty _reserveQty,
        InventDim _inventDim,
        boolean   _allowReserveReduction = false)
    {
        WHSOrderCommittedReservation           orderCommittedReservation = WHSOrderCommittedReservation::find(_orderCommittedReservationRecId);
        InventMov_WHSOrderCommittedReservation movement = InventMov_WHSOrderCommittedReservation::newFromOrderCommittedReservation(orderCommittedReservation);

        InventUpd_WHSReservation inventUpd_Reservation = InventUpd_Reservation::newInventDim(
            movement,
            _inventDim,
            -_reserveQty);

        if (_reserveQty > 0)
        {
            InventDimParm inventDimParm;

            inventDimParm.initFromInventDim(movement.inventdim());
            inventUpd_Reservation.parmInventDimParm(inventDimParm);
        }

        inventUpd_Reservation.parmAllowReserveReduction(_allowReserveReduction);
        inventUpd_Reservation.parmThrowOnInsufficientOnHand(!_allowReserveReduction);
        inventUpd_Reservation.updateNow();

        // getQtyLeftToReserve is negative when reservation is increased.
        return _reserveQty + inventUpd_Reservation.getQtyLeftToReserve();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates transferred quantity based on parameters.
    /// </summary>
    /// <param name = "_orderCommittedReservationRecId">The Record ID of the <c>WHSOrderCommittedReservation</c> record.</param>
    /// <param name = "_transferQty">Quantity to transfer.</param>
    /// <param name = "_mandatoryInventDimId">An <c>InventDim</c> buffer.</param>
    [Hookable(false)]
    internal static void updateTransferReservation(
        RecId       _orderCommittedReservationRecId,
        InventQty   _transferQty,
        InventDimId _mandatoryInventDimId)
    {
        WHSOrderCommittedReservationTransferred orderCommittedReservationTransferred;

        ttsbegin;

        select firstonly forupdate orderCommittedReservationTransferred
            where orderCommittedReservationTransferred.OrderCommittedReservation == _orderCommittedReservationRecId
            &&    orderCommittedReservationTransferred.InventDimId               == _mandatoryInventDimId;

        if (orderCommittedReservationTransferred)
        {
            orderCommittedReservationTransferred.QtyTransferred += _transferQty;

            if (orderCommittedReservationTransferred.QtyTransferred == 0)
            {
                orderCommittedReservationTransferred.delete();
            }
            else
            {
                orderCommittedReservationTransferred.update();
            }
        }
        else
        {
            orderCommittedReservationTransferred.initValue();
            orderCommittedReservationTransferred.OrderCommittedReservation = _orderCommittedReservationRecId;
            orderCommittedReservationTransferred.InventDimId               = _mandatoryInventDimId;
            orderCommittedReservationTransferred.QtyTransferred            = _transferQty;
            orderCommittedReservationTransferred.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransferredQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the transferred quantity for a specified set of parameters.
    /// </summary>
    /// <param name="_committingOriginInventTransId">
    /// The ID of the committing origin inventory transaction.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions to include in the search.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventory dimensions to include in the search.
    /// </param>
    /// <returns>
    /// The quantities for a specified set of parameters.
    /// </returns>
    [Hookable(false)]
    public static InventQty calculateTransferredQty(
        InventTransId _committingOriginInventTransId,
        InventDim     _inventDim,
        InventDimParm _inventDimParm)
    {
        WHSOrderCommittedReservation            orderCommittedReservation;
        WHSOrderCommittedReservationTransferred orderCommittedReservationTransferred;
        InventDim                               inventDimLocal;

        select firstonly sum(QtyTransferred) from orderCommittedReservationTransferred
            exists join orderCommittedReservation
                where orderCommittedReservation.CommittingOriginInventTransId == _committingOriginInventTransId
                &&    orderCommittedReservation.RecId                         == orderCommittedReservationTransferred.OrderCommittedReservation
            #InventDimExistsJoin(orderCommittedReservationTransferred.InventDimId, inventDimLocal, _inventDim, _inventDimParm);
        
        return orderCommittedReservationTransferred.QtyTransferred;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractMandatoryInventoryDimensions</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static InventDimId extractMandatoryInventoryDimensions(ItemId _itemId, InventDimId _fullDimensionsInventDimId)
    {
        if (_fullDimensionsInventDimId)
        {
			InventDim	inventDim = InventDim::find(_fullDimensionsInventDimId);
            InventTable	inventTable = InventTable::find(_itemId);

            WHSReservationHierarchyRecId reservationHierarchyRecId = inventTable.whsReservationHierarchy();

            WHSReservationHierarchyElementPolicyProvider reservationHierarchyElementPolicyProvider = WHSReservationHierarchyElementPolicyProvider::singleton();

            List dimListLocationAndBelow = WhsReservationHierarchyProvider::construct().getDimListLocationAndDownFromInventTable(inventTable, WhsReservationHierarchySortOrder::BottomUp);
            ListEnumerator dimListLocationAndBelowEnumerator = dimListLocationAndBelow.getEnumerator();

            while (dimListLocationAndBelowEnumerator.moveNext())
            {
                WHSReservationHierarchyElementData elementData = dimListLocationAndBelowEnumerator.current();

                if (!reservationHierarchyElementPolicyProvider.isReservationOnDemandOrderEnabled(reservationHierarchyRecId, elementData.parmDimensionFieldId()))
                {
                    inventDim.(elementData.parmDimensionFieldId()) = nullValue(inventDim.(elementData.parmDimensionFieldId()));
                }
            }

            return InventDim::findOrCreate(inventDim).inventDimId;
        }
        else
        {
            return _fullDimensionsInventDimId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewLocationQuantityMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a map with on-hand quantities found at specific inventory dimensions.
    /// </summary>
    /// <param name = "_itemId">Item identifier to search on-hand for.</param>
    /// <param name = "_inventDimId">Inventory dimensions to search on-hand at.</param>
    /// <param name = "_inventQtyToFind">How much quantity to find.</param>
    /// <param name = "_specificLocationId">Optionally can search at specific location.</param>
    /// <param name = "_throwErrorQtyMismatch">Specifies if error should be thrown if not enough on-hand is found.</param>
    /// <returns>A map with quantities found at specific inventory dimensions.</returns>
	[Hookable(false)]
	internal static Map createNewLocationQuantityMap(ItemId				_itemId,
													 InventDimId		_inventDimId,
													 InventHandlingQty  _inventQtyToFind,
													 WMSLocationId      _specificLocationId = '',
													 boolean			_throwErrorQtyMismatch = true)
    {
        InventDimId mandatoryDimensionsInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(_itemId, _inventDimId);

        InventDim inventDim = InventDim::find(mandatoryDimensionsInventDimId);
        inventDim.wmsLocationId = _specificLocationId;

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(inventDim);

        Map newLocationQuantityMap = new Map(Types::String, Types::Real);
        InventHandlingQty totalFoundQty = 0;

        if (InventUpdateOnHandGlobal::mustAddInventSumDeltaOnhand(_itemId))
        {
            InventSumUnionAllDeltaPhysicalQty inventSumSpecific;
            InventDim                         inventDimSpecific;

            while select inventSumSpecific
                where  inventSumSpecific.ItemId == _itemId
                    && inventSumSpecific.PhysicalInvent > 0
                #InventDimInnerJoin(inventSumSpecific.inventDimId, inventDimSpecific, inventDim, inventDimParm)
            {
                InventHandlingQty availPhysical = WHSInventOnHand::getPhysicalAvailHandlingQty(_itemId, inventDimSpecific, true, true);

                if (availPhysical > 0)
                {
                    InventHandlingQty qtyToUse = min(availPhysical, _inventQtyToFind - totalFoundQty);

                    newLocationQuantityMap.insert(inventDimSpecific.inventDimId, qtyToUse);
                    totalFoundQty += qtyToUse;

                    if (_inventQtyToFind == totalFoundQty)
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            InventSum inventSumSpecific;
            InventDim inventDimSpecific;

            while select inventSumSpecific
                where  inventSumSpecific.ItemId == _itemId
                    && inventSumSpecific.PhysicalInvent > 0
                    && inventSumSpecific.ClosedQty == NoYes::No
                #InventDimInnerJoin(inventSumSpecific.inventDimId, inventDimSpecific, inventDim, inventDimParm)
            {
                InventHandlingQty availPhysical = WHSInventOnHand::getPhysicalAvailHandlingQty(_itemId, inventDimSpecific, false, true);

                if (availPhysical > 0)
                {
                    InventHandlingQty qtyToUse = min(availPhysical, _inventQtyToFind - totalFoundQty);

                    newLocationQuantityMap.insert(inventDimSpecific.inventDimId, qtyToUse);
                    totalFoundQty += qtyToUse;

                    if (_inventQtyToFind == totalFoundQty)
                    {
                        break;
                    }
                }
            }
        }

        if (_inventQtyToFind != totalFoundQty && _throwErrorQtyMismatch)
        {
            throw error("@WAX3372");
        }

        return newLocationQuantityMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewLocationQuantityMapWithOrderCommittedIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a map with on-hand quantities found at specific inventory dimensions. Include the order-committed reservation.
    /// </summary>
    /// <param name = "_parentInventTransId">IventTransId for the order-committed reservation.</param>
    /// <param name = "_itemId">Item identifier to search on-hand for.</param>
    /// <param name = "_inventDimId">Inventory dimensions to search on-hand at.</param>
    /// <param name = "_inventQtyToFind">How much quantity to find.</param>
    /// <param name = "_specificLocationId">Optionally can search at specific location.</param>
    /// <param name = "_throwErrorQtyMismatch">Specifies if error should be thrown if not enough on-hand is found.</param>
    /// <returns>A map with quantities found at specific inventory dimensions.</returns>
	[Hookable(false)]
	internal static Map createNewLocationQuantityMapWithOrderCommittedIncluded( InventTransId		    _parentInventTransId,
                                                                                ItemId					_itemId,
                                                                                InventDimId				_inventDimId,
                                                                                InventHandlingQty		_inventQtyToFind,
                                                                                WMSLocationId			_specificLocationId = '',
																				boolean					_throwErrorQtyMismatch = true)
    {
        Map					newLocationQuantityMap = new Map(Types::String, Types::Real);
        InventHandlingQty	totalFoundQty = 0;

        InventTransOriginId	inventTransOriginId = InventTransOrigin::findByInventTransId(WHSOrderCommittedReservation::findByCommittingOriginInventTransId(_parentInventTransId).InventTransId).RecId;

        if (inventTransOriginId)
        {
            InventTrans	inventTrans;

            if (_specificLocationId)
            {
                InventDim	inventDim;

                while select sum(Qty) from inventTrans
                group by InventDimId
                where inventTrans.InventTransOrigin == inventTransOriginId
                exists join inventDim
                where  inventDim.InventDimId	  == inventTrans.InventDimId
                    && inventDim.InventLocationId == InventDim::find(_inventDimId).InventLocationId
                    && InventDim.WmsLocationId	  == _specificLocationId
                {
                    newLocationQuantityMap.insert(inventTrans.inventDimId, -inventTrans.Qty);
                    totalFoundQty += -inventTrans.Qty;
                }
            }
            else
            {
                while select sum(Qty) from inventTrans
                group by InventDimId
                where inventTrans.InventTransOrigin == inventTransOriginId
                {
                    newLocationQuantityMap.insert(inventTrans.inventDimId, -inventTrans.Qty);
                    totalFoundQty += -inventTrans.Qty;
                }
            }
        }

        if (totalFoundQty < _inventQtyToFind)
        {
            Map locationQuantityMapTmp = WHSOrderCommittedReservationFacade::createNewLocationQuantityMap(_itemId, _inventDimId, _inventQtyToFind - totalFoundQty, _specificLocationId, _throwErrorQtyMismatch);
            
            WHSOrderCommittedReservationFacade::mergeMaps(newLocationQuantityMap, locationQuantityMapTmp);
        }

        return newLocationQuantityMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeMaps</Name>
				<Source><![CDATA[
    private static void mergeMaps(Map _mapTo, Map _mapFrom)
    {
        MapEnumerator	mapFromEnumerator = _mapFrom.getEnumerator();

        while (mapFromEnumerator.moveNext())
        {
            str key	   = mapFromEnumerator.currentKey();
            real value = mapFromEnumerator.currentValue();

            if (_mapTo.exists(key))
            {
                value += _mapTo.lookup(key);
            }

            _mapTo.insert(key, value);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderCommittedReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add/Remove qty to the <c>WHSOrderCommittedReservationTransfered.QtyTransfered</c> field. Reservation will be changed.
    /// </summary>
    /// <param name = "_committingOriginInventTransId">Inventory transaction id of the source record.</param>
    /// <param name = "_inventDimId">Inventory dimensions id.</param>
    /// <param name = "_qtyToAdd">Quantity that will be added/removed to the <c>WHSOrderCommittedReservationTransfered.QtyTransfered</c> field value.</param>
    /// <param name = "_executeNow">Deterimnes if actual reservation changes should happen now or stored in balance and deferred to transaction end.</param>
    /// <param name = "_allowReserveReduction">Determines if requested qantity must be reserved or it is possible to reserve less in case of not enough on-hand.</param>
    /// <param name = "_updateTransferReservation">Determines if requested quantity must be added to/removed from transfer reservation.</param>
    [Hookable(false)]
    internal static void updateOrderCommittedReservation(
        InventTransId   _committingOriginInventTransId,
        InventDimId     _inventDimId,
        InventQty       _qtyToAdd,
        boolean         _executeNow = WHSOrderCommittedReservationFacade::RegisterInBalance,
        boolean         _allowReserveReduction = WHSOrderCommittedReservationFacade::DoNotAllowReserveReduction,
        boolean         _updateTransferReservation = WHSOrderCommittedReservationFacade::UpdateTransferReservation)
    {
        if (   !_qtyToAdd
            || !_committingOriginInventTransId
            || !_inventDimId)
        {
            return;
        }

        using (WHSOrderCommittedReservationFacadePerformanceTask perfTask = WHSOrderCommittedReservationFacadePerformanceTask::newFromAction('commitFacade'))
        {
            //Continuing on work creation failure is not supported when ordered committed reservations exist
            WHSWorkCreateReservationContext::disable();

            WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(_committingOriginInventTransId);
    
            if (!orderCommittedReservation)
            {
                throw error("@WAX:Error_WHSOrderCommittedReservationMissing");
            }
            
            InventDimId mandatoryInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(orderCommittedReservation.ItemId, _inventDimId);

            if (_executeNow)
            {
                InventQty reservedQty = WHSOrderCommittedReservationFacade::updateInventoryReservation(
                    orderCommittedReservation.RecId,
                    _qtyToAdd,
                    InventDim::find(mandatoryInventDimId),
                    _allowReserveReduction);

                if (_updateTransferReservation)
                {
                    WHSOrderCommittedReservationFacade::updateTransferReservation(
                        orderCommittedReservation.RecId,
                        -_qtyToAdd,
                        mandatoryInventDimId);
                }

                if (_allowReserveReduction && _qtyToAdd > 0 && _qtyToAdd > reservedQty)
                {
                    InventMov_WHSOrderCommittedReservation flexibleMovement = InventMov_WHSOrderCommittedReservation::newFromOrderCommittedReservation(orderCommittedReservation);
                    InventMovement parentMovement = flexibleMovement.orderCommittedReservationParentMovement();

                    InventUpd_Reservation inventUpd_Reservation = InventUpd_Reservation::newMovement(
                        parentMovement,
                        _qtyToAdd - reservedQty,
                        false);

                    inventUpd_Reservation.parmAllowReserveReduction(false);
                    inventUpd_Reservation.parmThrowOnInsufficientOnHand(true);
                    inventUpd_Reservation.updateNow();
                }
            }
            else
            {
                WHSOrderCommittedReservationBalanceGlobal::instance().orderCommittedReservationBalance().addToBalance(
                    _committingOriginInventTransId,
                    mandatoryInventDimId,
                    _qtyToAdd,
                    _allowReserveReduction,
                    _updateTransferReservation);
            }

            perfTask.setExecuteNow(_executeNow);
            perfTask.setAllowReserveReduction(_allowReserveReduction);
            perfTask.setOrderCommittedReservationRecId(orderCommittedReservation.RecId);
            perfTask.setMandatoryInventDimId(mandatoryInventDimId);
            perfTask.setQtyToAdd(_qtyToAdd);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOrderCommittedReservationsInBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// For given committing origin inventory transaction and inventory dimensions, checks balance if there are any pending reservations.
    /// </summary>
    /// <param name = "_committingOriginInventTransId">A committing origin to check.</param>
    /// <param name = "_inventDimId">Inventory dimensions to check.</param>
    /// <returns>true if there are pending order-committed reservations in balance; false, otherwise.</returns>
    [Hookable(false)]
    internal static boolean hasOrderCommittedReservationsInBalance(InventTransId _committingOriginInventTransId, InventDimId _inventDimId)
    {
        WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(_committingOriginInventTransId);
        if (!orderCommittedReservation)
        {
            return false;
        }

        InventDimId mandatoryInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(orderCommittedReservation.ItemId, _inventDimId);

        return WHSOrderCommittedReservationBalanceGlobal::instance().orderCommittedReservationBalance().hasOrderCommittedReservationsInBalance(
            _committingOriginInventTransId,
            mandatoryInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrderCommittedReservationMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a map instance with ordered reservation.
    /// </summary>
    /// <param name = "_committingOriginInventTransId">The ID of the committing origin inventory transaction.</param>
    /// <param name = "_loadLineInventDimId">The ID of the inventory dimension of load line.</param>
    /// <param name = "_inventTable">The <c>InventTable</c> related to the temporary work line.</param>
    /// <returns>The map instance.</returns>
    [Hookable(false)]
    internal static Map createOrderCommittedReservationMap(InventTransId _committingOriginInventTransId, InventDimId _loadLineInventDimId = '', InventTable _inventTable = null)
    {
        WHSInventTransOriginOrderCommittedReservation	inventTransOriginOrderCommittedReservation;
        WHSOrderCommittedReservation					orderCommittedReservation;

        Map dimAndQtyMap = new Map(extendedTypeId2Type(extendedTypeNum(InventDimId)), extendedTypeId2Type(extendedTypeNum(InventQty)));

        select firstonly InventTransOrigin from inventTransOriginOrderCommittedReservation
        exists join orderCommittedReservation
        where  orderCommittedReservation.RecId == inventTransOriginOrderCommittedReservation.OrderCommittedReservation
            && orderCommittedReservation.CommittingOriginInventTransId == _committingOriginInventTransId;

        if (inventTransOriginOrderCommittedReservation.InventTransOrigin)
        {
            List fieldIdList;

            if (_inventTable)
            {
                List hierarchyList = WHSReservationHierarchyProvider::construct().getDimListAboveLocationFromInventTable(_inventTable, WHSReservationHierarchySortOrder::TopDown);
                fieldIdList   = WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(hierarchyList);
            }

            InventTrans	inventTrans;
            
			while select sum(Qty) from inventTrans
                group by InventDimId
                where  inventTrans.InventTransOrigin == inventTransOriginOrderCommittedReservation.InventTransOrigin
                    && inventTrans.StatusIssue		 == StatusIssue::ReservPhysical
            {
                if ( !_loadLineInventDimId
                  || !_inventTable
                  || InventDim::isInventDimEqual(inventTrans.inventDim(), InventDim::find(_loadLineInventDimId), fieldIdList))
                {
                    dimAndQtyMap.insert(inventTrans.inventDimId, -inventTrans.Qty);
                }
            }
        }

        return dimAndQtyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderCommittedReservationExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if flexible reservation exists.
    /// </summary>
    /// <param name = "_committingOriginInventTransId">The ID of the committing origin inventory transaction.</param>
    /// <returns>True if flexible reservation exists; otherwise, false</returns>
    [Hookable(false)]
    internal static boolean orderCommittedReservationExists(InventTransId _committingOriginInventTransId)
    {
        WHSOrderCommittedReservation orderCommittedReservation;

        select firstonly RecId from orderCommittedReservation
            where  orderCommittedReservation.CommittingOriginInventTransId == _committingOriginInventTransId;

        if (!orderCommittedReservation)
        {
            return false;
        }

        WHSInventTransOriginOrderCommittedReservation inventTransOriginOrderCommittedReservation;
        InventTrans	                                  inventTrans;

        select firstonly TableId from inventTransOriginOrderCommittedReservation
            where inventTransOriginOrderCommittedReservation.OrderCommittedReservation == orderCommittedReservation.RecId
        exists join inventTrans
            where inventTrans.InventTransOrigin == inventTransOriginOrderCommittedReservation.InventTransOrigin
            &&    inventTrans.StatusIssue       == StatusIssue::ReservPhysical
            &&    inventTrans.Qty;

        if (inventTransOriginOrderCommittedReservation)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAllOrderCommittedReservationsOnInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all order commited reservations related to an <c>InventDim</c> on an item, and adds them to the balance to restore at the end of the transaction.
    /// </summary>
    /// <param name = "_itemId">Item identifier to search for</param>
    /// <param name = "_inventDimCriteria"><c>InventDim</c> itentifier</param>
    /// <param name = "_allowReserveReduction">Determines if requested qantity must be reserved or it is possible to reserve less in case of not enough on-hand.</param>
    /// <param name = "_updateTransferReservation">Determines if requested quantity must be added to/removed from transfer reservation.</param>
    [Hookable(false)]
    internal static void removeAllOrderCommittedReservationsOnInventDim(
        ItemId      _itemId,
        InventDim   _inventDimCriteria,
        boolean     _allowReserveReduction = WHSOrderCommittedReservationFacade::DoNotAllowReserveReduction,
        boolean     _updateTransferReservation = WHSOrderCommittedReservationFacade::UpdateTransferReservation)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventDim           inventDim;
        InventDimParm       inventDimParm;

        inventDimParm.initFromInventDim(_inventDimCriteria);

        while select Qty, InventDimId from inventTrans
            where inventTrans.ItemId        == _itemId
            &&    inventTrans.StatusReceipt == StatusReceipt::None // for the sake of performance
            &&    inventTrans.StatusIssue   == StatusIssue::ReservPhysical // for the sake of performance
            join InventTransId from inventTransOrigin
                where  inventTrans.InventTransOrigin       == inventTransOrigin.RecId
                &&     inventTransOrigin.ReferenceCategory == InventTransType::WHSOrderCommittedReservation
                &&     inventTransOrigin.ItemId            == _itemId // for the sake of performance
            #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm)
        {
            WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByTransId(inventTransOrigin.InventTransId);

            // remove order-committed reservations immediatelly.
            WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                orderCommittedReservation.CommittingOriginInventTransId,
                inventTrans.InventDimId,
                inventTrans.Qty,
                WHSOrderCommittedReservationFacade::ExecuteNow,
                _allowReserveReduction,
                _updateTransferReservation);

            // try to restore afterwards.
            WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                orderCommittedReservation.CommittingOriginInventTransId,
                inventTrans.InventDimId,
                -inventTrans.Qty,
                WHSOrderCommittedReservationFacade::RegisterInBalance,
                _allowReserveReduction,
                _updateTransferReservation);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>