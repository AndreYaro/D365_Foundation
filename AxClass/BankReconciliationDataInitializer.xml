<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankReconciliationDataInitializer</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BankReconciliationDataInitializer</c> is initializing data for bank reconciliation.
/// </summary>
public class BankReconciliationDataInitializer
{
    protected BankReconciliationHeader reconciliation;

    protected BankReconciliationStatementOpenTmp tmpStatement;
    protected BankReconciliationDocumentOpenTmp tmpDocument;

    private RecordInsertList documentInsertList;
    private RecordInsertList statementInsertList;

    private boolean isModernBankReconciliationFeatureEnabled = FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance());

    #macrolib.BankReconciliationConditions

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initDocumentOpenTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes temporary data for bank document from parameters.
    /// </summary>
    /// <param name="_documentView">
    /// Given <c>BankDocumentTableView</c> buffer.
    /// </param>
    /// <param name="_isMatched">
    /// Indicates whether the given bank document is matched.
    /// </param>
    protected void initDocumentOpenTmp(BankDocumentTableView _documentView, NoYesId _isMatched)
    {
        BankDocument document = BankDocument::newFromDocumentView(_documentView);
        
        tmpDocument.clear();
        tmpDocument.BankDocumentTableView = _documentView.BankDocumentTableRecId;

        Amount originalBankCurrencyAmount = document.getOriginalBankCurrencyAmount();
        if (originalBankCurrencyAmount > 0)
        {
            tmpDocument.DebitAmount = originalBankCurrencyAmount;
        }
        else
        {
            tmpDocument.CreditAmount = -1 * originalBankCurrencyAmount;
        }

        tmpDocument.BankCurrencyAmount = originalBankCurrencyAmount;
        tmpDocument.CorrectionBankCurrencyAmount = document.getCorrectionBankCurrencyAmount();
        tmpDocument.TransactionCurrency = document.getTransactionCurrency();
        tmpDocument.TransactionCurrencyAmount = document.getTransactionCurrencyAmount();

        tmpDocument.BankTransType = document.getBankTransType();
        tmpDocument.Description = _documentView.Description;
        tmpDocument.Reference = _documentView.Reference;
        tmpDocument.PaymId = document.getPaymId();
        tmpDocument.EndToEndId = document.getEndToEndId();

        tmpDocument.TransactionDate = document.getTransactionDate();
        tmpDocument.DocumentNum = document.getDocumentNum();
        tmpDocument.DocumentType = _documentView.DocumentType;

        tmpDocument.RelatedPartyAccount = document.getRelatedPartyAccount();
        tmpDocument.RelatedPartyName = document.getRelatedPartyName();
        tmpDocument.RelatedPartyCompany = document.getRelatedPartyCompany();
        tmpDocument.RelatedPartyType = document.getRelatedPartyType();

        tmpDocument.Status = document.getOrignalBankDocumentStatusName();
        tmpDocument.IsMatched = _isMatched;
        tmpDocument.Cancelled = document.getCancelled();
        tmpDocument.IsReconciled = _documentView.IsReconciled;
        tmpDocument.Posted = _documentView.Posted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmp</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmp()
    {
        this.updateDocumentOpenTmpForBankAccountTransLedgerJournalTransCust();
        this.updateDocumentOpenTmpForBankAccountTransLedgerJournalTransVend();
        this.updateDocumentOpenTmpForBankAccountTransBankChequeTableCust();
        this.updateDocumentOpenTmpForBankAccountTransBankChequeTableVend();
        this.updateDocumentOpenTmpForBankAccountTransBankDeposit();
        this.updateDocumentOpenTmpForBankChequeTableCust();
        this.updateDocumentOpenTmpForBankChequeTableVend();
        this.updateDocumentOpenTmpForBankDeposit();
        this.updateDocumentOpenTmpForBankDepositCancel();
        this.updateDocumentOpenTmpForPaymentVend();
        this.updateDocumentOpenTmpForPaymentCust();
        this.updateDocumentOpenTmpForBridgedPayment();
        this.updateDocumentOpenTmpForBankStatement();
        this.updateDocumentOpenTmpIsMatched();
        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerPostDatedChecks)))
        {
            this.updateTransDateForPDC();
        }
        this.updateDocumentOpenTmpForSummarizedTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankAccountTransLedgerJournalTransCust</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankAccountTransLedgerJournalTransCust()
    {
        BankDocumentTable bankDocumentTable;
        BankAccountTrans bankAccountTrans;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        LedgerJournalTrans ledgerJournalTrans;
        CustTable custTable;
        DirPartyTable dirPartyTable;

        str status = enum2str(DocumentStatus::None);

        FieldId customerKeyFieldId = LedgerJournalTransLedgerDimensionNameHelper::findDimensionAttributeValueCombinationKeyColumnFieldId(
            DimensionHierarchyType::Customer);

        update_recordset tmpDocument
            setting RelatedPartyAccount = custTable.AccountNum,
                RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankAccountTrans.DataAreaId,
                Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankAccountTrans)
            join RecId, DataAreaId, SourceRecId from bankAccountTrans
                where bankAccountTrans.RecId == bankDocumentTable.SourceRecId
                    && bankAccountTrans.SourceTableId == tableNum(LedgerJournalTrans)
            join RecId from ledgerJournalTrans
                where ledgerJournalTrans.RecId == bankAccountTrans.SourceRecId
                    && ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == ledgerJournalTrans.LedgerDimension
            join RecId, AccountNum from custTable
                where dimensionAttributeValueCombination.(customerKeyFieldId) == custTable.RecId
            join RecId, Name from dirPartyTable
                where custTable.Party == dirPartyTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankAccountTransLedgerJournalTransVend</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankAccountTransLedgerJournalTransVend()
    {
        BankDocumentTable bankDocumentTable;
        BankAccountTrans bankAccountTrans;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        LedgerJournalTrans ledgerJournalTrans;
        VendTable vendTable;
        DirPartyTable dirPartyTable;

        str status = enum2str(DocumentStatus::None);

        FieldId vendorKeyFieldId = LedgerJournalTransLedgerDimensionNameHelper::findDimensionAttributeValueCombinationKeyColumnFieldId(
            DimensionHierarchyType::Vendor);

        update_recordset tmpDocument
            setting RelatedPartyAccount = vendTable.AccountNum,
                RelatedPartyType = DirPartyRoleType::Vendor,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankAccountTrans.DataAreaId,
                Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankAccountTrans)
            join RecId, DataAreaId, SourceRecId from bankAccountTrans
                where bankAccountTrans.RecId == bankDocumentTable.SourceRecId
                    && bankAccountTrans.SourceTableId == tableNum(LedgerJournalTrans)
            join RecId from ledgerJournalTrans
                where ledgerJournalTrans.RecId == bankAccountTrans.SourceRecId
                    && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == ledgerJournalTrans.LedgerDimension
            join RecId, AccountNum from vendTable
                where dimensionAttributeValueCombination.(vendorKeyFieldId) == vendTable.RecId
            join RecId, Name from dirPartyTable
                where vendTable.Party == dirPartyTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankAccountTransBankChequeTableCust</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankAccountTransBankChequeTableCust()
    {
        BankDocumentTable bankDocumentTable;
        BankAccountTrans bankAccountTrans;
        BankChequeTable bankChequeTable;
        CustTable custTable;
        DirPartyTable dirPartyTable;

        str status = enum2str(DocumentStatus::None);

        update_recordset tmpDocument
            setting RelatedPartyAccount = bankChequeTable.RecipientAccountNum,
                RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyName = dirPartyTable.Name, 
                RelatedPartyCompany = bankAccountTrans.DataAreaId,
                Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankAccountTrans)
            join RecId, DataAreaId, SourceRecId from bankAccountTrans
                where bankAccountTrans.RecId == bankDocumentTable.SourceRecId
                    && bankAccountTrans.SourceTableId == tableNum(BankChequeTable)
            join RecId, RecipientAccountNum, ChequeStatus from bankChequeTable
                where bankChequeTable.RecId == bankAccountTrans.SourceRecId
                    && bankChequeTable.RecipientType == BankChequeRecipientType::Cust
            join RecId from custTable
                where bankChequeTable.RecipientAccountNum == custTable.AccountNum
            join RecId, Name from dirPartyTable
                where custTable.Party == dirPartyTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankAccountTransBankChequeTableVend</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankAccountTransBankChequeTableVend()
    {
        BankDocumentTable bankDocumentTable;
        BankAccountTrans bankAccountTrans;
        BankChequeTable bankChequeTable;
        VendTable vendTable;
        DirPartyTable dirPartyTable;

        str status = enum2str(DocumentStatus::None);

        update_recordset tmpDocument
            setting RelatedPartyAccount = bankChequeTable.RecipientAccountNum,
                RelatedPartyType = DirPartyRoleType::Vendor,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankAccountTrans.DataAreaId,
                Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankAccountTrans)
            join RecId, DataAreaId, SourceRecId from bankAccountTrans
                where bankAccountTrans.RecId == bankDocumentTable.SourceRecId
                    && bankAccountTrans.SourceTableId == tableNum(BankChequeTable)
            join RecId, RecipientAccountNum from bankChequeTable
                where bankChequeTable.RecId == bankAccountTrans.SourceRecId
                    && bankChequeTable.RecipientType == BankChequeRecipientType::Vend
            join RecId from vendTable
                where bankChequeTable.RecipientAccountNum == vendTable.AccountNum
            join RecId, Name from dirPartyTable
                where vendTable.Party == dirPartyTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankAccountTransBankDeposit</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankAccountTransBankDeposit()
    {
        BankDocumentTable bankDocumentTable;
        BankAccountTrans bankAccountTrans;
        BankDeposit bankDeposit;
        CustTable custTable;
        DirPartyTable dirPartyTable;

        str status = enum2str(DocumentStatus::None);

        update_recordset tmpDocument
            setting RelatedPartyAccount = bankDeposit.CustAccount,
            RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankAccountTrans.DataAreaId,
                Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankAccountTrans)
            join RecId, DataAreaId, SourceRecId from bankAccountTrans
                where bankAccountTrans.RecId == bankDocumentTable.SourceRecId
                    && bankAccountTrans.SourceTableId == tableNum(BankDeposit)
            join RecId, CustAccount from bankDeposit
                where bankDeposit.RecId == bankAccountTrans.SourceRecId
            join RecId from custTable
                where bankDeposit.CustAccount == custTable.AccountNum
            join RecId, Name from dirPartyTable
                where custTable.Party == dirPartyTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankChequeTableCust</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankChequeTableCust()
    {
        BankDocumentTable bankDocumentTable;
        BankChequeTable bankChequeTable;
        CustTable custTable;
        DirPartyTable dirPartyTable;

        TmpEnumIdLabel tmpEnumIdLabel;
        TmpEnumIdLabel::populate(enumNum(ChequeStatus), tmpEnumIdLabel);

        update_recordset tmpDocument
            setting RelatedPartyAccount = bankChequeTable.RecipientAccountNum,
                RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankChequeTable.DataAreaId,
                Status = tmpEnumIdLabel.Label
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankChequeTable)
            join RecId, RecipientAccountNum, DataAreaId from bankChequeTable
                where bankChequeTable.RecId == bankDocumentTable.SourceRecId
                    && bankChequeTable.RecipientType == BankChequeRecipientType::Cust
            join RecId from custTable
                where bankChequeTable.RecipientAccountNum == custTable.AccountNum
            join RecId, Name from dirPartyTable
                where custTable.Party == dirPartyTable.RecId
            outer join Label from tmpEnumIdLabel
                where tmpEnumIdLabel.Value == bankChequeTable.ChequeStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankChequeTableVend</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankChequeTableVend()
    {
        BankDocumentTable bankDocumentTable;
        BankChequeTable bankChequeTable;
        VendTable vendTable;
        DirPartyTable dirPartyTable;

        TmpEnumIdLabel tmpEnumIdLabel;
        TmpEnumIdLabel::populate(enumNum(ChequeStatus), tmpEnumIdLabel);

        update_recordset tmpDocument
            setting RelatedPartyAccount = bankChequeTable.RecipientAccountNum,
                RelatedPartyType = DirPartyRoleType::Vendor,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankChequeTable.DataAreaId,
                Status = tmpEnumIdLabel.Label
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankChequeTable)
            join RecId, RecipientAccountNum, DataAreaId from bankChequeTable
                where bankChequeTable.RecId == bankDocumentTable.SourceRecId
                    && bankChequeTable.RecipientType == BankChequeRecipientType::Vend
            join RecId from vendTable
                where bankChequeTable.RecipientAccountNum == vendTable.AccountNum
            join RecId, Name from dirPartyTable
                where vendTable.Party == dirPartyTable.RecId
            outer join Label from tmpEnumIdLabel
                where tmpEnumIdLabel.Value == bankChequeTable.ChequeStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankDeposit</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankDeposit()
    {
        BankDocumentTable bankDocumentTable;
        BankDepositDocument bankDepositDocument;

        str status = "@SYS107952";

        //Not updating party name information for bank deposits because most deposits will have more than one customer
        update_recordset tmpDocument
            setting Status = status,
                RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyCompany = bankDepositDocument.DataAreaId
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankDepositDocument)
            join RecId, DataAreaId from bankDepositDocument
                where bankDepositDocument.RecId == bankDocumentTable.SourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankDepositCancel</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankDepositCancel()
    {
        BankDocumentTable bankDocumentTable;
        BankDeposit bankDeposit;
        CustTable custTable;
        DirPartyTable dirPartyTable;
        str status;

        update_recordset tmpDocument
            setting RelatedPartyAccount = bankDeposit.CustAccount,
                RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = bankDeposit.RefCompany
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankDeposit)
            join RecId, CustAccount, DataAreaId, RefCompany from bankDeposit
                where bankDeposit.RecId == bankDocumentTable.SourceRecId
            join RecId from custTable
                where bankDeposit.CustAccount == custTable.AccountNum
            join RecId, Name from dirPartyTable
                where custTable.Party == dirPartyTable.RecId;

        status = "@SYS107952";
        update_recordset tmpDocument
            setting Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankDeposit)
            join RecId, CustAccount, DataAreaId, RefCompany from bankDeposit
                where bankDeposit.RecId == bankDocumentTable.SourceRecId
                    && BankDeposit.Canceled == NoYes::No
                    && BankDeposit.CancelPending == NoYes::No;

        status = "@SYS114141";
        update_recordset tmpDocument
            setting Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankDeposit)
            join RecId, CustAccount, DataAreaId, RefCompany from bankDeposit
                where bankDeposit.RecId == bankDocumentTable.SourceRecId
                    && BankDeposit.CancelPending == NoYes::Yes;

        status = "@SYS1068";
        update_recordset tmpDocument
            setting Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankDeposit)
            join RecId, CustAccount, DataAreaId, RefCompany from bankDeposit
                where bankDeposit.RecId == bankDocumentTable.SourceRecId
                    && BankDeposit.Canceled == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForPaymentVend</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForPaymentVend()
    {
        BankDocumentTable bankDocumentTable;
        LedgerJournalTrans ledgerJournalTrans;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        VendTable vendTable;
        DirPartyTable dirPartyTable;

        TmpEnumIdLabel tmpEnumIdLabel;
        TmpEnumIdLabel::populate(enumNum(CustVendPaymStatus), tmpEnumIdLabel);

        FieldId vendorKeyFieldId = LedgerJournalTransLedgerDimensionNameHelper::findDimensionAttributeValueCombinationKeyColumnFieldId(
            DimensionHierarchyType::Vendor);

        update_recordset tmpDocument
            setting RelatedPartyAccount = vendTable.AccountNum,
                RelatedPartyType = DirPartyRoleType::Vendor,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = ledgerJournalTrans.Company,
                Status = tmpEnumIdLabel.Label
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(LedgerJournalTrans)
            join RecId, Company, PaymentStatus from ledgerJournalTrans
                where ledgerJournalTrans.RecId == bankDocumentTable.SourceRecId
                    && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == ledgerJournalTrans.LedgerDimension
            join RecId, AccountNum from vendTable
                where dimensionAttributeValueCombination.(vendorKeyFieldId) == vendTable.RecId
            join RecId, Name from dirPartyTable
                where vendTable.Party == dirPartyTable.RecId
            outer join Label from tmpEnumIdLabel
                where tmpEnumIdLabel.Value == ledgerJournalTrans.PaymentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForPaymentCust</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForPaymentCust()
    {
        BankDocumentTable bankDocumentTable;
        LedgerJournalTrans ledgerJournalTrans;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        CustTable custTable;
        DirPartyTable dirPartyTable;

        TmpEnumIdLabel tmpEnumIdLabel;
        TmpEnumIdLabel::populate(enumNum(CustVendPaymStatus), tmpEnumIdLabel);

        FieldId customerKeyFieldId = LedgerJournalTransLedgerDimensionNameHelper::findDimensionAttributeValueCombinationKeyColumnFieldId(
            DimensionHierarchyType::Customer);

        update_recordset tmpDocument
            setting RelatedPartyAccount = custTable.AccountNum,
                RelatedPartyType = DirPartyRoleType::Customer,
                RelatedPartyName = dirPartyTable.Name,
                RelatedPartyCompany = ledgerJournalTrans.Company,
                Status = tmpEnumIdLabel.Label
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(LedgerJournalTrans)
            join RecId, Company from ledgerJournalTrans
                where ledgerJournalTrans.RecId == bankDocumentTable.SourceRecId
                    && ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == ledgerJournalTrans.LedgerDimension
            join RecId, AccountNum from custTable
                where dimensionAttributeValueCombination.(customerKeyFieldId) == custTable.RecId
            join RecId, Name from dirPartyTable
                where custTable.Party == dirPartyTable.RecId
            outer join Label from tmpEnumIdLabel
                where tmpEnumIdLabel.Value == ledgerJournalTrans.PaymentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBridgedPayment</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBridgedPayment()
    {
        if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()))
        {
            BankBridgingTrans bankBridgingTrans;
            BankDocumentTable bankDocumentTable;
            LedgerJournalTrans ledgerJournalTransBridged;
            str status;

            status = "@CashManagement:BankBridgingStatusBridged";
            update_recordset tmpDocument
                setting Status = status
                join RecId from bankDocumentTable
                    where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                        && bankDocumentTable.SourceRelationType == tableNum(LedgerJournalTrans)
                join RecId from ledgerJournalTransBridged
                    where ledgerJournalTransBridged.RecId == bankDocumentTable.SourceRecId
                join RecId from bankBridgingTrans
                    where bankBridgingTrans.BridgedLedgerJournalTransRecId == ledgerJournalTransBridged.RecId
                        && bankBridgingTrans.BridgingStatus == BankBridgingStatus::Bridged;

            status = "@CashManagement:BankBridgingStatusCleared";
            update_recordset tmpDocument
                setting Status = status
                join RecId from bankDocumentTable
                    where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                        && bankDocumentTable.SourceRelationType == tableNum(LedgerJournalTrans)
                join RecId from ledgerJournalTransBridged
                    where ledgerJournalTransBridged.RecId == bankDocumentTable.SourceRecId
                join RecId from bankBridgingTrans
                    where bankBridgingTrans.BridgedLedgerJournalTransRecId == ledgerJournalTransBridged.RecId
                        && bankBridgingTrans.BridgingStatus == BankBridgingStatus::Cleared;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForSummarizedTrans</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForSummarizedTrans()
    {
        BankDocumentTable bankDocumentTable;
        BankTransSummarizationDocument bankTransSummarizationDocument;

        str status = "@SYS107952";

        update_recordset tmpDocument
            setting Status = status,
                RelatedPartyType = bankTransSummarizationDocument.RelatedPartyType
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankTransSummarizationDocument)
            join RecId, RelatedPartyType from bankTransSummarizationDocument
                where bankTransSummarizationDocument.RecId == bankDocumentTable.SourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpForBankStatement</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpForBankStatement()
    {
        BankDocumentTable bankDocumentTable;

        str status = enum2str(BankStatementLineStatus::Booked);

        update_recordset tmpDocument
            setting Status = status
            join RecId, SourceRecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankStmtISOReportEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentOpenTmpIsMatched</Name>
				<Source><![CDATA[
    private void updateDocumentOpenTmpIsMatched()
    {
        BankReconciliationMatchingItemView bankReconciliationMatchingItemView;

        if (isModernBankReconciliationFeatureEnabled)
        {
            // Get match rule name to show on matched transactions tab on worksheet
            update_recordset tmpDocument
                setting IsMatched = NoYes::Yes,
                    BankReconciliationMatchRuleId = bankReconciliationMatchingItemView.BankReconciliationMatchRuleId,
                    MatchingId = bankReconciliationMatchingItemView.MatchingId,
                    BankReconciliationMatchingType = bankReconciliationMatchingItemView.BankReconciliationMatchingType
                join BankReconciliationMatchRuleId, MatchingId, BankReconciliationMatchingType from bankReconciliationMatchingItemView
                    where bankReconciliationMatchingItemView.BankReconciliationHeader == reconciliation.RecId
                        && bankReconciliationMatchingItemView.BankDocumentTable == tmpDocument.BankDocumentTableView;

            // Need to get matchRule.RecId for reference purpose, in this case, user can jump to match rule setting form from worksheet directly
            BankReconciliationMatchRule matchRule;
            update_recordset tmpDocument
                setting BankReconciliationMatchRule = matchRule.RecId
                where tmpDocument.BankReconciliationMatchRuleId != ''
                join RecId from matchRule
                    where tmpDocument.BankReconciliationMatchRuleId == matchRule.RuleId;
        }
        else
        {
            update_recordset tmpDocument
                setting IsMatched = NoYes::Yes
                join RecId from bankReconciliationMatchingItemView
                    where bankReconciliationMatchingItemView.BankReconciliationHeader == reconciliation.RecId
                        && bankReconciliationMatchingItemView.BankDocumentTable == tmpDocument.BankDocumentTableView;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransDateForPDC</Name>
				<Source><![CDATA[
    private void updateTransDateForPDC()
    {
        BankDocumentTable bankDocumentTable;
        BankChequeTable bankChequeTable;
        CustVendPDCRegister custVendPDCRegister;

        update_recordset tmpDocument
            setting TransactionDate = custVendPDCRegister.MaturityDate
            join RecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.SourceRelationType == tableNum(BankChequeTable)
            join RecId from bankChequeTable
                where bankChequeTable.RecId == bankDocumentTable.SourceRecId
            join MaturityDate from custVendPDCRegister
                where custVendPDCRegister.LedgerJournalTrans == bankChequeTable.SourceRecId
                    && bankChequeTable.SourceTableId == tableNum(LedgerJournalTrans)
                    && custVendPDCRegister.MaturityDate != dateNull();

        if (BankRedesignGenerateVoucherFlight::instance().isEnabled())
        {
            delete_from tmpDocument
                where tmpDocument.DocumentType == BankDocumentBookType::Cheque
                    && tmpDocument.TransactionDate > reconciliation.CutOffDate;
        }
        else
        {
            delete_from tmpDocument
                where tmpDocument.TransactionDate > reconciliation.CutOffDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initStatementOpenTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes temporary data for bank statement from parameters.
    /// </summary>
    /// <param name="_reportEntry">
    /// Given <c>BankStmtISOReportEntry</c> buffer.
    /// </param>
    /// <param name="_statement">
    /// Given <c>BankStmtISOAccountStatement</c> buffer.
    /// </param>
    /// <param name="_partyIdentification">
    /// Given <c>BankStmtISOPartyIdentification</c> buffer.
    /// </param>
    /// <param name="_isMatched">
    /// Indicates whether the given bank statement line is matched.
    /// </param>
    /// <param name="_matchingType">
    /// Matching type.
    /// </param>
    protected void initStatementOpenTmp(
        BankStmtISOReportEntry _reportEntry,
        BankStmtISOAccountStatement _statement,
        BankStmtISOPartyIdentification _partyIdentification,
        NoYesId _isMatched,
        BankReconciliationMatchingType _matchingType)
    {
        boolean isMarkedInLoading;
        //matched premarked statement line
        isMarkedInLoading = this.matchMarkedStatement(_reportEntry, _isMatched);

        tmpStatement.clear();
        tmpStatement.BankStmtISOReportEntry = _reportEntry.RecId;

        if (_reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit)
        {
            tmpStatement.DebitAmount = _reportEntry.Amount;
        }
        else
        {
            tmpStatement.CreditAmount = _reportEntry.Amount;
        }

        tmpStatement.BankCurrencyAmount = _reportEntry.getBankCurrencyAmount();
        tmpStatement.BankStatementCounterCurrency = _reportEntry.BankStatementCounterCurrency;
        tmpStatement.BankStatementCounterCurrencyAmount = _reportEntry.BankStatementCounterCurrencyAmount;
        tmpStatement.BankStatementInstructedCurrency = _reportEntry.BankStatementInstructedCurrency;
        tmpStatement.BankStatementInstructedCurrencyAmt = _reportEntry.BankStatementInstructedCurrencyAmt;

        tmpStatement.ProprietaryBankTransactionCode = _reportEntry.ProprietaryBankTransactionCode;
        tmpStatement.BankTransType = _reportEntry.getTransactionType();
        tmpStatement.ReferenceNumber = _reportEntry.ReferenceNumber;
        tmpStatement.CreditorReferenceInformation = _reportEntry.CreditorReferenceInformation;
        tmpStatement.Identification = _statement.Identification;
        tmpStatement.TradingParty = _partyIdentification.Name;
        tmpStatement.EntryReference = _reportEntry.EntryReference;
        tmpStatement.AdditionalEntryInformation = _reportEntry.AdditionalEntryInformation;
        tmpStatement.AccountServicerReference = _reportEntry.AccountServicerReference;

        tmpStatement.BankDocumentNumber = _reportEntry.BankDocumentNumber;
        tmpStatement.BookingDate = _reportEntry.getBookingDate();

        tmpStatement.RelatedBankAccount = _reportEntry.RelatedBankAccount;
        tmpStatement.RelatedBankName = _reportEntry.RelatedBankName;

        tmpStatement.BankStatementLineStatus = _reportEntry.BankStatementLineStatus;
        tmpStatement.Reversal = _reportEntry.ReversalIndicator;
        tmpStatement.Reconciled = _reportEntry.Reconciled;
        tmpStatement.IsMatched = _isMatched || isMarkedInLoading;
 
        tmpStatement.IsNewBankDocument = _reportEntry.IsNewBankDocument();
        tmpStatement.BankStmtISOAccountStatement = _statement.RecId;

        if (FeatureStateProvider::isFeatureEnabled(BankReconWorksheetFilterAndSplitNewFeature::instance()))
        {
            tmpStatement.AccountingDate = _reportEntry.AccountingDate;
            tmpStatement.Posted = (_statement.Posted || _reportEntry.isPosted());
            if (tmpStatement.Posted)
            {
                tmpStatement.Voucher = _statement.Voucher ? _statement.Voucher : _reportEntry.Voucher;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDocumentOpenTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates temporary data for bank document.
    /// </summary>
    /// <param name="_documentView">
    ///     An instance of <c>BankDocumentTableView</c> view buffer.
    /// </param>
    /// <param name="_isMatched">
    ///     A boolean value that indicates whether the given bank document is matched.
    /// </param>
    public void createDocumentOpenTmp(
        BankDocumentTableView _documentView,
        NoYesId _isMatched)
    {
        if (this.shouldCreateDocumentOpenTmp(_documentView, _isMatched))
        {
            this.initDocumentOpenTmp(_documentView, _isMatched);
            if (tmpDocument.TransactionDate <= reconciliation.CutOffDate)
            {
                documentInsertList.add(tmpDocument);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateDocumentOpenTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether the temporary data for bank document should be created.
    /// </summary>
    /// <param name="_documentView">
    ///     An instance of <c>BankDocumentTableView</c> view buffer.
    /// </param>
    /// <param name="_isMatched">
    ///     A boolean value that indicates whether the given bank document is matched.
    /// </param>
    /// <returns>
    ///     true if the temporary data for bank document should be created; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCreateDocumentOpenTmp(
        BankDocumentTableView _documentView,
        NoYesId _isMatched)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createStatementOpenTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates temporary data for bank statement.
    /// </summary>
    /// <param name="_reportEntry">
    ///     An instance of <c>BankStmtISOReportEntry</c> table buffer.
    /// </param>
    /// <param name="_statement">
    ///     An instance of <c>BankStmtISOAccountStatement</c> table buffer.
    /// </param>
    /// <param name="_partyIdentification">
    ///     An instance of <c>BankStmtISOPartyIdentification</c> table buffer.
    /// </param>
    /// <param name="_isMatched">
    ///     A boolean value that indicates whether the given bank statement line is matched.
    /// </param>
    /// <param name="_matchingType">
    ///     The matching type of bank reconciliation enumeration.
    /// </param>
    public void createStatementOpenTmp(
        BankStmtISOReportEntry _reportEntry,
        BankStmtISOAccountStatement _statement,
        BankStmtISOPartyIdentification _partyIdentification,
        NoYesId _isMatched,
        BankReconciliationMatchingType _matchingType)
    {
        if (this.shouldCreateStatementOpenTmp(_reportEntry, _statement, _partyIdentification, _isMatched, _matchingType))
        {
            this.initStatementOpenTmp(_reportEntry, _statement, _partyIdentification, _isMatched, _matchingType);
            statementInsertList.add(tmpStatement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateStatementOpenTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether the temporary data for bank statement should be created.
    /// </summary>
    /// <param name="_reportEntry">
    ///     An instance of <c>BankStmtISOReportEntry</c> table buffer.
    /// </param>
    /// <param name="_statement">
    ///     An instance of <c>BankStmtISOAccountStatement</c> table buffer.
    /// </param>
    /// <param name="_partyIdentification">
    ///     An instance of <c>BankStmtISOPartyIdentification</c> table buffer.
    /// </param>
    /// <param name="_isMatched">
    ///     A boolean value that indicates whether the given bank statement line is matched.
    /// </param>
    /// <param name="_matchingType">
    ///     The matching type of bank reconciliation enumeration.
    /// </param>
    /// <returns>
    ///     true if the temporary data for bank statement line should be created; otherwise false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCreateStatementOpenTmp(
        BankStmtISOReportEntry _reportEntry,
        BankStmtISOAccountStatement _statement,
        BankStmtISOPartyIdentification _partyIdentification,
        NoYesId _isMatched,
        BankReconciliationMatchingType _matchingType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the temporary data for bank document.
    /// </summary>
    /// <returns>
    /// Temporary data for bank document.
    /// </returns>
    public BankReconciliationDocumentOpenTmp getDocumentData()
    {
        return tmpDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the temporary data for bank statement.
    /// </summary>
    /// <returns>
    /// Temporary data for bank statement.
    /// </returns>
    public BankReconciliationStatementOpenTmp getStatementData()
    {
        return tmpStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankReconciliationUtility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>BankReconciliationUtility</c> class.
    /// </summary>
    /// <returns>A new <c>BankReconciliationUtility</c> instance.</returns>
    [SysObsolete('Method createBankReconciliationUtility is not used anymore.', false, 26\07\2021)]
    protected BankReconciliationUtility createBankReconciliationUtility()
    {
        return BankReconciliationUtility::construct(this.parmBankReconciliationHeader());
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for bank statement and bank document.
    /// </summary>
    public void loadData()
    {
        NoYes performLoadWorksheetRowByRow = BankParameters::find().LoadReconciliationWorksheetExtensible;
        this.loadStatementData(performLoadWorksheetRowByRow);
        this.loadDocumentData(performLoadWorksheetRowByRow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocumentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for bank document.
    /// </summary>
    private void loadDocumentData(NoYes _performLoadWorksheetRowByRow)
    {
        if (!RemoveLoadReconciliationWorksheetExtensibleFlight::instance().isEnabled() && _performLoadWorksheetRowByRow)
        {
            BankReconciliationUtility utility = this.createBankReconciliationUtility();

            documentInsertList = new RecordInsertList(tableNum(BankReconciliationDocumentOpenTmp), true, true, true, true, true, tmpDocument);

            utility.visitedDocument += eventhandler(this.createDocumentOpenTmp);
            utility.tranverseDocument();

            documentInsertList.insertDatabase();
        }
        else
        {
            this.loadDocumentDataSetBased();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocumentDataSetBased</Name>
				<Source><![CDATA[
    private void loadDocumentDataSetBased()
    {
        if (reconciliation.IsReconciled())
        {
            this.loadDocumentDataReconciled();
            if (isModernBankReconciliationFeatureEnabled)
            {
                this.updateTransDateForGenerateVoucher();
            }
        }
        else
        {
            this.loadDocumentDataUnReconciled();
            this.loadDocumentDataReconciledAndCancelledButStillOpen();
            if (isModernBankReconciliationFeatureEnabled)
            {
                this.loadDocumentDataGenerateVoucher();
            }
        }

        this.updateDocumentOpenTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadStatementDataSetBased</Name>
				<Source><![CDATA[
    private void loadStatementDataSetBased()
    {
        if (reconciliation.IsReconciled())
        {
            this.loadStatementDataSetReconciled();
        }
        else
        {
            this.loadStatementDataSetUnReconciled();
        }

        this.updateStatementOpenTmpIsMatched();

        this.updateStatementVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocumentDataReconciled</Name>
				<Source><![CDATA[
    private void loadDocumentDataReconciled()
    {
        BankReconciliationHistoryDetails bankReconciliationHistoryDetails;
        BankDocumentTableViewResult bankDocumentTableViewResult;

        insert_recordset tmpDocument
            (BankDocumentTableView, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId, TransactionDate,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted)
            select BankDocumentTableRecId, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId, TransactionDate,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted
                from bankDocumentTableViewResult
                exists join bankReconciliationHistoryDetails
                    where bankDocumentTableViewResult.BankDocumentTableRecId == bankReconciliationHistoryDetails.BankDocumentTable
                        && bankReconciliationHistoryDetails.BankReconciliationHeader == reconciliation.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocumentDataUnReconciled</Name>
				<Source><![CDATA[
    public void loadDocumentDataUnReconciled()
    {
        BankDocumentTableViewResult bankDocumentTableViewResult;

        insert_recordset tmpDocument
            (BankDocumentTableView, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId, TransactionDate,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted)
            select BankDocumentTableRecId, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId, TransactionDate,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted
                from bankDocumentTableViewResult
                where bankDocumentTableViewResult.IsReconciled == NoYes::No
                    && bankDocumentTableViewResult.AccountId   == reconciliation.AccountId
                    && bankDocumentTableViewResult.DocumentDate <= reconciliation.CutoffDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocumentDataReconciledAndCancelledButStillOpen</Name>
				<Source><![CDATA[
    private void loadDocumentDataReconciledAndCancelledButStillOpen()
    {
        BankDocumentBankChequeTableView bankDocumentBankChequeTableView;
        BankAccountTrans bankAccountTrans;

        insert_recordset tmpDocument
            (BankDocumentTableView, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId, TransactionDate,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted)
            select RecId, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId, TransactionDate,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted
                from bankDocumentBankChequeTableView
                where bankDocumentBankChequeTableView.IsReconciled == NoYes::Yes
                    && bankDocumentBankChequeTableView.DocumentType == BankDocumentBookType::Cheque
                    && bankDocumentBankChequeTableView.AccountId   == reconciliation.AccountId
                    && bankDocumentBankChequeTableView.DocumentDate <= reconciliation.CutoffDate
                    && bankDocumentBankChequeTableView.Cancelled   == NoYes::Yes
                    && bankDocumentBankChequeTableView.SourceRelationType == tableNum(BankChequeTable)
                exists join bankAccountTrans
                    where bankAccountTrans.SourceTableId == bankDocumentBankChequeTableView.SourceRelationType
                        && bankAccountTrans.SourceRecId == bankDocumentBankChequeTableView.SourceRecId
                        && bankAccountTrans.Cancel == NoYes::Yes
                        && bankAccountTrans.TransDate > reconciliation.CutoffDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocumentDataGenerateVoucher</Name>
				<Source><![CDATA[
    private void loadDocumentDataGenerateVoucher()
    {
        BankDocumentStatementLineView bankDocumentStatementLineView;
        BankStmtISOReportEntry bankStmtISOReportEntry;

        insert_recordset tmpDocument
            (BankDocumentTableView, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted, TransactionDate)
            select RecId, BankCurrencyAmount, DebitAmount, CreditAmount, CorrectionBankCurrencyAmount, TransactionCurrency,
                TransactionCurrencyAmount, BankTransType, Description, Reference, PaymId, EndToEndId,
                DocumentNum, DocumentType, Cancelled, IsReconciled, Posted
                from BankDocumentStatementLineView
                where BankDocumentStatementLineView.IsReconciled == NoYes::Yes
                    && BankDocumentStatementLineView.DocumentType == BankDocumentBookType::BankStatement
                    && BankDocumentStatementLineView.AccountId == reconciliation.AccountId
                    && BankDocumentStatementLineView.SourceRelationType == tableNum(BankStmtISOReportEntry)
                join AccountingDate from bankStmtISOReportEntry
                    where bankStmtISOReportEntry.RecId == BankDocumentStatementLineView.SourceRecId
                        && bankStmtISOReportEntry.Reconciled == NoYes::No
                        && bankStmtISOReportEntry.AccountingDate <= reconciliation.CutoffDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadStatementData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for bank statement.
    /// </summary>
    private void loadStatementData(NoYes _performLoadWorksheetRowByRow)
    {
        if (!RemoveLoadReconciliationWorksheetExtensibleFlight::instance().isEnabled() && _performLoadWorksheetRowByRow)
        {
            BankReconciliationUtility utility = this.createBankReconciliationUtility();

            statementInsertList = new RecordInsertList(tableNum(BankReconciliationStatementOpenTmp), true, true, true, true, true, tmpStatement);

            utility.visitedStatement += eventhandler(this.createStatementOpenTmp);
            utility.tranverseStatement();

            statementInsertList.insertDatabase();
        }
        else
        {
            this.loadMatchingStatementDataSetBased();
            this.loadStatementDataSetBased();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadMatchingStatementDataSetBased</Name>
				<Source><![CDATA[
    private void loadMatchingStatementDataSetBased()
    {
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;
        BankReconciliationMatchingItemView matchingItemView;

        TransDateTime cutoffDateTime = reconciliation.getCutOffDateTime();

        // Init new transactions for legacy worksheet
        if (!reconciliation.IsReconciled && !isModernBankReconciliationFeatureEnabled)
        {
            while select RecId from reportEntry
                where reportEntry.IsNewBankDocument == NoYes::Yes
                    && reportEntry.BookingDateTime <= cutoffDateTime
                    && reportEntry.Reconciled == NoYes::No
                exists join statement
                    where (statement.Status == BankStatementStatus::Validated || statement.Status == BankStatementStatus::Matched)
                        && statement.BankAccountTable == reconciliation.AccountId
                        && statement.RecId == reportEntry.BankStmtISOAccountStatement
                notexists join matchingItemView
                    where matchingItemView.BankStmtISOReportEntry == reportEntry.RecId
                        && matchingItemView.BankReconciliationHeader == reconciliation.RecId
            {
                //We need to process the match line by line because the processor only allows a single statement line for new document matching.
                BankReconciliationMatchingMatchProcessor matchProcessor = BankReconciliationMatchingMatchProcessor::construct(reconciliation);
                matchProcessor.addEntry(BankReconciliationMatchingEntry::construct(BankReconciliationMatchingEntryType::BankStatement, reportEntry.RecId));
                matchProcessor.processMatch();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchStatementWithPostedPayment</Name>
				<Source><![CDATA[
    private void matchStatementWithPostedPayment(BankStmtISOReportEntry _statementLine, RefRecId _ledgerJournalTrans, BankReconciliationHeader _reconciliation)
    {
        BankAccountTrans bankAccountTrans = BankAccountTrans::findBySource(tableNum(LedgerJournalTrans), _ledgerJournalTrans);
        BankDocumentTable bankDocumentTable = BankDocumentTable::findBySource(bankAccountTrans.TableId, bankAccountTrans.RecId);

        if (bankDocumentTable
            && bankAccountTrans.TransDate <= reconciliation.CutOffDate
            && !BankReconciliationMatchingItem::findValidByDocumentRecId(bankDocumentTable.RecId)
            && bankAccountTrans.AmountCur == _statementLine.getAmountWithSign())
        {
            BankReconciliationMatchingMatchProcessor matchingMatchProcessor = BankReconciliationMatchingMatchProcessor::construct(_reconciliation);

            BankReconciliationMatchingEntry matchingEntry = BankReconciliationMatchingEntry::construct(
                BankReconciliationMatchingEntryType::BankStatement,
                _statementLine.RecId);
            matchingMatchProcessor.addEntry(matchingEntry);

            matchingEntry = BankReconciliationMatchingEntry::construct(
                BankReconciliationMatchingEntryType::BankDocument,
                bankDocumentTable.RecId);
            matchingMatchProcessor.addEntry(matchingEntry);

            matchingMatchProcessor.processMatch();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchMarkedStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Matches a statement line automatically if it is marked as "New".
    /// </summary>
    /// <param name="_reportEntry">
    /// Given <c>BankStmtISOReportEntry</c> buffer.
    /// </param>
    /// <param name="_isMatched">
    /// Indicates whether the given statement line is matched.
    /// </param>
    /// <returns>
    /// True if the given statement line is matched; otherwise, false.
    /// </returns>
    protected boolean matchMarkedStatement(
        BankStmtISOReportEntry  _reportEntry,
        NoYesId                 _isMatched)
    {
        BankReconciliationMatchingMatchProcessor matchProcessor;
        boolean isMarkUpdated;

        // Init new transactions for legacy worksheet
        if (!isModernBankReconciliationFeatureEnabled
            && !reconciliation.IsReconciled
            && _reportEntry.IsNewBankDocument()
            && !_isMatched)
        {
            matchProcessor = BankReconciliationMatchingMatchProcessor::construct(reconciliation);
            matchProcessor.addEntry(BankReconciliationMatchingEntry::construct(BankReconciliationMatchingEntryType::BankStatement, _reportEntry.RecId));
            matchProcessor.processMatch();

            isMarkUpdated = true;
        }

        return isMarkUpdated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankReconciliationHeader</Name>
				<Source><![CDATA[
    public BankReconciliationHeader parmBankReconciliationHeader(BankReconciliationHeader _reconciliation = reconciliation)
    {
        reconciliation = _reconciliation;

        return reconciliation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of <c>BankReconciliationDataInitializer</c> for a reconciliation journal.
    /// </summary>
    /// <param name="_reconciliation">
    /// Given <c>BankReconciliationHeader</c> buffer.
    /// </param>
    /// <returns>
    /// An instance of <c>BankReconciliationDataInitializer</c>.
    /// </returns>
    public static BankReconciliationDataInitializer construct(BankReconciliationHeader _reconciliation)
    {
        BankReconciliationDataInitializer    dataInit = new BankReconciliationDataInitializer();

        dataInit.parmBankReconciliationHeader(_reconciliation);

        return dataInit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadStatementDataSetReconciled</Name>
				<Source><![CDATA[
    private void loadStatementDataSetReconciled()
    {
        BankReconciliationStatementOpenView statementView;
        BankReconciliationHistoryDetails historyDetails;

        insert_recordset tmpStatement(
            BankStmtISOReportEntry, DebitAmount, CreditAmount, BankCurrencyAmount, BankStatementCounterCurrency,
            BankStatementCounterCurrencyAmount, BankStatementInstructedCurrency, BankStatementInstructedCurrencyAmt, ProprietaryBankTransactionCode, BankTransType,
            ReferenceNumber, CreditorReferenceInformation, Identification, TradingParty, EntryReference,
            AdditionalEntryInformation, AccountServicerReference, BankDocumentNumber, BookingDate, RelatedBankAccount,
            RelatedBankName, BankStatementLineStatus, Reversal, Reconciled, IsNewBankDocument, BankStmtISOAccountStatement, AccountingDate)
        select BankISOReportEntryRecId, DebitAmount, CreditAmount, BankCurrencyAmount, BankStatementCounterCurrency,
            BankStatementCounterCurrencyAmount, BankStatementInstructedCurrency, BankStatementInstructedCurrencyAmt, ProprietaryBankTransactionCode, BankTransType,
            ReferenceNumber, CreditorReferenceInformation, Identification, Name, EntryReference,
            AdditionalEntryInformation, AccountServicerReference, BankDocumentNumber, BookingDate, RelatedBankAccount,
            RelatedBankName, BankStatementLineStatus, ReversalIndicator, Reconciled, IsNewBankDocument, BankISOAccountStatementRecId, AccountingDate
        from statementView
            exists join historyDetails
                where statementView.BankISOReportEntryRecId == historyDetails.BankStmtISOReportEntry
                    && historyDetails.BankReconciliationHeader == reconciliation.RecId;

        update_recordset tmpStatement
            setting IsMatched = NoYes::No;
        this.updateStatementOpenTmpBookingDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadStatementDataSetUnReconciled</Name>
				<Source><![CDATA[
    private void loadStatementDataSetUnReconciled()
    {
        BankReconciliationStatementOpenView statementView;
        TransDateTime cutOffDateTime = reconciliation.getCutOffDateTime();

        insert_recordset tmpStatement(
            BankStmtISOReportEntry, DebitAmount, CreditAmount, BankCurrencyAmount, BankStatementCounterCurrency,
            BankStatementCounterCurrencyAmount, BankStatementInstructedCurrency, BankStatementInstructedCurrencyAmt, ProprietaryBankTransactionCode,
            BankTransType, ReferenceNumber, CreditorReferenceInformation, Identification, TradingParty, EntryReference,
            AdditionalEntryInformation, AccountServicerReference, BankDocumentNumber, BookingDate, RelatedBankAccount,
            RelatedBankName, BankStatementLineStatus, Reversal, Reconciled, IsNewBankDocument, BankStmtISOAccountStatement, AccountingDate)
        select BankISOReportEntryRecId, DebitAmount, CreditAmount, BankCurrencyAmount, BankStatementCounterCurrency,
            BankStatementCounterCurrencyAmount, BankStatementInstructedCurrency, BankStatementInstructedCurrencyAmt, ProprietaryBankTransactionCode,
            BankTransType, ReferenceNumber, CreditorReferenceInformation, Identification, Name, EntryReference,
            AdditionalEntryInformation, AccountServicerReference, BankDocumentNumber, BookingDate, RelatedBankAccount,
            RelatedBankName, BankStatementLineStatus, ReversalIndicator, Reconciled, IsNewBankDocument, BankISOAccountStatementRecId, AccountingDate
        from statementView
            where statementView.Status != BankStatementStatus::Open
                && statementView.Reconciled == NoYes::No
                && statementView.BookingDateTime <= cutOffDateTime
                && statementView.BankAccountTable == reconciliation.AccountId;

        update_recordset tmpStatement
            setting IsMatched = NoYes::No;
        this.updateStatementOpenTmpBookingDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatementOpenTmpBookingDate</Name>
				<Source><![CDATA[
    private void updateStatementOpenTmpBookingDate()
    {
        BankStmtISOReportEntry reportEntry;
        BankReconciliationBookingDateUpdateTmp bookingDateUpdate;

        RecordInsertList insertList = new RecordInsertList(tableNum(BankReconciliationBookingDateUpdateTmp), true, true, true, true, true, bookingDateUpdate);

        while select BookingDateTime from reportEntry
            join BookingDate from tmpStatement
               where reportEntry.RecId == tmpStatement.BankStmtISOReportEntry
        {
            date utcBookingDate = tmpStatement.BookingDate;
            date companyTimezoneBookingDate = reportEntry.getBookingDate();

            if (utcBookingDate != companyTimezoneBookingDate)
            {
                bookingDateUpdate.clear();
                bookingDateUpdate.BankStmtISOReportEntry = reportEntry.RecId;
                bookingDateUpdate.BookingDate = companyTimezoneBookingDate;

                insertList.add(bookingDateUpdate);
            }
        }

        insertList.insertDatabase();

        update_recordset tmpStatement
            setting BookingDate = bookingDateUpdate.BookingDate
            join BookingDate from bookingDateUpdate
                where tmpStatement.BankStmtISOReportEntry == bookingDateUpdate.BankStmtISOReportEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatementOpenTmpIsMatched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the matching status for statements in reference to the current reconciliation worksheet.
    /// </summary>
    /// <remarks>
    /// The matching status of a statement depends on the existence of a <c>BankReconciliationMatchingItemView</c>
    /// record in the context of the current reconciliation header. This is true for both reconciled and unreconciled worksheets.
    /// </remarks>
    private void updateStatementOpenTmpIsMatched()
    {
        BankReconciliationMatchingItemView bankReconciliationMatchingItemView;

        if (FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
        {
            // Get match rule name to show on matched transactions tab on worksheet
            update_recordset tmpStatement
                setting IsMatched = NoYes::Yes,
                    BankReconciliationMatchRuleId = bankReconciliationMatchingItemView.BankReconciliationMatchRuleId,
                    MatchingId = bankReconciliationMatchingItemView.MatchingId,
                    BankReconciliationMatchingType = bankReconciliationMatchingItemView.BankReconciliationMatchingType
                join BankReconciliationMatchRuleId, MatchingId, BankReconciliationMatchingType from bankReconciliationMatchingItemView
                    where bankReconciliationMatchingItemView.BankReconciliationHeader == reconciliation.RecId
                        && bankReconciliationMatchingItemView.BankStmtISOReportEntry == tmpStatement.BankStmtISOReportEntry;

            // Need to get matchRule.RecId for reference purpose, in this case, user can jump to match rule setting form from worksheet directly
            BankReconciliationMatchRule matchRule;
            update_recordset tmpStatement
                setting BankReconciliationMatchRule = matchRule.RecId
                where tmpStatement.BankReconciliationMatchRuleId != ''
                join RecId from matchRule
                    where tmpStatement.BankReconciliationMatchRuleId == matchRule.RuleId;
        }
        else
        {
            update_recordset tmpStatement
                setting IsMatched = NoYes::Yes
                exists join RecId from bankReconciliationMatchingItemView
                    where bankReconciliationMatchingItemView.BankReconciliationHeader == reconciliation.RecId
                        && bankReconciliationMatchingItemView.BankStmtISOReportEntry == tmpStatement.BankStmtISOReportEntry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatementVoucher</Name>
				<Source><![CDATA[
    private void updateStatementVoucher()
    {
        BankReconciliationStatementOpenView statementView;

        update_recordset tmpStatement
            setting Voucher = statementView.HeaderVoucher,
                Posted = NoYes::Yes
            join HeaderVoucher from statementView
                where statementView.BankISOReportEntryRecId == tmpStatement.BankStmtISOReportEntry
                    && statementView.HeaderVoucher != '';

        update_recordset tmpStatement
            setting Voucher = statementView.LineVoucher,
                Posted = NoYes::Yes
            join LineVoucher from statementView
                where statementView.BankISOReportEntryRecId == tmpStatement.BankStmtISOReportEntry
                    && statementView.LineVoucher != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransDateForGenerateVoucher</Name>
				<Source><![CDATA[
    private void updateTransDateForGenerateVoucher()
    {
        BankDocumentTable bankDocumentTable;
        BankStmtISOReportEntry bankStmtISOReportEntry;

        update_recordset tmpDocument
            setting TransactionDate = bankStmtISOReportEntry.AccountingDate
            join RecId from bankDocumentTable
                where bankDocumentTable.RecId == tmpDocument.BankDocumentTableView
                    && bankDocumentTable.BankDocumentBookType == BankDocumentBookType::BankStatement
                    && bankDocumentTable.SourceRelationType == tableNum(BankStmtISOReportEntry)
            join AccountingDate from bankStmtISOReportEntry
                where bankStmtISOReportEntry.RecId == bankDocumentTable.SourceRecId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>