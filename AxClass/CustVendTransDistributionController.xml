<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendTransDistributionController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    This class provides support for generating distributions by using the original distributions that
///    are posted for a <c>CustVendTrans</c> record.
/// </summary>
class CustVendTransDistributionController
{
    CustVendTrans currentTransaction; // The transaction from which to discover journal entries.
    List currentLedgerPostingTypes;
    List currentDistributionFactors;
    LedgerDimensionAccount currentDefaultLedgerDimension;
    boolean currentForceSingleDistribution;
    Ledger currentLedger;
    // <GEERU>
    boolean usePreciseComparison;
    LedgerPostingType alternativeBalancePostingType;
    // </GEERU>
    boolean useGeneralLedgerDistribution;
    boolean skipUseLedgerVoucherChanged;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmSkipUseLedgerVoucherChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to indicate if the From or the To voucher and transaction date should be used to generate account and dimension factors.
    /// </summary>
    /// <param name="_skipUseLedgerVoucherChanged">
    /// True indicates that the From voucher voucher and transaction date will be used; otherwise false.
    /// </param>
    /// <returns>
    /// True indicates that the From voucher voucher and transaction date will be used; otherwise false.
    /// </returns>
    public boolean parmSkipUseLedgerVoucherChanged(boolean _skipUseLedgerVoucherChanged = skipUseLedgerVoucherChanged)
    {
        skipUseLedgerVoucherChanged = _skipUseLedgerVoucherChanged;

        return skipUseLedgerVoucherChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionDifferencesExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this instance has the same distribution factors as another instance.
    /// </summary>
    /// <param name="_compareToController">
    ///    The <c>CustVendTransDistributionContoller</c> object to which to compare.
    /// </param>
    /// <returns>
    ///    true if the distribution factors of the current instance and the object that is specified by the
    ///    <paramref name="_compareToController" /> parameter are different; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Differences do not exist ONLY if both controllers contain only one distribution and reference the
    ///    same LedgerDimensionAccount. If either controller contains more than one distribution factor, the
    ///    assumption is made that differences do exist.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    Thrown if the supplied <paramref name="_compareToController" /> is null.
    /// </exception>
    public boolean distributionDifferencesExist(CustVendTransDistributionController _compareToController)
    {
        boolean differencesExist;

        if (_compareToController == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        List currentDistributions = this.parmCurrentDistributionFactors();
        List compareToDistributions = _compareToController.parmCurrentDistributionFactors();

        if (currentDistributions != null && compareToDistributions != null &&
            currentDistributions.elements() == 1 && compareToDistributions.elements() == 1)
        {
            // verify whether the single distribution from each controller references the same LedgerDimensionAccount
            ListEnumerator currentDistributionEnumerator = currentDistributions.getEnumerator();
            currentDistributionEnumerator.moveNext();
            CustVendTransDistribution currentDistribution = currentDistributionEnumerator.current();

            ListEnumerator compareToDistributionEnumerator = compareToDistributions.getEnumerator();
            compareToDistributionEnumerator.moveNext();
            CustVendTransDistribution compareToDistribution = compareToDistributionEnumerator.current();

            differencesExist = !LedgerDimensionFacade::areEqual(this.applyFixedDimensions(currentDistribution.ledgerDimension()),
                this.applyFixedDimensions(compareToDistribution.ledgerDimension()));
        }
        else
        {
            // <GEERU>
            if (usePreciseComparison)
            {
                differencesExist = this.preciseCompareFactors(currentDistributions, compareToDistributions);
            }
            // <GEERU>
            else if (currentDistributions != null && compareToDistributions != null)
            {
                differencesExist = this.distributionLedgerDimensionDiffExist(currentDistributions, compareToDistributions);
            }
            else
            {
                differencesExist = true;
            }
        }

        return differencesExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyFixedDimensions</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount applyFixedDimensions(LedgerDimensionAccount _originalDimension)
    {
        LedgerDimensionAccount updatedDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(_originalDimension);

        if (updatedDimension != _originalDimension)
        {
            updatedDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(updatedDimension);
        }
    
        return updatedDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributionFactors</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Generates the distribution factors.
    /// </summary>
    /// <param name="_postedDistributionData">
    ///  A <c>List</c> that contains the collection of <c>CustVendTransDistribution</c> objects that
    ///  represent the distribution factors.
    /// </param>
    /// <param name="_postedDistributionsTotal">
    ///  The transaction amount total that will be allocated.
    /// </param>
    protected void generateDistributionFactors(List _postedDistributionData, Money _postedDistributionsTotal)
    {
        Money factor;

        List distributionFactors = new List(Types::Class);

        if (_postedDistributionData != null)
        {
            // calculate the distribution factors based on the total
            ListEnumerator postedDistributionDataEnumerator = _postedDistributionData.getEnumerator();
            while (postedDistributionDataEnumerator.moveNext())
            {
                CustVendTransDistribution postedDistribution = postedDistributionDataEnumerator.current();

                if (_postedDistributionsTotal != 0)
                {
                    factor = postedDistribution.accountingAmount() / _postedDistributionsTotal;     // factor = posted distribution amount / total
                }
                else
                {
                    factor = 0;
                }

                CustVendTransDistribution distributionFactor = new CustVendTransDistribution(
                    postedDistribution.ledgerDimension(),
                    factor);

                distributionFactor.setAccountingDistributions(postedDistribution.getAccountingDistributions());

                distributionFactors.addEnd(distributionFactor);
            }
        }

        this.parmCurrentDistributionFactors(distributionFactors);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes related currency amounts based on the distributions that were originally posted for a
    /// <c>CustVendTrans</c> record that are of a specific ledger posting type.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> record that is associated with the amounts to distribute.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The posting type of the original distributions to consider.
    /// </param>
    /// <param name="_transactionAmountToDistribute">
    /// The amount to distribute in the transaction currency of the <c>CustVendTrans</c> record.
    /// </param>
    /// <param name="_accountingAmountToDistribute">
    /// The amount to distribute in the accounting currency.
    /// </param>
    /// <param name="_reportingAmountToDistribute">
    /// The amount to distribute in the reporting currency.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    /// The ledger dimension account to distribute the amounts to when the original distributions cannot be
    /// identified.
    /// </param>
    /// <param name="_forceSingleDistribution">
    /// A Boolean value that indicates whether to force the process to only generate a single distribution;
    /// optional.
    /// </param>
    /// <param name="_mergeDefaultWithOriginalDimension">
    /// A Boolean value that indicates whether to merge the default ledger dimension and original distribution dimensions;
    /// optional.
    /// </param>
    /// <returns>
    /// A list that contains the collection of <c>CustVendTransDistribution</c> instances that were created.
    /// </returns>
    public List generateDistributions(
        CustVendTrans _custVendTrans,
        LedgerPostingType _ledgerPostingType,
        Money _transactionAmountToDistribute,
        Money _accountingAmountToDistribute,
        Money _reportingAmountToDistribute,
        LedgerDimensionAccount _defaultLedgerDimension,
        boolean _forceSingleDistribution = false,
        boolean _mergeDefaultWithOriginalDimension = false)
    {
        List ledgerPostingTypes = new List(Types::Enum);

        ledgerPostingTypes.addEnd(_ledgerPostingType);

        return this.generateDistributionsForPostingTypes(
            _custVendTrans,
            ledgerPostingTypes,
            _transactionAmountToDistribute,
            _accountingAmountToDistribute,
            _reportingAmountToDistribute,
            _defaultLedgerDimension,
            _forceSingleDistribution,
            _mergeDefaultWithOriginalDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributionsForPostingTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Generates distributions.
    /// </summary>
    /// <param name="_custVendTrans">
    ///  The customer or vendor transaction that is used to find the distribution factors.
    /// </param>
    /// <param name="_ledgerPostingTypes">
    ///  A <c>List</c> that contains the collection of <c>LedgerPostingType</c> enumerations that
    ///  that are used to find the distribution factors.
    /// </param>
    /// <param name="_transactionAmountToDistribute">
    ///  The transaction amount to distribute.
    /// </param>
    /// <param name="_accountingAmountToDistribute">
    ///  The accounting currency amount to distribute.
    /// </param>
    /// <param name="_reportingAmountToDistribute">
    ///  The reporting currency amount to distribute.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    ///  The default ledger dimension.
    /// </param>
    /// <param name="_forceSingleDistribution">
    ///  True when a single distribution should be created with the default ledger dimension; optional.
    /// </param>
    /// <param name="_mergeDefaultWithOriginalDimension">
    ///  True when the default ledger dimension should be merged with the ledger dimensions of the original document; optional.
    /// </param>
    /// <returns>
    /// A list that contains the collection of <c>CustVendTransDistribution</c> instances that were created.
    /// </returns>
    public List generateDistributionsForPostingTypes(
        CustVendTrans _custVendTrans,
        List _ledgerPostingTypes,
        Money _transactionAmountToDistribute,
        Money _accountingAmountToDistribute,
        Money _reportingAmountToDistribute,
        LedgerDimensionAccount _defaultLedgerDimension,
        boolean _forceSingleDistribution = false,
        boolean _mergeDefaultWithOriginalDimension = false)
    {
        List distributionFactors;
        List distributions;

        if (_transactionAmountToDistribute != 0 || _accountingAmountToDistribute != 0 || _reportingAmountToDistribute != 0)
        {
            // get the distribution factors for the current request
            distributionFactors = this.getDistributionFactorsForPostingTypes(
                _custVendTrans,
                _ledgerPostingTypes,
                _defaultLedgerDimension,
                _forceSingleDistribution,
                _mergeDefaultWithOriginalDimension);

            Debug::assert(currentTransaction == _custVendTrans);
            Debug::assert(currentLedgerPostingTypes.equalTo(_ledgerPostingTypes));
            Debug::assert(currentLedger.RecId != 0);
            Debug::assert(distributionFactors != null);

            if (distributionFactors.elements() > 1)
            {
                distributions = this.generateDistributionsFromFactors(
                    distributionFactors,
                    _custVendTrans.CurrencyCode,
                    _transactionAmountToDistribute,
                    currentLedger.AccountingCurrency,
                    _accountingAmountToDistribute,
                    currentLedger.ReportingCurrency,
                    _reportingAmountToDistribute);
            }
            else
            {
                // use less expensive process if we know there is only a single distribution to be created
                distributions = this.generateSingleDistribution(
                    distributionFactors,
                    _transactionAmountToDistribute,
                    _accountingAmountToDistribute,
                    _reportingAmountToDistribute);
            }
        }
        else
        {
            // instantiate the return value even if there were distributions created
            distributions = new List(Types::Class);
        }

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributionsFromFactors</Name>
				<Source><![CDATA[
    protected List generateDistributionsFromFactors(
        List _distributionFactors,
        CurrencyCode _transactionCurrency,
        Money _transactionAmountToDistribute,
        CurrencyCode _accountingCurrency,
        Money _accountingAmountToDistribute,
        CurrencyCode _reportingCurrency,
        Money _reportingAmountToDistribute)
    {
        if (_distributionFactors == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // instantiate the return value even if no distributions are created
        List distributions = new List(Types::Class);

        // calculate the portion of the supplied amount to be distributed to each LedgerDimension
        int distributionsProcessed = 0;
        Money remainingTransactionAmount = _transactionAmountToDistribute;
        Money remainingAccountingAmount = _accountingAmountToDistribute;
        Money remainingReportingAmount = _reportingAmountToDistribute;
        int distributionCount = _distributionFactors.elements();

        ListEnumerator distributionFactorsEnumerator = _distributionFactors.getEnumerator();

        Set accountingDistributionSet = new Set(Types::String);

        if (GroupSourceDocumentDistributionWithAccoutingDistributionFlight::instance().isEnabled())
        {
            while (distributionFactorsEnumerator.moveNext())
            {
                CustVendTransDistribution distributionFactor = distributionFactorsEnumerator.current();

                if (distributionFactor.getAccountingDistributions() != '')
                {
                    accountingDistributionSet.add(distributionFactor.getAccountingDistributions());
                }
            }

            distributionFactorsEnumerator.reset();
        }

        if (GroupSourceDocumentDistributionWithAccoutingDistributionFlight::instance().isEnabled() 
            && !CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled() 
            && accountingDistributionSet.elements() > 0)
        {
            int amountSignTran = this.getAmountSign(_transactionAmountToDistribute);
            int amountSignMST = this.getAmountSign(_accountingAmountToDistribute);
            int amountSignReporting = this.getAmountSign(_reportingAmountToDistribute);

            Map accountingDistributionAmountMap = new Map(Types::String, Types::Container);

            Money absRemainingTransactionAmount = abs(_transactionAmountToDistribute);
            Money absRemainingAccountingAmount = abs(_accountingAmountToDistribute);
            Money absRemainingReportingAmount = abs(_reportingAmountToDistribute);

            while (distributionFactorsEnumerator.moveNext())
            {
                CustVendTransDistribution distributionFactor = distributionFactorsEnumerator.current();
                str accountingDistributions = distributionFactor.getAccountingDistributions();

                if (!accountingDistributionAmountMap.exists(accountingDistributions))
                {
                    Money currentTransactionAmount;
                    Money currentAccountingAmount;
                    Money currentReportingAmount;

                    if (accountingDistributionSet.elements() == 1)
                    {
                        currentTransactionAmount = abs(absRemainingTransactionAmount);
                        currentAccountingAmount = abs(absRemainingAccountingAmount);
                        currentReportingAmount = abs(absRemainingReportingAmount);
                    }
                    else
                    {
                        real currentFactor = distributionFactor.transactionAmount();

                        currentTransactionAmount = abs(CurrencyExchange::round(
                            currentFactor * _transactionAmountToDistribute,
                            _transactionCurrency));
                        currentAccountingAmount = abs(CurrencyExchange::round(
                            currentFactor * _accountingAmountToDistribute,
                            _accountingCurrency));
                        currentReportingAmount = abs(CurrencyExchange::round(
                            currentFactor * _reportingAmountToDistribute,
                            _reportingCurrency));
                    }

                    accountingDistributionAmountMap.insert(accountingDistributions,
                        [currentTransactionAmount, currentAccountingAmount, currentReportingAmount]);

                    accountingDistributionSet.remove(accountingDistributions);

                    absRemainingTransactionAmount -= currentTransactionAmount;
                    absRemainingAccountingAmount -= currentAccountingAmount;
                    absRemainingReportingAmount -= currentReportingAmount;
                }
            }

            distributionFactorsEnumerator.reset();

            Map distributionMap = new Map(Types::Int64, Types::Class);

            while (distributionFactorsEnumerator.moveNext())
            {
                CustVendTransDistribution distributionFactor = distributionFactorsEnumerator.current();
                str accountingDistributions = distributionFactor.getAccountingDistributions();

                Money currentTransactionAmount;
                Money currentAccountingAmount;
                Money currentReportingAmount;

                [currentTransactionAmount, currentAccountingAmount, currentReportingAmount] = accountingDistributionAmountMap.lookup(accountingDistributions);

                int factor = this.getAmountSign(distributionFactor.transactionAmount());

                currentTransactionAmount = currentTransactionAmount * factor * amountSignTran;
                currentAccountingAmount = currentAccountingAmount * factor * amountSignMST;
                currentReportingAmount = currentReportingAmount * factor * amountSignReporting;

                this.addToDistributions(currentTransactionAmount, currentAccountingAmount, currentReportingAmount, distributionFactor, distributions);
            }
        }
        else
        {
            while (distributionFactorsEnumerator.moveNext())
            {
                CustVendTransDistribution distributionFactor = distributionFactorsEnumerator.current();

                distributionsProcessed ++;

                Money currentTransactionAmount;
                Money currentAccountingAmount;
                Money currentReportingAmount;

                // if this is the last distribution, allocate the remaining
                if (distributionsProcessed == distributionCount)
                {
                    currentTransactionAmount = remainingTransactionAmount;
                    currentAccountingAmount = remainingAccountingAmount;
                    currentReportingAmount = remainingReportingAmount;
                }
                else
                {
                    // calculate amount to distribute based on the current factor rounded according to currency
                    real currentFactor = distributionFactor.transactionAmount();

                    currentTransactionAmount = CurrencyExchange::round(
                    currentFactor * _transactionAmountToDistribute,
                    _transactionCurrency);
                    currentAccountingAmount = CurrencyExchange::round(
                    currentFactor * _accountingAmountToDistribute,
                    _accountingCurrency);
                    currentReportingAmount = CurrencyExchange::round(
                    currentFactor * _reportingAmountToDistribute,
                    _reportingCurrency);
                }

                remainingTransactionAmount -= currentTransactionAmount;
                remainingAccountingAmount -= currentAccountingAmount;
                remainingReportingAmount -= currentReportingAmount;

                this.addToDistributions(currentTransactionAmount, currentAccountingAmount, currentReportingAmount, distributionFactor, distributions);
            }
        }

        // amounts should never be overallocated or underallocated
        Debug::assert(remainingTransactionAmount == 0 && remainingAccountingAmount == 0 && remainingReportingAmount ==0);

        // all distributions should have been processed
        Debug::assert(distributionsProcessed == distributionCount);

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateSingleDistribution</Name>
				<Source><![CDATA[
    protected List generateSingleDistribution(
        List _distributionFactors,
        Money _transactionAmountToDistribute,
        Money _accountingAmountToDistribute,
        Money _reportingAmountToDistribute)
    {
        CustVendTransDistribution distribution;
        CustVendTransDistribution distributionFactor;

        Debug::assert(_distributionFactors != null);
        Debug::assert(_distributionFactors.elements() <= 1);    // should only get here if there is only 1 posted distribution in the collection, though it may be empty

        List distributions = new List(Types::Class);

        // use the LedgerDimensionAccount value from the first element in the collection, if it exists
        ListEnumerator distributionFactorsEnumerator = _distributionFactors.getEnumerator();
        if (distributionFactorsEnumerator.moveNext())
        {
            distributionFactor = distributionFactorsEnumerator.current();

            // <GEERU>
            if (this.useExtensibleFactors())
            {
                distribution = distributionFactor.clone(
                    _transactionAmountToDistribute,
                    _accountingAmountToDistribute,
                    _reportingAmountToDistribute);
            }
            else
            {
            // </GEERU>
                distribution = new CustVendTransDistribution(
                    distributionFactor.ledgerDimension(),
                    _transactionAmountToDistribute,
                    _accountingAmountToDistribute,
                    _reportingAmountToDistribute);
            // <GEERU>
            }
            // </GEERU>
            distributions.addEnd(distribution);
        }

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributionFactorsForPostingTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets distribution factors.
    /// </summary>
    /// <param name="_custVendTrans">
    ///  The customer or vendor transaction that is used to find the distribution factors.
    /// </param>
    /// <param name="_ledgerPostingTypes">
    ///  The posting types that are used to find the distribution factors.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    ///  The default ledger dimension.
    /// </param>
    /// <param name="_forceSingleDistribution">
    ///  True when a single distribution should be created with the default ledger dimension.
    /// </param>
    /// <param name="_mergeDefaultWithOriginalDimension">
    ///  True when the default ledger dimension should be merged with the ledger dimensions of the original document.
    /// </param>
    /// <returns>
    ///  A list of distribution factors.
    /// </returns>
    public List getDistributionFactorsForPostingTypes(
            CustVendTrans _custVendTrans,
            List _ledgerPostingTypes,
            LedgerDimensionAccount _defaultLedgerDimension,
            boolean _forceSingleDistribution,
            boolean _mergeDefaultWithOriginalDimension = false)
    {
        List postedDistributionData;
        Money postedDistributionsTotal = 0;
        List distributionFactors;

        if (this.needToAcquireFactorsForPostingTypes(_custVendTrans, _ledgerPostingTypes, _defaultLedgerDimension, _forceSingleDistribution))
        {
            // reset the class state to be associated with the transaction/etc. of the current request
            currentTransaction = _custVendTrans;
            currentLedgerPostingTypes =  _ledgerPostingTypes;
            currentDefaultLedgerDimension = _defaultLedgerDimension;
            currentForceSingleDistribution = _forceSingleDistribution;
            currentLedger = Ledger::findByLegalEntity(CompanyInfo::current(_custVendTrans.company()));

            distributionFactors = new List(Types::Class);

            // populate the posted distributions collection with the associated source document data, if it is needed and if it exists
            if (_forceSingleDistribution || !CustVendTransDistributionController::custVendTransHasSourceDocumentData(_custVendTrans))
            {
                if (!_forceSingleDistribution && useGeneralLedgerDistribution && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    postedDistributionData = new List(Types::Class);
                    postedDistributionsTotal = this.getGeneralJournalDistributionData(postedDistributionData, _custVendTrans, _ledgerPostingTypes);
                }
                else
                {
                    this.addDefaultDistributionFactors(_defaultLedgerDimension, _custVendTrans, distributionFactors);
                }
            }
            else
            {
                // discover distribution data based on the source document framework data associated with the transaction
                postedDistributionData = new List(Types::Class);
                postedDistributionsTotal = this.getSourceDocumentDistributionData(postedDistributionData, _custVendTrans, _ledgerPostingTypes);
            }

            if (postedDistributionData != null)
            {
                this.calculateDistributionFactors(postedDistributionData, postedDistributionsTotal, distributionFactors);
            }

            this.parmCurrentDistributionFactors(distributionFactors);
        }

        Debug::assert(this.parmCurrentDistributionFactors() != null);
        Debug::assert(this.needToAcquireFactorsForPostingTypes(_custVendTrans, _ledgerPostingTypes, _defaultLedgerDimension, _forceSingleDistribution) == false);

        return this.parmCurrentDistributionFactors();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentDistributionData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the distribution data from the source document data.
    /// </summary>
    /// <param name = "_postedDistributionData">A list of <c>CustVendTransDistribution</c> objects containing the data being gathered.</param>
    /// <param name = "_custVendTrans">A customer/vendor transaction.</param>
    /// <param name = "_ledgerPostingTypes">A list of ledger posting types.</param>
    /// <returns>A monetary total amount for all of the distributions.</returns>
    internal Money getSourceDocumentDistributionData(List _postedDistributionData, CustVendTrans _custVendTrans, List _ledgerPostingTypes)
    {
        Money postedDistributionsTotal;

        AccountingEvent accountingEvent = AccountingEvent::find(_custVendTrans.AccountingEvent);

        if (SourceDocumentDetermineDistributionFactorsForSettlementFlight::instance().isEnabled() &&
            accountingEvent.Type == AccountingEventType::PendingJournalized)
        {
            postedDistributionsTotal = SourceDocumentDistributionFactorsForSettlement::getSourceDocumentDistributionData
            (
                _postedDistributionData,
                accountingEvent,
                currentLedger,
                _ledgerPostingTypes
            );
        }
        else
        {
            SubledgerJournalAccountEntry sjae;

            Query query = this.getQueryForSourceDocument(_custVendTrans, sjae);

            query.dataSourceTable(tableNum(SubledgerJournalEntry)).findRange(fieldNum(SubledgerJournalEntry, AccountingEvent)).value(queryValue(_custVendTrans.AccountingEvent));
            query.dataSourceTable(tableNum(SubledgerJournalEntry)).findRange(fieldNum(SubledgerJournalEntry, Ledger)).value(queryValue(currentLedger.RecId));
            this.addLedgerPostingTypeRange(query.dataSourceTable(tableNum(SubledgerJournalAccountEntry)), fieldNum(SubledgerJournalAccountEntry, PostingType), _ledgerPostingTypes, true);

            QueryRun queryRun = new QueryRun(query);
            if (this.groupSourceDocumentDistributionEnabled(_custVendTrans) && sjae.RecId > 0)
            {
                List postedDistributions = new List(Types::Class);
                while (queryRun.next())
                {
                    SubledgerJournalAccountEntry subledgerJournalAccountEntry = queryRun.get(tableNum(SubledgerJournalAccountEntry));
                    SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution = queryRun.get(tableNum(SubledgerJournalAccountEntryDistribution));

                    // only non-zero values are processed
                    if (subledgerJournalAccountEntryDistribution.AccountingCurrencyAmount != 0)
                    {
                        CustVendTransDistribution postedDistribution = new CustVendTransDistribution(
                                subledgerJournalAccountEntry.LedgerDimension,
                                0,
                                subledgerJournalAccountEntryDistribution.AccountingCurrencyAmount);

                        if (subledgerJournalAccountEntryDistribution.AccountingDistribution != 0)
                        {
                            postedDistribution.setAccountingDistributions(int642Str(subledgerJournalAccountEntryDistribution.AccountingDistribution));
                        }

                        postedDistributions.addEnd(postedDistribution);
                        postedDistributionsTotal += subledgerJournalAccountEntryDistribution.AccountingCurrencyAmount;
                    }
                }

                _postedDistributionData.appendList(this.groupDistributions(postedDistributions, _custVendTrans));
            }
            else
            {
                while (queryRun.next())
                {
                    SubledgerJournalAccountEntry subledgerJournalAccountEntry = queryRun.get(tableNum(SubledgerJournalAccountEntry));

                    // only non-zero values are processed
                    if (subledgerJournalAccountEntry.AccountingCurrencyAmount != 0)
                    {
                        CustVendTransDistribution postedDistribution = new CustVendTransDistribution(
                                subledgerJournalAccountEntry.LedgerDimension,
                                0,
                                subledgerJournalAccountEntry.AccountingCurrencyAmount);

                        _postedDistributionData.addEnd(postedDistribution);
                        postedDistributionsTotal += subledgerJournalAccountEntry.AccountingCurrencyAmount;
                    }
                }
            }
        }

        return postedDistributionsTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForCustVendGeneralJournalEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build query for gets the distribution data from the general journal data.
    /// </summary>
    protected void buildQueryForCustVendGeneralJournalEntry(QueryBuildDataSource _qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalDistributionData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the distribution data from the general journal data.
    /// </summary>
    /// <param name = "_postedDistributionData">A list of <c>CustVendTransDistribution</c> objects containing the data being gathered.</param>
    /// <param name = "_custVendTrans">A customer/vendor transaction.</param>
    /// <param name = "_ledgerPostingTypes">A list of ledger posting types.</param>
    /// <returns>A monetary total amount for all of the distributions.</returns>
    internal Money getGeneralJournalDistributionData(List _postedDistributionData, CustVendTrans _custVendTrans, List _ledgerPostingTypes)
    {
        Money postedDistributionsTotal;

        Query query = new Query(queryStr(CustVendGeneralJournalAccountSource));

        query.dataSourceTable(tableNum(SubledgerVoucherGeneralJournalEntry)).findRange(fieldNum(SubledgerVoucherGeneralJournalEntry, Voucher)).value(queryValue(_custVendTrans.Voucher));
        query.dataSourceTable(tableNum(SubledgerVoucherGeneralJournalEntry)).findRange(fieldNum(SubledgerVoucherGeneralJournalEntry, VoucherDataAreaId)).value(queryValue(_custVendTrans.dataAreaId));
        query.dataSourceTable(tableNum(SubledgerVoucherGeneralJournalEntry)).findRange(fieldNum(SubledgerVoucherGeneralJournalEntry, AccountingDate)).value(queryValue(_custVendTrans.TransDate));
        this.addLedgerPostingTypeRange(query.dataSourceTable(tableNum(GeneralJournalAccountEntry)), fieldNum(GeneralJournalAccountEntry, PostingType), _ledgerPostingTypes, true);
        
        this.buildQueryForCustVendGeneralJournalEntry(query.dataSourceTable(tableNum(GeneralJournalAccountEntry)));

        QueryRun queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            GeneralJournalAccountEntry localGeneralJournalAccountEntry = queryRun.get(tableNum(GeneralJournalAccountEntry));

            // only non-zero values are processed
            if (localGeneralJournalAccountEntry.AccountingCurrencyAmount != 0)
            {
                CustVendTransDistribution postedDistribution = new CustVendTransDistribution(
                                localGeneralJournalAccountEntry.LedgerDimension,
                                0,
                                localGeneralJournalAccountEntry.AccountingCurrencyAmount);
                _postedDistributionData.addEnd(postedDistribution);
                postedDistributionsTotal += localGeneralJournalAccountEntry.AccountingCurrencyAmount;
            }
        }

        return postedDistributionsTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDistributionFactors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates distribution factors using the distribution data.
    /// </summary>
    /// <param name = "_postedDistributionData">The distribution data - a list of <c>CustVendTransDistribution</c> objects.</param>
    /// <param name = "_postedDistributionsTotal">A monetary total amount for all of the distributions.</param>
    /// <param name = "_distributionFactors">The calculated distribution factors - a list of <c>CustVendTransDistribution</c> objects.</param>
    internal void calculateDistributionFactors(List _postedDistributionData, Money _postedDistributionsTotal, List _distributionFactors)
    {
        // calculate the distribution factors based on the total
        ListEnumerator postedDistributionDataEnumerator = _postedDistributionData.getEnumerator();

        while (postedDistributionDataEnumerator.moveNext())
        {
            CustVendTransDistribution postedDistribution = postedDistributionDataEnumerator.current();
            Money factor;

            // protect for possible divide by zero error
            if (_postedDistributionsTotal != 0)
            {
                factor = postedDistribution.accountingAmount() / _postedDistributionsTotal;     // factor = posted distribution amount / total
            }
            else
            {
                factor = 0;
            }
                    
            CustVendTransDistribution distributionFactor = new CustVendTransDistribution(
                        postedDistribution.ledgerDimension(),
                        factor);

            distributionFactor.setAccountingDistributions(postedDistribution.getAccountingDistributions());

            _distributionFactors.addEnd(distributionFactor);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDefaultDistributionFactors</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adding the value to distribution factor list.
    /// </summary>
    /// <param name = "_defaultLedgerDimension">
    ///     The default ledger dimension.
    /// </param>
    /// <param name = "_custVendTrans">
    ///     The customer or vendor transaction that is used to find the distribution factors.
    /// </param>
    /// <param name = "_distributionFactors">
    ///     A list of distribution factors used for addition.
    /// </param>
    protected void addDefaultDistributionFactors(LedgerDimensionAccount _defaultLedgerDimension, CustVendTrans _custVendTrans, List _distributionFactors)
    {
        // create a single entry using the default ledger dimension provided and a factor of 100%
        _distributionFactors.addEnd(new CustVendTransDistribution(_defaultLedgerDimension, 1.0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingTypeRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets the ledger posting type range.
    /// </summary>
    /// <param name="_ledgerPostingTypeList">
    ///  A list of ledger posting types.
    /// </param>
    /// <param name="_useAlternativeBalancePostingType">
    ///  True when the alternative balance posting type should be included in the range.
    /// </param>
    /// <returns>
    ///  A string that identifies the ledger posting type range.
    /// </returns>
    protected str getLedgerPostingTypeRange(List _ledgerPostingTypeList, boolean _useAlternativeBalancePostingType = false)
    {
        LedgerPostingType ledgerPostingType;
        ListEnumerator listEnumerator;
        str ledgerPostingTypeRange;
        boolean alternativeBalancePostingTypeFound;

        int i = 0;
        listEnumerator = _ledgerPostingTypeList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            ledgerPostingType = listEnumerator.current();

            if (i==0)
            {
                ledgerPostingTypeRange += strfmt('%1', ledgerPostingType);
            }
            else
            {
                ledgerPostingTypeRange += strfmt(',%1', ledgerPostingType);
            }

            if (_useAlternativeBalancePostingType && alternativeBalancePostingType == ledgerPostingType)
            {
                alternativeBalancePostingTypeFound = true;
            }

            i++;
        }

        if (_useAlternativeBalancePostingType && !alternativeBalancePostingTypeFound)
        {
            if (i==0)
            {
                ledgerPostingTypeRange += strfmt('%1', alternativeBalancePostingType);
            }
            else
            {
                ledgerPostingTypeRange += strfmt(',%1', alternativeBalancePostingType);
            }
        }

        return ledgerPostingTypeRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostedDistributionTransactionTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets the total transaction amount for a list of distributions.
    /// </summary>
    /// <param name="_postedDistributionData">
    ///  A list of <c>CustVendTransDistribution</c> information
    /// </param>
    /// <returns>
    ///  The total transaction amount.
    /// </returns>
    protected Money getPostedDistributionTransactionTotal(List _postedDistributionData)
    {
        Money transactionTotal;

        if (_postedDistributionData)
        {
            ListEnumerator postedDistributionDataEnumerator = _postedDistributionData.getEnumerator();
            while (postedDistributionDataEnumerator.moveNext())
            {
                CustVendTransDistribution postedDistribution = postedDistributionDataEnumerator.current();
                transactionTotal += postedDistribution.accountingAmount();
            }
        }

        return transactionTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needToAcquireFactorsForPostingTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines if we need to acquire distribution factors.
    /// </summary>
    /// <param name="_custVendTrans">
    ///  The customer or vendor document that is being revalued.
    /// </param>
    /// <param name="_ledgerPostingTypes">
    ///  A <c>List</c> that contains the collection of <c>LedgerPostingType</c> enumerations that
    ///  that are used to find the distribution factors.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    ///  The default ledger dimension.
    /// </param>
    /// <param name="_forceSingleDistribution">
    ///  True when a single distribution should be created with the _defaultLedgerDimension; otherwise false.
    /// </param>
    /// <returns>
    ///  True when new distribution factors have to be retrieved; otherwise, false.
    /// </returns>
    protected boolean needToAcquireFactorsForPostingTypes(
        CustVendTrans _custVendTrans,
        List _ledgerPostingTypes,
        LedgerDimensionAccount  _defaultLedgerDimension,
        boolean _forceSingleDistribution)
    {
        return (currentDistributionFactors == null
                || currentTransaction.RecId != _custVendTrans.RecId
                || currentTransaction.AccountingEvent != _custVendTrans.AccountingEvent
                || !currentLedgerPostingTypes.equalTo(_ledgerPostingTypes)
                || currentDefaultLedgerDimension != _defaultLedgerDimension
                || currentForceSingleDistribution != _forceSingleDistribution);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAlernativeBalancePostingType</Name>
				<Source><![CDATA[
    public LedgerPostingType parmAlernativeBalancePostingType(LedgerPostingType _value = LedgerPostingType::None)
    {
        alternativeBalancePostingType = _value;
        return alternativeBalancePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrentDistributionFactors</Name>
				<Source><![CDATA[
    protected List parmCurrentDistributionFactors(List _distributionFactors = currentDistributionFactors)
    {
        currentDistributionFactors = _distributionFactors;

        return currentDistributionFactors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseGeneralLedgerDistribution</Name>
				<Source><![CDATA[
    public boolean parmUseGeneralLedgerDistribution(boolean _useGeneralLedgerDistribution = useGeneralLedgerDistribution)
    {
        useGeneralLedgerDistribution = _useGeneralLedgerDistribution;

        return useGeneralLedgerDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsePreciseComparison</Name>
				<Source><![CDATA[
    public boolean parmUsePreciseComparison(boolean _value = usePreciseComparison)
    {
        usePreciseComparison = _value;
        return usePreciseComparison;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preciseCompareFactors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares lists of factors.
    /// </summary>
    /// <param name="_compare">
    /// First list of factors.
    /// </param>
    /// <param name="_compareTo">
    /// First list of factors.
    /// </param>
    /// <returns>
    /// True if two lists are different.
    /// </returns>
    boolean preciseCompareFactors(List _compare, List _compareTo)
    {
        Set factorsToContainerSet(List _factors)
        {
            Enumerator e = _factors.getEnumerator();
            CustVendTransDistribution distribution;
            Set ret = new Set(Types::String);
            while (e.moveNext())
            {
                distribution = e.current();

                str ledgerDimensionAndAmount = strFmt('%1 %2', 
                    LedgerDimensionFacade::serviceGetLedgerDimensionForCurrentHash(distribution.ledgerDimension()),
                    distribution.accountingAmount());

                ret.add(ledgerDimensionAndAmount);
            }
            return ret;
        }

        if (_compare.elements() != _compareTo.elements())
        {
            return true;
        }

        Set compareSet = factorsToContainerSet(_compare);
        Set compareToSet = factorsToContainerSet(_compareTo);

        //Duplicate ledger dimension and amounts are considered a difference 
        if (_compare.elements() != compareSet.elements() 
            || _compareTo.elements() != compareToSet.elements())
        {
            return true;
        }

        Set differenceSet = Set::difference(compareSet, compareToSet);
        if (differenceSet != null && differenceSet.elements() > 0)
        {
            return true;
        }

        differenceSet = Set::difference(compareToSet, compareSet);
        if (differenceSet != null && differenceSet.elements() > 0)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useExtensibleFactors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses the clone method from the <c>CustVendTransDistribution</c>class to make distributions from
    /// factors
    /// </summary>
    /// <returns>
    /// true if successful; otherwise, false.
    /// </returns>
    protected boolean useExtensibleFactors()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendTransDistributionController construct()
    {
        return new CustVendTransDistributionController();
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTransHasSourceDocumentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a transaction record is associated with source document framework data.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> record to check.
    /// </param>
    /// <returns>
    /// true if the <c>CustVendTrans</c> record has associated source document framework data; otherwise,
    /// false.
    /// </returns>
    public static boolean custVendTransHasSourceDocumentData(CustVendTrans _custVendTrans)
    {
        if (_custVendTrans.AccountingEvent == 0)
        {
            return false;
        }
        AccountingEvent accountingEvent = AccountingEvent::find(_custVendTrans.AccountingEvent);
        if (accountingEvent.Type == AccountingEventType::PendingJournalized && !SourceDocumentDetermineDistributionFactorsForSettlementFlight::instance().isEnabled())
        {
            throw error(strFmt("@SourceDocumentAccountingFramework:ThrowSettlementCannotBeDoneError", _custVendTrans.Invoice, ' ', _custVendTrans.Invoice));
        }
        // If the transaction record is associated with an accounting event, then there is source document data associated with the transaction
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerPostingTypeRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add posting type ranges for a list of posting types.
    /// </summary>
    /// <param name="_qbds">
    /// The data source that contains the posting type field.
    /// </param>
    /// <param name="_postingTypeFieldNum">
    /// The posting type field number.
    /// </param>
    /// <param name="_ledgerPostingTypeList">
    /// A list of ledger posting types.
    /// </param>
    /// <param name="_useAlternativeBalancePostingType">
    /// True when the alternative balance posting type should be included in the range.
    /// </param>
    protected void addLedgerPostingTypeRange(
        QueryBuildDataSource _qbds,
        int _postingTypeFieldNum,
        List _ledgerPostingTypeList,
        boolean _useAlternativeBalancePostingType = false)
    {
        LedgerPostingType ledgerPostingType;
        boolean alternativeBalancePostingTypeFound;

        int i = 0;
        ListEnumerator listEnumerator = _ledgerPostingTypeList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            ledgerPostingType = listEnumerator.current();
            _qbds.addRange(_postingTypeFieldNum).value(queryValue(ledgerPostingType));

            if (_useAlternativeBalancePostingType && alternativeBalancePostingType == ledgerPostingType)
            {
                alternativeBalancePostingTypeFound = true;
            }

            i++;
        }

        if (_useAlternativeBalancePostingType
            && alternativeBalancePostingType != ledgerPostingType::None
            && !alternativeBalancePostingTypeFound)
        {
            _qbds.addRange(_postingTypeFieldNum).value(queryValue(alternativeBalancePostingType));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initializes an instance of the <c>CustVendTransDistributionController</c> class for settlements.
    /// </summary>
    /// <param name="_isSettleByLineEnabled">
    ///  Identifies when line level settlements are enabled.
    /// </param>
    /// <param name="_currentSpecTransId">
    ///  Identifies the current invoice line that is being settled for line level settlements.
    /// </param>
    /// <returns>
    /// An instance of the <c>CustVendTransDistributionController</c> class.
    /// </returns>
    public static CustVendTransDistributionController constructForSettlement(boolean _isSettleByLineEnabled, RefRecId _currentSpecTransId)
    {
        CustVendTransDistributionController controller;
        CustVendTransSettleDistController settleController;
        CustTransMarkedOpenLine custTransMarkedOpenLine;

        if (_isSettleByLineEnabled)
        {
            select firstOnly RecId from custTransMarkedOpenLine
            where custTransMarkedOpenLine.SpecTrans == _currentSpecTransId;

            if (custTransMarkedOpenLine)
            {
                settleController = CustVendTransSettleDistController::construct(_isSettleByLineEnabled);
                settleController.parmSpecTransId(_currentSpecTransId);

                controller = settleController;
            }
        }

        if (!controller)
        {
            controller = CustVendTransExchAdjDistController::construct();
        }

        return controller;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionLedgerDimensionDiffExist</Name>
				<Source><![CDATA[
    private boolean distributionLedgerDimensionDiffExist(List _compare, List _compareTo)
    {
        boolean differencesExist = false;
        Set compareLedgerDimensionSet;
        Set compareToLedgerDimensionSet;
        Set differenceSet;

        Set convertDistributionListToLedgerDimesionSet(List distributions)
        {
            ListEnumerator le;
            CustVendTransDistribution distribution;
            Set ledgerDimensionSet = new Set(Types::Int64);

            le = distributions.getEnumerator();
            while (le.moveNext())
            {
                distribution = le.current();

                ledgerDimensionSet.add(LedgerDimensionFacade::serviceGetLedgerDimensionForCurrentHash(distribution.ledgerDimension()));
            }

            return ledgerDimensionSet;
        }

        compareLedgerDimensionSet = convertDistributionListToLedgerDimesionSet(_compare);
        compareToLedgerDimensionSet = convertDistributionListToLedgerDimesionSet(_compareTo);

        if (compareLedgerDimensionSet.elements() != compareToLedgerDimensionSet.elements())
        {
            return true;
        }
        
        differenceSet = Set::difference(compareLedgerDimensionSet, compareToLedgerDimensionSet);
        if (differenceSet != null && differenceSet.elements() > 0)
        {
            return true;
        }

        differenceSet = Set::difference(compareToLedgerDimensionSet, compareLedgerDimensionSet);
        if (differenceSet != null && differenceSet.elements() > 0)
        {
            return true;
        }

        return differencesExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributionsFromTaxLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate distribution factors based on the invoice source lines and the invoice tax amounts.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The customer or vendor transaction that is used to find the distribution factors.
    /// </param>
    /// <param name="_invoiceTaxTransRecId">
    /// The customer or vendor invoice <c>TaxTrans</c> record ID.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    /// The default cash discount ledger dimension.
    /// </param>
    /// <param name="_transactionAmountToDistribute">
    /// The transaction amount to distribute.
    /// </param>
    /// <param name="_accountingAmountToDistribute">
    /// The accounting currency amount to distribute.
    /// </param>
    /// <param name="_reportingAmountToDistribute">
    /// The reporting currency amount to distribute.
    /// </param>
    /// <returns>
    /// A list that contains the collection of <c>CustVendTransDistribution</c> instances that were created.
    /// </returns>
    public List generateDistributionsFromTaxLink(
        CustVendTrans _custVendTrans,
        RecId _invoiceTaxTransRecId,
        LedgerDimensionAccount _defaultLedgerDimension,
        AmountCur _transactionAmountToDistribute,
        AmountMST _accountingAmountToDistribute,
        AmountMSTSecondary _reportingAmountToDistribute)
    {
        List distributionFactors;
        List distributions;

        if (_transactionAmountToDistribute != 0 || _accountingAmountToDistribute != 0 || _reportingAmountToDistribute != 0)
        {
            currentTransaction = _custVendTrans;
            currentDefaultLedgerDimension = _defaultLedgerDimension;
            currentLedger = Ledger::findByLegalEntity(CompanyInfo::current(_custVendTrans.company()));

            // get the distribution factors for the current request
            distributionFactors = this.getDistributionFactorsFromTaxLink(_invoiceTaxTransRecId, _defaultLedgerDimension, _custVendTrans);
            Debug::assert(distributionFactors != null);

            if (distributionFactors.elements() > 1)
            {
                distributions = this.generateDistributionsFromFactors(
                    distributionFactors,
                    _custVendTrans.CurrencyCode,
                    _transactionAmountToDistribute,
                    currentLedger.AccountingCurrency,
                    _accountingAmountToDistribute,
                    currentLedger.ReportingCurrency,
                    _reportingAmountToDistribute);
            }
            else
            {
                // use less expensive process if we know there is only a single distribution to be created
                distributions = this.generateSingleDistribution(
                    distributionFactors,
                    _transactionAmountToDistribute,
                    _accountingAmountToDistribute,
                    _reportingAmountToDistribute);
            }
        }
        else
        {
            // instantiate the return value even if there were not distributions created
            distributions = new List(Types::Class);
        }

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributionFactorsFromTaxLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets distribution factors based on the invoice source lines and invoice tax amounts.
    /// </summary>
    /// <param name="_invoiceTaxTransRecId">
    /// The customer or vendor invoice <c>TaxTrans</c> record ID.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    /// The default cash discount ledger dimension.
    /// </param>
    /// <param name="_custVendTrans">
    /// The customer or vendor transaction that is used to find the distribution factors.
    /// </param>
    /// <returns>
    /// A list of distribution factors.
    /// </returns>
    protected List getDistributionFactorsFromTaxLink(
        RecId _invoiceTaxTransRecId,
        LedgerDimensionAccount _defaultLedgerDimension,
        CustVendTrans _custVendTrans)
    {
        TaxTransGeneralJournalAccountEntry taxLink;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        CustVendTransDistribution invoiceTaxTransDistribution;
        CustVendTransDistribution distributionFactor;
        LedgerDimensionAccount ledgerDimensionAccount;
        AmountCur invoiceTaxTransDistributionTotal;
        List invoiceTaxTransDistributions = new List(Types::Class);
        List distributionFactors = new List(Types::Class);
        boolean useInvoiceLineAccount;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && _custVendTrans.CashDiscCode)
        {
            useInvoiceLineAccount = true;
        }

        while select AccountingCurrencyAmount, LedgerDimension from generalJournalAccountEntry
            order by generalJournalAccountEntry.RecId
            exists join taxLink
            where taxLink.TaxTrans == _invoiceTaxTransRecId
                && taxLink.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                && taxLink.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
        {
            if (useInvoiceLineAccount)
            {
                ledgerDimensionAccount = generalJournalAccountEntry.LedgerDimension;
            }

            DimensionDefault dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(generalJournalAccountEntry.LedgerDimension);
            ledgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(_defaultLedgerDimension, dimensionDefault);

            invoiceTaxTransDistribution = new CustVendTransDistribution(
                ledgerDimensionAccount,
                0,
                generalJournalAccountEntry.AccountingCurrencyAmount);

            invoiceTaxTransDistributions.addEnd(invoiceTaxTransDistribution);
        }

        Debug::assert(invoiceTaxTransDistributions.elements() > 0);

        if (invoiceTaxTransDistributions.elements() > 0)
        {
            invoiceTaxTransDistributionTotal = this.getPostedDistributionTransactionTotal(invoiceTaxTransDistributions);
            this.generateDistributionFactors(invoiceTaxTransDistributions, invoiceTaxTransDistributionTotal);
        }
        else
        {
            distributionFactor = new CustVendTransDistribution(
                _defaultLedgerDimension,
                1);

            distributionFactors.addEnd(distributionFactor);
            this.parmCurrentDistributionFactors(distributionFactors);
        }

        return this.parmCurrentDistributionFactors();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryForSourceDocument</Name>
				<Source><![CDATA[
    protected internal Query getQueryForSourceDocument(CustVendTrans _custVendTrans, SubledgerJournalAccountEntry _subledgerJournalAccountEntry)
    {
        if (this.groupSourceDocumentDistributionEnabled(_custVendTrans))
        {
            SubledgerJournalAccountEntryDistribution accountDistributuion;
            SubledgerJournalEntry subledgerJournalEntry;
            select count(RecId) from _subledgerJournalAccountEntry
                join accountDistributuion
                join subledgerJournalEntry
                where accountDistributuion.SubledgerJournalAccountEntry == _subledgerJournalAccountEntry.RecId
                    && subledgerJournalEntry.AccountingEvent == _custVendTrans.AccountingEvent
                    && subledgerJournalEntry.RecId == _subledgerJournalAccountEntry.SubledgerJournalEntry
                    && subledgerJournalEntry.Ledger == currentLedger.RecId;
            if (_subledgerJournalAccountEntry.RecId > 0)
            {
                return new Query(queryStr(CustVendSourceDocumentSourceGroup));
            }
        }

        return new Query(queryStr(CustVendSourceDocumentSource));
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupDistributions</Name>
				<Source><![CDATA[
    protected internal List groupDistributions(List _postedDistributionData, CustVendTrans _custVendTrans)
    {
        if (this.groupSourceDocumentDistributionEnabled(_custVendTrans))
        {
            ListEnumerator postedDistributionDataEnumerator = _postedDistributionData.getEnumerator();

            Map ledgerDimensionMap = new Map(Types::Int64, Types::Class);

            while (postedDistributionDataEnumerator.moveNext())
            {
                CustVendTransDistribution postedDistribution = postedDistributionDataEnumerator.current();
                LedgerDimensionAccount ledgerDimension = postedDistribution.ledgerDimension();
                List distributionList;
                if (ledgerDimensionMap.exists(ledgerDimension))
                {
                    distributionList = ledgerDimensionMap.lookup(ledgerDimension);
                }
                else
                {
                    distributionList = new List(Types::Class);
                }

                distributionList.addEnd(postedDistribution);
                ledgerDimensionMap.insert(ledgerDimension, distributionList);
            }

            List groupedDistributions = new List(Types::Class);

            MapEnumerator ledgerDiemsnionMapEnumerator = ledgerDimensionMap.getEnumerator();
            while (ledgerDiemsnionMapEnumerator.moveNext())
            {
                Money accountingAmount = 0;
                str accountingDistributions = '';
                List distributions = ledgerDiemsnionMapEnumerator.currentValue();
                ListEnumerator distributionsEnumerator = distributions.getEnumerator();
                while (distributionsEnumerator.moveNext())
                {
                    CustVendTransDistribution distribution = distributionsEnumerator.current();
                    accountingAmount += distribution.accountingAmount();
                    accountingDistributions = accountingDistributions + distribution.getAccountingDistributions();
                }
                CustVendTransDistribution newDistribution = new CustVendTransDistribution(
                        ledgerDiemsnionMapEnumerator.currentKey(),
                        0,
                        accountingAmount);
                newDistribution.setAccountingDistributions(accountingDistributions);
                groupedDistributions.addEnd(newDistribution);
            }

            return groupedDistributions;
        }
        else
        {
            return _postedDistributionData;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupSourceDocumentDistributionEnabled</Name>
				<Source><![CDATA[
    protected internal boolean groupSourceDocumentDistributionEnabled(CustVendTrans _custVendTrans)
    {
        return GroupSourceDocumentDistributionWithAccoutingDistributionFlight::instance().isEnabled()
            && !CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled()
            && _custVendTrans.TransType == LedgerTransType::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToDistributions</Name>
				<Source><![CDATA[
    private void addToDistributions(
        Money _currentTransactionAmount, 
        Money _currentAccountingAmount, 
        Money _currentReportingAmount,
        CustVendTransDistribution _distributionFactor,
        List _distributions)
    {
        if (_currentTransactionAmount != 0 ||
            _currentAccountingAmount != 0 ||
            _currentReportingAmount != 0)
        {
            CustVendTransDistribution distribution;

            // add the distributed amounts for the current LedgerDimension to the result set
            // <GEERU>
            if (this.useExtensibleFactors())
            {
                distribution = _distributionFactor.clone(
                    _currentTransactionAmount,
                    _currentAccountingAmount,
                    _currentReportingAmount);
            }
            else
            {
                // </GEERU>
                distribution = new CustVendTransDistribution(
                    _distributionFactor.ledgerDimension(),
                    _currentTransactionAmount,
                    _currentAccountingAmount,
                    _currentReportingAmount);
                // <GEERU>
            }
            // </GEERU>

            _distributions.addEnd(distribution);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountSign</Name>
				<Source><![CDATA[
    private int getAmountSign(Money _amount)
    {
        return _amount >= 0 ? 1 : -1;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>