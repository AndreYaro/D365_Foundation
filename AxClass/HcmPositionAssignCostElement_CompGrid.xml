<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>HcmPositionAssignCostElement_CompGrid</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Adds earning cost lines to the forecast position based on the compensation information.
/// </summary>
/// <remarks>
/// The process to add earning cost lines is based on the budget process legal entity, not login company.
/// This will require the compensation related information to be retrieved using the cross company data access pattern
/// in order to prevent the data from being restricted to just the current company context.
/// </remarks>
public class HcmPositionAssignCostElement_CompGrid extends HcmPositionForecastAssignCostElement
{
    #define.GridRateDateStart('RateStartDate')
    #define.GridRateDateEnd('RateEndDate')
    #define.IncreaseDateStart('IncreaseStartDate')
    #define.IncreaseDateEnd('IncreaseEndDate')
    #define.GridRecId('RateGridId')

    #OccRetryCount

    HcmBudgetPurposeTypeRecId                earningCostElementId;
    HcmPositionForecastCompensationGridRecId compensationGridRecId, currentCompensationGridId;
    HcmPositionForecastCompensationGridRecId currentYearIncreaseGridId;
    ValidFromDate                            levelAssignmentStartDate, compRateStartDate, firstIncreaseDateByPosition;
    ValidToDate                              levelAssignmentEndDate, compRateEndDate;
    Struct                                   gridVersionDateRangeStruct;     // Store the start time and end time for each version
    boolean                                  nextLineAdded;
    boolean                                  isCompensationIncrease;
    boolean                                  isLevelStepExisted;
    boolean                                  isLevelStepSelection;
    container                                tmpPositionForecastScenarioContainer;
    int64                                    totalPositionForecastScenario;
    Map                                      skippedPositionsMap;
    boolean                                  isHighestStep;
    boolean                                  hasIncreaseCostLine;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>applyCompensationIncreaseUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the compensation increase or update on all selected forecast positions.
    /// </summary>
    protected void applyCompensationIncreaseUpdate()
    {
        HcmPositionForecastScenarioRecId currentPositionForecastScenarioRecId;
        Set                              positionForecastScenarioSet;
        SetEnumerator                    setEnumerator;

        positionForecastScenarioSet = Set::create(this.parmPositionForecastScenarioContainer());

        totalPositionForecastScenario = positionForecastScenarioSet.elements();

        setEnumerator = positionForecastScenarioSet.getEnumerator();

        //
        // Go through all selected forecast positions
        // and apply the increase or update within budget plan date range
        //
        while (setEnumerator.moveNext())
        {
            currentPositionForecastScenarioRecId = setEnumerator.current();

            // Get Forecast position scenario info
            this.setPositionForecastScenarioInfo(currentPositionForecastScenarioRecId);

            if (this.validatePositionForecastCompChange())
            {
                // Create cost lines on the forecast position and calculate the budget amount
                this.processPositionForecastCost();
            }
        }

        // Show message
        this.showResultMessages();
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyCompensationLevelSelection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the compensation level selection on the forecast positions.
    /// </summary>
    protected void applyCompensationLevelSelection()
    {
        MapEnumerator skippedMapEnumerator;

        if (this.validatePositionForecastCompChange())
        {
            if (isLevelStepSelection && !this.parmIsLevelStepExisted())
            {
                this.parmForecastCompGridId(0);
                this.parmEarningCostAssigned(true);
            }

            // Create cost lines on the forecast position and calculate the budget amount
            this.processPositionForecastCost();
        }
        else if (isLevelStepSelection)
        {
            // Display the failure message for current forecast position directly
            skippedMapEnumerator = skippedPositionsMap.getEnumerator();

            if (skippedMapEnumerator.moveNext())
            {
                // Display the error message
                warning(skippedMapEnumerator.currentValue());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignCompLevelCostElement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the earning cost assignment to the forecast position based on the compensation level.
    /// </summary>
    /// <returns>
    /// true if the level assignment is done successfully; otherwise, false.
    /// </returns>
    private boolean assignCompLevelCostElement()
    {
        boolean        costLineAdded;
        boolean        costLineAddedPerRateVersion;
        ListEnumerator gridRateVersionListEnumerator;
        List           compRateVersionList;  // Store the grid id and a pair of dates for effective/expiration for each rate version
        boolean        isFirstRateVersionWithinLevel;

        try
        {
            compRateStartDate = levelAssignmentStartDate;
            compRateEndDate = levelAssignmentEndDate;

            ttsbegin;

            compRateVersionList = this.getAllCompRateVersionInRange(currentYearIncreaseGridId);

            if (compRateVersionList && compRateVersionList.elements() > 0)
            {
                // Add all available rate versions to cost lines for the forecast position
                gridRateVersionListEnumerator = compRateVersionList.getEnumerator();
                isFirstRateVersionWithinLevel = true;

                //
                // The following section implements different rates and date ranges.
                // Add each cost line that is associated with the compensation rate.
                //
                while (gridRateVersionListEnumerator.moveNext())
                {
                    gridVersionDateRangeStruct = gridRateVersionListEnumerator.current();
                    currentCompensationGridId = gridVersionDateRangeStruct.value(#GridRecId);

                    if (isFirstRateVersionWithinLevel)
                    {
                        currentYearIncreaseGridId = currentCompensationGridId;
                        isFirstRateVersionWithinLevel = false;
                    }

                    compRateStartDate = max(gridVersionDateRangeStruct.value(#GridRateDateStart), levelAssignmentStartDate);
                    compRateEndDate = min(gridVersionDateRangeStruct.value(#GridRateDateEnd), levelAssignmentEndDate);

                    // Updates the expiration date on the existing cost line.
                    this.updateBudgetAcctLineExpirationDate(compRateStartDate);

                    // Adding earning line that lies between the date ranges of the rate table and position
                    costLineAddedPerRateVersion = this.createEarningCostLinePerRateVersion();
                    costLineAdded = costLineAdded || costLineAddedPerRateVersion;
                }
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }

        return costLineAdded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllIncreaseCostLinePerPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates all increase cost lines for the forecast position.
    /// </summary>
    /// <returns>
    /// true if all increase cost lines are created successfully for the forecast position; otherwise, false.
    /// </returns>
    /// <remarks>
    /// There might be multiple years increase if the forecast position is with more than one year budget plan.
    /// The cost line will be created yearly on the forecast position.
    /// </remarks>
    protected boolean createAllIncreaseCostLinePerPosition()
    {
        HcmPositionForecastScenario hcmPositionForecastScenario;
        boolean                     increaseApplied;
        boolean                     firstYearIncrease = true;
        List                        increaseGridList;
        ListEnumerator              increaseGridListEnumerator;
        Struct                      currentIncreaseGridDateRange;

        hcmPositionForecastScenario = HcmPositionForecastScenario::find(this.parmNewPositionForecastScenarioId());

        // Get all increase date ranges yearly for current Position forecast scenario
        increaseGridList = this.getAllIncreaseGridInRange();

        if (increaseGridList.empty() == false)
        {
            increaseApplied = true;
            increaseGridListEnumerator = increaseGridList.getEnumerator();

            //
            // Loop through all increase years if applied
            // and add cost lines for each year's increase one at a time
            //
            ttsbegin;
            while (increaseApplied && increaseGridListEnumerator.moveNext())
            {
                // Get increase date range
                currentIncreaseGridDateRange = increaseGridListEnumerator.current();

                if (currentYearIncreaseGridId == currentIncreaseGridDateRange.value(#GridRecId))
                {
                    isHighestStep = true;
                }

                currentYearIncreaseGridId = currentIncreaseGridDateRange.value(#GridRecId);
                levelAssignmentStartDate = currentIncreaseGridDateRange.value(#IncreaseDateStart);
                levelAssignmentEndDate = currentIncreaseGridDateRange.value(#IncreaseDateEnd);

                if (firstYearIncrease == true)
                {
                    // Delete existing cost item by checking the first increase date
                    this.deleteExistingCostWithinIncreaseRange();
                    this.parmEarningCostAssigned(true);
                    firstYearIncrease = false;
                }

                // Get all increase pay for this year
                increaseApplied = this.assignCompLevelCostElement();
            }
        }

        if (increaseApplied)
        {
            ttscommit;
        }
        else
        {
            ttsabort;
        }

        return increaseApplied;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEarningCostLinePerRateVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates earning cost line for the forecast position within the specific rate version date range.
    /// </summary>
    /// <returns>
    /// true if the cost line is created successfully; otherwise, false.
    /// </returns>
    private boolean createEarningCostLinePerRateVersion()
    {
        HcmBudgetPurposeTypeDetail              budgetPurposetypedetail;
        HcmPositionForecastBudgetAcctLine       positionForecastBudgetAcctLine;
        Query                                   query;
        QueryRun                                queryRun;
        boolean                                 isCostLineAddedWithinRateRange;

        // Get qualified earning cost elements for Forecast position
        query = this.getQueryForBudgetCostElement();
        queryRun = new QueryRun(query);

        ttsbegin;
        while (queryRun.next())
        {
            budgetPurposetypedetail = queryRun.get(tableNum(HcmBudgetPurposeTypeDetail));

            positionForecastBudgetAcctLine = queryRun.get(tableNum(HcmPositionForecastBudgetAcctLine));

            this.setPositionForecastBudgetAcctline(this.parmNewPositionForecastScenarioId(),
                                                    budgetPurposetypedetail,
                                                    positionForecastBudgetAcctLine);

            // Save cost line to the forecast position
            if (nextLineAdded)
            {
                this.processBudgetAccountLine(positionForecastBudgetAcctLine);
                isCostLineAddedWithinRateRange = true;
            }
        }
        ttscommit;

        return isCostLineAddedWithinRateRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingCostWithinIncreaseRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the existing cost lines that fall within the scheduled increase range.
    /// </summary>
    private void deleteExistingCostWithinIncreaseRange()
    {
        try
        {
            HcmPositionForecastBudgetAcctLine::removeExistingCostWithinIncreaseRange(this.parmNewPositionForecastScenarioId(),
                                                                                    this.parmEarningCostElementId(),
                                                                                    this.parmFirstIncreaseDate());
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllCompRateVersionInRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list for all rate versions within specified date range.
    /// </summary>
    /// <param name="_currentGridRecId">
    /// The grid record ID of the <c>HcmPositionForecastCompensationGrid</c> table.
    /// </param>
    /// <returns>
    /// The list for all rate versions within the specified date range.
    /// </returns>
    /// <remarks>
    /// The list of rate version contains the structure of the grid record Id, effective date and expiration date for each rate version.
    /// </remarks>
    protected List getAllCompRateVersionInRange(HcmPositionForecastCompensationGridRecId _currentGridRecId)
    {
        HcmPositionForecastCompensationGrid     currentPositionForecastCompensationGrid;
        HcmPositionForecastCompensationGrid     compensationGrid;
        HcmPositionForecastCompensationRate     compensationRate;
        HcmPositionForecastCompGroupRefPoint    compensationGroupRef;
        List                                    gridVersionIdList;
        ValidToDate                             rateEndDate;
        ValidFromDate                           rateStartDate;

        gridVersionIdList = new List(Types::Class);

        currentPositionForecastCompensationGrid = HcmPositionForecastCompensationGrid::findCrossCompany(_currentGridRecId);

        // Get all grid rate versions in the group and date range
        while select crossCompany EffectiveDate, ExpirationDate from compensationRate
                    order by compensationRate.EffectiveDate
                    where compensationRate.CompensationGroup == this.parmForecastCompGroupId()
                join RecId from compensationGroupRef
                    where compensationGroupRef.CompensationRate == compensationRate.RecId
                        && compensationRate.EffectiveDate <= levelAssignmentEndDate
                        && compensationRate.ExpirationDate >= levelAssignmentStartDate
                join RecId from compensationGrid
                    where compensationGrid.CompensationGroupRefPointId == compensationGroupRef.RecId
                        && compensationGrid.CompensationLevel == currentPositionForecastCompensationGrid.CompensationLevel
                        && compensationGrid.RefPointId == currentPositionForecastCompensationGrid.RefPointId
        {
            rateStartDate = max(compensationRate.EffectiveDate, levelAssignmentStartDate);
            rateEndDate = min(compensationRate.ExpirationDate, levelAssignmentEndDate);

            if (compensationGrid.RecId > 0)
            {
                gridVersionDateRangeStruct = new Struct(Types::Int64, #GridRecId, Types::Date, #GridRateDateStart, Types::Date, #GridRateDateEnd);

                gridVersionDateRangeStruct.value(#GridRecId, compensationGrid.RecId);
                gridVersionDateRangeStruct.value(#GridRateDateStart, rateStartDate);
                gridVersionDateRangeStruct.value(#GridRateDateEnd, rateEndDate);

                gridVersionIdList.addEnd(gridVersionDateRangeStruct);
            }
        }

        return gridVersionIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllIncreaseGridInRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the increase grid list for the forecast position scenario.
    /// </summary>
    /// <returns>
    /// The list for all yearly increase information on the forecast position scenario.
    /// </returns>
    /// <remarks>
    /// The list contains the structure of the rate grid Id, start and end date for each year on the forecast position scenario.
    /// </remarks>
    protected List getAllIncreaseGridInRange()
    {
        Struct          increaseGridDateRangeStruct;
        ValidFromDate   increaseStartDate;
        ValidToDate     increaseEndDate;
        List            increaseGridList;

        increaseGridList = new List(Types::Class);

        currentYearIncreaseGridId = this.parmForecastCompGridId();
        increaseStartDate = this.parmFirstIncreaseDate();

        // Find all increase date range for each year during valid date range on the forecast position scenario
        while (increaseStartDate != dateNull() && increaseStartDate <= this.parmValidDateRangeEnd())
        {
            currentYearIncreaseGridId = this.getNextYearCompensationGridId();

            increaseEndDate =  nextYr(increaseStartDate) - 1;

            if (increaseEndDate > this.parmValidDateRangeEnd())
            {
                // Make sure the increase date range is valid date
                increaseEndDate = this.parmValidDateRangeEnd();
            }

            increaseGridDateRangeStruct = new Struct(Types::Int64, #GridRecId, Types::Date, #IncreaseDateStart, Types::Date, #IncreaseDateEnd);
            increaseGridDateRangeStruct.value(#GridRecId, currentYearIncreaseGridId);
            increaseGridDateRangeStruct.value(#IncreaseDateStart, increaseStartDate);
            increaseGridDateRangeStruct.value(#IncreaseDateEnd, increaseEndDate);

            // Save the increase date range and the compensation grid record Id to this map
            increaseGridList.addEnd(increaseGridDateRangeStruct);

            // Get next increase start date
            increaseStartDate = increaseEndDate + 1;
        }

        return increaseGridList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetAcctLineSource</Name>
				<Source><![CDATA[
    protected HcmPositionForecastBudgetAcctLineSource getBudgetAcctLineSource()
    {
        HcmPositionForecastBudgetAcctLineSource ret;

        ret = super();

        // Set the line source for the cost line based on compensation grid id
        if (currentCompensationGridId == this.parmForecastCompGridId() && !isHighestStep)
        {
            ret = HcmPositionForecastBudgetAcctLineSource::OriginalAssignment;
        }
        else if ((this.parmIsCompensationIncrease()
                    || hasIncreaseCostLine)
                    && (currentCompensationGridId == currentYearIncreaseGridId
                    || isHighestStep == true))
        {
            // Toggle the highest step flag when it is set to true
            if (isHighestStep)
            {
                isHighestStep = false;
            }

            ret = HcmPositionForecastBudgetAcctLineSource::StepIncrease;
        }
        else
        {
            ret = HcmPositionForecastBudgetAcctLineSource::RateChange;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstIncreaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first increase date from the forecast position scenario.
    /// </summary>
    /// <returns>
    /// The first increase date on the forecast position scenario.
    /// </returns>
    /// <remarks>
    /// The first increase date is defined by the compensation group.
    /// It also is confined by the budget process date range.
    /// </remarks>
    protected ValidFromDate getFirstIncreaseDate()
    {
        ValidFromDate firstIncreaseDate;
        HcmPositionForecastScenario positionForecastScenario;

        positionForecastScenario = HcmPositionForecastScenario::find(this.parmNewPositionForecastScenarioId());
        firstIncreaseDate = HcmPositionForecastScenario::getCompensationIncreaseDate(positionForecastScenario.RecId,
                                                                                        positionForecastScenario.AnniversaryDate,
                                                                                        positionForecastScenario.CompensationGroupId,
                                                                                        positionForecastScenario.CompensationGroupDataAreaId);

        // Make sure the first increase date is valid within the date range on the forecast position scenario.
        while (firstIncreaseDate != dateNull() && firstIncreaseDate < this.parmValidDateRangeStart())
        {
            firstIncreaseDate = nextYr(firstIncreaseDate);
        }

        if (firstIncreaseDate > this.parmValidDateRangeEnd())
        {
            // Reset to null date if the first increase date is outside of the valid date range on the forecast position scenario.
            firstIncreaseDate = dateNull();
        }

        return firstIncreaseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextStepGridId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the record Id for the next step in the <c>HcmPositionForecastCompensationGrid</c> table.
    /// The next step is based on current step ID from the <c>HRCCompRefPointSetupLine</c> table.
    /// </summary>
    /// <param name="_currentGridId">
    /// The record Id of the current record in the <c>HcmPositionForecastCompensationGrid</c> table.
    /// </param>
    /// <returns>
    /// The record Id of the record with the next Step in the <c>HcmPositionForecastCompensationGrid</c> table.
    /// </returns>
    private HcmPositionForecastCompensationGridRecId getNextStepGridId(HcmPositionForecastCompensationGridRecId _currentGridId)
    {
        HcmPositionForecastCompensationGrid hcmPositionForecastCompensationGrid;

        // Get the record of the current grid.
        HRCCompRefPointSetupLine currentHRCCompRefPointSetupLine;
        HcmPositionForecastCompensationGrid currentStepGrid;

        select firstonly crossCompany currentStepGrid
                where currentStepGrid.RecId == _currentGridId
            join LineNum from currentHRCCompRefPointSetupLine
                where currentHRCCompRefPointSetupLine.RefPointId == currentStepGrid.RefPointId
                && currentHRCCompRefPointSetupLine.RefPointSetupId == currentStepGrid.RefPointSetupId;

        if (currentStepGrid.RecId != 0)
        {
            HRCCompRefPointSetupLine hrcCompRefPointSetupLine;

            // Find next step grid record
            select firstonly crossCompany RecId from hcmPositionForecastCompensationGrid
                join RefPointId from hrcCompRefPointSetupLine order by RefPointSetupId, LineNum asc
                    where hcmPositionForecastCompensationGrid.RefPointId == hrcCompRefPointSetupLine.RefPointId
                    && hrcCompRefPointSetupLine.RefPointSetupId == currentStepGrid.RefPointSetupId
                    && hrcCompRefPointSetupLine.LineNum > currentHRCCompRefPointSetupLine.LineNum
                    && hcmPositionForecastCompensationGrid.CompensationGroupRefPointId == currentStepGrid.CompensationGroupRefPointId
                    && hcmPositionForecastCompensationGrid.CompensationLevel == currentStepGrid.CompensationLevel;
        }

        return hcmPositionForecastCompensationGrid.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextYearCompensationGridId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the next increase compensation grid Id based on current compensation grid Id.
    /// </summary>
    /// <returns>
    /// The record Id of the <c>HcmPositionForecastCompensationGrid</c> table for next increase.
    /// </returns>
    /// <remarks>
    /// The next increase grid Id is one step up from current grid Id. The next increase grid Id is the same as current grid Id
    /// when the step reaches the highest step.
    /// </remarks>
    private HcmPositionForecastCompensationGridRecId getNextYearCompensationGridId()
    {
        HcmPositionForecastCompensationGridRecId nextYearGridId;

        // Find the next step grid id
        nextYearGridId = this.getNextStepGridId(currentYearIncreaseGridId);

        if (nextYearGridId == 0)
        {
            // Use current grid Id when the current grid Id is the highest step.
            nextYearGridId = currentYearIncreaseGridId;
        }

        return nextYearGridId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryForBudgetCostElement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the query for the records to add on the <c>HcmPositionForecastBudgetAccountLine</c> table.
    /// </summary>
    /// <returns>
    /// Returns a query for the <c>HcmPositionForecastBudgetAcctLine</c> table record.
    /// </returns>
    protected Query getQueryForBudgetCostElement()
    {
        Query query;
        QueryBuildDataSource qbdsBudgetPurposeTypeDetail;
        QueryBuildDataSource qbdspositionForecastBudgetAcctLine;

        query = new Query();
        query.allowCrossCompany(true);
        qbdsBudgetPurposeTypeDetail = query.addDataSource(tableNum(HcmBudgetPurposeTypeDetail));

        qbdsBudgetPurposeTypeDetail.addRange(fieldNum(HcmBudgetPurposeTypeDetail, BudgetPurposeType)).value(queryValue(earningCostElementId));
        qbdsBudgetPurposeTypeDetail.addRange(fieldNum(HcmBudgetPurposeTypeDetail, LegalEntity)).value(queryValue(this.parmCompanyId()));
        qbdsBudgetPurposeTypeDetail.addRange(fieldNum(HcmBudgetPurposeTypeDetail, EffectiveDate)).value(HcmPositionForecastFormUtility::formatCriteriaDateRangeByDate(fieldStr(HcmBudgetPurposeTypeDetail, EffectiveDate),
                                                                                                                                                                         fieldStr(HcmBudgetPurposeTypeDetail, ExpirationDate),
                                                                                                                                                                         compRateStartDate,
                                                                                                                                                                         compRateEndDate));
        qbdspositionForecastBudgetAcctLine = qbdsBudgetPurposeTypeDetail.addDataSource(tableNum(HcmPositionForecastBudgetAcctLine));

        qbdspositionForecastBudgetAcctLine.joinMode(JoinMode::OuterJoin);

        qbdspositionForecastBudgetAcctLine.relations(true);

        qbdspositionForecastBudgetAcctLine.addRange(fieldNum(HcmPositionForecastBudgetAcctLine, PositionForecastScenario)).value(queryValue(this.parmNewPositionForecastScenarioId()));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasExistingEarningCostLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the earning cost line already exists on the forecast position.
    /// </summary>
    /// <returns>
    /// true if any earning cost line exists; otherwise, false.
    /// </returns>
    private boolean hasExistingEarningCostLine()
    {
        boolean hasExistingEarningCostLine;

        // Check if there is any earning cost line related to the earning type defined in the compensation group on forecast position
        hasExistingEarningCostLine = HcmPositionForecastBudgetAcctLine::existsEarningCostRelateToType(this.parmNewPositionForecastScenarioId(), this.parmEarningCostElementId());

        if (hasExistingEarningCostLine == false)
        {
            //
            // The earning type might be changed in the compensation group, need to check if there is any cost line related to the rate grid
            // on forecast position based on previous earning cost type defined in the compensation group.
            //
            hasExistingEarningCostLine = HcmPositionForecastBudgetAcctLine::existsEarningCostRelateToRate(this.parmNewPositionForecastScenarioId());
        }

        return hasExistingEarningCostLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        skippedPositionsMap = new Map(Types::Int64, Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEarningCostElementId</Name>
				<Source><![CDATA[
    public HcmBudgetPurposeTypeRecId parmEarningCostElementId(HcmBudgetPurposeTypeRecId _earningCostElementId = earningCostElementId)
    {
        earningCostElementId = _earningCostElementId;
        return earningCostElementId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFirstIncreaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the first increase date for the compensation increase on the forecast position.
    /// </summary>
    /// <param name="_firstIncreaseDateByPosition">
    /// The first increase date for the compensation increase on the forecast position.
    /// </param>
    /// <returns>
    /// The first increase date for the compensation increase on the forecast position.
    /// </returns>
    protected ValidFromDate parmFirstIncreaseDate(ValidFromDate _firstIncreaseDateByPosition = firstIncreaseDateByPosition)
    {
        firstIncreaseDateByPosition = _firstIncreaseDateByPosition;
        return firstIncreaseDateByPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForecastCompGridId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the record ID of the Compensation grid in the <c>HcmPositionForecastCompensationGrid</c> table.
    /// </summary>
    /// <param name="_compensationGridId">
    /// The record ID of the Compensation group in the <c>HcmPositionForecastCompensationGroup</c> table.
    /// </param>
    /// <returns>
    /// The record ID of the <c>HcmPositionForecastCompensationGrid</c> table.
    /// </returns>
    public HcmPositionForecastCompensationGridRecId parmForecastCompGridId(HcmPositionForecastCompensationGridRecId _compensationGridId = compensationGridRecId)
    {
        compensationGridRecId = _compensationGridId;
        return compensationGridRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCompensationIncrease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the flag for the compensation increase on the forecast position.
    /// </summary>
    /// <param name="_isCompensationIncrease">
    /// The flag for the compensation increase on the forecast position.
    /// </param>
    /// <returns>
    /// true if the cost element assignment is for compensation increase on the forecast position; otherwise, false.
    /// </returns>
    public boolean parmIsCompensationIncrease(HcmPositionForecastCompensationGridRecId _isCompensationIncrease = isCompensationIncrease)
    {
        isCompensationIncrease = _isCompensationIncrease;
        return isCompensationIncrease;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsLevelStepExisted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the flag for the level and step assignment on the forecast position.
    /// </summary>
    /// <param name="_isLevelStepExisted">
    /// The flag for the level and step assignment on the forecast position.
    /// </param>
    /// <returns>
    /// true if the level and step is assigned to the forecast position; otherwise, false
    /// </returns>
    public boolean parmIsLevelStepExisted(boolean _isLevelStepExisted = isLevelStepExisted)
    {
        isLevelStepExisted = _isLevelStepExisted;
        return isLevelStepExisted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPositionForecastScenarioContainer</Name>
				<Source><![CDATA[
    public container parmPositionForecastScenarioContainer(container _tmpPositionForecastScenarioContainer = tmpPositionForecastScenarioContainer)
    {
        tmpPositionForecastScenarioContainer = _tmpPositionForecastScenarioContainer;

        return tmpPositionForecastScenarioContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBudgetAccountLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the record to the <c>HcmPositionForecastBudgetAcctLine</c> table.
    /// </summary>
    /// <param name="_positionForecastBudgetAcctLine">
    /// The <c>HcmPositionForecastBudgetAcctLine</c> table record.
    /// </param>
    protected void processBudgetAccountLine(HcmPositionForecastBudgetAcctLine _positionForecastBudgetAcctLine)
    {
        ttsbegin;
        if (_positionForecastBudgetAcctLine.validateWrite())
        {
            _positionForecastBudgetAcctLine.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCostElementQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts earning cost lines to the single forecast position.
    /// </summary>
    protected void processCostElementQuery()
    {
        HcmPositionForecastScenario            hcmPositionForecastScenario;
        HcmPositionForecastCalcProcessLauncher positionForecastCalcProcessLauncher;
        boolean                                success;

        // Add cost line(s) based on the level/Step selection
        this.refreshEarningCostByLevelSelection();

        if (this.parmIsCompensationIncrease() || hasIncreaseCostLine)
        {
            success = this.createAllIncreaseCostLinePerPosition();
        }

        //
        // Make sure the calculation go through for the forecast position with the maximum retry
        // during the process.
        //
        try
        {
            if (success || this.parmEarningCostAssigned())
            {
                this.parmEarningCostAssigned(true);

                // Run the calculation process for the budget amount in the forecast position
                hcmPositionForecastScenario = HcmPositionForecastScenario::find(this.parmNewPositionForecastScenarioId());

                positionForecastCalcProcessLauncher = HcmPositionForecastCalcProcessLauncher::newForecastCalculateSinglePosition(hcmPositionForecastScenario);
                positionForecastCalcProcessLauncher.runPositionForecstCalculationProcess();
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshEarningCostByLevelSelection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all existing earning cost lines and creates earning cost lines
    /// based on the compensation group, level and step for the forecast position.
    /// </summary>
    private void refreshEarningCostByLevelSelection()
    {
        boolean costLineChanged;

        // Delete existing earning cost line first
        this.removeEarningCostByForecastScenario();
        this.parmEarningCostAssigned(true);

        //
        // Add cost line(s) on the forecast position
        // based on the level/Step selection and its valid date ranges
        //
        currentYearIncreaseGridId = this.parmForecastCompGridId();
        levelAssignmentStartDate = this.parmValidDateRangeStart();
        levelAssignmentEndDate = this.parmValidDateRangeEnd();

        costLineChanged = this.assignCompLevelCostElement();
        costLineChanged = costLineChanged || this.parmEarningCostAssigned();

        // Set the flag of cost line change for the process
        this.parmEarningCostAssigned(costLineChanged);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeEarningCostByForecastScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all of the existing earning cost element lines in the <c>HcmPositionForecastBudgetAcctLine</c> table for the forecast position.
    /// </summary>
    private void removeEarningCostByForecastScenario()
    {
        HcmPositionForecastBudgetAcctLine   hcmPositionForecastBudgetAcctLine;
        HcmBudgetPurposeType                budgetCostElement;
        HcmBudgetPurposeTypeDetail          budgetCostElementDetail;

        try
        {
            // Remove all earning cost lines by the cost element type
            delete_from hcmPositionForecastBudgetAcctLine
                where hcmPositionForecastBudgetAcctLine.PositionForecastScenario == this.parmNewPositionForecastScenarioId()
                    && hcmPositionForecastBudgetAcctLine.LegalEntity == this.parmCompanyId()
                    exists join budgetCostElementDetail
                        where budgetCostElementDetail.RecId == hcmPositionForecastBudgetAcctLine.BudgetPurposeTypeDetail
                    exists join budgetCostElement
                        where budgetCostElement.RecId == budgetCostElementDetail.BudgetPurposeType
                            && budgetCostElement.CostElementType == HcmBudgetCostElementType::Earning
                            && budgetCostElement.RecId == this.parmEarningCostElementId();

            // Also remove all rate grid related cost lines in case the earning type changed in the compensation group
            delete_from hcmPositionForecastBudgetAcctLine
                where hcmPositionForecastBudgetAcctLine.PositionForecastScenario == this.parmNewPositionForecastScenarioId()
                    && hcmPositionForecastBudgetAcctLine.LegalEntity == this.parmCompanyId()
                    && hcmPositionForecastBudgetAcctLine.IsSystemGenerated == true;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForecastPositionCostAssignments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the cost element assignments for the level selection, compensation increase and update
    /// on a single forecast position or multiple forecast positions.
    /// </summary>
    public void runForecastPositionCostAssignments()
    {
        if (this.parmPositionForecastScenarioContainer())
        {
            // Creates cost line for the compensation increase or update.
            this.applyCompensationIncreaseUpdate();
        }
        else
        {
            isLevelStepSelection = true;

            this.setPositionForecastScenarioInfo(this.parmNewPositionForecastScenarioId());

            // Creates cost line for the level selection.
            this.applyCompensationLevelSelection();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPositionForecastBudgetAcctline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns <c>HcmBudgetPurposeTypeDetail</c> table record to the <c>HcmPositionForecastBudgetAcctLine</c> table.
    /// </summary>
    /// <param name="_positionForecastScenario">
    /// The record ID of the <c>HcmPositionForecastScenario</c> table.
    /// </param>
    /// <param name="_budgetPurposeTypeDetail">
    /// The <c>HcmBudgetPurposeTypeDetail</c> table record.
    /// </param>
    /// <param name="_positionForecastBudgetAcctLine">
    /// The <c>HcmPositionForecastBudgetAcctLine</c> table record.
    /// </param>
    /// <param name="_defaultValues">
    /// A Boolean optional value that sets the default date values to the <c>HcmPositionForecastBudgetAcctLine</c> table.
    /// </param>
    public void setPositionForecastBudgetAcctline(HcmPositionForecastScenarioRecId _positionForecastScenario,
                                                    HcmBudgetPurposeTypeDetail _budgetPurposeTypeDetail,
                                                    HcmPositionForecastBudgetAcctLine _positionForecastBudgetAcctLine,
                                                    boolean _defaultValues = true)
    {
        super(_positionForecastScenario, _budgetPurposeTypeDetail, _positionForecastBudgetAcctLine, _defaultValues);

        _positionForecastBudgetAcctLine.IsSystemGenerated = true;

        // Set initial dates based on the rate and cost element start and end date range
        _positionForecastBudgetAcctLine.EffectiveDate = max(compRateStartDate, _budgetPurposeTypeDetail.EffectiveDate);
        _positionForecastBudgetAcctLine.ExpirationDate = min(compRateEndDate, _budgetPurposeTypeDetail.ExpirationDate);

        if (this.validateBudgetAcctLine(_positionForecastBudgetAcctLine))
        {
            _positionForecastBudgetAcctLine.PositionForecastCompensationGrid = currentCompensationGridId;
            _positionForecastBudgetAcctLine.AmountCur = HcmPositionForecastCompensationGrid::annualizeCompensationAmount(this.parmForecastCompGroupId(), currentCompensationGridId);

            nextLineAdded = true;
        }
        else
        {
            nextLineAdded = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPositionForecastScenarioInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the forecast position scenario detail information related to the compensation increase.
    /// </summary>
    /// <param name="_positionForecastScenarioRecId">
    /// The record Id of the <c>HcmPositionForecastScenario</c> table.
    /// </param>
    private void setPositionForecastScenarioInfo(HcmPositionForecastScenarioRecId _positionForecastScenarioRecId)
    {
        HcmPositionForecastScenario             hcmPositionForecastScenario;
        HcmPositionForecastCompensationGroup    hcmPositionForecastCompensationGroup;

        hcmPositionForecastScenario = HcmPositionForecastScenario::find(_positionForecastScenarioRecId);

        // Set valid date ranges
        this.parmValidDateRangeStart(hcmPositionForecastScenario.getPositionForecastDateRangeStartDate());
        this.parmValidDateRangeEnd(hcmPositionForecastScenario.getPositionForecastDateRangeEndDate());

        // Set legal entity criteria
        this.parmCompanyId(hcmPositionForecastScenario.LegalEntity);

        // Set compensation related information
        if (hcmPositionForecastScenario.CompensationGroupId)
        {
            hcmPositionForecastCompensationGroup = HcmPositionForecastCompensationGroup::findByCompensationGrpIdDataAreaId(hcmPositionForecastScenario.CompensationGroupId,
                                                                                                                           hcmPositionForecastScenario.CompensationGroupDataAreaId);
        }

        this.parmNewPositionForecastScenarioId(_positionForecastScenarioRecId);
        this.parmForecastCompGroupId(hcmPositionForecastCompensationGroup.RecId);
        this.parmForecastCompGridId(hcmPositionForecastScenario.PositionForecastCompensationGrid);
        this.parmEarningCostElementId(hcmPositionForecastCompensationGroup.HcmBudgetPurposeType);

        this.parmFirstIncreaseDate(this.getFirstIncreaseDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>showResultMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the result information after the compensation increase or update completes.
    /// </summary>
    private void showResultMessages()
    {
        MapEnumerator   skippedMapEnumerator;

        setPrefix((strFmt("@Budget:BudgetPlan_PositionForecasting_HcmPositionForecast_GenerateIncreasesValidationMessage",
                    totalPositionForecastScenario - skippedPositionsMap.elements(),
                    totalPositionForecastScenario)));

        // Display all invalid forecast positions with the failure reason.
        skippedMapEnumerator = skippedPositionsMap.getEnumerator();

        while (skippedMapEnumerator.moveNext())
        {
            warning(strFmt("@SYS76785",
                    HcmPositionForecastScenario::getPositionIdBudgetScenarioName(skippedMapEnumerator.currentKey()),
                    skippedMapEnumerator.currentValue()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetAcctLineExpirationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the existing cost line with the proper expiration date.
    /// </summary>
    /// <param name="_newCostLineStartDate">
    /// The start date of the new cost line on forecast position.
    /// </param>
    private void updateBudgetAcctLineExpirationDate(ValidFromDate _newCostLineStartDate)
    {
        HcmBudgetPurposeTypeDetail              budgetPurposetypedetail;
        HcmPositionForecastBudgetAcctLine       positionForecastBudgetAcctLine;

        update_recordset positionForecastBudgetAcctLine
            setting
                ExpirationDate = _newCostLineStartDate - 1
            exists join budgetPurposetypedetail
                where budgetPurposetypedetail.RecId == positionForecastBudgetAcctLine.BudgetPurposeTypeDetail
                    && positionForecastBudgetAcctLine.PositionForecastScenario == this.parmNewPositionForecastScenarioId()
                    && positionForecastBudgetAcctLine.EffectiveDate < _newCostLineStartDate
                    && positionForecastBudgetAcctLine.ExpirationDate >= _newCostLineStartDate
                    && budgetPurposetypedetail.BudgetPurposeType == earningCostElementId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetAcctLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the budget cost line is valid to be added to the forecast position.
    /// </summary>
    /// <param name="_positionForecastBudgetAcctLine">
    /// The record of the <c>HcmPositionForecastBudgetAcctLine</c> table.
    /// </param>
    /// <returns>
    /// true if the budget cost line is valid to be added; otherwise, false.
    /// </returns>
    private boolean validateBudgetAcctLine(HcmPositionForecastBudgetAcctLine _positionForecastBudgetAcctLine)
    {
        boolean isValidCostLine = true;

        if (_positionForecastBudgetAcctLine.ExpirationDate < _positionForecastBudgetAcctLine.EffectiveDate)
        {
            isValidCostLine = false;
        }
        else if (HcmPositionForecastBudgetAcctLine::existOverLappingBudgetElementLegalEntity(_positionForecastBudgetAcctLine.EffectiveDate,
                                                            _positionForecastBudgetAcctLine.ExpirationDate,
                                                            _positionForecastBudgetAcctLine.LegalEntity,
                                                            _positionForecastBudgetAcctLine.PositionForecastScenario,
                                                            this.parmEarningCostElementId(),
                                                            _positionForecastBudgetAcctLine.RecId))
        {
            isValidCostLine = false;
        }
        else if (_positionForecastBudgetAcctLine.ExpirationDate < compRateStartDate ||
                _positionForecastBudgetAcctLine.EffectiveDate > compRateEndDate)
        {
            isValidCostLine = false;
        }

        return isValidCostLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePositionForecastCompChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation checks to verify if a position forecast is valid. If the position forecast is not
    /// valid, the position id and error encountered is stored.
    /// </summary>
    /// <returns>
    /// true if all the validation checks passed, otherwise false.
    /// </returns>
    protected boolean validatePositionForecastCompChange()
    {
        boolean isValid = true;

        if (this.parmIsCompensationIncrease() == false)
        {
            // Check if there is any increase cost line added currently before applying level selection or update
            hasIncreaseCostLine = HcmPositionForecastBudgetAcctLine::existsIncreaseCostLine(this.parmNewPositionForecastScenarioId());
        }

        if (this.parmForecastCompGroupId() == 0 || this.parmForecastCompGridId() == 0)
        {
            isValid = false;
            skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), "@SYP4940008");
        }
        else if (this.parmEarningCostElementId() == 0)
        {
            isValid = false;
            skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), "@SYS4005777");
        }
        else if (HcmPositionForecastBudgetAcctLine::existsRetainFlagOnEarningCostLine(this.parmNewPositionForecastScenarioId(), this.parmEarningCostElementId()))
        {
            isValid = false;

            if (isLevelStepSelection)
            {
                skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), "@SYP4861376");
            }
            else
            {
                skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), strFmt("@SYP4861377", HcmBudgetPurposeType::getPurposebyRecId(this.parmEarningCostElementId())));
            }
        }

        else if ((this.parmIsCompensationIncrease() || hasIncreaseCostLine)
                 && this.parmFirstIncreaseDate() == dateNull())
        {
            isValid = false;
            skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), "@Budget:PositionForecastInvalidCompensationIncreaseDate");
        }
        else if (HcmBudgetPurposeTypeDetail::hasGapWithinDateRange(this.parmCompanyId(),
                                                                   this.parmEarningCostElementId(),
                                                                   this.parmValidDateRangeStart(),
                                                                   this.parmValidDateRangeEnd()))
        {
            isValid = false;
            skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), "@SYP4940035");
        }
        else if (HcmPositionForecastCompensationRate::hasGapWithinDateRange(this.parmForecastCompGroupId(),
                                            this.parmValidDateRangeStart(),
                                            this.parmValidDateRangeEnd()))
        {
            isValid = false;
            skippedPositionsMap.insert(this.parmNewPositionForecastScenarioId(), "@SYP4940012");
        }

        return isValid;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>