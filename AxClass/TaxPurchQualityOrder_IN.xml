<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxPurchQualityOrder_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxPurchQualityOrder_IN</c> class integrates with the calculation of purch tax from the quality order lines.
/// </summary>
class TaxPurchQualityOrder_IN extends Tax
{
    PurchCalcTax_Trans    purchFormLetter;
    MarkupTrans           markupTrans;
    NoYes                 markupAdminister;
    PurchLine             purchLine;
    RefRecId              inventLedgerAccount;
    LedgerVoucher         ledgerVoucher;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount.
    /// </summary>
    /// <returns>
    /// Returns the calculated amount.
    /// </returns>
    public TaxAmount calc()
    {
        TaxAmountCur   taxAmount;
        boolean        moreLines;
        Amount         baseAmount;
        AmountCur      baseAmountInclTax;
        boolean        amountsInclTaxExist;
        SysTmpRecIdMap amountInclTax = SysTmpRecIdMap::construct(Types::Real);
        SysTmpRecIdMap amountExclTax = SysTmpRecIdMap::construct(Types::Real);
        RecId          adjustRecId[];
        AmountCur      pennyDiff[];
        RefTableId               adjustedTableId[];
        Counter        counter;
        Counter        counterMax;
        TableId        qualityOrderTableId;
        DiscPct        cashDisc = purchFormLetter.taxCashDiscPercent();
        Currency       sourceCurrency;
        TaxCalculationAdjustment taxCalculationAdjustment;

        if (!headingRecId)
        {
            return 0;
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        sourceCurrency = this.getSourceCurrency();

        purchFormLetter.initCursorMarkupHeader(purchFormLetter.tableId(),
                                               purchFormLetter.recID());

        purchFormLetter.initCursor();
        moreLines = true;

        while (moreLines)
        {
            purchLine            = purchFormLetter.nextLine();
            inventQualityOrderTable = InventQualityOrderTable::findSalesPurchRefTransId_IN(purchLine.InventTransId, InventTestReferenceType::Purch);

            if (purchLine.RecId)
            {
                if (!purchFormLetter.isNewLine())
                {
                    continue;
                }

                baseAmount        = -purchFormLetter.baseAmount_IN(false);
                baseAmountInclTax = -purchFormLetter.baseAmountInclTax_IN();

                if (baseAmountInclTax != baseAmount)
                {
                    amountInclTax.insert(purchLine.RecId, baseAmountInclTax);
                    amountExclTax.insert(purchLine.RecId, baseAmount);
                    amountsInclTaxExist = true;
                }

                if (this.taxParameters().TaxLessCashDisc)
                {
                    baseAmount -= baseAmount * cashDisc / 100;
                }

                qualityOrderTableId = this.sourceTableId();

                this.parmAssessableValue_IN(purchFormLetter.assessableValue_IN());
                this.parmMaximumRetailPrice_IN(purchFormLetter.maximumRetailPrice_IN());
                this.insertLineInInternal(baseAmount,
                                          purchFormLetter.destructiveQty_IN(),
                                          purchFormLetter.transPurchUnit(),
                                          purchFormLetter.transItemId(),
                                          purchFormLetter.transPcsPrice(),
                                          purchLine.DefaultDimension,
                                          purchFormLetter.operationAccount(),
                                          purchFormLetter.operationPosting());

                if (taxCalculateLine)
                {
                    taxAmount = this.calcTax();
                    this.saveInProcessTransaction();

                    if  (!taxCalculateTotal
                        && (purchFormLetter.exchRate(taxDate)         != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate)
                        || purchFormLetter.exchRateSecondary(taxDate) != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate)
                        || purchFormLetter.triangulation(taxDate)     != Currency::triangulation(sourceCurrencyCode, taxDate)))
                    {
                        this.adjustAmount(purchFormLetter.exchRate(taxDate),purchFormLetter.exchRateSecondary(taxDate));
                    }
                }
            }
            else
            {
                moreLines = false;
            }
        }

        if (taxCalculateTotal)
        {
            this.insertTotalInInternal(cashDisc);
            taxAmount = this.calcTax();
            this.saveTotalInProcessTransaction();
        }

        if (amountsInclTaxExist)
        {
            while select sum(SourceTaxAmountCur)
                from taxWorkTrans
                group by SourceRecId
                where taxWorkTrans.SourceTableId == qualityOrderTableId
                   && taxWorkTrans.TaxDirection  != TaxDirection::UseTax
                   && taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed
            {
                amountInclTax.insert(taxWorkTrans.SourceRecId, sourceCurrency.amount_Instance(amountInclTax.lookup(taxWorkTrans.SourceRecId)));

                if (amountInclTax.lookup(taxWorkTrans.SourceRecId)
                    && amountExclTax.lookup(taxWorkTrans.SourceRecId) + taxWorkTrans.SourceTaxAmountCur != amountInclTax.lookup(taxWorkTrans.SourceRecId))
                {
                    counterMax++;
                    adjustRecId[counterMax]     = taxWorkTrans.SourceRecId;
                    adjustedTableId[counterMax] = taxWorkTrans.SourceTableId;
                    pennyDiff[counterMax]   = amountExclTax.lookup(taxWorkTrans.SourceRecId)
                                              + taxWorkTrans.SourceTaxAmountCur
                                              - amountInclTax.lookup(taxWorkTrans.SourceRecId);
                }
            }

            if (counterMax)
            {
                for (counter = 1; counter <= counterMax; counter++)
                {
                    this.adjustPennyDiff(pennyDiff[counter], adjustedTableId[counter], adjustRecId[counter]);
                }
            }
        }

        if (taxCalculateTotal)
        {
            if (purchFormLetter.exchRate(taxDate)             != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate)
                || purchFormLetter.exchRateSecondary(taxDate) != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate)
                || purchFormLetter.triangulation(taxDate)     != Currency::triangulation(sourceCurrencyCode, taxDate))
            {
                this.adjustAmount(purchFormLetter.exchRate(taxDate),purchFormLetter.exchRateSecondary(taxDate));
            }

            this.adjustTaxInCostPrice(0);
        }

        this.roundTaxOnTaxGroup();

        taxCalculationAdjustment = TaxCalculationAdjustment::construct(taxWorkTrans, this);
        if (taxCalculationAdjustment)
        {
            taxCalculationAdjustment.loadTaxAdjustments();
        }

        taxAmount = this.totalTaxAmount();

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets currency code.
    /// </summary>
    /// <returns>
    /// The instance of the <c>CurrencyCode</c> class.
    /// </returns>
    public CurrencyCode currencyCode()
    {
        return Ledger::accountingCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exciseTaxCalculationdate_IN</Name>
				<Source><![CDATA[
    protected TransDateTime exciseTaxCalculationdate_IN(RefRecId _sourceRecId,
                                                        TableId _sourceTableId)
    {
        TransDateTime                   taxCalculationDateTime;
        VendorCalculationDateType_IN    vendorCalculationDateType   = this.taxParameters().VendorCalculationDateType_IN;
        InventQualityOrderTable         inventQualityOrderTableLoc;

        if (_sourceTableId == tableNum(InventQualityOrderTable))
        {
            inventQualityOrderTableLoc = InventQualityOrderTable::findSalesPurchRefTransId_IN(purchLine.InventTransId, InventTestReferenceType::Purch);

            switch (vendorCalculationDateType)
            {
                case VendorCalculationDateType_IN::DeliveryDate:
                    if (inventQualityOrderTableLoc.ValidateDate_IN)
                    {
                        taxCalculationDateTime = DateTimeUtil::newDateTime(inventQualityOrderTable.ValidateDate_IN, 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                    else
                    {
                        taxCalculationDateTime = DateTimeUtil::newDateTime(purchFormLetter.deliveryDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                    break;

                case VendorCalculationDateType_IN::DocumentDate:
                    if (inventQualityOrderTableLoc.ValidateDate_IN)
                    {
                        taxCalculationDateTime = DateTimeUtil::newDateTime(inventQualityOrderTable.ValidateDate_IN, 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                    else
                    {
                        taxCalculationDateTime = DateTimeUtil::newDateTime(purchFormLetter.documentDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                    break;

                case VendorCalculationDateType_IN::InvoiceDate:
                    taxCalculationDateTime = DateTimeUtil::newDateTime(purchFormLetter.invoiceDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                    break;
            }
        }

        return taxCalculationDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance <c>TaxPurchQualityOrder_IN</c> for given parameter.
    /// </summary>
    /// <param name="_purchFormLetter">
    /// A instance of <c>PurchCalcTax_TransQualityOrder_IN</c>.
    /// </param>
    public void init(PurchCalcTax_TransQualityOrder_IN  _purchFormLetter)

    {
        boolean                      moreLines;
        PurchTable                   purchTable;
        PurchParameters              purchParameters;
        VendorCalculationDateType_IN vendTaxCalculationDateType = TaxParameters::find().VendorCalculationDateType_IN;

        purchFormLetter    = _purchFormLetter;

        taxModuleType      = TaxModuleType::Purch;
        headingTableId     = inventQualityOrderTable.TableId;
        headingRecId       = inventQualityOrderTable.RecId;
        purchTable         = PurchTable::findRecId(purchFormLetter.recID());
        sourceCurrencyCode = purchFormLetter.currencyCode();
        triangulation      = purchFormLetter.triangulation(purchFormLetter.invoiceDate());

        purchFormLetter.initCursorMarkupHeader(purchFormLetter.tableId(),
                                               purchFormLetter.recID());

        purchFormLetter.initCursor();

        documentStatus  = purchFormLetter.parmDocumentStatus_IN();
        purchParameters = PurchParameters::find();

        moreLines = true;

        switch (vendTaxCalculationDateType)
        {
            case VendorCalculationDateType_IN::DeliveryDate:
                taxDate = purchFormLetter.deliveryDate();
                break;

            case VendorCalculationDateType_IN::DocumentDate:
                taxDate = purchFormLetter.documentDate();
                break;

            case VendorCalculationDateType_IN::InvoiceDate:
                taxDate = purchFormLetter.invoiceDate();
                break;
        }

        while (moreLines)
        {
            purchLine               = purchFormLetter.nextLine();
            inventQualityOrderTable = InventQualityOrderTable::findSalesPurchRefTransId_IN(purchLine.InventTransId, InventTestReferenceType::Purch);

            if (purchLine.RecId)
            {
                if (!purchFormLetter.isNewLine())
                {
                    continue;
                }

                this.insertIntersection(purchFormLetter.transTaxGroup(),
                                        purchFormLetter.transTaxItemGroup(),
                                        purchFormLetter.transTransId(),
                                        purchFormLetter.transItemId(),
                                        taxDate);

                if (! this.checkTaxCodesByLine())
                {
                    throw error("@SYS22772");
                }

                if (!skipLineMarkup)
                {
                    this.markup(purchFormLetter.transTransId());
                }
            }
            else
            {
                moreLines = false;
            }
        }

        if (!this.checkTaxCodesInTotal())
        {
            throw error("@SYS22772");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts intersection.
    /// </summary>
    /// <param name="_taxGroup">
    /// The tax group.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The tax item group.
    /// </param>
    /// <param name="_inventTransId">
    /// The invent transaction id.
    /// </param>
    /// <param name="_txt">
    /// The instance of the <c>Name</c> class.
    /// </param>
    /// <param name="_taxCalculationDate">
    /// The tax calculation date.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice id.
    /// </param>
    /// <param name="_gsthstTaxType_CA">
    /// The gsthst tax type.
    /// </param>
    public void insertIntersection(TaxGroup                 _taxGroup,
                                      TaxItemGroup          _taxItemGroup,
                                      InventTransId         _inventTransId,
                                      TransactionTextlarge  _txt,
                                      TransDate             _taxCalculationDate,
                                      InvoiceId             _invoiceId = '',
                                      GSTHSTTaxType_CA      _gsthstTaxType_CA = GSTHSTTaxType_CA::None)
    {
        TaxGroupData taxGroupData;
        TaxOnItem    taxOnItem;
        boolean      found;
        Set          taxCodeCombination = new Set(Types::String);
        boolean      commonTaxCode = false;
        TaxType_IN   taxType;

        ttsbegin;

        while select TaxCode
            from taxGroupData
            where taxGroupData.TaxGroup  == _taxGroup
            join  TaxCode from taxOnItem
            where taxOnItem.TaxItemGroup == _taxItemGroup
               && taxOnItem.TaxCode      == taxGroupData.TaxCode
            {
                taxType = TaxTable::find(taxOnItem.TaxCode).TaxType_IN;

                if (!commonTaxCode && taxType != TaxType_IN::None)
                {
                    commonTaxCode = true;
                    found = true;
                    this.insertIntersection_IN(_taxGroup, _taxItemGroup, _inventTransId, _txt, _taxCalculationDate, _invoiceId);
                }
            }

        if (!found
            && (markupTrans.taxCombinationAllowed())
            && (this.taxCombinationAllowed())
            && (_taxGroup || _taxItemGroup))
        {
            switch (this.taxParameters().CheckIntersection)
            {
                case CheckTaxGroups::Warning :
                    warning(strFmt("@Tax:Validation_GroupItemGroupIntersectionInvalid", _taxGroup, _taxItemGroup));
                    break;

                case CheckTaxGroups::Error :
                    throw error(strFmt("@Tax:Validation_GroupItemGroupIntersectionInvalid", _taxGroup, _taxItemGroup));

                default :
                    break;
            }
        }

        update_recordset taxWorkTrans
            setting TaxCodeCombinationId = this.findTaxCodeCombinationId(taxCodeCombination)
            where taxWorkTrans.HeadingRecId == headingRecId
                && taxWorkTrans.HeadingTableId == headingTableId
                && taxWorkTrans.SourceTableId == this.sourceTableId()
                && taxWorkTrans.SourceRecId == this.sourceRecId();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLossAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invents loss account.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    public void inventLossAccount(ItemId _itemId)
    {
        inventLedgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventLoss, _itemId));

        if (!inventLedgerAccount)
        {
            throw error("@GLS60830");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">An inventory account type.</param>
    /// <param name="_itemId">An item Id.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingItemLedgerDimensionParameters buildItemLedgerDimensionParameter(
        InventAccountType   _inventAccountType,
        ItemId              _itemId)
    {
        return InventPostingItemLedgerDimensionParameters::newFromParameters(_inventAccountType, _itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts all intersections.
    /// </summary>
    /// <param name="_inventTransId">
    /// The invent transaction id.
    /// </param>
    protected void markup(InventTransId _inventTransId)
    {
        NoYes                  moreMarkup;
        TransDate              taxCalculationDate;
        TaxCalculationDateType taxCalculationDateType = TaxParameters::find().TaxCalculationDateType;

        taxDate = purchFormLetter.invoiceDate();

        moreMarkup = true;

        while (moreMarkup)
        {
            markupTrans = purchFormLetter.nextMarkupLine();

            if (markupTrans)
            {
                markupAdminister = NoYes::Yes;

                switch (taxCalculationDateType)
                {
                    case TaxCalculationDateType::DeliveryDate:
                        taxCalculationDate = purchFormLetter.deliveryDateMarkup();
                        break;

                    case TaxCalculationDateType::DocumentDate:
                        taxCalculationDate = purchFormLetter.documentDate();
                        break;

                    case TaxCalculationDateType::InvoiceDate:
                        taxCalculationDate = purchFormLetter.invoiceDate();
                        break;
                }

                this.insertIntersection('',
                                        '',
                                        _inventTransId,
                                        markupTrans.Txt,
                                        taxCalculationDate);

                if (!this.checkTaxCodesByLine())
                {
                    throw error("@SYS22772");
                }
            }
            else
            {
                markupAdminister = NoYes::No;
                moreMarkup       = false;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(
        InventQualityOrderTable _inventQualityOrderTable,
        SalesQty                _salesQty,
        LedgerVoucher           _ledgerVoucher = null)
    {
        super();

        inventQualityOrderTable = _inventQualityOrderTable;
        destructiveQty          = _inventQualityOrderTable.Qty;
        lineQty                 = _salesQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts ledger journal transaction.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// A instance of <c>LedgerPostingController</c>.
    /// </param>
    /// <param name="_taxTrans">
    /// A instance of <c>TaxTrans</c>.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_chargeAmount">
    /// The charge amount.
    /// </param>
    /// <param name="_exchRateHelper">
    /// A instance of <c>CurrencyExchangeHelper</c>.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_operationLedgerDimension">
    /// The operation ledger dimension.
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    /// The tax offset ledger dimension.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level; optional.
    /// </param>
    /// <param name="_projLedger">
    /// The project ledger; optional.
    /// </param>
    /// <param name="_offsetLedgerDimension">
    /// The offset ledger dimension; optional.
    /// </param>
    /// <param name="_amountMSTSecondary">
    /// The secondary amount MST; optional.
    /// </param>
    protected void post(LedgerPostingController _ledgerPostingController,
                        TaxTrans                _taxTrans,
                        TaxAmount               _taxAmount,
                        TaxAmount               _chargeAmount,
                        CurrencyExchangeHelper  _exchRateHelper,
                        LedgerDimensionAccount  _ledgerDimension,
                        LedgerDimensionAccount  _operationLedgerDimension,
                        LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                        LedgerDetailLevel       _ledgerDetailLevel = LedgerDetailLevel::AsDefault,
                        ProjLedger              _projLedger = null,
                        LedgerDimensionAccount  _offsetLedgerDimension = 0,
                        AmountMSTSecondary      _amountMSTSecondary    = 0)
    {
        LedgerVoucherTransObject            ledgerVoucherTransObject;
        AmountCur                           postingAmountCur;
        LedgerPostingType                   ledgerPostingTypeQM;

        if (! this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax)
        {
            if (taxPostingType == LedgerPostingType::VAT_IN)
            {
                postingAmountCur    = (_taxAmount - _chargeAmount);
                ledgerPostingTypeQM = taxPostingType;
            }
            else if (taxPostingType == LedgerPostingType::Excise_IN)
            {
                postingAmountCur    = (_taxAmount - _chargeAmount);
                ledgerPostingTypeQM = LedgerPostingType::Excise_IN;
            }
            else
            {
                postingAmountCur    = ((_taxAmount - _chargeAmount)* -1);
                ledgerPostingTypeQM = LedgerPostingType::InventLoss;
            }

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                             ledgerPostingTypeQM,
                                                                                             LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimension),
                                                                                             sourceCurrencyCode,
                                                                                             postingAmountCur,
                                                                                             _exchRateHelper);

            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
            }
            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postHandleExciseAmountRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts handle excise amount register.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// The excise taxable tax model.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_register">
    /// The tax excise amount register.
    /// </param>
    /// <param name="_taxTransIN">
    /// The tax transaction.
    /// </param>
    protected void postHandleExciseAmountRegister_IN(
        TaxModelExciseTaxable_IN    _taxModelExciseTaxable,
        TaxTrans                    _taxTrans,
        TaxExciseAmountRegister_IN  _register,
        TaxTrans_IN                 _taxTransIN)
    {
        _register.selectForUpdate(true);
        _register.TaxTrans_IN = _taxTransIN.RecId;
        _register.rgDate      = _taxTransIN.TransDate;
        _register.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postHandleExciseQuantityRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts handle excise quantity register.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// The excise taxable tax model.
    /// </param>
    /// <param name="_register">
    /// The tax excise quantity register.
    /// </param>
    /// <param name="_taxTransIN">
    /// The tax transaction.
    /// </param>
    protected void postHandleExciseQuantityRegister_IN(
        TaxModelExciseTaxable_IN        _taxModelExciseTaxable,
        TaxExciseQuantityRegister_IN    _register,
        TaxTrans_IN                     _taxTransIN)
    {
        _register.selectForUpdate(true);
        _register.TaxTrans_IN = _taxTransIN.RecId;
        _register.rgDate      = _taxTransIN.TransDate;
        _register.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Save and post.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_inventQualityOrderTable">
    /// The invent quality order table.
    /// </param>
    public void saveAndPost(
        LedgerPostingController _ledgerPostingController,
        InventQualityOrderTable _inventQualityOrderTable = null)
    {
        TaxTrans                     taxTrans;
        TaxAmountCur                 taxAmountCur;
        TaxAmountCur                 totalLoadOnInventoryAmt;
        TaxAmountCur                 taxInCostPrice;
        TaxAmountCur                 totalTaxAmount;
        CurrencyExchangeHelper       exchangeRateHelper;
        TaxTable                     taxTableLoc;
        RefRecId                     ledgerDimension;
        SalesPurchJournalLine        salesPurchJournalLine;
        VendorCalculationDateType_IN vendorCalculationDateType = TaxParameters::find().VendorCalculationDateType_IN;
        TaxTrans_W taxTrans_W;

        this.validate_IN();
        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        if (!this.checkTaxCodesByOperationAccount())
        {
            throw error("@SYS18447");
        }

        ttsbegin;

        while select
            sum(TaxBaseAmount),
            sum(TaxBaseAmountCur),
            sum(TaxBaseQty),
            sum(TaxAmount),
            sum(TaxAmountCur),
            sum(TaxInCostPrice),
            sum(TaxInCostPriceMST),
            sum(TaxInCostPriceCur),
            sum(SourceTaxAmountCur),
            sum(SourceBaseAmountCur),
            sum(SourceRegulateAmountCur),
            sum(TaxInCostPriceRegulated),
            sum(AbatementAmount_IN),
            sum(SourceBaseAmountCurRegulated),
            NegativeTax
        from taxWorkTrans
        group by Voucher, TransDate, InventTransId, TaxCode, CurrencyCode, TaxDirection, ExemptTax, TaxOrigin,
               LedgerDimension, TaxOffsetUseTaxLedgerDimension, Source, SourceCurrencyCode, TaxAutogenerated,
               TaxReports,  OperationLedgerDimension, TaxRefId, TaxGroup, TaxItemGroup, euroTriangulation,
               CalculationDate, IntracomVAT, NegativeTax, Warning, SourceTableId, SourceRecId
        where taxWorkTrans.HeadingRecId == headingRecId
           && taxWorkTrans.SourceRecId  == _inventQualityOrderTable.RecId
           && taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed
        {
            taxTableLoc = TaxTable::find(taxWorkTrans.TaxCode);

            if (taxWorkTrans.TaxCode)
            {
                taxTrans.clear();

                this.initFromTaxWorkTrans(taxTrans, taxWorkTrans, this.taxOrigin(taxWorkTrans.TaxOrigin));

                if (!taxWorkTrans.TaxAutogenerated)
                {
                    taxTrans.TaxAutogenerated = NoYes::No;
                }

                taxTrans.euroTriangulation = triangulation;
                taxTrans.TaxOrigin         = this.taxOrigin(taxWorkTrans.TaxOrigin);
                taxTrans.Voucher           = voucher;
                taxTrans.JournalNum        = this.journalNum();

                if (!taxTrans.TaxAutogenerated)
                {
                    taxAmountCur = taxTrans.SourceRegulateAmountCur;
                    taxInCostPrice = taxTrans.TaxInCostPriceRegulated;
                    this.taxAmountRegulation(taxTrans,
                                             taxTrans.SourceRegulateAmountCur,
                                             this.exchRate(),
                                             this.exchRateSecondary());
                    this.taxInCostPriceReporting(taxTrans,
                                                 taxTrans.TaxInCostPriceRegulated,
                                                 this.exchRate(),
                                                 this.exchRateSecondary());
                }
                else
                {
                    taxAmountCur   = taxTrans.SourceTaxAmountCur;
                    taxInCostPrice = taxTrans.TaxInCostPrice;
                }

                this.initTaxTrans(taxTrans, _ledgerPostingController.getJournal().parmVoucherSeriesCode());

                if (taxTableLoc.TaxType_IN != TaxType_IN::None)
                {
                    taxTrans_W = taxTrans.taxTrans_W();
                    abatementAmount               = taxWorkTrans.AbatementAmount_IN;
                    salesPurchJournalLine         = this.getSalesPurchJournalLineFromInventId_IN();
                    taxTrans.TaxValue             = taxWorkTrans.showTaxValue_IN(salesPurchJournalLine);
                    taxTrans.SourceTableId        = _inventQualityOrderTable.TableId;
                    taxTrans.SourceRecId          = _inventQualityOrderTable.RecId;
                    taxTrans_W.TaxComponentTable_IN = taxTableLoc.TaxComponentTable_IN;
                    taxTrans.packTaxTrans_W(taxTrans_W);
                }

                if (taxModuleType   == TaxModuleType::PurchInvoice
                   || taxModuleType == TaxModuleType::Purch)
                {
                    if (taxTableLoc.TaxType_IN != TaxType_IN::None
                        && ((taxTableLoc.TaxType_IN == TaxType_IN::Customs          && isCustomsEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::Excise        && isExciseEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::SalesTax      && isSalesTaxEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax    && isServiceTaxEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::VAT           && isVATEnabled)))
                    {
                        totalLoadOnInventoryAmt += !taxTrans.TaxAutogenerated
                                                   ? taxTrans.TaxInCostPriceRegulated
                                                   : taxTrans.TaxInCostPrice;
                    }
                }

                taxTrans_W = taxTrans.taxTrans_W();
                taxTrans_W.TaxRegistrationNumberTable_IN = this.getTaxRegistrationNumber_IN(taxTableLoc.TaxType_IN, salesPurchJournalLine);
                taxTrans.packTaxTrans_W(taxTrans_W);

                this.getPostingType_IN(taxTableLoc.TaxType_IN);

                if (isExciseEnabled
                    && taxTableLoc.TaxType_IN == TaxType_IN::Excise)
                {
                    ledgerDimension      = this.getSettledExcisePayableAcc_IN(taxTrans);
                }

                taxTrans.insert();

                if (taxWorkTrans.ExemptTax == NoYes::No
                    && taxAmountCur)
                {
                    exchangeRateHelper.parmExchangeRate1(exchRate);
                    exchangeRateHelper.parmExchangeRate2(exchRateSecond);
                    exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);
                    totalTaxAmount += taxAmountCur;
                    this.post(_ledgerPostingController,
                              taxTrans,
                              taxAmountCur,
                              taxInCostPrice,
                              exchangeRateHelper,
                              taxWorkTrans.LedgerDimension,
                              taxWorkTrans.OperationLedgerDimension,
                              taxWorkTrans.TaxOffsetUseTaxLedgerDimension,
                              LedgerDetailLevel::AsDefault);
                }
            }

            if (taxTableLoc.TaxType_IN != TaxType_IN::None)
            {
                this.insertTaxTrans_IN(taxTrans, salesPurchJournalLine);
            }

            if (taxTableLoc.TaxType_IN == TaxType_IN::Excise)
            {
                this.updateExciseRegister_IN(taxTrans, _inventQualityOrderTable);
            }
        }

        if (totalTaxAmount && inventLedgerAccount)
        {
            taxPostingType = LedgerPostingType::InventLoss;
            this.post(_ledgerPostingController,
                      taxTrans,
                      totalTaxAmount,
                      totalLoadOnInventoryAmt,
                      exchangeRateHelper,
                      inventLedgerAccount,
                      0,
                      0);
        }

        TaxCalculationAdjustment::deleteTaxRegulation(this);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRelatedVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets related voucher object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher.
    /// </param>
    public void setRelatedVoucherObject(LedgerVoucher _ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoucherId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets voucher id.
    /// </summary>
    /// <param name="_voucherId">
    /// The voucher id.
    /// </param>
    /// <returns>
    /// The instance of the <c>Voucher</c> class.
    /// </returns>
    public Voucher setVoucherId(Voucher _voucherId)
    {
        voucher = _voucherId;

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    public RecId sourceRecId()
    {
        if (markupAdminister)
        {
            return markupTrans.RecId;
        }
        else
        {
            return inventQualityOrderTable.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    public RefTableId sourceTableId()
    {
        if (markupAdminister)
        {
            return markupTrans.TableId;
        }
        else
        {
            return inventQualityOrderTable.TableId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCombinationAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tax combination is allowed.
    /// </summary>
    /// <returns>
    /// If 'True', the tax combination is allowed.
    /// </returns>
    public boolean taxCombinationAllowed()
    {
        MarkupTable markupTable;

        markupTable = markupTrans.markupTable();

        if (markupTable.CustType == MarkupType::Item
            || markupTable.VendType == MarkupType::LedgerAccount)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSalesTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method returns a Boolean value that indicates whether the current transaction being calculated
    ///    supports sales tax adjustments.
    /// </summary>
    /// <returns>
    ///    return true always.
    /// </returns>
    /// <remarks>
    ///    By default, the current transaction supports sales tax adjustments.
    /// </remarks>
    public boolean useSalesTaxAdjustments()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance <c>TaxPurchQualityOrder_IN</c> for given parameters.
    /// </summary>
    /// <param name="_inventQualityOrderTable">
    /// A instance of <c>InventQualityOrderTable</c>.
    /// </param>
    /// <param name="_vendInvoiceInfoLine">
    /// A instance of <c>VendInvoiceInfoLine</c>; optional.
    /// </param>
    /// <returns>
    /// A new instance <c>TaxPurchQualityOrder_IN</c>
    /// </returns>
    public static TaxPurchQualityOrder_IN construct(InventQualityOrderTable  _inventQualityOrderTable, VendInvoiceInfoLine _vendInvoiceInfoLine = null)
    {
        TaxPurchQualityOrder_IN             qualityOrderTax;
        PurchTable                          purchTableLoc;
        PurchTotals                         purchTotals;
        PurchLine                           purchLineLoc;
        PurchCalcTax_TransQualityOrder_IN   purchForm;

        purchTableLoc   = PurchTable::find(_inventQualityOrderTable.InventRefId);
        purchLineLoc    = PurchLine::findInventTransId(_inventQualityOrderTable.InventRefTransId);

        qualityOrderTax = new TaxPurchQualityOrder_IN(_inventQualityOrderTable, purchLineLoc.PurchQty);

        purchForm = new PurchCalcTax_TransQualityOrder_IN(purchTableLoc);
        purchForm.parmVendInvoiceInfoLine(_vendInvoiceInfoLine);
        purchTotals = PurchTotals_Trans::construct(purchTableLoc, PurchUpdate::All);
        purchForm.setPurchTotals_IN(purchTotals);
        qualityOrderTax.init(purchForm);

        return qualityOrderTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs and runs a MenuFuntion to form <c>TaxTmpWorkQualityOrder_IN</c> for given parameter.
    /// </summary>
    /// <param name="_inventQualityOrderTable">
    /// A instance of <c>InventQualityOrderTable</c>.
    /// </param>
    /// <returns>
    /// Returns a FormRun.
    /// </returns>
    static FormRun showTax(InventQualityOrderTable _inventQualityOrderTable)
    {
        TaxPurchQualityOrder_IN purchQualityOrderTax;

        purchQualityOrderTax = TaxPurchQualityOrder_IN::construct(_inventQualityOrderTable);
        purchQualityOrderTax.calc();
        return Tax::showTaxes(menuitemDisplayStr(TaxTmpWorkQualityOrder_IN), purchQualityOrderTax, _inventQualityOrderTable);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>