<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecute</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkExecute</c> class contains the work execution logic.
/// </summary>
public class WhsWorkExecute
{
    #ISOCountryRegionCodes

    WMSLocationId           anchoringFromLocation;
    WHSAnchor               doAnchor;
    WHSAnchorBy             anchorBy;
    InventDimParm           dimParm;
    InventCostOnhandCache	inventCostOnhandCache;
    boolean                 skipWorkTableStatusUpdate;
    RecordInsertList        rilWHSWorkTrans;
    boolean                 useInsertListForWorkTrans;
    private Map				itemIsDimTrackingControlledCache    = new Map(Types::String, Types::Enum);
    private LineNum         warehouseTransferWorkLineNumCounter = 1;
    Set                     checkedInventBatch                  = new Set(Types::Int64);

    private WHSInstrumentationLogger instrumentationLogger;
    private boolean                  autoReallocationRequired;
    private WHSItemReallocation      reallocationProcess;
    private container                scannedCatchWeightTags;
    private boolean                  wasLPWorkCreationAttempted = false;
    private WMSLocationId            defaultReceivingLocationId;
    private InventLocationId         defaultInventLocationId;
    private InventGTDId_RU           inventGTDId;    
    private WMSLocationId            selectedLocationId;
    private boolean                  manualReallocationSelected;
    private boolean                  isGroupPickEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WhsWorkExecute construct()
    {
        return new WhsWorkExecute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWasLPWorkCreationAttempted</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmWasLPWorkCreationAttempted()
    {
        return wasLPWorkCreationAttempted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultReceivingLocationId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WMSLocationId parmDefaultReceivingLocationId(WMSLocationId _wmsLocationId = defaultReceivingLocationId)
    {
        defaultReceivingLocationId = _wmsLocationId;
        return defaultReceivingLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustContainerHandlingQuantity</Name>
				<Source><![CDATA[
    private void adjustContainerHandlingQuantity(
        WHSWorkLine				_workLine,
        InventHandlingQty		_handlingQty)
    {
        // Check to see if there is a container, and if so, decrease it's container line qty.
        if (_workLine.ContainerId)
        {
            WHSContainerLine::adjustQuantityBasedOnWorkLine(_workLine, _handlingQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the container line being adjusted is for a catch weight item, and adjusts the container accordingly.
    /// </summary>
    /// <param name="_workLine">
    /// The work line that is being updated.
    /// </param>
    /// <param name="_handlingQty">
    /// The quantity to be updated in the inventory handling unit.
    /// </param>
    /// <param name="_handlingUnitId">
    /// The handling unit of measure.
    /// </param>
    final protected internal void adjustContainer(
        WHSWorkLine				_workLine,
        InventHandlingQty		_handlingQty,
        InventHandlingUnitId	_handlingUnitId)
    {
        this.adjustContainerHandlingQuantity(_workLine, _handlingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLoadLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the load that is tied to a work line with a quantity update.
    /// </summary>
    /// <param name="_workLine">
    /// The work line that is being updated
    /// </param>
    /// <param name="_handlingQty">
    /// The quantity to update by in inventory handling units.
    /// </param>
    /// <param name="_updateLoadLineQty">
    /// Update the shipment quantity.
    /// </param>
    private void adjustLoadLineQuantities(
        WHSWorkLine			_workLine,
        InventHandlingQty	_handlingQty,
        boolean             _updateLoadLineQty = false)
    {
        // Check to see if there's a load, and if so adjust the work created quantity.
        if (_workLine.LoadLineRefRecId != 0)
        {
            this.decreaseCrossDockLoadLineQtyWhenDecreasingLoadLineWorkCreatedQty(_workLine, _handlingQty);

            if (_updateLoadLineQty)
            {
                WHSLoadLine::updateWorkCreatedQtyAndQty(_workLine.LoadLineRefRecId, _handlingQty, _workLine.InventDimId);
            }
            else
            {
                WHSLoadLine::updateWorkCreatedQty(_workLine.LoadLineRefRecId, _handlingQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>decreaseCrossDockLoadLineQtyWhenDecreasingLoadLineWorkCreatedQty</Name>
				<Source><![CDATA[
    private void decreaseCrossDockLoadLineQtyWhenDecreasingLoadLineWorkCreatedQty(WHSWorkLine _workLine, InventHandlingQty _adjustLoadLineWorkCreatedQty)
    {
        if (_workLine.whsWorkTable().WorkTransType == WHSWorkTransType::CrossDocking
                && _workLine.InventTransOriginIdSupply
                && _adjustLoadLineWorkCreatedQty < 0)
        {
            WHSCrossDockLoadLine::updateQuantityForCrossDockLoadLine(_workLine.LoadLineRefRecId, _workLine.InventTransOriginIdSupply, -_adjustLoadLineWorkCreatedQty);
                    
            WHSLoadLine loadLine = WHSLoadLine::findbyRecId(_workLine.LoadLineRefRecId, true);

            loadLine.CrossDockEvaluatedQuantity = max(loadLine.CrossDockEvaluatedQuantity + _adjustLoadLineWorkCreatedQty, 0);
            loadLine.update();
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustOrderTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update order transactions with over picked quantity.
    /// </summary>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_workTransType">
    /// The transaction type of the work.
    /// </param>
    /// <param name="_inventDiffHandlingQty">
    /// The quantity that is being overpicked in handling units.
    /// </param>
    /// <param name="_workLineHandlingQty">
    /// The quantity on the work line in handling units.
    /// </param>
    private void adjustOrderTrans(
        WHSWorkLine			_workLine,
        WHSWorkTransType	_workTransType,
        InventHandlingQty   _inventDiffHandlingQty,
        InventHandlingQty   _workLineHandlingQty)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTransType);

        if (workTransactionType)
        {
            workTransactionType.adjustOrderTrans(_workLine, _inventDiffHandlingQty, _workLineHandlingQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkInventTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the work transaction quantities.
    /// </summary>
    /// <param name="_workLine">
    /// the work line to update.
    /// </param>
    /// <param name="_inventTransId">
    /// The transaction number for the work line.
    /// </param>
    /// <param name="_handlingQty">
    /// The quantity in the handling unit to update by.
    /// </param>
    /// <param name="_userId">
    /// The user who initiated the update.
    /// </param>
    private void adjustWorkInventTransQty(
        WHSWorkLine			_workLine,
        InventTransId		_inventTransId,
        InventHandlingQty	_handlingQty,
        WHSUserId			_userId)
    {
        InventHandlingQty runningQty = _handlingQty;

        ttsbegin;

        // Update WITs from handling unit first, if we're short picking
        if (runningQty < 0 && _workLine.hasHandlingUnitWorkTransaction())
        {
            runningQty = this.adjustHandlingUnitWorkInventTransQty(_workLine, _inventTransId, runningQty, _userId);
        }

        if (runningQty)
        {
            _workLine.adjustWorkInventTransQuantitiesAndToLocation(_inventTransId, runningQty, _userId);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkLineQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the work lines, transactions, load lines, and containers with a quantity change.
    /// </summary>
    /// <param name="_workLine">
    /// The original work line that is being adjusted.
    /// </param>
    /// <param name="_diffHandlingQty">
    /// The quantity the work line is adjusted by in handling units.
    /// </param>
    /// <param name="_handlingUnitId">
    /// The handling unit of measure for the item being adjusted.
    /// </param>
    /// <param name="_userId">
    /// The work user adjusting the work line quantity.
    /// </param>
    /// <param name="_updateLoadLineQuantity">
    /// true if the load line quantity should be updated; otherwise, false.
    /// </param>
    /// <param name="_reallocateWorkLine">
    /// true if the passed work line will be reallocated; otherwise, false.
    /// </param>
    [Wrappable(false)]
    protected void adjustWorkLineQty(
        WHSWorkLine             _workLine,
        InventHandlingQty       _diffHandlingQty,
        InventHandlingUnitId    _handlingUnitId,
        WHSUserId               _userId,
        boolean                 _updateLoadLineQuantity,
        boolean                 _reallocateWorkLine = false)
    {
        WHSWorkLine                         workLine;
        Qty                                 diffQty;
        LineNum                             oppositeLineNum;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter;

        oppositeLineNum = WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, WHSWorkType::Pick);
        releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        // Find the quantity in work units the line that is being adjusted.
        diffQty = releasedProductUnitConverter.convert(_diffHandlingQty,
                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(_handlingUnitId),
                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(_workLine.UnitId),
                                                    NoYes::No,
                                                    _workLine.ItemId,
                                                    _workLine.InventDimId,
                                                    NoYes::No);

        // Work line updates are split out to prevent locking the entire table.
        // Update the current work line
        ttsBegin;
        workLine = WHSWorkLine::find(_workLine.WorkId, _workLine.LineNum, true);

        this.adjustWorkLineQtyUpdateFromHandlingQty(workLine,
                                 _diffHandlingQty,
                                 _handlingUnitId,
                                 diffQty,
                                 _workLine.InventTransId,
                                 _userId,
                                 _updateLoadLineQuantity,
                                 _reallocateWorkLine);

        workLine.clear();

        if (!_reallocateWorkLine)
        {
            // Update subsequent pick/put lines
            while select forUpdate workLine
            where workLine.WorkId   == _workLine.WorkId
            && workLine.LineNum >= oppositeLineNum
            {
                this.adjustWorkLineQtyUpdateFromHandlingQty(workLine,
                                    _diffHandlingQty,
                                    _handlingUnitId,
                                    diffQty,
                                    _workLine.InventTransId,
                                    _userId,
                                    _updateLoadLineQuantity,
                                    false);
            }

            _workLine.adjustFollowingPrintAndCustomLineQuantities(oppositeLineNum - 1, _diffHandlingQty);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkLineQtyUpdateFromHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an item is a catch weight enabled warehouse item and performs work line updates for the passed in work line.
    /// </summary>
    /// <param name="_updWorkLine">
    /// The work line to be  updated.
    /// </param>
    /// <param name="_diffHandlingQty">
    /// The quantity that is being updated in handling units.
    /// </param>
    /// <param name="_handlingUnitId">
    /// The handling unit of measure.
    /// </param>
    /// <param name="_diffQty">
    /// The quantity being updated in the original work line's work unit.
    /// </param>
    /// <param name="_origWorkLineInventTransId">
    /// The original work line that has a quantity adjustment.
    /// </param>
    /// <param name="_userId">
    /// The user who is updating the work line.
    /// </param>
    /// <param name="_updateLoadLineQuantity">
    /// true if the load line quantity should be updated; otherwise, false.
    /// </param>
    /// <param name="_reallocateWorkLine">
    /// true if the passed work line will be reallocated; otherwise, false.
    /// </param>
    public void adjustWorkLineQtyUpdateFromHandlingQty(
        WHSWorkLine             _updWorkLine,
        InventHandlingQty       _diffHandlingQty,
        InventHandlingUnitId    _handlingUnitId,
        Qty                     _diffQty, // diffQty is not used by any supporting process, but retained for extensions on public method
        InventTransId           _origWorkLineInventTransId,
        WHSUserId               _userId,
        boolean                 _updateLoadLineQuantity,
        boolean                 _reallocateWorkLine)
    {
        this.adjustWorkLineUpdate(_updWorkLine,
                _diffHandlingQty,
                _handlingUnitId,
                _origWorkLineInventTransId,
                _userId,
                _updateLoadLineQuantity,
                _reallocateWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkLineUpdate</Name>
				<Source><![CDATA[
    private void adjustWorkLineUpdate(
        WHSWorkLine             _updWorkLine,
        InventHandlingQty       _diffHandlingQty,
        InventHandlingUnitId    _handlingUnitId,
        InventTransId           _origWorkLineInventTransId,
        WHSUserId               _userId,
        boolean                 _updateLoadLineQuantity,
        boolean                 _reallocateWorkLine)
    {
        _updWorkLine.adjustWorkLineQuantities(_diffHandlingQty);

        if (_updWorkLine.WorkType == WHSWorkType::Pick)
        {
            // Update quantity associated WHSWorkInventTransRecords
            this.adjustWorkInventTransQty(_updWorkLine, _origWorkLineInventTransId, _diffHandlingQty, _userId);
        }

        this.adjustLoadLineQuantities(_updWorkLine, _diffHandlingQty, _updateLoadLineQuantity);

        /*
        If it is set to reallocate this work line, the container line quantity
        will be adjusted later, when the quantity that was not possible to reallocate (if any) will have been calculated.
        */
        if (!_reallocateWorkLine)
        {
            this.adjustContainer(_updWorkLine, _diffHandlingQty, _handlingUnitId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkLineQtyUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs work line updates for the pass in work line.
    /// </summary>
    /// <param name="_updWorkLine">
    /// The work line to be  updated.
    /// </param>
    /// <param name="_diffInventQty">
    /// The quantity that is being updated in inventory units.
    /// </param>
    /// <param name="_inventUnitId">
    /// The inventory unit of measure.
    /// </param>
    /// <param name="_diffQty">
    /// The quantity being updated in the original work line's work unit.
    /// </param>
    /// <param name="_origWorkLineInventTransId">
    /// The original work line that has a quantity adjustment.
    /// </param>
    /// <param name="_userId">
    /// The user who is updating the work line.
    /// </param>
    /// <param name="_updateLoadLineQuantity">
    /// true if the load line quantity should be updated; otherwise, false.
    /// </param>
    /// <param name="_reallocateWorkLine">
    /// true if the passed work line will be reallocated; otherwise, false.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the adjustWorkLineQtyUpdateFromHandlingQty method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public void adjustWorkLineQtyUpdate(
        WHSWorkLine         _updWorkLine,
        InventQty           _diffInventQty,
        UnitOfMeasureSymbol _inventUnitId,
        Qty                 _diffQty,
        InventTransId       _origWorkLineInventTransId,
        WHSUserId           _userId,
        boolean             _updateLoadLineQuantity,
        boolean             _reallocateWorkLine = false)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _updWorkLine.ItemId);

        this.adjustWorkLineUpdate(
                _updWorkLine,
                _diffInventQty,
                _inventUnitId,
                _origWorkLineInventTransId,
                _userId,
                _updateLoadLineQuantity,
                _reallocateWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeOverPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Over pick the work line.
    /// </summary>
    /// <param name="_workLine">
    /// The work line to over pick.
    /// </param>
    /// <param name="_workTable">
    /// The work unit to over pick.
    /// </param>
    /// <param name="_qty">
    /// The quantity being picked.
    /// </param>
    /// <param name="_unitId">
    /// The inventory unit of the quantity being picked.
    /// </param>
    /// <param name="_userId">
    /// The user who is over picking.
    /// </param>
    /// <param name="_menuItemName">
    /// The menu item that is being used to execute work.
    /// </param>
    /// <returns>
    /// true if over pick was completed; otherwise, false.
    /// </returns>
    public boolean executeOverPick(
        WHSWorkLine                _workLine,
        WHSWorkTable               _workTable,
        Qty                        _qty,
        UnitOfMeasureSymbol        _unitId,
        WHSUserId                  _userId,
        WHSMenuItemName            _menuItemName)
    {
        boolean ret;

        if (!_workLine.ItemId)
        {
            throw error("@WAX1349");
        }

        WhsrfControlData::validateDecimalPrecision(_qty, _unitId);

        InventHandlingUnitId inventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_workLine.ItemId);

        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        InventHandlingQty inventHandlingQty       = releasedProductUnitConverter.convert(_qty,
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_unitId),
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(inventHandlingUnitId),
                                                        NoYes::No,
                                                        _workLine.ItemId,
                                                        _workLine.InventDimId,
                                                        NoYes::No);

        InventHandlingQty diffInventHandlingQty = inventHandlingQty - _workLine.InventQtyRemain;

        // Check that overpicking is possible
        if (this.validateShippingOverpickHandlingQty(diffInventHandlingQty, _workLine, _workTable))
        {
            ttsbegin;
            // Update the order line and reservation
            this.adjustOrderTrans(_workLine, _workTable.workTransType, diffInventHandlingQty, _workLine.InventQtyWork);

            // Update work lines and associated records with new quantity.
            this.adjustWorkLineQty(_workLine, diffInventHandlingQty, inventHandlingUnitId, _userId, true);
            ttsCommit;

            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addNewWorkTransToInsertList</Name>
				<Source><![CDATA[
    private void addNewWorkTransToInsertList(
        WHSWorkLine         _workLine,
        InventDimId         _inventDimId,
        Qty                 _qty,
        WHSUserId           _userId,
        WHSLicensePlateId   _targetLicensePlateId)
    {
        if (!rilWHSWorkTrans)
        {
            rilWHSWorkTrans = new RecordInsertList(tableNum(WHSWorkTrans));
        }

        rilWHSWorkTrans.add(this.initNewWorkTrans(_workLine, _inventDimId, _qty, _userId, _targetLicensePlateId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>anchorWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Anchors the work lines in a specific location to an anchor location.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the work lines to be anchored.
    /// </param>
    /// <param name="_anchorLocationId">
    /// Anchor location id.
    /// </param>
    /// <param name="_oldLocationId">
    /// Old location id.
    /// </param>
    /// <param name="_anchorBy">
    /// Determines whether work lines will be grouped to anchor by shipment or load.
    /// </param>
    void anchorWork(WHSWorkId _workId, WMSLocationId _anchorLocationId, WMSLocationId _oldLocationId, WHSAnchorBy _anchorBy)
    {
        if (_anchorBy == WHSAnchorBy::Shipment)
        {
            WHSWorkTable workTable = WHSWorkTable::find(_workId);

            Enumerator shipmentIdEnumerator = workTable.shipmentIds().getEnumerator();

            while (shipmentIdEnumerator.moveNext())
            {
                var shipmentId = shipmentIdEnumerator.current();
                WHSWorkTable::anchorRemainingWorkByShipment(shipmentId, _workId, _oldLocationId, _anchorLocationId);
            }
        }
        else if (_anchorBy == WHSAnchorBy::Load)
        {
            WHSWorkLine workLine;

            while select workLine
                    group by workLine.LoadId
                     where workLine.WorkId      == _workId
                        && workLine.WorkType    == WHSWorkType::Pick
                        && workLine.LoadId      != ''
            {
                WHSWorkTable::anchorRemainingWorkByLoad(workLine.LoadId, _workId, _oldLocationId, _anchorLocationId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQtyLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds quantity map of items that have the same license plate.
    /// </summary>
    /// <param name="_qtyMap">
    /// Quantity map to be populated.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id.
    /// </param>
    /// <param name="_inventDim">
    /// Dimensions of the items.
    /// </param>
    public void buildQtyLicensePlate(Map _qtyMap, WHSLicensePlateId _licensePlateId, InventDim _inventDim)
    {
        WHSLicensePlate         licensePlate;
        Map                     qtyMap;

        ttsbegin;

        qtyMap = _qtyMap;

        if (WHSLicensePlate::find(_licensePlateId).LicensePlateLevel == 1)
        {
            WhsWorkExecute::createQuantityMapFromParentLicensePlate(_qtyMap, _licensePlateId, _inventDim);
        }
        else
        {
            while select LicensePlateId from licensePlate
                where licensePlate.LicensePlateParent == _licensePlateId
            {
                this.buildQtyLicensePlate(qtyMap, licensePlate.LicensePlateId, _inventDim);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuantityMapFromParentLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds quantity map of items for the specified <c>InventDim</c> criteria.
    /// </summary>
    /// <param name="_qtyMap">
    /// Quantity map to be populated.
    /// </param>
    /// <param name="_parentLicensePlateId">
    /// parent license plate ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// <c>InventDim</c> criteria for getting the quantities.
    /// </param>
    private static void createQuantityMapFromParentLicensePlate(
        Map					_qtyMap,
        WHSLicensePlateId	_parentLicensePlateId,
        InventDim			_inventDimCriteria)
    {
        ttsbegin;

        InventSum		inventSum;
        InventDim		inventDim;
        InventDimParm	inventDimParm;
        WHSLicensePlate licensePlate;

        inventDimParm.initFromInventDim(_inventDimCriteria);
        inventDimParm.LicensePlateFlag = NoYes::No;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            while select ItemId, PhysicalInvent, #InventDimGroupAllFields from inventSum
                where inventSum.ClosedQty       == NoYes::No
                   && inventSum.PhysicalInvent  > 0
                   && #InventDimFieldsFilter(inventSum, _inventDimCriteria, inventDimParm)
            exists join licensePlate
                where licensePlate.LicensePlateId == inventSum.LicensePlateId
                   && licensePlate.LicensePlateParent == _parentLicensePlateId
            {
                inventDim.clear();
                inventDim.initFromInventSum(inventSum);

                InventDim inventDimKey;

                EcoResProductDimGroupSetup::copyProductDimensionsForItem(inventSum.ItemId, inventDim, inventDimKey);
                inventDimKey = InventDim::findOrCreate(inventDimKey);

                str key = inventSum.ItemId + inventDimKey.InventDimId;

                if (_qtyMap.exists(key))
                {
                    InventQty qty = _qtyMap.lookup(key);
                    qty += inventSum.PhysicalInvent;
                    _qtyMap.insert(key, qty);
                }
                else
                {
                    _qtyMap.insert(key, inventSum.PhysicalInvent);
                }
            }
        }
        else
        {
            while select ItemId, PhysicalInvent from inventSum
                where inventSum.ClosedQty       == NoYes::No
                   && inventSum.PhysicalInvent  > 0
                #InventDimInnerJoin(inventSum.inventDimId, inventDim, _inventDimCriteria, inventDimParm)
            exists join licensePlate
                where licensePlate.LicensePlateId == inventDim.LicensePlateId
                   && licensePlate.LicensePlateParent == _parentLicensePlateId

            {
                InventDim inventDimKey;

                EcoResProductDimGroupSetup::copyProductDimensionsForItem(inventSum.ItemId, inventDim, inventDimKey);
                inventDimKey = InventDim::findOrCreate(inventDimKey);

                str key = inventSum.ItemId + inventDimKey.InventDimId;

                if (_qtyMap.exists(key))
                {
                    InventQty qty = _qtyMap.lookup(key);
                    qty += inventSum.PhysicalInvent;
                    _qtyMap.insert(key, qty);
                }
                else
                {
                    _qtyMap.insert(key, inventSum.PhysicalInvent);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLicensePlateReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if anything is reserved on the license plate.
    /// </summary>
    /// <param name="_workId">
    /// Work id.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_inventSiteId">
    /// Site id.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Location id.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when license plate has inventory reserved against it.
    /// </exception>
    [SysObsolete('This logic is not supported', false, 18\05\2022)]
    void checkLicensePlateReservations(
        WHSWorkId         _workId,
        InventLocationId  _inventLocationId,
        InventSiteId      _inventSiteId,
        WMSLocationId     _wmsLocationId,
        WHSLicensePlateId _licensePlateId)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>blockDependentWorks</Name>
				<Source><![CDATA[
    private void blockDependentWorks(WHSWorkId _workId, InventDimId _inventDimId)
    {
        WHSWorkTable            workTable;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;

        while select WorkId from workTable
            where  workTable.WorkStatus     <  WHSWorkStatus::InProcess     &&
                    (workTable.WorkTransType == WHSWorkTransType::ProdPick   ||
                    workTable.WorkTransType == WHSWorkTransType::KanbanPick)
            exists join inventTransOrigin
                where  inventTransOrigin.ReferenceId == workTable.WorkId
                    && inventTransOrigin.ReferenceId != _workId
                    && inventTransOrigin.ReferenceId != ''
            exists join inventTrans
                where inventTrans.InventTransOrigin  == inventTransOrigin.RecId
                    && inventTrans.InventDimId       == _inventDimId
                    && inventTrans.StatusReceipt     == StatusReceipt::None
                    && (inventTrans.StatusIssue      == StatusIssue::ReservOrdered
                        || inventTrans.StatusIssue   == StatusIssue::ReservPhysical)
        {
            WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(workTable.WorkId)
                    .tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedOverPickWork);
        }
        

        WHSWorkFrozen           workFrozen;

        insert_recordset workFrozen (WorkId, FrozenWorkId)
            select _workId, WorkId from workTable
            where workTable.WorkStatus     <  WHSWorkStatus::InProcess     &&
                    (workTable.WorkTransType == WHSWorkTransType::ProdPick   ||
                    workTable.WorkTransType == WHSWorkTransType::KanbanPick)
            exists join inventTransOrigin
                where  inventTransOrigin.ReferenceId == workTable.WorkId
                    && inventTransOrigin.ReferenceId != _workId
                    && inventTransOrigin.ReferenceId != ''
            exists join inventTrans
                where inventTrans.InventTransOrigin  == inventTransOrigin.RecId
                    && inventTrans.InventDimId       == _inventDimId
                    && inventTrans.StatusReceipt     == StatusReceipt::None
                    && (inventTrans.StatusIssue      == StatusIssue::ReservOrdered
                        || inventTrans.StatusIssue   == StatusIssue::ReservPhysical);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify that the batch is assigned to the work is OK.
    /// </summary>
    /// <param name = "_inventDimid">
    /// Inventory dimension id move from.
    /// </param>
    /// <param name = "_workLine">
    /// The work line to check against.
    /// </param>
    private void checkInventBatch(InventDimId _inventDimid, WHSWorkLine _workLine)
    {
        InventBatch inventBatch = InventBatch::find(InventDim::find(_inventDimid).inventBatchId, _workLine.ItemId);

        if (inventBatch.RecId && !checkedInventBatch.in(inventBatch.RecId))
        {
            checkedInventBatch.add(inventBatch.RecId);
            WhsWorkExecute::checkBatchSellableDays(inventBatch, _workLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBatchSellableDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the batch number assigned to the work has a valid expiration date.
    /// </summary>
    /// <param name = "_inventBatch">
    /// The batch dimension to move from.
    /// </param>
    /// <param name = "_workLine">
    /// The work line to check against.
    /// </param>
    protected static void checkBatchSellableDays(InventBatch _inventBatch, WHSWorkLine _workLine)
    {
        WHSWorkTransType whsWorkTransType = _workLine.whsWorkTable().WorkTransType;

        if (_inventBatch
            && _workLine.WorkType == WHSWorkType::Pick
            && InventTable::find(_workLine.ItemId).whsBatchActive()
            && (whsWorkTransType == WHSWorkTransType::Sales
            || (whsWorkTransType == WHSWorkTransType::ProdPick))
            && !WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum))
        {
            InventDim productInventDim = _workLine.inventDim();
            productInventDim.clearNotProductDim(InventDimGroupSetup::newItemId(_workLine.ItemId));
            productInventDim = InventDim::findOrCreate(productInventDim);
            SalesLine salesLine;
            
            if (whsWorkTransType == WHSWorkTransType::Sales)
            {
                salesLine = SalesLine::findInventTransId(_workLine.InventTransId);
            }

            boolean batchSellableDaysCheck = InventBatch::pdsCheckExpiryDate(_inventBatch.inventBatchId,
                                                                             _workLine.ItemId,
                                                                             DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                                             false,
                                                                             salesLine.CustAccount,
                                                                             false,
                                                                             productInventDim);

            if (!batchSellableDaysCheck)
            {
                if (_workLine.whsWorkTable().WorkTransType == WHSWorkTransType::ProdPick)
                {
                    throw error("@WAX:BatchHasPassedExpirationDate");
                }
                else
                {
                    throw error("@WAX:BatchIsNotSellable");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOverDelivery</Name>
				<Source><![CDATA[
    [SysObsolete('Logic has been moved to checkOverDeliveryForOrderLine', false, 03\03\2023)]
    boolean checkOverDelivery(
        PurchId _purchId, TradeLineNumber _lineNum, Qty _qty, UnitOfMeasureSymbol _unit)
    {
        return this.checkOverDeliveryForOrderLineInternal(PurchLine::find(_purchId, _lineNum), _qty, _unit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOverDeliveryForOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the total received and registered quantity of an inbound order line is below over delivery threshold.
    /// </summary>
    /// <param name="_orderLine">
    /// The inbound order line.
    /// </param>
    /// <param name="_qty">
    /// Current received quantity.
    /// </param>
    /// <param name="_unit">
    /// Current UOM of received quantity.
    /// </param>
    /// <returns>
    /// true if it is below over delivery threshold, false otherwise.
    /// </returns>
    public boolean checkOverDeliveryForOrderLine(WHSReceiptOrderLine _orderLine, Qty _qty, UnitOfMeasureSymbol _unit)
    {
        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        var purchLine = _orderLine as PurchLine;
        if (purchLine)
        {
            return this.checkOverDelivery(purchLine.PurchId, purchLine.LineNumber, _qty, _unit);
        }

        return this.checkOverDeliveryForOrderLineInternal(_orderLine, _qty, _unit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOverDeliveryForOrderLineInternal</Name>
				<Source><![CDATA[
    private boolean checkOverDeliveryForOrderLineInternal(WHSReceiptOrderLine _orderLine, Qty _qty, UnitOfMeasureSymbol _unit)
    {
        InventQty expectedReceiptQty;
        boolean receiptQtyFlight = WHSWorkExecuteExpectedReceiptHandlingQtyForInboundOrderFlight::instance().isEnabled();

        if (receiptQtyFlight)
        {
            expectedReceiptQty = this.expectedReceiptHandlingQtyForInboundOrderLine(_orderLine);
            if (!expectedReceiptQty)
            {
                return false;
            }
        }

        UnitOfMeasureRecId inventHandlingUnitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(_orderLine.ItemId));

        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        InventQty inventQtyToBeRegistered = releasedProductUnitConverter.convert(_qty,
                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(_unit),
                                                    inventHandlingUnitOfMeasureRecId,
                                                    NoYes::No,
                                                    _orderLine.ItemId,
                                                    _orderLine.InventDimId,
                                                    NoYes::No);
 
        InventQty totalReceivedAndRegisteredQty = this.inboundOrderLineReceivedAndRegisteredQty(_orderLine, inventHandlingUnitOfMeasureRecId);

        if (WHSDeferredReceivingContext::isInContext() && WHSIncludeOpenMixedLPInRemainQtyCalcForDeferredRecFlight::instance().isEnabled())
        {
            totalReceivedAndRegisteredQty += WHSMixedLicensePlateReceiptLine::getTotalOpenQtyOnTransId(_orderLine.InventTransId);
        }

        if (!receiptQtyFlight)
        {
            expectedReceiptQty = this.expectedReceiptHandlingQtyForInboundOrderLine(_orderLine);
            if (!expectedReceiptQty)
            {
                return false;
            }
        }

        OverDeliveryPct pct = (((totalReceivedAndRegisteredQty + inventQtyToBeRegistered) / expectedReceiptQty) * 100) - 100;

        return (pct <= _orderLine.OverDeliveryPct);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inboundOrderLineReceivedAndRegisteredQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of the total received and registered quantity for the given inbound order line.
    /// </summary>
    /// <param name = "_orderLine">The inbound order line.</param>
    /// <param name = "_inventHandlingUnitOfMeasureRecId">The record id of the inventory unit of measure of the received item.</param>
    /// <returns>The sum of the total received and registered quantity in inventory units.</returns>
    [Replaceable, Wrappable(true)]
    internal InventHandlingQty inboundOrderLineReceivedAndRegisteredQty(WHSReceiptOrderLine _orderLine, UnitOfMeasureRecId _inventHandlingUnitOfMeasureRecId)
    {
        if (PdsGlobal::pdsIsCWItem(_orderLine.ItemId))
        {
            return _orderLine.pdsCWReceivedInTotal() + _orderLine.pdsCWRegistered();
        }

        return _orderLine.receivedInventInTotal() + _orderLine.registered();
    }

]]></Source>
			</Method>
			<Method>
				<Name>expectedReceiptHandlingQtyForInboundOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the expected receipt inventory quantity for the given inbound order line.
    /// </summary>
    /// <param name = "_orderLine">The inbound order line.</param>
    /// <returns>The expected receipt inventory quantity.</returns>
    [Replaceable, Wrappable(true)]
    internal InventHandlingQty expectedReceiptHandlingQtyForInboundOrderLine(WHSReceiptOrderLine _orderLine)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_orderLine.ItemId);

        if (WHSWorkExecuteExpectedReceiptHandlingQtyForInboundOrderFlight::instance().isEnabled())
        {
            InventHandlingQty inventHandlingQty;

            if (_orderLine.InventTransId
                && _orderLine.isStocked())
            {
                InventTransIdSum inventTransIdSum = InventTransIdSum::newTransOriginId(_orderLine.inventTransOriginId());
                inventHandlingQty = isCWItem ? inventTransIdSum.pdsCWReceipt() : inventTransIdSum.receipt();
            }

            return inventHandlingQty;
        }

        if (isCWItem)
        {
            return _orderLine.PdsCWQty;
        }
        
        return _orderLine.InventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomWorkLineRemainingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work line setting remaining quantities to zero.
    /// </summary>
    /// <param name = "_workLine">
    /// Work line to update.
    /// </param>
    public void updateCustomWorkLineRemainingQuantities(WHSWorkLine _workLine)
    {
        ttsbegin;

        _workLine.InventQtyRemain = 0;
        _workLine.QtyRemain = 0;
        _workLine.write();
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes a work line by setting remaining quantity to zero.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the line to be closed.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the line to be closed.
    /// </param>
    /// <returns>
    /// Total quantity that has work transaction associated with it.
    /// </returns>
    [SysObsolete('Use WhsWorkExecute.updateCustomWorkLineRemainingQuantities() method instead.', false, 27\03\2020)]
    public Qty closeWorkLine(WHSWorkId _workId, LineNum _lineNum)
    {
        ttsbegin;
        
        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum, true);

        this.updateCustomWorkLineRemainingQuantities(workLine);

        ttscommit;

        return workLine.InventQtyWork - workLine.InventQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmCustomWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms custom work line.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the custom work line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the custom work line.
    /// </param>
    /// <param name="_userId">
    /// User id that does the confirmation.
    /// </param>
    /// <returns>
    /// First open work line associated with the work.
    /// </returns>
    public WHSWorkLine confirmCustomWork(WHSWorkId _workId, LineNum _lineNum, WHSUserId _userId)
    {
        ttsbegin;

        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum);
        
        WHSWorkTrans workTrans;
        workTrans.setWorkTransId();
        workTrans.InventDimId   = workLine.InventDimId;
        workTrans.ItemId        = workLine.ItemId;
        workTrans.Qty           = workLine.QtyWork;
        workTrans.uom           = workLine.UnitId;
        workTrans.TransDateTime = DateTimeUtil::utcNow();
        workTrans.WorkId        = workLine.WorkId;
        workTrans.LineNum       = workLine.LineNum;
        workTrans.UserId        = _userId;
        workTrans.InventTransId = workLine.InventTransId;
        workTrans.write();

        this.closeWorkLine(_workId, _lineNum);

        this.updateWorkStatus(_workId, _lineNum, _userId);

        ttscommit;

        return this.getFirstOpenLine(_workId, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertWMSLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds WMS location id from check text.
    /// </summary>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_checkText">
    /// Check text.
    /// </param>
    /// <returns>
    /// WMS Location id.
    /// </returns>
    WMSLocationId convertWMSLocationId(InventLocationId _inventLocationId, WMSCheckText _checkText)
    {
        WMSLocation     location;

        select firstonly wmsLocationId from location
            where location.InventLocationId == _inventLocationId    &&
                  location.wmsLocationId    == _checkText;

        if (!location.wmsLocationId)
        {
            select firstonly wmsLocationId from location
                where location.InventLocationId == _inventLocationId    &&
                      location.CheckText        == _checkText;
        }

        return location.wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustmentWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates adjustment work for an inventory item and adjusts inventory.
    /// </summary>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_inventDim">
    /// Item dimensions.
    /// </param>
    /// <param name="_qty">
    /// Item quantity.
    /// </param>
    /// <param name="_uom">
    /// Item unit of measurement.
    /// </param>
    /// <param name="_wmsLocationId">
    /// location id of the adjustment work.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id of the adjustment work.
    /// </param>
    /// <param name="_adjustmentTypeCode">
    /// Adjustment type code.
    /// </param>
    /// <param name="_licensePlateId">
    /// Target license plate id of the work.
    /// </param>
    /// <param name="_transType">
    /// Work transaction type, default value is Invent.
    /// </param>
    /// <param name="_workType">
    /// Work type, default value is Adjustment.
    /// </param>
    /// <returns>
    /// Work id of the created adjustment work.
    /// </returns>
    [SysObsolete('Use WHSInventAdjustmentCreate class instead', false, 30\11\2017)]
    WHSWorkId createAdjustmentWork(WHSUserId                _userId,
                                   ItemId                   _itemId,
                                   InventDim                _inventDim,
                                   Qty                      _qty,
                                   WHSUOM                   _uom,
                                   WMSLocationId            _wmsLocationId,
                                   InventLocationId         _inventLocationId,
                                   WHSAdjustmentTypeCode    _adjustmentTypeCode,
                                   WHSLicensePlateId        _licensePlateId = '',
                                   WHSWorkTransType         _transType      = WHSWorkTransType::Invent,
                                   WHSWorkType              _workType       = WHSWorkType::Adjustment)
    {
        WHSInventAdjustmentCreateParameters params = WHSInventAdjustmentCreateParameters::construct();
        params.WorkUserId = _userId;
        params.ItemId = _itemId;
        params.InventDim = _inventDim;
        params.AdjustmentQty = _qty;
        params.AdjustmentUnit = _uom;
        params.WmsLocationId = _wmsLocationId;
        params.InventLocationId = _inventLocationId;
        params.AdjustmentTypeCode = _adjustmentTypeCode;
        params.LicensePlateId = _licensePlateId;
        params.WorkTransType = _transType;
        params.WorkType = _workType;

        WHSInventAdjustmentCreate createAdj = WHSInventAdjustmentCreate::newFromParams(params);
        createAdj.run();

        return createAdj.createdWorkId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostTransferJournalQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the item provided is a warehouse enabled catch weight item and creates and posts an inventory transfer journal.
    /// </summary>
    /// <param name="_inventJournalNameId">
    /// Journal name of the journal to be created.
    /// </param>
    /// <param name="_itemId">
    /// Item id that is subject to the movement.
    /// </param>
    /// <param name="_handlingQty">
    /// Quantity of the item that is subject to the movement.
    /// </param>
    /// <param name="_capturedWeight">
    /// Weight of the item, will be blank for non-cw items.
    /// </param>
    /// <param name="_fromInventDimId">
    /// Initial dimensions of the inventory item.
    /// </param>
    /// <param name="_toInventDimId">
    /// Final dimensions of the inventory item.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    [Hookable(false)]
    final public void createAndPostTransferJournalQuantities(
        InventJournalNameId   _inventJournalNameId,
        ItemId                _itemId,
        InventHandlingQty     _handlingQty,
        InventQty             _capturedWeight,
        InventDimId           _fromInventDimId,
        InventDimId           _toInventDimId,
        WHSUserId             _userId)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _itemId, _capturedWeight))
        {
            this.createAndPostTransferJournalQty(
                _inventJournalNameId,
                _itemId,
                _handlingQty,
                _capturedWeight,
                _fromInventDimId,
                _toInventDimId,
                _userId);
        }
        else
        {
            this.createAndPostTransferJournal(
                _inventJournalNameId,
                _itemId,
                _handlingQty,
                _fromInventDimId,
                _toInventDimId,
                _userId);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostTransferJournalQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts an inventory transfer journal.
    /// </summary>
    /// <param name="_inventJournalNameId">
    /// Journal name of the journal to be created.
    /// </param>
    /// <param name="_itemId">
    /// Item id that is subject to the movement.
    /// </param>
    /// <param name="_handlingQty">
    /// Quantity of the item that is subject to the movement.
    /// </param>
    /// <param name="_capturedWeight">
    /// Weight of the item.
    /// </param>
    /// <param name="_fromInventDimId">
    /// Initial dimensions of the inventory item.
    /// </param>
    /// <param name="_toInventDimId">
    /// Final dimensions of the inventory item.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the createAndPostTransferJournalQuantities method.
    /// </remarks>
    [Wrappable(true)]
    protected void createAndPostTransferJournalQty(
        InventJournalNameId   _inventJournalNameId,
        ItemId                _itemId,
        InventHandlingQty     _handlingQty,
        InventQty             _capturedWeight,
        InventDimId           _fromInventDimId,
        InventDimId           _toInventDimId,
        WHSUserId             _userId)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _itemId, _handlingQty, _capturedWeight);

        ttsbegin;

        // Create the journal.
        InventJournalTable inventJournalTable = this.createTransferJournal(_inventJournalNameId, _itemId, _handlingQty, _capturedWeight, _fromInventDimId, _toInventDimId);

        // Posts the journal.
        this.postTransferJournal(inventJournalTable);

        // Creates the corresponding warehouse work.
        this.createWarehouseTransferWork(inventJournalTable, _itemId, _handlingQty, _capturedWeight, _fromInventDimId, _toInventDimId, _userId);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantityAndPostTransferJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the weight and posts the journal. It also creates pick/put work pair for the inventory transfer with closed state.
    /// </summary>
    /// <param name="_journalId">
    /// Journal ID of the journal to be posted.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the journal transaction.
    /// </param>
    /// <param name="_itemId">
    /// Item id that is subject to the movement.
    /// </param>
    /// <param name="_handlingQty">
    /// Quantity of the item that is subject to the movement.
    /// </param>
    /// <param name="_capturedWeight">
    /// Weight of the item, will be blank for non-catch weight items.
    /// </param>
    /// <param name="_fromInventDimId">
    /// Initial dimensions of the inventory item.
    /// </param>
    /// <param name="_toInventDimId">
    /// Final dimensions of the inventory item.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    [Hookable(false)]
    internal void updateQuantityAndPostTransferJournal(
        JournalId             _journalId,
        LineNum               _lineNum,
        ItemId                _itemId,
        InventHandlingQty     _handlingQty,
        InventQty             _capturedWeight,
        InventDimId           _fromInventDimId,
        InventDimId           _toInventDimId,
        WHSUserId             _userId)
    {
        ttsbegin;

        InventJournalTable inventJournalTable = InventJournalTable::find(_journalId);
        
        // Update the weight in the journal line.
        this.updateJournalTransQuantity(_journalId, _lineNum, _capturedWeight);

        // Posts the journal
        this.postTransferJournal(inventJournalTable);

        // Creates the corresponding warehouse work.
        this.createWarehouseTransferWork(inventJournalTable, _itemId, _handlingQty, _capturedWeight, _fromInventDimId, _toInventDimId, _userId);
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTransQuantity</Name>
				<Source><![CDATA[
    private void updateJournalTransQuantity(JournalId _journalId, LineNum _lineNum, InventQty _capturedWeight)
    {
        InventJournalTrans inventJournalTrans;

        select firstOnly forUpdate inventJournalTrans
            where  inventJournalTrans.JournalId == _journalId
                && inventJournalTrans.LineNum   == _lineNum;

        if (inventJournalTrans.Qty != -_capturedWeight)
        {
            inventJournalTrans.Qty = -_capturedWeight;
            inventJournalTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an inventory transfer journal.
    /// </summary>
    /// <param name="_inventJournalNameId">
    /// Journal name of the journal to be created.
    /// </param>
    /// <param name="_itemId">
    /// Item id that is subject to the movement.
    /// </param>
    /// <param name="_handlingQty">
    /// Quantity of the item that is subject to the movement.
    /// </param>
    /// <param name="_capturedWeight">
    /// Weight of the item, will be blank for non-cw items.
    /// </param>
    /// <param name="_fromInventDimId">
    /// Initial dimensions of the inventory item.
    /// </param>
    /// <param name="_toInventDimId">
    /// Final dimensions of the inventory item.
    /// </param>
    /// <returns>The invent jounral header.</returns>
    [Hookable(false)]
    internal InventJournalTable createTransferJournal(
        InventJournalNameId   _inventJournalNameId,
        ItemId                _itemId,
        InventHandlingQty     _handlingQty,
        InventQty             _capturedWeight,
        InventDimId           _fromInventDimId,
        InventDimId           _toInventDimId)
    {
        ttsbegin;

        // Create the journal header
        InventJournalTable inventJournalTable = this.createTransferJournalHeader(_inventJournalNameId);

        // Create the journal line
        this.createTransferJournalLine(inventJournalTable, _itemId, _handlingQty, _capturedWeight, _fromInventDimId, _toInventDimId);

        ttscommit;

        return inventJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWarehouseTransferWork</Name>
				<Source><![CDATA[
    private void createWarehouseTransferWork(
        InventJournalTable     _inventJournalTable,
        ItemId                _itemId,
        InventHandlingQty     _handlingQty,
        InventQty             _capturedWeight,
        InventDimId           _fromInventDimId,
        InventDimId           _toInventDimId,
        WHSUserId             _userId)
    {
        // Create the work header
        InventDim fromInventDim = InventDim::find(_fromInventDimId);
        WHSWorkTable workTable = this.createTransferWorkHeader(_inventJournalTable, fromInventDim);
        
        // Create the Pick work line
        WHSWorkLine pickWorkLine = this.createTransferPickWorkLine(workTable, _itemId, _handlingQty, _capturedWeight, fromInventDim, _userId);

        // Create the Put work line
        InventDim toInventDim = InventDim::find(_toInventDimId);
        WHSWorkLine putWorkLine = this.createTransferPutWorkLine(pickWorkLine, toInventDim);

        // Create the Pick work trans
        this.createTransferWorkTrans(workTable, pickWorkLine, _userId);

        // Create the Put work trans
        this.createTransferWorkTrans(workTable, putWorkLine, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostTransferJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts inventory transfer journal. It also creates pick/put work pair for the inventory transfer with closed state.
    /// </summary>
    /// <param name="_inventJournalNameId">
    /// Journal name of the journal to be created.
    /// </param>
    /// <param name="_itemId">
    /// Item id that is subject to the movement.
    /// </param>
    /// <param name="_inventQty">
    /// Quantity of the item that is subject to the movement.
    /// </param>
    /// <param name="_fromInventDimId">
    /// Initial dimensions of the inventory item.
    /// </param>
    /// <param name="_toInventDimId">
    /// Final dimensions of the inventory item.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the createAndPostTransferJournalQuantities method. Extenders should move their logic to wrap or override the createAndPostTransferJournalQty method.', false, 30\9\2019)]
    void createAndPostTransferJournal(InventJournalNameId   _inventJournalNameId,
                                      ItemId                _itemId,
                                      InventQty             _inventQty,
                                      InventDimId           _fromInventDimId,
                                      InventDimId           _toInventDimId,
                                      WHSUserId             _userId)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId);

        this.createAndPostTransferJournalQty(_inventJournalNameId,
            _itemId,
            _inventQty,
            0, // captured weight should be zero for non-cw items
            _fromInventDimid,
            _toInventDimId,
            _userId);

        // Update location status fields for to and from locations.
        InventDim       fromInventDim = InventDim::find(_fromInventDimId);
        InventDim       toInventDim   = InventDim::find(_toInventDimId);

        WHSLocationWorkUpdater::updateLocationInfoFromMovement(
            fromInventDim.InventLocationId,
            fromInventDim.wMSLocationId,
            toInventDim.InventLocationId,
            toInventDim.wMSLocationId,
            fromInventDim.LicensePlateId);

        WHSLocationLicensePlatePositioningSequencer::newFromLicensePlateAtLocation(fromInventDim.LicensePlateId, fromInventDim.wmsLocation()).pickLicensePlateFromCurrentPosition();

        WHSLocationLicensePlatePositioningSequencer::newFromLicensePlateAtLocation(toInventDim.LicensePlateId, toInventDim.wmsLocation()).putLicensePlateAtFirstPosition();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferJournalHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the inventory transfer journal header.
    /// </summary>
    /// <param name = "_inventJournalNameId">Journal name of the journal to be created.</param>
    /// <returns>The created inventory transfer journal header.</returns>
    protected InventJournalTable createTransferJournalHeader(InventJournalNameId _inventJournalNameId)
    {
        InventJournalTable inventJournalTable;
        inventJournalTable.initFromInventJournalName(InventJournalName::find(_inventJournalNameId));
        inventJournalTable.Reservation  = ItemReservation::Automatic;
        inventJournalTable.NumOfLines   = 1;
        inventJournalTable.insert();

        return inventJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferJournalLine</Name>
				<Source><![CDATA[
    private void createTransferJournalLine(InventJournalTable  _inventJournalTable,
                                           ItemId              _itemId,
                                           InventHandlingQty   _handlingQty,
                                           InventQty           _capturedWeight,
                                           InventDimId         _fromInventDimId,
                                           InventDimId         _toInventDimId)
    {
        InventJournalTrans inventJournalTrans = this.initializeTransferJournalLine(
            _inventJournalTable,
            _itemId,
            _handlingQty,
            _capturedWeight,
            _fromInventDimId,
            _toInventDimId);
        inventJournalTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransferJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory transfer journal line.
    /// </summary>
    /// <param name = "_inventJournalTable">The inventory journal table record.</param>
    /// <param name = "_itemId">The item number.</param>
    /// <param name = "_inventHandlingQty">The inventory handling quantity.</param>
    /// <param name = "_capturedWeight">The captured weight.</param>
    /// <param name = "_fromInventDimId">The from inventory dimension.</param>
    /// <param name = "_toInventDimId">The to inventory dimension.</param>
    /// <returns>An instance of <c>InventJournalTrans</c> record.</returns>
    protected InventJournalTrans initializeTransferJournalLine(
        InventJournalTable  _inventJournalTable,
        ItemId              _itemId,
        InventHandlingQty   _inventHandlingQty,
        InventQty           _capturedWeight,
        InventDimId         _fromInventDimId,
        InventDimId         _toInventDimId)
    {
        InventJournalTrans inventJournalTrans;
        inventJournalTrans.initValue();
        inventJournalTrans.initFromInventJournalTable(_inventJournalTable);
        inventJournalTrans.initFromInventTable(InventTable::find(_itemId), false, false, true);
        inventJournalTrans.setInventDimId(_fromInventDimId);
        inventJournalTrans.ToInventDimId    = _toInventDimId;

        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            inventJournalTrans.Qty      = -_capturedWeight;
            inventJournalTrans.PdsCWQty = -_inventHandlingQty;
        }
        else
        {
            inventJournalTrans.Qty = -_inventHandlingQty;
        }
        
        inventJournalTrans.CostAmount = inventJournalTrans.calcCostAmount();
        return inventJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransferJournal</Name>
				<Source><![CDATA[
    private void postTransferJournal(InventJournalTable _inventJournalTable)
    {
        JournalCheckPost journalPost;
        journalPost = InventJournalCheckPost::newPostJournal(_inventJournalTable);
        journalPost.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferWorkHeader</Name>
				<Source><![CDATA[
    private WHSWorkTable createTransferWorkHeader(InventJournalTable _inventJournalTable, InventDim _fromInventDim)
    {
        WHSWorkTable workTable;
        workTable.setWorkId();
        workTable.WorkStatus                = WHSWorkStatus::Closed;
        workTable.WorkTransType             = WHSWorkTransType::Invent;
        workTable.InventSiteId              = _fromInventDim.InventSiteId;
        workTable.InventLocationId          = _fromInventDim.InventLocationId;
        workTable.WorkInProcessUTCDateTime  = DateTimeUtil::utcNow();
        workTable.WorkClosedUTCDateTime     = DateTimeUtil::utcNow();
        workTable.TargetLicensePlateId      = _fromInventDim.LicensePlateId;
        workTable.InventJournalId           = _inventJournalTable.JournalId;
        workTable.write();

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferPickWorkLine</Name>
				<Source><![CDATA[
    private WHSWorkLine createTransferPickWorkLine(
        WHSWorkTable        _workTable,
        ItemId              _itemId,
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _capturedWeight,
        InventDim           _fromInventDim,
        WHSUserId           _userId,
        LineNum             _lineNum            = 1)
    {
        WHSWorkLine pickWorkLine;
        pickWorkLine.WorkId                     = _workTable.WorkId;
        pickWorkLine.LineNum                    = _lineNum;
        pickWorkLine.WorkStatus                 = WHSWorkStatus::Closed;
        pickWorkLine.WorkType                   = WHSWorkType::Pick;
        pickWorkLine.wmsLocationId              = _fromInventDim.wmsLocationId;
        pickWorkLine.ItemId                     = _itemId;
        pickWorkLine.InventDimId                = _fromInventDim.InventDimId;
        pickWorkLine.InventQtyRemain            = 0;
        pickWorkLine.InventQtyWork              = _handlingQty;
        pickWorkLine.QtyWork                    = _handlingQty;
        pickWorkLine.CapturedWeight             = _capturedWeight;
        pickWorkLine.UnitId                     = WHSCatchWeightHelper::inventHandlingUnitId(_itemId);
        pickWorkLine.UserId                     = _userId;
        pickWorkLine.WorkInProcessUTCDateTime   = DateTimeUtil::utcNow();
        pickWorkLine.WorkClosedUTCDateTime      = DateTimeUtil::utcNow();
        pickWorkLine.insert();

        return pickWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferPutWorkLine</Name>
				<Source><![CDATA[
    private WHSWorkLine createTransferPutWorkLine(WHSWorkLine _pickWorkLine, InventDim _toInventDim, LineNum _lineNum = 2)
    {
        WHSWorkLine putWorkLine;
        buf2Buf(_pickWorkLine, putWorkLine);
        putWorkLine.LineNum         = _lineNum;
        putWorkLine.WorkStatus      = WHSWorkStatus::Closed;
        putWorkLine.WorkType        = WHSWorkType::Put;
        putWorkLine.wmsLocationId   = _toInventDim.wmsLocationId;
        putWorkLine.InventDimId     = _toInventDim.InventDimId;
        putWorkLine.insert();

        return putWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferWorkTrans</Name>
				<Source><![CDATA[
    private void createTransferWorkTrans(WHSWorkTable _workTable, WHSWorkLine _transferWorkLine, WHSUserId _userId)
    {
        WHSWorkTrans workTrans;
        workTrans.setWorkTransId();
        workTrans.InventDimId   = _transferWorkLine.InventDimId;
        workTrans.ItemId        = _transferWorkLine.ItemId;
        workTrans.Qty           = _transferWorkLine.QtyWork;
        workTrans.uom           = _transferWorkLine.UnitId;
        workTrans.TransDateTime = DateTimeUtil::utcNow();
        workTrans.WorkId        = _workTable.WorkId;
        workTrans.LineNum       = _transferWorkLine.LineNum;
        workTrans.UserId        = _userId;
        workTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCountingJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method creates a counting journal that acts as the inventory movement
    /// </summary>
    /// <param name="_workId">
    /// Parameter relates to the InventJournalTable record journal lines will be assigned to
    /// </param>
    /// <param name="_lineNum">
    /// The work trans record used to establish journal line from inventTable
    /// </param>
    /// <param name="_adjustmentTypeCode">
    /// The line number established from work trans in createCountingJournal
    /// </param>
    /// <param name="_qty">
    /// The qty passed in from workTrans creation in createCountingJournal
    /// </param>
    /// <param name="_workerRecId">
    /// Passed in the recid of whsworker in createCountingJournal
    /// </param>
    /// <returns>
    /// The created journal ID.
    /// </returns>
    [SysObsolete('Use WHSInventAdjustmentCreate for creating inventory adjustments', false, 30\11\2017)]
    protected InventJournalId createCountingJournal(
                                        WHSWorkId             _workId,
                                        LineNum               _lineNum,
                                        WHSAdjustmentTypeCode _adjustmentTypeCode,
                                        Qty                   _qty = 0,
                                        WHSWorkerRecId        _workerRecId = 0)
    {
        JournalCheckPost            journalPost;
        InventJournalTable          journalTable;
        WHSWorkTrans                workTrans;
        int                         lineNum = 0;
        Qty                         locationQty;
        Qty                         differenceQty;
        Qty                         movementQty;
        InventSum                   inventSum;
        WHSWorkLine                 workLine;

        ttsbegin;

        journalTable = this.createInventHeader(_workId, _adjustmentTypeCode, _workerRecId);

        if (_qty)
        {
            movementQty = _qty;

            while select workTrans
                where workTrans.WorkId  == _workId &&
                      workTrans.LineNum == _lineNum
            {
                ++lineNum;
                this.createInventLine(journalTable, workTrans, lineNum, movementQty);
            }
        }
        else
        {
            while select Qty from workTrans
                where workTrans.WorkId  == _workId &&
                        workTrans.LineNum == _lineNum
                join PhysicalInvent from inventSum
                    where inventSum.InventDimId == workTrans.InventDimId &&
                            inventSum.ItemId    == workTrans.ItemId
                join WorkType from workLine
                    where workLine.WorkId       == _workId &&
                            workLine.LineNum      == _lineNum
            {
                locationQty = inventSum.PhysicalInvent;
                differenceQty = locationQty - workTrans.Qty;
                if (workLine.WorkType == WHSWorkType::Count)
                {
                    differenceQty = -differenceQty;
                }
                else
                {
                    differenceQty = abs(differenceQty);
                }
                movementQty = differenceQty;

                if (movementQty)
                {
                    ++lineNum;
                    this.createInventLine(journalTable, workTrans, lineNum, movementQty);
                }
            }
        }

        if (lineNum > 1)
        {
            journalTable.NumOfLines = lineNum;
            journalTable.write();
        }

        if (lineNum > 0)
        {
            journalPost = InventJournalCheckPost::newPostJournal(journalTable);
            journalPost.runOperation();
        }
        else
        {
            journalTable.delete();
        }

        ttscommit;

        return journalTable.JournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingNegative</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>WHSDimTracking</c> record for negative batch picking.
    /// </summary>
    /// <param name="_workLine">
    /// Work line record that is tracked by the record.
    /// </param>
    /// <param name="_inventTransId">
    /// Inventory transaction id that is tracked by the record.
    /// </param>
    /// <param name="_batchId">
    /// Batch id of the tracked dimensions.
    /// </param>
    /// <param name="_serialId">
    /// Serial id of the tracked dimensions.
    /// </param>
    void createDimTrackingNegative(WHSWorkLine      _workLine,
                                   InventTransId    _inventTransId,
                                   InventBatchId    _batchId = '',
                                   InventSerialId   _serialId = '')
    {
        WHSDimTracking  dimTracking;
        InventDim       inventDim;

        inventDim.data(_workLine.inventDim());
        inventDim.wmsLocationId     = _workLine.wmsLocationId;
        inventDim.InventBatchId     = _batchId;
        inventDim.InventSerialId    = _serialId;
        inventDim.InventGtdId_RU = this.parmInventGTDId();
        inventDim = InventDim::findOrCreate(inventDim);

        dimTracking.WorkId              = _workLine.WorkId;
        dimTracking.LineNum             = _workLine.LineNum;
        dimTracking.InventDimId         = inventDim.InventDimId;
        dimTracking.Qty                 = _workLine.InventQtyRemain;
        dimTracking.InventTransIdParent = _inventTransId;
        dimTracking.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkDimTrackingEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work dimension tracking entries to track below License Plate dimensions during work execution.
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed.
    /// </param>
    /// <param name="_inventDim">
    /// The below Location dimension set used for picking.
    /// </param>
    /// <param name="_capturedWeight">
    /// The weight that has been captured on the mobile device.
    /// </param>
    /// <param name="_overPick">
    /// A boolean distinguishing if we are doing raw material overpicking.
    /// </param>
    /// <returns>
    /// true if any dimension tracking entries were created; otherwise, false.
    /// </returns>
    final protected boolean createWorkDimTrackingEntries(
        WHSWorkLine         _workLine,
        InventDim           _inventDim,
        WHSCapturedWeight   _capturedWeight,
        boolean             _overPick)
    {
        if (_capturedWeight && !WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!_workLine.ItemId ? _capturedWeight : !WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _workLine.Itemid, _capturedWeight))
        {
            return this.createWorkLineDimTrackingEntries(_workLine, _inventDim, _capturedWeight, _overPick);
        }

        return this.createDimTrackingRecords(_workLine, _inventDim, _overPick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkLineDimTrackingEntries</Name>
				<Source><![CDATA[
    protected boolean createWorkLineDimTrackingEntries(
        WHSWorkLine         _workLine,
        InventDim           _inventDim,
        WHSCapturedWeight   _capturedWeight,
        boolean             _overPick)
    {
        boolean ret;

        ttsbegin;

        // If raw material overpicking, call into separate method to account for additional WHSWorkInventTrans records
        if (_overPick)
        {
            this.createOverPickDimTracking(_workLine, _inventDim.LicensePlateId);

            if (_capturedWeight && !WHSInventTable::isCatchWeightTagTracked(_workLine.ItemId))
            {
                this.updateDimTrackingWithAverageCapturedWeight(_workLine, _inventDim, _capturedWeight);
            }

            ret = true;
        }
        else
        {
            // If executing a staged pick (put workLine has been executed previously), reference initial pick dim tracking records
            if (WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum))
            {
                ret = this.insertStagedPickDimTrackingRecords(_workLine);
            }
            else
            {
                WMSLocation location = WMSLocation::find(_workLine.wmsLocationId, _workLine.whsWorkTable().InventLocationId);

                // If configuration allow for negative batch picking, call into separate method to create dim tracking records
                if (   _workLine.ItemId
                    && _inventDim.InventBatchId
                    && !location.whsLocationIsLPControlled()
                    && location.whsLocationProfile().AllowNegative
                    && InventTable::find(_workLine.ItemId).whsAllowPhysNeg())
                {
                    this.parmInventGTDId(_inventDim.InventGtdId_RU);

                    this.createDimTrackingNegative(_workLine, _workLine.InventTransId, _inventDim.InventBatchId);
                    ret = true;
                }
                else
                {
                    // Create initial pick dim tracking records
                    ret = this.insertInitialPickDimTrackingRecords(_workLine, _inventDim);

                    if (_capturedWeight && !this.useInventoryOnHandWeight(_workLine, _inventDim, _capturedWeight))
                    {
                        this.updateDimTrackingWithAverageCapturedWeight(_workLine, _inventDim, _capturedWeight);
                    }
                }
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventGTDId</Name>
				<Source><![CDATA[
    private InventGTDId_RU parmInventGTDId(InventGTDId_RU _inventGTDId = inventGTDId)
    {
        inventGTDId = _inventGTDId;

        return inventGTDId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimTrackingWithAverageCapturedWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates average weight and updates the <c>WHSDimTracking</c> records with the captured weight based on the number of units.
    /// </summary>
    /// <param name = "_workLine">A <c>WHSWorkLine</c> buffer.</param>
    /// <param name = "_inventDim">A <c>InventDim</c> buffer.</param>
    /// <param name = "_capturedWeight">Total weight that was captured.</param>
    private void updateDimTrackingWithAverageCapturedWeight(WHSWorkLine _workLine, InventDim _inventDim, WHSCapturedWeight _capturedWeight)
    {
        if (!_workLine || _capturedWeight <= 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        InventHandlingQty runningHandlingQty    = WHSCatchWeightHelper::calculatePickingQuantity(_workLine, _inventDim);
        WHSTransWeight runningWeight            = _capturedWeight;

        UnitOfMeasureDecimalPrecision decimalPrecision = InventTable::inventDecimals(_workLine.ItemId);

        WHSDimTracking dimTrackingLoop;

        while select forupdate dimTrackingLoop
            where dimTrackingLoop.WorkId        == _workLine.WorkId
                && dimTrackingLoop.LineNum      == _workLine.LineNum
                && dimTrackingLoop.Processed    == NoYes::No
        {
            // For the handling quantity for which user has provided the weight, set the average weight based on the user input.
            if (runningHandlingQty > 0)
            {
                dimTrackingLoop.CapturedWeight = decRound(WHSCatchWeightHelper::calculateAverageWeight(dimTrackingLoop.Qty, runningHandlingQty, runningWeight),
                                                     decimalPrecision);

                // reduce the running quantity that is used in the captured weight calculation
                runningHandlingQty  -= dimTrackingLoop.Qty;
                runningWeight       -= dimTrackingLoop.CapturedWeight;
            }
            else
            {
                // For the remaining quantity, set the default weight based on the total weight and total quantity of the item within the dimension set.
                dimTrackingLoop.CapturedWeight = WHSCatchWeightHelper::calculateDefaultWeightForPick(_workLine.ItemId,
                                                                                                     InventDim::find(dimTrackingLoop.InventDimId),
                                                                                                     dimTrackingLoop.Qty,
                                                                                                     decimalPrecision);
            }

            dimTrackingLoop.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInventoryOnHandWeight</Name>
				<Source><![CDATA[
    private boolean useInventoryOnHandWeight(WHSWorkLine _workLine, InventDim _inventDim, WHSCapturedWeight _capturedWeight)
    {
        boolean ret = false;

        if (WHSInventTable::outboundWeightVarianceMethod(_workLine.ItemId) == WHSOutboundWeightVarianceMethod::Restrict)
        {
            ret = WHSInventOnHand::getWorkPhysicalInventByInventDim(_workLine.ItemId, _inventDim) == _capturedWeight;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method manages the creation of dim tracking records used to track below License Plate dimensions during work execution.
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed
    /// </param>
    /// <param name="_inventDim">
    /// The below Location dimension set used for picking
    /// </param>
    /// <param name="_overPick">
    /// A boolean distinguishing if we are doing raw material overpicking
    /// </param>
    /// <returns>
    /// true if any dim tracking records were inserted; otherwise false
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the createWorkDimTrackingEntries method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    protected boolean createDimTrackingRecords(
        WHSWorkLine _workLine,
        InventDim   _inventDim,
        boolean     _overPick = false)
    {
        if (_workLine.ItemId)
        {
            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workLine.ItemId);
        }

        return this.createWorkLineDimTrackingEntries(
                        _workLine,
                        _inventDim,
                        0,  // no weight will be provided for non warehouse enabled cw items
                        _overPick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExtraWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates extra work inventory transaction records for missing quantity.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the work inventory transactions
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work inventory transactions.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_inventSiteId">
    /// Site id.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Location id.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_qty">
    /// Item quantity.
    /// </param>
    /// <param name="_create">
    /// Determines whether to create a work transaction or not, default value is false.
    /// </param>
    /// <returns>
    /// Total quantity of created work transactions.
    /// </returns>
    InventQty createExtraWorkInventTrans(WHSWorkId          _workId,
                                         LineNum            _lineNum,
                                         InventLocationId   _inventLocationId,
                                         InventSiteId       _inventSiteId,
                                         WMSLocationId      _wmsLocationId,
                                         WHSLicensePlateId  _licensePlateId,
                                         ItemId             _itemId,
                                         InventQty          _qty,
                                         boolean            _create = false)
    {
        WHSWorkInventTrans  workInventTrans;
        WHSLicensePlate     licensePlate;
        InventDimId         inventDimIdFrom;
        InventDimId         inventDimIdTo;
        InventDim           inventDim;
        InventDim           tmpInventDim;
        InventDim           inventDimCriteria;
        InventDimParm       inventDimParm;
        InventSum           inventSum;
        InventQty           qty;
        InventQty           testQty = _qty;
        boolean             create = _create;

        ttsbegin;

        licensePlate = WHSLicensePlate::find(_licensePlateId);

        if (licensePlate.LicensePlateLevel == 0)
        {
            inventDimCriteria = WHSWorkLine::find(_workId, _lineNum).inventDim();
            inventDimCriteria.wmsLocationId = _wmsLocationId;
            inventDimCriteria.LicensePlateId = _licensePlateId;
            inventDimParm.initFromInventDim(inventDimCriteria);

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select PhysicalInvent, ItemId, #InventDimGroupAllFields from inventSum
                    where inventSum.ClosedQty == NoYes::No
                       && #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm)
                {
                    if (inventSum.ItemId == _itemId && inventSum.PhysicalInvent != qty && testQty)
                    {
                        qty = inventSum.PhysicalInvent - testQty;
                        testQty = 0;
                        create = true;
                    }
                    else
                    {
                        qty = inventSum.PhysicalInvent;
                    }

                    if (qty)
                    {
                        tmpInventDim.clear();
                        tmpInventDim.initFromInventSum(inventSum);
                        tmpInventDim.LicensePlateId = '';
                        tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                        inventDimIdFrom = tmpInventDim.InventDimId;

                        tmpInventDim.wmsLocationId = '';
                        tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                        inventDimIdTo = tmpInventDim.InventDimId;

                        workInventTrans.clear();

                        if (!workInventTrans || create)
                        {
                            workInventTrans.WorkId              = _workId;
                            workInventTrans.LineNum             = _lineNum;
                            workInventTrans.ItemId              = inventSum.ItemId;
                            workInventTrans.Qty                 = qty;
                            workInventTrans.InventQtyRemain     = qty;
                            workInventTrans.InventDimIdFrom     = inventDimIdFrom;
                            workInventTrans.InventDimIdTo       = inventDimIdTo;
                            workInventTrans.InventTransIdParent = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
                            workInventTrans.TransDateTime       = DateTimeUtil::utcNow();
                        }
                        else
                        {
                            workInventTrans.Qty                 += qty;
                            workInventTrans.InventQtyRemain     += qty;
                        }
                        workInventTrans.write();
                    }
                }
            }
            else
            {
                while select PhysicalInvent, ItemId from inventSum
                where inventSum.ClosedQty == NoYes::No
                #InventDimInnerJoin(inventSum.inventDimId, inventDim, inventDimCriteria, inventDimParm)
                {
                    if (inventSum.ItemId == _itemId && inventSum.PhysicalInvent != qty && testQty)
                    {
                        qty = inventSum.PhysicalInvent - testQty;
                        testQty = 0;
                        create = true;
                    }
                    else
                    {
                        qty = inventSum.PhysicalInvent;
                    }

                    if (qty)
                    {
                        tmpInventDim = inventDim;
                        tmpInventDim.LicensePlateId = '';
                        tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                        inventDimIdFrom = tmpInventDim.InventDimId;

                        tmpInventDim.wmsLocationId = '';
                        tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                        inventDimIdTo = tmpInventDim.InventDimId;

                        workInventTrans.clear();

                        if (!workInventTrans || create)
                        {
                            workInventTrans.WorkId              = _workId;
                            workInventTrans.LineNum             = _lineNum;
                            workInventTrans.ItemId              = inventSum.ItemId;
                            workInventTrans.Qty                 = qty;
                            workInventTrans.InventQtyRemain     = qty;
                            workInventTrans.InventDimIdFrom     = inventDimIdFrom;
                            workInventTrans.InventDimIdTo       = inventDimIdTo;
                            workInventTrans.InventTransIdParent = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
                            workInventTrans.TransDateTime       = DateTimeUtil::utcNow();
                        }
                        else
                        {
                            workInventTrans.Qty                 += qty;
                            workInventTrans.InventQtyRemain     += qty;
                        }
                        workInventTrans.write();
                    }
                }
            }
        }
        else
        {
            licensePlate.clear();

            while select LicensePlateId from licensePlate
                where licensePlate.LicensePlateParent == _licensePlateId
            {
                testQty = this.createExtraWorkInventTrans(_workId,
                                                          _lineNum,
                                                          _inventLocationId,
                                                          _inventSiteId,
                                                          _wmsLocationId,
                                                          licensePlate.LicensePlateId,
                                                          _itemId,
                                                          testQty,
                                                          create);
            }
        }

        ttscommit;

        return testQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an inventory journal header record.
    /// </summary>
    /// <param name="_workId">
    /// Work is to be set in the description field of the journal.
    /// </param>
    /// <param name="_adjustmentTypeCode">
    /// Adjustment type code to be used to find journal name.
    /// </param>
    /// <param name="_workerRecId">
    /// Passed in the recid of whsworker in createInventHeader
    /// </param>
    /// <returns>
    /// Inventory journal header record.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when adjustment type code is invalid.
    /// </exception>
    [SysObsolete('Use WHSInventAdjustmentCreate for creating inventory adjustments', false, 30\11\2017)]
    public InventJournalTable createInventHeader(WHSWorkId             _workId,
                                                 WHSAdjustmentTypeCode _adjustmentTypeCode,
                                                 WHSWorkerRecId        _workerRecId = 0)
    {
        InventJournalTable          journalTable;
        InventJournalName           journalName;
        WHSAdjustmentType           adjustmentType;

        ttsbegin;

        adjustmentType  = WHSAdjustmentType::find(_adjustmentTypeCode);
        dimParm.setAllInventDim();

        if (!_adjustmentTypeCode)
        {
            throw error("@WAX1473");
        }

        journalName = InventJournalName::find(adjustmentType.InventJournalNameId);

        journalTable.initFromInventJournalName(journalName);
        journalTable.initValue();
        journalTable.InventDimFixed = dimParm.inventDimFixed();
        journalTable.Reservation    = journalName.Reservation;
        journalTable.NumOfLines     = 1;
        journalTable.Description    = _workId;
        journalTable.Worker         = _workerRecId;
        journalTable.insert();

        ttscommit;

        return journalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Method creates the journal lines tied to _journalTable.
    /// </summary>
    /// <param name = "_journalTable">
    ///    Parameter relates to the InventJournalTable record journal lines will be assigned to.
    /// </param>
    /// <param name = "_workTrans">
    ///    The work trans record used to establish journal line from inventTable.
    /// </param>
    /// <param name = "_lineNum">
    ///    The line number established from work trans in createCountingJournal.
    /// </param>
    /// <param name = "_qty">
    ///    The qty passed in from workTrans creation in createCountingJournal.
    /// </param>
    [SysObsolete('Use WHSInventAdjustmentCreate for creating inventory adjustments', false, 30\11\2017)]
    public void createInventLine(InventJournalTable     _journalTable,
                                 WHSWorkTrans           _workTrans,
                                 LineNum                _lineNum,
                                 Qty                    _qty)
    {
        InventJournalTrans          journalTrans;
        InventSumDateDim            sumDateDim = new InventSumDateDim();
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        ttsbegin;

        journalTrans.initFromInventJournalTable(_journalTable);
        journalTrans.initFromInventTable(InventTable::find(_workTrans.ItemId));
        journalTrans.setInventDimId(_workTrans.InventDimId);
        journalTrans.LineNum            = _lineNum;
        journalTrans.Qty                = releasedProductUnitConverter.convert(_qty,
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_workTrans.uom),
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(InventTableModule::find(_workTrans.ItemId, ModuleInventPurchSales::Invent).UnitId),
                                                                        NoYes::No,
                                                                               _workTrans.ItemId,
                                                                               _workTrans.InventDimId,
                                                                        NoYes::No);
        journalTrans.TransDate          = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        journalTrans.LedgerDimension    = _journalTable.LedgerDimension;
        sumDateDim                      = InventSumDateDim::newParameters(
                                                                        journalTrans.TransDate,
                                                                        journalTrans.ItemId,
                                                                        journalTrans.inventDim(),
                                                                        dimParm);
        journalTrans.InventOnHand       = sumDateDim.postedQty();
        journalTrans.Counted            = journalTrans.InventOnHand + journalTrans.Qty;
        journalTrans.Worker             = _journalTable.Worker;
        journalTrans.setCostPrice();
        journalTrans.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMovementWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work inventory transaction records for movement work type.
    /// </summary>
    /// <param name="_workId">
    /// Work id.
    /// </param>
    /// <param name="_lineNum">
    /// Work line number.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the inventory item that is subject to movement.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// Initial dimensions of the inventory item that is subject to movement.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// Final dimensions of the inventory item that is subject to movement.
    /// </param>
    /// <param name="_keepLicensePlate">
    /// Determines whether the final dimensions should keep license plate information.
    /// </param>
    /// <param name="_hasLicensePlate">
    /// Determines whether the initial dimensions should keep license plate information.
    /// </param>
    [SysObsolete("This method will not be used in future releases", false, 31\03\2019)]
    void createMovementWorkInventTrans(WHSWorkId            _workId,
                                       LineNum              _lineNum,
                                       WHSLicensePlateId    _licensePlateId,
                                       InventDimId          _inventDimIdFrom,
                                       InventDimId          _inventDimIdTo,
                                       boolean              _keepLicensePlate = true,
                                       boolean              _hasLicensePlate = true)
    {
        WHSWorkInventTrans          workInventTrans;
        WHSLicensePlate             licensePlate = WHSLicensePlate::find(_licensePlateId);
        WHSLicensePlateLevel        level = licensePlate.LicensePlateLevel;
        WHSWorkLine                 workLine;
        Qty                         qty;
        InventDimId                 inventDimIdFrom;
        InventDimId                 inventDimIdTo = _inventDimIdTo;
        InventDim                   inventDim;
        InventSum                   inventSum;

        ttsbegin;

        if (level == 0)
        {
            inventDim = InventDim::find(_inventDimIdFrom);
            if (_hasLicensePlate)
            {
                inventDim.LicensePlateId = _licensePlateId;
            }
            inventDimIdFrom = InventDim::findOrCreate(inventDim).InventDimId;

            inventDim = InventDim::find(_inventDimIdTo);
            inventDim.LicensePlateId = _keepLicensePlate ? _licensePlateId : '';
            inventDimIdTo = InventDim::findOrCreate(inventDim).InventDimId;

            if (_licensePlateId && _hasLicensePlate)
            {
                while select ItemId, PhysicalInvent from inventSum
                    where inventSum.InventDimId == inventDimIdFrom &&
                          inventSum.ClosedQty   == NoYes::No &&
                          inventSum.PhysicalInvent > 0
                {
                    workInventTrans.clear();
                    workInventTrans.WorkId = _workId;
                    workInventTrans.LineNum = _lineNum;
                    workInventTrans.ItemId = inventSum.ItemId;
                    workInventTrans.Qty = inventSum.PhysicalInvent;
                    workInventTrans.InventQtyRemain = inventSum.PhysicalInvent;
                    workInventTrans.InventDimIdFrom = inventDimIdFrom;
                    workInventTrans.InventDimIdTo = inventDimIdTo;
                    workInventTrans.InventTransIdParent = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
                    workInventTrans.WorkHasReservation = NoYes::Yes;
                    workInventTrans.TransDateTime = DateTimeUtil::utcNow();
                    workInventTrans.insert();

                    WHSInvent::moveWorkQuantities(workInventTrans, inventDimIdFrom, inventDimIdTo, inventSum.PhysicalInvent, 0);
                }
            }
            else
            {
                workLine = WHSWorkLine::find(_workId, _lineNum);
                qty = InventTableModule::unitConvert(workLine.ItemId,
                                                     ModuleInventPurchSales::Invent,
                                                     workLine.UnitId,
                                                     workLine.QtyWork,
                                                     workLine.InventDimId);

                workInventTrans.clear();
                workInventTrans.WorkId = _workId;
                workInventTrans.LineNum = _lineNum;
                workInventTrans.ItemId = workLine.ItemId;
                workInventTrans.Qty = qty;
                workInventTrans.InventQtyRemain = qty;
                workInventTrans.InventDimIdFrom = inventDimIdFrom;
                workInventTrans.InventDimIdTo = inventDimIdTo;
                workInventTrans.InventTransIdParent = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
                workInventTrans.WorkHasReservation = NoYes::Yes;
                workInventTrans.TransDateTime = DateTimeUtil::utcNow();
                workInventTrans.insert();

                WHSInvent::moveWorkQuantities(workInventTrans, inventDimIdFrom, inventDimIdTo, qty, 0);
            }
        }
        else
        {
            licensePlate.clear();
            while select licensePlate
                where licensePlate.LicensePlateParent == _licensePlateId
            {
                this.createMovementWorkInventTrans(_workId,
                                                   _lineNum,
                                                   licensePlate.LicensePlateId,
                                                   _inventDimIdFrom,
                                                   _inventDimIdTo);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allWorkInventTransQtyCreated</Name>
				<Source><![CDATA[
    private boolean allWorkInventTransQtyCreated(WHSWorkLine _workLine)
    {
        WHSWorkInventTrans  workInventTrans;

        if (_workLine.WorkId && _workLine.LineNum)
        {
            select sum(Qty) from workInventTrans
                where workInventTrans.WorkId        == _workLine.WorkId
                    &&    workInventTrans.LineNum   == _workLine.LineNum;

            return workInventTrans.Qty == _workLine.InventQtyWork;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatusChangingDuringWork</Name>
				<Source><![CDATA[
    private boolean isStatusChangingDuringWork(
        ItemId              _itemId,
        InventDim           _workLineInventDim,
        InventDimId         _witInventDimId,
        WHSWorkTransType    _workTransType)
    {
        boolean dimSameExceptStatusChanging;

        // It's possible to change status during a movement,
        // in order to build up the next work invent transaction correctly,
        // must check to see if previous work line had a different status.
        if (_workTransType == WHSWorkTransType::Invent)
        {
            InventDim witInventDimNoStatus = InventDim::find(_witInventDimId);
            InventDim workLineDimNoStatus = _workLineInventDim;
            
            if (witInventDimNoStatus.InventStatusId
                && workLineDimNoStatus.InventStatusId
                && witInventDimNoStatus.InventStatusId != workLineDimNoStatus.InventStatusId)
            {
                witInventDimNoStatus.InventStatusId = '';
                workLineDimNoStatus.InventStatusId = '';

                dimSameExceptStatusChanging = InventDim::isInventDimEqualWHSNonWork(witInventDimNoStatus, workLineDimNoStatus, _itemId);
            }
        }

        return dimSameExceptStatusChanging;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNextWorkInventTransQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates next work inventory transaction based on the current work line.
    /// </summary>
    /// <param name="_currentWorkLine">
    /// The current work line.
    /// </param>
    /// <param name="_workInventTrans">
    /// The current work inventory transaction.
    /// </param>
    /// <param name="_qty">
    /// Current quantity.
    /// </param>
    /// <param name="_transWeight">
    /// Current weight, will be zero except for warehouse enabled catch weight items.
    /// </param>
    /// <param name="_startLine">
    /// The start line number.
    /// </param>
    /// <param name="_wmsLocationId">
    /// The location of the current work.
    /// </param>
    /// <param name="_overPicking">
    /// Determines whether it is over picked in the current work, false by default. Optional.
    /// </param>
    /// <param name="_inventDimIdFromSpecific">
    /// The inventory dimension ID for the transaction; optional.
    /// </param>
    [Hookable(false)]
    final public void createNextWorkInventTransQuantities(
        WHSWorkLine         _currentWorkLine,
        WHSWorkInventTrans  _workInventTrans,
        InventHandlingQty   _qty,
        WHSTransWeight      _transWeight,
        LineNum             _startLine,
        WMSLocationId       _wmsLocationId,
        boolean             _overPicking,
        InventDimId         _inventDimIdFromSpecific)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _workInventTrans.ItemId, _transWeight))
        {
            this.createNextWorkInventTransQty(_currentWorkLine,
                    _workInventTrans,
                    _qty,
                    _transWeight,
                    _startLine,
                    _wmsLocationId,
                    _overPicking,
                    _inventDimIdFromSpecific);
        }
        else
        {
            this.createNextWorkInventTrans(_currentWorkLine,
                    _workInventTrans,
                    _qty,
                    _startLine,
                    _wmsLocationId,
                    _overPicking,
                    _inventDimIdFromSpecific);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNextWorkInventTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates next work inventory transaction based on the current work line.
    /// </summary>
    /// <param name="_currentWorkLine">
    /// The current work line.
    /// </param>
    /// <param name="_workInventTrans">
    /// The current work inventory transaction.
    /// </param>
    /// <param name="_qty">
    /// Current quantity.
    /// </param>
    /// <param name="_transWeight">
    /// Current weight, will be zero except for warehouse enabled catch weight items.
    /// </param>
    /// <param name="_startLine">
    /// The start line number.
    /// </param>
    /// <param name="_wmsLocationId">
    /// The location of the current work.
    /// </param>
    /// <param name="_overPicking">
    /// Determines whether it is over picked in the current work, false by default. Optional.
    /// </param>
    /// <param name="_inventDimIdFromSpecific">
    /// The inventory dimension ID for the transaction; optional.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the createNextWorkInventTransQuantities method.
    /// </remarks>
    [Wrappable(true)]
    protected void createNextWorkInventTransQty(
        WHSWorkLine         _currentWorkLine,
        WHSWorkInventTrans  _workInventTrans,
        InventHandlingQty   _qty,
        InventQty           _transWeight,
        LineNum             _startLine,
        WMSLocationId       _wmsLocationId,
        boolean             _overPicking,
        InventDimId         _inventDimIdFromSpecific)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _workInventTrans.ItemId, _qty, _transWeight);
        
        WHSWorkInventTrans      newWorkInventTrans;
        WHSWorkTransType        workTransType;
        WHSWorkType             oppositeWorkType;
        WHSWorkLine             workLine;
        InventQty               qtyLeftOnWorkLine;
        InventQty               qtyLeftToProcess;
        InventQty               qtyToUpdate;
        InventDim               inventDim;
        InventDim               tmpInventDim;
        InventDim               workInventTransInventDim;
        InventDim               inventDimFrom, inventDimTo;

        ttsbegin;

        if (_startLine)
        {
            InventQty weightLeftToProcess = _transWeight;
            InventQty weightToUpdate;

            UnitOfMeasureDecimalPrecision weightUnitDecimalPrecision = InventTable::inventDecimals(_currentWorkLine.ItemId);

            qtyLeftToProcess = _qty;
            oppositeWorkType = _currentWorkLine.WorkType == WHSWorkType::Put ? WHSWorkType::Pick : WHSWorkType::Put;
            workTransType = WHSWorkTable::find(_currentWorkLine.WorkId).WorkTransType;

            // Only invent movements can change statuses during work execution.
            if (_currentWorkLine.WorkType == WHSWorkType::Pick
                && workTransType == WHSWorkTransType::Invent)
            {
                this.changeWorkStatusAfterPick(_currentWorkLine, _startLine, _workInventTrans.InventDimIdTo, _transWeight);
            }

            //some work types can pick up additional material which is not seen as an overpick from the warehouse workers side
            boolean workTransTypeMustAlwaysConsiderOverPick = (workTransType == WHSWorkTransType::ProdPick || workTransType == WHSWorkTransType::KanbanPick);
            workInventTransInventDim = InventDim::find(_workInventTrans.InventDimIdTo);

            WHSWorkInventTrans existWorkInventTrans;
            WHSWorkLine pickLineInventTransIdParent;
            if (workTransTypeMustAlwaysConsiderOverPick)
            {
                select firstOnly InventTransId from pickLineInventTransIdParent
                    order by LineNum
                    where pickLineInventTransIdParent.WorkId == _currentWorkLine.WorkId
                        && pickLineInventTransIdParent.InventTransId != ''
                    exists join existWorkInventTrans
                        where existWorkInventTrans.WorkId                == pickLineInventTransIdParent.WorkId
                           && existWorkInventTrans.LineNum               == pickLineInventTransIdParent.LineNum
                           && existWorkInventTrans.InventTransIdParent   == _workInventTrans.InventTransIdParent;
            }
            while select workLine
                order by LineNum
                where workLine.WorkId           == _currentWorkLine.WorkId      &&
                      workLine.LineNum          >= _startLine                   &&
                      workLine.WorkStatus       != WHSWorkStatus::Skipped       &&
                      (!workLine.ItemId         || workLine.ItemId == _workInventTrans.ItemId)
            {
                if (workLine.WorkType == oppositeWorkType)
                {
                    // Analyze if the current WorkLine matches the WorkInventTrans record that we need to create a successor WorkInventTrans record for.
                    if (!_overPicking
                        &&  (!workTransTypeMustAlwaysConsiderOverPick
                            || (!pickLineInventTransIdParent.InventTransId || pickLineInventTransIdParent.InventTransId == _workInventTrans.InventTransIdParent)))
                    {
                        if (workTransTypeMustAlwaysConsiderOverPick || !this.allWorkInventTransQtyCreated(workLine))
                        {
                            boolean dimEqualExceptStatusChange = this.isStatusChangingDuringWork(workLine.ItemId,
                                                                                                 workLine.inventDim(),
                                                                                                 workInventTransInventDim.inventDimId,
                                                                                                 workTransType);

                            if ((!workLine.InventTransId || workLine.InventTransId == _workInventTrans.InventTransIdParent)
                            &&  (!workLine.ItemId
                            ||   (workLine.ItemId == _workInventTrans.ItemId
                            &&   (WHSWorkLine::isInventDimBlankOrProductDimensionOnly(workLine.InventDimId)
                                || (InventDim::isInventDimEqualWHSNonWork(workInventTransInventDim, workLine.inventDim(), workLine.ItemId)
                                    || dimEqualExceptStatusChange)))))
                            {
                                buf2Buf(workInventTransInventDim, tmpInventDim);
                                tmpInventDim.wmsLocationId = _wmsLocationId;
                                tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                                newWorkInventTrans = WHSWorkInventTrans::find(workLine.WorkId, workLine.LineNum, _workInventTrans.ItemId, _workInventTrans.InventTransIdParent, tmpInventDim.InventDimId, true);

                                if (newWorkInventTrans)
                                {
                                    if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLine.WorkId)
                                        && _workInventTrans.InventQtyRemain == 0)
                                    {
                                        // We expect that the work inventory transaction is not executed yet (even partially), only reservation exists.
                                        Debug::assert(newWorkInventTrans.InventQtyRemain == newWorkInventTrans.Qty);

                                        // Add the contents of the item sets with the inventory status of the workLine.
                                        WHSInventoryItemSetElement::addItemsFromSet(
                                            _workInventTrans.ItemSetId,
                                            newWorkInventTrans.ItemSetId,
                                            WHSInventoryProductTrackingDimensions::construct().setInventStatusId(workLine.inventDim().InventStatusId));
                                    }

                                    qtyLeftOnWorkLine = workLine.InventQtyRemain - newWorkInventTrans.Qty;

                                    if (qtyLeftOnWorkLine)
                                    {
                                        qtyToUpdate = qtyLeftOnWorkLine < qtyLeftToProcess ? qtyLeftOnWorkLine : qtyLeftToProcess;

                                        //we are only updating the from dimensions to be specific since there is no way they can differ since we need to remove exactly what we added
                                        //the to-dimensions cannot safely be updated to the most specific level of details since we do not know if the location will be changed by the user during the put operation
                                        if (_inventDimIdFromSpecific)
                                        {
                                            newWorkInventTrans.createTransForSpecificDimensions(qtyToUpdate, InventDim::find(_inventDimIdFromSpecific), InventDim::find(newWorkInventTrans.InventDimIdTo), true);
                                        }
                                        else
                                        {
                                            if (weightLeftToProcess)
                                            {
                                                if (qtyToUpdate < qtyLeftToProcess)
                                                {
                                                    weightToUpdate = WHSCatchWeightHelper::calculateAverageWeight(qtyToUpdate, qtyLeftToProcess, weightLeftToProcess, weightUnitDecimalPrecision);
                                                }
                                                else
                                                {
                                                    weightToUpdate = weightLeftToProcess;
                                                }

                                                weightLeftToProcess -= weightToUpdate;
                                            }

                                            newWorkInventTrans.increaseQuantities(qtyToUpdate, weightToUpdate);
                                        }

                                        qtyLeftToProcess -= qtyToUpdate;
                                    }
                                }
                                else
                                {
                                    qtyToUpdate = min(workLine.InventQtyRemain, qtyLeftToProcess);

                                    if (qtyToUpdate > 0)
                                    {
                                        newWorkInventTrans.initFromWorkInventTrans(_workInventTrans);
                                        newWorkInventTrans.LineNum          = workLine.LineNum;
                                        newWorkInventTrans.Qty              = qtyToUpdate;
                                        newWorkInventTrans.InventQtyRemain  = qtyToUpdate;

                                        if (qtyToUpdate < qtyLeftToProcess)
                                        {
                                            weightToUpdate = WHSCatchWeightHelper::calculateAverageWeight(qtyToUpdate, qtyLeftToProcess, weightLeftToProcess, weightUnitDecimalPrecision);
                                        }
                                        else
                                        {
                                            weightToUpdate = weightLeftToProcess;
                                        }

                                        newWorkInventTrans.TransactionWeight            = weightToUpdate;
                                        newWorkInventTrans.RemainingTransactionWeight   = newWorkInventTrans.TransactionWeight;

                                        weightLeftToProcess -= weightToUpdate;

                                        // Set the location on the from inventDim based on the passed in location.
                                        inventDimFrom = InventDim::find(newWorkInventTrans.InventDimIdFrom);
                                        inventDimFrom.wmsLocationId = _wmsLocationId;

                                        WHSLicensePlateId originalInventDimFromLicensePlateId = inventDimFrom.LicensePlateId;
                                        WHSLicensePlateId targetLicensePlateId = _currentWorkLine.whsWorkTable().TargetLicensePlateId;
                                        
                                        // add reservation on license plate level for handle by lp
                                        if (_inventDimIdFromSpecific && WhsInventoryTransactionLicensePlateHandledByLPContext::instance() != null)
                                        {
                                            inventDimFrom.LicensePlateId = InventDim::find(_inventDimIdFromSpecific).LicensePlateId;
                                        }

                                        // add reservation on license plate level for next pick line work.
                                        if (targetLicensePlateId
                                            && this.mustAddReservationOnLicensePlateByWorkTransType(workTransType)
                                            && workLine.WorkType == WHSWorkType::Pick)
                                        {
                                            inventDimFrom.LicensePlateId = targetLicensePlateId;
                                        }
          
                                        if (dimEqualExceptStatusChange)
                                        {
                                            inventDimFrom.InventStatusId = workLine.inventDim().InventStatusId;
                                        }

                                        inventDimFrom = InventDim::findOrCreate(inventDimFrom);
                                        newWorkInventTrans.InventDimIdFrom = inventDimFrom.InventDimId;

                                        // To InventDim is different for pick or put.  Pick has no location, Put has a location.
                                        inventDimTo.data(inventDimFrom);
                                        inventDimTo.wmsLocationId = workLine.WorkType == WHSWorkType::Put ? workLine.wmsLocationId : '';
                                        inventDimTo.LicensePlateId = originalInventDimFromLicensePlateId;
                                        inventDimTo = InventDim::findOrCreate(inventDimTo);
                                        newWorkInventTrans.InventDimIdTo = inventDimTo.InventDimId;

                                        // pass the constructed item set to the next work line when the current work transaction is completed.
                                        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLine.WorkId)
                                            && _workInventTrans.InventQtyRemain == 0)
                                        {
                                            // for initial picks create a duplicate item set; but for subsequent work lines can reuse the item set.
                                            if (_currentWorkLine.isInitialPickLine())
                                            {
                                                // Duplicate the ItemSet with the inventory status of the put invent dim.
                                                newWorkInventTrans.ItemSetId = WHSInventoryItemSetElement::duplicateItemSet(
                                                    _workInventTrans.ItemSetId,
                                                    WHSInventoryProductTrackingDimensions::construct().setInventStatusId(inventDimTo.InventStatusId));
                                            }
                                            else
                                            {
                                                newWorkInventTrans.ItemSetId = _workInventTrans.ItemSetId;
                                            }
                                        }

                                        //we are only updating the from dimensions to be specific since there is no way they can differ since we need to remove exactly what we added
                                        //the to-dimensions cannot safely be updated to the most specific level of details since we do not know if the location will be changed by the user during the put operation
                                        if (_inventDimIdFromSpecific)
                                        {
                                            newWorkInventTrans.insertWithSpecificDimensions(newWorkInventTrans.Qty, inventDimFrom, inventDimTo, InventDim::find(_inventDimIdFromSpecific), inventDimTo, true);
                                        }
                                        else
                                        {
                                            newWorkInventTrans.insert();
                                        }

                                        qtyLeftToProcess -= qtyToUpdate;
                                    }
                                }
                            }
                        }
                    }
                    else    // Overpicking
                    {
                        buf2Buf(workInventTransInventDim, tmpInventDim);
                        tmpInventDim.wmsLocationId = _wmsLocationId;
                        tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                        newWorkInventTrans = WHSWorkInventTrans::find(workLine.WorkId, workLine.LineNum, _workInventTrans.ItemId, _workInventTrans.InventTransIdParent, tmpInventDim.InventDimId, true);

                        if (newWorkInventTrans)
                        {
                            if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLine.WorkId)
                                && _workInventTrans.InventQtyRemain == 0)
                            {
                                // We expect that the work inventory transaction is not executed yet (even partially), only reservation exists.
                                Debug::assert(newWorkInventTrans.InventQtyRemain == newWorkInventTrans.Qty);

                                // Add the contents of the item sets with the inventory status of the workLine.
                                WHSInventoryItemSetElement::addItemsFromSet(
                                    _workInventTrans.ItemSetId,
                                    newWorkInventTrans.ItemSetId,
                                    WHSInventoryProductTrackingDimensions::construct().setInventStatusId(workLine.inventDim().InventStatusId));
                            }

                            qtyLeftOnWorkLine = workLine.InventQtyRemain - newWorkInventTrans.Qty;

                            if (qtyLeftOnWorkLine)
                            {
                                qtyToUpdate = qtyLeftOnWorkLine < qtyLeftToProcess ? qtyLeftOnWorkLine : qtyLeftToProcess;

                                if (weightLeftToProcess)
                                {
                                    weightToUpdate      = weightLeftToProcess;
                                    weightLeftToProcess -= weightToUpdate;
                                }

                                newWorkInventTrans.increaseQuantities(qtyToUpdate, weightToUpdate);

                                qtyLeftToProcess -= qtyToUpdate;
                            }
                        }
                        else
                        {
                            newWorkInventTrans.initFromWorkInventTrans(_workInventTrans);
                            newWorkInventTrans.LineNum          = workLine.LineNum;
                            newWorkInventTrans.Qty              = min(_workInventTrans.Qty, _qty);
                            newWorkInventTrans.InventQtyRemain  = min(_workInventTrans.Qty, _qty);

                            newWorkInventTrans.TransactionWeight            = _transWeight;
                            newWorkInventTrans.RemainingTransactionWeight   = newWorkInventTrans.TransactionWeight;

                            // Set the location on the from inventDim based on the passed in Location.
                            inventDim = InventDim::find(newWorkInventTrans.InventDimIdFrom);
                            inventDim.wmsLocationId = _wmsLocationId;
                            newWorkInventTrans.InventDimIdFrom = InventDim::findOrCreate(inventDim).InventDimId;

                            // To InventDim is different for pick or put.  Pick has no location;
                            // Put has a location.
                            inventDim = InventDim::find(newWorkInventTrans.InventDimIdFrom);
                            inventDim.wmsLocationId = workLine.WorkType == WHSWorkType::Put ?
                                                        workLine.wmsLocationId : '';
                            newWorkInventTrans.InventDimIdTo = InventDim::findOrCreate(inventDim).InventDimId;

                            // pass the constructed item set to the next work line when the current work transaction is completed.
                            if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLine.WorkId)
                                && _workInventTrans.InventQtyRemain == 0)
                            {
                                // for initial picks create a duplicate item set; but for subsequent work lines can reuse the item set.
                                if (_currentWorkLine.isInitialPickLine())
                                {
                                    // Duplicate the ItemSet with the inventory status of the put invent dim.
                                    newWorkInventTrans.ItemSetId = WHSInventoryItemSetElement::duplicateItemSet(
                                        _workInventTrans.ItemSetId,
                                        WHSInventoryProductTrackingDimensions::construct().setInventStatusId(inventDimTo.InventStatusId));
                                }
                                else
                                {
                                    newWorkInventTrans.ItemSetId = _workInventTrans.ItemSetId;
                                }
                            }

                            newWorkInventTrans.insert();
                            qtyLeftToProcess -= newWorkInventTrans.Qty;
                        }
                    }
                }
                else
                {
                    break;
                }
                // End Opposite

                if (qtyLeftToProcess <= 0)
                {
                    break;
                }
            }
            // End While
            if (qtyLeftToProcess > 0)
            {
                throw error(strFmt("@WAX:WHSWorkStockTransactionNotCreatedError",
                    _currentWorkLine.WorkId,
                    _currentWorkLine.LineNum,
                    _workInventTrans.ItemId,
                    _workInventTrans.InventTransIdParent,
                    _startLine,
                    qtyLeftToProcess));
            }
        }
        // End Start Line

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAddReservationOnLicensePlateByWorkTransType</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean mustAddReservationOnLicensePlateByWorkTransType(WHSWorkTransType _workTransType)
    {
        return _workTransType == WHSWorkTransType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNextWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates next work inventory transaction based on the current work line.
    /// </summary>
    /// <param name="_currentWorkLine">
    /// The current work line.
    /// </param>
    /// <param name="_workInventTrans">
    /// The current work inventory transaction.
    /// </param>
    /// <param name="_qty">
    /// Current quantity.
    /// </param>
    /// <param name="_startLine">
    /// The start line number.
    /// </param>
    /// <param name="_wmsLocationId">
    /// The location of the current work.
    /// </param>
    /// <param name="_overPicking">
    /// Determines whether it is over picked in the current work, false by default. Optional.
    /// </param>
    /// <param name="_inventDimIdFromSpecific">
    /// The inventory dimension ID for the transaction; optional.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the createNextWorkInventTransQuantities method. Extenders should move their logic to wrap or override the createNextWorkInventTransQty method.', false, 30\9\2019)]
    public void createNextWorkInventTrans(
        WHSWorkLine          _currentWorkLine,
        WHSWorkInventTrans   _workInventTrans,
        InventQty            _qty,
        LineNum              _startLine,
        WMSLocationId        _wmsLocationId,
        boolean              _overPicking = false,
        InventDimId          _inventDimIdFromSpecific = '')
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workInventTrans.ItemId);

        this.createNextWorkInventTransQty(
                _currentWorkLine,
                _workInventTrans,
                _qty,
                0, // No weight will be provided for non-cw warehouse enabled items
                _startLine,
                _wmsLocationId,
                _overPicking,
                _inventDimIdFromSpecific);

    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewWorkTrans</Name>
				<Source><![CDATA[
    private WHSWorkTrans initNewWorkTrans(
        WHSWorkLine         _workLine,
        InventDimId         _inventDimId,
        Qty                 _qty,
        WHSUserId           _userId,
        WHSLicensePlateId   _targetLicensePlateId)
    {
        WHSWorkTrans newWorkTrans;

        newWorkTrans.setWorkTransId();
        newWorkTrans.initFromWorkLine(_workLine);
        newWorkTrans.InventDimId   = _inventDimId;
        newWorkTrans.Qty           = _qty;
        newWorkTrans.TransDateTime = DateTimeUtil::utcNow();
        newWorkTrans.UserId        = _userId;

        if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
            || WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
        {
            newWorkTrans.TargetLicensePlateId = _targetLicensePlateId;
        }

        return newWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkTransFromList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the <c>WHSWorkTrans</c> records from the <c>RecordInsertList</c> to the database.
    /// </summary>
    public void insertWorkTransFromList()
    {
        if (rilWHSWorkTrans)
        {
            rilWHSWorkTrans.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipWorkTableStatusUpdate</Name>
				<Source><![CDATA[
    public boolean parmSkipWorkTableStatusUpdate(boolean _skipWorkTableStatusUpdate = skipWorkTableStatusUpdate)
    {
        skipWorkTableStatusUpdate = _skipWorkTableStatusUpdate;

        return skipWorkTableStatusUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseInsertListForWorkTrans</Name>
				<Source><![CDATA[
    public boolean parmUseInsertListForWorkTrans(boolean _useInsertListForWorkTrans = useInsertListForWorkTrans)
    {
        useInsertListForWorkTrans = _useInsertListForWorkTrans;

        return useInsertListForWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmScannedCatchWeightTags</Name>
				<Source><![CDATA[
    public container parmScannedCatchWeightTags(container _scannedCatchWeightTags = scannedCatchWeightTags)
    {
        scannedCatchWeightTags = _scannedCatchWeightTags;

        return scannedCatchWeightTags;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoReallocationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets auto reallocation required variable for reallocation.
    /// </summary>
    /// <param name = "_autoReallocationRequired">Auto reallocation required variable.</param>
    /// <returns>Auto reallocation required variable.</returns>
    [Hookable(false)]
    internal boolean parmAutoReallocationRequired(boolean _autoReallocationRequired = autoReallocationRequired)
    {
        autoReallocationRequired = _autoReallocationRequired;

        return autoReallocationRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReallocationProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets auto reallocation process type for reallocation.
    /// </summary>
    /// <param name = "_reallocationProcess">Reallocation process type.</param>
    /// <returns>Reallocation process type.</returns>
    [Hookable(false)]
    internal WHSItemReallocation parmReallocationProcess(WHSItemReallocation _reallocationProcess = reallocationProcess)
    {
        reallocationProcess = _reallocationProcess;

        return reallocationProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectedLocationId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WMSLocationId parmSelectedLocationId(WMSLocationId _selectedLocationId = selectedLocationId)
    {
        selectedLocationId = _selectedLocationId;

        return selectedLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmManualReallocationSelected</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmManualReallocationSelected(boolean _manualReallocationSelected = manualReallocationSelected)
    {
        manualReallocationSelected = _manualReallocationSelected;

        return manualReallocationSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsGroupPickEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmIsGroupPickEnabled(boolean _isGroupPickEnabled = isGroupPickEnabled)
    {
        isGroupPickEnabled  = _isGroupPickEnabled;

        return isGroupPickEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeOverPickDimTrackingCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimension criteria for dimension tracking records when overpicking a license plate.
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate being picked.
    /// </param>
    /// <returns>The inventory dimension criteria.</returns>
    protected InventDim initializeOverPickDimTrackingCriteria(WHSWorkLine _workLine, WHSLicensePlateId _licensePlateId)
    {
        InventDim inventDimCriteria = InventDim::find(_workLine.inventDimWithLocation().InventDimId);
        inventDimCriteria.LicensePlateId = _licensePlateId;
        return inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOverPickDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts dimension tracking records when overpicking a license plate.
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate being picked.
    /// </param>
    private void createOverPickDimTracking(
        WHSWorkLine         _workLine,
        WHSLicensePlateId   _licensePlateId)
    {
        if (this.itemIsDimTrackingControlled(_workLine.ItemId))
        {
            InventSumAggrDeltaView  inventSumAggrDeltaView;
            WHSWorkInventTrans      workInventTrans;
            InventDimParm           inventDimParm;
            WHSDimTracking          dimTracking;
            Qty                     workInventTransQty, consumedQty;
            InventDim               loopInventDim;
            Map                     consumedInventory = new Map(Types::String, Types::Real);
            WHSWorkTransType        workTransType     = _workLine.whsWorkTable().WorkTransType;
            InventDim				inventDim;

            ttsbegin;
            InventDim inventDimCriteria = this.initializeOverPickDimTrackingCriteria(_workLine, _licensePlateId);

            inventDimParm.initFromInventDim(inventDimCriteria);

            while select ItemId, InventQtyRemain, InventTransIdParent from workInventTrans
                where workInventTrans.WorkId == _workLine.WorkId
                    && workInventTrans.LineNum == _workLine.LineNum
                    && workInventTrans.InventQtyRemain > 0
            {
                boolean isItemCWEnabled = PdsGlobal::pdsIsCWItem(workInventTrans.ItemId);
                workInventTransQty = workInventTrans.InventQtyRemain;

                while select inventSumAggrDeltaView
                    where inventSumAggrDeltaView.ItemId == workInventTrans.ItemId
                        && ((!isItemCWEnabled
                                && inventSumAggrDeltaView.PhysicalInvent > 0)
                            || (isItemCWEnabled
                                && inventSumAggrDeltaView.PdsCWPhysicalInvent > 0))
                    #InventDimExistsJoin(inventSumAggrDeltaView.InventDimId, inventDim, inventDimCriteria, inventDimParm)
                {
                    consumedQty = 0;

                    // If some of a particular dimensions inventory is already consumed by a different work invent trans, store off for new dim tracking creation
                    if (consumedInventory.exists(inventSumAggrDeltaView.InventDimId))
                    {
                        consumedQty = consumedInventory.lookup(inventSumAggrDeltaView.InventDimId);
                    }

                    InventHandlingQty qtyAvailForDims = isItemCWEnabled ? inventSumAggrDeltaView.PdsCWPhysicalInvent : inventSumAggrDeltaView.PhysicalInvent;

                    // Validate qty has not already been consumed by previous work invent trans records in the loop
                    if (qtyAvailForDims > consumedQty)
                    {
                        loopInventDim = InventDim::find(inventSumAggrDeltaView.InventDimId);

                        // If the disposition code specified on the batch prevents picking, we must throw an error during dim tracking record creation.
                        if (_workLine.WorkType == WHSWorkType::Pick
                            && loopInventDim.InventBatchId
                            && !InventBatch::find(loopInventDim.InventBatchId, _workLine.ItemId).validateBatchDispCodeForPicking(workTransType))
                        {
                            throw error(strFmt("@WAX5580", loopInventDim.InventBatchId));
                        }

                        dimTracking.WorkId              = _workLine.WorkId;
                        dimTracking.LineNum             = _workLine.LineNum;
                        dimTracking.InventTransIdParent = workInventTrans.InventTransIdParent;
                        dimTracking.InventDimId         = inventSumAggrDeltaView.InventDimId;
                        dimTracking.Qty                 = min((qtyAvailForDims - consumedQty), workInventTransQty);
                        dimTracking.insert();

                        // If value already exists in qty map, increment; otherwise, insert new value
                        if (consumedQty)
                        {
                            consumedInventory.insert(inventSumAggrDeltaView.InventDimId, consumedQty + dimTracking.Qty);
                        }
                        else
                        {
                            consumedInventory.insert(inventSumAggrDeltaView.InventDimId, dimTracking.Qty);
                        }

                        workInventTransQty -= dimTracking.Qty;

                        if (!workInventTransQty)
                        {
                            break;
                        }
                    }
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatusChangeAllowedForCWItem</Name>
				<Source><![CDATA[
    private boolean isStatusChangeAllowedForCWItem(ItemId _itemId)
    {
        return !WHSInventTable::isCatchWeightTagTracked(_itemId)
                || WHSInventTable::catchWeightTagDimensionTrackingMethod(_itemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateQuarantineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines execution path based on the work id being provided Creates and executes quarantine work records.
    /// </summary>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_inventDim">
    /// Inventory dimensions of the item to be quarantined.
    /// </param>
    /// <param name="_fromInventStatusId">
    /// Initial inventory item status.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_qty">
    /// Quantity to be quarantined.
    /// </param>
    /// <param name="_uom">
    /// UOM of the item.
    /// </param>
    /// <param name="_movementByTemplate">
    /// Determines whether the quarantine movement is done by template.
    /// </param>
    /// <param name="_useLPDimensions">
    /// Use the dimensions of the license plate.
    /// </param>
    /// <param name="_workId">
    /// Work Id of the quarantine work being updated and executed.
    /// </param>
    /// <param name="_transWeight">
    /// The weight of the catch weight item, will be zero except for warehouse enabled catch weight items.
    /// </param>
    [Hookable(false)]
    final public void createOrUpdateQuarantineWork(
        WHSUserId           _userId,
        InventDim           _inventDim,
        WHSInventStatusId   _fromInventStatusId,
        ItemId              _itemId,
        InventHandlingQty   _qty,
        WHSUOM              _uom,
        boolean             _movementByTemplate,
        boolean             _useLPDimensions,
        WHSWorkId           _workId,
        WHSTransWeight      _transWeight)
    {
        if (_workId || PdsGlobal::pdsIsCWItem(_itemId))
        {
            this.createOrUpdateAndExecuteQuarantineWork(_userId,
                    _inventDim,
                    _fromInventStatusId,
                    _itemId,
                    _qty,
                    _uom,
                    _movementByTemplate,
                    _useLPDimensions,
                    _workId,
                    _transWeight);
        }
        else
        {
            this.createQuarantineWork(_userId,
                    _inventDim,
                    _fromInventStatusId,
                    _itemId,
                    _qty,
                    _uom,
                    _movementByTemplate,
                    _useLPDimensions);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateAndExecuteQuarantineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines execution path based on the work id being provided Creates and executes quarantine work records.
    /// </summary>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_inventDim">
    /// Inventory dimensions of the item to be quarantined.
    /// </param>
    /// <param name="_fromInventStatusId">
    /// Initial inventory item status.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_qty">
    /// Quantity to be quarantined.
    /// </param>
    /// <param name="_uom">
    /// UOM of the item.
    /// </param>
    /// <param name="_movementByTemplate">
    /// Determines whether the quarantine movement is done by template.
    /// </param>
    /// <param name="_useLPDimensions">
    /// Use the dimensions of the license plate.
    /// </param>
    /// <param name="_workId">
    /// Work Id of the quarantine work being updated and executed.
    /// </param>
    /// <param name="_transWeight">
    /// The weight of the catch weight item, will be zero except for warehouse enabled catch weight items.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the createOrUpdateQuarantineWork method.
    /// </remarks>
    [Wrappable(true)]
    protected void createOrUpdateAndExecuteQuarantineWork(
        WHSUserId           _userId,
        InventDim           _inventDim,
        WHSInventStatusId   _fromInventStatusId,
        ItemId              _itemId,
        InventHandlingQty   _qty,
        WHSUOM              _uom,
        boolean             _movementByTemplate,
        boolean             _useLPDimensions,
        WHSWorkId           _workId,
        WHSTransWeight      _transWeight)
    {
        InventSum               inventSum;
        InventDim               inventDim;
        InventDim               tmpInventDim;
        InventDimId             inventDimIdFrom;
        InventDimId             inventDimIdTo;
        WHSWorkTable            workTable;
        WHSWorkLine             workLine;
        WHSWorkTrans            workTrans;
        WHSWorkQuarantine       workQuarantine;
        InventHandlingUnitId    uom = _uom;
        ItemId                  itemId = _itemId;
        InventHandlingQty       handlingQty = _qty;
        int                     lineNum;
        utcdatetime             currentDateTime = DateTimeUtil::utcNow();
        InventDimParm           inventDimParm;
        InventOnhand            inventOnhand;
        InventTableModule       inventTableModule;
        boolean                 createCatchWeightQuarantineRecords;

        boolean isCWItem = PdsGlobal::pdsIsCWItem(itemId);

        void createAndExecuteQuarantineRecord()
        {
            isCWItem = PdsGlobal::pdsIsCWItem(inventSum.ItemId);

            if (!_movementByTemplate)
            {
                inventDimParm.initFromInventDim(tmpInventDim);
                inventOnhand = InventOnhand::newParameters(inventSum.ItemId,
                                                           tmpInventDim,
                                                           inventDimParm);

                //since we are looking for physical invent only we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
                inventOnhand.parmDelayAvailabilityCalculation(true);

                if (isCWItem)
                {
                    handlingQty = inventOnhand.pdsCWPhysicalInvent();
                }
                else
                {
                    handlingQty = inventOnhand.physicalInvent();
                }
            }

            if (handlingQty)
            {
                workQuarantine.clear();
                ++lineNum;

                uom = WHSCatchWeightHelper::inventHandlingUnitId(inventSum.ItemId);

                workLine.LineNum                    = lineNum;
                workLine.wmsLocationId              = tmpInventDim.wmsLocationId;
                workLine.ItemId                     = inventSum.ItemId;
                workLine.InventDimId                = tmpInventDim.InventDimId;
                workLine.InventQtyWork              = handlingQty;
                workLine.QtyWork                    = handlingQty;
                workLine.UnitId                     = uom;
                workLine.insert();

                workTrans.setWorkTransId();
                workTrans.InventDimId   = tmpInventDim.InventDimId;
                workTrans.ItemId        = inventSum.ItemId;
                workTrans.Qty           = handlingQty;
                workTrans.uom           = uom;
                workTrans.LineNum       = workLine.LineNum;

                if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
                    || WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
                {
                    workTrans.TargetLicensePlateId = tmpInventDim.LicensePlateId;
                }

                workTrans.insert();

                if (!isCWItem || (createCatchWeightQuarantineRecords && this.isStatusChangeAllowedForCWItem(inventSum.ItemId)))
                {
                    // Create and execute the Quarantine records.
                    workQuarantine.initFromWorkLine(workLine);

                    this.setQuarantineDimIds(workQuarantine, tmpInventDim, _fromInventStatusId, _inventDim.InventStatusId, _inventDim.LicensePlateId);

                    if (isCWItem)
                    {
                        if (_movementByTemplate)
                        {
                            workQuarantine.CapturedWeight = _transWeight;

                            if (!workQuarantine.CapturedWeight)
                            {
                                workQuarantine.CapturedWeight = WHSCatchWeightHelper::calculateMovingWeight(inventSum.ItemId, tmpInventDim.InventDimId, handlingQty);
                            }
                        }
                        else
                        {
                            workQuarantine.CapturedWeight = inventOnHand.physicalInvent();
                        }

                        workQuarantine.RemainingCapturedWeight = workQuarantine.CapturedWeight;
                    }

                    workQuarantine.insert();
                    WHSWorkQuarantineExecutor quarantineExecutor = WHSWorkQuarantineExecutor::newWorkQuarantine(workQuarantine, handlingQty, false);
                    if (scannedCatchWeightTags)
                    {
                        quarantineExecutor.parmCatchWeightTagDimensionUpdater(WHSCatchWeightTagDimensionUpdater::newScannedTags(scannedCatchWeightTags, InventDim::find(workQuarantine.InventDimIdTo)));
                    }
                    quarantineExecutor.execute();
                }
            }
        }

        ttsbegin;

        inventDim = InventDim::find(_inventDim.InventDimId);
        inventDim.InventStatusId    = _fromInventStatusId;
        inventDim = InventDim::findOrCreate(inventDim);
        inventDimIdFrom = inventDim.InventDimId;

        inventDim.InventStatusId = _inventDim.InventStatusId;
        inventDimIdTo = InventDim::findOrCreate(inventDim).InventDimId;

        if (_workId) // if the work id is provided then work quarantine records already exist
        {
            workTable = WHSWorkTable::find(_workId);
        }
        else
        {
            workTable.setWorkId();

            workTable.WorkStatus                = WHSWorkStatus::Closed;
            workTable.WorkTransType             = WHSWorkTransType::Invent;
            workTable.InventSiteId              = _inventDim.InventSiteId;
            workTable.InventLocationId          = _inventDim.InventLocationId;
            workTable.WorkInProcessUTCDateTime  = currentDateTime;
            workTable.WorkClosedUTCDateTime     = currentDateTime;
            workTable.insert();

            createCatchWeightQuarantineRecords = WHSCatchWeightConfigurationKeyManager::instance().isEnabled();
        }

        workLine.WorkId                     = workTable.WorkId;
        workLine.WorkStatus                 = WHSWorkStatus::Closed;
        workLine.WorkType                   = WHSWorkType::Quarantine;
        workLine.InventQtyRemain            = 0;
        workLine.QtyRemain                  = 0;
        workLine.UserId                     = _userId;
        workLine.WorkInProcessUTCDateTime   = currentDateTime;
        workLine.WorkClosedUTCDateTime      = currentDateTime;

        workTrans.TransDateTime = currentDateTime;
        workTrans.WorkId        = workLine.WorkId;
        workTrans.UserId        = _userId;

        if (_useLPDimensions
            && (_inventDim.LicensePlateId
                || WMSLocation::find(_inventDim.wMSLocationId, _inventDim.InventLocationId).whsLocationIsLPControlled()))
        {
            InventDim inventDimFrom = this.initializeInventDimFromForQuarantineWork(_inventDim, _fromInventStatusId);
            InventDimParm inventDimParmCriteria = this.initializeInventDimParmForQuarantineWork(inventDimFrom);

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select ItemId, InventDimId, #InventDimGroupAllFields from inventSum
                where inventSum.PhysicalInvent       > 0
                    && inventSum.ClosedQty           == NoYes::No
                    && (_itemId == '' || inventSum.ItemId == _itemId)
                    && #InventDimFieldsFilter(inventSum, inventDimFrom, inventDimParmCriteria)
                join UnitId from inventTableModule
                    where inventTableModule.ItemId      == inventSum.ItemId
                        && inventTableModule.ModuleType  == ModuleInventPurchSales::Invent
                {
                    tmpInventDim.clear();
                    tmpInventDim.initFromInventSum(inventSum);
                    tmpInventDim.inventDimId = inventSum.InventDimId;

                    createAndExecuteQuarantineRecord();
                }
            }
            else
            {
                while select ItemId, InventDimId from inventSum
                where inventSum.PhysicalInvent   > 0
                &&    inventSum.ClosedQty       == NoYes::No
                &&   (_itemId == '' || inventSum.ItemId == _itemId)
                join tmpInventDim
                    where inventSum.InventDimId          == tmpInventDim.InventDimId
                        && #InventDimFieldsFilter(tmpInventDim, inventDimFrom, inventDimParmCriteria)
                join UnitId from inventTableModule
                    where inventTableModule.ItemId       == inventSum.ItemId
                        && inventTableModule.ModuleType  == ModuleInventPurchSales::Invent
                {
                    createAndExecuteQuarantineRecord();
                }
            }
        }
        else
        {
            workLine.LineNum                    = 1;
            workLine.wmsLocationId              = _inventDim.wmsLocationId;
            workLine.ItemId                     = itemId;
            workLine.InventDimId                = inventDim.InventDimId;
            workLine.InventQtyWork              = WHSCatchWeightHelper::convertInventQuantity(itemId, uom, handlingQty, workLine.InventDimId);
            workLine.QtyWork                    = handlingQty;
            workLine.UnitId                     = uom;
            workLine.write();

            workTrans.setWorkTransId();
            workTrans.InventDimId           = inventDim.InventDimId;
            workTrans.ItemId                = itemId;
            workTrans.Qty                   = handlingQty;
            workTrans.uom                   = uom;
            workTrans.LineNum               = workLine.LineNum;
            workTrans.write();

            if (!isCWItem || (createCatchWeightQuarantineRecords && this.isStatusChangeAllowedForCWItem(itemId)))
            {
                workQuarantine.initFromWorkLine(workLine);
                workQuarantine.setDimIds(inventDim, _fromInventStatusId, _inventDim.InventStatusId, _inventDim.LicensePlateId);

                if (isCWItem)
                {
                    workQuarantine.CapturedWeight = _transWeight;

                    if (!workQuarantine.CapturedWeight)
                    {
                        workQuarantine.CapturedWeight = WHSCatchWeightHelper::calculateMovingWeight(itemId, inventDimIdFrom, handlingQty);
                    }

                    workQuarantine.RemainingCapturedWeight = workQuarantine.CapturedWeight;
                }

                workQuarantine.insert();
                WHSWorkQuarantineExecutor quarantineExecutor = WHSWorkQuarantineExecutor::newWorkQuarantine(workQuarantine, workLine.InventQtyWork, false);
                if (scannedCatchWeightTags)
                {
                    quarantineExecutor.parmCatchWeightTagDimensionUpdater(WHSCatchWeightTagDimensionUpdater::newScannedTags(scannedCatchWeightTags, InventDim::find(workQuarantine.InventDimIdTo)));
                }
                quarantineExecutor.execute();
            }
        }

        if (_workId)
        {
            PDSCatchWeightItem catchWeightItem;

            // Iterate over and execute the catch weight items
            while select forUpdate workQuarantine
                where workQuarantine.WorkId == workTable.WorkId
                exists join catchWeightItem
                    where catchWeightItem.ItemId == workQuarantine.ItemId
            {
                workQuarantine.executeHandlingQty(workQuarantine.Qty, false);
            }
        }

        ttscommit;

    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuarantineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and executes quarantine work records.
    /// </summary>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_inventDim">
    /// Inventory dimensions of the item to be quarantined.
    /// </param>
    /// <param name="_fromInventStatusId">
    /// Initial inventory item status.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_qty">
    /// Quantity to be quarantined.
    /// </param>
    /// <param name="_uom">
    /// UOM of the item.
    /// </param>
    /// <param name="_movementByTemplate">
    /// Determines whether the quarantine movement is done by template.
    /// </param>
    /// <param name="_useLPDimensions">
    /// Use the dimensions of the license plate.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the createOrUpdateQuarantineWork method. Extenders should move their logic to wrap or override the createOrUpdateAndExecuteQuarantineWork method.', false, 30\9\2019)]
    void createQuarantineWork(WHSUserId             _userId,
                              InventDim             _inventDim,
                              WHSInventStatusId     _fromInventStatusId,
                              ItemId                _itemId = '',
                              Qty                   _qty = 0,
                              WHSUOM                _uom = '',
                              boolean               _movementByTemplate = false,
                              boolean               _useLPDimensions = true)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId); // although item id is not guaranteed, it is the only way to determine if call is for a CW item or not

        this.createOrUpdateAndExecuteQuarantineWork(_userId,
                _inventDim,
                _fromInventStatusId,
                _itemId,
                _qty,
                _uom,
                _movementByTemplate,
                _useLPDimensions,
                '', 0); // no work will have been created outside of catch weight work quarantine scenarios
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTOReceivingException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a work exception log for a transfer order receiving item.
    /// </summary>
    /// <param name="_structure">
    /// UOM structure of the received inventory item.
    /// </param>
    /// <param name="_desc">
    /// Work exception description.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_transferId">
    /// Transfer order id, default value is empty string.
    /// </param>
    /// <param name="_transferLineNum">
    /// Transfer order line number, default value is empty string.
    /// </param>
    [Hookable(false)]
    internal void createTOReceivingException(WHSUOMStructure       _structure,
                                    WHSWorkExceptionDesc  _desc,
                                    UserId                _userId,
                                    InventTransferId      _transferId = '',
                                    LineNum               _transferLineNum = 0)
    {
        WHSLoadLine loadLine = this.getLoadLineFromShipment(_structure.ShipmentId);

        ttsbegin;

        WhsWorkExecuteWorkExceptionLogParameters workExecuteWorkExceptionLogParameters = this.initializeWorkExceptionLogParameters(_structure, _desc, _userId);
        workExecuteWorkExceptionLogParameters.OrderNumber       = _transferId ? _transferId : loadLine.OrderNum;
        workExecuteWorkExceptionLogParameters.OrderLineNumber   = _transferLineNum ? _transferLineNum : loadLine.inventTransferLine().LineNum;
        workExecuteWorkExceptionLogParameters.WorkTransType     = WHSWorkTransType::TransferIssue;
        
        WHSWorkExceptionLog workExceptionLog = this.initializeReceivingWorkExceptionLog(workExecuteWorkExceptionLogParameters);
        workExceptionLog.write();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkExceptionLogParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields for receiving on work exception log parametres object.
    /// </summary>
    /// <param name="_structure">
    /// UOM structure of the received inventory item.
    /// </param>
    /// <param name="_desc">
    /// Work exception description.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <returns>Work exception log parameters instance.</returns>
    internal WhsWorkExecuteWorkExceptionLogParameters initializeWorkExceptionLogParameters(WHSUOMStructure       _structure,
                                                                                            WHSWorkExceptionDesc  _desc,
                                                                                            UserId                _userId)
    {
        WHSWorkException receivingException = WHSWorkException::findByDescriptionAndType(_desc, WHSExceptionType::Receiving);
        WHSLoadLine loadLine = this.getLoadLineFromShipment(_structure.ShipmentId);
        
        WhsWorkExecuteWorkExceptionLogParameters workExecuteWorkExceptionLogParameters = WhsWorkExecuteWorkExceptionLogParameters::construct();
        workExecuteWorkExceptionLogParameters.UserId            = _userId;
        workExecuteWorkExceptionLogParameters.ExceptionType     = WHSExceptionType::Receiving;
        workExecuteWorkExceptionLogParameters.WorkExceptionCode = receivingException.WorkExceptionCode;
        workExecuteWorkExceptionLogParameters.ShipmentId        = _structure.ShipmentId;
        workExecuteWorkExceptionLogParameters.LoadId            = loadLine.LoadId;
        workExecuteWorkExceptionLogParameters.LicensePlateId    = _structure.LicensePlateId;
        workExecuteWorkExceptionLogParameters.InventTransId     = loadLine.InventTransId;
        return workExecuteWorkExceptionLogParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReceivingException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a work exception log for a receiving item.
    /// </summary>
    /// <param name="_structure">
    /// UOM structure of the received inventory item.
    /// </param>
    /// <param name="_desc">
    /// Work exception description.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_purchId">
    /// Purchase order id, default value is empty string. Load id is used when this value is missing.
    /// </param>
    /// <param name="_lineNum">
    /// Purchase order line number, default value is empty string.
    /// </param>
    [SysObsolete('This method has been replaced by createInboundOrderReceivingException', false, 04\07\2023)]
    void createReceivingException(WHSUOMStructure       _structure,
                                  WHSWorkExceptionDesc  _desc,
                                  UserId                _userId,
                                  PurchId               _purchId = '',
                                  LineNum               _lineNum = 0)
    {
        ttsbegin;
        
        WHSLoadLine loadLine = this.getLoadLineFromShipment(_structure.ShipmentId);

        WhsWorkExecuteWorkExceptionLogParameters workExecuteWorkExceptionLogParameters = this.initializeWorkExceptionLogParameters(_structure, _desc, _userId);
        workExecuteWorkExceptionLogParameters.OrderNumber       = _purchId ? _purchId : loadLine.OrderNum;
        workExecuteWorkExceptionLogParameters.OrderLineNumber   = _lineNum ? _lineNum : loadLine.purchLine().LineNumber;
        workExecuteWorkExceptionLogParameters.WorkTransType     = WHSWorkTransType::Purch;
        
        WHSWorkExceptionLog workExceptionLog = this.initializeReceivingWorkExceptionLog(workExecuteWorkExceptionLogParameters);
        workExceptionLog.write();
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInboundOrderReceivingException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a work exception log for an inbound order receiving item.
    /// </summary>
    /// <param name="_structure">
    /// UOM structure of the received inventory item.
    /// </param>
    /// <param name="_desc">
    /// Work exception description.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_orderId">
    /// Inbound order number.
    /// </param>
    /// <param name="_lineNum">
    /// Inbound order line number.
    /// </param>
    /// <param name="_workTransType">
    /// Inbound order WHSWorkTransType.
    /// </param>
    public void createInboundOrderReceivingException(WHSUOMStructure      _structure,
                                                     WHSWorkExceptionDesc _desc,
                                                     UserId               _userId,
                                                     Num                  _orderId,
                                                     TradeLineNumber      _lineNum,
                                                     WHSWorkTransType     _workTransType)
    {
        if (_workTransType == WHSWorkTransType::Purch)
        {
            // Call obsolete method in order to not break extensions
            this.createReceivingException(_structure, _desc, _userId, _orderId, _lineNum);
            return;
        }

        ttsbegin;

        WHSLoadLine loadLine;
        if (!_orderId || !_lineNum)
        {
            loadLine = this.getLoadLineFromShipment(_structure.ShipmentId);
        }
        
        WhsWorkExecuteWorkExceptionLogParameters workExecuteWorkExceptionLogParameters = this.initializeWorkExceptionLogParameters(_structure, _desc, _userId);
        workExecuteWorkExceptionLogParameters.OrderNumber     = _orderId ? _orderId : loadLine.OrderNum;
        workExecuteWorkExceptionLogParameters.OrderLineNumber = _lineNum ? _lineNum : (loadLine.getOrderCommonFromLoadLine() as WHSReceiptOrderLine).LineNumber;
        workExecuteWorkExceptionLogParameters.WorkTransType   = _workTransType;
        
        WHSWorkExceptionLog workExceptionLog = this.initializeReceivingWorkExceptionLog(workExecuteWorkExceptionLogParameters);
        workExceptionLog.write();
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoadLineFromShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSLoadLine getLoadLineFromShipment(WHSShipmentId _shipmentId)
    {
        WHSLoadLine loadLine;
        WHSShipmentTable shipmentTable = WHSShipmentTable::find(_shipmentId);
        
        select firstonly loadLine
                where loadLine.LoadId == shipmentTable.LoadId;

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReceivingWorkExceptionLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields for receiving on work exception log.
    /// </summary>
    /// <param name = "_workExecuteWorkExceptionLogParameters">The <c>WhsWorkExecuteDisplayBuildPickParameters</c> object.</param>
    /// <returns>The work exception log record.</returns>
    protected WHSWorkExceptionLog initializeReceivingWorkExceptionLog(WhsWorkExecuteWorkExceptionLogParameters _workExecuteWorkExceptionLogParameters)
    {
        WHSWorkExceptionLog workExceptionLog;

        workExceptionLog.UserId                 = _workExecuteWorkExceptionLogParameters.UserId;
        workExceptionLog.ExceptionType          = _workExecuteWorkExceptionLogParameters.ExceptionType;
        workExceptionLog.WorkExceptionCode      = _workExecuteWorkExceptionLogParameters.WorkExceptionCode;
        workExceptionLog.ShipmentId             = _workExecuteWorkExceptionLogParameters.ShipmentId;
        workExceptionLog.LoadId                 = _workExecuteWorkExceptionLogParameters.LoadId;
        workExceptionLog.LicensePlateId         = _workExecuteWorkExceptionLogParameters.LicensePlateId;
        workExceptionLog.OrderNum               = _workExecuteWorkExceptionLogParameters.OrderNumber;
        workExceptionLog.OrderLineNum           = _workExecuteWorkExceptionLogParameters.OrderLineNumber;
        workExceptionLog.WorkTransType          = _workExecuteWorkExceptionLogParameters.WorkTransType;
        
        return workExceptionLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createShortPickException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a work exception log for a short picking.
    /// Runs a cycle count work if auto create cycle count field is set in the work exception record.
    /// </summary>
    /// <param name = "_workTable">Work header of the line to create work exception log entry for.</param>
    /// <param name = "_workLine">Work line to create work exception log entry for.</param>
    /// <param name = "_userId">Work user executing the short pick.</param>
    /// <param name = "_workException">Work exception selected on mobile device.</param>
    void createShortPickException(WHSWorkTable      _workTable,
                                  WHSWorkLine       _workLine,
                                  WHSUserId         _userId,
                                  WHSWorkException  _workException)
    {


        ttsbegin;

        LineNum sourceDocLineNum = WhsWorkTransactionType::singletonFromTypeOrDefault(_workTable.WorkTransType).findOrderLineNumFromInventTransId(_workLine.InventTransId);

        WhsWorkExecuteWorkExceptionLogParameters workExecuteWorkExceptionLogParameters = WhsWorkExecuteWorkExceptionLogParameters::construct();
        workExecuteWorkExceptionLogParameters.WorkId            = _workLine.WorkId;
        workExecuteWorkExceptionLogParameters.LineNumber        = _workLine.LineNum;
        workExecuteWorkExceptionLogParameters.UserId            = _userId;
        workExecuteWorkExceptionLogParameters.WarehouseId       = _workTable.InventLocationId;
        workExecuteWorkExceptionLogParameters.LocationId        = _workLine.WMSLocationId;
        workExecuteWorkExceptionLogParameters.ExceptionType     = _workException.ExceptionType;
        workExecuteWorkExceptionLogParameters.WorkExceptionCode = _workException.WorkExceptionCode;
        workExecuteWorkExceptionLogParameters.ShipmentId        = _workTable.ShipmentId;
        workExecuteWorkExceptionLogParameters.LoadId            = _workTable.LoadId;
        workExecuteWorkExceptionLogParameters.LicensePlateId    = _workTable.TargetLicensePlateId;
        workExecuteWorkExceptionLogParameters.OrderNumber       = _workTable.OrderNum;
        workExecuteWorkExceptionLogParameters.OrderLineNumber   = sourceDocLineNum;
        workExecuteWorkExceptionLogParameters.WorkTransType     = _workTable.WorkTransType;
        workExecuteWorkExceptionLogParameters.InventTransId     = _workLine.InventTransId;

        WHSWorkExceptionLog workExceptionLog = this.initializeShortPickWorkExceptionLog(workExecuteWorkExceptionLogParameters);
        workExceptionLog.write();

        if (_workException.AutoCreateCycleCount && _workLine.wmsLocationId)
        {
            var cycleCount = WHSCycleCountCreateLocation::constructFromWMSLocation(_workTable.InventLocationId, _workLine.WMSLocationId);
            cycleCount.runOperation();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeShortPickWorkExceptionLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields for short picking on work exception log.
    /// </summary>
    /// <param name = "_workExecuteWorkExceptionLogParameters">The <c>WhsWorkExecuteDisplayBuildPickParameters</c> object.</param>
    /// <returns>The work exception log record.</returns>
    protected WHSWorkExceptionLog initializeShortPickWorkExceptionLog(WhsWorkExecuteWorkExceptionLogParameters _workExecuteWorkExceptionLogParameters)
    {
        WHSWorkExceptionLog workExceptionLog;

        workExceptionLog.WorkId                 = _workExecuteWorkExceptionLogParameters.WorkId;
        workExceptionLog.LineNum                = _workExecuteWorkExceptionLogParameters.LineNumber;
        workExceptionLog.UserId                 = _workExecuteWorkExceptionLogParameters.UserId;
        workExceptionLog.InventLocationId       = _workExecuteWorkExceptionLogParameters.WarehouseId;
        workExceptionLog.WMSLocationId          = _workExecuteWorkExceptionLogParameters.LocationId;
        workExceptionLog.ExceptionType          = _workExecuteWorkExceptionLogParameters.ExceptionType;
        workExceptionLog.WorkExceptionCode      = _workExecuteWorkExceptionLogParameters.WorkExceptionCode;
        workExceptionLog.ShipmentId             = _workExecuteWorkExceptionLogParameters.ShipmentId;
        workExceptionLog.LoadId                 = _workExecuteWorkExceptionLogParameters.LoadId;
        workExceptionLog.LicensePlateId         = _workExecuteWorkExceptionLogParameters.LicensePlateId;
        workExceptionLog.OrderNum               = _workExecuteWorkExceptionLogParameters.OrderNumber;
        workExceptionLog.OrderLineNum           = _workExecuteWorkExceptionLogParameters.OrderLineNumber;
        workExceptionLog.WorkTransType          = _workExecuteWorkExceptionLogParameters.WorkTransType;

        return workExceptionLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a work exception log and
    /// Runs a cycle count work if auto create cycle count field is set in the work exception record.
    /// </summary>
    /// <param name="_workId">
    /// Work id to be set to work exception.
    /// </param>
    /// <param name="_lineNum">
    /// Work line number to be set to work exception.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_desc">
    /// Work exception description.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Location id of the work line.
    /// </param>
    void createWorkException(WHSWorkId              _workId,
                             LineNum                _lineNum,
                             WHSUserId              _userId,
                             WHSWorkExceptionDesc   _desc,
                             WMSLocationId          _wmsLocationId)
    {
        ttsbegin;

        WHSWorkException workException = WHSWorkException::findByDescriptionAndType(_desc, WHSExceptionType::Work);
        WHSWorkTable workTable = WHSWorkTable::find(_workId);
        InventTransId inventTransId = WHSWorkLine::find(_workId, _lineNum).InventTransId;

        LineNum lineNum = WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType).findOrderLineNumFromInventTransId(inventTransId);

        WhsWorkExecuteWorkExceptionLogParameters workExecuteWorkExceptionLogParameters = WhsWorkExecuteWorkExceptionLogParameters::construct();
        workExecuteWorkExceptionLogParameters.WorkId            = _workId;
        workExecuteWorkExceptionLogParameters.LineNumber        = _lineNum;
        workExecuteWorkExceptionLogParameters.UserId            = _userId;
        workExecuteWorkExceptionLogParameters.ExceptionType     = WHSExceptionType::Work;
        workExecuteWorkExceptionLogParameters.WorkExceptionCode = workException.WorkExceptionCode;
        workExecuteWorkExceptionLogParameters.ShipmentId        = workTable.ShipmentId;
        workExecuteWorkExceptionLogParameters.LoadId            = workTable.LoadId;
        workExecuteWorkExceptionLogParameters.LicensePlateId    = workTable.TargetLicensePlateId;
        workExecuteWorkExceptionLogParameters.OrderNumber       = workTable.OrderNum;
        workExecuteWorkExceptionLogParameters.OrderLineNumber   = lineNum;
        workExecuteWorkExceptionLogParameters.WorkTransType     = workTable.WorkTransType;
        workExecuteWorkExceptionLogParameters.LocationId        = _wmsLocationId;
        workExecuteWorkExceptionLogParameters.WarehouseId       = workTable.InventLocationId;
        workExecuteWorkExceptionLogParameters.InventTransId     = inventTransId;

        WHSWorkExceptionLog workExceptionLog = this.initializeWorkExceptionLog(workExecuteWorkExceptionLogParameters);
        workExceptionLog.write();

        if (workException.AutoCreateCycleCount && _wmsLocationId)
        {
            var cycleCount = WHSCycleCountCreateLocation::constructFromWMSLocation(workTable.InventLocationId, _wmsLocationId);
            cycleCount.runOperation();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkExceptionLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields from work on the work exception log.
    /// </summary>
    /// <param name = "_workExecuteWorkExceptionLogParameters">The <c>WhsWorkExecuteDisplayBuildPickParameters</c> object.</param>
    /// <returns>The work exception log record.</returns>
    protected WHSWorkExceptionLog initializeWorkExceptionLog(WhsWorkExecuteWorkExceptionLogParameters _workExecuteWorkExceptionLogParameters)
    {
        WHSWorkExceptionLog workExceptionLog;

        workExceptionLog.WorkId                 = _workExecuteWorkExceptionLogParameters.WorkId;
        workExceptionLog.LineNum                = _workExecuteWorkExceptionLogParameters.LineNumber;
        workExceptionLog.UserId                 = _workExecuteWorkExceptionLogParameters.UserId;
        workExceptionLog.ExceptionType          = _workExecuteWorkExceptionLogParameters.ExceptionType;
        workExceptionLog.WorkExceptionCode      = _workExecuteWorkExceptionLogParameters.WorkExceptionCode;
        workExceptionLog.ShipmentId             = _workExecuteWorkExceptionLogParameters.ShipmentId;
        workExceptionLog.LoadId                 = _workExecuteWorkExceptionLogParameters.LoadId;
        workExceptionLog.LicensePlateId         = _workExecuteWorkExceptionLogParameters.LicensePlateId;
        workExceptionLog.OrderNum               = _workExecuteWorkExceptionLogParameters.OrderNumber;
        workExceptionLog.OrderLineNum           = _workExecuteWorkExceptionLogParameters.OrderLineNumber;
        workExceptionLog.WorkTransType          = _workExecuteWorkExceptionLogParameters.WorkTransType;
        workExceptionLog.WMSLocationId          = _workExecuteWorkExceptionLogParameters.LocationId;
        workExceptionLog.InventLocationId       = _workExecuteWorkExceptionLogParameters.WarehouseId;

        return workExceptionLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeBatchPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes initial batched picks, picks to work headers in order they were applied to the cluster.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_itemId">
    /// The item Id, if present, of the work line to be executed.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <returns>
    /// Container of WHSWorkTransId.
    /// </returns>
    public container executeBatchPick(
        WHSClusterId                 _clusterId,
        WMSLocationId                _locationId,
        ItemId                       _itemId,
        WHSUserId                    _userId,
        InventDim                    _inventDimCriteria,
        boolean                      _assignSerial = false)
    {
        container transCon = conNull();
        
        ttsbegin;
        
        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(_inventDimCriteria);

        // InventSum.AvailPhisical:         qty for the inventory dimensions that exists on the location and is not reserved by any work -ie.  if so batch below items work
        // WHSInventReserve.ReservPhysical: reserved qty, in case we have reserved exactly the same inventory dimensions what we are checking on the inventsum - ie. from non-lp controlled location we reserved item
        // that has reservation hierarchy with location as the lowest reservation field.
        InventQtyAvailPhysical availableQty = InventSum::findSumQty(_itemId, _inventDimCriteria, inventDimParm).AvailPhysical + WHSInventReserve::findByInventDim(_itemId, _inventDimCriteria).ReservPhysical;
        InventHandlingQty usedQty;

        InventDimParm inventDimParmResHieachy = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));

        boolean isSerialNumberControlPicking = (WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Picking);
        
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         pickWorkLine;
        InventDim           inventDim;
        while select WorkId, ClusterId from workClusterLine
            where workClusterLine.ClusterId   == _clusterId
            join pickWorkLine
                where  pickWorkLine.WorkId           == workClusterLine.WorkId
                    && pickWorkLine.WorkType         == WHSWorkType::Pick
                    && pickWorkLine.InventQtyRemain  != 0
                    && pickWorkLine.wmsLocationId    == _locationId
                    && pickWorkLine.ItemId           == _itemId
                        #InventDimExistsJoin(pickWorkLine.InventDimId, inventDim, _inventDimCriteria, inventDimParmResHieachy)
        {
            WHSWorkTable workTable = WHSWorkTable::find(pickWorkLine.WorkId);

            if (_inventDimCriteria.LicensePlateId)     // Picking location is LP Controlled
            {
                if (this.validateLicensePlate(pickWorkLine, _inventDimCriteria.LicensePlateId))
                {
                    this.pickWorkFromLicensePlate(_inventDimCriteria.LicensePlateId,
                                                    pickWorkLine,
                                                    _userId,
                                                    _inventDimCriteria,
                                                    workTable.TargetLicensePlateId,
                                                    0, // cluster picking does not support weight capturing
                                                    _assignSerial,
                                                    NoYes::No,
                                                    true, // Skip validation of LP for performance since it has already been done before the call
                                                    false);
                }
                else
                {
                    break;
                }
            }
            else                    // Picking location is not LP Controlled
            {
                this.pickNonLicensePlateCheckDigitQuantities(pickWorkLine.WorkId,
                                                    pickWorkLine.LineNum,
                                                    _itemId,
                                                    pickWorkLine.QtyRemain,
                                                    0, // cluster picking does not support weight capturing
                                                    pickWorkLine.UnitId,
                                                    _userId,
                                                    _inventDimCriteria,
                                                    workTable.TargetLicensePlateId,
                                                    _assignSerial);
            }

            // Use WHSWorkTrans records to determine quantities actually picked, save off to use during sort validation
            WHSWorkTrans workTrans;
            select firstonly WorkTransId, Qty, WorkId, LineNum from workTrans
                order by RecId desc
                where workTrans.WorkId      == pickWorkLine.WorkId  &&
                        workTrans.LineNum     == pickWorkLine.LineNum;

            transCon += workTrans.WorkTransId;

            usedQty += workTrans.Qty;
            if (usedQty >= availableQty || (isSerialNumberControlPicking && !_assignSerial))
            {
                break;
            }
                        
            WHSDimTracking whsDimTracking;
            select firstonly whsDimTracking
                where   whsDimTracking.WorkId    == workTrans.WorkId  &&
                        whsDimTracking.LineNum   == workTrans.LineNum &&
                        whsDimTracking.Processed == NoYes::No;

            if (whsDimTracking)
            {
                break;
            }
        }

        ttscommit;
            
        return transCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeBatchShortPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes a short pick of initial batched pick when cluster picking.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    /// <param name="_userId">
    /// The user ID.
    /// </param>
    /// <param name="_shortPickReasonCode">
    /// The short pick reason code.
    /// </param>
    /// <param name="_qtyToPick">
    /// Quantity to pick.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate Id of picking location. Empty if location is not license plate controlled; optional.
    /// </param>
    /// <param name="_needsAddtionalDimensions">
    /// Specifies if additional dimensions must be capture prior to actually performing the pick; optional.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_reallocationTriggered">
    /// Specifies if the reallocation process for this pick line has been triggered or not.
    /// </param>
    /// <returns>
    /// Container of WHSWorkTransId.
    /// </returns>
    [SysObsolete('Use WhsWorkExecute.executeClusterShortPick() instead.', false, 30\06\2018)]
    public container executeBatchShortPick(
        WHSClusterId            _clusterId,
        WMSLocationId           _locationId,
        ItemId                  _itemId,
        WHSUserId               _userId,
        WHSWorkExceptionCode    _shortPickReasonCode,
        InventQty               _qtyToPick,
        WHSLicensePlateId       _licensePlateId = '',
        boolean                 _needsAddtionalDimensions = false,
        InventDim               _inventDimCriteria = null,
        boolean                 _reallocationTriggered = false)
    {
        return conPeek(this.executeClusterShortPick(_clusterId,
                                                    _locationId,
                                                    _itemId,
                                                    _userId,
                                                    _shortPickReasonCode,
                                                    _qtyToPick,
                                                    _licensePlateId,
                                                    _needsAddtionalDimensions,
                                                    _inventDimCriteria,
                                                    _reallocationTriggered),
                       1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustIncludePickWorkLineInCluster</Name>
				<Source><![CDATA[
    protected boolean mustIncludePickWorkLineInCluster(WHSClusterId _clusterId, WHSWorkLine _clusterShortPickWorkLine, WHSUserId _userId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeClusterShortPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes a short pick of initial batched pick when cluster picking.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    /// <param name="_userId">
    /// The user ID.
    /// </param>
    /// <param name="_shortPickReasonCode">
    /// The short pick reason code.
    /// </param>
    /// <param name="_qtyToPick">
    /// Quantity to pick.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate Id of picking location. Empty if location is not license plate controlled; optional.
    /// </param>
    /// <param name="_needsAdditionalDimensions">
    /// Specifies if additional dimensions must be capture prior to actually performing the pick; optional.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_reallocationTriggered">
    /// Specifies if the reallocation process for this pick line has been triggered or not.
    /// </param>
    /// <returns>
    /// Container of WHSWorkTransId, the current active work line, the intial pick quantity of the active work line.
    /// </returns>
    public container executeClusterShortPick(
        WHSClusterId            _clusterId,
        WMSLocationId           _locationId,
        ItemId                  _itemId,
        WHSUserId               _userId,
        WHSWorkExceptionCode    _shortPickReasonCode,
        InventQty               _qtyToPick,
        WHSLicensePlateId       _licensePlateId = '',
        boolean                 _needsAdditionalDimensions = false,
        InventDim               _inventDimCriteria = null,
        boolean                 _reallocationTriggered = false)
    {
        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            throw error("@WAX:Error_ClusterPickingDoesNotSupportCW");
        }

        container           transCon;
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         pickWorkLine;
        WHSWorkTransId      oldTransId;
        WHSWorkTransId      newTransId;
        InventDim           inventDim;
        WHSWorkLine         returnWorkLine;
        InventQty           initialInventPickQty;
        int                 i		   = 1;
        Qty                 runningQty = _qtyToPick;
        UnitOfMeasureSymbol inventUOM  = InventTableModule::find(_itemId, ModuleInventPurchSales::Invent).UnitId;

        ttsbegin;

        InventDimParm inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));

        while select WorkId, ClusterId from workClusterLine
            where workClusterLine.ClusterId == _clusterId
            join pickWorkLine
                where pickWorkLine.WorkId			 == workClusterLine.WorkId
                    && pickWorkLine.WorkStatus       != WHSWorkStatus::Cancelled
                    && pickWorkLine.WorkType         == WHSWorkType::Pick
                    && pickWorkLine.InventQtyRemain  != 0
                    && pickWorkLine.wmsLocationId    == _locationId
                    && pickWorkLine.ItemId           == _itemId
                #InventDimExistsJoin(pickWorkLine.InventDimId, inventDim, _inventDimCriteria, inventDimParm)
        {
            if (!this.mustIncludePickWorkLineInCluster(_clusterId, pickWorkLine, _userId))
            {
                continue;
            }

            WHSWorkTable workTable = WHSWorkTable::find(pickWorkLine.WorkId);
            WHSWorkTrans workTrans;

            select firstonly WorkTransId from workTrans
                order by RecId desc
                where  workTrans.WorkId      == pickWorkLine.WorkId
                    && workTrans.LineNum     == pickWorkLine.LineNum;

            oldTransId = workTrans.WorkTransId;

            boolean workLineShortPicked;

            if (pickWorkLine.InventQtyRemain <= runningQty
                && !_needsAdditionalDimensions)
            {
                if (_licensePlateId) // Picking Location Is License Plate Controlled
                {
                    this.pickWorkFromLicensePlate(_licensePlateId,
                                                  pickWorkLine,
                                                  _userId,
                                                  _inventDimCriteria,
                                                  workTable.TargetLicensePlateId,
                                                  0, // weight capturing not supported for cluster picking
                                                  false,
                                                  NoYes::No,
                                                  false,
                                                  false);
                }
                else    // Picking Location Is Non License Plate Controlled
                {
                    this.pickNonLicensePlateCheckDigitQuantities(pickWorkLine.WorkId,
                                                       pickWorkLine.LineNum,
                                                       _itemId,
                                                       pickWorkLine.QtyRemain,
                                                       0, // weight capturing not supported for cluster picking
                                                       pickWorkLine.UnitId,
                                                       _userId,
                                                       _inventDimCriteria,
                                                       workTable.TargetLicensePlateId,
                                                       false);
                }
            }
            else // If running qty to pick is less than work qty, Short Pick
            {
                WHSInventQtyRemain initialQty = pickWorkLine.InventQtyRemain;

                this.executeShortPick(pickWorkLine.WorkId,
                                      pickWorkLine.LineNum,
                                      _shortPickReasonCode,
                                      runningQty,
                                      inventUOM,
                                      _userId,
                                      _licensePlateId,
                                      _needsAdditionalDimensions,
                                      false,
                                      _reallocationTriggered);

                if (returnWorkLine)
                {
                    pickWorkLine.reread();

                    if (autoReallocationRequired && (reallocationProcess == WHSItemReallocation::Automatic || reallocationProcess == WHSItemReallocation::AutomaticAndManual))
                    {
                        WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromWorkLine(pickWorkLine, _shortPickReasonCode, _userId, initialQty, runningQty);

                        WHSWorkLineAutoReallocatorBase autoReallocator = WHSWorkLineAutoReallocatorBase::newFromParams(workLineReallocationParams);
                        autoReallocator.reallocateWorkLineHandlingQty();
                    }
                    else if (reallocationProcess == WHSItemReallocation::Manual || reallocationProcess == WHSItemReallocation::AutomaticAndManual)
                    {
                        WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromWorkLine(pickWorkLine, _shortPickReasonCode, _userId, initialQty, runningQty);

                        WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
                        InventHandlingQty inventQtyToReallocate = workLineReallocationParams.getInventHandlingQtyToReallocate();
                        if (manualReallocationSelected)
                        {
                            InventHandlingQty reallocatedQty = reallocator.reallocateWorkLineHandlingQty(selectedLocationId, inventQtyToReallocate);
                            inventQtyToReallocate -= reallocatedQty;
                            reallocator.runShortPickConfirmationPostUpdatesHandlingQty(inventQtyToReallocate);
                        }
                        else
                        {
                            reallocator.runShortPickConfirmationPostUpdatesHandlingQty(inventQtyToReallocate);
                        }
                    }
                }

                workLineShortPicked = true;
            }

            // Use WHSWorkTrans records to determine quantities actually picked, save off to use during sort validation
            workTrans.clear();

            if (!_needsAdditionalDimensions)
            {
                select firstonly WorkTransId, uom, Qty, InventDimId from workTrans
                    order by RecId desc
                    where  workTrans.WorkId      == pickWorkLine.WorkId
                        && workTrans.LineNum     == pickWorkLine.LineNum;

                newTransId = workTrans.WorkTransId;

                if (newTransId != oldTransId)
                {
                    transCon = conPoke(transCon, i, newTransId);
                    runningQty -= InventTableModule::unitConvert(_itemId,
                                                             ModuleInventPurchSales::Invent,
                                                             workTrans.uom,
                                                             workTrans.Qty,
                                                             workTrans.InventDimId);
                    ++i;
                }
            }
            else
            {
                runningQty -= min(runningQty, pickWorkLine.InventQtyRemain);
            }

            if (workLineShortPicked
                    && _reallocationTriggered
                    && !runningQty
                    && !returnWorkLine)
            {
                // Pick work line may have been updated in execute short pick, but the pickWorkLine buffer was never reread
                // so the remain quantity is still correct.
                initialInventPickQty = pickWorkLine.InventQtyRemain;
                returnWorkLine = WHSWorkLine::find(pickWorkLine.WorkId, pickWorkLine.LineNum);
            }
        }

        ttscommit;

        return [transCon, returnWorkLine, initialInventPickQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeClusterPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes clustered picks (non initial).
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_userId">
    /// The user ID.
    /// </param>
    public void executeClusterPick(
        WHSClusterId        _clusterId,
        WMSLocationId       _locationId,
        WHSUserId           _userId)
    {
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         pickWorkLine;
        WHSWorkTable        workTable;

        ttsbegin;

        while select WorkId, ClusterId from workClusterLine
            join pickWorkLine
            where workClusterLine.WorkId        == pickWorkLine.WorkId      &&
                  workClusterLine.ClusterId     == _clusterId               &&
                  pickWorkLine.WorkType         == WHSWorkType::Pick        &&
                  pickWorkLine.InventQtyRemain  != 0                        &&
                  pickWorkLine.wmsLocationId    == _locationId
        {
            workTable = WHSWorkTable::find(pickWorkLine.WorkId);

            if (WMSLocation::find(_locationId, workTable.InventLocationId).whsLocationIsLPControlled())
            {
                this.pickWorkFromLicensePlate(workTable.TargetLicensePlateId,
                                              pickWorkLine,
                                              _userId,
                                              null,
                                              workTable.TargetLicensePlateId,
                                              0, // cluster picking does not support weight capturing
                                              false,
                                              NoYes::No,
                                              false,
                                              false);
                
                // Reread the work line in case it has been changed during picking from license plate.
                pickWorkLine.reread();

                if (pickWorkLine.AskForNewLicensePlate
                    && WHSClusterProfile::find(workTable.ClusterProfileId).ClusterType == WHSClusterType::Putaway)
                {
                    throw error(strFmt("@WAX:ClusterPutAwayMoreInventoryError",
                                    workTable.TargetLicensePlateId,  pickWorkLine.InventQtyWork,
                                    pickWorkLine.UnitId, pickWorkLine.ItemId,
                                    WHSLicensePlate::getTotalHandlingQtyOnLicensePlate(workTable.TargetLicensePlateId)));
                }
            }
            else
            {
                this.pickNonLicensePlateCheckDigitQuantities(pickWorkLine.WorkId,
                                                   pickWorkLine.LineNum,
                                                   '',
                                                   pickWorkLine.QtyRemain,
                                                   0, // cluster picking does not support weight capturing
                                                   pickWorkLine.UnitId,
                                                   _userId,
                                                   null,
                                                   workTable.TargetLicensePlateId,
                                                   false);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeClusterPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes clustered putaways
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_userId">
    /// The user ID.
    /// </param>
    public void executeClusterPut(
        WHSClusterId         _clusterId,
        WMSLocationId        _locationId,
        WHSUserId            _userId)
    {
        this.executeClusterPutConsiderDeferredPut(_clusterId, _locationId, _userId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineToteReuseLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the license plate id of a tote when tote reuse is enabled.
    /// </summary>
    /// <param name = "_toteId">The license plate id to replace.</param>
    /// <param name = "_workLine">Current work line to check if we are putting to a packing station.</param>
    /// <returns>The temporary license id in case early tote reuse is enabled.</returns>
    public WHSLicensePlateId determineToteReuseLicensePlateId(WHSLicensePlateId _toteId, WHSWorkLine _workLine)
    {
        WHSLicensePlateId temporaryLicensePlateId;
        
        if (WHSToteReuseTable::isToteReuseEnabled(_workLine))
        {
            WHSToteReuseTable toteReuseTable = WHSToteReuseTable::addNewRecord(_workLine.WorkId, _toteId);
            temporaryLicensePlateId = toteReuseTable.TmpToteId;
        }

        return temporaryLicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePackingLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the packing license plate id under consideration of tote reuse.
    /// </summary>
    /// <param name = "_targetLicensePlateId">The target license plate id to replace when tote reuse is enabled.</param>
    /// <param name = "_workLine">Current work line to check if we are putting to a packing station.</param>
    /// <returns>The temporary license id in case early tote reuse is enabled; otherwise the passed target license plate id.</returns>
    protected WHSLicensePlateId determinePackingLicensePlateId(WHSLicensePlateId _targetLicensePlateId, WHSWorkLine _workLine)
    {
        WHSLicensePlateId packLicensePlateId = _targetLicensePlateId;
        
        WHSLicensePlateId temporaryLicensePlateId = this.determineToteReuseLicensePlateId(_targetLicensePlateId, _workLine);
        if (temporaryLicensePlateId)
        {
            // Change the LicensePlate to the newly generated LicensePlateId.
            packLicensePlateId = temporaryLicensePlateId;
        }

        return packLicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeClusterPutConsiderDeferredPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes clustered putaways. If deferred put is allowed the put operations are deferred.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_userId">
    /// The user ID.
    /// </param>
    /// <param name = "_allowDeferrdPut">
    /// true if deferred put should be used if the configuration allows it; otherwise, false.
    /// </param>
    public void executeClusterPutConsiderDeferredPut(
        WHSClusterId         _clusterId,
        WMSLocationId        _locationId,
        WHSUserId            _userId,
        boolean              _allowDeferrdPut)
    {
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         putWorkLine;

        ttsbegin;

        while select WorkId, ClusterId from workClusterLine
            join  WorkId, LineNum, WorkType, InventQtyWork from putWorkLine
            where workClusterLine.WorkId        == putWorkLine.WorkId
                && workClusterLine.ClusterId     == _clusterId
                && putWorkLine.WorkType          == WHSWorkType::Put
                && putWorkLine.WorkStatus        != WHSWorkStatus::Cancelled
                && putWorkLine.InventQtyRemain   != 0
                && putWorkLine.wmsLocationId     == _locationId
        {
            if (this.hasPutWorkLinePreviousPickWorkLineClosed(putWorkLine))
            {
                WHSWorkTable workTable = WHSWorkTable::find(putWorkLine.WorkId);

                // Check to see if the early tote reuse is turned on and if yes get the temporary license plate id
                WHSLicensePlateId packLicensePlateId = this.determinePackingLicensePlateId(workTable.TargetLicensePlateId, putWorkLine);

                WHSWorkPutOperationParameters putOperationParameters = WHSWorkPutOperationParameters::construct();

                putOperationParameters.parmWorkId(putWorkLine.WorkId);
                putOperationParameters.parmLineNum(putWorkLine.LineNum);
                putOperationParameters.parmPutWMSlocationId(_locationId);
                putOperationParameters.parmSourceLicensePlateId(workTable.TargetLicensePlateId);
                putOperationParameters.parmTargetLicensePlateId(packLicensePlateId);
                putOperationParameters.parmUserId(_userId);
                putOperationParameters.parmWorkPutFlow(this.clusterWorkPutFlow(workTable.WorkTransType, putWorkLine));
                putOperationParameters.parmHandleByLP(false);

                boolean isAllowUseOfDeferredPut = _allowDeferrdPut &&                    
                    WHSWorkDeferredPutProcessingRuleEvaluator::newFromWorkLine(putWorkLine).canUseDeferredPutProcessing(putOperationParameters.parmWorkPutFlow());

                if (isAllowUseOfDeferredPut)
                {
                    using (var context = WHSWorkDeferredPutProcessingSkipRuleEvaluationContext::construct())
                    {
                        this.putAwayToLocationConsiderDeferredPut(putOperationParameters, isAllowUseOfDeferredPut);
                    }
                }
                else
                {
                    // Close work's container
                    if (!WHSWorkLine::isPutBefore(putWorkLine.WorkId, putWorkLine.LineNum))
                    {
                        WHSContainerTable::determineContainerClose(putWorkLine.WorkId);
                    }

                    this.putAwayToLocationConsiderDeferredPut(putOperationParameters, isAllowUseOfDeferredPut);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clusterWorkPutFlow</Name>
				<Source><![CDATA[
    private WHSWorkPutFlow clusterWorkPutFlow(WHSWorkTransType _workTransType, WHSWorkLine _putWorkLine)
    {
        WHSWorkPutFlow ret = WHSWorkPutFlow::MoveAll;

        if (WhsWorkTransactionType::singletonFromTypeOrDefault(_workTransType).isForExternalInboundShipment())
        {
            WHSWorkLine prevOppositeWorkLine = WHSWorkLine::getPrevOppositeWorkLine(_putWorkLine.WorkId,
                                                                                    _putWorkLine.LineNum,
                                                                                    _putWorkLine.WorkType);

            ret = prevOppositeWorkLine.InventQtyWork > _putWorkLine.InventQtyWork ? WHSWorkPutFlow::SplitQuantity : WHSWorkPutFlow::MoveAll;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPutWorkLinePreviousPickWorkLineClosed</Name>
				<Source><![CDATA[
    private boolean hasPutWorkLinePreviousPickWorkLineClosed(WHSWorkLine _putWorkLine)
    {
        WHSWorkLine oppositeWorkLine = WHSWorkLine::getPrevOppositeWorkLine(_putWorkLine.WorkId, _putWorkLine.LineNum, _putWorkLine.WorkType);

        return oppositeWorkLine.WorkStatus == WHSWorkStatus::Closed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeShortPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates quantity on the work lines and work inventory transactions coming after the short picked work lines.
    /// Performs the actual short pick after that and creates work exception record for short pick.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the short pick work line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the short pick work line.
    /// </param>
    /// <param name="_shortPickReasonCode">
    /// Short pick reason code.
    /// </param>
    /// <param name="_qtyToPick">
    /// Quantity of the short picked items.
    /// </param>
    /// <param name="_unitId">
    /// UOM of the short picked items.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the short picked items.
    /// </param>
    /// <param name="_needsAddtionalDimensions">
    /// Determines if additional dimensions must be capture prior to actually performing the pick; optional.
    /// </param>
    /// <param name="_assignSerial">
    /// Determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <param name="_reallocationTriggered">
    /// Specifies if the reallocation process for this pick line has been triggered or not.
    /// </param>
    /// <returns>
    /// The work line for short pick
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when item is not specified.
    /// </exception>
    WHSWorkLine executeShortPick(WHSWorkId                  _workId,
                                 LineNum                    _lineNum,
                                 WHSWorkExceptionCode       _shortPickReasonCode,
                                 Qty                        _qtyToPick,
                                 UnitOfMeasureSymbol        _unitId,
                                 WHSUserId                  _userId,
                                 WHSLicensePlateId          _licensePlateId = '',
                                 boolean                    _needsAddtionalDimensions = false,
                                 boolean                    _assignSerial             = false,
                                 boolean                    _reallocationTriggered    = false)
    {
        WHSWorkTable            workTable;
        WHSWorkLine             workLine;
        WHSWorkLine             workLineShortPicked;
        WHSWorkException        workException;
        InventDim               inventDim;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter;

        ttsbegin;

        workLineShortPicked = WHSWorkLine::find(_workId, _lineNum);

        if (!workLineShortPicked.ItemId)
        {
            throw error("@WAX1349");
        }

        InventHandlingUnitId inventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(workLineShortPicked.ItemId);

        releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        InventQty inventQtyToPick = releasedProductUnitConverter.convert(_qtyToPick,
                                                          UnitOfMeasure::unitOfMeasureIdBySymbol(_unitId),
                                                          UnitOfMeasure::unitOfMeasureIdBySymbol(inventHandlingUnitId),
                                                          NoYes::No,
                                                          workLineShortPicked.ItemId,
                                                          workLineShortPicked.InventDimId,
                                                          NoYes::No);

        InventQty inventQtyNotPicked = workLineShortPicked.InventQtyRemain - inventQtyToPick;

        if (inventQtyNotPicked >= 0)
        {
            workTable = workLineShortPicked.whsWorkTable();
            workException = WHSWorkException::find(_shortPickReasonCode, WHSExceptionType::ShortPick);

            this.adjustWorkLineQty(workLineShortPicked, -inventQtyNotPicked, inventHandlingUnitId, _userId, workException.AutoDecrementShipment, _reallocationTriggered);
            
            switch (workTable.WorkTransType)
            {
                case WHSWorkTransType::Replenishment:
                    // If this is replenishment work tied to demand work then we need to short the demand work as well
                    InventQty totalDemandInventQty = WHSReplenWorkLink::getDemandReplenishmentInventQty(workLineShortPicked);
                    InventQty demandInventQtyWhichCouldNotBeReplenished = totalDemandInventQty - inventQtyToPick;
                    if (demandInventQtyWhichCouldNotBeReplenished > 0)
                    {
                        using (WhsWorkCancelDemandContext workcancelDemandContext = new WhsWorkCancelDemandContext())
                        {
                            workcancelDemandContext.updateLoadLineQuantity = workException.AutoDecrementShipment;
                            WHSWorkTable::cancelDemandWork(_workId, _lineNum, demandInventQtyWhichCouldNotBeReplenished , true, _userId, !_reallocationTriggered);
                        }
                    }
                    break;
                case WHSWorkTransType::ProdPick:
                    WHSProdBOMPool::adjustWavedHandlingQty(workLineShortPicked.InventTransId, -inventQtyNotPicked);
                    break;
            }
            
            // Ensure we try to update the work status here since the line status is changed inside adjustWorkLineQty
            WHSWorkTable::updateWorkStatusFromWorkLines(workLineShortPicked.WorkId, _userId);
            
            if (!_reallocationTriggered)
            {
                WHSLoadLine::deleteZeroLoadLines(workLineShortPicked.WorkId);
            }

            inventDim = workLineShortPicked.inventDimWithLocation();
            if (WMSLocation::find(workLineShortPicked.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled())
            {
                inventDim.LicensePlateId = _licensePlateId;
            }

            if (workLineShortPicked.OrderCommittedInventDimId)
            {
                inventDim.inventBatchId = InventDim::find(workLineShortPicked.OrderCommittedInventDimId).inventBatchId;
            }

            inventDim = InventDim::findOrCreate(inventDim);
            
            // Adjust the inventory if we need to
            // Note: we do not support adjust inventory for items with tracking dimensions below location unless
            // the work line has flex batch reservation.
            if (workException.AdjustInventory
                && (  !this.itemIsDimTrackingControlled(workLineShortPicked.ItemId)
                    || this.shouldAdjustInventoryForOrderCommitted(workLineShortPicked)))
            {
                this.shortPickAdjustOut(_userId, workLineShortPicked, inventDim, inventQtyToPick, workException);
            }

            // Perform the actual Pick
            if (_qtyToPick
                && !_needsAddtionalDimensions
                && !PdsGlobal::pdsIsCWItem(workLineShortPicked.ItemId))
            {
                // Make sure we have the most updated work line prior to trying to execute the work.
                workLineShortPicked.reread();
            
                if (WMSLocation::find(workLineShortPicked.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled())
                {
                    workLine = this.pickWorkFromLicensePlate(_licensePlateId,
                                                             workLineShortPicked,
                                                             _userId,
                                                             inventDim,
                                                             workTable.TargetLicensePlateId,
                                                             0,
                                                             _assignSerial,
                                                             NoYes::No,
                                                             false,
                                                             false);
                }
                else
                {
                    // This is not a LP-controlled location. It means that passed license plate id is a target license plate.
                    if (!workTable.TargetLicensePlateId && _licensePlateId)
                    {
                        workTable = WHSWorkTable::addTargetLicensePlate(workLineShortPicked.WorkId, _licensePlateId);
                    }

                    workLine = this.pickNonLicensePlateCheckDigitQuantities(workLineShortPicked.WorkId,
                                                                  workLineShortPicked.LineNum,
                                                                  workLineShortPicked.ItemId,
                                                                  _qtyToPick,
                                                                  0,
                                                                  _unitId,
                                                                  _userId,
                                                                  inventDim,
                                                                  workTable.TargetLicensePlateId,
                                                                  _assignSerial);
                }
            }
            else
            {
                workLine = this.getFirstOpenLine(workLineShortPicked.WorkId, _userId);

                if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLineShortPicked.WorkId))
                {
                    workLineShortPicked.reread();

                    if (   workLineShortPicked.WorkStatus == WHSWorkStatus::Closed  // work line got closed by short-pick -> we won't reach the normal execution flow for it anymore.
                        && workLineShortPicked.InventQtyWork    // check that something was picked by the pick work line.
                        && _qtyToPick == 0)     // it was short-pick to 0 scenario => we just closed the work line without executing picking logic above.
                    {
                        // The corresponding Put line's WIT gets updated with the cummulative item set when the pick line's WIT is _completely_ executed.
                        // This logic happens in the WhsWorkExecute.createNextWorkInventTransQty() method.
                        // Now, when we reach this branch, we have closed the pick work line by short picking to 0, but have picked some portion of the required pick qty before.
                        // In this scenario we simply reduced the pick work line qty and quantity on its WIT.
                        // But haven't updated the put line's WIT with item set which was picked so far by the current pick work line.
                        // So we must make sure the put lines are properly updated.
                        // This is a cheap inefficient version to achieve this. I am adding a note for potential improvement if we ever see real problem with this code.
                        this.rebuildPutLineItemSetBasedOnClosedPickLine(workLineShortPicked);
                    }
                }
            }
            
            this.createShortPickException(workTable, workLineShortPicked, _userId, workException);
        }
        else
        {
            workLine = workLineShortPicked;
        }

        ttscommit;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildPutLineItemSetBasedOnClosedPickLine</Name>
				<Source><![CDATA[
    private void rebuildPutLineItemSetBasedOnClosedPickLine(WHSWorkLine _pickWorkLine)
    {
        // We can make a more performant implementation here by making some assumptions like:
        // - we reach this method from initial pick lines => we have just a single WIT related to the pick work line.
        // - we can just take the item set on the pick line's WIT and add it to the next put work line.
        // But lets keep the implementation simple here till we see that further performance optimization is needed.
        // If decide to do optimization here take care of:
        // - split put scenarios (especially when there are several put lines).
        // - double-check the assumption about single WIT per initial pick work line.
        WHSWorkTable::rebuildItemSetOnPutLinesBasedOnPreviousPicks(_pickWorkLine.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAdjustInventoryForOrderCommitted</Name>
				<Source><![CDATA[
    private boolean shouldAdjustInventoryForOrderCommitted(WHSWorkLine _workLine)
    {
        boolean result = false;

        if (_workLine.OrderCommittedInventDimId)
        {
            List dimList = WHSReservationHierarchyProvider::construct().getDimListBelowBatch(
                InventTable::find(_workLine.ItemId),
                WHSReservationHierarchySortOrder::TopDown);

            result = dimList.empty();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeGroupPickShortPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Short picks each individual pick line from a single picking group.
    /// </summary>
    /// <param name = "_workId">
    /// The <c>WHSWorkId</c> from the first of the grouped lines.
    /// </param>
    /// <param name = "_lineNum">
    /// <c>LineNum</c> from the first of the grouped lines.
    /// </param>
    /// <param name = "_shortPickReasonCode">
    /// Short pick reason code.
    /// </param>
    /// <param name = "_qtyToPick">
    /// Quantity of the short picked items.
    /// </param>
    /// <param name = "_unitId">
    /// UOM of the short picked items.
    /// </param>
    /// <param name = "_userId">
    /// Work user id.
    /// </param>
    /// <param name = "_licensePlateId">
    /// License plate id of the short picked items.
    /// </param>
    /// <param name = "_needsAdditionalDimensions">
    /// Determines if additional dimensions must be capture prior to actually performing the pick.
    /// </param>
    /// <returns>
    /// The first <c>WHSWorkLine</c> of the grouped lines.
    /// </returns>
    [Hookable(false)]
    internal WHSWorkLine executeGroupPickShortPick(
        WHSWorkId               _workId,
        LineNum                 _lineNum,
        WHSWorkExceptionCode    _shortPickReasonCode,
        Qty                     _qtyToPick,
        UnitOfMeasureSymbol     _unitId,
        WHSUserId               _userId,
        WHSLicensePlateId       _licensePlateId,
        boolean                 _needsAdditionalDimensions)
    {
        WHSWorkLine firstWorkLineGroupPick = WHSWorkLine::find(_workId, _lineNum, true);
        WHSWorkLine groupWorkLine;
        WHsWorkLine workLine;
        Qty         qtyToPick;
    
        UnitOfMeasureSymbol inventUnitId        = WHSCatchWeightHelper::inventHandlingUnitId(firstWorkLineGroupPick.ItemId);
        Qty                 remainingQtyToPick  = WHSCatchWeightHelper::convertInventQuantity(firstWorkLineGroupPick.ItemId, _unitId, _qtyToPick, firstWorkLineGroupPick.InventDimId);
        boolean             executeLines        = this.isQtyOnLicensePlateSufficient(_licensePlateId, firstWorkLineGroupPick, remainingQtyToPick);

        ttsBegin;
    
        while select groupWorkLine
            order by LineNum
            where groupWorkLine.WorkId == _workId
                && groupWorkLine.WorkType == WHSWorkType::Pick
                && groupWorkLine.LineNum >= firstWorkLineGroupPick.LineNum
        {
            if (!WHSWorkLine::canWorkLineBeGroupPicked(firstWorkLineGroupPick, groupWorkLine))
            {
                break;
            }

            if (groupWorkLine.InventQtyRemain >= remainingQtyToPick)
            {
                qtyToPick = remainingQtyToPick;
                remainingQtyToPick = 0;
            }
            else
            {
                qtyToPick = groupWorkLine.InventQtyRemain;
                remainingQtyToPick -= groupWorkLine.InventQtyRemain;
            }
    
            workLine = this.executeShortPick(groupWorkLine.WorkId,
                                            groupWorkLine.LineNum,
                                            _shortPickReasonCode,
                                            qtyToPick,
                                            inventUnitId,
                                            _userId,
                                            _licensePlateId,
                                            _needsAdditionalDimensions,
                                            false,
                                            false);

            if (this.doesNoninitialWorkLineAskForLP(workLine.AskForNewLicensePlate, workLine.LineNum, _lineNum))
            {
                firstWorkLineGroupPick.reread();

                workLine = this.maintainFirstPickLineAsReference(workLine, firstWorkLineGroupPick);
            }
        }
    
        ttsCommit;
    
        if (!executeLines)
        {
            workLine = this.getFirstOpenLine(_workId, _userId);
        }
    
        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQtyOnLicensePlateSufficient</Name>
				<Source><![CDATA[
    private boolean isQtyOnLicensePlateSufficient(
        WHSLicenseplateId   _licensePlateId,
        WHSWorkLine         _firstWorkLineGroupPick,
        Qty                 _remainingQtyToPick)
    {
        if  (WHSLicensePlate::isMultiSKU(_licensePlateId)
             && (_remainingQtyToPick < WHSInvent::getQtyOnLicensePlate(_licensePlateId, _firstWorkLineGroupPick.ItemId, _firstWorkLineGroupPick.InventDimId, _firstWorkLineGroupPick.WMSLocationId))
             && _firstWorkLineGroupPick.whsWorkTable().WorkTransType != WHSWorkTransType::ProdPick)
        {
            _firstWorkLineGroupPick.AskForNewLicensePlate = true;
            _firstWorkLineGroupPick.update();

            return false;
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesNoninitialWorkLineAskForLP</Name>
				<Source><![CDATA[
    private boolean doesNoninitialWorkLineAskForLP(
        boolean _askForNewLP,
        LineNum _currentLineNum,
        LineNum _firstLineNumInGroup)
    {
        return _currentLineNum != _firstLineNumInGroup
            && _askForNewLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainFirstPickLineAsReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that the first of a group of pick lines is used as the definitive <c>AskForNewLicenseplate</c> for the group.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <param name = "_firstWorkLineGroupPick">The first group pick work line record.</param>
    /// <returns>The updated first group pick work line record.</returns>
    private WHSWorkLine maintainFirstPickLineAsReference(WHSWorkLine _workLine, WHSWorkLine _firstWorkLineGroupPick)
    {
        _workLine.selectForUpdate(true);
        _workLine.AskForNewLicensePlate = NoYes::No;
        _workLine.update();        

        if (!_firstWorkLineGroupPick.AskForNewLicensePlate)
        {
            _firstWorkLineGroupPick.AskForNewLicensePlate = NoYes::Yes;
            _firstWorkLineGroupPick.update();
        }

        return _firstWorkLineGroupPick;

    }

]]></Source>
			</Method>
			<Method>
				<Name>overrideGroupPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the group pick lines to a new location.
    /// </summary>
    /// <param name="_workLine">
    /// The current work line number being executed.
    /// </param>
    /// <param name="_locationId">
    /// The new location the lines will use.
    /// </param>
    /// <param name="_userId">
    /// The RF user Id.
    /// </param>
    [Hookable(false)]
    internal void overrideGroupPick(
        WHSWorkLine     _workLine,
        WMSLocationId   _locationId,
        UserId          _userId)
    {
        WHSWorkLine overrideWorkLine;
    
        while select overrideWorkLine
            order by LineNum
            where overrideWorkLine.WorkId == _workLine.WorkId
                && overrideWorkLine.LineNum >= _workLine.LineNum
        {
            if (!WHSWorkLine::canWorkLineBeGroupPicked(_workLine, overrideWorkLine))
            {
                break;
            }
            
            this.updateWorkLineLocation(_workLine.workId, overrideWorkLine.LineNum, _locationId, _userId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNewLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a new pick/put location for a work line using location directives.
    /// </summary>
    /// <param name="_workLine">
    /// Work line that needs a location.
    /// </param>
    /// <param name="_excludeLocationId">
    /// Set containing location ids to be excluded in location directives.
    /// </param>
    /// <returns>
    /// Container containing found location information.
    /// </returns>
    public container findNewLocation(WHSWorkLine _workLine, Set _excludeLocationId)
    {
        if (_workLine.OrderCommittedInventDimId)
        {
            Set excludeLocationIdSet = _excludeLocationId;

            WMSLocationId newLocationId = this.findNewLocationFromOnHand(
                _workLine.ItemId,
                _workLine.OrderCommittedInventDimId,
                _workLine.InventQtyRemain,
                _excludeLocationId);

            if (newLocationId)
            {
                excludeLocationIdSet.add(newLocationId);
            }

            return [newLocationId, excludeLocationIdSet.pack()];
        }

        return this.findNewLocationWithDirectiveCode(_workLine, _excludeLocationId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNewLocationFromOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find new location using specific inventory dimensions.
    /// </summary>
    /// <param name = "_itemId">Item identifier to search on-hand for.</param>
    /// <param name = "_inventDimId">Inventory dimensions to search on-hand at.</param>
    /// <param name = "_inventQtyToFind">How much quantity to find.</param>
    /// <param name="_excludeLocationId">A <c>Set</c> of WMSLocationIds which should be excluded from location search.</param>
    /// <returns>A location that match criteria.</returns>
    private WMSLocationId findNewLocationFromOnHand(ItemId               _itemId,
                                                    InventDimId          _inventDimId,
                                                    InventHandlingQty    _inventQtyToFind,
                                                    Set                  _excludeLocationId)
    {
        WMSLocationId	curWMSLocationId, prevWMSLocationId;
        InventQty		locationQty;

        InventDimId		mandatoryDimensionsInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(_itemId, _inventDimId);
        InventDim		inventDim = InventDim::find(mandatoryDimensionsInventDimId);

        InventDimParm	inventDimParm;
        inventDimParm.initFromInventDim(inventDim);

        if (InventUpdateOnHandGlobal::mustAddInventSumDeltaOnhand(_itemId))
        {
            InventSumUnionAllDeltaPhysicalQty inventSumSpecific;
            InventDim                         inventDimSpecific;

            while select inventSumSpecific
                order by inventDimSpecific.InventLocationId, inventDimSpecific.wMSLocationId
                where  inventSumSpecific.ItemId == _itemId
                    && inventSumSpecific.PhysicalInvent > 0
                #InventDimInnerJoin(inventSumSpecific.inventDimId, inventDimSpecific, inventDim, inventDimParm)
            {
                if (_excludeLocationId.in(inventDimSpecific.wMSLocationId))
                {
                    locationQty = 0;
                    curWMSLocationId = '';
                    prevWMSLocationId = '';

                    continue;
                }

                if (prevWMSLocationId != inventDimSpecific.wMSLocationId)
                {
                    locationQty = 0;
                    curWMSLocationId = inventDimSpecific.wMSLocationId;
                    prevWMSLocationId = inventDimSpecific.wMSLocationId;
                }

                locationQty += WHSInventOnHand::getPhysicalAvailHandlingQty(_itemId, inventDimSpecific, true, true);

                if (locationQty >= _inventQtyToFind)
                {
                    break;
                }
            }
        }
        else
        {
            InventSum inventSumSpecific;
            InventDim inventDimSpecific;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select #InventDimGroupAllFields from inventSumSpecific
                order by inventSumSpecific.InventLocationId, inventSumSpecific.wMSLocationId
                where  inventSumSpecific.ItemId == _itemId
                    && inventSumSpecific.PhysicalInvent > 0
                    && inventSumSpecific.ClosedQty == NoYes::No
                    && #InventDimFieldsFilter(inventSumSpecific, inventDim, inventDimParm)
                {
                    inventDimSpecific.clear();
                    inventDimSpecific.initFromInventSum(inventSumSpecific);

                    if (_excludeLocationId.in(inventDimSpecific.wMSLocationId))
                    {
                        locationQty = 0;
                        curWMSLocationId = '';
                        prevWMSLocationId = '';

                        continue;
                    }

                    if (prevWMSLocationId != inventDimSpecific.wMSLocationId)
                    {
                        locationQty = 0;
                        curWMSLocationId = inventDimSpecific.wMSLocationId;
                        prevWMSLocationId = inventDimSpecific.wMSLocationId;
                    }

                    locationQty += WHSInventOnHand::getPhysicalAvailHandlingQty(_itemId, inventDimSpecific, true, true);

                    if (locationQty >= _inventQtyToFind)
                    {
                        break;
                    }
                }
            }
            else
            {
                while select inventSumSpecific
                order by inventDimSpecific.InventLocationId, inventDimSpecific.wMSLocationId
                where  inventSumSpecific.ItemId == _itemId
                    && inventSumSpecific.PhysicalInvent > 0
                    && inventSumSpecific.ClosedQty == NoYes::No
                #InventDimInnerJoin(inventSumSpecific.inventDimId, inventDimSpecific, inventDim, inventDimParm)
                {
                    if (_excludeLocationId.in(inventDimSpecific.wMSLocationId))
                    {
                        locationQty = 0;
                        curWMSLocationId = '';
                        prevWMSLocationId = '';

                        continue;
                    }

                    if (prevWMSLocationId != inventDimSpecific.wMSLocationId)
                    {
                        locationQty = 0;
                        curWMSLocationId = inventDimSpecific.wMSLocationId;
                        prevWMSLocationId = inventDimSpecific.wMSLocationId;
                    }

                    locationQty += WHSInventOnHand::getPhysicalAvailHandlingQty(_itemId, inventDimSpecific, true, true);

                    if (locationQty >= _inventQtyToFind)
                    {
                        break;
                    }
                }
            }
        }

        if (locationQty < _inventQtyToFind)
        {
            curWMSLocationId = '';
        }

        return curWMSLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNewLocationWithDirectiveCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a new pick/put location for a work line using location directives with directive code.
    /// </summary>
    /// <param name="_workLine">
    /// Work line that needs a location.
    /// </param>
    /// <param name="_excludeLocationId">
    /// Set containing location ids to be excluded in location directives.
    /// </param>
    /// <param name="_locDirHintCode">
    /// Finds a location with directive code.
    /// </param>
    /// <returns>
    /// Container containing found location information.
    /// </returns>
    public container findNewLocationWithDirectiveCode(
        WHSWorkLine		  _workLine,
        Set				  _excludeLocationId,
        WHSLocDirHintCode _locDirHintCode)
    {
        WHSLocationDirective    locationDirective = new WHSLocationDirective();
        WMSLocationId           wmsLocationId;
        InventQty               inventQty;
        Qty                     qty;
        UnitOfMeasureSymbol     unitId;
        Set                     excludeLocationId = new Set(Types::String);
        InventBatchId           inventBatchId;
        InventDim               workLineInventDim;
        InventSum               inventSum;

        excludeLocationId       = _excludeLocationId;
        WHSWorkTable workTable  = _workLine.whsWorkTable();
        WHSLocDirHintCode directiveCode = this.findDirectiveCode(_workLine, _locDirHintCode);
        
        WHSLicensePlateId targetLP = workTable.TargetLicensePlateId;

        while (inventQty != _workLine.InventQtyRemain)
        {
            if (_workLine.ItemId)
            {
                if (InventTable::find(_workLine.ItemId).whsBatchActive())
                {
                    workLineInventDim = _workLine.inventDim();

                    inventBatchId = workLineInventDim.InventBatchId;

                    if (!inventBatchId)
                    {
                        if (InventUseDimOfInventSumToggle::instance().isEnabled())
                        {
                            select firstonly InventBatchId from inventSum
                            where inventSum.InventLocationId    == workLineInventDim.InventLocationId               &&
                                  inventSum.LicensePlateId      == workTable.TargetLicensePlateId                   &&
                                  inventSum.ItemId              == _workLine.ItemId                                 &&
                                  inventSum.ClosedQty           == NoYes::No                                        &&
                                  inventSum.PhysicalInvent       > 0;

                            inventBatchId = inventSum.InventBatchId;
                        }
                        else
                        {
                            InventDim               inventDim;

                            select firstonly InventBatchId from inventDim
                            where inventDim.InventLocationId    == workLineInventDim.InventLocationId               &&
                                  inventDim.LicensePlateId      == workTable.TargetLicensePlateId
                            exists join inventSum
                            where inventSum.InventDimId         == inventDim.InventDimId                            &&
                                  inventSum.ItemId              == _workLine.ItemId                                 &&
                                  inventSum.ClosedQty           == NoYes::No                                        &&
                                  inventSum.PhysicalInvent       > 0;

                            inventBatchId = inventDim.InventBatchId;
                        }
                    }
                }

                if (workTable.WorkTransType == WHSWorkTransType::QualityOrder)
                {
                    locationDirective.setOriginRefId(workTable.OrderNum);
                }

                [wmsLocationId, qty, unitId, inventQty] = locationDirective.findPickPutLocation(_workLine.InventDimId,
                                                                                                _workLine.InventTransId,
                                                                                                _workLine.ItemId,
                                                                                                _workLine.InventQtyRemain,
                                                                                                workTable.WorkTransType,
                                                                                                _workLine.WorkType,
                                                                                                directiveCode,
                                                                                                WHSLoadLine::findbyRecId(_workLine.LoadLineRefRecId).PackingQty,
                                                                                                excludeLocationId,
                                                                                                '',
                                                                                                inventBatchId,
                                                                                                workTable.DispositionCode, 
                                                                                                null, 
                                                                                                targetLP);
            }
            else
            {
                [wmsLocationId, qty, unitId, inventQty] = locationDirective.findPickPutLocationMultiSKU(workTable.InventLocationId,
                                                                                                        workTable.WorkTransType,
                                                                                                        _workLine.WorkType,
                                                                                                        directiveCode,
                                                                                                        excludeLocationId,
                                                                                                        workTable.DispositionCode,
                                                                                                        targetLP);

                qty         = _workLine.QtyRemain;
                unitId      = _workLine.UnitId;
                inventQty   = _workLine.InventQtyRemain;
            }

            if (wmsLocationId)
            {
                excludeLocationId.add(wmsLocationId);
            }
            else
            {
                break;
            }
        }

        return [wmsLocationId, excludeLocationId.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDirectiveCode</Name>
				<Source><![CDATA[
    private WHSLocDirHintCode findDirectiveCode(WHSWorkLine _workline, WHSLocDirHintCode _locDirHintCode)
    {
        WHSLocDirHintCode localLocDirHintCode;

        if (_workLine.WorkTemplateLineRecId)
        {
            localLocDirHintCode = WHSWorkTemplateLine::findByRecId(_workLine.WorkTemplateLineRecId).LocDirHintCode;
        }
        if (!localLocDirHintCode && _locDirHintCode)
        {
            localLocDirHintCode = _locDirHintCode;
        }

        return localLocDirHintCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds first open work line related to a work header.
    /// The work line status can be Open, InProcess or PendingReview.
    /// </summary>
    /// <param name="_workId">
    /// Work header id.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_throwOnInvalidWork">
    /// A boolean that allows throwing an error for invalid work.
    /// </param>
    /// <returns>
    /// The first open work line.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if header record is not found.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if work is frozen.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if work is in Cancelled status.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if the work is not locked by the work user.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if the work only has pick lines that need replenishment left.
    /// </exception>
    /// <remarks>
    /// If the work order replenishment dependent work blocking policy is set up to block on individual line level, account for lines with replenishment potentially present.
    /// </remarks>
    public WHSWorkLine getFirstOpenLine(
        WHSWorkId _workId,
        WHSUserId _userId,
        boolean _throwOnInvalidWork = true)
    {
        return this.getFirstOpenLineByWorkTable(
            WHSWorkTable::find(_workId, true),
            _userId,
            _throwOnInvalidWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenLineByWorkTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds first open work line related to a work header.
    /// The work line status can be Open, InProcess or PendingReview.
    /// </summary>
    /// <param name="_workTable">
    /// Work header table buffer.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_throwOnInvalidWork">
    /// A boolean that allows throwing an error for invalid work.
    /// </param>
    /// <returns>
    /// The first open work line.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if header record is not found.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if work is frozen.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if work is in Cancelled status.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if the work is not locked by the work user.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown if the work only has pick lines that need replenishment left.
    /// </exception>
    /// <remarks>
    /// If the work order replenishment dependent work blocking policy is set up to block on individual line level, account for lines with replenishment potentially present.
    /// </remarks>
    public WHSWorkLine getFirstOpenLineByWorkTable(
        WHSWorkTable _workTable,
        WHSUserId    _userId,
        boolean      _throwOnInvalidWork = true)
    {
        WHSWorkHeaderProcessingValidator workValidator = WHSWorkHeaderProcessingValidator::newFromWorkTable(_workTable, _userId);
        workValidator.parmThrowOnInvalidWork(_throwOnInvalidWork);

        boolean ret = workValidator.validateWorkHeaderForProcessing();

        if (ret)
        {
            WHSSingleWorkLineSelector workLineSelector = WHSSingleWorkLineSelector::newFromWorkTable(_workTable);
            WHSWorkLine workLine = workLineSelector.findOpenWorkLine();

            WHSWorkLineProcessingValidator workLineValidator = WHSWorkLineProcessingValidator::newFromWorkLine(workLine, _userId);
            workLineValidator.parmThrowOnInvalidWork(_throwOnInvalidWork);

            if (workLineValidator.validateWorkLineForProcessing())
            {
                return workLine;
            }
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkEligibleForSystemDirected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the work is eligible for system directed flows.
    /// </summary>
    /// <param name = "_skipWorkId">Container of works in which the work is not expected to be.</param>
    /// <param name = "_workTable">Work to check.</param>
    /// <param name = "_userId">The userid for which the work is being checked.</param>
    /// <returns>
    /// true if the work is eligible for system directed flows; otherwise, false.
    /// </returns>
    [Hookable(true)]
    protected internal boolean isWorkEligibleForSystemDirected(
        container		_skipWorkId,
        WHSWorkTable	_workTable,
        WHSUserId		_userId)
    {
        boolean ret = (!_workTable.LockedUser || _workTable.LockedUser == _userId)
                        && (_skipWorkId == conNull() || !conFind(_skipWorkId, _workTable.WorkId));

        ret = ret && (_workTable.shouldSkipLoadingStrategyValidation() || _workTable.validateWorkCanBeLoadedWithoutTransportLoad());

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSystemDirectedWorkLineDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first eligible work line for system directed menu items.
    /// </summary>
    /// <param name = "_menuItemName">
    /// Name of the menu item that has defined as system directed.
    /// </param>
    /// <param name = "_inventSiteId">
    /// Site id to be set to query range.
    /// </param>
    /// <param name = "_inventLocationId">
    /// Warehouse id to be set to query range.
    /// </param>
    /// <param name = "_userId">
    /// Work user id to be set to query range.
    /// </param>
    /// <param name = "_skipWorkId">
    /// Container containing work ids to be skipped for finding the first open work line.
    /// </param>
    /// <param name = "_sequenceNumber">
    /// The sequence number lf the system directed work sequence queries to begin searching from.
    /// </param>
    /// <returns>
    /// An instance of the <c>WHSSystemDirectedWorkLineDetails</c> that provides the work line and the
    /// sequence number of the system directed work sequence query where the work line was found.
    /// </returns>
    [Hookable(false)]
    final public WHSSystemDirectedWorkLineDetails getSystemDirectedWorkLineDetails(
        WHSMenuItemName		_menuItemName,
        InventSiteId		_inventSiteId,
        InventLocationId	_inventLocationId,
        WHSUserId			_userId,
        container			_skipWorkId,
        WHSSeqNum			_sequenceNumber)
    {
        return this.findSystemDirectedWorkLineDetails(_menuItemName,
            _inventSiteId,
            _inventLocationId,
            _userId,
            _skipWorkId,
            _sequenceNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenLineSystemDirected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds first open work line assigned to work user using system directed menu item.
    /// </summary>
    /// <param name="_menuItemName">
    /// Name of the menu item that has defined as system directed.
    /// </param>
    /// <param name="_inventSiteId">
    /// Site id to be set to query range.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id to be set to query range.
    /// </param>
    /// <param name="_userId">
    /// Work user id to be set to query range.
    /// </param>
    /// <param name="_skipWorkId">
    /// Container containing work ids to be skipped for finding the first open work line.
    /// </param>
    /// <returns>
    /// First open work line directed by system to the work user.
    /// </returns>
    [SysObsolete('Method is obsoleted to support system directed work sequencing. Callers should redirect their calls to the getSystemDirectedWorkLineDetails method. Extenders should move their logic to wrap or override the findSystemDirectedWorkLineDetails method.', false, 1\1\2020)]
    public WHSWorkLine getFirstOpenLineSystemDirected(WHSMenuItemName  _menuItemName,
                                                      InventSiteId     _inventSiteId,
                                                      InventLocationId _inventLocationId,
                                                      WHSUserId        _userId,
                                                      container        _skipWorkId = conNull())
    {
        if (WHSParameters::find().EnableSystemDirectedWorkSequencing)
        {
            // The System Directed Work Sequence functionality has been enabled in this company
            // Block calls to the obsolete API that relies on the legacy way of sequencing work
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        Query	query           = new Query(queryStr(WHSWorkSysDir));
        Set     workClassIdSet  = this.getFirstOpenLineSystemDirectedWorkClassIds(_menuItemName);

        QueryRun queryRun = new QueryRun(query);

        WHSWorkLine returnWorkLine = this.getFirstOpenWorkLineSystemDirectedFromQueryRun(queryRun,
                _menuItemName,
                _inventSiteId,
                _inventLocationId,
                _userId,
                _skipWorkId,
                workClassIdSet,
                false);

        return returnWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSystemDirectedWorkLineDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first eligible work line for system directed menu items.
    /// </summary>
    /// <param name = "_menuItemName">
    /// Name of the menu item that has defined as system directed.
    /// </param>
    /// <param name = "_inventSiteId">
    /// Site id to be set to query range.
    /// </param>
    /// <param name = "_inventLocationId">
    /// Warehouse id to be set to query range.
    /// </param>
    /// <param name = "_userId">
    /// Work user id to be set to query range.
    /// </param>
    /// <param name = "_skipWorkId">
    /// Container containing work ids to be skipped for finding the first open work line.
    /// </param>
    /// <param name = "_sequenceNumber">
    /// The sequence number lf the system directed work sequence queries to begin searching from.
    /// </param>
    /// <returns>
    /// An instance of the <c>WHSSystemDirectedWorkLineDetails</c> that provides the work line and the
    /// sequence number of the system directed work sequence query where the work line was found.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the getSystemDirectedWorkLineDetails method.
    /// </remarks>
    [Wrappable(true)]
    final protected WHSSystemDirectedWorkLineDetails findSystemDirectedWorkLineDetails(
        WHSMenuItemName		_menuItemName,
        InventSiteId		_inventSiteId,
        InventLocationId	_inventLocationId,
        WHSUserId			_userId,
        container			_skipWorkId,
        WHSSeqNum			_sequenceNumber)
    {
        WHSSystemDirectedWorkLineDetails systemDirectedWorkLineDetails = this.getWorkLineDetailsFromSystemDirectedWorkSequenceQueries(_menuItemName,
            _inventSiteId,
            _inventLocationId,
            _userId,
            _skipWorkId,
            _sequenceNumber);

        if (!systemDirectedWorkLineDetails.hasWorkLine()) // if nothing found in the remaining queries in the sequence order, restart the sequence and run again
        {
            systemDirectedWorkLineDetails = this.getWorkLineDetailsFromSystemDirectedWorkSequenceQueries(_menuItemName,
                _inventSiteId,
                _inventLocationId,
                _userId,
                _skipWorkId,
                0);
        }

        return systemDirectedWorkLineDetails;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkLineDetailsFromSystemDirectedWorkSequenceQueries</Name>
				<Source><![CDATA[
    private WHSSystemDirectedWorkLineDetails getWorkLineDetailsFromSystemDirectedWorkSequenceQueries(
        WHSMenuItemName		_menuItemName,
        InventSiteId		_inventSiteId,
        InventLocationId	_inventLocationId,
        WHSUserId			_userId,
        container			_skipWorkId,
        WHSSeqNum			_sequenceNumber)
    {
        Set workClassIdSet  = this.getFirstOpenLineSystemDirectedWorkClassIds(_menuItemName);
        WHSSystemDirectedWorkSequenceQuery systemDirectedWorkSequenceQuery;
        WHSSystemDirectedWorkLineDetails    systemDirectedWorkLineDetails;

        using (var workQueryingPerfTask = WHSInstrumentationSystemDirectedWorkQueryingPerformanceTask::newProcessWorkSequenceQuery(WHSRFMenuItemTable::find(_menuItemName), InventLocation::find(_inventLocationId), _sequenceNumber))
        {
            while select PackedQueryRun, SequenceNumber from systemDirectedWorkSequenceQuery
                order by SequenceNumber asc
                where systemDirectedWorkSequenceQuery.MenuItemName		== _menuItemName
                    && systemDirectedWorkSequenceQuery.SequenceNumber	>= _sequenceNumber
            {
                WHSWorkLine returnWorkLine = this.getFirstOpenWorkLineSystemDirectedFromQueryRun(new QueryRun(systemDirectedWorkSequenceQuery.PackedQueryRun),
                    _menuItemName,
                    _inventSiteId,
                    _inventLocationId,
                    _userId,
                    _skipWorkId,
                    workClassIdSet,
                    true);

                if (returnWorkLine)
                {
                    systemDirectedWorkLineDetails = WHSSystemDirectedWorkLineDetails::newFromWorkLineSequenceNumber(returnWorkLine, systemDirectedWorkSequenceQuery.SequenceNumber);
                    break;
                }
            }

            if (!systemDirectedWorkLineDetails)
            {
                systemDirectedWorkLineDetails = WHSSystemDirectedWorkLineDetails::newDefault();
            }

            workQueryingPerfTask.setEndingSequenceNumber(systemDirectedWorkLineDetails.SequenceNumber);
            workQueryingPerfTask.setWorkLine(systemDirectedWorkLineDetails.WorkLine);
        }

        return systemDirectedWorkLineDetails;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenWorkLineSystemDirectedFromQueryRun</Name>
				<Source><![CDATA[
    private WHSWorkLine getFirstOpenWorkLineSystemDirectedFromQueryRun(
        QueryRun			_queryRun,
        WHSMenuItemName		_menuItemName,
        InventSiteId		_inventSiteId,
        InventLocationId	_inventLocationId,
        WHSUserId			_userId,
        container			_skipWorkId,
        Set					_workClassIdSet,
        boolean				_mustDirectlyUpdateWorkUser)
    {
        QueryBuildDataSource qbdsWorkTable   = this.buildWorkTableQuery(_menuItemName, _userId, _queryRun.query(), _inventSiteId, _inventLocationId);
        this.excludePartialCycleCountWorkForBlindCycleCount(qbdsWorkTable, _menuItemName);
        this.buildWorkLineQuery(_workClassIdSet, _queryRun.query());

        WHSWorkLine workLine;

        while (_queryRun.next())
        {
            WHSWorkTable workTable = _queryRun.get(tableNum(WHSWorkTable));

            if (_mustDirectlyUpdateWorkUser)
            {
                workLine = this.getFirstOpenWorkLineAndUpdateWorkLockedByUser(workTable.WorkId, _userId, _skipWorkId, _workClassIdSet);

                if (workLine.RecId)
                {
                    break;
                }
            }
            else
            {
                /*
                Re-find the workTable in case the query becomes out of date.
                This often occurs when the work user is updated, so this should also be rechecked
                despite it being included in the work table query by default.
                */

                workTable = WHSWorkTable::find(workTable.WorkId);

                if (this.isWorkEligibleForSystemDirected(_skipWorkId, workTable, _userId))
                {
                    workLine = this.getFirstOpenLine(workTable.WorkId, _userId, false);

                    // Validate work class again for first open line
                    if (this.isWorkLineValid(workLine, _workClassIdSet))
                    {
                        break;
                    }
                    else
                    {
                        workLine.clear();
                    }
                }
            }
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenWorkLineAndUpdateWorkLockedByUser</Name>
				<Source><![CDATA[
    private WHSWorkLine getFirstOpenWorkLineAndUpdateWorkLockedByUser(WHSWorkId	_workId,
                                                                      WHSUserId	_userId,
                                                                      container	_skipWorkId,
                                                                      Set		_workClassIdSet)
    {
        UserConnection  conn;
        WHSWorkTable    workTable;
        WHSWorkLine		workLine;
     
        try
        {
            conn = new UserConnection();

            workTable.setConnection(conn);

            conn.ttsbegin();
    
            workTable.readPast(true);

            select firstonly pessimisticLock workTable
                where workTable.WorkId == _workId;
    
            if (workTable && this.isWorkEligibleForSystemDirected(_skipWorkId, workTable, _userId))
            {
                workLine = this.getFirstOpenLine(workTable.WorkId, _userId, false);
                
                // Validate work class again for first open line
                if (this.isWorkLineValid(workLine, _workClassIdSet))
                {
                    workTable.LockedUser = _userId;
                    workTable.update();
                }
                else
                {
                    workLine.clear();
                }
            }

            conn.ttscommit();
        }
        finally
        {
            conn.finalize();
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLineValid</Name>
				<Source><![CDATA[
    private boolean isWorkLineValid(WHSWorkLine _workLine, Set _workClassIdSet)
    {
        return (_workLine && (!_workClassIdSet.elements() || _workClassIdSet.in(_workLine.WorkClassId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenLineSystemDirectedWorkClassIds</Name>
				<Source><![CDATA[
    private Set getFirstOpenLineSystemDirectedWorkClassIds(WHSMenuItemName _menuItemName)
    {
        Set                 workClassIdSet = new Set(Types::String);
        WHSRFMenuItemLine   menuItemLine;
        
        while select WorkClassId from menuItemLine
            where menuItemLine.MenuItemName == _menuItemName
        {
            workClassIdSet.add(menuItemLine.WorkClassId);
        }

        return workClassIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkLineQuery</Name>
				<Source><![CDATA[
    [Hookable(true)]
    protected internal QueryBuildDataSource buildWorkLineQuery(Set _workClassIdSet, Query _query)
    {
        QueryBuildDataSource qbdsWorkLine = _query.dataSourceTable(tableNum(WHSWorkLine));
        
        Enumerator enumerator = _workClassIdSet.getEnumerator();
        str workClassIdRange;
        while (enumerator.moveNext())
        {
            workClassIdRange = queryRangeConcat(workClassIdRange, enumerator.current());
        }
        // Add Work Class ranges
        qbdsWorkLine.addRange(fieldNum(WHSWorkLine, WorkClassId)).value(workClassIdRange);
        return qbdsWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkTableQuery</Name>
				<Source><![CDATA[
    [Hookable(true)]
    protected internal QueryBuildDataSource buildWorkTableQuery(
        WHSMenuItemName     _menuItemName,
        WHSUserId           _userId,
        Query               _query,
        InventSiteId        _inventSiteId,
        InventLocationId    _inventLocationId)
    {
        QueryBuildDataSource qbdsWorkTable = _query.dataSourceTable(tableNum(WHSWorkTable));

        if (qbdsWorkTable)
        {
            // Add Site and Warehouse ranges
            qbdsWorkTable.addRange(fieldNum(WHSWorkTable, InventSiteId)).value(SysQuery::value(_inventSiteId));
            qbdsWorkTable.addRange(fieldNum(WHSWorkTable, InventLocationId)).value(SysQuery::value(_inventLocationId));

            // Add User range
            SysQuery::findOrCreateRange(qbdsWorkTable, fieldNum(WHSWorkTable, LockedUser)).value(strFmt('%1,=""', _userId));

            QueryBuildRange qbr = SysQuery::findOrCreateRange(qbdsWorkTable, fieldNum(WHSWorkTable, recid));
            qbr.value(strFmt('(%1!=%2)', fieldStr(WHSWorkTable, workTransType), any2int(WHSWorkTransType::Packing)));
        }

        return qbdsWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludePartialCycleCountWorkForBlindCycleCount</Name>
				<Source><![CDATA[
    private void excludePartialCycleCountWorkForBlindCycleCount(QueryBuildDataSource _qbdsWorkTable, WHSMenuItemName _menuItemName)
    {
        if (!WHSRFMenuItemCycleCount::find(_menuItemName).BlindItem)
        {
            _qbdsWorkTable.addRange(fieldNum(WHSWorkTable, IsPartialCycleCountWork)).value(SysQuery::value(NoYes::No));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLicensePlateLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the location of a license plate from inventory dimensions.
    /// </summary>
    /// <param name="_inventLocationId">
    /// Warehouse id that the location is located.
    /// </param>
    /// <param name="_inventSiteId">
    /// Site id that the location is located.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id.
    /// </param>
    /// <returns>
    /// Location of a license plate in the warehouse.
    /// </returns>
    WMSLocationId getLicensePlateLocation(InventLocationId  _inventLocationId,
                                          InventSiteId      _inventSiteId,
                                          WHSLicensePlateId _licensePlateId)
    {
        InventSum       inventSum;
        
        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            select firstonly wmsLocationId from inventSum
            where inventSum.InventLocationId    == _inventLocationId        &&
                  inventSum.LicensePlateId      == _licensePlateId          &&
                  inventSum.ClosedQty           == NoYes::No                &&
                  inventSum.PhysicalInvent       > 0;

            return inventSum.wmsLocationId;
        }
        else
        {
            InventDim       inventDim;

            select firstonly wmsLocationId from inventDim
            join InventDimId, PhysicalInvent from inventSum
            where inventDim.InventDimId         == inventSum.InventDimId    &&
                  inventDim.InventLocationId    == _inventLocationId        &&
                  inventDim.LicensePlateId      == _licensePlateId          &&
                  inventSum.ClosedQty           == NoYes::No                &&
                  inventSum.PhysicalInvent       > 0;

            return inventDim.wmsLocationId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModule</Name>
				<Source><![CDATA[
    WHSModule getModule(WHSWorkTransType _workTransType)
    {
        WHSModule   module;

        switch (_workTransType)
        {
            case WHSWorkTransType::Sales:
                module = WHSModule::Sales;
                break;

            case WHSWorkTransType::Purch:
                module = WHSModule::Purch;
                break;
        }

        return module;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrevLineRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a from line number and to line number that is the range matching the passed in type
    /// </summary>
    /// <param name="_workId">
    /// The work ID
    /// </param>
    /// <param name="_lineNum">
    /// The starting line number.
    /// </param>
    /// <param name="_workType">
    /// The type to look for.
    /// </param>
    /// <returns>
    /// A from line number and to line number that is the range matching the passed in type.
    /// </returns>
    container getPrevLineRange(WHSWorkId _workId, LineNum _lineNum, WHSWorkType _workType)
    {
        WHSWorkLine     workLine;
        LineNum         fromLineNum;
        LineNum         toLineNum;

        ttsbegin;

        select firstonly LineNum from workLine
            order by LineNum desc
            where workLine.WorkId           == _workId
                && workLine.LineNum          <  _lineNum
                && workLine.WorkType         == _workType
                && workLine.WorkStatus       != WHSWorkStatus::Skipped
                && workLine.WorkStatus       != WHSWorkStatus::Cancelled;

        if (workLine.LineNum)
        {
            toLineNum = workLine.LineNum;

            select firstonly LineNum from workLine
                order by LineNum desc
                where workLine.WorkId           == _workId
                    && workLine.LineNum          <  toLineNum
                    && workLine.WorkType         != _workType
                    && workLine.WorkStatus       != WHSWorkStatus::Skipped
                    && workLine.WorkStatus       != WHSWorkStatus::Cancelled;

            fromLineNum = workLine.LineNum + 1;
        }

        ttscommit;

        return [fromLineNum, toLineNum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInitialPickDimTrackingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which inserts dimension tracking records for any initial pick work lines
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension set used for picking
    /// </param>
    /// <returns>
    /// true if work transactions item number is not dimension tracked, work transaction type is of a given picking type or a dimension tracked record got inserted; otherwise false
    /// </returns>
    private boolean insertInitialPickDimTrackingRecords(
        WHSWorkLine _workLine,
        InventDim   _inventDim)
    {
        boolean dimTrackingControlled = false;
  
        ttsbegin;

        WHSWorkTable workTable = _workLine.whsWorkTable();
        Map itemId2FieldIdList = new Map(Types::String, Types::Class);
        Map usedDimQuantities = new Map(Types::String, Types::Real);
        WHSWorkInventTrans workInventTrans;

        while select workInventTrans
            where workInventTrans.WorkId            == _workLine.WorkId
            &&    workInventTrans.LineNum           == _workLine.LineNum
            &&    workInventTrans.InventQtyRemain    > 0
        {
            if (this.itemIsDimTrackingControlled(workInventTrans.ItemId) ||
                this.mustUseDimTrackingForWorkTransType(workInventTrans.ItemId, workTable.WorkTransType))
            {
                dimTrackingControlled = true;
                this.insertInitialPickDimTrackingRecordsForWorkInventTrans(workTable, _workLine, workInventTrans, _inventDim, usedDimQuantities, itemId2FieldIdList);
            }
        }

        ttscommit;

        return !dimTrackingControlled || !usedDimQuantities.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInitialPickDimTrackingRecordsForWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the initial picking dimension tracking records for a work inventory transaction.
    /// </summary>
    /// <param name = "_workTable">The work to insert the tracking records for.</param>
    /// <param name = "_workLine">The work line to insert the tracking records for.</param>
    /// <param name = "_workInventTrans">The work transaction to insert the tracking records for.</param>
    /// <param name = "_inventDim">The below location dimension set used for picking.</param>
    /// <param name = "_usedDimQuantities">A map with the dimension quantities used.</param>
    /// <param name = "_itemId2FieldIdList">A cache list of fields for items.</param>
    protected void insertInitialPickDimTrackingRecordsForWorkInventTrans(
        WHSWorkTable        _workTable,
        WHSWorkLine         _workLine,
        WHSWorkInventTrans  _workInventTrans,
        InventDim           _inventDim,
        Map                 _usedDimQuantities,
        Map                 _itemId2FieldIdList)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTable.WorkTransType);

        if (workTransactionType && this.mustInsertInitialPickDimTrackingRecords(_workInventTrans, _inventDim))
        {
            workTransactionType.insertInitialPickDimTrackingRecords(_workTable, _workLine, _workInventTrans, _inventDim, _usedDimQuantities, _itemId2FieldIdList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertInitialPickDimTrackingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether dimension tracking records for initial pick work lines must be inserted.
    /// </summary>
    /// <param name = "_workInventTrans">Inventory transaction for work.</param>
    /// <param name = "_inventDim">The below location dimension set used for picking.</param>
    /// <returns>true if dimension tracking records for initial pick work lines must be inserted; otherwise, false.</returns>
    protected boolean mustInsertInitialPickDimTrackingRecords(WHSWorkInventTrans _workInventTrans, InventDim  _inventDim)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertStagedPickDimTrackingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which inserts dimension tracking records for any staged pick work lines
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed
    /// </param>
    /// <returns>
    /// true if any dim tracking records were inserted; otherwise false
    /// </returns>
    private boolean insertStagedPickDimTrackingRecords(WHSWorkLine  _workLine)
    {
        boolean ret;

        ttsbegin;

        ret = this.createOrUpdateDimTrackingForWorkLines(_workLine) || ret;

        //if we have a contribution to this line we need to go back and also include those tracking records
        ret = this.createDimTrackingFromWorkLineOrigin(_workLine) || ret;

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingFromWorkLineOrigin</Name>
				<Source><![CDATA[
    private boolean createDimTrackingFromWorkLineOrigin(WHSWorkLine _workLine)
    {
        WHSConsolidatedWorkLine consolidatedWorkLine;
        WHSWorkLine       predecessorWorkLine;
        boolean anyWritten = false;

        while select predecessorWorkLine
            exists join consolidatedWorkLine
            where consolidatedWorkLine.ConsolidatedWorkLine == _workLine.recId
                &&  consolidatedWorkLine.OriginWorkLine     == predecessorWorkLine.RecId
        {
            anyWritten = this.createOrUpdateDimTrackingForWorkLines(predecessorWorkLine, _workLine) || anyWritten;
        }

        return anyWritten;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateDimTrackingForWorkLines</Name>
				<Source><![CDATA[
    private boolean createOrUpdateDimTrackingForWorkLines(WHSWorkLine _workLineFrom, WHSWorkLine _workLineTo = _workLineFrom)
    {
        WHSWorkLine workLinePrevPickOrigin = WHSWorkLine::getPreviousOppositePredecessorSameTypeWorkLine(_workLineFrom);
        WHSDimTracking dimTracking;
        InventDim inventDimJoin;
        boolean anyWritten = false;
        WHSLicensePlateId targetLicensePlateId = _workLineTo.whsWorkTable().TargetLicensePlateId;

        while select dimTracking
            where dimTracking.WorkId    == _workLineFrom.WorkId
                &&    dimTracking.LineNum    < _workLineFrom.LineNum
                &&    dimTracking.LineNum    > workLinePrevPickOrigin.LineNum
                &&    dimTracking.Processed == NoYes::Yes
            join inventDimJoin
                where inventDimJoin.inventDimId == dimTracking.InventDimId
        {
            WHSDimTracking updateOrCreateDimTracking;
            //we need to merge in location and lp from the work line
            InventDim inventDim;
            buf2Buf(inventDimJoin, inventDim);
            inventDim.wmsLocationId = _workLineTo.wmsLocationId;

            WHSWorkTable workTable = WHSWorkTable::find(_workLineFrom.WorkId);

            // Need to update new inventory status while it is changed during inventory movement by template.
            if (workTable.WorkTransType == WHSWorkTransType::Invent)
            {
                inventDim.InventStatusId = InventDim::find(_workLineFrom.InventDimId).InventStatusId;
            }

            // Packed containers that are grouped on a license plate should use the existing child license plate and not the parent license plate.
            if (workTable.WorkTransType != WHSWorkTransType::PackedContainerPicking
                || !WHSLicensePlate::isParentLicensePlate(targetLicensePlateId))
            {
                inventDim.LicensePlateId = targetLicensePlateId;
            }

            inventDim = InventDim::findOrCreate(inventDim);

            //if from and to are different then try to find an existing one on the to-work that can be updated
            // NOTE - we expect this condition to be false when WorkTransType is Invent, because we are changing inventDim above in case of WorkTransType::Invent
            // hence we would not find any dimtracking based on new inventdim
            if (_workLineFrom.RecId != _workLineTo.RecId)
            {
                select firstonly forupdate updateOrCreateDimTracking
                    where updateOrCreateDimTracking.InventTransIdParent == dimTracking.InventTransIdParent
                        && updateOrCreateDimTracking.WorkId == _workLineTo.WorkId
                        && updateOrCreateDimTracking.LineNum == _workLineTo.LineNum
                        && updateOrCreateDimTracking.InventDimId == inventDim.inventDimId
                        && updateOrCreateDimTracking.Processed == NoYes::No;
            }

            if (!updateOrCreateDimTracking.RecId)
            {
                buf2Buf(dimTracking, updateOrCreateDimTracking);
                updateOrCreateDimTracking.WorkId        = _workLineTo.WorkId;
                updateOrCreateDimTracking.LineNum       = _workLineTo.LineNum;
                updateOrCreateDimTracking.InventDimId   = inventDim.InventDimId;
                updateOrCreateDimTracking.Processed     = NoYes::No;
            }
            else
            {
                updateOrCreateDimTracking.Qty += dimTracking.Qty;
            }

            updateOrCreateDimTracking.write();
            anyWritten = true;
        }

        return anyWritten;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostOnhandCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Getter method for inventCostOnhandCache field.
    /// </summary>
    /// <returns>
    /// The inventory cost onhand cache.
    /// </returns>
    [Hookable(false)]
    public InventCostOnhandCache inventCostOnhandCache()
    {
        if (!inventCostOnhandCache)
        {
            inventCostOnhandCache = InventCostOnhandCache::construct();
        }

        return inventCostOnhandCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemSerialControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if items serial number is control enabled.
    /// </summary>
    /// <param name = "_itemId">
    /// ItemId that need to be checked.
    /// </param>
    /// <returns>
    /// If the items serial number is control enabled, return true;
    /// otherwise, return false.
    /// </returns>
    [SysObsolete('Use InventTable.isItemSerialNumberControlled() instead.', false, 30\11\2017)]
    public static boolean isItemSerialControlled(ItemId _itemId)
    {
        return InventTable::find(_itemId).isItemSerialNumberControlled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLessThanLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the remaining work quantity is less than the item quantity on license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// License plate of the items.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_workLine">
    /// Work line to be used to find remaining work quantity of the line.
    /// </param>
    /// <returns>
    /// true if the remaining work quantity is less than the item quantity on license plate.
    /// </returns>
    boolean isLessThanLicensePlate(WHSLicensePlateId    _licensePlateId,
                                   InventLocationId     _inventLocationId,
                                   WHSWorkLine          _workLine)
    {
        InventDimParm   inventDimParm;
        InventDim       inventDimCriteria;
        InventDim       inventDim;
        InventSum       inventSum;
        boolean         ret;

        ttsbegin;

        inventDimCriteria = _workLine.inventDim();
        inventDimCriteria.wmsLocationId = _workLine.wmsLocationId;
        inventDimCriteria.LicensePlateId = _licensePlateId;
        inventDimParm.initFromInventDim(inventDimCriteria);

        if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
        {
            select sum(PhysicalInvent) from inventSum
                where inventSum.ClosedQty == NoYes::No &&
                #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm);
        }
        else
        {
            select sum(PhysicalInvent) from inventSum
                where inventSum.ClosedQty == NoYes::No
                #InventDimExistsJoin(inventSum.inventDimId, inventDim, inventDimCriteria, inventDimParm);
        }

        if (inventSum && inventSum.PhysicalInvent > _workLine.InventQtyRemain)
        {
            ret = true;
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMoreThanLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the remaining work quantity is more than the item quantity on license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// License plate of the items.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_workLine">
    /// Work line to be used to find remaining work quantity of the line.
    /// </param>
    /// <returns>
    /// true if the remaining work quantity is more than the item quantity on license plate.
    /// </returns>
    boolean isMoreThanLicensePlate(WHSLicensePlateId    _licensePlateId,
                                   InventLocationId     _inventLocationId,
                                   WHSWorkLine          _workLine)
    {
        InventDimParm   inventDimParm;
        InventDim       inventDimCriteria;
        InventDim       inventDim;
        InventSum       inventSum;
        boolean         ret;

        ttsbegin;

        inventDimCriteria = _workLine.inventDim();
        inventDimCriteria.wmsLocationId = _workLine.wmsLocationId;
        inventDimCriteria.LicensePlateId = _licensePlateId;
        inventDimParm.initFromInventDim(inventDimCriteria);

        if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
        {
            select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSum
                group by ItemId
                where inventSum.ClosedQty == NoYes::No &&
                #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm);
        }
        else
        {
            select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSum
                group by ItemId
                where inventSum.ClosedQty == NoYes::No
                #InventDimExistsJoin(inventSum.inventDimId, inventDim, inventDimCriteria, inventDimParm);
        }

        if (inventSum)
        {
            InventHandlingQty handlingQty = PdsGlobal::pdsIsCWItem(inventSum.ItemId)
                                                ? inventSum.PdsCWPhysicalInvent
                                                : inventSum.PhysicalInvent;

            if (handlingQty < _workLine.InventQtyRemain)
            {
                ret = true;
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndValidateLicensePlateQuantityForWholeLicensePlateCheckCWEnabled</Name>
				<Source><![CDATA[
    private boolean findAndValidateLicensePlateQuantityForWholeLicensePlateCheckCWEnabled(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine,
        boolean             _allowLess)
    {
        InventHandlingQty   handlingQtyOnLicensePlate;
        InventDim           lpOnlyInventDim;
        InventDim           inventDim;
        InventDimParm       inventDimParm;

        lpOnlyInventDim.LicensePlateId = _licensePlateId;
        inventDimParm.initFromInventDim(lpOnlyInventDim);

        if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
        {
            boolean isWHSWorkExecuteLicensePlateValidationCWEnabledFlightEnabled = WHSWorkExecuteLicensePlateValidationCWEnabledFlight::instance().isEnabled();

            InventSumUnionDeltaPhysicalQty sumUnionDeltaPhysicalQty;

            while select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from sumUnionDeltaPhysicalQty
                group by sumUnionDeltaPhysicalQty.ItemId
                    #InventDimExistsJoin(sumUnionDeltaPhysicalQty.inventDimId, inventDim, lpOnlyInventDim, inventDimParm)
            {

                // if any other items are on the work line then this should return empty as it is not the whole license plate
                if (!isWHSWorkExecuteLicensePlateValidationCWEnabledFlightEnabled
                 && _workLine.ItemId != sumUnionDeltaPhysicalQty.ItemId)
                {
                    return false;
                }

                // if we find any other items we break, therefore the running handling quantity would only be calculated from one loop of the while select
                if (PdsGlobal::pdsIsCWItem(sumUnionDeltaPhysicalQty.ItemId))
                {
                    handlingQtyOnLicensePlate = sumUnionDeltaPhysicalQty.PdsCWPhysicalInvent;
                }
                else
                {
                    handlingQtyOnLicensePlate = sumUnionDeltaPhysicalQty.PhysicalInvent;
                }

                // if any other items are on the work line then this should return empty as it is not the whole license plate
                if (isWHSWorkExecuteLicensePlateValidationCWEnabledFlightEnabled
                 && handlingQtyOnLicensePlate != 0
                 && _workLine.ItemId != sumUnionDeltaPhysicalQty.ItemId)
                {
                    return false;
                }
            }
        }
        else
        {
            InventSum inventSum;

            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSum
                    group by inventSum.ItemId
                        where inventSum.ClosedQty == NoYes::No &&
                              inventSum.PhysicalInvent != 0 &&
                        #InventDimFieldsFilter(inventSum, lpOnlyInventDim, inventDimParm);
            }
            else
            {
                select sum(PhysicalInvent), sum(PdsCWPhysicalInvent), ItemId from inventSum
                    group by inventSum.ItemId
                        where inventSum.ClosedQty == NoYes::No &&
                              inventSum.PhysicalInvent != 0
                        #InventDimExistsJoin(inventSum.inventDimId, inventDim, lpOnlyInventDim, inventDimParm);
            }

            while (inventSum.ItemId)
            {
                // if any other items are on the work line then this should return empty as it is not the whole license plate
                if (_workLine.ItemId != inventSum.ItemId)
                {
                    return false;
                }

                // if we find any other items we break, therefore the running handling quantity would only be calculated from one loop of the while select
                if (PdsGlobal::pdsIsCWItem(inventSum.ItemId))
                {
                    handlingQtyOnLicensePlate = inventSum.PdsCWPhysicalInvent;
                }
                else
                {
                    handlingQtyOnLicensePlate = inventSum.PhysicalInvent;
                }

                next inventSum;
            }
        }

        boolean isWholeLicensePlate = this.isLicensePlateQuantityWholeLP(_licensePlateId,
                                            handlingQtyOnLicensePlate,
                                            _workLine,
                                            (handlingQtyOnLicensePlate > 0), // inventSum must have a value for the view to populate a value in the qty on license plate
                                            _allowLess);

        return isWholeLicensePlate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndValidateLicensePlateQuantityForWholeLicensePlateCheck</Name>
				<Source><![CDATA[
    private boolean findAndValidateLicensePlateQuantityForWholeLicensePlateCheck(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine,
        boolean             _allowLess)
    {
        InventDim       lpOnlyInventDim;
        InventDim       inventDim;
        InventDimParm   inventDimParm;

        lpOnlyInventDim.LicensePlateId = _licensePlateId;
        inventDimParm.initFromInventDim(lpOnlyInventDim);

        InventSum inventSum;

        if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
        {
            select sum(PhysicalInvent) from inventSum
                where inventSum.ClosedQty == NoYes::No &&
                    #InventDimFieldsFilter(inventSum, lpOnlyInventDim, inventDimParm);
        }
        else
        {
            select sum(PhysicalInvent) from inventSum
                where inventSum.ClosedQty == NoYes::No
                    #InventDimExistsJoin(inventSum.inventDimId, inventDim, lpOnlyInventDim, inventDimParm);
        }

        InventSumDelta inventSumDelta;

        if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
        {
            if (InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
            {
                select sum(PhysicalInvent) from inventSumDelta
                    where inventSumDelta.SQLTransactionId == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                        && #InventDimFieldsFilter(inventSumDelta, lpOnlyInventDim, inventDimParm);
            }
            else
            {
                select sum(PhysicalInvent) from inventSumDelta
                    where inventSumDelta.SQLTransactionId == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                    #InventDimExistsJoin(inventSumDelta.inventDimId, inventDim, lpOnlyInventDim, inventDimParm);
            }
        }

        InventQty qtyOnLicensePlate =  inventSum.PhysicalInvent + inventSumDelta.PhysicalInvent;

        boolean isWholeLicensePlate = this.isLicensePlateQuantityWholeLP(_licensePlateId,
                                            qtyOnLicensePlate,
                                            _workLine,
                                            (inventSum.PhysicalInvent != 0), // inventSum must have a value for the view to populate a value in the qty on license plate
                                            _allowLess);

        return isWholeLicensePlate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateQuantityWholeLP</Name>
				<Source><![CDATA[
    private boolean isLicensePlateQuantityWholeLP(
        WHSLicensePlateId   _licensePlateId,
        InventHandlingQty   _qtyOnLicensePlate,
        WHSWorkLine         _workLineToCompare,
        boolean             _licensePlateHasPhysicalInvent,
        boolean             _allowLess)
    {
        boolean ret;

        if ((_qtyOnLicensePlate && _qtyOnLicensePlate == _workLineToCompare.InventQtyRemain)
            ||  (_allowLess && _licensePlateHasPhysicalInvent
                && _qtyOnLicensePlate < _workLineToCompare.InventQtyRemain))
        {
            // Get full qty on plate for the required dimension criteria and item of the workLine.
            InventDim inventDimCriteria = _workLineToCompare.inventDimWithLocation();
            inventDimCriteria.LicensePlateId = _licensePlateId;

            if (WHSInventOnHand::onHandHandlingQty(_workLineToCompare.ItemId, InventDim::findOrCreate(inventDimCriteria).InventDimId) == _qtyOnLicensePlate)
            {
                ret = true;
            }
        }
        else if (_qtyOnLicensePlate 
                 && _qtyOnLicensePlate == _workLineToCompare.InventQtyWork)
        {
            InventDim inventDimCriteria = _workLineToCompare.inventDimWithLocation();
            inventDimCriteria.LicensePlateId = _licensePlateId;

            InventDim inventDimCriteriaWithoutLocation;

            inventDimCriteriaWithoutLocation = _workLineToCompare.inventDimWithLocation();
            inventDimCriteriaWithoutLocation.LicensePlateId = _licensePlateId;
            //Deleting location to fing onHand that can be on user location if LP got split between two locations because of confirmation setup
            inventDimCriteriaWithoutLocation.wmsLocationId = '';

            InventHandlingQty qtyOnWorkLineLocation = WHSInventOnHand::onHandHandlingQty(_workLineToCompare.ItemId, InventDim::findOrCreate(inventDimCriteria).InventDimId);

            if (qtyOnWorkLineLocation
                && qtyOnWorkLineLocation == _workLineToCompare.InventQtyRemain
                && WHSInventOnHand::onHandHandlingQty(_workLineToCompare.ItemId, InventDim::findOrCreate(inventDimCriteriaWithoutLocation).InventDimId) == _qtyOnLicensePlate)
            {
                ret = true;
            }
        }
        else if (_qtyOnLicensePlate
                 && _qtyOnLicensePlate > _workLineToCompare.InventQtyRemain
                 && this.makeWholeLpValidationAgainstMultipleSKU())
        {
            ret = this.isWholeLPQtyMultiSKU(_licensePlateId, _qtyOnLicensePlate, _workLineToCompare, _licensePlateHasPhysicalInvent, _allowLess);
        }
        else if (_qtyOnLicensePlate && _allowLess && _licensePlateHasPhysicalInvent && isGroupPickEnabled
                 && _qtyOnLicensePlate <= WHSGroupPickLineDetails::newForTotalGroupPickQty(_workLineToCompare).totalInventQty
                 && WHSWorkExecuteDifferentSOLineGroupPickWholeLPNotPromptTargetLPFlight::instance().isEnabled())
        {
            InventDim inventDimCriteria = _workLineToCompare.inventDimWithLocation();
            inventDimCriteria.LicensePlateId = _licensePlateId;
            
            InventQty handlingQty = WHSInventOnHand::onHandHandlingQty(_workLineToCompare.ItemId, InventDim::findOrCreate(inventDimCriteria).InventDimId);
            WHSGroupPickLineDetails groupPickLineDetails = WHSGroupPickLineDetails::newForTotalGroupPickQty(_workLineToCompare);

            if (handlingQty + groupPickLineDetails.pickedQty <= _qtyOnLicensePlate)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeWholeLpValidationAgainstMultipleSKU</Name>
				<Source><![CDATA[
    private boolean makeWholeLpValidationAgainstMultipleSKU()
    {
        WHSWholeLPQtyMultipleSKUValidationContext context = WHSWholeLPQtyMultipleSKUValidationContext::current();

        return (context 
                && context.implementMultipleSKUValidation 
                && WHSWorkExecuteHandleByLPCreateWorkDimTrackingV2Flight::instance().isEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWholeLPQtyMultiSKU</Name>
				<Source><![CDATA[
    private boolean isWholeLPQtyMultiSKU(WHSLicensePlateId   _licensePlateId,
                                         InventHandlingQty   _qtyOnLicensePlate,
                                         WHSWorkLine         _workLine,
                                         boolean             _licensePlateHasPhysicalInvent,
                                         boolean             _allowLess)
    {
        if (_workLine.WorkType != WHSWorkType::Pick)
        {
            return false;
        }

        LineNum nextPutWorkLineNum = WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType);
        LineNum prevPickBeforePutWorkLineNum = WHSWorkLine::getPrevOppositeWorkLine(_workLine.WorkId, nextPutWorkLineNum, WHSWorkType::Put).LineNum;
           
        if (nextPutWorkLineNum == 0
            || prevPickBeforePutWorkLineNum == _workLine.LineNum)
        {
            return false;
        }

        Query	    query	  = this.pickWorkLineHandleByLPQuery(_workLine.WorkId, nextPutWorkLineNum, _licensePlateId, false, true);
        QueryRun    queryRun = new QueryRun(query);
        WHSWorkLine skuWorkLine;
        InventQty   workLinesPickQty = 0;

        while (queryRun.next())
        {
            skuWorkLine = queryRun.get(tableNum(WHSWorkLine));
            workLinesPickQty += skuWorkLine.InventQtyRemain;
        }

        return (_qtyOnLicensePlate == workLinesPickQty
            || (_allowLess && _licensePlateHasPhysicalInvent
            && _qtyOnLicensePlate < workLinesPickQty));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWholeLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the license plate will be complete picked by the work line.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate to be evaluated.
    /// </param>
    /// <param name="_workLine">
    /// The work line being executed.
    /// </param>
    /// <param name="_allowLess">
    /// A Boolean that determines of the license plate qty must exactly match the work lines qty to be executed or if we allow it to be less.
    /// </param>
    /// <returns>
    /// true if the license plate's full qty will be picked by the work line; otherwise, false
    /// </returns>
    /// <remarks>
    /// Multi-sku pick work lines will always return true.
    /// Raw material staging pick work lines which are potentially overpicking will always return true.
    /// </remarks>
    public boolean isWholeLicensePlate(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine,
        boolean             _allowLess = false)
    {
        boolean ret;

        if (WHSPreventPickingWholeLPIfItHasNestedLPV2Flight::instance().isEnabled()
            && this.isWholeLPWithChildrenPreventedForWorkTransType(_licensePlateId, _workLine))
        {
            return false;
        }
        
        // This method does not support multisku pick
        if (!this.isItemEmptyOrIsPickStagedOverPick(_workLine))
        {
            if (!_licensePlateId)
            {
                return false;
            }

            if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
            {
                ret = this.findAndValidateLicensePlateQuantityForWholeLicensePlateCheckCWEnabled(_licensePlateId, _workLine, _allowLess);
            }
            else
            {
                ret = this.findAndValidateLicensePlateQuantityForWholeLicensePlateCheck(_licensePLateId, _workLine, _allowLess);
            }
        }
        else if (this.isWorkForInboundShipment(_workLine))
        {
            ret = this.isWorkForInboundShipmentFullLP(_licensePlateId, _workLine);
        }
        else
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkForInboundShipmentFullLP</Name>
				<Source><![CDATA[
    private boolean isWorkForInboundShipmentFullLP(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine)
    {
        InventHandlingQty qtyOnLP = WHSLicensePlate::getTotalHandlingQtyOnLicensePlate(_licensePlateId);
        return qtyOnLP <= _workLine.InventQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkForInboundShipment</Name>
				<Source><![CDATA[
    private boolean isWorkForInboundShipment(
        WHSWorkLine _workLine)
    {
        WHSWorkTransType workTransType = WHSWorkClassTable::findByWorkClassId(_workLine.WorkClassId).WorkTransType;
        return WhsWorkTransactionType::singletonFromTypeOrDefault(workTransType).isForInboundShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemEmptyOrIsPickStagedOverPick</Name>
				<Source><![CDATA[
    private boolean isItemEmptyOrIsPickStagedOverPick(
        WHSWorkLine _workLine)
    {
        return !_workLine.ItemId || WHSWorkExecute::isPotentialStagedOverPick(_workLine.whsWorkTable(), _workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWholeLPWithChildrenPreventedForWorkTransType</Name>
				<Source><![CDATA[
    private boolean isWholeLPWithChildrenPreventedForWorkTransType(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine)
    {
        WHSWorkClassTable workClass = WHSWorkClassTable::findByWorkClassId(_workLine.WorkClassId);
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(workClass.WorkTransType);
        
        if (workTransactionType.isWholeLPWithChildrenPrevented())
        {
            if (WHSLicensePlate::isParentLicensePlate(_licensePlateId))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPotentialStagedOverPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method determines if the raw material staging pick work line is potentially overpicking.
    /// </summary>
    /// <param name="_workTable">
    /// The current work table being executed.
    /// </param>
    /// <param name="_workLine">
    /// The current work line being executed.
    /// </param>
    /// <returns>
    /// true if it is potentially overpicking; otherwise false.
    /// </returns>
    public static boolean isPotentialStagedOverPick(WHSWorkTable _workTable, WHSWorkLine _workLine)
    {
        WHSWorkLine firstPickLine;

        if ((_workTable.WorkTransType == WHSWorkTransType::ProdPick
            ||   _workTable.WorkTransType == WHSWorkTransType::KanbanPick)
            &&   WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum)
            &&   WHSInventTable::find(_workLine.ItemId).AllowMaterialOverPick == WHSAllowMaterialOverPick::Staging)
        {
            select firstOnly firstPickLine
                order by LineNum asc
                where firstPickLine.WorkId      == _workLine.WorkId
                    && firstPickLine.WorkType   == WHSWorkType::Pick
                    && firstPickLine.WorkStatus != WHSWorkStatus::Skipped
                    && firstPickLine.WorkStatus != WHSWorkStatus::Cancelled;

            if (!firstPickLine.isTransferKanban())
            {
                return WMSLocation::find(firstPickLine.WMSLocationId, _workTable.InventLocationId).whsLocationIsLPControlled();
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPotentialStagedMultiSkuOverPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method determines if a raw material pick from a stage location is potentially overpicking.
    /// Handles both multi sku and single item picks.
    /// </summary>
    /// <param name = "_workTable">
    /// The current work table being executed.
    /// </param>
    /// <param name = "_workLine">
    /// The current work line being executed.
    /// </param>
    /// <returns>
    /// true if it is potentially overpicking; otherwise false.
    /// </returns>
    public static boolean isPotentialStagedMultiSkuOverPick(
        WHSWorkTable _workTable,
        WHSWorkLine	 _workLine)
    {
        if (_workLine.ItemId)
        {
            return WhsWorkExecute::isPotentialStagedOverPick(_workTable, _workLine);
        }
        else
        {
            if ((_workTable.WorkTransType == WHSWorkTransType::ProdPick
            ||   (_workTable.WorkTransType == WHSWorkTransType::KanbanPick
            &&    !_workLine.isTransferKanban()))
            &&	WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum))
            {
                WHSWorkLine initialPickLines;

                // Find if any of the initial picks were from an LP location and the item allows for over picking.
                while select ItemId, WMSLocationId, WorkType from initialPickLines
                    order by LineNum asc
                    where initialPickLines.WorkId	  == _workLine.WorkId
                    &&	  initialPickLines.WorkStatus != WHSWorkStatus::Skipped
                    &&	  initialPickLines.WorkStatus != WHSWorkStatus::Cancelled
                    &&	  (initialPickLines.WorkType  == WHSWorkType::Pick
                    ||	   initialPickLines.WorkType  == WHSWorkType::Put)
                {
                    if (initialPickLines.WorkType != WHSWorkType::Pick)
                    {
                        break;
                    }
                    else if (WHSInventTable::find(initialPickLines.ItemId).AllowMaterialOverPick == WHSAllowMaterialOverPick::Staging
                         &&	 WMSLocation::find(initialPickLines.WMSLocationId, _workTable.InventLocationId).whsLocationIsLPControlled())
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemIsDimTrackingControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which determines if dimension tracking records need to be created for an item when executing work
    /// </summary>
    /// <param name="_itemId">
    /// The itemId used to find the reservation hierarchy
    /// </param>
    /// <returns>
    /// true if dimension tracking records need to be created; otherwise false
    /// </returns>
    /// <remarks>
    /// If the item has dimensions below license plate in the reservation hierarchy then dimension tracking records are needed.
    /// </remarks>
    public boolean itemIsDimTrackingControlled(ItemId _itemId)
    {
        NoYes dimTrackingControlled = NoYes::No;
  
        if (itemIsDimTrackingControlledCache.exists(_itemId))
        {
            dimTrackingControlled = itemIsDimTrackingControlledCache.lookup(_itemId);
        }
        else
        {
            var reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
            List dimList = reservationHierarchyProvider.getDimListBelowLicensePlate(InventTable::find(_itemId), WHSReservationHierarchySortOrder::TopDown);

            if (dimList.elements() > 0)
            {
                dimTrackingControlled = NoYes::Yes;
            }

            itemIsDimTrackingControlledCache.insert(_itemId, dimTrackingControlled);
        }

        return dimTrackingControlled == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveLicensePlateWorkItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves inventory items from a license plate controlled pick location to user location.
    /// </summary>
    /// <param name="_workLine">
    /// Pick work line.
    /// </param>
    /// <param name="_licensePlateId">
    /// Id of the license plate of the picked items.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_capturedWeight">
    /// Weight captured for warehouse enabled catch weight items.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// Id of the target license plate of the picked items.
    /// </param>
    /// <param name="_overPicking">
    /// Determines whether the work line is being overpicked.
    /// </param>
    /// <param name="_overPickHandlingQty">
    /// The quantity being overpicked in the handling unit.
    /// </param>
    /// <param name="_assignSerial">
    /// Determines whether serial number should assigned before movement.
    /// </param>
    /// <returns>
    /// A container with the quantity and weight of the items that are moved. Weight is always zero for non-catch weight items.
    /// </returns>
    final protected container moveLicensePlateWorkItems(
        WHSWorkLine             _workLine,
        WHSLicensePlateId       _licensePlateId,
        WHSUserId               _userId,
        WHSTransWeight          _capturedWeight,
        WHSLicensePlateId       _targetLicensePlateId,
        boolean                 _overPicking,
        InventHandlingQty       _overPickHandlingQty,
        boolean                 _assignSerial)
    {
        if (_capturedWeight && !WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!_workLine.ItemId ? _capturedWeight : !WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _workLine.ItemId, _capturedWeight))
        {
            return this.moveLicensePlateWorkLineItems(_workLine,
                                                      _licensePlateId,
                                                      _userId,
                                                      _capturedWeight,
                                                      _targetLicensePlateId,
                                                      _overPicking,
                                                      _overPickHandlingQty,
                                                      _assignSerial);
        }

        return [this.moveLicensePlate(_workLine,
                                     _licensePlateId,
                                     _userId,
                                     _targetLicensePlateId,
                                     _overPicking,
                                     _assignSerial), 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMoveLicensePlateMultipleWorkInventTrans</Name>
				<Source><![CDATA[
    private InventHandlingQty isMoveLicensePlateMultipleWorkInventTrans(WHSWorkLine _workLine)
    {
        WHSWorkInventTrans  workInventTrans;

        select count(RecId) from workInventTrans
            where workInventTrans.WorkId    == _workLine.WorkId
                && workInventTrans.LineNum  == _workLine.LineNum;

        return (workInventTrans.RecId > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkInventTransWeight</Name>
				<Source><![CDATA[
    private void adjustWorkInventTransWeight(
        WHSWorkInventTrans  _workInventTrans,
        WHSTransWeight      _transWeight,
        PdsCWInventQTy      _cwQty)
    {
        ttsbegin;

        if (_workInventTrans.Qty == _cwQty &&  _workInventTrans.InventQtyRemain == _workInventTrans.Qty)
        {
            _workInventTrans.RemainingTransactionWeight = _transWeight;
        }
        else
        {
            // Increase remaining weight by the difference between the specified weight and the average weight of the cw quantity being moved
            _workInventTrans.RemainingTransactionWeight += _transWeight - WHSInvent::defaultCatchWeightReserveQuantity(_workInventTrans.ItemId, _cwQty);
        }

        if (_workInventTrans.orig().RemainingTransactionWeight != _workInventTrans.RemainingTransactionWeight)
        {
            _workInventTrans.update();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveLicensePlateWorkLineItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves inventory items from a license plate controlled pick location to user location.
    /// </summary>
    /// <param name="_workLine">
    /// Pick work line.
    /// </param>
    /// <param name="_licensePlateId">
    /// Id of the license plate of the picked items.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_capturedWeight">
    /// Weight captured for warehouse enabled catch weight items.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// Id of the target license plate of the picked items.
    /// </param>
    /// <param name="_overPicking">
    /// Determines whether the work line is being overpicked.
    /// </param>
    /// <param name="_overPickHandlingQty">
    /// The quantity being overpicked in the handling unit.
    /// </param>
    /// <param name="_assignSerial">
    /// Determines whether serial number should assigned before movement.
    /// </param>
    /// <returns>
    /// A container with the quantity and weight of the items that are moved. Weight is always zero for non-catch weight items.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the moveLicensePlateWorkItems method.
    /// </remarks>
    [Wrappable(true)]
    protected container moveLicensePlateWorkLineItems(
        WHSWorkLine             _workLine,
        WHSLicensePlateId       _licensePlateId,
        WHSUserId               _userId,
        WHSTransWeight          _capturedWeight,
        WHSLicensePlateId       _targetLicensePlateId,
        boolean                 _overPicking,
        InventHandlingQty       _overPickHandlingQty,
        boolean                 _assignSerial)
    {        
        using (var activityContext = this.instrumentationLogger().workExecuteActivities().moveLicensePlateWorkLineItems())
        {
            boolean isCWEnabled = WHSCatchWeightConfigurationKeyManager::instance().isEnabled(); // If warehouse catch weight enablement is on, additional commands must be ran to move license plates.

            InventHandlingQty qtySum;
            WHSTransWeight    weightSum;

            ttsbegin;

            // Find the next putaway or pick line, if there is one
            LineNum nextWorkLine = WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType);

            // Determine if multiple pick WITs exist, required for weight capturing
            boolean multiplePickWITs;

            if (isCWEnabled)
            {
                multiplePickWITs = this.isMoveLicensePlateMultipleWorkInventTrans(_workLine);
            }

            WHSTransWeight weightRemaining;
            WHSTransWeight capturedWeightAdjusted;

            // Loop over all inventory transactions for the workline
            WHSWorkInventTrans  workInventTrans;
            int                 workInventTransCount;

            while select forupdate workInventTrans
               where workInventTrans.WorkId           == _workLine.WorkId &&
                     workInventTrans.LineNum          == _workLine.LineNum &&
                     workInventTrans.InventQtyRemain != 0

            {
                workInventTransCount++;

                // determine if an item is cw enabled, even if the license is not turned on this should not be a costly check
                boolean isCWItem = PdsGlobal::pdsIsCWItem(workInventTrans.ItemId);

                //determine if variables for tracking captured weight needs to be kept or cleared
                if (!_capturedWeight)
                {
                    weightRemaining = 0;
                    capturedWeightAdjusted = 0;
                }

                // Build a merged InventDim with all above location dims as well as location and license plate
                InventDim mergedInventDim = InventDim::find(workInventTrans.InventDimIdFrom);
                mergedInventDim.LicensePlateId = _licensePlateId;
                mergedInventDim = InventDim::findOrCreate(mergedInventDim);

                // Build "To" inventDim overriding location and license plate if necessary
                InventDim inventDim = mergedInventDim.data();
                if (_targetLicensePlateId)
                {
                    inventDim.LicensePlateId = _targetLicensePlateId;
                }
                inventDim.wmsLocationId = _userId;
                inventDim = InventDim::findOrCreate(inventDim);
                InventDimId inventDimIdTo = inventDim.InventDimId;
   
                Qty qty = 0;
                WHSTransWeight transWeightToMove = 0;

                if (isCWItem
                && _capturedWeight
                && (_overPicking
                    || multiplePickWITs))
                {
                    // weightRemaining is set once the workline's demand has been processed
                    if (!weightRemaining)
                    {
                        // only move the proportional weight captured based on the amount we need for the current workline
                        capturedWeightAdjusted = WHSCatchWeightHelper::calculateAverageWeight(_workLine.InventQtyRemain, (_workLine.InventQtyRemain + _overPickHandlingQty), _capturedWeight, InventTable::inventDecimals(workInventTrans.ItemId));
                        weightRemaining = _capturedWeight - capturedWeightAdjusted;
                    }
                    else
                    {
                        // weightRemaining should be the weight we associated to the overpicked inventory
                        capturedWeightAdjusted = weightRemaining;
                    }
                }

                if ( !_assignSerial
                && this.itemIsDimTrackingControlled(workInventTrans.ItemId)
                && !this.skipAssignTrackingDim(_workLine, workInventTrans.InventTransIdParent))
                {
                    if (isCWItem)
                    {
                        WHSDimTracking      dimTrackingSum;
                        InventHandlingQty   totalDimHandlingQty;
 
                        while select sum(Qty), sum(CapturedWeight) from dimTrackingSum
                        group by InventDimId
                        where dimTrackingSum.WorkId                     == _workLine.WorkId
                            &&    dimTrackingSum.LineNum                == _workLine.LineNum
                            &&    dimTrackingSum.Processed              != NoYes::Yes
                            &&    dimTrackingSum.InventTransIdParent    == workInventTrans.InventTransIdParent
                        {
                            if (!InventDim::isInventDimEqualWHSNonWork(InventDim::find(dimTrackingSum.InventDimId), mergedInventDim, workInventTrans.ItemId))
                            {
                                continue;
                            }

                            if (dimTrackingSum.CapturedWeight)
                            {
                                transWeightToMove += dimTrackingSum.CapturedWeight;
                            }
                            else
                            {
                                // Calculate weight based off inventory values.
                                transWeightToMove += WHSCatchWeightHelper::calculateMovingWeight(workInventTrans.ItemId, dimTrackingSum.InventDimId, dimTrackingSum.Qty);
                            }
  
                            totalDimHandlingQty += dimTrackingSum.Qty;
                        }

                        this.adjustWorkInventTransWeight(workInventTrans, transWeightToMove, totalDimHandlingQty);
                    }

                    if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workLine.WorkId))
                    {
                        boolean isInitialPickLine = _workLine.isInitialPickLine();

                        WHSDimTracking dimTracking;
                        while select forupdate dimTracking
                        where dimTracking.WorkId					== _workLine.WorkId
                              && dimTracking.LineNum				== _workLine.LineNum
                              && dimTracking.Processed				== NoYes::No
                              && dimTracking.InventTransIdParent	== workInventTrans.InventTransIdParent
                        {
                            this.checkInventBatch(dimTracking.InventDimId, _workLine);

                            if (isInitialPickLine)
                            {
                                // follow the piece-by-piece logic for initial picks.
                                qty += WhsWorkExecute::processSingleDimTrackingRecord(
                                dimTracking,
                                workInventTrans,
                                inventDim.wmsLocationId,
                                _targetLicensePlateId);
                            }
                        }

                        if (!isInitialPickLine)
                        {
                            // for non-initial picks the item set should be ready - should be able to move all at once.
                            WHSInventoryTransactionWorkController::construct().moveFullItemSet(
                            workInventTrans,
                            mergedInventDim,
                            InventDim::find(inventDimIdTo));

                            update_recordset dimTracking
                            setting Processed = NoYes::Yes
                            where dimTracking.WorkId == workInventTrans.WorkId
                                && dimTracking.LineNum == workInventTrans.LineNum
                                && dimTracking.InventTransIdParent == workInventTrans.InventTransIdParent;

                            qty += workInventTrans.Qty;
                        }
                    }
                    else
                    {
                        WHSDimTracking dimTracking;
                        while select forupdate dimTracking
                        where dimTracking.WorkId					== _workLine.WorkId
                              && dimTracking.LineNum				== _workLine.LineNum
                              && dimTracking.Processed				== NoYes::No
                              && dimTracking.InventTransIdParent	== workInventTrans.InventTransIdParent
                        {
                            this.checkInventBatch(dimTracking.InventDimId, _workLine);

                            qty += WhsWorkExecute::processSingleDimTrackingRecord(dimTracking, workInventTrans, inventDim.wmsLocationId, _targetLicensePlateId);
                        }
                    }

                    if (qty == 0
                    && qtySum == 0)
                    {
                        throw error(strFmt("@WAX:QtyNotAvailableForItem", workInventTrans.ItemId));
                    }

                    if (qty)
                    {
                        this.createNextWorkInventTransQuantities(_workLine,
                            workInventTrans,
                            qty,
                            transWeightToMove,
                            nextWorkLine,
                            _userId,
                            _overPicking,
                            '');
                    }
                }
                else
                {
                    WHSTransWeight physicalInventWeight;

                    if (isCWEnabled)
                    {
                        [qty, physicalInventWeight] = whsInventOnHand::getPhysicalHandlingQuantities(workInventTrans.ItemId, mergedInventDim.InventDimId);
                
                        // when CW is enabled use the comparison of quantity to determine how captured weight should be found
                        if (qty > workInventTrans.InventQtyRemain)
                        {
                            qty = workInventTrans.InventQtyRemain;
                        }
                        else if (!capturedWeightAdjusted)
                        {
                            // if moving the full dimension set use the weight instead of the nominal calculation
                            capturedWeightAdjusted = physicalInventWeight;
                        }
                    }
                    else
                    {
                        qty = WHSInventOnHand::getWorkPhysicalInventHandlingQty(workInventTrans.ItemId, mergedInventDim.InventDimId);
                        qty = min(qty, workInventTrans.InventQtyRemain);
                    }


                    if (qty > 0)
                    {
                        InventDimId inventDimIdFrom = mergedInventDim.InventDimId;

                        this.checkInventBatch(inventDimIdFrom, _workLine);

                        if (_targetLicensePlateId)
                        {
                            WHSAgingDate agingDate = WHSLicensePlate::calculateAgingDateForMovement(_licensePlateId, mergedInventDim.wMSLocationId, mergedInventDim.InventLocationId, _targetLicensePlateId);
                            WHSLicensePlate::createLicensePlateWithAgingDate(_targetLicensePlateId, agingDate);
                        }

                        if (qty < workInventTrans.InventQtyRemain &&
                            InventDim::find(workInventTrans.InventDimIdTo).wMSLocationId != inventDim.wMSLocationId)
                        {
                            InventDim inventDimTo = InventDim::find(workInventTrans.InventDimIdTo);
                            inventDimTo.wMSLocationId = inventDim.wMSLocationId;
                            inventDimTo = InventDim::findOrCreate(inventDimTo);

                            InventQty   inventQty;
                            PdsCWQty    cwQty;

                            if (isCWItem)
                            {
                                inventQty = workInventTrans.TransactionWeight;
                                cwQty = workInventTrans.Qty;
                            }
                            else
                            {
                                inventQty = workInventTrans.Qty;
                                cwQty = 0;
                            }

                            WhsInvent::updateReceiptWorkTransactionDimensions(workInventTrans, inventDimTo.inventDimId, inventQty, cwQty);

                            workInventTrans.InventDimIdTo = inventDimTo.InventDimId;
                            workInventTrans.doUpdate();
                        }

                        if (!_assignSerial)
                        {
                            if (isCWitem)
                            {
                                // if executing staged pick, use the transaction weight
                                if (WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum))
                                {
                                    transWeightToMove = workInventTrans.RemainingTransactionWeight;
                                }
                                else
                                {
                                    if (capturedWeightAdjusted)
                                    {
                                        transWeightToMove = capturedWeightAdjusted;
                                    }
                                    else
                                    {
                                        // Calculate weight based off inventory values.
                                        transWeightToMove = WHSCatchWeightHelper::calculateMovingWeight(workInventTrans.ItemId, inventDimIdFrom, qty);
                                    }
                                }

                                // Account for calculation error in adjustWorkInventTransWeight method.
                                // In fact, increase remaininig weight by the different between the specified weight and onhand physical weight
                                WHSTransWeight transWeight = transWeightToMove;
                                if (WHSWorkTable::find(workInventTrans.WorkId).WorkTransType == WHSWorkTransType::Invent
                                    && (workInventTrans.Qty != qty
                                    || workInventTrans.Qty != workInventTrans.InventQtyRemain))
                                {
                                    transWeight += WHSInvent::defaultCatchWeightReserveQuantity(workInventTrans.ItemId, qty) - physicalInventWeight;
                                }

                                this.adjustWorkInventTransWeight(workInventTrans, transWeight, qty);

                                if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workLine.WorkId))
                                {
                                    if (_workLine.isInitialPickLine())
                                    {
                                        // initial pick.
                                        WHSInventoryTransactionWorkController::construct().moveSpecificQty(
                                        workInventTrans,
                                        InventDim::find(inventDimIdFrom),
                                        InventDim::find(inventDimIdTo),
                                        transWeightToMove,
                                        qty);
                                    }
                                    else
                                    {
                                        // for subsequent picks the item set should be already constructed.
                                        WHSInventoryTransactionWorkController::construct().moveFullItemSet(
                                        workInventTrans,
                                        InventDim::find(inventDimIdFrom),
                                        InventDim::find(inventDimIdTo));
                                    }
                                }
                                else
                                {
                                    WhsInvent::moveWorkQuantities(
                                    workInventTrans,
                                    inventDimIdFrom,
                                    inventDimIdTo,
                                    transWeightToMove,
                                    qty);
                                }
                            }
                            else
                            {
                                if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workLine.WorkId))
                                {
                                    if (_workLine.isInitialPickLine())
                                    {
                                        // initial pick.
                                        WHSInventoryTransactionWorkController::construct().moveSpecificQty(
                                        workInventTrans,
                                        InventDim::find(inventDimIdFrom),
                                        InventDim::find(inventDimIdTo),
                                        qty,
                                        0);
                                    }
                                    else
                                    {
                                        // for subsequent picks the item set should be already constructed.
                                        WHSInventoryTransactionWorkController::construct().moveFullItemSet(
                                        workInventTrans,
                                        InventDim::find(inventDimIdFrom),
                                        InventDim::find(inventDimIdTo));
                                    }
                                }
                                else
                                {
                                    WHSInvent::moveWorkQuantities(workInventTrans, inventDimIdFrom, inventDimIdTo, qty, 0);
                                }
                            }
                        }
                        else
                        {
                            WHSInvent::assignSerialMoveWorkQty(workInventTrans, inventDimIdFrom, inventDimIdTo);
                        }

                        this.createNextWorkInventTransQuantities(_workLine,
                            workInventTrans,
                            qty,
                            transWeightToMove,
                            nextWorkLine,
                            _userId,
                            _overPicking,
                            '');
                    }
                }

                if (this.mustUpdateTotalQuantity(_overPicking, _workLine, workInventTrans))
                {
                    qtySum += qty;
                    weightSum += transWeightToMove;
                }
            }

            ttscommit;

            activityContext.addCustomProperty('workInventTransCount', int2Str(workInventTransCount));

            return [qtySum, weightSum];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateTotalQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether quantity must be updated.
    /// </summary>
    /// <param name = "_overPicking">Determines whether it is over picked in the current work.</param>
    /// <param name = "_workLine">The current work line.</param>
    /// <param name = "_workInventTrans">The current work inventory transaction.</param>
    /// <returns>true if quantity must be updated; otherwise, false.</returns>
    protected boolean mustUpdateTotalQuantity(boolean _overPicking, WHSWorkLine _workLine, WHSWorkInventTrans _workInventTrans)
    {
        return !_overPicking
                || (_overPicking && _workLine.ExtraInventHandlingQty)
                || InventTrans::findTransId(_workInventTrans.InventTransIdParent).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipAssignTrackingDimOnLicensePlateMove</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean mustSkipAssignTrackingDimOnLicensePlateMove(WHSWorkTransType _workTransType)
    {
        return _workTransType == WHSWorkTransType::Purch
            || _workTransType == WHSWorkTransType::TransferReceipt
            || _workTransType == WHSWorkTransType::QualityItemSampling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipAssignTrackingDim</Name>
				<Source><![CDATA[
    private boolean skipAssignTrackingDim(WHSWorkLine _workLine, str _inventTransIdParent)
    {
        if (_workLine.WorkType != WHSWorkType::Pick)
        {
            return false;
        }

        boolean workTransTypeCanSkip = this.mustSkipAssignTrackingDimOnLicensePlateMove(WHSWorkTable::find(_workLine.WorkId).WorkTransType);

        if (!workTransTypeCanSkip)
        {
            return false;
        }
       
        WHSDimTracking dimTracking;
        select firstonly RecId, InventDimId from dimTracking
        where dimTracking.WorkId				== _workLine.WorkId
            && dimTracking.LineNum				== _workLine.LineNum
            && dimTracking.Processed			== NoYes::No
            && dimTracking.InventTransIdParent	== _inventTransIdParent;

        if (!this.skipAssignTrackingDimBasedOnDimTracking(dimTracking))
        {
            return false;
        }

        return this.skipAssignTrackingDimBasedOnBlankAllowed(_workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipAssignTrackingDimBasedOnDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if <c>WHSDimTracking</c> exists and has values
    /// </summary>
    /// <param name = "_dimTracking"><c>WHSDimTracking</c> record</param>
    /// <returns>True if <c>WHSDimTracking</c> doesn't exist and dim assignment can be skipped</returns>
    internal boolean skipAssignTrackingDimBasedOnDimTracking(WHSDimTracking   _dimTracking)
    {
        boolean ret = true;
        
        if (_dimTracking.InventDimId)
        {
            InventDim dimTrackingInventDim = InventDim::find(_dimTracking.InventDimId);

            if (dimTrackingInventDim.inventSerialId)
            {
                ret = false;
            }
        }

        if (ret && SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoRU]))
        {
            ret = this.skipAssignGTDBasedOnDimTracking_RU(_dimTracking);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipAssignGTDBasedOnDimTracking_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if GTD issignment can be skipped based on <c>WHSDimTracking</c> record
    /// </summary>
    /// <param name = "_dimTracking"><c>WHSDimTracking</c> record</param>
    /// <returns>True if can skip tracking dimension assignment</returns>
    internal boolean skipAssignGTDBasedOnDimTracking_RU(WHSDimTracking   _dimTracking)
    {
        return !(_dimTracking.InventDimId && InventDim::find(_dimTracking.InventDimId).InventGtdId_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipAssignTrackingDimBasedOnBlankAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if blank values are allowed and assignment can be skipped
    /// </summary>
    /// <param name = "_workLine"><c>WHSWorkLine</c> record</param>
    /// <returns>True, if blank allowed and dim assignment should be skipped</returns>
    internal boolean skipAssignTrackingDimBasedOnBlankAllowed(WHSWorkLine _workLine)
    {
        InventTable  inventTable = InventTable::find(_workLine.ItemId);
        EcoResTrackingDimensionGroupFldSetup trackingDimGroupFieldSetup = EcoResTrackingDimensionGroupFldSetup::findByDimensionGroupFieldId(inventTable.trackingDimensionGroup(), fieldNum(InventDim, InventSerialId));
        
        boolean ret = (inventTable.isItemSerialNumberActivated()
                        && !inventTable.isItemBatchActivated()
                        && trackingDimGroupFieldSetup.IsAllowBlankIssueEnabled
                        && trackingDimGroupFieldSetup.IsAllowBlankReceiptEnabled
                        && WHSInventTable::captureSerial(_workLine.ItemId) != WHSRFWhenToCapture::Receiving);

        if (!ret && SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoRU]))
        {
            ret = this.skipAssignGTDBasedOnBlankAllowed_RU(_workLine);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipAssignGTDBasedOnBlankAllowed_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if GTD assignment can be skipped based on blank values set up
    /// </summary>
    /// <param name = "_workLine"><c>WHSWorkLine</c> record</param>
    /// <returns>True if can skip tracking dimension assignment</returns>
    internal protected boolean skipAssignGTDBasedOnBlankAllowed_RU(WHSWorkLine _workLine)
    {
        return !InventTable::find(_workLine.ItemId).isItemBatchActivated()
                && WhsInvent::isGTDNumberOptional(_workLine.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves inventory items from a license plate controlled pick location to user location.
    /// </summary>
    /// <param name="_workLine">
    /// Pick work line.
    /// </param>
    /// <param name="_licensePlateId">
    /// Id of the license plate of the picked items.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// Id of the target license plate of the picked items.
    /// </param>
    /// <param name="_overPicking">
    /// Determines whether if the work is overpicking or not.
    /// </param>
    /// <param name="_assignSerial">
    /// Determines whether serial number should assigned before movement.
    /// </param>
    /// <returns>
    /// The quantity of the items that are moved.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the moveLicensePlateWorkItems method. Extenders should move their logic to wrap or override the moveLicensePlateWorkLineItems method.', false, 30\9\2019)]
    public Qty moveLicensePlate(
        WHSWorkLine            _workLine,
        WHSLicensePlateId      _licensePlateId,
        WHSUserId              _userId,
        WHSLicensePlateId      _targetLicensePlateId = '',
        boolean                _overPicking = false,
        boolean                _assignSerial = false)
    {
        if (_workLine.ItemId)
        {
            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workLine.ItemId);
        }

        return conPeek(this.moveLicensePlateWorkLineItems(_workLine,
                                                  _licensePlateId,
                                                  _userId,
                                                  0, // weight is not relevant for non-cw warehouse items
                                                  _targetLicensePlateId,
                                                  _overPicking,
                                                  0, // over picking quantity is not provided for non-cw warehouse items
                                                  _assignSerial), 1);

    }

]]></Source>
			</Method>
			<Method>
				<Name>changeWorkStatusAfterPick</Name>
				<Source><![CDATA[
    private void changeWorkStatusAfterPick(
        WHSWorkLine _previousLine,
        LineNum		_nextWorkLineNum,
        InventDimId	_workInventTransInventDimToId,
        InventQty   _transWeight)
    {
        WHSInventStatusId nextWorkLineInventStatusId = WHSWorkLine::find(_previousLine.WorkId, _nextWorkLineNum).inventDim().InventStatusId;
        WHSInventStatusId firstPickInventStatusId = _previousLine.inventDim().InventStatusId;

        if (nextWorkLineInventStatusId
            && firstPickInventStatusId
            && nextWorkLineInventStatusId != firstPickInventStatusId)
        {
            InventDim quarantineInventDim = InventDim::find(_workInventTransInventDimToId);
            quarantineInventDim.InventStatusId = nextWorkLineInventStatusId;

            // If picking from a non license plate location, the LP won't be on the dimension set,
            // but the inventory is on a user at this point so must be on an LP.
            if (!quarantineInventDim.LicensePlateId)
            {
                quarantineInventDim.LicensePlateId = _previousLine.whsWorkTable().TargetLicensePlateId;
            }

            // We expect always a license plate here since we pick to user location which is license plate controlled.
            WHSLicensePlateId originalLicensePlateId = quarantineInventDim.LicensePlateId;

            // In some cases the below location dimensions are removed from the inventDim stored in the workLine and
            // the related whsWorkInventTrans. One case where we need to remove the below location dimensions is when
            // we create movement work (WhsWorkCreateMovement.createTempTable()). So here we need to restore all below
            // location dimensions, as we are checking that they exist in InventUpd_Physical and InvnetUpd_Financial
            // by calling InventMovement.checkDimPhysical().
            this.restoreInventDimsBelowLocationFromWorkLine(quarantineInventDim, _previousLine);

            // We want to restore license plate since we may have picked part of the source LP on target LP.
            quarantineInventDim.LicensePlateId = originalLicensePlateId;

            quarantineInventDim = InventDim::findOrCreate(quarantineInventDim);

            this.createOrUpdateQuarantineWork(quarantineInventDim.wMSLocationId,
                                        quarantineInventDim,
                                        firstPickInventStatusId,
                                        _previousLine.ItemId,
                                        _previousLine.QtyWork,
                                        _previousLine.UnitId,
                                        false,
                                        false,
                                        '', _transWeight);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreInventDimsBelowLocationFromWorkLine</Name>
				<Source><![CDATA[
    private void restoreInventDimsBelowLocationFromWorkLine(
        InventDim   _inventDim,
        WHSWorkLine _whsWorkLine)
    {
        if (_whsWorkLine.ItemId)
        {
            WHSDimTracking whsDimTracking;
            InventDimId    whsDimTrackingInventDimid;

            while select InventDimId from whsDimTracking
                where whsDimTracking.WorkId  == _whsWorkLine.WorkId
                &&    whsDimTracking.LineNum == _whsWorkLine.LineNum
            {
                if (whsDimTrackingInventDimid)
                {
                    // We don't expect to get here.
                    var logger   = WHSInstrumentationLogger::createLogger(classStr(WhsWorkExecute));

                    logger.logError("Multiple whsDimTracking records for single workLine.");
                    logger.logRecordInformation(_whsWorkLine);

                    return;
                }

                whsDimTrackingInventDimId = whsDimTracking.InventDimId;
            }

            if (whsDimTrackingInventDimid)
            {
                InventDim inventDimWithBelowLocationDims = InventDim::find(whsDimTrackingInventDimid);

                List fieldsBelowLocation = WhsReservationHierarchyProvider::construct().getDimListBelowLocation(
                                                                InventTable::find(_whsWorkLine.ItemId),
                                                                WHSReservationHierarchySortOrder::TopDown);

                List fieldIdList = WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(fieldsBelowLocation);

                _inventDim.initFromInventDim(inventDimWithBelowLocationDims, fieldIdList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSingleDimTrackingRecord</Name>
				<Source><![CDATA[
    private static Qty processSingleDimTrackingRecord(
        WHSDimTracking		_dimTracking,
        WHSWorkInventTrans	_workInventTrans,
        WMSLocationId		_inventDimToWmsLocation,
        WHSLicensePlateId   _targetLicensePlateId	= '')
    {
        Qty qty;

        if (InventDim::isInventDimEqualWHSNonWork(InventDim::find(_dimTracking.InventDimId), InventDim::find(_workInventTrans.InventDimIdFrom), _workInventTrans.ItemId))
        {
            InventDimId trackingInventDimIdFrom = _dimTracking.InventDimId;

            InventDim trackingInventDimTo = InventDim::find(_dimTracking.InventDimId);
            trackingInventDimTo.wmsLocationId = _inventDimToWmsLocation;

            if (_targetLicensePlateId)
            {
                WHSLicensePlate::createLicensePlate(_targetLicensePlateId);
                trackingInventDimTo.LicensePlateId = _targetLicensePlateId;
            }

            trackingInventDimTo = InventDim::findOrCreate(trackingInventDimTo);


            if (PdsGlobal::pdsIsCWItem(_workInventTrans.ItemId))
            {
                WHSTransWeight transWeightToMove;

                if (_dimTracking.CapturedWeight)
                {
                    transWeightToMove = _dimTracking.CapturedWeight;
                }
                else
                {
                    // Calculate weight based off inventory values.
                    transWeightToMove = WHSCatchWeightHelper::calculateMovingWeight(_workInventTrans.ItemId, _dimTracking.InventDimId, _dimTracking.Qty);
                }

                WHSInvent::moveWorkQuantities(_workInventTrans, trackingInventDimIdFrom, trackingInventDimTo.InventDimId, transWeightToMove, _dimTracking.Qty);
            }
            else
            {
                WHSInvent::moveWorkQuantities(_workInventTrans, trackingInventDimIdFrom, trackingInventDimTo.InventDimId, _dimTracking.Qty, 0);
            }

            _dimTracking.Processed = NoYes::Yes;
            _dimTracking.update();

            qty = _dimTracking.Qty;
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyForLicensePlateAndMoveWorkQuantities</Name>
				<Source><![CDATA[
    private Qty getQtyForLicensePlateAndMoveWorkQuantities(
        WHSWorkInventTrans _workInventTrans,
        WHSUserId _userId,
        WHSLicensePlateId _childLicensePlateId,
        WHSContainerLine _containerLine = null)
    {
        Qty qty = 0;

        InventDim inventDimTo = InventDim::find(_workInventTrans.InventDimIdFrom);
        inventDimTo.LicensePlateId	= _childLicensePlateId;
        inventDimTo.wmsLocationId	= _userId;
        inventDimTo = InventDim::findOrCreate(inventDimTo);

        if (this.itemIsDimTrackingControlled(_workInventTrans.ItemId))
        {
            WHSDimTracking	dimTracking;
            InventDim		childLicensePlateInventDim;
            while select forupdate dimTracking
                        where dimTracking.WorkId                == _workInventTrans.WorkId
                            && dimTracking.LineNum              == _workInventTrans.LineNum
                            && dimTracking.Processed            == NoYes::No
                            && dimTracking.InventTransIdParent  == _workInventTrans.InventTransIdParent
                        exists join childLicensePlateInventDim
                            where childLicensePlateInventDim.InventDimId        == dimTracking.InventDimId
                                && childLicensePlateInventDim.LicensePlateId    == _childLicensePlateId
            {
                qty += WhsWorkExecute::processSingleDimTrackingRecord(dimTracking, _workInventTrans, inventDimTo.wmsLocationId);
            }
        }
        else
        {
            InventDim inventDimFrom = InventDim::find(_workInventTrans.InventDimIdFrom);
            inventDimFrom.LicensePlateId = _childLicensePlateId;
            inventDimFrom = InventDim::findOrCreate(inventDimFrom);

            qty = WHSInventOnHand::getWorkPhysicalInvent(_workInventTrans.ItemId, inventDimFrom.InventDimId);

            qty = min(qty, _workInventTrans.InventQtyRemain);
            if(_containerLine != null)
            {
                qty = min(qty, _containerLine.Qty);
            }

            if (qty > 0)
            {
                WHSInvent::moveWorkQuantities(_workInventTrans, inventDimFrom.InventDimId, inventDimTo.InventDimId, qty, 0);
            }
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateQtyOnChildLicensePlatesAndMoveWorkQuantities</Name>
				<Source><![CDATA[
    private Qty calculateQtyOnChildLicensePlatesAndMoveWorkQuantities(
        WHSWorkInventTrans _workInventTrans,
        WHSUserId _userId,
        WHSLicensePlateId _targetLicensePlateId)
    {
        Qty	qtyOnChildLicensePlates;
        WHSLicensePlate	childLicensePlate;
        WHSLoadLine loadLine;
        WHSContainerLine containerLine;

        while select LicensePlateId from childLicensePlate
            group by childLicensePlate.LicensePlateId
            where childLicensePlate.LicensePlateParent == _targetLicensePlateId
            join sum(Qty) from containerLine
                where containerLine.ContainerId == childLicensePlate.LicensePlateId
            exists join loadLine
                where loadLine.RecId == containerLine.LoadLine
                    && loadLine.InventTransId == _workInventTrans.InventTransIdParent
        {
            qtyOnChildLicensePlates += this.getQtyForLicensePlateAndMoveWorkQuantities(
                _workInventTrans,
                _userId,
                childLicensePlate.LicensePlateId,
                containerLine);
        }

        return qtyOnChildLicensePlates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveGroupedContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves containers grouped on a parent license plate to user location.
    /// </summary>
    /// <param name="_workLine">
    /// Pick work line for the grouped containers work.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// Id of the parent license plate for the grouped containers.
    /// </param>
    /// <returns>
    /// The quantity of the items that are moved.
    /// </returns>
    private Qty moveGroupedContainers(
        WHSWorkLine         _workLine,
        WHSUserId           _userId,
        WHSLicensePlateId   _targetLicensePlateId)
    {
        Qty qtySum;

        using (var activityContext = this.instrumentationLogger().workExecuteActivities().moveGroupedContainers())
        {
            LineNum nextWorkLine = WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType);
            
            WHSWorkInventTrans  workInventTrans;
            int workInventTransCount;

            while select forupdate workInventTrans
            where workInventTrans.WorkId    == _workLine.WorkId
                && workInventTrans.LineNum  == _workLine.LineNum
            {
                workInventTransCount++;

                // Currently creating work for grouped containers with catch weight items is blocked, so this should only be hit by custom code.
                if (PdsGlobal::pdsIsCWItem(workInventTrans.ItemId))
                {
                    throw error("@WAX:Error_ContainerGroupingNotSupportedForCWItems");
                }

                Qty qtyOnChildLicensePlates = this.calculateQtyOnChildLicensePlatesAndMoveWorkQuantities(workInventTrans, _userId, _targetLicensePlateId);

                if (qtyOnChildLicensePlates == 0)
                {
                    throw error(strFmt("@WAX:QtyNotAvailableForItem", workInventTrans.ItemId));
                }

                this.createNextWorkInventTransQuantities(_workLine,
                    workInventTrans,
                    qtyOnChildLicensePlates,
                    0, // warehouse enabled catch weight items are currently not supported for grouped containers
                    nextWorkLine,
                    _userId,
                    false,
                    '');

                qtySum += qtyOnChildLicensePlates;
            }

            // There could be some unprocessed WHSDimTracking records in a case there was a container with below location tracking dimensions items which was removed from the group.
            WHSDimTracking::deleteUnprocessedForWorkId(_workLine.WorkId);

            activityContext.addCustomProperty('workInventTransCount', int2Str(workInventTransCount));
        }

        return qtySum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustChangeWorkWithDiffFinalLocations</Name>
				<Source><![CDATA[
    private boolean mustChangeWorkWithDiffFinalLocations(
        InventQty           _remainingQtyOnLP,
        InventQty           _diffLocationQty,
        InventQty           _unallocatedQty,
        WHSLicensePlateId   _licensePlateId,
        InventDimId         _inventDimId)
    {
        boolean ret;

        if (_remainingQtyOnLP > _unallocatedQty)
        {
            ret = true;
        }

        if (!ret)
        {
            InventSum  inventSum;
            InventDim  workLineDim = InventDim::find(_inventDimId);
            
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                select firstonly RecId from inventSum
                where  inventSum.LicensePlateId   != _licensePlateId
                    && inventSum.LicensePlateId   != ''
                    && inventSum.InventLocationId == workLineDim.InventLocationId
                    && inventSum.wMSLocationId    == workLineDim.wMSLocationId
                    && inventSum.ClosedQty        == NoYes::No
                    && inventSum.PhysicalInvent   > 0;
            
                if (!inventSum.RecId)
                {
                    ret = true;
                }
            }
            else
            {
                InventDim  inventDim;

                select firstonly RecId from inventDim
                where  inventDim.LicensePlateId   != _licensePlateId
                    && inventDim.LicensePlateId   != ''
                    && inventDim.InventLocationId == workLineDim.InventLocationId
                    && inventDim.wMSLocationId    == workLineDim.wMSLocationId
                exists join inventSum
                    where  inventSum.InventDimId   == inventDim.inventDimId
                        && inventSum.ClosedQty     == NoYes::No
                        && inventSum.PhysicalInvent > 0;
            
                if (!inventDim.RecId)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndFreezeRawMaterialPickWork</Name>
				<Source><![CDATA[
    private Qty findAndFreezeRawMaterialPickWork(
        InventHandlingQty   _runningQty,
        WHSTransWeight      _capturedWeight,
        ItemId              _itemId,
        InventDimId         _inventDimId,
        WHSWorkLine         _workLine,
        WMSLocationId       _finalLocationId,
        WHSWorkTransType    _workTransType,
        boolean             _equalOrderNum,
        boolean             _updateDiffLocationWork,
        Map                 _diffLocationWorkMap)
    {
        WHSWorkInventTrans  workInventTrans;
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;
        InventHandlingQty   runningQty = _runningQty;
        WHSCapturedWeight   capturedWeightRemaining = _capturedWeight;

        if (runningQty > 0)
        {
            // First check raw material picking work for the same order
            while select forupdate workTable
                order by workInventTrans.Qty
                where ((   workTable.WorkStatus   == WHSWorkStatus::InProcess)
                        || workTable.WorkStatus   == WHSWorkStatus::Open)
                      && workTable.WorkTransType  == _workTransType
                join workLine
                    where  workLine.WorkId    == workTable.WorkId
                        && workLine.WorkStatus == WHSWorkStatus::Open  //If work has InProgress status, then need to check only open lines
                        && !(workLine.WorkId  == _workLine.WorkId
                        &&   workLine.LineNum == _workLine.LineNum)
                        && ((_equalOrderNum && workline.OrderNum  == _workline.OrderNum)
                        ||  (!_equalOrderNum && workline.OrderNum != _workline.OrderNum))
                join workInventTrans
                    where  workInventTrans.WorkId          == workLine.WorkId
                        && workInventTrans.LineNum         == workLine.LineNum
                        && workInventTrans.InventDimIdFrom == _inventDimId
                        && workInventTrans.ItemId          == _itemId
                        && workInventTrans.Qty              > 0
            {
                if (workTable.getFinalPutLocation() == _finalLocationId)
                {
                    InventHandlingQty qtyToProcess = min(workInventTrans.Qty, runningQty);
                    WHSTransWeight weightToFreeze;

                    if (capturedWeightRemaining) // if no weightprovided, then freeze at nominal
                    {
                        weightToFreeze = WHSCatchWeightHelper::calculateAverageWeight(qtyToProcess, (runningQty + _workLine.InventQtyRemain), capturedWeightRemaining);
                        weightToFreeze = decRound(weightToFreeze, InventTable::inventDecimals(workInventTrans.ItemId));
                        capturedWeightRemaining -= weightToFreeze;
                    }
                    else
                    {
                        weightToFreeze = PdsCatchWeight::inventQty(workInventTrans.ItemId,
                                                                qtyToProcess,
                                                                '',
                                                                PdsCatchWeightItem::find(workInventTrans.ItemId).PdsCWUnitId);
                    }

                    this.overPickFreezeWork(_workLine.WorkId, workLine, runningQty, workInventTrans.Qty, weightToFreeze);

                    runningQty -= workInventTrans.Qty;
                }
                else if (_updateDiffLocationWork)
                {
                    _diffLocationWorkMap.insert(workInventTrans.RecId, workInventTrans.Qty);
                }
                                
                if (runningQty <= 0)
                {
                    break;
                }
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freezeDiffLocationWork</Name>
				<Source><![CDATA[
    private void freezeDiffLocationWork(
        WHSWorkLine _workLine,
        Qty         _runningQty,
        Map         _diffLocationWorkMap)
    {
        MapEnumerator me = _diffLocationWorkMap.getEnumerator();
        Qty           runningQty = _runningQty;

        ttsbegin;

        while (runningQty > 0
        &&     me.moveNext())
        {
            WHSWorkInventTrans workInventTrans = WHSWorkInventTrans::findByRecId(me.currentKey(), true);
            WHSWorkLine        workLine		  = WHSWorkLine::find(workInventTrans.WorkId, workInventTrans.LineNum);
            WHSWorkTable       workTable	  = WHSWorkTable::find(workLine.WorkId, true);
            InventHandlingQty  cancelQuantity = min(runningQty, workInventTrans.Qty);

            runningQty -= cancelQuantity;
            
            WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(workTable.WorkId).tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedOverPickWork);
            
            WHSWorkFrozen::createFrozenWorkQuantities(_workLine.WorkId, workTable.WorkId, workLine.InventTransId, workLine.InventDimId, cancelQuantity, workInventTrans.TransactionWeight);

            // This could be 0 quantity, but want to avoid deleting, because will find work line from WIT after overpick work is closed.
            workInventTrans.Qty -= cancelQuantity;
            workInventTrans.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overPickQuantitiesByItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Over picks items from other lines in the same order/different orders if they have the same final put location with the current work line.
    /// </summary>
    /// <param name="_workLine">
    /// Over picking work line.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions of the inventory item in the work line.
    /// </param>
    /// <param name="_itemId">
    /// Inventory item id.
    /// </param>
    /// <param name="_additionalQty">
    /// Additional quantity in the handling unit needed to be overpicked.
    /// </param>
    /// <param name="_transWeight">
    /// Weight needing to be overpicked.
    /// </param>
    /// <param name="_workTransType">
    /// The work transaction type.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate ID: optional.
    /// </param>
    /// <returns>
    /// true if successfully over picked items, false otherwise.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when there is not enough unallocated quantity for the item to over pick.
    /// </exception>
    [Hookable(false)]
    final public boolean overPickQuantitiesByItem(
        WHSWorkLine         _workLine,
        InventDimId         _inventDimId,
        ItemId              _itemId,
        InventHandlingQty   _additionalQty,
        WHSTransWeight      _transWeight,
        WHSWorkTransType    _workTransType,
        WHSLicensePlateId   _licensePlateId)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _itemId, _transWeight))
        {
            return this.overPickByItemQuantities(_workLine,
                        _inventDimId,
                        _itemId,
                        _additionalQty,
                        _transWeight,
                        _workTransType,
                        _licensePlateId);
        }

        return this.overPickByItem(_workLine,
                        _inventDimId,
                        _itemId,
                        _additionalQty,
                        _workTransType,
                        _licensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>overPickByItemQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Over picks items from other lines in the same order/different orders if they have the same final put location with the current work line.
    /// </summary>
    /// <param name="_workLine">
    /// Over picking work line.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions of the inventory item in the work line.
    /// </param>
    /// <param name="_itemId">
    /// Inventory item id.
    /// </param>
    /// <param name="_additionalQty">
    /// Additional quantity in the handling unit needed to be overpicked.
    /// </param>
    /// <param name="_transWeight">
    /// Weight needing to be overpicked.
    /// </param>
    /// <param name="_workTransType">
    /// The work transaction type.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate ID: optional.
    /// </param>
    /// <returns>
    /// true if successfully over picked items, false otherwise.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when there is not enough unallocated quantity for the item to over pick.
    /// </exception>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the overPickQuantitiesByItem method.
    /// </remarks>
    [Wrappable(true)]
    protected boolean overPickByItemQuantities(
        WHSWorkLine         _workLine,
        InventDimId         _inventDimId,
        ItemId              _itemId,
        InventHandlingQty   _additionalQty,
        WHSTransWeight      _transWeight,
        WHSWorkTransType    _workTransType,
        WHSLicensePlateId   _licensePlateId)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _itemId, _additionalQty, _transWeight);
        
        Qty matchLocationWorkQty;
        Qty diffLocationWorkQty;

        ttsbegin;

        InventHandlingQty runningQty = _additionalQty;
        InventHandlingQty unallocatedQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(_itemId, _inventDimId, true);

        WMSLocationId finalLocationId = _workLine.whsWorkTable().getFinalPutLocation();

        // Find the amount of qty we will be able to decrement from other work (frozen work)
        [matchLocationWorkQty, diffLocationWorkQty] = this.overPickQtyToFreeze(_inventDimId, _itemId, _workLine, _workTransType, finalLocationId);

        if (matchLocationWorkQty + diffLocationWorkQty + unallocatedQty < _additionalQty)
        {
            throw error("@WAX3502");
        }

        boolean updateDiffLocationWork;

        // See if some of the additional picked qty will need to be used by other input location work.
        if (runningQty > matchLocationWorkQty
            &&  diffLocationWorkQty)
        {
            updateDiffLocationWork = this.mustChangeWorkWithDiffFinalLocations((runningQty - matchLocationWorkQty),
                                                                               diffLocationWorkQty,
                                                                               unallocatedQty,
                                                                               _licensePlateId,
                                                                               _inventDimId);
        }

        Map diffLocationWorkMap = new Map(Types::Int64, Types::Real);

        // First check raw material picking work for the same order
        runningQty = this.findAndFreezeRawMaterialPickWork(runningQty,
                            _transWeight,
                            _itemId,
                            _inventDimId,
                            _workLine,
                            finalLocationId,
                            _workTransType,
                            true,
                            updateDiffLocationWork,
                            diffLocationWorkMap);

        // Check again for work pointed to the same location but not on the same order
        runningQty = this.findAndFreezeRawMaterialPickWork(runningQty,
                            _transWeight,
                            _itemId,
                            _inventDimId,
                            _workLine,
                            finalLocationId,
                            _workTransType,
                            false,
                            updateDiffLocationWork,
                            diffLocationWorkMap);

        if (runningQty > 0
            &&  diffLocationWorkMap.elements() > 0)
        {
            this.freezeDiffLocationWork(_workLine, runningQty, diffLocationWorkMap);
        }

        this.createOverPickWorkInventTrans(_workLine, _itemId, _additionalQty);

        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overPickByItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Over picks items from other lines in the same order/different orders if they have the same final put location with the current work line.
    /// </summary>
    /// <param name="_workLine">
    /// Over picking work line.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions of the inventory item in the work line.
    /// </param>
    /// <param name="_itemId">
    /// Inventory item id.
    /// </param>
    /// <param name="_additionalQty">
    /// Additional quantity needed to be overpicked.
    /// </param>
    /// <param name="_workTransType">
    /// The work transaction type.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate ID: optional.
    /// </param>
    /// <returns>
    /// true if successfully over picked items, false otherwise.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when there is not enough unallocated quantity for the item to over pick.
    /// </exception>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the overPickQuantitiesByItem method. Extenders should move their logic to wrap or override the overPickByItemQuantities method.', false, 30\9\2019)]
    boolean overPickByItem(
        WHSWorkLine         _workLine,
        InventDimId         _inventDimId,
        ItemId              _itemId,
        Qty                 _additionalQty,
        WHSWorkTransType    _workTransType,
        WHSLicensePlateId   _licensePlateId = '')
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId);

        return this.overPickByItemQuantities(_workLine,
                    _inventDimId,
                    _itemId,
                    _additionalQty,
                    0, // Weight has no value for non-cw enabled warehouse items
                    _workTransType,
                    _licensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOverPickWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates over-pick WHS work inventory transaction.
    /// </summary>
    /// <param name="_workLine">
    /// Over picking work line.
    /// </param>
    /// <param name="_itemId">
    /// Inventory item id.
    /// </param>
    /// <param name="_additionalQty">
    /// Additional quantity needed to be overpicked.
    /// </param>
    [Replaceable]
    protected void createOverPickWorkInventTrans(
        WHSWorkLine     _workLine,
        ItemId          _itemId,
        Qty             _additionalQty)
    {
        WHSWorkInventTrans workInventTransNew;

        workInventTransNew.initFromWorkLine(_workLine);
        workInventTransNew.ItemId = _itemId;
        workInventTransNew.Qty = _additionalQty;
        workInventTransNew.InventQtyRemain = _additionalQty;
        workInventTransNew.InventTransIdParent = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();

        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            workInventTransNew.TransactionWeight            = WhsInvent::defaultCatchWeightReserveQuantity(_itemId, _additionalQty);
            workInventTransNew.RemainingTransactionWeight   = workInventTransNew.TransactionWeight;
        }

        workInventTransNew.insert();

        this.updateOverPickedRawMaterialInventDimParentReference(_workLine, _itemId, workInventTransNew.InventTransIdParent, _additionalQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOverPickedRawMaterialInventDimParentReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates raw material over picked quantity with the correct <c>InventTransIdParent</c> record when capturing during pick.
    /// </summary>
    /// <param name="_workLine">Over picking work line.</param>
    /// <param name="_itemId">Inventory item id.</param>
    /// <param name="_workInventTransParentId">A reference to the WHS work item parent transaction.</param>
    /// <param name="_additionalQty">Additional quantity needed to be overpicked.</param>
    private void updateOverPickedRawMaterialInventDimParentReference(
        WHSWorkLine         _workLine,
        ItemId              _itemId,
        InventTransId       _workInventTransParentId,
        Qty                 _additionalQty)
    {
        if (WHSInventTable::captureSerial(_workLine.ItemId) == WHSRFWhenToCapture::Picking)
        {
            WHSWorkInventTrans workInventTrans;

            select firstonly InventTransIdParent from workInventTrans
                where workInventTrans.WorkId                == _workLine.WorkId
                    && workInventTrans.LineNum              == _workLine.LineNum
                    && workInventTrans.InventTransIdParent  != _workInventTransParentId;

            InventTransId originalInventTransParent = workInventTrans.InventTransIdParent;

            Qty modifyQty = _additionalQty;
            WHSDimTracking dimTracking;

            while select forUpdate dimTracking
                where dimTracking.WorkId                == _workLine.WorkId
                    && dimTracking.LineNum              == _workLine.LineNum
                    && dimTracking.InventTransIdParent  == originalInventTransParent
            {
                dimTracking.InventTransIdParent = _workInventTransParentId;
                dimTracking.update();

                --modifyQty;

                // Only need to update the over picked quantity, not the full license plate
                if (modifyQty == 0)
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>overPickDecrementFrozenWorkLines</Name>
				<Source><![CDATA[
    private void overPickDecrementFrozenWorkLines(
        WHSWorkId   _workId,
        ItemId      _itemId,
        InventQty   _inventQty)
    {
        WHSWorkLine frozenWorkLine;
        Qty         tmpWorkQty;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        ttsbegin;

        while select forupdate frozenWorkLine
            where frozenWorkLine.WorkId == _workId
        {
            frozenWorkLine.InventQtyWork    = _inventQty;
            frozenWorkLine.InventQtyRemain  = _inventQty;
            tmpWorkQty = releasedProductUnitConverter.convert(_inventQty,
                                                            UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(_itemId).inventUnitId()),
                                                            UnitOfMeasure::unitOfMeasureIdBySymbol(frozenWorkLine.UnitId),
                                                            NoYes::No,
                                                              _itemId,
                                                              frozenWorkLine.InventDimId,
                                                            NoYes::No);
            frozenWorkLine.QtyWork      = tmpWorkQty;
            frozenWorkLine.QtyRemain    = tmpWorkQty;
            frozenWorkLine.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overPickFreezeWork</Name>
				<Source><![CDATA[
    private void overPickFreezeWork(
        WHSWorkId       _overPickWorkId,
        WHSWorkLine     _workLine,
        Qty             _runningQty,
        Qty             _workInventTransQty,
        WHSTransWeight  _weightToFreeze)
    {
        ttsbegin;

        // Only not current work can be frozen.
        if (_workLine.WorkId != _overPickWorkId)
        {
            WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(_workLine.WorkId).tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedOverPickWork);
        }

        InventQty cancelQuantity = min(_runningQty, _workInventTransQty);

        WHSWorkFrozen::findAndWriteFrozenWorkQuantities(_overPickWorkId,
                        _workLine.WorkId,
                        _workLine.InventTransId,
                        _workLine.InventDimId,
                        cancelQuantity,
                        _weightToFreeze);

        // Only cancel the quantity that was just frozen, as there could have been an existing work frozen record that the qty was added too.
        WHSWorkLine::cancelLine(_workLine.WorkId, _workLine.LineNum, cancelQuantity, _workLine.ItemId, false, false);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOverPickQuantityToFreezeQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for over pick quantity to freeze.
    /// </summary>
    /// <param name = "_workInventTrans">The work inventory transaction record.</param>
    /// <param name = "_workTable">The work header record.</param>
    /// <param name = "_itemId">The item number.</param>
    /// <param name = "_inventDimId">The inventory dimension.</param>
    /// <param name = "_workLine">The work line record that should be excluded from the query.</param>
    /// <param name = "_workTransType">The work transaction type.</param>
    /// <returns>The query object to be executed.</returns>
    /// <remarks>
    /// Fields selected for tables:
    /// - WHSWorkInventTrans : InventQtyRemain
    /// - WHSWorkTable : All, table used late in getFinalPutLocation
    /// - WHSWorkLine : WorkId
    /// </remarks>
    protected SysDaQueryObject buildOverPickQuantityToFreezeQuery(
        WHSWorkInventTrans  _workInventTrans,
        WHSWorkTable        _workTable,
        ItemId              _itemId,
        InventDimId         _inventDimId,
        WHSWorkLine         _workLine,
        WHSWorkTransType    _workTransType)
    {
        SysDaQueryObject workInventTransQueryObject = new SysDaQueryObject(_workInventTrans);
        workInventTransQueryObject.projection().add(fieldStr(WHSWorkInventTrans, InventQtyRemain));
        workInventTransQueryObject.whereClause(
                 new SysDaEqualsExpression(new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, ItemId)), new SysDaValueExpression(_itemId))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, InventDimIdFrom)), new SysDaValueExpression(_inventDimId))));
        
        SysDaQueryObject workTableQueryObject = new SysDaQueryObject(_workTable);
        workTableQueryObject.whereClause(
                 new SysDaEqualsExpression(new SysDaFieldExpression(_workTable, fieldStr(WHSWorkTable, WorkId)), new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, WorkId)))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(_workTable, fieldStr(WHSWorkTable, WorkTransType)), new SysDaValueExpression(_workTransType)))
            .and(new SysDaLessThanExpression(new SysDaFieldExpression(_workTable, fieldStr(WHSWorkTable, WorkStatus)), new SysDaValueExpression(WHSWorkStatus::Closed))));
        
        WHSWorkLine workLine;
        SysDaQueryObject workLineQueryObject = new SysDaQueryObject(workLine);
        workLineQueryObject.projection().add(fieldStr(WHSWorkLine, WorkId));
        workLineQueryObject.whereClause(
                 new SysDaEqualsExpression(new SysDaFieldExpression(workLine, fieldStr(WHSWorkLine, WorkId)), new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, WorkId)))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(workLine, fieldStr(WHSWorkLine, LineNum)), new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, LineNum))))
            .and(new SysDaLessThanExpression(new SysDaFieldExpression(workLine, fieldStr(WHSWorkLine, WorkStatus)), new SysDaValueExpression(WHSWorkStatus::InProcess)))
            .and(   new SysDaNotEqualsExpression(new SysDaFieldExpression(workLine, fieldStr(WHSWorkLine, WorkId)), new SysDaValueExpression(_workLine.WorkId))
                .or(new SysDaNotEqualsExpression(new SysDaFieldExpression(workLine, fieldStr(WHSWorkLine, LineNum)), new SysDaValueExpression(_workLine.LineNum)))));

        workInventTransQueryObject.joinClause(SysDaJoinKind::InnerJoin, workTableQueryObject);
        workTableQueryObject.joinClause(SysDaJoinKind::ExistsJoin, workLineQueryObject);

        return workInventTransQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overPickQtyToFreeze</Name>
				<Source><![CDATA[
    private container overPickQtyToFreeze(
        InventDimId         _inventDimId,
        ItemId              _itemId,
        WHSWorkLine         _workLine,
        WHSWorkTransType    _workTransType,
        WMSLocationId       _finalLocation)
    {
        WHSWorkInventTrans  workInventTrans;
        WHSWorkTable        workTable;
        InventQty           matchLocationQty;
        InventQty           diffLocationQty;
        
        SysDaSearchObject searchObject = new SysDaSearchObject(
            this.buildOverPickQuantityToFreezeQuery(workInventTrans, workTable, _itemId, _inventDimId, _workLine, _workTransType));
        SysDaSearchStatement statement = new SysDaSearchStatement();
        while (statement.next(searchObject))
        {
            if (workTable.getFinalPutLocation() == _finalLocation)
            {
                matchLocationQty += workInventTrans.InventQtyRemain;
            }
            else
            {
                diffLocationQty += workInventTrans.InventQtyRemain;
            }
        }

        return [matchLocationQty, diffLocationQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>overrideGroupPutaway</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the group putaway location.
    /// </summary>
    /// <param name="_workGroupingId">
    /// The ID of grouped work.
    /// </param>
    /// <param name="_locationId">
    /// The location for override.
    /// </param>
    /// <param name="_userId">
    /// The associated user ID.
    /// </param>
    /// <param name="_workId">
    /// The associated work ID.
    /// </param>
    /// <param name="_lineNum">
    /// The associated line number.
    /// </param>
    public void overrideGroupPutaway(
                        WHSWorkGroupingId   _workGroupingId,
                        WMSLocationId       _locationId,
                        UserId              _userId,
                        WHSWorkId           _workId,
                        LineNum             _lineNum)
    {
        WHSWorkGrouping     workGrouping;
        WHSWorkLine         overrideWorkLine;

        if (_workGroupingId)
        {
            while select WorkId from workGrouping
                where workGrouping.WorkGroupingId == _workGroupingId
            {
                WHSWorkLine firstWorkLine = this.getFirstOpenLine(workGrouping.WorkId, _userId);

                // Need to change all put lines on this work, up to the next pick
                while select overrideWorkLine
                    order by LineNum asc
                    where overrideWorkLine.WorkId   == firstWorkLine.WorkId
                        && overrideWorkLine.LineNum  >= firstWorkLine.LineNum
                {
                    if (overrideWorkLine.WorkType == WHSWorkType::Pick)
                    {
                        break;
                    }

                    this.updateWorkLineLocation(overrideWorkLine.WorkId, overrideWorkLine.LineNum, _locationId, _userId);
                }
            }
        }
        else
        {
            while select overrideWorkLine
                where overrideWorkLine.WorkId   == _workId
                    && overrideWorkLine.LineNum  >= _lineNum
                    && overrideWorkLine.WorkType == WHSWorkType::Put
            {
                this.updateWorkLineLocation(_workId, overrideWorkLine.LineNum, _locationId, _userId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>overrideClusterPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides cluster put for putaway clusters.
    /// </summary>
    /// <param name="_clusterId">
    /// The ID of the cluster we are overriding.
    /// </param>
    /// <param name="_locationId">
    /// The new location to be stamped on the clustered put work lines.
    /// </param>
    /// <param name="_workLine">
    /// An existing put work line in the cluster.
    /// </param>
    /// <param name="_userId">
    /// The mobile device user executing the override.
    /// </param>
    [Hookable(false)]
    internal void overrideClusterPut(
        WHSClusterId    _clusterId,
        WMSLocationId   _locationId,
        WHSWorkLine     _workLine,
        WHSUserId       _userId)
    {
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         workLine;
    
        ttsBegin;
    
        while select WorkId, LineNum from workLine
            where workLine.WorkType == WHSWorkType::Put
                && workLine.WMSLocationId == _workLine.WMSLocationId
                && workLine.InventQtyRemain != 0
            exists join workClusterLine
                where workClusterLine.WorkId == workLine.WorkId
                    && workClusterLine.ClusterId == _clusterId
        {
            this.updateWorkLineLocation(workLine.WorkId, workLine.LineNum, _locationId, _userId);
        }
    
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overridePartialPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new work line for the remaining quantity in the work line after partial pick.
    /// Adjusts the work quantity of the current work line to the partial pick quantity and sets it closed.
    /// Work inventory transaction records are also overridden to show the changes.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the partially picked work line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the partially picked work line.
    /// </param>
    /// <param name="_locationId">
    /// WMS location of the partially picked items.
    /// </param>
    void overridePartialPick(WHSWorkId      _workId,
                             LineNum        _lineNum,
                             WMSLocationId  _locationId)
    {
        WHSWorkInventTrans  workInventTrans;
        WHSWorkInventTrans  newWorkInventTrans;
        WHSWorkLine         newWorkLine;
        WHSWorkLine         workLine;

        ttsbegin;

        // Modify the partially picked workLine and workInventTrans
        select firstonly forupdate workLine
            where workLine.WorkId       == _workId  &&
                  workLine.LineNum      == _lineNum;

        select firstonly forupdate workInventTrans
            where workInventTrans.WorkId    == _workId  &&
                    workInventTrans.LineNum   == _lineNum &&
                    workInventTrans.InventQtyRemain != 0;

        buf2Buf(workLine, newWorkLine);
        buf2Buf(workInventTrans, newWorkInventTrans);

        InventDim inventDim = InventDim::find(workInventTrans.InventDimIdFrom);

        InventHandlingQty inventHandlingQty = workInventTrans.InventQtyRemain;
        UnitOfMeasureSymbol inventHandlingUnit = WHSCatchWeightHelper::inventHandlingUnitId(workInventTrans.ItemId);

        // Modify the partially picked workLine and workInventTrans
        this.modifyPartiallyPickedLine(_workId, _lineNum);

        // Increment the LineNum on the following workLine, workInventTrans, dimTracking, replenishment, workTrans, and exceptionLog
        this.moveRelatedEntites(_workId, _lineNum, 1);

        // Insert the new workLine and workInventTrans
        this.createNewWorkLine(newWorkLine,
                               _lineNum + 1,
                               _locationId,
                               inventHandlingQty + this.getNotStartedWorkInventTransQty(workInventTrans),
                               inventHandlingUnit);

        inventDim.wmsLocationId = _locationId;
        inventDim = InventDim::findOrCreate(inventDim);

        this.createNewWorkInventTrans(newWorkInventTrans, _lineNum + 1, inventDim.inventDimId, inventHandlingQty);
        this.updateNotStartedWorkInventTrans(workInventTrans, inventDim.inventDimId, _lineNum + 1);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNotStartedWorkInventTrans</Name>
				<Source><![CDATA[
    private void updateNotStartedWorkInventTrans(WHSWorkInventTrans _workInventTrans, InventDimId _inventDimId, LineNum _newLineNum)
    {
        WHSWorkInventTrans workInventTrans;

        ttsbegin;
        workInventTrans.skipDataMethods(true);

        update_recordset workInventTrans
            setting LineNum = _newLineNum,
                    InventDimIdFrom = _inventDimId
            where workInventTrans.WorkId == _workInventTrans.WorkId
               && workInventTrans.LineNum == _workInventTrans.LineNum
               && workInventTrans.Qty == workInventTrans.InventQtyRemain;
        ttscommit;

    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewWorkInventTrans</Name>
				<Source><![CDATA[
    private void createNewWorkInventTrans(WHSWorkInventTrans _newWorkInventTrans,
                                          LineNum            _newlineNum,
                                          InventDimId        _inventDimId,
                                          InventHandlingQty  _handlingQty)
    {
        _newWorkInventTrans.Qty              = _handlingQty;
        _newWorkInventTrans.InventQtyRemain  = _handlingQty;
        _newWorkInventTrans.LineNum          = _newlineNum;
        _newWorkInventTrans.InventDimIdFrom  = _inventDimId;

        // Need to clear RecId to update data in WHSInventTransOriginWorkTo correctly
        _newWorkInventTrans.RecId = 0;
        _newWorkInventTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewWorkLine</Name>
				<Source><![CDATA[
    private void createNewWorkLine(WHSWorkLine          _newWorkLine,
                                   LineNum              _newlineNum,
                                   WMSLocationId        _locationId,
                                   InventHandlingQty    _handlingQty,
                                   UnitOfMeasureSymbol  _inventHandlingUnit,
                                   InventDimId          _orderCommittedInventDimId = '',
                                   WHSQtyWork           _qtyWork = 0)
    {
        _newWorkLine.UnitId                     = _inventHandlingUnit;
        _newWorkLine.QtyWork                    = _qtyWork ? _qtyWork : _handlingQty;
        _newWorkLine.QtyRemain                  = _qtyWork ? _qtyWork : _handlingQty;
        _newWorkLine.InventQtyWork              = _handlingQty;
        _newWorkLine.InventQtyRemain            = _handlingQty;
        _newWorkLine.LineNum                    = _newlineNum;
        _newWorkLine.wmsLocationId              = _locationId;
        _newWorkLine.OrderCommittedInventDimId  = _orderCommittedInventDimId;
        _newWorkLine.WorkStatus                 = WHSWorkStatus::Open;
        _newWorkLine.WorkInProcessUTCDateTime   = utcDateTimeNull();
        _newWorkLine.UserId                     = '';
        _newWorkLine.AskForNewLicensePlate      = NoYes::No;
        _newWorkLine.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyPartiallyPickedLine</Name>
				<Source><![CDATA[
    private void modifyPartiallyPickedLine(WHSWorkId _workId,
                                           LineNum   _lineNum)
    {
        WHSWorkLine         workLine;
        WHSWorkInventTrans  workInventTrans;

        select firstonly forupdate workLine
            where workLine.WorkId       == _workId  &&
                  workLine.LineNum      == _lineNum;

        select firstonly forupdate workInventTrans
            where workInventTrans.WorkId    == _workId  &&
                  workInventTrans.LineNum   == _lineNum &&
                  workInventTrans.InventQtyRemain != 0;

        var toInventDim = InventDim::find(workInventTrans.InventDimIdTo);

        workLine.QtyRemain              = 0;
        workLine.InventQtyRemain        = 0;
        workLine.InventQtyWork          -= workInventTrans.InventQtyRemain;
        workLine.InventQtyWork          -= this.getNotStartedWorkInventTransQty(workInventTrans);       

        workLine.QtyWork                = workLine.InventQtyWork;
        workLine.UnitId                 = WHSCatchWeightHelper::inventHandlingUnitId(workInventTrans.ItemId);
        workLine.WorkStatus             = WHSWorkStatus::Closed;
        workLine.WorkClosedUTCDateTime  = DateTimeUtil::utcNow();
        workLine.update();

        toInventDim.wmsLocationId   = workLine.UserId;
        toInventDim = InventDim::findOrCreate(toInventDim);

        workInventTrans.Qty = workLine.InventQtyWork;
        workInventTrans.Qty -= this.getCompletedWorkInventTransQty(workLine);

        workInventTrans.InventDimIdTo = toInventDim.InventDimId;
        workInventTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompletedWorkInventTransQty</Name>
				<Source><![CDATA[
    private ProductQuantity getCompletedWorkInventTransQty(WHSWorkLine _workLine)
    {
        WHSWorkInventTrans workInventTrans;

        select sum(Qty) from workInventTrans
            where workInventTrans.WorkId == _workLine.WorkId
               && workInventTrans.LineNum == _workLine.LineNum
               && workInventTrans.InventQtyRemain == 0;

        return workInventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNotStartedWorkInventTransQty</Name>
				<Source><![CDATA[
    private ProductQuantity getNotStartedWorkInventTransQty(WHSWorkInventTrans _workInventTrans)
    {
        WHSWorkInventTrans workInventTrans;

        select sum(Qty) from workInventTrans
            where workInventTrans.WorkId == _workInventTrans.WorkId
               && workInventTrans.LineNum == _workInventTrans.LineNum
               && workInventTrans.InventQtyRemain == workInventTrans.Qty
               && workInventTrans.RecId != _workInventTrans.RecId;

        return workInventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveRelatedEntites</Name>
				<Source><![CDATA[
    private void moveRelatedEntites(WHSWorkId   _workId,
                                    LineNum     _lineNum,
                                    LineNum     _numberOfLinesToMove)
    {
        WHSWorkLine workLine;

        while select forupdate workLine
            order by LineNum desc
            where workLine.WorkId       == _workId  &&
                  workLine.LineNum       > _lineNum
        {
            WHSWorkInventTrans::moveToNewWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkId, workLine.LineNum + _numberOfLinesToMove);
            WHSDimTracking::moveToNewWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkId, workLine.LineNum + _numberOfLinesToMove);
            WHSReplenWorkLink::moveToNewWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkId, workLine.LineNum + _numberOfLinesToMove);
            WHSWorkTrans::moveToNewWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkId, workLine.LineNum + _numberOfLinesToMove);
            WHSWorkExceptionLog::moveToNewWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkId, workLine.LineNum + _numberOfLinesToMove);

            workLine.LineNum += _numberOfLinesToMove;
            workLine.update();
        }
        WHSWorkLineCache::remove(_workId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickWorkFromLicensePlateWithParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks work from a license plate controlled location given the pick parameters.
    /// </summary>
    /// <param name = "_parameters">The parameters to do the pick.</param>
    /// <returns>The next open work line for the work being executed.</returns>
    public WHSWorkLine pickWorkFromLicensePlateWithParameters(WHSWorkLinePickParameters _parameters)
    {
        _parameters.validate();

        return this.pickWorkFromLicensePlate(_parameters.licensePlateId, _parameters.workLine, _parameters.userId, _parameters.inventDim, _parameters.targetLicensePlateId, _parameters.capturedWeight, _parameters.assignSerial, _parameters.overrideTargetLP, _parameters.skipValidateLP, _parameters.handleByLP);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickWorkFromLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks work from a License plate controlled location.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate Id.
    /// </param>
    /// <param name="_workLine">
    /// The work line to be executed.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The specified target license of the work being executed.
    /// </param>
    /// <param name="_capturedWeight">
    /// The weight being captured for the license plate.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <param name="_overrideTargetLP">
    /// Boolean that determines if we want to override target license plate
    /// </param>
    /// <param name="_skipValidateLP">
    /// Skip validation of onhand for given license plate ID
    /// </param>
    /// <param name="_handleByLP">
    /// A Boolean value that indicates whether to use standard put procedure or "Handle by LP" put
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    [Hookable(false)]
    final public WHSWorkLine pickWorkFromLicensePlate(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine,
        WHSUserId           _userId,
        InventDim           _inventDim,
        WHSLicensePlateId   _targetLicensePlateId,
        WHSTransWeight      _capturedWeight,
        boolean             _assignSerial,
        WHSOverrideTargetLP _overrideTargetLP,
        boolean             _skipValidateLP,
        boolean             _handleByLP)
    {
        if (_capturedWeight && !WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!_workLine.ItemId ? _capturedWeight : !WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _workLine.ItemId, _capturedWeight))
        {
            return this.pickWorkLineFromLicensePlate(_licensePlateId,
                                                     _workLine,
                                                     _userId,
                                                     _inventDim,
                                                     _targetLicensePlateId,
                                                     _capturedWeight,
                                                     _assignSerial,
                                                     _overrideTargetLP,
                                                     _skipValidateLP,
                                                     _handleByLP);
        }
        
        return this.pickFromLicensePlate(_licensePlateId,
                                         _workLine.WorkId,
                                         _workLine.LineNum,
                                         _userId,
                                         _inventDim,
                                         _targetLicensePlateId,
                                         _assignSerial,
                                         _overrideTargetLP,
                                         _skipValidateLP,
                                         _handleByLP);
    }

]]></Source>
			</Method>
			<Method>
				<Name>needToAskForNewLicensePlateForWorkLinePick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if we need to ask for new license plate during work line pick.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <param name = "_licensePlateId">The license plate.</param>
    /// <param name = "_targetLicensePlate">The target license plate.</param>
    /// <param name = "_overrideTargetLicensePlate">A Boolean value that indicates whether to override target license plate.</param>
    /// <param name = "_wholePicking">A Boolean value that indicates if whole picking.</param>
    /// <param name = "_overPicking">A Boolean value that indicates if over picking.</param>
    /// <returns>true if asking for new license plate for the pick; otherwise, false.</returns>
    protected boolean needToAskForNewLicensePlateForWorkLinePick(
        WHSWorkLine         _workLine,
        WHSLicensePlateId   _licensePlateId,
        WHSLicensePlateId   _targetLicensePlate,
        WHSOverrideTargetLP _overrideTargetLicensePlate,
        boolean             _wholePicking,
        boolean             _overPicking)
    {
        return  (!_wholePicking || _overrideTargetLicensePlate)
             && (!_targetLicensePlate || _targetLicensePlate == _licensePlateId)
             && !_overPicking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickWorkLineFromLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks work from a License plate controlled location.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate Id.
    /// </param>
    /// <param name="_workLine">
    /// The work line to be executed.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The specified target license of the work being executed.
    /// </param>
    /// <param name="_capturedWeight">
    /// The weight being captured for the license plate.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <param name="_overrideTargetLP">
    /// Boolean that determines if we want to override target license plate
    /// </param>
    /// <param name="_skipValidateLP">
    /// Skip validation of onhand for given license plate ID
    /// </param>
    /// <param name="_handleByLP">
    /// A Boolean value that indicates whether to use standard put procedure or "Handle by LP" put
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the pickWorkFromLicensePlate method.
    /// </remarks>
    [Wrappable(true)]
    protected WHSWorkLine pickWorkLineFromLicensePlate(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkLine         _workLine,
        WHSUserId           _userId,
        InventDim           _inventDim,
        WHSLicensePlateId   _targetLicensePlateId,
        WHSTransWeight      _capturedWeight,
        boolean             _assignSerial,
        WHSOverrideTargetLP _overrideTargetLP,
        boolean             _skipValidateLP,
        boolean             _handleByLP)
    {
        WHSWorkTable workTable = _workLine.whsWorkTable();
        boolean      wholePicking;

        WHSWorkExecuteInstrumentationActivities workExecuteActivities = this.instrumentationLogger().workExecuteActivities();
        using (var activityContext = !_handleByLP ? workExecuteActivities.pickWorkLineFromLicensePlate() : workExecuteActivities.pickLicensePlateHandledByLP())
        {
            // Evaluate if we will be overpicking
            boolean overPicking = WHSWorkExecute::validateOverPick(_workLine, _licensePlateId);
            using (var context = new WHSWholeLPQtyMultipleSKUValidationContext())
            {
                context.implementMultipleSKUValidation = _handleByLP;                

                wholePicking = this.isWholeLicensePlate(_licensePlateId, _workLine, true);
            }

            WHSTargetLicensePlateId targetLicensePlateForPick = _targetLicensePlateId;

            // if target license plate was provided, set it. Otherwise, if pick full LP, it becomes target LP.
            if (!workTable.TargetLicensePlateId)
            {
                if (targetLicensePlateForPick)
                {
                    workTable = WHSWorkTable::addTargetLicensePlate(_workLine.WorkId, targetLicensePlateForPick);
                }
                else if (wholePicking || overPicking)
                {
                    workTable = WHSWorkTable::addTargetLicensePlate(_workLine.WorkId, _licensePlateId);
                    targetLicensePlateForPick = _licensePlateId;
                }
            }

            boolean needToAskForNewLicensePlateForWorkLinePick = this.needToAskForNewLicensePlateForWorkLinePick(_workLine, _licensePlateId, targetLicensePlateForPick, _overrideTargetLP, wholePicking, overPicking);

            if (_handleByLP)
            {                
                return this.pickLicensePlateHandledByLP(_workLine.WorkId, _workLine.LineNum, _licensePlateId, _workLine.wmsLocationId, _userId);
            }

            ttsbegin;

            if (!_skipValidateLP && !this.validateLicensePlate(_workLine, _licensePlateId))
            {
                throw error("@WAX528");
            }

            // Break nested LP if full pick
            if (!_handleByLP && wholePicking && WHSLicensePlate::find(_licensePlateId).LicensePlateParent)
            {
                WHSLicensePlate::removeFromParentLP(_licensePlateId);
            }            

            WHSWorkLine retWorkLine;

            if (needToAskForNewLicensePlateForWorkLinePick)
            {
                ttsbegin;
                retWorkLine = WHSWorkLine::find(_workLine.WorkId, _workLine.LineNum, true);

                retWorkLine.AskForNewLicensePlate = NoYes::Yes;
                retWorkLine.update();
                ttscommit;

                activityContext.addCustomProperty('pickWorkLineFromLicensePlateFlow', 'needToAskForNewLicensePlateForWorkLinePick');
            }
            else
            {
                this.updateLicensePlateStatusByPickWorkLine(_workLine, _licensePlateId);
                InventHandlingQty overPickQty;
                // If overpicking, call into method to freeze/cancel other work
                if (overPicking)
                {
                    //If overpicking, the total quantity on the license plate is equal
                    //to the quantity of this item and this dimensions on the current license plate.
                    //For performance reasons, the total quantity on the license plate is calculated here.

                    overPickQty = WHSInvent::calculateHandlingQtyOnLicensePlate(_licensePlateId) - _workLine.InventQtyRemain;

                    this.overPickQuantitiesByItem(
                        _workLine,
                        _workLine.inventDimWithLocation().InventDimId,
                        _workLine.ItemId,
                        overPickQty,
                        _capturedWeight,
                        workTable.WorkTransType,
                        _licensePlateId);
                }

                if (!_assignSerial)
                {
                    this.createWorkDimTrackingEntries(_workLine, _inventDim, _capturedWeight, overPicking);
                }

                InventDim inventDim = InventDim::find(_workLine.InventDimId);
                inventDim.wmsLocationId = _workLine.wmsLocationId;
                inventDim.InventSiteId  = workTable.InventSiteId;
                inventDim.InventLocationId  = workTable.InventLocationId;

                WHSWorkTrans workTrans;
                workTrans.setWorkTransId();
                workTrans.initFromWorkLine(_workLine);
                workTrans.UserId                    = _userId;
                workTrans.TransDateTime             = DateTimeUtil::utcNow();

                if (WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
                {
                    workTrans.TargetLicensePlateId = targetLicensePlateForPick;
                }

                if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
                    || WHSConsumeTargetLPFromWHSWorkTransFlight::instance().isEnabled())
                {
                    inventDim.LicensePlateId = _licensePlateId;
                    workTrans.TargetLicensePlateId = targetLicensePlateForPick;
                }
                else if (targetLicensePlateForPick)
                {
                    inventDim.LicensePlateId = targetLicensePlateForPick;
                }
                else
                {
                    inventDim.LicensePlateId = _licensePlateId;
                }

                workTrans.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;

                Qty qty;
                WHSTransWeight weight;

                if (workTable.WorkTransType == WHSWorkTransType::PackedContainerPicking
                    && WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(targetLicensePlateForPick))
                {
                    activityContext.addCustomProperty('pickWorkLineFromLicensePlateFlow', methodStr(WhsWorkExecute, moveGroupedContainers));
                    qty = this.moveGroupedContainers(_workLine, _userId, targetLicensePlateForPick);
                }
                else
                {
                    activityContext.addCustomProperty('pickWorkLineFromLicensePlateFlow', methodStr(WhsWorkExecute, moveLicensePlateWorkItems));
                    [qty, weight] = this.moveLicensePlateWorkItems(_workLine, _licensePlateId, _userId, _capturedWeight, targetLicensePlateForPick, overPicking, overPickQty, _assignSerial);
                }

                workTrans.Qty = qty;
                workTrans.insert();
                    
                // Reset to passed in weight for inbound pick work (only record actual weight for outbound)
                if (weight != _capturedWeight && workTable.isInbound())
                {
                    weight = _capturedWeight;
                }

                this.updateWorkLineRemainingQuantities(_workLine, qty, weight);

                this.updateWorkStatus(_workLine.WorkId, _workLine.LineNum, _userId);

                this.updateTagWithWorkInProgressStatus(workTable, _workLine);

                retWorkLine = this.getFirstOpenLine(_workLine.WorkId, _userId);
            }

            // Update location fields for the pick location.
            WHSLocationWorkUpdater::updateLocationInfoFromPickPutWork(
                workTable.InventLocationId,
                _workLine.WMSLocationId,
                WHSWorkType::Pick);

            WMSLocation wmsLocation = WMSLocation::find(_workLine.WMSLocationId, workTable.InventLocationId);

            WHSLocationLicensePlatePositioningSequencer::newFromLicensePlateAtLocation(_licensePlateId, wmsLocation).pickLicensePlateFromCurrentPosition();

            ttscommit;

            return retWorkLine;
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLicensePlateStatusByPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update license plate status by pick work line.
    /// </summary>
    /// <param name = "_workLine">The work line.</param>
    /// <param name = "_licensePlateId">License plate id.</param>
    protected void updateLicensePlateStatusByPickWorkLine(WHSWorkLine _workLine, WHSLicensePlateId _licensePlateId)
    {
        if ((select firstonly RecId from whsWorkLine
                    where whsWorkLine.WorkId        == _workLine.WorkId      &&
                          whsWorkLine.LineNum       == _workLine.LineNum - 1 &&
                          whsWorkLine.WorkType      == WHSWorkType::StatusChange).RecId > 0)
        {
            WHSWorkQuarantine::changeLPStatusByWorkLine(_workLine, _workLine.inventDim().InventStatusId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTagWithWorkInProgressStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the tag status to picking in progress.
    /// </summary>
    /// <param name = "_workTable">A <c>WHSWorkTable</c> buffer.</param>
    /// <param name = "_workLine">A <c>WHSWorkLine</c> buffer.</param>
    private void updateTagWithWorkInProgressStatus(WHSWorkTable _workTable, WHSWorkLine _workLine)
    {
        if (!WHSCatchWeightTagCache::construct().isCatchWeightTagFeatureUsed()
            || !this.doesWorkTransTypeSupportInprocessTagRegistration(_workTable.WorkTransType))
        {
            return;
        }

        WHSCatchWeightTagRegistrationEvent registrationEvent = _workTable.isInbound()
                                                                    ? WHSCatchWeightTagRegistrationEvent::PickingStarted
                                                                    : WHSCatchWeightTagRegistrationEvent::OutboundPickingStarted;

        if (!_workLine.ItemId)
        {
            WHSWorkInventTrans workInventTrans;

            while select ItemId from workInventTrans
                group by ItemId
                where  workInventTrans.WorkId  == _workLine.WorkId
                    && workInventTrans.LineNum == _workLine.LineNum
            {
                this.registerTagWithPickedStatus(_workLine, workInventTrans.ItemId, registrationEvent);
            }
        }
        else
        {
            this.registerTagWithPickedStatus(_workLine, _workLine.ItemId, registrationEvent);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerTagWithPickedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers picking started status for the catch weight tags.
    /// </summary>
    /// <param name = "_workLine">The work line.</param>
    /// <param name = "_itemId">Item Id.</param>
    /// <param name = "_registrationEvent">Registration event.</param>
    private void registerTagWithPickedStatus(
        WHSWorkLine                         _workLine,
        ItemId                              _itemId,
        WHSCatchWeightTagRegistrationEvent  _registrationEvent)
    {
        if (PdsGlobal::pdsIsCWItem(_itemId)
            && WHSInventTable::isCatchWeightTagTracked(_itemId))
        {
            WHSCatchWeightTagEventRegistration tagRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(_registrationEvent);
            WHSCatchWeightTagLastRegistration lastRegistration;
            WHSCatchWeightTag tag;

            if (!_workLine.isInitialPickLine())
            {
                WHSWorkLine locWorkLine;
                while select tag
                    where tag.ItemId == _itemId
                    exists join lastRegistration
                        where lastRegistration.TagNumber == tag.TagNumber
                            && lastRegistration.RegistrationEvent != _registrationEvent
                    exists join locWorkLine
                        where lastRegistration.WorkLine == locWorkLine.RecId
                            && locWorkLine.WorkType == WHSWorkType::Pick
                            && locWorkLine.WorkId == _workLine.WorkId
                            && locWorkLine.LineNum < _workLine.LineNum
                {
                    tagRegistration.parmWorkLineRecId(_workLine.RecId);
                    tagRegistration.registerEvent(tag);
                }
            }
            else
            {
                while select tag
                    where tag.ItemId == _itemId
                    exists join lastRegistration
                        where lastRegistration.TagNumber == tag.TagNumber
                            && lastRegistration.WorkLine == _workLine.RecId
                            && lastRegistration.RegistrationEvent != _registrationEvent
                {
                    tagRegistration.parmWorkLineRecId(_workLine.RecId);
                    tagRegistration.registerEvent(tag);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesWorkTransTypeSupportInprocessTagRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the work transaction type supports tag registrations.
    /// </summary>
    /// <param name = "_workTransType">Work transaction type.</param>
    /// <returns>true if the tag has to be registered; otherwise false</returns>
    private boolean doesWorkTransTypeSupportInprocessTagRegistration(WHSWorkTransType _workTransType)
    {
        switch (_workTransType)
        {
            case WHSWorkTransType::Purch:
            case WHSWorkTransType::TransferReceipt:
            case WHSWorkTransType::ReturnOrder:
            case WHSWorkTransType::ProdPut:
            case WHSWorkTransType::Sales:
            case WHSWorkTransType::ProdPick:
            case WHSWorkTransType::TransferIssue:
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalQtyOnLicensePlateByItemAndDimensions</Name>
				<Source><![CDATA[
    public static InventHandlingQty getTotalQtyOnLicensePlateByItemAndDimensions(
        WHSWorkLine         _workLine,
        WHSLicensePlateId   _licensePlateId)
    {
        InventDim inventDimCriteria = _workLine.inventDimWithLocation();
        inventDimCriteria.LicensePlateId = _licensePlateId;
        inventDimCriteria.inventBatchId  = _workLine.FEFOBatchId ? _workLine.FEFOBatchId : inventDimCriteria.inventBatchId;
        
        InventDimParm inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_workLine.ItemId));
        inventDimParm.wmsLocationIdFlag = NoYes::Yes;
        inventDimParm.LicensePlateFlag = NoYes::Yes;
        inventDimParm.InventBatchIdFlag = _workLine.FEFOBatchId ? NoYes::Yes : inventDimParm.InventBatchIdFlag;

        InventHandlingQty physicalInventHandlingQtyOnLPByItemAndDimensions = WhsWorkExecute::getQtyByItemAndDimensions(_workLine.itemId,
                                                                                                                       inventDimCriteria,
                                                                                                                       inventDimParm);

        if (!physicalInventHandlingQtyOnLPByItemAndDimensions)
        {
            inventDimCriteria.inventBatchId = '';
            inventDimParm.InventBatchIdFlag = false;

            physicalInventHandlingQtyOnLPByItemAndDimensions = WhsWorkExecute::getQtyByItemAndDimensions(_workLine.itemId,
                                                                                                         inventDimCriteria,
                                                                                                         inventDimParm);
        }

        return physicalInventHandlingQtyOnLPByItemAndDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyByItemAndDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates physical invent qty by item and dimensions.
    /// </summary>
    /// <param name = "_itemId"> Id of item to calculate </param>
    /// <param name = "_inventDimCriteria"> Invent dimensions to calculate </param>
    /// <param name = "_inventDimParm"> Invent dimension parms to calculate </param>
    /// <returns> Physical invent qty based on item and dimensions </returns>
    private static InventHandlingQty getQtyByItemAndDimensions(ItemId          _itemId,
                                                               InventDim       _inventDimCriteria,
                                                               InventDimParm   _inventDimParm)
    {
        InventSum           inventSum;
        InventDim           inventDim;
        InventHandlingQty   physicalInventHandlingQty;

        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                select sum(PdsCWPhysicalInvent) from inventSum
                        where inventSum.ItemId      == _itemId
                            && inventSum.ClosedQty  == NoYes::No
                            && #InventDimFieldsFilter(inventSum, _inventDimCriteria, _inventDimParm);
            }
            else
            {
                select sum(PdsCWPhysicalInvent) from inventSum
                        where inventSum.ItemId      == _itemId
                            && inventSum.ClosedQty  == NoYes::No
                        #InventDimExistsJoin(inventSum.InventDimId, inventDim, _inventDimCriteria, _inventDimParm);
            }

            physicalInventHandlingQty = inventSum.PdsCWPhysicalInvent;
        }
        else
        {

            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                select sum(PhysicalInvent) from inventSum
                        where inventSum.ItemId      == _itemId
                            && inventSum.ClosedQty  == NoYes::No
                            && #InventDimFieldsFilter(inventSum, _inventDimCriteria, _inventDimParm);
            }
            else
            {
                select sum(PhysicalInvent) from inventSum
                        where inventSum.ItemId      == _itemId
                            && inventSum.ClosedQty  == NoYes::No
                        #InventDimExistsJoin(inventSum.InventDimId, inventDim, _inventDimCriteria, _inventDimParm);
            }

            physicalInventHandlingQty = inventSum.PhysicalInvent;
        }

        return physicalInventHandlingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickFromLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes part of a pick work line from a License plate controlled location.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate Id.
    /// </param>
    /// <param name="_workId">
    /// The work Id of the current work to be executed.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the current line of work to be executed.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The specified target license of the work being executed.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <param name="_overrideTargetLP">
    /// Boolean that determines if we want to override target license plate
    /// </param>
    /// <param name="_skipValidateLP">
    /// Skip validation of onhand for given license plate ID
    /// </param>
    /// <param name="_handleByLP">
    ///    A Boolean value that indicates whether to use standard put procedure or "Handle by LP" put
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the pickWorkFromLicensePlate method. Extenders should move their logic to wrap or override the pickWorkLineFromLicensePlate method.', false, 30\9\2019)]
    public WHSWorkLine pickFromLicensePlate(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkId           _workId,
        LineNum             _lineNum,
        WHSUserId           _userId,
        InventDim           _inventDim              = null,
        WHSLicensePlateId   _targetLicensePlateId   = '',
        boolean             _assignSerial           = false,
        WHSOverrideTargetLP _overrideTargetLP       = NoYes::No,
        boolean             _skipValidateLP         = false,
        boolean             _handleByLP             = false)
    {
        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum);
        if (workLine.ItemId)
        {
            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), workLine.ItemId);
        }

        return this.pickWorkLineFromLicensePlate(_licensePlateId,
                                                 workLine,
                                                 _userId,
                                                 _inventDim,
                                                 _targetLicensePlateId,
                                                 0, // weight is not relevant for non-cw enabled warehouse items
                                                 _assignSerial,
                                                 _overrideTargetLP,
                                                 _skipValidateLP,
                                                 _handleByLP);

    }

]]></Source>
			</Method>
			<Method>
				<Name>pickNonLicensePlateCheckDigitQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes part of a pick work line from a non-License plate controlled location.
    /// </summary>
    /// <param name="_workId">
    /// The work Id of the current work to be executed.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the current line of work to be executed.
    /// </param>
    /// <param name="_itemId">
    /// The item Id, if present, of the work line to be executed.
    /// </param>
    /// <param name="_handlingQty">
    /// The handling quantity to be executed.
    /// </param>
    /// <param name="_transWeight">
    /// The weight to be executed.
    /// </param>
    /// <param name="_handlingUnitId">
    /// The handling unit of measure.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The specified target license of the work being executed.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws if a suitable <c>WHSWorkInventTrans</c> is not found for execution.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Throws if a suitable <c>WHSWorkInventTrans</c> is not found for execution.
    /// </exception>
    [Hookable(false)]
    final public WHSWorkLine pickNonLicensePlateCheckDigitQuantities(
        WHSWorkId         _workId,
        LineNum           _lineNum,
        ItemId            _itemId,
        InventHandlingQty _handlingQty,
        WHSTransWeight    _transWeight,
        WHSUOM            _handlingUnitId,
        WHSUserId         _userId,
        InventDim         _inventDim,
        WHSLicensePlateId _targetLicensePlateId,
        boolean           _assignSerial)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _itemId, _transWeight))
        {
            return this.pickNonLicensePlateCheckDigitQty(_workId,
                         _lineNum,
                        _itemId,
                        _handlingQty,
                        _transWeight,
                        _handlingUnitId,
                        _userId,
                        _inventDim,
                        _targetLicensePlateId,
                        _assignSerial,
                        true);
        }

        return this.pickNonLicensePlateCheckDigit(_workId,
                         _lineNum,
                        _itemId,
                        _handlingQty,
                        _handlingUnitId,
                        _userId,
                        _inventDim,
                        _targetLicensePlateId,
                        _assignSerial);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickNonLicensePlateCheckDigitQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes part of a pick work line from a non-License plate controlled location.
    /// </summary>
    /// <param name="_workId">
    /// The work Id of the current work to be executed.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the current line of work to be executed.
    /// </param>
    /// <param name="_itemId">
    /// The item Id, if present, of the work line to be executed.
    /// </param>
    /// <param name="_handlingQty">
    /// The handling quantity to be executed.
    /// </param>
    /// <param name="_transWeight">
    /// The weight to be executed.
    /// </param>
    /// <param name="_handlingUnitId">
    /// The handling unit of measure.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The specified target license of the work being executed.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <param name="_pickCWItem">
    /// A Boolean that determines if pick catch weight item.
    /// Used for capture at picking.
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws if a suitable <c>WHSWorkInventTrans</c> is not found for execution.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Throws if a suitable <c>WHSWorkInventTrans</c> is not found for execution.
    /// </exception>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the pickNonLicensePlateCheckDigitQuantities method.
    /// </remarks>
    [Wrappable(true)]
    protected WHSWorkLine pickNonLicensePlateCheckDigitQty(
        WHSWorkId         _workId,
        LineNum           _lineNum,
        ItemId            _itemId,
        InventHandlingQty _handlingQty,
        WHSTransWeight    _transWeight,
        WHSUOM            _handlingUnitId,
        WHSUserId         _userId,
        InventDim         _inventDim,
        WHSLicensePlateId _targetLicensePlateId,
        boolean           _assignSerial,
        boolean           _pickCWItem)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _itemId, _handlingQty, _transWeight);
        
        WHSWorkLine             returnWorkLine;
        InventDim               inventDim;
        Qty                     dimTrackingQty;
        InventDimId             trackingInventDimIdFrom;
        boolean                 useDimTracking = false;

        using (var activityContext = this.instrumentationLogger().workExecuteActivities().pickNonLicensePlateCheckDigitQty())
        {
            if (_targetLicensePlateId)
            {
                WHSAgingDate agingDate = WHSLicensePlate::calculateAgingDateForMovement('', _inventDim.wMSLocationId, _inventDim.InventLocationId, _targetLicensePlateId);
                WHSLicensePlate::createLicensePlateWithAgingDate(_targetLicensePlateId, agingDate);
            }

            WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum);

            if (!this.validateNoSerialInventoryNonLP(workLine, _inventDim))
            {
                throw error("@WAX5563");
            }

            InventHandlingQty convertedQty = this.convertNonLPPickInventoryHandlingQuantity(_itemId, _handlingQty, _handlingUnitId, workLine);
            InventHandlingQty fullQtyToMove = convertedQty;
            
            ttsbegin;

            // When assign serial is enabled, the dimension tracking records are created
            // from Assign Serial step. Else, create the needed dim tracking records.
            if (!_assignSerial && !this.createWorkDimTrackingEntries(workLine, _inventDim, _transWeight, false))
            {
                returnWorkLine = this.getFirstOpenLine(workLine.WorkId, _userId);

                if (!inventDim.InventGtdId_RU
                && WhsInvent::isGTDNumberOptional(_itemId))
                {
                    throw error("@Inventory_Localization:MobileAppNoQtyForSpecifiedDimError");
                }
            }
            else
            {
                Qty     qtyToMove;
                boolean foundWIT;

                WHSTransWeight weightLeftToMove = _transWeight;

                // Determine if multiple pick WITs exist, required for weight capturing
                boolean multiplePickWITs;

                if (_pickCWItem)
                {
                    multiplePickWITs = this.isMoveLicensePlateMultipleWorkInventTrans(workLine);
                }

                // With rounding up to handling unit, it is possible to have multiple WITs here
                WHSWorkInventTrans workInventTrans;
                SysDaQueryObject workInventTransQueryObject         = this.buildPickNonLicensePlateCheckDigitQtyWorkInventTransQuery(workInventTrans, _workId, _lineNum, _itemId);
                SysDaSearchObject workInventTransSearchObject       = new SysDaSearchObject(workInventTransQueryObject);
                SysDaSearchStatement workInventTransSearchStatement = new SysDaSearchStatement();
                
                while (workInventTransSearchStatement.nextRecord(workInventTransSearchObject))
                {
                    foundWIT = true;

                    // If all qty has been picked stop updating WITs
                    if (convertedQty == 0)
                    {
                        break;
                    }

                    [convertedQty, qtyToMove] = this.calculateConvertedQtyForWorkInventTrans(workInventTrans, convertedQty);

                    // Reset dim tracking variables
                    useDimTracking = false;
                    dimTrackingQty = 0;

                    // Build up InventDim to have location location and license plate
                    inventDim = InventDim::find(workInventTrans.InventDimIdTo);
                    inventDim.wmsLocationId = _userId;
                    boolean isUserLocationLPControlled = inventDim.wmsLocation().whsLocationIsLPControlled();

                    if (isUserLocationLPControlled)
                    {
                        inventDim.LicensePlateId = _targetLicensePlateId;
                    }

                    inventDim = InventDim::findOrCreate(inventDim);

                    if (!WHSWorkTable::find(_workId).TargetLicensePlateId)
                    {
                        WHSWorkTable::addTargetLicensePlate(_workId, _targetLicensePlateId);
                    }

                    WHSTransWeight totalWeightDimTracking, totalWeightNonDimTracking;
                    WHSTransWeight dimTrackingWeightMove;
                    WHSTransWeight transWeightToMove;

                    if (!_assignSerial)
                    {
                        if (_pickCWItem)
                        {
                            WHSDimTracking      sumDimTracking;
                            InventHandlingQty   totalDimHandlingQty;
                            
                            // update the WIT weight to match the captured or calculated weight
                            // we update the WIT once for all unprocessed dimTracking records for better performance
                            while select sum(Qty), sum(CapturedWeight) from sumDimTracking
                            group by InventDimId
                            where sumDimTracking.WorkId    == workLine.WorkId
                                && sumDimTracking.LineNum   == workLine.LineNum
                                && sumDimTracking.Processed != NoYes::Yes
                            {
                                if (sumDimTracking.CapturedWeight)
                                {
                                    totalWeightDimTracking += sumDimTracking.CapturedWeight;
                                }
                                else
                                {
                                    // Calculate weight based off inventory values.
                                    totalWeightDimTracking += WHSCatchWeightHelper::calculateMovingWeight(workInventTrans.ItemId, sumDimTracking.InventDimId, sumDimTracking.Qty);
                                }

                                totalDimHandlingQty += sumDimTracking.Qty;
                            }

                            this.adjustWorkInventTransWeight(workInventTrans, totalWeightDimTracking, totalDimHandlingQty);
                        }

                        WHSDimTracking dimTracking;
                        SysDaQueryObject dimTrackingQuery = this.buildPickNonLicensePlateCheckDigitQtyDimTrackingQuery(dimTracking, workInventTrans, workLine.WorkId, workLine.LineNum);
                        SysDaSearchObject dimTrackingSearchObject = new SysDaSearchObject(dimTrackingQuery);
                        SysDaSearchStatement dimTrackingSearchStatement = new SysDaSearchStatement();
                        
                        while (dimTrackingSearchStatement.nextRecord(dimTrackingsearchObject))
                        {
                            useDimTracking = true;

                            trackingInventDimIdFrom = dimTracking.InventDimId;

                            this.checkInventBatch(trackingInventDimIdFrom, workLine);

                            InventDim tmpTrackingInventDimTo = InventDim::find(dimTracking.InventDimId);
                            tmpTrackingInventDimTo.wmsLocationId = _userId;

                            if (isUserLocationLPControlled)
                            {
                                tmpTrackingInventDimTo.LicensePlateId = _targetLicensePlateId;
                            }

                            tmpTrackingInventDimTo = InventDim::findOrCreate(tmpTrackingInventDimTo);

                            if (_pickCWItem)
                            {
                                if (dimTracking.CapturedWeight)
                                {
                                    transWeightToMove = dimTracking.CapturedWeight;
                                }
                                else
                                {
                                    // Calculate weight based off inventory values.
                                    transWeightToMove = WHSCatchWeightHelper::calculateMovingWeight(workInventTrans.ItemId, dimTracking.InventDimId, dimTracking.Qty);
                                }

                                WHSInvent::moveWorkQuantities(workInventTrans, trackingInventDimIdFrom, tmpTrackingInventDimTo.inventDimId, transWeightToMove, dimTracking.Qty);
                            }
                            else
                            {
                                WHSInvent::moveWorkQuantities(workInventTrans, trackingInventDimIdFrom, tmpTrackingInventDimTo.InventDimId, dimTracking.Qty, 0);
                            }

                            dimTracking.Processed = NoYes::Yes;
                            dimTracking.update();

                            dimTrackingQty          += dimTracking.Qty;
                            dimTrackingWeightMove   += dimTracking.CapturedWeight;
                        }

                        // If the item requires dim tracking and no dim tracking quantity was found, skip this WIT
                        boolean dimTrackingNeeded = (this.itemIsDimTrackingControlled(workInventTrans.ItemId) || this.mustUseDimTrackingForWorkTransType(workInventTrans.ItemId, workLine.whsWorkTable().WorkTransType));
                    
                        if (!useDimTracking && dimTrackingNeeded)
                        {
                            continue;
                        }
                    }

                    if (!useDimTracking && !_assignSerial)
                    {
                        this.checkInventBatch(workInventTrans.InventDimIdFrom, workLine);

                        if (_pickCWItem)
                        {
                            if (!_transWeight)
                            {
                                // Calculate weight based off inventory values.
                                transWeightToMove = WHSCatchWeightHelper::calculateMovingWeight(workInventTrans.ItemId, workLine.inventDimWithLocation().inventDimId, qtyToMove);
                            }
                            else
                            {
                                if (multiplePickWITs)
                                {
                                    if (convertedQty == 0)
                                    {
                                        transWeightToMove = weightLeftToMove;
                                    }
                                    else
                                    {
                                        transWeightToMove = WHSCatchWeightHelper::calculateAverageWeight(qtyToMove, fullQtyToMove, _transWeight, InventTable::inventDecimals(workInventTrans.ItemId));
                                        weightLeftToMove -= transWeightToMove;
                                    }
                                }
                                else
                                {
                                    transWeightToMove = _transWeight;
                                }
                            }

                            this.adjustWorkInventTransWeight(workInventTrans, transWeightToMove, qtyToMove);
                            WHSInvent::moveWorkQuantities(workInventTrans, workInventTrans.InventDimIdFrom, inventDim.InventDimId, transWeightToMove, qtyToMove);
                        
                            totalWeightNonDimTracking = transWeightToMove;
                        }
                        else
                        {
                            WHSInvent::moveWorkQuantities(workInventTrans, workInventTrans.InventDimIdFrom, inventDim.InventDimId, qtyToMove, 0);
                        }
                    }
                    else if (_assignSerial)
                    {
                        WHSInvent::assignSerialMoveWorkQty(workInventTrans, workInventTrans.InventDimIdFrom, inventDim.InventDimId);
                    }

                    if (useDimTracking)
                    {
                        if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
                            || WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
                        {
                            this.createWorkTransFromWorkInventTrans(workInventTrans, dimTrackingQty, _userId, _targetLicensePlateId);
                        }
                        else
                        {
                            WHSWorkTrans::createFromWorkInventTrans(workInventTrans, dimTrackingQty, _userId);
                        }

                        this.createNextWorkInventTransQuantities(workLine,
                            workInventTrans,
                            dimTrackingQty,
                            totalWeightDimTracking,
                            WHSWorkLine::getNextOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType),
                            _userId,
                            false,
                            '');
                    }
                    else
                    {
                        if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
                            || WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
                        {
                            this.createWorkTransFromWorkInventTrans(workInventTrans, workInventTrans.Qty, _userId, _targetLicensePlateId);
                        }
                        else
                        {
                            WHSWorkTrans::createFromWorkInventTrans(workInventTrans, workInventTrans.Qty, _userId);
                        }

                        this.createNextWorkInventTransQuantities(workLine,
                            workInventTrans,
                            qtyToMove,
                            totalWeightNonDimTracking,
                            WHSWorkLine::getNextOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType),
                            _userId,
                            false,
                            '');
                    }

                    if (dimTrackingQty)
                    {
                        this.updateWorkLineRemainingQuantities(WHSWorkLine::find(_workId, _lineNum), dimTrackingQty, dimTrackingWeightMove);
                    }
                    else
                    {
                        this.updateWorkLineRemainingQuantities(WHSWorkLine::find(_workId, _lineNum), qtyToMove, transWeightToMove);
                    }
                }
                // End while

                if (!foundWIT)
                {
                    throw error("@WAX530");
                }

                this.updateWorkStatus(_workId, _lineNum, _userId);

                returnWorkLine = this.getFirstOpenLine(_workId, _userId);
            }

            // Update location status fields for pick location.
            WHSLocationWorkUpdater::updateLocationInfoFromPickPutWork(
                workLine.whsWorkTable().InventLocationId,
                workLine.WMSLocationId,
                WHSWorkType::Pick);

            ttscommit;
        }

        return returnWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkTransFromWorkInventTrans</Name>
				<Source><![CDATA[
    private WHSWorkTrans createWorkTransFromWorkInventTrans(
        WHSWorkInventTrans  _workInventTrans,
        Qty                 _qty,
        WHSUserId           _userId,
        WHSLicensePlateId   _targetLicensePlateId)
    {
        ttsbegin;

        WHSWorkTrans workTrans = WHSWorkTrans::initFromWorkInventTrans(_workInventTrans, _qty, _userId);

        if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
            || WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
        {
            workTrans.TargetLicensePlateId = _targetLicensePlateId;
        }

        workTrans.insert();

        ttscommit;

        return workTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickNonLicensePlateCheckDigitQtyWorkInventTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build query for work inventory transactions for non licence plate pick.
    /// </summary>
    /// <param name = "_workInventTrans">The work inventory transaction record.</param>
    /// <param name = "_workId">The work Id.</param>
    /// <param name = "_lineNum">The work line number.</param>
    /// <param name = "_itemId">The item number.</param>
    /// <returns>The qyery to work inventory transactions for non licence plate pick.</returns>
    protected SysDaQueryObject buildPickNonLicensePlateCheckDigitQtyWorkInventTransQuery(WHSWorkInventTrans _workInventTrans, WHSWorkId _workId, LineNum _lineNum, ItemId _itemId)
    {
        SysDaQueryObject workInventTransQueryObject = new SysDaQueryObject(_workInventTrans);
        workInventTransQueryObject.forUpdateHint = true;

        workInventTransQueryObject.whereClause(new SysDaEqualsExpression(
                new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, WorkId)),
                new SysDaValueExpression(_workId))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, LineNum)),
                new SysDaValueExpression(_lineNum))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_workInventTrans, fieldStr(WHSWorkInventTrans, ItemId)),
                new SysDaValueExpression(_itemId)))));

        return workInventTransQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickNonLicensePlateCheckDigitQtyDimTrackingQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build query for dimension tracking for non licence plate pick.
    /// </summary>
    /// <param name = "_dimTracking">Inventory dimension tracking.</param>
    /// <param name = "_workInventTrans">Work inventory transaction.</param>
    /// <param name = "_workId">The work Id.</param>
    /// <param name = "_lineNum">Work line number.</param>
    /// <returns>The query to  dimension tracking for non licence plate pick.</returns>
    protected SysDaQueryObject buildPickNonLicensePlateCheckDigitQtyDimTrackingQuery(WHSDimTracking _dimTracking, WHSWorkInventTrans _workInventTrans, WHSWorkId _workId, LineNum _lineNum)
    {
        SysDaQueryObject dimTrackingQueryObject = new SysDaQueryObject(_dimTracking);
        dimTrackingQueryObject.forUpdateHint = true;

        dimTrackingQueryObject.whereClause(new SysDaEqualsExpression(
                new SysDaFieldExpression(_dimTracking, fieldStr(WHSDimTracking, WorkId)),
                new SysDaValueExpression(_workId))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_dimTracking, fieldStr(WHSDimTracking, LineNum)),
                new SysDaValueExpression(_lineNum))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_dimTracking, fieldStr(WHSDimTracking, Processed)),
                new SysDaValueExpression(NoYes::No))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_dimTracking, fieldStr(WHSDimTracking, InventTransIdParent)),
                new SysDaValueExpression(_workInventTrans.InventTransIdParent))))));

        return dimTrackingQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateConvertedQtyForWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines converted inventory unit and handling quantity being moved.
    /// </summary>
    /// <param name = "_workInventTrans">The work inventory transaction.</param>
    /// <param name = "_convertedQty">Inventory handling quantity.</param>
    /// <returns>Container containing converted inventory unit and handling quantity being moved.</returns>
    protected container calculateConvertedQtyForWorkInventTrans(WHSWorkInventTrans _workInventTrans, InventHandlingQty _convertedQty)
    {
        Qty qtyToMove;

        // If the remain qty on the WIT is more than the rest of the qty that needs to be moved only take what's left to move.
        if (_convertedQty < _workInventTrans.InventQtyRemain)
        {
            qtyToMove = _convertedQty;
            _convertedQty = 0;
        }
        // If the remain qty on the WIT isn't more than the rest of the qty that needs to be moved, we'll move all the qty for the WIT
        else
        {
            qtyToMove = _workInventTrans.InventQtyRemain;
            _convertedQty -= _workInventTrans.InventQtyRemain;
        }

        return [_convertedQty, qtyToMove];
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertNonLPPickInventoryHandlingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts non license plate inventory units.
    /// </summary>
    /// <param name = "_itemId">The item Id, if present, of the work line to be executed.</param>
    /// <param name = "_handlingQty">The handling quantity to be executed.</param>
    /// <param name = "_handlingUnitId">The handling unit of measure.</param>
    /// <param name = "_workLine">The work line.</param>
    /// <returns>The converted quantity value.</returns>
    protected InventHandlingQty convertNonLPPickInventoryHandlingQuantity(ItemId _itemId, InventHandlingQty _handlingQty, WHSUOM _handlingUnitId, WHSWorkLine _workLine)
    {
        return WHSCatchWeightHelper::convertInventQuantity(_itemId, _handlingUnitId, _handlingQty, _workLine.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickNonLicensePlateCheckDigit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes part of a pick work line from a non-License plate controlled location.
    /// </summary>
    /// <param name="_workId">
    /// The work Id of the current work to be executed.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the current line of work to be executed.
    /// </param>
    /// <param name="_itemId">
    /// The item Id, if present, of the work line to be executed.
    /// </param>
    /// <param name="_qty">
    /// The qty to be executed.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure the _qty is represented in.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_inventDim">
    /// The below location dimension criteria for this work execution.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The specified target license of the work being executed.
    /// </param>
    /// <param name="_assignSerial">
    /// A Boolean that determines if the current step begin executed is assigning serial Ids to the inventory.
    /// Used for capture at picking.
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws if a suitable <c>WHSWorkInventTrans</c> is not found for execution.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Throws if a suitable <c>WHSWorkInventTrans</c> is not found for execution.
    /// </exception>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the pickNonLicensePlateCheckDigitQuantities method. Extenders should move their logic to wrap or override the pickNonLicensePlateCheckDigitQty method.', false, 30\9\2019)]
    public WHSWorkLine pickNonLicensePlateCheckDigit(
        WHSWorkId         _workId,
        LineNum           _lineNum,
        ItemId            _itemId,
        Qty               _qty,
        WHSUOM            _uom,
        WHSUserId         _userId,
        InventDim         _inventDim            = null,
        WHSLicensePlateId _targetLicensePlateId = '',
        boolean           _assignSerial         = false)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId);

        return this.pickNonLicensePlateCheckDigitQty(_workId,
                        _lineNum,
                        _itemId,
                        _qty,
                        0, // Weight variable is not relevant for non-cw enabled warehouse items
                        _uom,
                        _userId,
                        _inventDim,
                        _targetLicensePlateId,
                        _assignSerial,
                        false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodStartUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates production start parameters and runs production start up.
    /// </summary>
    /// <param name="_prodId">
    /// Production order id.
    /// </param>
    /// <param name="_qty">
    /// Start up quantity; optional.
    /// </param>
    /// <param name="_whsUserId">
    /// Warehouse worker id; optional.
    /// </param>
    /// <param name="_bomAutoConsump">
    /// The automatic BOM consumption type; optional.
    /// </param>
    public void prodStartUp(
        ProdId			_prodId,
        Qty				_qty = 0,
        WHSUserId		_whsUserId = '',
        BOMAutoConsump	_bomAutoConsump = BOMAutoConsump::FlushingPrincip)
    {
        WHSPostProdJournal::prodStartUp(_prodId, _qty, _whsUserId, _bomAutoConsump);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logProductionOrderStart</Name>
				<Source><![CDATA[
    /// <summary>
    /// Logs that a production order was started.
    /// </summary>
    /// <param name = "_prodId">
    /// The production ID that was started.
    /// </param>
    /// <param name = "_parmId">
    /// The parm ID of the production start.
    /// </param>
    /// <param name = "_userId">
    /// The warehouse worker responsible for starting the production order.
    /// </param>
    /// <param name = "_workExecuteMode">
    /// The work mode that started the production order.
    /// </param>
    public static void logProductionOrderStart(
        ProdId              _prodId,
        ParmId              _parmId,
        WHSUserId           _userId,
        WHSWorkExecuteMode  _workExecuteMode = WHSWorkExecuteMode::StartProdOrder)
    {
        WHSMobileDeviceActivityLogger::newStandard(_userId, _workExecuteMode)
                        .append(#WHSLabelFromEDT(ProdId), _prodId)
                        .append(#WHSLabelFromEDT(ParmId), _parmId)
                        .save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>putAwayToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates necessary records to put inventory in a location
    /// </summary>
    /// <param name="_workId">
    ///    Work id associated with action
    /// </param>
    /// <param name="_lineNum">
    ///    Line number of work
    /// </param>
    /// <param name="_locationId">
    ///    Location inventory id to be put into
    /// </param>
    /// <param name="_workPutFlow">
    ///    Determines if all inventory is being put down from the user
    /// </param>
    /// <param name="_userId">
    ///    User executing work
    /// </param>
    /// <param name="_sourceLicensePlateId">
    ///    Source license plate
    /// </param>
    /// <param name="_targetLicensePlateId">
    ///    Target license plate
    /// </param>
    /// <param name="_handleByLP">
    ///    A Boolean value that indicates whether to use standard put procedure or "Handle by LP" put
    /// </param>
    /// <returns>
    ///    Work line record used in put
    /// </returns>
    public WHSWorkLine putAwayToLocation(WHSWorkId     _workId,
                                  LineNum              _lineNum,
                                  WMSLocationId        _locationId,
                                  WHSWorkPutFlow       _workPutFlow,
                                  WHSUserId            _userId,
                                  WHSLicensePlateId    _sourceLicensePlateId,
                                  WHSLicensePlateId    _targetLicensePlateId,
                                  boolean              _handleByLP = false)
    {
        WhsWorkExecutePutAwayToLocation::newFromWorkExecute(this).run(_workId, _lineNum, _locationId, _workPutFlow, _userId, _sourceLicensePlateId, _targetLicensePlateId, _handleByLP);
        
        return this.getFirstOpenLine(_workId, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>putAwayToLocationConsiderDeferredPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the put operation. If deferred put is allowed the put operation is deferred.
    /// </summary>
    /// <param name = "_putParameters">The parameters for the operation.</param>
    /// <param name = "_useDeferredPutIfAllowed">true if deferred put should be used if the configuration allows it; otherwise, false.</param>
    /// <returns>The next work line that can be processed.</returns>
    public WHSWorkLine putAwayToLocationConsiderDeferredPut(
        WHSWorkPutOperationParameters   _putParameters,
        boolean                         _useDeferredPutIfAllowed)
    {
        WHSWorkDeferredPutProcessingRuleEvaluator ruleEvaluator;

        WHSInstrumentationLogger logger = WHSInstrumentationLogger::createLogger(classStr(WhsWorkExecute));

        using (var activityContext = logger.workDeferredPut().putAwayToLocationConsiderDeferredPut())
        {
            logger.logInformation(strFmt('_useDeferredPutIfAllowed: %1', _useDeferredPutIfAllowed));

            WHSWorkLine workLine = WHSWorkLine::find(_putParameters.parmWorkId(), _putParameters.parmLineNum());
            logger.logRecordInformation(workLine);

            boolean isDeferredPutRuleChecked;

            if (_useDeferredPutIfAllowed)
            {
                // If this context exists it is allowed to use deferred put processing without checking of rules
                isDeferredPutRuleChecked = WHSWorkDeferredPutProcessingSkipRuleEvaluationContext::current() ? true : false;

                ruleEvaluator = WHSWorkDeferredPutProcessingRuleEvaluator::newFromWorkLine(workLine, isDeferredPutRuleChecked);
            }

            boolean useDeferredPut = _useDeferredPutIfAllowed &&
                (isDeferredPutRuleChecked || ruleEvaluator.canUseDeferredPutProcessing(_putParameters.parmWorkPutFlow()));
        
            if (!useDeferredPut)
            {
                logger.logInformation('Not using deferred put.');
            
                WhsWorkExecutePutAwayToLocation::newFromWorkExecute(this).runFromParameters(_putParameters);
                return this.getFirstOpenLine(_putParameters.parmWorkId(), _putParameters.parmUserId());
            }
            
            logger.logInformation('Using deferred put - pre startOperationFromParameters');
            WHSWorkDeferredPutProcessingServiceController::startOperationFromParameters(_putParameters, ruleEvaluator.parmWorkOperationProcessingRule());
            logger.logInformation('Using deferred put - post startOperationFromParameters');
            
            //there are no lines that can be processed until the put complete so we do not want to throw
            return this.getFirstOpenLineNoThrow(_putParameters.parmWorkId(), _putParameters.parmUserId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOpenLineNoThrow</Name>
				<Source><![CDATA[
    private WHSWorkLine getFirstOpenLineNoThrow(
        WHSWorkId _workId,
        WHSUserId _userId)
    {
        return this.getFirstOpenLine(_workId, _userId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preparePutAwayToInventDimWithNewStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares 'to' inventory dimension for put away scenario when the status is being changed during work.
    /// </summary>
    /// <param name = "_workId">Work id associated with an action.</param>
    /// <param name = "_inventTrans">An inventory transaction affected by a put away.</param>
    /// <param name = "_locationId">Location inventory id to be put into.</param>
    /// <param name = "_targetLicensePlateId">Target license plate.</param>
    /// <param name = "_newStatusId">The status that the inventory was changed during the work.</param>
    /// <returns>A 'to' inventory dimension.</returns>
    [SysObsolete('Use WhsWorkExecutePutAwayToLocation.preparePutAwayToInventDim() instead.', false, 31\03\2019)]
    protected InventDim preparePutAwayToInventDimWithNewStatus(
        WHSWorkId           _workId,
        InventTrans         _inventTrans,
        WMSLocationId       _locationId,
        WHSLicensePlateId   _targetLicensePlateId,
        WHSInventStatusId   _newStatusId)
    {
        return WhsWorkExecutePutAwayToLocation::newFromWorkExecute(this).preparePutAwayToInventDim(_workId, _inventTrans.inventDimId, _locationId, _targetLicensePlateId, _newStatusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preparePutAwayToInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares 'to' inventory dimension for put away scenario.
    /// </summary>
    /// <param name = "_workId">Work id associated with an action.</param>
    /// <param name = "_inventTrans">An inventory transaction affected by a put away.</param>
    /// <param name = "_locationId">Location inventory id to be put into.</param>
    /// <param name="_targetLicensePlateId">Target license plate.</param>
    /// <returns>A 'to' inventory dimension.</returns>
    [SysObsolete('Use WhsWorkExecutePutAwayToLocation.preparePutAwayToInventDim() instead.', false, 31\03\2019)]
    protected InventDim preparePutAwayToInventDim(
        WHSWorkId           _workId,
        InventTrans         _inventTrans,
        WMSLocationId       _locationId,
        WHSLicensePlateId   _targetLicensePlateId)
    {
        return WhsWorkExecutePutAwayToLocation::newFromWorkExecute(this).preparePutAwayToInventDim(_workId, _inventTrans.inventDimId, _locationId, _targetLicensePlateId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>scanLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks validity of the received license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// License plate id of the received license plate.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_module">
    /// UOM structure module of the received license plate.
    /// </param>
    /// <param name="_workId">
    /// Work id of the received license plate; optional.
    /// </param>
    /// <param name="_createWork">
    /// Determines whether work header should be created or not; optional.
    /// </param>
    /// <param name="_dispositionCode">
    /// Disposition code of the received license plate; optional.
    /// </param>
    /// <param name="_containerTypeCode">
    /// The container type code; optional.
    /// </param>
    /// <returns>
    /// Next work line of the work bound to the license plate.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when license plate is invalid.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when work for license plate is not found.
    /// </exception>
    WHSWorkLine scanLicensePlate(
        WHSLicensePlateId       _licensePlateId,
        WHSUserId               _userId,
        WHSModule               _module,
        WHSWorkId               _workId = '',
        boolean                 _createWork = false,
        WHSDispositionCode      _dispositionCode = '',
        WHSContainerTypeCode    _containerTypeCode = '')
    {
        WHSWorkBuildId          workBuildId;
        InventDim               inventDim;
        WHSUOMStructure         structure;
        WHSWorkTable            workTable;
        WHSWorkLine             workLine;
        WHSWorkTrans            workTrans;
        WHSWorkLine             nextWorkLine;
        WHSWorkId               workId = _workId;
        WHSWorkLine             ret;
        LineNum                 lineNum = 1;
        
        boolean                 promptUser;

        InventLocationId currentWarehouseId  = this.getCurrentInventLocationId(_userId);

        boolean WhsWorkExecuteScanLPQueryPerfFixFlightEnabled = WhsWorkExecuteScanLPQueryPerfFixFlight::instance().isEnabled();

        ttsbegin;

        if (!workId)
        {
            WHSWorkExecuteWorkByLicensePlateSearch workByLicensePlateSearch;
            if (WhsWorkExecuteScanLPQueryPerfFixFlightEnabled)
            {
                workByLicensePlateSearch = WHSWorkExecuteWorkByLicensePlateSearch::newFromLicensePlateWarehouse(_licensePlateId, currentWarehouseId);
            }
            
            // Try find LicensePlateId on related WHSWorkTrans.
            if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
                || WHSConsumeTargetLPFromWHSWorkTransFlight::instance().isEnabled())
            {
                if (WhsWorkExecuteScanLPQueryPerfFixFlightEnabled)
                {
                    workId = workByLicensePlateSearch.findBasedOnWorkTrans();
                }
                else
                {
                    select firstonly RecId from workTable
                        where workTable.WorkStatus < WHSWorkStatus::Closed
                        join workId, LineNum from workLine
                            where workLine.WorkId == workTable.WorkId
                               && workLine.WorkStatus != WHSWorkStatus::Skipped
                        exists join workTrans
                            where workTrans.WorkId == workLine.WorkId
                                && workTrans.LineNum == workLine.LineNum
                                && workTrans.TargetLicensePlateId == _licensePlateId;
                }
            }
            else
            {
                if (WhsWorkExecuteScanLPQueryPerfFixFlightEnabled)
                {
                    workId = workByLicensePlateSearch.findBasedOnInventDim();
                }
                else
                {
                    select firstonly RecId from workTable
                        where workTable.WorkStatus < WHSWorkStatus::Closed
                        join workId, LineNum from workLine
                            where workLine.WorkId == workTable.WorkId
                               && workLine.WorkStatus != WHSWorkStatus::Skipped
                        exists join workTrans
                            where workTrans.WorkId == workLine.WorkId
                                && workTrans.LineNum == workLine.LineNum
                        exists join inventDim
                            where inventDim.InventDimId == workTrans.InventDimId
                                && inventDim.LicensePlateId == _licensePlateId;
                }
            }


            if (WhsWorkExecuteScanLPQueryPerfFixFlightEnabled)
            {
                workId = workByLicensePlateSearch.findBasedOnWork();
            }
            else
            {
                if (!workTable)
                {
                    select firstonly workTable
                        join WorkId, LineNum from workLine
                        where workTable.WorkId                  == workLine.WorkId
                            && workTable.TargetLicensePlateId   == _licensePlateId
                            && workTable.WorkStatus             <= WHSWorkStatus::InProcess
                            && workLine.WorkStatus              <= WHSWorkStatus::InProcess
                            && workTable.InventLocationId       == currentWarehouseId;

                }
            }

            if (!WhsWorkExecuteScanLPQueryPerfFixFlightEnabled)
            {
                if (workTable)
                {
                    workId = workLine.WorkId;                    
                }
            }

            if (!workId)
            {
                structure = WHSUOMStructure::findUOMStructureForScannedLicensePlate(_licensePlateId, _module, _createWork, currentWarehouseId);
                _module = structure.Module;

                if (!structure)
                {
                    throw error("@WAX691");
                }
                
                WHSWorkId structureCreatedWorkId = structure.createdReceiptWorkId();

                if (structureCreatedWorkId)
                {
                    workId = structureCreatedWorkId;
                }
                else
                {
                    wasLPWorkCreationAttempted = false;

                    if (_createWork)
                    {
                        boolean isLicensePlateReceivingHistoryEnabled = WHSLicensePlateReceivingHistory::isLicensePlateReceivingHistoryEnabled();

                        WHSWorkCreateLP workCreateLP = this.initializeWorkCreateLP(structure, _licensePlateId, _dispositionCode, _containerTypeCode, _userId);
                        workCreateLP.parmMustDelayASNCleanup(isLicensePlateReceivingHistoryEnabled);
                        workBuildId = workCreateLP.createWork();
                        wasLPWorkCreationAttempted = workCreateLP.wasWorkCreationAttempted();

                        if (wasLPWorkCreationAttempted)
                        {
                            workId = (select firstonly WorkId from whsWorkTable
                                        where whsWorkTable.WorkBuildId == workBuildId).WorkId;
                        }

                        // WHSWorkCreateLP could have changed the passed structure variable's fields.
                        structureCreatedWorkId = structure.createdReceiptWorkId();

                        if (!structureCreatedWorkId)
                        {
                            WHSUOMStructureCreatedWorkIdForScannedLicensePlateUpdater uomStructureUpdater = WHSUOMStructureCreatedWorkIdForScannedLicensePlateUpdater::construct();
                            uomStructureUpdater.parmLicensePlateId(_licensePlateId);
                            uomStructureUpdater.parmUserId(_userId);
                            uomStructureUpdater.parmModule(_module);
                            uomStructureUpdater.parmCurrentWarehouseId(currentWarehouseId);
                            uomStructureUpdater.parmLoadId(structure.LoadId);
                            uomStructureUpdater.parmWorkBuildId(workBuildId);
                            uomStructureUpdater.parmWorkId(workId);
                            uomStructureUpdater.parmWasLPWorkCreationAttempted(wasLPWorkCreationAttempted);
                            uomStructureUpdater.parmMustAddRegistrationToHistory(isLicensePlateReceivingHistoryEnabled);

                            uomStructureUpdater.updateUOMStructureCreatedWorkIdForScannedLicensePlate();
                        }

                        workCreateLP.cleanUpEmptyAsnItemsAndUomStructures();
                    }
                    
                    if (!_createWork || !wasLPWorkCreationAttempted)
                    {
                        nextWorkLine.LineNum = -100;
                        ret = nextWorkLine;
                        promptUser = true;
                        workId = ' ';
                    }
                }

                if (!workId)
                {
                    throw error("@WAX531");
                }
            }
        }

        if (!promptUser)
        {
            nextWorkLine = this.getFirstOpenLine(workId, _userId);

            if (nextWorkLine.RecId != 0)
            {
                if (nextWorkLine.whsWorkTable().TargetLicensePlateId)
                {
                    if (!this.validateLicensePlate(nextWorkLine, _licensePlateId))
                    {
                        throw error("@WAX528");
                    }

                    if (!WhsWorkExecuteScanLPQueryPerfFixFlightEnabled)
                    {
                        workTable.clear();
                    }

                    workTable = WHSWorkTable::find(nextWorkLine.WorkId);

                    if (workTable.TargetLicensePlateId ||
                        !this.isLessThanLicensePlate(_licensePlateId, workTable.InventLocationId, nextWorkLine))
                    {
                        if (this.isMoreThanLicensePlate(_licensePlateId, workTable.InventLocationId, nextWorkLine) &&
                            !workTable.TargetLicensePlateId)
                        {
                            workTable = WHSWorkTable::addTargetLicensePlate(workTable.WorkId, _licensePlateId);
                        }
                        else
                        {
                            ret = nextWorkLine;
                        }
                    }
                    else
                    {
                        nextWorkLine.AskForNewLicensePlate = NoYes::Yes;
                        ret = nextWorkLine;
                    }
                }
                else
                {
                    ret = nextWorkLine;
                }
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWHSWorkCreateLPInstance</Name>
				<Source><![CDATA[
    protected WHSWorkCreateLP createWHSWorkCreateLPInstance(WHSUOMStructure _uomStructure)
    {
        return new WHSWorkCreateLP(_uomStructure);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkCreateLP</Name>
				<Source><![CDATA[
    protected WHSWorkCreateLP initializeWorkCreateLP(WHSUOMStructure         _uomStructure,
                                                     WHSLicensePlateId       _licensePlateId,
                                                     WHSDispositionCode      _dispositionCode,
                                                     WHSContainerTypeCode    _containerTypeCode,
                                                     WHSUserId               _userId)
    {
        var workCreateLP = this.createWHSWorkCreateLPInstance(_uomStructure);
        workCreateLP.parmTargetLicensePlateId(_licensePlateId);
        workCreateLP.parmDispositionCode(_dispositionCode);
        workCreateLP.parmContainerTypeCode(_containerTypeCode);

        if (_uomStructure.Module == WHSModule::Purch)
        {
            workCreateLP.parmWorkTransType(WHSWorkTransType::Purch);
            workCreateLP.parmInventLocationId(this.getCurrentInventLocationId(_userId));
        }
        else if (_uomStructure.Module == WHSModule::Transfer)
        {
            workCreateLP.parmWorkTransType(WHSWorkTransType::TransferReceipt);
        }

        if (defaultReceivingLocationId)
        {
            workCreateLP.parmStartLocationId(defaultReceivingLocationId);
        }

        return workCreateLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventAdjustmentCreateParams</Name>
				<Source><![CDATA[
    protected WHSInventAdjustmentCreateParameters initInventAdjustmentCreateParams(
                WHSUserId           _userId,
                ItemId              _itemId,
                InventDim           _inventDim,
                InventQty           _adjustmentQty,
                InventUnitId        _adjustmentUnit,
                WHSWorkException    _shortPickWorkException)
    {
        WHSInventAdjustmentCreateParameters createAdjParams = WHSInventAdjustmentCreateParameters::construct();

        createAdjParams.WorkUserId         = _userId;
        createAdjParams.ItemId             = _itemId;
        createAdjParams.InventDim          = _inventDim;
        createAdjParams.AdjustmentQty      = _adjustmentQty;
        createAdjParams.AdjustmentUnit     = _adjustmentUnit;
        createAdjParams.WmsLocationId      = _inventDim.wmsLocationId;
        createAdjParams.InventLocationId   = _inventDim.InventLocationId;
        createAdjParams.AdjustmentTypeCode = _shortPickWorkException.DefaultAdjustmentTypeCode;
        createAdjParams.LicensePlateId     = _inventDim.LicensePlateId;
        createAdjParams.WorkCreatedBy      = WHSWorkUser::getWorkerEmployeeRecId(_userId);
        createAdjParams.InventCountingReasonCode = WHSAdjustmentType::find(_shortPickWorkException.DefaultAdjustmentTypeCode).DefaultCountingReasonCode;

        return createAdjParams;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shortPickAdjustOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust inventory out for short pick exceptions configured to adjust out.
    /// </summary>
    /// <param name="_userId">
    /// The user Id of the work performing the short pick.
    /// </param>
    /// <param name="_workLineShortPicked">
    /// The work line being short picked.
    /// </param>
    /// <param name="_inventDim">
    /// The known inventory dimensions being adjusted out.
    /// </param>
    /// <param name="_qtyBeingPicked">
    /// The quantity still being picked for the current work line.
    /// </param>
    /// <param name="_shortPickWorkException">
    /// The short pick exception configuration.
    /// </param>
    protected void shortPickAdjustOut(
        WHSUserId           _userId,
        WHSWorkLine         _workLineShortPicked,
        InventDim           _inventDim,
        InventQty           _qtyBeingPicked,
        WHSWorkException    _shortPickWorkException)
    {
        InventTable inventTable = InventTable::find(_workLineShortPicked.ItemId);

        InventHandlingQty   physicalQty = WHSInventOnHand::getWorkPhysicalInventHandlingQty(_workLineShortPicked.itemId, _inventDim.inventDimId);
        InventHandlingQty   qtyToAdjust;

        if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabled(inventTable.whsReservationHierarchy(), fieldNum(InventDim, inventBatchId)))
        {
            boolean shortPickRemoveReservation = WHSAdjustmentType::find(_shortPickWorkException.DefaultAdjustmentTypeCode).RemoveReservation;

            // this line got reduced already and balance contains an instruction to bring reservation back to
            // order committed level. That instruction is a strict requirement - while if short-pick settings allow remove
            // reservations, we should allow to reserve less.
            if (   shortPickRemoveReservation
                && _workLineShortPicked.OrderCommittedInventDimId)
            {
                // essentially by calls below we convert a request in balance from 'must' return reservation
                // on order committed level, to 'try' to remove reservation, which corresponds to short pick settings.

                InventQty qtyNotPicked = _workLineShortPicked.InventQtyRemain - _qtyBeingPicked;

                WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                    _workLineShortPicked.InventTransId,
                    _inventDim.InventDimId,
                    -qtyNotPicked,
                    WHSOrderCommittedReservationFacade::RegisterInBalance,
                    WHSOrderCommittedReservationFacade::DoNotAllowReserveReduction);

                WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                    _workLineShortPicked.InventTransId,
                    _inventDim.InventDimId,
                    qtyNotPicked,
                    WHSOrderCommittedReservationFacade::RegisterInBalance,
                    WHSOrderCommittedReservationFacade::AllowReserveReduction);
            }

            // It does not matter if current work line is flex or not - we need to remove all order-committed reservations
            // for specific item from specific location/LP since short-pick can happen on "normal" lines.
            // Remove all order-committed reservations from this inventDim - store in balance.
            WHSOrderCommittedReservationFacade::removeAllOrderCommittedReservationsOnInventDim(
                _workLineShortPicked.ItemId,
                _inventDim,
                shortPickRemoveReservation);

            WHSInventReserveQty inventReserveQty = WHSInventReserveQty::newFromParms(
                inventTable,
                _inventDim,
                _inventDim.toDimParm());

            inventReserveQty.parmUpperLevelOfMinimumCalculation(
                WhsReservationHierarchyProvider::construct().getLocationHierarchyLevel(inventTable));

            qtyToAdjust = inventReserveQty.availPhysical();
        }
        else
        {
            qtyToAdjust = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(_workLineShortPicked.ItemId, _inventDim.InventDimId, true);
        }

        // If the physical qty left after adjusting out inventory is less than the qty to be picked we must recalculate the amount to adjust
        // This can happen if LP has been specified in the dimension criteria, and other LPs in the location exists for the same item; increasing location availability.
        // Work does not reserve at the LP level so it is still deemed available by the getWorkPhysicalAvail method.
        if (physicalQty - qtyToAdjust < _qtyBeingPicked)
        {
            // We only adjust out physical inventory less the qty being picked.
            qtyToAdjust = physicalQty - _qtyBeingPicked;
        }

        if (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabled(inventTable.whsReservationHierarchy()))
        {
            using (WHSOrderCommittedReservationAdjustReservationContext context = WHSOrderCommittedReservationAdjustReservationContext::construct())
            {
                this.shortPickAdjustOutQty(
                    _userId,
                    _workLineShortPicked,
                    _inventDim,
                    qtyToAdjust,
                    _shortPickWorkException);

                List adjustReservationEntryList = context.getAdjustReservationEntryList();

                ListEnumerator adjustReservationEntryListEnumerator = adjustReservationEntryList.getEnumerator();
                while (adjustReservationEntryListEnumerator.moveNext())
                {
                    WHSOrderCommittedReservationAdjustReservationEntry adjustReservationEntry = adjustReservationEntryListEnumerator.current();

                    if (   adjustReservationEntry.getQty() > 0
                        && WHSOrderCommittedReservationFacade::hasOrderCommittedReservationsInBalance(adjustReservationEntry.getCommittingOriginInventTransId(), adjustReservationEntry.getInventDimId()))
                    {
                        WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                            adjustReservationEntry.getCommittingOriginInventTransId(),
                            adjustReservationEntry.getInventDimId(),
                            -adjustReservationEntry.getQty(),
                            WHSOrderCommittedReservationFacade::RegisterInBalance,
                            WHSOrderCommittedReservationFacade::AllowReserveReduction);

                        WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(adjustReservationEntry.getCommittingOriginInventTransId());
                        InventDimId mandatoryInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(orderCommittedReservation.ItemId, adjustReservationEntry.getInventDimId());

                        // We reduced the work line quantity and are not going to restore following quantity on order-committed level.
                        // We need to reduce transferred quantity manually in this case.
                        WHSOrderCommittedReservationFacade::updateTransferReservation(
                            orderCommittedReservation.RecId,
                            -adjustReservationEntry.getQty(),
                            mandatoryInventDimId);
                    }
                }
            }
        }
        else
        {
            this.shortPickAdjustOutQty(
                _userId,
                _workLineShortPicked,
                _inventDim,
                qtyToAdjust,
                _shortPickWorkException);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shortPickAdjustOutQty</Name>
				<Source><![CDATA[
    private void shortPickAdjustOutQty(
        WHSUserId           _userId,
        WHSWorkLine         _workLineShortPicked,
        InventDim           _inventDim,
        InventHandlingQty   _qtyToAdjust,
        WHSWorkException    _shortPickWorkException)
    {
        InventDim                       inventDim;
        InventDimParm                   inventDimParm;

        InventDimParm.initFromInventDim(_inventDim);

        UnitOfMeasureSymbol inventUnit  = WHSCatchWeightHelper::inventHandlingUnitId(_workLineShortPicked.itemId);
        boolean isItemCWEnabled      = PdsGlobal::pdsIsCWItem(_workLineShortPicked.ItemId);

        InventHandlingQty qtyToAdjust = _qtyToAdjust;
        InventHandlingQty runningQty  = _qtyToAdjust;

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_workLineShortPicked.ItemId))
        {
            InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;

            // Loop over inventory for the given dimension criteria and adjust out until the qtyToAdjust has been satisfied.
            while #InventDimSelect(inventDim, _inventDim, inventDimParm)
            join PhysicalInvent, PdsCWPhysicalInvent from inventSumUnionDeltaPhysicalQty
            where inventSumUnionDeltaPhysicalQty.InventDimId == inventDim.inventDimId
               && inventSumUnionDeltaPhysicalQty.ItemId == _workLineShortPicked.ItemId
               && ((!isItemCWEnabled
                    && inventSumUnionDeltaPhysicalQty.PhysicalInvent > 0)
                || (isItemCWEnabled
                    && inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent > 0))
            {
                if (runningQty == 0)
                {
                    break;
                }

                qtyToAdjust = isItemCWEnabled
                    ? min(runningQty, inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent)
                    : min(runningQty, inventSumUnionDeltaPhysicalQty.PhysicalInvent);

                runningQty -= qtyToAdjust;

                WHSInventAdjustmentCreateParameters createAdjParams = this.initInventAdjustmentCreateParams(
                    _userId,
                    _workLineShortPicked.itemId,
                    inventDim,
                    -qtyToAdjust,
                    inventUnit,
                    _shortPickWorkException);

                createAdjParams.InventTransId = _workLineShortPicked.InventTransId;

                createAdjParams.AdjustmentCatchWeight = WHSCatchWeightHelper::calculateDefaultWeightForPick(
                    _workLineShortPicked.itemId,
                    inventDim,
                    -qtyToAdjust,
                    InventTable::inventDecimals(_workLineShortPicked.itemId));

                WHSInventAdjustmentCreate createAdj = WHSInventAdjustmentCreate::newFromParams(createAdjParams);
                createAdj.run();
            }
        }
        else
        {
            InventSum  inventSum;

            // Loop over inventory for the given dimension criteria and adjust out until the qtyToAdjust has been satisfied.
            while #InventDimSelect(inventDim, _inventDim, inventDimParm)
            join PhysicalInvent, PdsCWPhysicalInvent from inventSum
            where inventSum.InventDimId == inventDim.inventDimId
                && inventSum.ItemId		== _workLineShortPicked.ItemId
                && inventSum.ClosedQty	== NoYes::No
                && ((!isItemCWEnabled
                    && inventSum.PhysicalInvent > 0)
                || (isItemCWEnabled
                    && inventSum.PdsCWPhysicalInvent > 0))
            {
                if (runningQty == 0)
                {
                    break;
                }

                qtyToAdjust = isItemCWEnabled
                ? min(runningQty, inventSum.PdsCWPhysicalInvent)
                : min(runningQty, inventSum.PhysicalInvent);

                runningQty -= qtyToAdjust;

                WHSInventAdjustmentCreateParameters createAdjParams = this.initInventAdjustmentCreateParams(
                                                                            _userId,
                                                                            _workLineShortPicked.itemId,
                                                                            inventDim,
                                                                            -qtyToAdjust,
                                                                            inventUnit,
                                                                            _shortPickWorkException);

                createAdjParams.InventTransId = _workLineShortPicked.InventTransId;

                createAdjParams.AdjustmentCatchWeight = WHSCatchWeightHelper::calculateDefaultWeightForPick(_workLineShortPicked.itemId,
                                                                                                    inventDim,
                                                                                                    -qtyToAdjust,
                                                                                                    InventTable::inventDecimals(_workLineShortPicked.itemId));

                WHSInventAdjustmentCreate createAdj = WHSInventAdjustmentCreate::newFromParams(createAdjParams);
                createAdj.run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shortPickLoad</Name>
				<Source><![CDATA[
    private void shortPickLoad(
        WHSWorkLine         _workLine,
        InventQty           _inventQty,
        UnitOfMeasureSymbol _inventUnit,
        boolean             _autoDecrementShipment)
    {
        WHSLoadLine loadLine;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter;

        // Check to see if there's a load, and if so decrease it's Work Created Qty
        if (_workLine.LoadLineRefRecId != 0)
        {
            ttsbegin;

            loadLine = WHSLoadLine::findbyRecId(_workLine.LoadLineRefRecId, true);
            loadLine.WorkCreatedQty -= _inventQty;

            if (_workLine.whsWorkTable().WorkTransType == WHSWorkTransType::CrossDocking)
            {
                WHSCrossDockLoadLine::updateQuantityForCrossDockLoadLine(loadLine.RecId, _workLine.InventTransOriginIdSupply, _inventQty);
    
                loadLine.CrossDockEvaluatedQuantity = max(loadLine.CrossDockEvaluatedQuantity - _inventQty, 0);
            }

            // Automatically decrement the load line if enabled.
            if (_autoDecrementShipment)
            {
                releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

                loadLine.Qty -= releasedProductUnitConverter.convert(_inventQty,
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUnit),
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(loadLine.uom),
                                                                NoYes::No,
                                                                     _workLine.ItemId,
                                                                     _workLine.InventDimId,
                                                                NoYes::No);
            }

            loadLine.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipSerialValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if serial validation can be skipped.
    /// </summary>
    /// <param name="_itemId">
    /// ItemId that need to be checked.
    /// </param>
    /// <returns>
    /// If serial validation can be skipped, return true;
    /// otherwise, return false.
    /// </returns>
    public static boolean skipSerialValidation(ItemId _itemId)
    {
        EcoResTrackingDimensionGroup ecoResTrackingDimensionGroup = EcoResTrackingDimensionGroup::find(InventTable::find(_itemId).trackingDimensionGroup());

        return !ecoResTrackingDimensionGroup.IsSerialNumberControlEnabled
            && !ecoResTrackingDimensionGroup.CaptureSerial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work line passed in is a catch weight item and verify that over picking can take place.
    /// </summary>
    /// <param name="_handlingQty">
    /// The quantity in the handling unit that is being over picked.
    /// </param>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_workTable">
    /// The work unit that is being over picked.
    /// </param>
    /// <returns>
    /// true if the work line can be over picked, otherwise an exception is thrown.
    /// </returns>
    final internal boolean validateShippingOverpickHandlingQty(
        InventHandlingQty   _handlingQty,
        WHSWorkLine         _workLine,
        WHSWorkTable        _workTable)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _workLine.ItemId))
        {
            return this.validateShippingOverpickQuantities(_handlingQty, _workLine, _workTable);
        }

        return this.validateShippingOverpick(_handlingQty, _workLine, _workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work line passed in is a catch weight item and verify that over picking can take place.
    /// </summary>
    /// <param name="_handlingQty">
    /// The quantity in the handling unit that is being over picked.
    /// </param>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_workTable">
    /// The work unit that is being over picked.
    /// </param>
    /// <returns>
    /// true if the work line can be over picked, otherwise an exception is thrown.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the validateShippingOverpickHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected boolean validateShippingOverpickQuantities(
        InventHandlingQty   _handlingQty,
        WHSWorkLine         _workLine,
        WHSWorkTable        _workTable)
    {
        // Check that overpick quantity is within allowed limit.
        boolean ret = WHSWorkExecute::validateShippingOverpickWorkTrans(_workTable.WorkTransType, _workLine, _handlingQty);

        // Check that there is sufficient quantity available to overpick on the location and above hierarchy levels.
        if (ret)
        {
            InventDim inventDimCriteria = _workLine.inventDimWithLocation();

            ret = (WHSInventOnHand::getPhysicalAvailHandlingQty(_workLine.ItemId,
                                                                inventDimCriteria,
                                                                true,
                                                                false) >= _handlingQty);

            if (!ret)
            {
                throw error("@WAX:OverPickNotEnoughInventoryErrorMessage");
            }
        }

        // If there is a container tied to the work, check that the container has room for the over picked quantity.
        if (ret && _workLine.ContainerId != '')
        {
            ret = WHSWorkExecute::validateShippingOverpickContainerItemVolumetricsHandlingQty(_handlingQty, _workLine, _workTable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify that over picking can take place.
    /// </summary>
    /// <param name="_inventQty">
    /// The quantity that is being over picked.
    /// </param>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_workTable">
    /// The work unit that is being over picked.
    /// </param>
    /// <returns>
    /// true if the work line can be over picked, otherwise an exception is thrown.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the validateShippingOverpickHandlingQty method. Extenders should move their logic to wrap or override the validateShippingOverpickQuantities method.', false, 30\9\2019)]
    public boolean validateShippingOverpick(
        InventQty       _inventQty,
        WHSWorkLine     _workLine,
        WHSWorkTable    _workTable)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workLine.ItemId);

        return this.validateShippingOverpickQuantities(_inventQty, _workLine, _workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickContainerItemVolumetricsHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an item is warehouse enabled catch weight and validates that the overpicked handling quantity can fit into the container related to the work line.
    /// </summary>
    /// <param name = "_overpickedHandlingQuantity">The handling quantity that is being over picked.</param>
    /// <param name = "_workLine">The work line that is being over picked.</param>
    /// <param name = "_workTable">The work header that is being over picked.</param>
    /// <returns>true if the overpicked handling quantity can fit into the container related to the work line; otherwise, throws an exception.</returns>
    [Hookable(false)]
    public static boolean validateShippingOverpickContainerItemVolumetricsHandlingQty(
        InventHandlingQty   _overpickedHandlingQuantity,
        WHSWorkLine         _workLine,
        WHSWorkTable        _workTable)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _workLine.ItemId))
        {
            return WHSWorkExecute::validateShippingOverpickContainerItemVolumetricsQuantitites(_overpickedHandlingQuantity, _workLine, _workTable);
        }

        return WHSWorkExecute::validateShippingOverpickContainerItemVolumetrics(_overpickedHandlingQuantity, _workLine, _workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickContainerItemVolumetricsQuantitites</Name>
				<Source><![CDATA[
    private static boolean validateShippingOverpickContainerItemVolumetricsQuantitites(
        InventHandlingQty   _overpickedHandlingQuantity,
        WHSWorkLine         _workLine,
        WHSWorkTable        _workTable)
    {
        WHSContainerLine        containerLine       = WHSContainerLine::find(_workTable.ShipmentId, _workLine.ContainerId, _workLine.InventDimId, _workLine.LoadLineRefRecId, _workLine.UnitId);
        WHSContainerTable       containerTable      = containerLine.containerTable();
        WHSContainerGroupLine   containerGroupLine  = WHSContainerGroupLine::find(containerTable.ContainerGroupId, containerTable.ContainerTypeCode);
        
        boolean physDimFit;
        boolean volumeFit;
        boolean weightFit;

        WHSContainerization containerization = new WHSContainerization();

        [physDimFit, volumeFit, weightFit] = containerization.validateVolumetricsOfEmptyContainer(containerTable, containerGroupLine, _workLine.itemKey(),_workLine.QtyWork + _overpickedHandlingQuantity, _workLine.UnitId);

        if (!(physDimFit && volumeFit && weightFit))
        {
            throw error("@WAX:OverPickVolumetricsCheckErrorMessage");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickContainerItemVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the overpicked inventory quantity can fit into the container related to the work line.
    /// </summary>
    /// <param name = "_overpickedInventoryQuantity">The inventory quantity that is being over picked.</param>
    /// <param name = "_workLine">The work line that is being over picked.</param>
    /// <param name = "_workTable">The work header that is being over picked.</param>
    /// <returns>true if the overpicked inventory quantity can fit into the container related to the work line; otherwise, throws an exception.</returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the validateShippingOverpickContainerItemVolumetricsHandlingQty method. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static boolean validateShippingOverpickContainerItemVolumetrics(
        InventQty       _overpickedInventoryQuantity,
        WHSWorkLine     _workLine,
        WHSWorkTable    _workTable)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workLine.ItemId);

        return WHSWorkExecute::validateShippingOverpickContainerItemVolumetricsQuantitites(_overpickedInventoryQuantity, _workLine, _workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the item is a warehouse enabled catch weight item and verifies that the quantity being over picked is within the acceptable overdelivery range.
    /// </summary>
    /// <param name="_workTransType">
    /// The transaction type of the work.
    /// </param>
    /// <param name="_workLine">
    /// The work line that is being overpicked.
    /// </param>
    /// <param name="_overpickHandlingQty">
    /// The additional quantity in the handling unit to be over picked.
    /// </param>
    /// <returns>
    /// true if the quantity is within an acceptable range; otherwise, an exception is thrown.
    /// </returns>
    [Hookable(false)]
    public static boolean validateShippingOverpickWorkTrans(
        WHSWorkTransType    _workTransType,
        WHSWorkLine         _workLine,
        InventHandlingQty   _overpickHandlingQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _workLine.ItemId))
        {
            return WhsWorkExecute::validateShippingOverpickWorkTransHandlingQuantity(_workTransType, _workLine, _overpickHandlingQty);
        }

        return WhsWorkExecute::validateShippingOverpickQty(_workTransType, _workLine, _overpickHandlingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickWorkTransHandlingQuantity</Name>
				<Source><![CDATA[
    private static boolean validateShippingOverpickWorkTransHandlingQuantity(
        WHSWorkTransType    _workTransType,
        WHSWorkLine         _workLine,
        InventHandlingQty   _overpickHandlingQty)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTransType);

        if (workTransactionType)
        {
            return workTransactionType.validateShippingOverpick(_workLine, _overpickHandlingQty);
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the quantity being over picked is within the acceptable overdelivery range.
    /// </summary>
    /// <param name="_workTransType">
    /// The transaction type of the work.
    /// </param>
    /// <param name="_workLine">
    /// The work line that is being overpicked.
    /// </param>
    /// <param name="_overpickInventQty">
    /// The additional quantity to be over picked.
    /// </param>
    /// <returns>
    /// true if the quantity is within an acceptable range; otherwise, an exception is thrown.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the validateShippingOverpickWorkTrans method. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static boolean validateShippingOverpickQty(
        WHSWorkTransType _workTransType,
        WHSWorkLine      _workLine,
        InventQty        _overpickInventQty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workLine.ItemId);

        return WhsWorkExecute::validateShippingOverpickWorkTransHandlingQuantity(_workTransType, _workLine, _overpickInventQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyLeft</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates remaining quantity of a work line.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the work line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work line.
    /// </param>
    /// <param name="_qty">
    /// Quantity that is reduced from remaining quantity of the work line.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the updateWorkLineRemainingQuantities method. Extenders should move their logic to wrap or override the updateWHSWorkLineRemainingQuantities method.', false, 30\9\2019)]
    public void updateQtyLeft(WHSWorkId _workId, LineNum _lineNum, Qty _qty)
    {
        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum);

        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), workLine.ItemId);

        this.updateWHSWorkLineRemainingQuantities(workLine, _qty, 0); // weight values are not relevant for non-cw enabled warehouse items
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWHSWorkLineRemainingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if updating catch weight warehouse values and updates remaining quantity of a work line.
    /// </summary>
    /// <param name="_workLine">
    /// A work line.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity that is reduced from remaining quantity of the work line.
    /// </param>
    /// <param name="_transWeight">
    /// Weight that is reduced from remaining weight of the work line.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the updateWorkLineRemainingQuantities method.
    /// </remarks>
    [Wrappable(true)]
    protected void updateWHSWorkLineRemainingQuantities(
        WHSWorkLine         _workLine,
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _transWeight)
    {
        WHSWorkLine     workLine;
        Qty             qty;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        ttsbegin;

        workLine = WHSWorkLine::find(_workLine.WorkId, _workLine.LineNum, true);

        qty = workLine.InventQtyRemain - _handlingQty;

        workLine.InventQtyRemain = qty >= 0 ? qty : 0;
        workLine.QtyRemain = releasedProductUnitConverter.convert(workLine.InventQtyRemain,
                                                             UnitOfMeasure::unitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId)),
                                                             UnitOfMeasure::unitOfMeasureIdBySymbol(workLine.UnitId),
                                                             NoYes::No,
                                                             workLine.ItemId,
                                                             workLine.InventDimId,
                                                             NoYes::No);

        WHSTransWeight newWeight = _transWeight + workLine.CapturedWeight;
        workLine.CapturedWeight = newWeight >= 0 ? newWeight : 0;

        workLine.write();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineRemainingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if updating catch weight warehouse values and updates remaining quantity of a work line.
    /// </summary>
    /// <param name="_workLine">
    /// A work line.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity that is reduced from remaining quantity of the work line.
    /// </param>
    /// <param name="_transWeight">
    /// Weight that is reduced from remaining weight of the work line.
    /// </param>
    [Hookable(false)]
    final public void updateWorkLineRemainingQuantities(
        WHSWorkLine         _workLine,
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _transWeight)
    {
        
        if (_transWeight && (!_workLine.ItemId || !PdsGlobal::pdsIsCWItem(_workLine.ItemId)))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        this.updateWHSWorkLineRemainingQuantities(_workLine, _handlingQty, _transWeight);
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates UOM structure for license plate if it is not found.
    /// </summary>
    /// <param name="_workLine">
    /// Work line to be used to populate fields of the UOM structure.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the UOM structure.
    /// </param>
    [SysObsolete("This method will not be used in future releases", false, 30\06\2018)]
    void updateStructure(WHSWorkLine _workLine, WHSLicensePlateId _licensePlateId)
    {
        WHSUOMStructure     structure;
        WHSWorkTable        workTable = WHSWorkTable::find(_workLine.WorkId);

        if (workTable)
        {
            ttsbegin;

            select firstonly forupdate structure
                where structure.LicensePlateId == _licensePlateId;

            if (structure.LicensePlateId != _licensePlateId)
            {
                structure.LicensePlateId    = _licensePlateId;
                structure.CreatedWorkId     = _workLine.WorkId;
                structure.Module            = this.getModule(workTable.WorkTransType);
                structure.ShipmentId        = workTable.ShipmentId;
                structure.uomItem           = _workLine.ItemId;
                structure.Qty               = _workLine.InventQtyRemain;
                structure.write();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWorkLinesAfterRejectedQualityCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels open Print and Custom work lines before the put line and all work lines after the put line after a quality check is rejected.
    /// </summary>
    /// <param name = "_putWorkLine">A put <c>WHSWorkLine</c> record.</param>
    [Hookable(false)]
    internal void cancelWorkLinesAfterRejectedQualityCheck(WHSWorkLine _putWorkLine)
    {
        using (var activityContext = this.instrumentationLogger().qualityCheckActivities().cancelWorkLinesAfterRejectedQualityCheck())
        {
            this.instrumentationLogger().logRecordInformation(_putWorkLine);

            ttsbegin;

            WHSWorkLine workLine;

            update_recordSet workLine
                setting WorkStatus = WHSWorkStatus::Cancelled
                where   workLine.WorkId     == _putWorkLine.WorkId
                    &&  (workLine.LineNum   > _putWorkLine.LineNum
                    ||  (workLine.LineNum    < _putWorkLine.LineNum
                    &&  workLine.WorkStatus == WHSWorkStatus::Open
                    &&  (workLine.WorkType  == WHSWorkType::Print
                    ||  workLine.WorkType   == WHSWorkType::Custom)));
    
            int cancelledWorkLines = workLine.RowCount();

            WHSWorkInventTrans workInventTrans;

            delete_from workInventTrans
                where workInventTrans.WorkId            == _putWorkLine.WorkId
                &&    workInventTrans.LineNum            > _putWorkLine.LineNum
                &&    workInventTrans.InventQtyRemain    > 0;

            ttscommit;

            this.instrumentationLogger().qualityCheckActivities().cancelledWorkLinesAfterRejectedQualityCheck(activityContext , cancelledWorkLines);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates location of the work line.
    /// </summary>
    /// <param name="_workId">
    /// Work header id of the work line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work line.
    /// </param>
    /// <param name="_locationId">
    /// New location id.
    /// </param>
    /// <param name="_userLoc">
    /// User location.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when staging location is not license plate controlled.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when location is invalid.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when new location doesn't allow mixed items and there are some items other than the current item in the work line.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when new location doesn't allow mixed status and there are some items with different status than the the current item in the work line.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when new location doesn't allow mixed batch and there are some items with different batch id than the current item in the work line.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when dock management rules are violated.
    /// </exception>
    void updateWorkLineLocation(WHSWorkId _workId, LineNum _lineNum, WMSLocationId _locationId, WMSLocationId _userLoc = '')
    {
        WHSWorkLine             workLine;
        WHSWorkTable            workTable;
        WHSWorkInventTrans      workInventTrans;
        InventSum               inventSum;
        InventDim               inventDim;
        InventLocationId        inventLocationId;
        WHSLocationProfile      locationProfile;
        WMSLocation             wmsLocation;
        InventBatchId           prevBatchId;
        WHSWorkLine             prevPicks;
        boolean                 batchEnabled;
        InventTable             inventTable;
        WHSWorkTable            tmpWorkTable;
        WHSWorkLine             tmpWorkLine;
        WHSInventStatusId       statusId;

        ttsbegin;

        workLine = WHSWorkLine::find(_workId, _lineNum, true);
        workTable = WHSWorkTable::find(workLine.WorkId);

        inventLocationId = workLine.whsWorkTable().InventLocationId;

        select firstonly locationProfile
            join wmsLocation
                where wmsLocation.LocProfileId      == locationProfile.LocProfileId
                    && wmsLocation.inventLocationId == inventLocationId
                    && wmsLocation.wMSLocationId    == _locationId;

        // If workLine is a put and there are picks after the put, than the location must be LP controlled.
        if (!workLine.validateStagingLocIsLPControlled(locationProfile))
        {
            throw error("@WAX5811");
        }

        // If workline is a final put then do extra validation.
        if (!workLine.validateFinalPutLocation(wmsLocation, locationProfile, true))
        {
            throw error("@WAX755");
        }

        // If the new location doesn't allow mixed items, check to make sure nothing is already in the location.
        if (!locationProfile.AllowMixedItems && workLine.WorkType != WHSWorkType::Pick)
        {
            if (locationProfile.EnableLocationProductDimensionSpecificMixing)
            {
                if (!WHSLocationProductDimensionMixingValidator::newFromProductAndLocation(wmsLocation, workLine.ItemId, workLine.inventDim()).validateLocationProductDimensionMixingParameters())
                {
                    throw error(strFmt("@WAX1343", _locationId));
                }
            }
            else
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    select firstonly RecId from inventSum
                    where inventSum.InventLocationId    == inventLocationId                                     &&
                          inventSum.wmsLocationId       == _locationId                                          &&
                          inventSum.ItemId              != workLine.ItemId                                      &&
                          inventSum.ClosedQty           == NoYes::No                                            &&
                          inventSum.PhysicalInvent       > 0;
                }
                else
                {
                    select firstonly RecId from inventSum
                    join inventDim
                    where inventSum.InventDimId         == inventDim.InventDimId                                &&
                          inventDim.InventLocationId    == inventLocationId                                     &&
                          inventDim.wmsLocationId       == _locationId                                          &&
                          inventSum.ItemId              != workLine.ItemId                                      &&
                          inventSum.ClosedQty           == NoYes::No                                            &&
                          inventSum.PhysicalInvent       > 0;
                }

                if (inventSum.RecId != 0)
                {
                    throw error(strFmt("@WAX1343", _locationId));
                }

                // Also check if any other open or in process work is pointed to the location
                select firstonly RecId from tmpWorkTable
                    join tmpWorkLine
                    where tmpWorkTable.WorkId               == tmpWorkLine.WorkId                                   &&
                          tmpWorkTable.WorkId               != workTable.WorkId                                     &&
                          tmpWorkTable.InventSiteId         == InventLocation::find(inventLocationId).InventSiteId  &&
                          tmpWorkTable.InventLocationId     == inventLocationId                                     &&
                          tmpWorkTable.WorkStatus           <= WHSWorkStatus::InProcess                             &&
                          tmpWorkLine.WorkStatus            <= WHSWorkStatus::InProcess                             &&
                          tmpWorkLine.WorkType              == WHSWorkType::Put                                     &&
                          tmpWorkLine.wmsLocationId         == _locationId                                          &&
                          tmpWorkLine.ItemId                != workLine.ItemId;

                if (tmpWorkTable.RecId != 0)
                {
                    throw error(strFmt("@WAX1343", _locationId));
                }
            }
        }

        // Check status mixing rules
        if (!locationProfile.AllowMixedStatus && workLine.WorkType == WHSWorkType::Put)
        {
            if (workTable.isInbound())
            {
                if (!WHSInvent::allowMixedStatus(workLine.inventDim().InventStatusId, workTable.InventLocationId, _locationId))
                {
                    throw error("@WAX3389");
                }
            }
            else
            {
                inventDim.clear();

                while select prevPicks
                join inventDim
                where prevPicks.InventDimId == inventDim.InventDimId    &&
                      prevPicks.WorkId      == workLine.WorkId          &&
                      prevPicks.LineNum      < workLine.LineNum         &&
                      prevPicks.WorkType    == WHSWorkType::Pick
                {
                    if (!statusId)
                    {
                        statusId = inventDim.InventStatusId;
                    }
                    else if (statusId != inventDim.InventStatusId)
                    {
                        statusId = '';
                        break;
                    }

                    if (!statusId || !WHSInvent::allowMixedStatus(statusId, workTable.InventLocationId, _locationId))
                    {
                        throw error("@WAX3389");
                    }
                }
            }
            inventDim.clear();
            prevPicks.clear();
        }

        // If item is batch make sure new location allows mix batch or has not other batches in the location.
        if (workLine.ItemId)
        {
            batchEnabled = InventTable::find(workLine.ItemId).whsBatchActive();
        }
        else
        {
            while select prevPicks
                join inventTable
                where prevPicks.WorkId      == workLine.WorkId      &&
                      prevPicks.LineNum      <  workLine.LineNum    &&
                      prevPicks.ItemId      == inventTable.ItemId
            {
                if (batchEnabled)
                {
                    break;
                }

                batchEnabled = inventTable.whsBatchActive();
            }
        }

        if (this.mustCheckMixedBatchesConstrain(batchEnabled, locationProfile, workLine))
        {
            if (workLine.inventDim().InventBatchId)
            {
                if (!WHSInvent::allowMixedBatch(workLine.ItemId, workLine.inventDim().InventBatchId, inventLocationId, _locationId))
                {
                    throw error(strFmt("@WAX1678", _locationId));
                }
            }
            else if (workTable.TargetLicensePlateId)
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    while select InventBatchId from inventSum
                    where inventSum.InventLocationId    == inventLocationId                                     &&
                          inventSum.wmsLocationId       == _userLoc                                             &&
                          inventSum.LicensePlateId      == workTable.TargetLicensePlateId                       &&
                          inventSum.InventBatchId       != ''                                                   &&
                          inventSum.ClosedQty           == NoYes::No                                            &&
                          inventSum.PhysicalInvent      >  0
                    {
                        if ((prevBatchId && prevBatchId != inventSum.InventBatchId) || !WHSInvent::allowMixedBatch(workLine.ItemId, inventSum.InventBatchId, inventLocationId, _locationId))
                        {
                            throw error(strFmt("@WAX1678", _locationId));
                        }

                        prevBatchId = inventSum.InventBatchId;
                    }
                }
                else
                {
                    while select InventBatchId from inventDim
                    join InventDimId, PhysicalInvent from inventSum
                    where inventDim.InventLocationId    == inventLocationId                                     &&
                          inventDim.wmsLocationId       == _userLoc                                             &&
                          inventDim.LicensePlateId      == workTable.TargetLicensePlateId                       &&
                          inventDim.InventBatchId       != ''                                                   &&
                          inventSum.ClosedQty           == NoYes::No                                            &&
                          inventSum.PhysicalInvent      >  0                                                    &&
                          inventSum.InventDimId         == inventDim.InventDimId
                    {
                        if ((prevBatchId && prevBatchId != inventDim.InventBatchId) || !WHSInvent::allowMixedBatch(workLine.ItemId, inventDim.InventBatchId, inventLocationId, _locationId))
                        {
                            throw error(strFmt("@WAX1678", _locationId));
                        }

                        prevBatchId = inventDim.InventBatchId;
                    }
                }
            }
        }

        if (workLine.OrderCommittedInventDimId
            && workLine.WorkType == WHSWorkType::Pick)
        {
            select firstonly forupdate workInventTrans
                where  workInventTrans.WorkId  == workLine.WorkId
                    && workInventTrans.LineNum == workLine.LineNum;

            Map newLocationQuantityMap = WHSOrderCommittedReservationFacade::createNewLocationQuantityMap(
                workInventTrans.ItemId,
                workInventTrans.InventDimIdFrom,
                workLine.InventQtyRemain,
                _locationId);

            // Here we have a map with InventDimId -> qty to use from there. At this point we know we have enough on-hand.
            MapEnumerator newLocationQuantityMapEnumerator = newLocationQuantityMap.getEnumerator();
            WHSWorkLine workLineLocal;
            WHSWorkInventTrans workInventTransLocal;
            UnitOfMeasureSymbol inventHandlingUnit = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);
            UnitOfMeasureSymbol workUOM;
            WHSQtyWork qtyWork;

            if (workLine.InventQtyRemain != workLine.InventQtyWork)
            {
                buf2Buf(workLine, workLineLocal);
                buf2Buf(workInventTrans, workInventTransLocal);

                this.modifyPartiallyPickedLine(workLine.WorkId, workLine.LineNum);
                this.moveRelatedEntites(workLine.WorkId, workLine.LineNum, newLocationQuantityMap.elements());

                while (newLocationQuantityMapEnumerator.moveNext())
                {
                    [qtyWork, workUOM] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(workLine.ItemId,
                                                                                        newLocationQuantityMapEnumerator.currentValue(),
                                                                                        inventHandlingUnit,
                                                                                        workLine.InventDimId);

                    this.createNewWorkLine(workLineLocal,
                                            workLineLocal.LineNum + 1,
                                            _locationId,
                                            newLocationQuantityMapEnumerator.currentValue(),
                                            workUOM,
                                            workLine.OrderCommittedInventDimId,
                                            qtyWork);

                    this.createNewWorkInventTrans(workInventTrans,
                                                  workLineLocal.LineNum,
                                                  newLocationQuantityMapEnumerator.currentKey(),
                                                  newLocationQuantityMapEnumerator.currentValue());
                }
            }
            else
            {
                if (newLocationQuantityMap.elements() == 1)
                {
                    // There is single inventory dimension which can cover required qty.
                    // Can simply "point" existing work line to the new dimensions (like in vanila case).

                    newLocationQuantityMapEnumerator.moveNext();

                    workLine.wmsLocationId = _locationId;
                    workLine.write();

                    workInventTrans.InventDimIdFrom = newLocationQuantityMapEnumerator.currentKey();
                    workInventTrans.update();
                }
                else
                {
                    // Need to update current work line with partial qty - i.e. current work line will pick from the first element in a map (not full qty).
                    newLocationQuantityMapEnumerator.moveNext();

                    workLine.wmsLocationId = _locationId;
                    [qtyWork, workUOM] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(workLine.ItemId,
                                                                                        newLocationQuantityMapEnumerator.currentValue(),
                                                                                        inventHandlingUnit,
                                                                                        workLine.InventDimId);

                    workLine.QtyWork = qtyWork;
                    workLine.QtyRemain = qtyWork;
                    workLine.UnitId = workUOM;

                    workLine.InventQtyWork = newLocationQuantityMapEnumerator.currentValue();
                    workLine.InventQtyRemain = newLocationQuantityMapEnumerator.currentValue();
                    workLine.write();

                    buf2Buf(workLine, workLineLocal);
                    buf2Buf(workInventTrans, workInventTransLocal);

                    workInventTrans.delete();

                    this.createNewWorkInventTrans(workInventTransLocal,
                                                  workLineLocal.LineNum,
                                                  newLocationQuantityMapEnumerator.currentKey(),
                                                  newLocationQuantityMapEnumerator.currentValue());

                    this.moveRelatedEntites(workLine.WorkId, workLine.LineNum, newLocationQuantityMap.elements() - 1);
                    
                    while (newLocationQuantityMapEnumerator.moveNext())
                    {
                        [qtyWork, workUOM] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(workLine.ItemId,
                                                                                            newLocationQuantityMapEnumerator.currentValue(),
                                                                                            inventHandlingUnit,
                                                                                            workLine.InventDimId);

                        this.createNewWorkLine(workLineLocal,
                                            workLineLocal.LineNum + 1,
                                            _locationId,
                                            newLocationQuantityMapEnumerator.currentValue(),
                                            workUOM,
                                            workLine.OrderCommittedInventDimId,
                                            qtyWork);

                        this.createNewWorkInventTrans(workInventTrans,
                                                      workLineLocal.LineNum,
                                                      newLocationQuantityMapEnumerator.currentKey(),
                                                      newLocationQuantityMapEnumerator.currentValue());
                    }
                }
            }

            WHSWorkLineCache::remove(workLine.WorkId);
        }
        else if (workLine.WorkType           == WHSWorkType::Pick    &&
            workLine.InventQtyRemain    != workLine.InventQtyWork)
        {
            this.overridePartialPick(workLine.WorkId, workLine.LineNum, _locationId);
        }
        else
        {
            // Check Dock Management Rules
            if (!WHSDockManagement::validateDockMgmtMixing(WMSLocation::find(_locationId, inventLocationId), workLine))
            {
                throw error("@WAX3915");
            }

            if (workLine.InventQtyRemain > 0)
            {
                // If some qty has already been put down and we are changing the location, need to split the work line.
                if (workLine.WorkType == WHSWorkType::Put
                    && workLine.InventQtyWork > workLine.InventQtyRemain)
                {
                    workLine = workLine.splitWorkLine(_locationId);
                }
                else
                {
                    workLine.wmsLocationId = _locationId;
                    workLine.write();
                }
            }

            if (this.mustUpdateWorkLineInventoryTransactionLocation(workLine))
            {
                this.updateWorkLineInventoryTransactionLocation(workLine, _locationId);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateWorkLineInventoryTransactionLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether work inventory transaction for a given work line must be updated.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <returns>true if work inventory transaction must be updated; otherwise, false.</returns>
    protected boolean mustUpdateWorkLineInventoryTransactionLocation(WHSWorkLine _workLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineInventoryTransactionLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work inventory transaction location for a given work line.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <param name = "_locationId">The new location Id.</param>
    private void updateWorkLineInventoryTransactionLocation(
        WHSWorkLine     _workLine,
        WMSLocationId   _locationId)
    {
        ttsbegin;

        WHSWorkInventTrans workInventTrans;

        while select forupdate workInventTrans
            where workInventTrans.WorkId  == _workLine.WorkId
                && workInventTrans.LineNum == _workLine.LineNum
        {
            InventDim inventDim;
            if (_workLine.WorkType == WHSWorkType::Pick)
            {
                inventDim = InventDim::find(workInventTrans.InventDimIdFrom);
                inventDim.wmsLocationId = _locationId;
                inventDim = InventDim::findOrCreate(inventDim);
                workInventTrans.InventDimIdFrom = inventDim.InventDimId;
            }
            else
            {
                inventDim = InventDim::find(workInventTrans.InventDimIdTo);
                inventDim.wmsLocationId = _locationId;
                inventDim = InventDim::findOrCreate(inventDim);
                workInventTrans.InventDimIdTo = inventDim.InventDimId;
            }

            workInventTrans.update();
        }
        
        if (_workLine.WorkType == WHSWorkType::Put && !_workLine.isLastWorkLine())
        {
            LineNum nextOppositeWorkLineNum = WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType);

            if (nextOppositeWorkLineNum)
            {
                this.updateWorkLineLocation(_workLine.WorkId, nextOppositeWorkLineNum, _locationId);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckMixedBatchesConstrain</Name>
				<Source><![CDATA[
    private boolean mustCheckMixedBatchesConstrain(
        boolean             _batchEnabled,
        WHSLocationProfile  _locationProfile,
        WHSWorkLine         _workLine)
    {
        return _batchEnabled
            && !_locationProfile.AllowMixedBatches
            && _workLine.WorkType != WHSWorkType::Pick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workProcessingTimeCalculationStrategy</Name>
				<Source><![CDATA[
    private WHSWorkProcessingTimeCalculationStrategy workProcessingTimeCalculationStrategy()
    {
        return WHSWorkTable::workProcessingTimeCalculationStrategy();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates work line status.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the work line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work line.
    /// </param>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    void updateWorkStatus(WHSWorkId _workId, LineNum _lineNum, WHSUserId _userId)
    {
        ttsbegin;

        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum, true);

        //we don't want to update lines with replenishment demand
        if (workLine && !workLine.ReplenDemand)
        {
            WHSWorkProcessingTimeCalculationStrategy workProcessingTimeCalculationStrategy;

            this.validateWorkLineStatusCanBeUpdated(workLine);

            if (!workLine.WorkInProcessUTCDateTime)
            {
                workProcessingTimeCalculationStrategy = this.workProcessingTimeCalculationStrategy();

                workLine.setStatusInProcess(workProcessingTimeCalculationStrategy);
            }

            if (workLine.InventQtyRemain == 0 && workLine.WorkStatus != WHSWorkStatus::Cancelled)
            {
                if (!workProcessingTimeCalculationStrategy)
                {
                    workProcessingTimeCalculationStrategy = this.workProcessingTimeCalculationStrategy();
                }

                workLine.setStatusClosed(workProcessingTimeCalculationStrategy);
            }

            workLine.UserId = _userId;
            workLine.write();

            if (!this.parmSkipWorkTableStatusUpdate())
            {
                using (var context = WhsWorkTableStatusUpdaterContext::newFromWorkLine(workLine))
                {
                    WHSWorkTable::updateWorkStatusFromWorkLines(_workId, _userId);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkLineStatusCanBeUpdated</Name>
				<Source><![CDATA[
    private void validateWorkLineStatusCanBeUpdated(WHSWorkLine _workLine)
    {
        WHSWorkExecuteUpdateWorkStatusContext context = WHSWorkExecuteUpdateWorkStatusContext::current();

        if (context && context.parmValidateWorkLineStatus())
        {
            switch (_workLine.WorkStatus)
            {
                case WHSWorkStatus::Closed:
                case WHSWorkStatus::Cancelled:
                    throw Error(strFmt("@WAX:WHSWorkExecuteWorkLineStatusCanBeUpdatedValidationError", _workLine.WorkStatus, _workLine.WorkId, _workLine.LineNum));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkStatusCycleCount</Name>
				<Source><![CDATA[
    void updateWorkStatusCycleCount(WHSWorkId _workId)
    {
        WHSWorkTable            workTable;
        WHSWorkLineCycleCount   workLineCycleCount;

        workTable = WHSWorkTable::find(_workId, true);

        if (workTable.RecId != 0)
        {
            select firstonly RecId from workLineCycleCount
                where workLineCycleCount.WorkId             == _workId  &&
                      workLineCycleCount.AcceptReject       == WHSAcceptReject::None;

            if (workLineCycleCount.RecId == 0)
            {
                ttsbegin;
                workTable.WorkStatus = WHSWorkStatus::Closed;
                workTable.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateChildLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a nested license plate.
    /// </summary>
    /// <param name="_workId">
    /// Work header of the work bound to license plate.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work bound to license plate.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id to be validated.
    /// </param>
    /// <returns>
    /// true if the license plate is valid, false otherwise.
    /// </returns>
    public boolean validateChildLicensePlate(
        WHSWorkId           _workId,
        LineNum             _lineNum,
        WHSLicensePlateId   _licensePlateId)
    {
        boolean ret;

        ttsbegin;

        if (WHSUOMStructureReceiptHandler::existUOMStructureForReceiptCreatedWorkIdAndLicensePlateId(_workId, _licensePlateId))
        {
            ret = this.validateLicensePlate(WHSWorkLine::find(_workId, _lineNum), _licensePlateId);
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInitialPickPackWorkId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the initial work is setup correctly.
    /// </summary>
    /// <param name="_workId">
    /// The work Id to validate.
    /// </param>
    /// <returns>
    /// A string containing an error message if work is invalid, otherwise an empty string.
    /// </returns>
    public str validateInitialPickPackWorkId(WHSWorkId _workId)
    {
        WHSWorkTable    workTable;
        str             ret;

        workTable = WHSWorkTable::find(_workId);

        switch (true)
        {
            case workTable.RecId == 0:
                ret = "@WAX613";
                break;

            case workTable.WorkStatus > WHSWorkStatus::Open:
                ret = "@WAX3756";
                break;

            case workTable.countFirstPicks() != 1:
                ret = "@WAX5584";
                break;

            case (!workTable.isWorkTransTypeOutbound()):
                ret = "@WAX677";
                break;

            default:
                ret = '';
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates license plate of a work line.
    /// </summary>
    /// <param name="_workLine">
    /// Work line.
    /// </param>
    /// <param name="_licensePlate">
    /// License plate to be validated.
    /// </param>
    /// <returns>
    /// true if the license plate is valid; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when quantity was expected on license plate, but no quantity found.
    /// </exception>
    public boolean validateLicensePlate(
        WHSWorkLine       _workLine,
        WHSLicensePlateId _licensePlate)
    {   
        boolean ret = true;

        ttsbegin;

        WHSWorkLine workLine = _workLine;
        WHSWorkTable workTable = workLine.whsWorkTable();

        // Production or kanban
        if (workTable.WorkTransType     == WHSWorkTransType::ProdPick
            || workTable.WorkTransType  == WHSWorkTransType::KanbanPick)
        {
            ret = this.validateLicensePlateForProductionPick(workTable, workLine, _licensePlate);
            if (!ret)
            {
                throw error("@WAX894");
            }
        }
        else    // Not Production, kanban
        {
            if (workLine.LineNum == 1
                &&    (workTable.WorkTransType == WHSWorkTransType::TransferReceipt
                    || workTable.WorkTransType == WHSWorkTransType::ReturnOrder
                    || workTable.WorkTransType == WHSWorkTransType::QualityInQualityCheck
                    || workTable.WorkTransType == WHSWorkTransType::QualityItemSampling
                    || workTable.WorkTransType == WHSWorkTransType::QualityOrder
                    || WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType).isForExternalInboundShipment()))
            {
                ret = true;
            }
            else
            {
                boolean isNonPackedContainerPickingWithLicensePlateLevelZero = workTable.WorkTransType != WHSWorkTransType::PackedContainerPicking
                    && WHSLicensePlate::find(_licensePlate).LicensePlateLevel == 0;

                boolean isPackedContainerPickingWithNonParentLicensePlate = workTable.WorkTransType == WHSWorkTransType::PackedContainerPicking
                            && !WHSLicensePlate::isParentLicensePlate(_licensePlate);

                WHSWorkInventTrans workInventTrans;
                InventDim inventDim;

                if (isNonPackedContainerPickingWithLicensePlateLevelZero
                    || isPackedContainerPickingWithNonParentLicensePlate)
                {
                    while select workInventTrans
                        where workInventTrans.WorkId    == workLine.WorkId
                            && workInventTrans.LineNum  == workLine.LineNum
                    {
                        inventDim = InventDim::find(workInventTrans.InventDimIdFrom);
                        inventDim.LicensePlateId = _licensePlate;
                        inventDim = InventDim::findOrCreate(inventDim);

                        if (!WHSInventOnHand::getWorkPhysicalInventHandlingQty(workInventTrans.ItemId, inventDim.InventDimId))
                        {
                            ret = false;
                            break;
                        }
                    }
                }
                else
                {
                    inventDim = InventDim::find(_workLine.InventDimId);
                    inventDim.wmsLocationId = _workLine.wmsLocationId;

                    Map itemQtyTotals = new Map(Types::String, Types::Real);

                    if (!workLine.ItemId)
                    {
                        if (workTable.WorkTransType == WHSWorkTransType::PackedContainerPicking)
                        {
                            WhsWorkExecute::createQuantityMapFromParentLicensePlate(itemQtyTotals, _licensePlate, inventDim);
                        }
                        else
                        {
                            this.buildQtyLicensePlate(itemQtyTotals, _licensePlate, inventDim);
                        }

                        while select ItemId, InventDimIdFrom, Qty from workInventTrans
                            where workInventTrans.WorkId    == _workLine.WorkId &&
                                  workInventTrans.LineNum   == _workLine.LineNum
                        {
                            inventDim.clear();
                            EcoResProductDimGroupSetup::copyProductDimensionsForItem(workInventTrans.ItemId, InventDim::find(workInventTrans.InventDimIdFrom), inventDim);
                            inventDim = InventDim::findOrCreate(inventDim);
                            str key = workInventTrans.ItemId + inventDim.InventDimId;
                            if (itemQtyTotals.exists(key))
                            {
                                Qty qty = itemQtyTotals.lookup(key);
                                qty -= workInventTrans.Qty;

                                if (qty < 0)
                                {
                                    ret = false;
                                    break;
                                }

                                if (qty == 0)
                                {
                                    itemQtyTotals.remove(key);
                                }
                                else
                                {
                                    itemQtyTotals.insert(key, qty);
                                }
                            }
                            else
                            {
                                ret = false;
                                break;
                            }
                        }

                        if (ret)
                        {
                            if (itemQtyTotals.elements() != 0)
                            {
                                ret = false;
                            }
                        }
                    }
                }
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipLicensePlateValidation</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean mustSkipLicensePlateValidation(WHSWorkTransType _workTransType)
    {
        return _workTransType == WHSWorkTransType::Purch
            || _workTransType == WHSWorkTransType::TransferReceipt
            || _workTransType == WHSWorkTransType::ReturnOrder
            || _workTransType == WHSWorkTransType::QualityInQualityCheck
            || _workTransType == WHSWorkTransType::QualityItemSampling
            || _workTransType == WHSWorkTransType::QualityOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLicensePlateForProductionPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates license plate of a production pick work line.
    /// </summary>
    /// <param name="_workTable">
    /// Work line.
    /// </param>
    /// <param name="_workLine">
    /// Work line.
    /// </param>
    /// <param name="_licensePlate">
    /// License plate to be validated.
    /// </param>
    /// <returns>
    /// true if the license plate is valid; otherwise, false.
    /// </returns>
    private boolean validateLicensePlateForProductionPick(
        WHSWorkTable        _workTable,
        WHSWorkLine         _workLine,
        WHSLicensePlateId   _licensePlate)
    {
        boolean ret = true;

        if (_workTable.WorkTransType     != WHSWorkTransType::ProdPick
            && _workTable.WorkTransType  != WHSWorkTransType::KanbanPick)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Check to see if there's anything reserved on this license plate.
        this.checkLicensePlateReservations(_workLine.WorkId,
                                           _workTable.InventLocationId,
                                           _workTable.InventSiteId,
                                           _workLine.wmsLocationId,
                                           _licensePlate);

        // Check to make sure there is quantity on the license plate
        WHSWorkInventTrans workInventTrans;
        while select ItemId from workInventTrans
            group by ItemId
            where workInventTrans.WorkId        == _workLine.WorkId
                  && workInventTrans.LineNum    == _workLine.LineNum
        {
            var qty = WHSInvent::getQtyOnLicensePlate(_licensePlate,
                                                      workInventTrans.ItemId,
                                                      _workLine.InventDimId,
                                                      _workLine.wmsLocationId);

            if (!qty)
            {
                ret = false;
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLicensePlateInSystem</Name>
				<Source><![CDATA[
    boolean validateLicensePlateInSystem(WHSLicensePlateId _licensePlateId)
    {
        return WHSLicensePlate::find(_licensePlateId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLocationChange</Name>
				<Source><![CDATA[
    boolean validateLocationChange(InventLocationId _inventLocationId,
                                   WMSLocationId _locationId,
                                   ItemId _itemId,
                                   WHSWorkLine _workLine = null)
    {
        WHSPutLocationChangeCheck locationCheck = WHSPutLocationChangeCheck::newFromParameters(
            _inventLocationId,
            _locationId,
            _itemId,
            _workLine);

        return locationCheck.checkLocation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMovementLPQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that quantity moved by license plate matches with on hand inventory.
    /// </summary>
    /// <param name="_inventDim">
    /// Inventory dimensions of the moved item.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_qty">
    /// Moved quantity.
    /// </param>
    /// <param name="_unitId">
    /// UOM of the moved quantity.
    /// </param>
    /// <returns>
    /// true if the quantity is valid, false otherwise.
    /// </returns>
    boolean validateMovementLPQty(
        InventDim                   _inventDim,
        ItemId                      _itemId,
        Qty                         _qty,
        UnitOfMeasureSymbol         _unitId)
    {
        InventDim           inventDim;
        InventHandlingQty   convertedHandlingQty;
        InventHandlingQty   handlingQty;

        inventDim = InventDim::find(_inventDim.InventDimId);
        inventDim.InventSiteId      = InventLocation::find(inventDim.InventLocationId).InventSiteId;
        inventDim = InventDim::findOrCreate(inventDim);

        convertedHandlingQty    = WHSCatchWeightHelper::convertInventQuantity(_itemId, _unitId, _qty, _inventDim.inventDimId);
        handlingQty             = WHSInventOnHand::getWorkPhysicalInventHandlingQty(_itemId, inventDim.InventDimId);

        return handlingQty == convertedHandlingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoSerialInventoryLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that there is no serial inventory for the given license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate value to validate against.
    /// </param>
    /// <param name="_workLine">
    /// The work record that has the item and other needed fields.
    /// </param>
    /// <returns>
    /// true if there is no serial inventory; otherwise false.
    /// </returns>
    /// <remarks>
    /// In this method false is returned when inventory is found because finding inventory is considered
    /// the invalid scenario.
    /// </remarks>
    public boolean validateNoSerialInventoryLP(WHSLicensePlateId _licensePlateId, WHSWorkLine _workLine)
    {
        boolean            ret = true;
        InventSum          inventSum;
        WHSRFWhenToCapture whenToCapture;

        if (WHSWorkExecute::skipSerialValidation(_workLine.ItemId))
        {
            return true;
        }

        whenToCapture = WHSInventTable::captureSerial(_workLine.ItemId);

        if (!WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum)
            && (whenToCapture == WHSRFWhenToCapture::Picking
            || whenToCapture  == WHSRFWhenToCapture::Packing))
        {
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                select firstonly RecId from inventSum
                where inventSum.ClosedQty      == NoYes::No &&
                      inventSum.PhysicalInvent  > 0 &&
                      inventSum.LicensePlateId   == _licensePlateId &&
                      inventSum.InventSerialId    != '';
            }
            else
            {
                InventDim          inventDim;

                select firstonly RecId from inventSum
                where inventSum.ClosedQty      == NoYes::No &&
                      inventSum.PhysicalInvent  > 0
                exists join inventDim
                    where inventSum.InventDimId    == inventDim.InventDimId &&
                        inventDim.LicensePlateId   == _licensePlateId &&
                        inventDim.InventSerialId    != '';
            }

            if (inventSum.RecId != 0)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoSerialInventoryNonLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that there is no serial inventory for the specified dimensions.
    /// </summary>
    /// <param name="_workLine">
    /// The work record that has the item and inventory dimensions.
    /// </param>
    /// <param name="_inventDim">
    /// Another <c>InventDim</c> record to be compared to the work inventory dimensions.
    /// </param>
    /// <returns>
    /// true if there is no serial inventory; otherwise false.
    /// </returns>
    /// <remarks>
    /// In this method false is returned when inventory is found because finding inventory is considered
    /// the invalid scenario.
    /// </remarks>
    public boolean validateNoSerialInventoryNonLP(WHSWorkLine _workLine, InventDim _inventDim)
    {
        boolean            ret = true;
        InventDim          inventDim;
        InventDim          inventDimCriteria;
        InventDimParm      inventDimParm;
        InventSum          inventSum;
        WHSRFWhenToCapture whenToCapture;

        if (WHSWorkExecute::skipSerialValidation(_workLine.ItemId))
        {
            return true;
        }

        whenToCapture = WHSInventTable::captureSerial(_workLine.ItemId);

        if (  (whenToCapture == WHSRFWhenToCapture::Picking
            || whenToCapture  == WHSRFWhenToCapture::Packing)
            && !WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum))
        {
            // Set inventDim criteria and ensure that serial values are not set so
            // the select statement can check if any serial inventory exists.
            inventDimCriteria.data(InventDim::find(_workLine.InventDimId, true));
            inventDimCriteria.mergeUsedDim(InventDimGroupSetup::newItemId(_workLine.ItemId), _inventDim);
            inventDimCriteria.InventSerialId = '';
            inventDimParm.initFromInventDim(inventDimCriteria);

            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                select firstonly RecId from inventSum
                    where inventSum.ItemId          == _workLine.ItemId &&
                          inventSum.ClosedQty       == NoYes::No &&
                          inventSum.PhysicalInvent   >  0 &&
                          #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm) &&
                inventSum.InventSerialId != '';
            }
            else
            {
                select firstonly RecId from inventSum
                    where inventSum.ItemId          == _workLine.ItemId &&
                          inventSum.ClosedQty       == NoYes::No &&
                          inventSum.PhysicalInvent   >  0
                    #InventDimExistsJoin(inventSum.InventDimId, inventDim, inventDimCriteria, inventDimParm) &&
                inventDim.InventSerialId != '';
            }

            if (inventSum.RecId != 0)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePickPackGrouping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the values on the new and original work to validate if all values are correct.
    /// </summary>
    /// <param name="_sourceWorkId">
    /// The work Id of the original work.
    /// </param>
    /// <param name="_newWorkId">
    /// The work Id of the new work.
    /// </param>
    /// <returns>
    /// A string value containing an error message if the new work is invalid, or an empty string if it is valid.
    /// </returns>
    public str validatePickPackGrouping(WHSWorkId _sourceWorkId, WHSWorkId _newWorkId)
    {
        WHSWorkTable    sourceWorkTable;
        WHSWorkTable    newWorkTable;
        WHSWorkLine     sourceWorkLine;
        WHSWorkLine     newWorkLine;
        LineNum         sourcePutLineNum;
        LineNum         newPutLineNum;
        boolean         workIsSame;
        str             ret;

        sourceWorkTable = WHSWorkTable::find(_sourceWorkId);
        newWorkTable = WHSWorkTable::find(_newWorkId);

        switch (true)
        {
            case _sourceWorkId == _newWorkId:
                ret = "@WAX5585";
                break;

            case newWorkTable.WorkStatus > WHSWorkStatus::Open:
                ret = "@WAX3756";
                break;

            // Validate that they're on the same load.
            case sourceWorkTable.LoadId != newWorkTable.LoadId:
                ret = "@WAX5588";
                break;

            case sourceWorkTable.OrderNum != newWorkTable.OrderNum:
                ret = "@WAX5587";
                break;

            case (!(newWorkTable.InventSiteId      == sourceWorkTable.InventSiteId
                && newWorkTable.InventLocationId == sourceWorkTable.InventLocationId)):
                ret = "@WAX5589";
                break;

            case (newWorkTable.countFirstPicks() != 1):
                ret = "@WAX5586";
                break;

            // Replenishment is part of item related picking, but is an exception for this check,
            // therefore this edge case must be handled differently.
            case (!WhsWorkTransactionType::singletonFromTypeOrDefault(newWorkTable.workTransType).isItemRelatedPicking()
                    || newWorkTable.WorkTransType == WHSWorkTransType::Replenishment):
                    ret = "@WAX677";
                    break;

            default:
                ret = '';
        }

        // Validate that the Work is the same.
        if (ret == '')
        {
            newPutLineNum = WHSWorkLine::getNextOppositeWorkLine(newWorkTable.WorkId, 1, WHSWorkType::Pick);
            sourcePutLineNum = WHSWorkLine::getNextOppositeWorkLine(sourceWorkTable.WorkId, 1, WHSWorkType::Pick);

            while select wmsLocationId, WorkType, WorkStop, Mandatory from sourceWorkLine
                where sourceWorkLine.WorkId     == _sourceWorkId &&
                      sourceWorkLine.LineNum    >= sourcePutLineNum
            {
                select firstonly wmsLocationId, WorkType, WorkStop, Mandatory from newWorkLine
                    where newWorkLine.WorkId    == _newWorkId   &&
                          newWorkLine.LineNum   == newPutLineNum;

                workIsSame = sourceWorkLine.wmsLocationId  == newWorkLine.wmsLocationId    &&
                             sourceWorkLine.WorkType       == newWorkLine.WorkType         &&
                             sourceWorkLine.WorkStop       == newWorkLine.WorkStop         &&
                             sourceWorkLine.Mandatory      == newWorkLine.Mandatory;

                if (!workIsSame)
                {
                    ret = "@WAX5590";
                    break;
                }

                ++newPutLineNum;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOverPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which validates the inventory on a license plate to be picked in order to determine if we are overpicking.
    /// </summary>
    /// <param name="_workLine">
    /// The current work line being executed
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate being picked.
    /// </param>
    /// <returns>
    /// true if license plate will be overpicked; otherwise false
    /// </returns>
    public static boolean validateOverPick(
        WHSWorkLine         _workLine,
        WHSLicensePlateId   _licensePlateId)
    {
        InventSum       inventSum;
        InventDim       inventDim;
        InventDim       inventDimCriteria;
        InventDimParm   inventDimParm;
        WHSWorkTable    workTable = _workLine.whsWorkTable();
        boolean         ret;

        // Only overpick for initial production raw materials picking work lines
        if (WHSWorkExecute::isPotentialOverPick(workTable, _workLine, _licensePlateId))
        {
            InventHandlingQty physicalInventHandlingQtyOnLPByItemAndDimensions =
                WhsWorkExecute::getTotalQtyOnLicensePlateByItemAndDimensions(_workLine, _licensePlateId);

            ret = (physicalInventHandlingQtyOnLPByItemAndDimensions > _workLine.InventQtyRemain
                    && physicalInventHandlingQtyOnLPByItemAndDimensions == WHSInvent::calculateHandlingQtyOnLicensePlate(_licensePlateId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickLicensePlateHandledByLPWhsInventoryTransaction</Name>
				<Source><![CDATA[
    private WHSWorkLine pickLicensePlateHandledByLPWhsInventoryTransaction(
        WHSWorkId           _workId,
        LineNum             _lineNum,
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _locationId,
        WHSUserId           _userId,
        boolean             _skipSelectOnLocatedLP = false)
    {
        container executePick(
            WHSWorkInventTrans _pickWorkInventTrans,
            InventSum _inventSum,
            InventQty _qtyRemainToBePicked,
            InventDimId _pickDimId)
        {
            InventQty qtyToPick;
            PdsCWInventQty qtyToPickCW;
            [qtyToPick, qtyToPickCW] = this.getIssueWorkTransQuantitiesForPick(_pickWorkInventTrans, _inventSum, _qtyRemainToBePicked);


            InventDim pickInventDim = InventDim::find(_pickDimId);
            InventDim inventDimTo = pickInventDim.data();
            inventDimTo.wmsLocationId = _userId;
            inventDimTo = InventDim::findOrCreate(inventDimTo);

            WHSInventoryTransactionWorkController::construct().moveSpecificQty(
                                _pickWorkInventTrans,
                                pickInventDim,
                                inventDimTo,
                                qtyToPick,
                                qtyToPickCW);

            return [qtyToPick, qtyToPickCW];
        }

        InventQty qtyPicked = 0;
        
        LineNum nextPutWorkLineNum = WHSWorkLine::getNextOppositeWorkLine(_workId, _lineNum, WHSWorkType::Pick);

        if (nextPutWorkLineNum == 0)
        {
            throw error("@WAX1349");
        }

        boolean handleByLPCreateWorkDimTrackingFlight = WHSWorkExecuteHandleByLPCreateWorkDimTrackingV2Flight::instance().isEnabled();

        ttsbegin;

        Query query	= this.pickWorkLineHandleByLPQuery(_workId, nextPutWorkLineNum, _licensePlateId, _skipSelectOnLocatedLP);
        QueryRun queryRun = new QueryRun(query);

        // Remove inventory from Picking location
        while (queryRun.next())
        {
            WHSWorkLine pickWorkLine = queryRun.get(tableNum(WHSWorkLine));

            if (queryRun.changed(tableNum(WHSWorkLine)))
            {
                // Target LP is explicitly assigned by calling ensureTargetLicensePlateOnWork once all pick work lines are processed.
                const boolean skipAddingTargetLP = true;
                this.validateAndUpdatePickWorkLineHandledByLP(pickWorkLine, _locationId, _licensePlateId, _userId, skipAddingTargetLP);
            }

            WHSWorkInventTrans pickWorkInventTrans = queryRun.get(tableNum(WHSWorkInventTrans));

            if (PdsGlobal::pdsIsCWItem(pickWorkInventTrans.ItemId) && !this.canPickByLicensePlateForCWItems())
            {
                throw error(strFmt("@WAX:Error_PickByLicensePlateNotSupportedForCWItems", pickWorkInventTrans.ItemId));
            }

            InventQty qtyRemainToBePicked = pickWorkInventTrans.Qty;

            // Build a merged InventDim with all above location dims as well as location and license plate
            InventDim inventDimPick = InventDim::find(pickWorkInventTrans.InventDimIdFrom);
            inventDimPick.wmsLocationId = _locationId;
            inventDimPick.LicensePlateId = _licensePlateId;
            inventDimPick = InventDim::findOrCreate(inventDimPick);

            InventDimParm inventDimParm;
            inventDimParm.initFromInventDim(inventDimPick);

            InventQty qtyPickedForDim;
            PdsCWInventQty qtyPickedForDimCW;
            InventQty qtyPickedByPickWorkInventTrans = 0;
            PdsCWInventQty cwQtyPickedByPickWorkInventTrans = 0; // cw items are supported only if customer extends canPickByLicensePlateForCWItems

            if (handleByLPCreateWorkDimTrackingFlight)
            {
                InventDim inventDimPickForTracking;
                inventDimPickForTracking.data(inventDimPick);
                inventDimPickForTracking.InventStatusId = '';
                inventDimPickForTracking = InventDim::findOrCreate(inventDimPickForTracking);

                boolean overPicking = WHSWorkExecute::validateOverPick(pickWorkLine, _licensePlateId);

                this.createWorkDimTrackingEntries(pickWorkLine, inventDimPickForTracking, 0, overPicking);
            }

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                // Take everything we can find on inventsum and pick based on the exact dimensions, this will include serial/batch numbers
                InventSum inventSum;

                while select inventSum
                    where inventSum.ItemId == pickWorkInventTrans.ItemId
                        && inventSum.PhysicalInvent > 0
                        && inventSum.ClosedQty == NoYes::No
                        && #InventDimFieldsFilter(inventSum, inventDimPick, inventDimParm)
                {
                    this.applyExistingInventSumDeltaThatCouldMovedLP(inventSum);

                    // Deltas might have impacted physical invent and we need to account for that
                    if (inventSum.PhysicalInvent > 0)
                    {
                        [qtyPickedForDim, qtyPickedForDimCW] = executePick(pickWorkInventTrans, inventSum, qtyRemainToBePicked, inventSum.InventDimId);

                        qtyPickedByPickWorkInventTrans += qtyPickedForDim;
                        cwQtyPickedByPickWorkInventTrans += qtyPickedForDimCW;

                        qtyRemainToBePicked -= qtyPickedForDim;
                        qtyPicked += qtyPickedForDim;

                        if (qtyRemainToBePicked <= 0)
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                // Take everything we can find on inventsum and pick based on the exact dimensions, this will include serial/batch numbers
                InventSum inventSum;
                InventDim inventDimJoin;

                while select inventSum
                    where inventSum.ItemId == pickWorkInventTrans.ItemId
                        && inventSum.PhysicalInvent > 0
                        && inventSum.ClosedQty == NoYes::No
                    #InventDimInnerJoin(inventSum.inventDimId, inventDimJoin, inventDimPick, inventDimParm)
                {
                    this.applyExistingInventSumDeltaThatCouldMovedLP(inventSum);

                    // Deltas might have impacted physical invent and we need to account for that
                    if (inventSum.PhysicalInvent > 0)
                    {
                        [qtyPickedForDim, qtyPickedForDimCW] = executePick(pickWorkInventTrans, inventSum, qtyRemainToBePicked, inventDimJoin.InventDimId);
                            
                        qtyPickedByPickWorkInventTrans += qtyPickedForDim;
                        cwQtyPickedByPickWorkInventTrans += qtyPickedForDimCW;

                        qtyRemainToBePicked -= qtyPickedForDim;
                        qtyPicked += qtyPickedForDim;

                        if (qtyRemainToBePicked <= 0)
                        {
                            break;
                        }
                    }
                }
            }

            using (var context = WhsInventoryTransactionLicensePlateHandledByLPContext::construct())
            {
                InventDim inventDimSpecific = inventDimPick.data();
                inventDimSpecific.wmsLocationId = _userId;
                // Even if there is batch-below reservation (below the LP), we don't carry over the specific reservation of it to the user location.
                this.clearInventDimBelowLicensePlate(pickWorkInventTrans.ItemId, inventDimSpecific);
                inventDimSpecific = InventDim::findOrCreate(inventDimSpecific);

                this.createNextWorkInventTransQuantities(
                    pickWorkLine,
                    pickWorkInventTrans,
                    qtyPickedByPickWorkInventTrans,
                    cwQtyPickedByPickWorkInventTrans,
                    nextPutWorkLineNum,
                    _userId,
                    false,
                    inventDimSpecific.InventDimId);
            }

            // once all the dimensions are pushed to the inventory transactions then update the entire qty
                
            InventQty workInventTransQty;
            PdsCWInventQty cwQty;
            [workInventTransQty, cwQty]  = this.getWorkQuantitiesForPick(pickWorkInventTrans);

            if (this.parmUseInsertListForWorkTrans())
            {
                this.addNewWorkTransToInsertList(pickWorkLine, inventDimPick.InventDimId, pickWorkInventTrans.Qty, _userId, _licensePlateId);
            }
            else
            {
                this.initNewWorkTrans(pickWorkLine, inventDimPick.InventDimId, pickWorkInventTrans.Qty, _userId, _licensePlateId).insert();
            }

            if (qtyRemainToBePicked > 0)
            {
                throw error(strFmt("@SYS54900", pickWorkLine.QtyRemain, StatusIssue::OnOrder, StatusIssue::ReservOrdered, StatusIssue::ReservPhysical));
            }

            this.updateWorkLineRemainingQuantities(pickWorkLine, workInventTransQty, cwQty);
            this.updateWorkStatus(pickWorkLine.WorkId, pickWorkLine.LineNum, _userId);

            this.updateDimTrackingToProcessed(pickWorkInventTrans);
        }

        this.ensureTargetLicensePlateOnWork(_workId, _licensePlateId);

        this.ensureEntireLicensePlateIsPicked(_workId, _licensePlateId, qtyPicked);

        WHSLicensePlate::removeFromParentLP(_licensePlateId);

        ttscommit;

        return this.getFirstOpenLine(_workId, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearInventDimBelowLicensePlate</Name>
				<Source><![CDATA[
    private void clearInventDimBelowLicensePlate(ItemId _itemId, InventDim _inventDim)
    {
        WHSReservationHierarchyProvider reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();

        Enumerator enumerator = reservationHierarchyProvider.getDimListBelowLicensePlate(
                                    InventTable::find(_itemId),
                                    WHSReservationHierarchySortOrder::TopDown)
                                .getEnumerator();

        while (enumerator.moveNext())
        {
            WHSReservationHierarchyElementData elementData = enumerator.current();
            _inventDim.clearField(elementData.parmDimensionFieldId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyExistingInventSumDeltaThatCouldMovedLP</Name>
				<Source><![CDATA[
    private void applyExistingInventSumDeltaThatCouldMovedLP(InventSum _inventSum)
    {
        // Existing inventSumDelta records may have already moved this LP
        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_inventSum.ItemId))
        {
            _inventSum.applyInventSumDeltaQuantitiesForSqlTransaction(InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureEntireLicensePlateIsPicked</Name>
				<Source><![CDATA[
    private void ensureEntireLicensePlateIsPicked(WHSWorkId _workId, WHSLicensePlateId _licensePlateId, InventQty _qtyPicked)
    {
        if (_qtyPicked != WHSLicensePlate::getTotalHandlingQtyOnLicensePlate(_licensePlateId))
        {
            throw error(strFmt("@WAX:WorkCanNotCompleteNoEntireLicensePlate", _workId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndUpdatePickWorkLineHandledByLP</Name>
				<Source><![CDATA[
    private void validateAndUpdatePickWorkLineHandledByLP(
        WHSWorkLine _pickWorkLine,
        WMSLocationId _locationId,
        WHSLicensePlateId _licensePlateId,
        WHSUserId _userId,
        boolean _skipAddingTargetLP = false)
    {
        if (_pickWorkLine.wmsLocationId && _pickWorkLine.wmsLocationId != _locationId)
        {
            throw error("@WAX755");
        }

        // Validate that there is enough non-serial inventory to pick.
        if (!this.validateNoSerialInventoryLP(_licensePlateId, _pickWorkLine))
        {
            throw error("@WAX5563");
        }

        this.updateWorkStatus(_pickWorkLine.WorkId, _pickWorkLine.LineNum, _userId);

        WHSWorkTable workTable = WHSWorkTable::find(_pickWorkLine.WorkId);

        //Fill the target LP if it is empty and work is Transfer Issue or Sales picking.
        //It is used for cross docking process to create ASN for the transfer order receiving process
        if (!_skipAddingTargetLP && this.allowAssignTargetLPToWorkTableHandledByLP(workTable, _pickWorkLine, _licensePlateId))
        {
            WHSWorkTable::addTargetLicensePlate(_pickWorkLine.WorkId, _licensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickLicensePlateHandledByLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks goods from the inventory based on work and license plate and puts them to user location by using "Handles by LP" strategy
    /// Removes link between the license plate and parent license plate.
    /// </summary>
    /// <param name="_workId">
    /// The work Id of the current work to be executed.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the current line of work to be started from.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate being picked.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID to pick from.
    /// </param>
    /// <param name="_userId">
    /// The Id of the user executing the work.
    /// </param>
    /// <param name="_skipSelectOnLocatedLP">
    /// Skip select on selected LP.
    /// </param>
    /// <returns>
    /// The first open workline for the work being executed.
    /// </returns>
    public WHSWorkLine pickLicensePlateHandledByLP(
        WHSWorkId           _workId,
        LineNum             _lineNum,
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _locationId,
        WHSUserId           _userId,
        boolean             _skipSelectOnLocatedLP = false)
    {
        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workId))
        {
            return this.pickLicensePlateHandledByLPWhsInventoryTransaction(_workId, _lineNum, _licensePlateId, _locationId, _userId, _skipSelectOnLocatedLP);
        }

        InventQty           qtyPicked = 0;
        LedgerVoucher       ledgerVoucher = null;
        Map                 costAmountMap = new Map(Types::Integer, Types::Real);

        LineNum nextPutWorkLineNum = WHSWorkLine::getNextOppositeWorkLine(_workId, _lineNum, WHSWorkType::Pick);

        if (nextPutWorkLineNum == 0)
        {
            throw error("@WAX1349");
        }

        boolean handleByLPCreateWorkDimTrackingFlight = WHSWorkExecuteHandleByLPCreateWorkDimTrackingV2Flight::instance().isEnabled();

        ttsbegin;

        Query	 query	  = this.pickWorkLineHandleByLPQuery(_workId, nextPutWorkLineNum, _licensePlateId, _skipSelectOnLocatedLP);
        QueryRun queryRun = new QueryRun(query);

        // Remove inventory from Picking location
        while (queryRun.next())
        {
            WHSWorkLine pickWorkLine = queryRun.get(tableNum(WHSWorkLine));

            if (queryRun.changed(tableNum(WHSWorkLine)))
            {
                this.validateAndUpdatePickWorkLineHandledByLP(pickWorkLine, _locationId, _licensePlateId, _userId);
            }

            WHSWorkInventTrans workInventTrans = queryRun.get(tableNum(WHSWorkInventTrans));

            if (PdsGlobal::pdsIsCWItem(workInventTrans.ItemId) && !this.canPickByLicensePlateForCWItems())
            {
                throw error(strFmt("@WAX:Error_PickByLicensePlateNotSupportedForCWItems", workInventTrans.ItemId));
            }
                    
            WHSInventMov_Work workMovement = InventMovement::construct(workInventTrans) as WHSInventMov_Work;
            if (!ledgerVoucher && !workMovement.canUseLiteProcess())
            {
                ledgerVoucher = WHSInvent::beginLedger(_workId);
            }

            InventQty qtyRemainToBePicked = workInventTrans.Qty;

            // Build a merged InventDim with all above location dims as well as location and license plate
            InventDim inventDimPick = InventDim::find(workInventTrans.InventDimIdFrom);
            inventDimPick.wmsLocationId     = _locationId;
            inventDimPick.LicensePlateId    = _licensePlateId;
            inventDimPick = InventDim::findOrCreate(inventDimPick);

            InventDimParm inventDimParm;
            inventDimParm.initFromInventDim(inventDimPick);

            if (handleByLPCreateWorkDimTrackingFlight)
            {
                InventDim inventDimPickForTracking;
                inventDimPickForTracking.data(inventDimPick);
                inventDimPickForTracking.InventStatusId = '';
                inventDimPickForTracking = InventDim::findOrCreate(inventDimPickForTracking);

                boolean overPicking = WHSWorkExecute::validateOverPick(pickWorkLine, _licensePlateId);

                this.createWorkDimTrackingEntries(pickWorkLine, inventDimPickForTracking, 0, overPicking);
            }

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                // Take everything we can find on inventsum and pick based on the exact dimensions, this will include serial/batch numbers
                InventSum inventSum;

                while select inventSum
                    where inventSum.ItemId          == workInventTrans.ItemId
                    &&    inventSum.PhysicalInvent  > 0
                    &&    inventSum.ClosedQty       == NoYes::No
                    &&    #InventDimFieldsFilter(inventSum, inventDimPick, inventDimParm)
                {
                    this.applyExistingInventSumDeltaThatCouldMovedLP(inventSum);

                    // Deltas might have impacted physical invent and we need to account for that
                    if (inventSum.PhysicalInvent > 0)
                    {
                        InventQty qtyToPick;
                        PdsCWInventQty qtyToPickCW;
                        [qtyToPick, qtyToPickCW] = this.getIssueWorkTransQuantitiesForPick(workInventTrans, inventSum, qtyRemainToBePicked);

                        WHSInvent::updateIssueWorkTransactionDimensions(workInventTrans, inventSum.InventDimId, qtyToPick, qtyToPickCW);

                        qtyRemainToBePicked -= qtyToPick;
                        qtyPicked           += qtyToPick;

                        if (qtyRemainToBePicked <= 0)
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                // Take everything we can find on inventsum and pick based on the exact dimensions, this will include serial/batch numbers
                InventSum inventSum;
                InventDim inventDimJoin;

                while select inventSum
                    where inventSum.ItemId == workInventTrans.ItemId
                    &&    inventSum.PhysicalInvent > 0
                    &&    inventSum.ClosedQty     == NoYes::No
                #InventDimInnerJoin(inventSum.inventDimId, inventDimJoin, inventDimPick, inventDimParm)
                {
                    this.applyExistingInventSumDeltaThatCouldMovedLP(inventSum);

                    // Deltas might have impacted physical invent and we need to account for that
                    if (inventSum.PhysicalInvent > 0)
                    {
                        InventQty qtyToPick;
                        PdsCWInventQty qtyToPickCW;
                        [qtyToPick, qtyToPickCW] = this.getIssueWorkTransQuantitiesForPick(workInventTrans, inventSum, qtyRemainToBePicked);

                        WHSInvent::updateIssueWorkTransactionDimensions(workInventTrans, inventDimJoin.InventDimId, qtyToPick, qtyToPickCW);

                        qtyRemainToBePicked -= qtyToPick;
                        qtyPicked           += qtyToPick;

                        if (qtyRemainToBePicked <= 0)
                        {
                            break;
                        }
                    }
                }
            }

            //once all the dimensions are pushed to the inventory transactions then update the entire qty

            InventQty workInventTransQty;
            PdsCWInventQty cwQty;
            [workInventTransQty, cwQty]  = this.getWorkQuantitiesForPick(workInventTrans);

            CostAmount costAmount = -WHSInvent::removeWorkQuantitiesFromLocation(workInventTrans, inventDimPick.InventDimId, workInventTransQty, cwQty, null, ledgerVoucher, workMovement).updCostAmountInvent();
            costAmountMap.insert(workInventTrans.RecId, costAmount);

            if (this.parmUseInsertListForWorkTrans())
            {
                this.addNewWorkTransToInsertList(pickWorkLine, inventDimPick.InventDimId, workInventTrans.Qty, _userId, _licensePlateId);
            }
            else
            {
                this.initNewWorkTrans(pickWorkLine, inventDimPick.InventDimId, workInventTrans.Qty, _userId, _licensePlateId).insert();
            }

            if (qtyRemainToBePicked > 0)
            {
                throw error(strFmt("@SYS54900", pickWorkLine.QtyRemain, StatusIssue::OnOrder, StatusIssue::ReservOrdered, StatusIssue::ReservPhysical));
            }
        }

        this.ensureEntireLicensePlateIsPicked(_workId, _licensePlateId, qtyPicked);

        // Add inventory to user location by looping through the work inventtrans for the pick lines that had the issue transactions updated in the loop above
        queryRun.reset();

        while (queryRun.next())
        {
            WHSWorkInventTrans workInventTrans = queryRun.get(tableNum(WHSWorkInventTrans));
            WHSWorkLine pickWorkLine = queryRun.get(tableNum(WHSWorkLine));

            if (!costAmountMap.exists(workInventTrans.RecId))
            {
                throw error("@SYP5070008");
            }

            WHSInventMov_Work workMovement = InventMovement::construct(workInventTrans) as WHSInventMov_Work;
            if (!ledgerVoucher && !workMovement.canUseLiteProcess())
            {
                ledgerVoucher = WHSInvent::beginLedger(_workId);
            }

            //we only need the values and not the key but we cannot be certain that we do not have multiple inventTrans with the same dimId and since it is faster to just go through them instead of grouping and summing we use a map
            Map dimQtyPutIssueTransDataMap = new Map(Types::Int64, Types::Container);
            InventTrans inventTrans;
            InventTransOrigin inventTransOrigin;
            InventDim inventDimTo, inventDimJoin;

            //This loop needs to be separated because workInventTrans can be updated several times
            while select inventTrans
            join inventDimJoin
                where inventDimJoin.inventDimId == inventTrans.inventDimId
            join tableId from inventTransOrigin
                where inventTransOrigin.InventTransId == workInventTrans.InventTransIdFrom
                &&    inventTransOrigin.RecId         == inventTrans.InventTransOrigin
            {
                // Build specific "To" inventDim overriding location and other dimensions from the issue transactions
                inventDimTo.data(inventDimJoin);
                inventDimTo.wmsLocationId = _userId;
                inventDimTo = InventDim::findOrCreate(inventDimTo);

                //prepare the receipt transactions with the specific dimensions
                InventQty receiptQty;
                PdsCWInventQty receiptQtyCW;
                [receiptQty, receiptQtyCW] = this.getReceiptWorkTransQuantitiesForPick(workInventTrans, inventTrans);
                WHSInvent::updateReceiptWorkTransactionDimensions(workInventTrans, inventDimTo.InventDimId, -receiptQty, -receiptQtyCW);

                //track the quantity and dimensions since we will use these to create more specific inventory transactions for the next WorkInventTrans - what we add here is exactly what we must remove later
                dimQtyPutIssueTransDataMap.insert(inventTrans.RecId, [inventDimTo.InventDimId, -receiptQty, -receiptQtyCW]);
            }

            inventDimTo = InventDim::find(workInventTrans.InventDimIdTo);
            inventDimTo.wmsLocationId = _userId;
            inventDimTo = InventDim::findOrCreate(inventDimTo);

            InventQty workInventTransQty;
            PdsCWInventQty workInventTransCWQty;
            [workInventTransQty, workInventTransCWQty] = this.getWorkQuantitiesForPick(workInventTrans);

            //do the physical update of the receipt transactions
            WHSInvent::addWorkQuantitiesToLocation(workInventTrans, inventDimTo.InventDimId, workInventTransQty, workInventTransCWQty, null, ledgerVoucher, costAmountMap.lookup(workInventTrans.RecId), workMovement, null);

            MapEnumerator me = dimQtyPutIssueTransDataMap.getEnumerator();

            //create the next work transactions with the specific dimensions on the issue transactions since this will prevent update of dimensions later which causes a perf overhead
            while (me.moveNext())
            {
                InventDimId inventDimIdFromSpecific;
                InventQty putIssueinventQty;
                PdsCWInventQty putIssueCWQty;

                [inventDimIdFromSpecific, putIssueinventQty, putIssueCWQty] = me.currentValue();
                this.createNextWorkInventTransQuantities(pickWorkLine, workInventTrans, putIssueinventQty, putIssueCWQty, nextPutWorkLineNum, _userId, false, inventDimIdFromSpecific);
            }

            this.updateWorkLineRemainingQuantities(pickWorkLine, workInventTransQty, workInventTransCWQty);
            this.updateWorkStatus(pickWorkLine.WorkId, pickWorkLine.LineNum, _userId);
            
            this.updateDimTrackingToProcessed(workInventTrans);
        }

        if (ledgerVoucher)
        {
            ledgerVoucher.end();
        }

        WHSLicensePlate::removeFromParentLP(_licensePlateId);

        ttscommit;

        return this.getFirstOpenLine(_workId, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimTrackingToProcessed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the Processed field as a Yes value in WHSDimTracking records for the WHSWorkInventTrans record.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The WHSWorkInventTrans record.
    /// </param>
    private void updateDimTrackingToProcessed(WHSWorkInventTrans _workInventTrans)
    {
        if (WHSWorkExecuteHandleByLPCreateWorkDimTrackingV2Flight::instance().isEnabled())
        {
            WHSDimTracking dimTracking;
            update_recordset dimTracking
                setting Processed = NoYes::Yes
                where dimTracking.WorkId == _workInventTrans.WorkId
                   && dimTracking.LineNum == _workInventTrans.LineNum
                   && dimTracking.InventTransIdParent == _workInventTrans.InventTransIdParent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReceiptWorkTransQuantitiesForPick</Name>
				<Source><![CDATA[
    protected container getReceiptWorkTransQuantitiesForPick(WHSWorkInventTrans _workInventTrans, InventTrans _inventTrans)
    {
        return [_inventTrans.Qty, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIssueWorkTransQuantitiesForPick</Name>
				<Source><![CDATA[
    protected container getIssueWorkTransQuantitiesForPick(WHSWorkInventTrans _workInventTrans, InventSum _inventSum, InventQty _qtyRemainToBePicked)
    {
        return [min(_qtyRemainToBePicked, _inventSum.PhysicalInvent), 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPickByLicensePlateForCWItems</Name>
				<Source><![CDATA[
    protected boolean canPickByLicensePlateForCWItems()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkQuantitiesForPick</Name>
				<Source><![CDATA[
    protected container getWorkQuantitiesForPick(WHSWorkInventTrans _workInventTrans)
    {
        return [_workInventTrans.Qty, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickWorkLineHandleByLPQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create query that will be used to process pick work lines during handle by lp picking process
    /// </summary>
    /// <param name="_workId">
    /// The work Id of the current work to be executed.
    /// </param>
    /// <param name="_nextPutWorkLineNum">
    /// The line number of the next put work line.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate being picked.
    /// </param>
    /// <param name="_skipSelectOnLocatedLP">
    /// Skip select on selected LP.
    /// </param>
    /// <param name="_selectPickLinesSum">
    /// An optional boolean determining if the quantity from the pick lines should be summarized.
    /// </param>
    /// <returns>
    /// The query for eligible for processing pick work lines.
    /// </returns>
    private Query pickWorkLineHandleByLPQuery(WHSWorkId _workId, LineNum _nextPutWorkLineNum, WHSLicensePlateId _licensePlateId, boolean _skipSelectOnLocatedLP, boolean _selectPickLinesSum = false)
    {
        Query    query = new Query();

        QueryBuildDataSource workLineQbds = query.addDataSource(tableNum(WHSWorkLine));

        workLineQbds.addRange(fieldNum(WHSWorkLine, WorkId)).value(queryValue(_workId));
        // Find a Pick that occurred before the put
        workLineQbds.addRange(fieldNum(WHSWorkLine, WorkType)).value(queryValue(WHSWorkType::Pick));
        workLineQbds.addRange(fieldNum(WHSWorkLine, LineNum)).value(strFmt('<%1', queryValue(_nextPutWorkLineNum)));
        workLineQbds.addRange(fieldNum(WHSWorkLine, Skipped)).value(queryValue(NoYes::No));
        workLineQbds.addRange(fieldNum(WHSWorkLine, WorkStatus)).value(strFmt('<%1', queryValue(WHSWorkStatus::Skipped)));

        // If the statement qualifies more lines than what is fectched at once we risk that lines that
        // were returned on the first fecth are updated and fetched again because SQL can use a non static cursor.
        workLineQbds.addSortIndex(indexNum(WHSWorkLine, WorkIdLineNumIdx));
        workLineQbds.indexIsHint(true);

        if (_selectPickLinesSum)
        {
            workLineQbds.addSelectionField(fieldNum(WHSWorkLine, InventQtyRemain), SelectionField::Sum);
        }

        QueryBuildDataSource workInventTransQbds = workLineQbds.addDataSource(tableNum(WHSWorkInventTrans));
        workInventTransQbds.update(true);
        workInventTransQbds.joinMode(JoinMode::InnerJoin);
        workInventTransQbds.relations(true);

        if (!_skipSelectOnLocatedLP)
        {
            QueryBuildDataSource inventDimQbds = workInventTransQbds.addDataSource(tableNum(InventDim));
            inventDimQbds.joinMode(JoinMode::InnerJoin);
            inventDimQbds.relations(false);
            inventDimQbds.addLink(fieldnum(WHSWorkInventTrans, InventDimIdFrom), fieldNum(InventDim, inventDimId));

            query.addQueryFilter(workLineQbds, fieldStr(WHSWorkLine, LocatedLPId)).value(strFmt('((%1.%2 == "%5") || (%3.%4 == "%5"))',
                                                                                        workLineQbds.name(), fieldStr(WHSWorkLine, LocatedLPId),
                                                                                        inventDimQbds.name(), fieldStr(InventDim, LicensePlateId),
                                                                                        queryValue(_licensePlateId)));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPotentialOverPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method determines if workLine is potentially overpicking.
    /// </summary>
    /// <param name="_workTable">
    /// The current work table being executed.
    /// </param>
    /// <param name="_workLine">
    /// The current work line being executed
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate ID to pick.
    /// </param>
    /// <returns>
    /// true if license plate will be overpicked potentially; otherwise false
    /// </returns>
    public static boolean isPotentialOverPick(WHSWorkTable _workTable, WHSWorkLine _workLine, WHSLicensePlateId _licensePlateId = '')
    {
        if (!WhsWorkExecute::isWorkLineStagingPick(_workTable, _workLine))
        {
            return false;
        }

        InventTrans inventTransPhysReservOnLP;
        if (_licensePlateId)
        {
            InventDim inventDimCriteria = _workLine.inventDim();
            inventDimCriteria.wMSLocationId = _workLine.WMSLocationId;
            inventDimCriteria.LicensePlateId = _licensePlateId;
            inventDimCriteria = InventDim::findOrCreate(inventDimCriteria);

            InventDimParm inventDimParm;
            inventDimParm.initFromInventDim(inventDimCriteria);

            InventTransOrigin inventTransOrigin;
            InventDim inventDim;

            select firstOnly RecId from inventTransPhysReservOnLP
            where inventTransPhysReservOnLP.ItemId          == _workLine.ItemId
               && inventTransPhysReservOnLP.StatusIssue     == StatusIssue::ReservPhysical
               && inventTransPhysReservOnLP.StatusReceipt   == StatusReceipt::None
            exists join inventTransOrigin
                where inventTransOrigin.RecId               == inventTransPhysReservOnLP.InventTransOrigin
                   && inventTransOrigin.ReferenceCategory   != InventTransType::WHSWork
            #InventDimExistsJoin(inventTransPhysReservOnLP.InventDimId, inventDim, inventDimCriteria, inventDimParm);
        }

        return inventTransPhysReservOnLP.RecId == 0 && !WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLineStagingPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a work line is a staging raw material pick line.
    /// </summary>
    /// <param name="_workTable">
    /// The current work table being executed.
    /// </param>
    /// <param name="_workLine">
    /// The current work line being executed.
    /// </param>
    /// <returns>
    /// true if the work line should be staged; otherwise false.
    /// </returns>
    public static boolean isWorkLineStagingPick(WHSWorkTable _workTable, WHSWorkLine _workLine)
    {
        return (_workTable.WorkTransType == WHSWorkTransType::ProdPick || (_workTable.WorkTransType == WHSWorkTransType::KanbanPick && !_workLine.isTransferKanban()))
            &&  WHSInventTable::find(_workLine.ItemId).AllowMaterialOverPick == WHSAllowMaterialOverPick::Staging
            &&  WMSLocation::find(_workLine.WMSLocationId, _workTable.InventLocationId).whsLocationIsLPControlled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>putPartialAwayToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates necessary records to put inventory in a location when splitting a put.
    /// </summary>
    /// <param name="_workId">
    /// Work id associated with action.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of work.
    /// </param>
    /// <param name="_qty">
    /// The quantity being put down.
    /// </param>
    /// <param name="_locationId">
    /// Location inventory is to being put too.
    /// </param>
    /// <param name="_userId">
    /// User executing the work.
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The license plate the inventory is going too.
    /// </param>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> the inventory is coming from.
    /// </param>
    /// <returns>
    /// Returns the next <c>WHSWorkLine</c> to process.
    /// </returns>
    public WHSWorkLine putPartialAwayToLocation(
                                        WHSWorkId           _workId,
                                        LineNum             _lineNum,
                                        Qty                 _qty,
                                        WMSLocationId       _locationId,
                                        WHSUserId           _userId,
                                        WHSLicensePlateId   _targetLicensePlateId,
                                        InventDimId         _inventDimId)
    {
        InventDim                           toInventDim, fromInventDim;
        WHSWorkInventTrans                  workInventTrans;
        inventQty                           qtyMoved;
        LedgerVoucher                       ledgerVoucher;

        ttsBegin;

        if (_targetLicensePlateId)
        {
            WHSLicensePlate::createLicensePlate(_targetLicensePlateId);
        }

        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum, true);

        // Qty being passed in is from #QtyToPut which is already in handling unit
        InventHandlingQty handlingQty = _qty;

        boolean useQueryApi = WHSInventoryTransactionConfigurationProvider::shouldUseWorkInventoryTransactionQuery(_workId);
        LineNum fromLineNum, toLineNum;
        if (!useQueryApi)
        {
            [fromLineNum, toLineNum] = this.getPrevLineRange(_workId, _lineNum, WHSWorkType::Pick);
        }

        while select forupdate workInventTrans
            where workInventTrans.WorkId    == _workId
                && workInventTrans.LineNum  == _lineNum
        {
            WHSInventMov_Work workMovement = InventMovement::construct(workInventTrans) as WHSInventMov_Work;
            if (!ledgerVoucher
                && !workMovement.canUseLiteProcess())
            {
                ledgerVoucher = WHSInvent::beginLedger(_workId);
            }

            boolean shouldMove = useQueryApi;

            if (!useQueryApi)
            {
                InventTrans inventTrans;
                InventTransOrigin inventTransOrigin;
                WHSWorkInventTrans loopWorkInventTrans;

                // Next loop over all InventTrans records that match each previous WIT
                while select sum(Qty) from inventTrans
                    group by inventTrans.InventDimId
                    where inventTrans.StatusReceipt == StatusReceipt::Purchased
                        && inventTrans.StatusIssue   == StatusIssue::None
                        && inventTrans.inventDimId   == _inventDimId
                join RecId, InventTransId from inventTransOrigin
                    where  inventTrans.InventTransOrigin    == inventTransOrigin.RecId
                join LineNum from loopWorkInventTrans
                    where loopWorkInventTrans.InventTransIdTo      == inventTransOrigin.InventTransId
                        && loopWorkInventTrans.WorkId               == workInventTrans.WorkId
                        && loopWorkInventTrans.LineNum              >= fromLineNum
                        && loopWorkInventTrans.LineNum              <= toLineNum
                        && loopWorkInventTrans.InventDimIdTo        == workInventTrans.InventDimIdFrom
                        && loopWorkInventTrans.ItemId               == workInventTrans.ItemId
                        && loopWorkInventTrans.InventTransIdParent  == workInventTrans.InventTransIdParent
                {
                    shouldMove = true;
                }
            }

            if (shouldMove)
            {
                // Finally prep Dim Ids and move qty
                fromInventDim   = InventDim::find(_inventDimId);

                if (!fromInventDim.wmsLocation().whsLocationIsLPControlled())
                {
                    fromInventDim.LicensePlateId = '';
                }
                fromInventDim = InventDim::findOrCreate(fromInventDim);

                toInventDim     = InventDim::find(_inventDimId);
                toInventDim.wmsLocationId = _locationId;
                if (_targetLicensePlateId)
                {
                    toInventDim.LicensePlateId = _targetLicensePlateId;
                }
                if (!toInventDim.wmsLocation().whsLocationIsLPControlled())
                {
                    toInventDim.LicensePlateId = '';
                }

                toInventDim = InventDim::findOrCreate(toInventDim);

                if (PdsGlobal::pdsIsCWItem(workInventTrans.ItemId))
                {
                    // Calculate weight based off inventory values.
                    WHSTransWeight transWeight = WHSCatchWeightHelper::calculateMovingWeight(workInventTrans.ItemId, fromInventDim.inventDimId, handlingQty);

                    WHSInvent::moveWorkQuantities(workInventTrans, fromInventDim.InventDimId, toInventDim.InventDimId, transWeight, handlingQty, this.inventCostOnhandCache(), ledgerVoucher, workMovement);
                }
                else
                {
                    WHSInvent::moveWorkQuantities(workInventTrans, fromInventDim.InventDimId, toInventDim.InventDimId, handlingQty, 0, this.inventCostOnhandCache(), ledgerVoucher, workMovement);
                }

                qtyMoved += handlingQty;
                
                // Update location status fields for the put location.
                WHSLocationWorkUpdater::updateLocationInfoFromPickPutWork(
                    toInventDim.InventLocationId,
                    toInventDim.wMSLocationId,
                    WHSWorkType::Put);
                
            }
        }

        // Start building the inventDim for workTrans
        InventDim workTransInventDim = toInventDim;
        workTransInventDim.clearBelowLocationDim(workLine.ItemId);
        workTransInventDim.wmsLocationId = _locationId;

        WHSWorkTrans newWorkTrans;

        if (WHSPopulateTargetLPOnWHSWorkTransFlight::instance().isEnabled())
        {
            newWorkTrans.TargetLicensePlateId = toInventDim.LicensePlateId;
        }

        if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
            || WHSConsumeTargetLPFromWHSWorkTransFlight::instance().isEnabled())
        {
            workTransInventDim.LicensePlateId = fromInventDim.LicensePlateId;
            newWorkTrans.TargetLicensePlateId = toInventDim.LicensePlateId;
        }
        else
        {
            workTransInventDim.LicensePlateId = toInventDim.LicensePlateId;
        }

        this.updateWorkLineRemainingQuantities(workLine, qtyMoved, 0);

        newWorkTrans.setWorkTransId();
        newWorkTrans.initFromWorkLine(workLine);
        newWorkTrans.InventDimId   = InventDim::findOrCreate(workTransInventDim).InventDimId;
        newWorkTrans.Qty           = qtyMoved;
        newWorkTrans.TransDateTime = DateTimeUtil::utcNow();
        newWorkTrans.UserId        = _userId;
        newWorkTrans.insert();

        // do not update the captured weght as that field is only to record the captured actual weight during picking
        this.updateWorkStatus(_workId, _lineNum, _userId);

        if (ledgerVoucher)
        {
            ledgerVoucher.end();
        }

        ttsCommit;

        return this.getFirstOpenLine(_workId, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustHandlingUnitWorkInventTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work transaction related to the handling unit quantity.
    /// </summary>
    /// <param name="_workLine">
    /// The work line related to the transactions.
    /// </param>
    /// <param name="_inventTransId">
    /// The transaction number for the work line.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity to update by.
    /// </param>
    /// <param name="_userId">
    /// The user who initiated the update.
    /// </param>
    /// <returns>
    /// The qty left to update on remaining transactions.
    /// </returns>
    private InventQty adjustHandlingUnitWorkInventTransQty(
        WHSWorkLine     _workLine,
        InventTransId   _inventTransId,
        InventQty       _inventQty,
        WHSUserId       _userId)
    {
        WHSWorkInventTrans  workInventTrans;
        InventDim           toInventDim;
        InventQty           runningQty = _inventQty;
        InventQty           updateQty;

        while select forUpdate workInventTrans
            where workInventTrans.WorkId                == _workLine.WorkId
            &&    workInventTrans.LineNum               == _workLine.LineNum
            &&    workInventTrans.ItemId                == _workLine.ItemId
            &&    workInventTrans.InventTransIdParent   != _inventTransId
        {
            updateQty = workInventTrans.Qty;

            workInventTrans.Qty = workInventTrans.Qty + runningQty < 0 ? 0 : workInventTrans.Qty + runningQty;
            workInventTrans.update();

            // If no qty is left on the WIT, delete it and reduce the running qty by what was on the WIT
            if (workInventTrans.Qty == 0)
            {
                workInventTrans.delete();
                runningQty += updateQty;
            }
            else
            {
                if (!workInventTrans.InventQtyRemain)
                {
                    // Update to inventDim on workInventTrans if workLine is complete.
                    toInventDim = InventDim::find(workInventTrans.InventDimIdTo);

                    if (!toInventDim.wmsLocationId)
                    {
                        toInventDim.wmsLocationId = _userId;
                        toInventDim = InventDim::findOrCreate(toInventDim);
                        workInventTrans.InventDimIdTo = toInventDim.InventDimId;
                        workInventTrans.doUpdate();
                    }
                }

                // If there is qty left on the WIT then we've reduced the entire running qty.
                runningQty = 0;
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method determines if the specified work can be auto picked.
    /// </summary>
    /// <param name="_menuItemName">
    /// The menu item that is being used to execute work.
    /// </param>
    /// <param name="_workLine">
    /// The <c>WHSWorkLine</c> record that needs to be validated
    /// </param>
    /// <param name="validateIsPutBefore">
    /// Validate if the current work line has any put work as predecessors; optional
    /// </param>
    /// <returns>
    /// true if the work has to be skipped; otherwise false
    /// </returns>
    public static boolean canAutoPickWorkLine(WHSMenuItemName   _menuItemName,
                                              WHSWorkLine       _workLine,
                                              boolean           validateIsPutBefore = false)
    {
        boolean ret = true;
        WHSWorkTable workTable = _workLine.whsWorkTable();
        InventTable inventTable;

        if (!WHSRFAutoConfirm::isAutoConfirmationEnabled(_menuItemName, WHSWorkType::Pick)
            || _workLine.WorkType != WHSWorkType::Pick)
        {
            ret = false;
        }

        // Consider only the Pick lines before the first Put line.
        if (ret && validateIsPutBefore)
        {
            ret = !WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum);
        }

        // Abort iteration if a pick from LP-Controlled location is found, or the item is dimension tracking controlled
        if (ret && WMSLocation::find(_workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled())
        {
            ret = false;
        }

        // In case of BatchAboveLocation scenario, validate if the batch disposition code of the selected batch is valid
        if (ret && !WHSWorkExecute::isBatchDispCodeValidForPicking(
                                                _workLine.ItemId,
                                                InventDim::find(_workLine.InventDimId).inventBatchId,
                                                workTable.WorkTransType))
        {
            ret = false;
        }

        // Validate if the specified item is a BatchBelowLocation or SerialBelowLocation scenario.
        if (ret)
        {
            inventTable = InventTable::find(_workLine.ItemId);
            if ((inventTable.whsSerialActive() && WHSReservationHierarchyInventDimUtil::isSerialBelowLocation(inventTable))
            || (inventTable.whsBatchActive() && WHSReservationHierarchyInventDimUtil::isBatchBelowLocation(inventTable)))
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>multiPicksNonLicensePlateCheckDigit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the picking of subsequent work lines.
    /// </summary>
    /// <param name="_menuItemName">
    /// The menu item that is being used to execute work.
    /// </param>
    /// <param name = "_currentWorkLine">
    /// Current work line to pick.
    /// </param>
    /// <param name = "_userId">
    /// The id for the user performing the picking.
    /// </param>
    /// <param name = "_targetLicensePlateId">
    /// The target license plate for the pick; optional.
    /// </param>
    /// <param name = "_assignSerial">
    /// A boolean that determines if the current pick steps begin executed is assigning serial Ids to the inventory; optional.
    /// </param>
    /// <returns>
    /// Returns a container with the last picked work line and the next open work line.
    /// </returns>
    public container multiPicksNonLicensePlateCheckDigit(
                    MenuItemName      _menuItemName,
                    WHSWorkLine       _currentWorkLine,
                    WHSUserId         _userId,
                    WHSLicensePlateId _targetLicensePlateId = '',
                    boolean           _assignSerial         = false)
    {
        WHSWorkTable workTable = WHSWorkTable::find(_currentWorkLine.WorkId);
        WHSWorkLine  workLineToPick = _currentWorkLine;
        WHSWorkLine  nextOpenWorkLine;
        boolean      isCyclePickingEnabled = !WHSRFMenuItemTable::find(_menuItemName).DisableCycleCountThreshold;

        do
        {
            if (nextOpenWorkLine)
            {
                workLineToPick.data(nextOpenWorkLine);
            }

            // Process pick work line from non LP-Controlled location
            nextOpenWorkLine = this.pickNonLicensePlateCheckDigitQuantities(workLineToPick.WorkId,
                                                            workLineToPick.LineNum,
                                                            workLineToPick.ItemId,
                                                            workLineToPick.QtyRemain,
                                                            0, // multipicks does not support catch weight capturing
                                                            workLineToPick.UnitId,
                                                            _userId,
                                                            workLineToPick.inventDim(),
                                                            _targetLicensePlateId,
                                                            _assignSerial);

            // Check to see if an immediate count needs to be executed
            if (isCyclePickingEnabled)
            {
                WHSCycleCountThresholdId cycleCountThresholdId = WHSCycleCountCreateThreshold::processCycleCountThreshold(workLineToPick.WorkId, workLineToPick.LineNum);
                if(WHSCycleCountThreshold::find(cycleCountThresholdId).ImmediateCycleCount)
                {
                    // Abort iteration if we need to process the immediate count
                    break;
                }
            }

            if (!WHSWorkExecute::canAutoPickWorkLine(_menuItemName, nextOpenWorkLine))
            {
                break;
            }
        }
        while (nextOpenWorkLine);

        return [workLineToPick, nextOpenWorkLine];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBatchDispCodeValidForPicking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that the selected batch is available for picking.
    /// </summary>
    /// <param name="_itemId">
    ///     The item Id of the work line to be executed.
    /// </param>
    /// <param name="_inventBatchId">
    ///     The batch id of the selected item.
    /// </param>
    /// <param name="_workTransType">
    ///     The work transaction type.
    /// </param>
    /// <returns>
    ///     Returns true, if the batch is available for picking; otherwise false
    /// </returns>
    public static boolean isBatchDispCodeValidForPicking(ItemId           _itemId,
                                                     InventBatchId    _inventBatchId,
                                                     WHSWorkTransType _workTransType)
    {
        if (_inventBatchId
        && WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(InventTable::find(_itemId))
        && !InventBatch::find(_inventBatchId, _itemId).validateBatchDispCodeForPicking(_workTransType))
        {
            return false;
        }
    
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseDimTrackingForWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Method which determines if dimension tracking records need to be created for special workTransType.
    /// </summary>
    /// <param name="_itemId">
    ///     The item Id of the work line to be executed.
    /// </param>
    /// <param name="_workTransType">
    ///     The work transaction type.
    /// </param>
    /// <returns>
    ///     true if dimension tracking records need to be created; otherwise false.
    /// </returns>
    private boolean mustUseDimTrackingForWorkTransType(ItemId _itemId, WHSWorkTransType _workTransType)
    {
        NoYes dimTrackingControlled = NoYes::No;
       
        // For serial tracked items that are set to capture serial number on picking, should create WHSDimTracking records
        if (_workTransType == WHSWorkTransType::PackedContainerPicking &&
            WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Picking)
        {
            dimTrackingControlled = NoYes::Yes;

            if (itemIsDimTrackingControlledCache.exists(_itemId) && itemIsDimTrackingControlledCache.lookup(_itemId) == NoYes::No)
            {
                itemIsDimTrackingControlledCache.remove(_itemId);
            }

            itemIsDimTrackingControlledCache.insert(_itemId, dimTrackingControlled);
        }

        return dimTrackingControlled == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyInventDimWithNewLocationDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new inventory dimension, where all the fields are set based on the targetInventDim except
    /// the location dimensions (site, warehouse, location and inventory status if a new one is provided.), which are taken from the
    /// sourceInventDim.
    /// </summary>
    /// <param name = "_mainInventDim">The inventDim that contains all the dimension for the new inventDim, except the location dimensions.</param>
    /// <param name = "_locationInventDim">The inventDim that contains the location dimensions.</param>
    /// <returns>An instance of InventDim with the fields set as described in the summary.</returns>
    private InventDim copyInventDimWithNewLocationDimensions(InventDim _mainInventDim, InventDim _locationInventDim)
    {
        boolean workExecuteCopyDimensionsToInventDimToFlightEnabled = WHSWorkExecuteCopyDimensionsToInventDimToFlight::instance().isEnabled();
        InventDim inventDim;

        WMSLocation wmsLocationTo = WMSLocation::find(_locationInventDim.wMSLocationId,_locationInventDim.InventLocationId);

        if (!workExecuteCopyDimensionsToInventDimToFlightEnabled && _mainInventDim.LicensePlateId && !wmsLocationTo.whsLocationIsLPControlled())
        {
            return _locationInventDim;
        }

        buf2Buf(_mainInventDim, inventDim);

        inventDim.InventSiteId     = _locationInventDim.InventSiteId;
        inventDim.InventLocationId = _locationInventDim.InventLocationId;
        inventDim.wMSLocationId    = _locationInventDim.wMSLocationId;

        if (_locationInventDim.InventStatusId)
        {
            inventDim.InventStatusId = _locationInventDim.InventStatusId;
        }

        if (workExecuteCopyDimensionsToInventDimToFlightEnabled && _mainInventDim.LicensePlateId && !wmsLocationTo.whsLocationIsLPControlled())
        {
            inventDim.LicensePlateId = '';
        }

        inventDim = InventDim::findOrCreate(inventDim);

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLPWarehouseTransferPickWorkAndJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method creates for the pick work lines and the journal lines for all the items on a given license plate.
    /// </summary>
    /// <param name = "_licensePlateId">The license plate id we are transfering.</param>
    /// <param name = "_inventDimTo">The to inventDim to be used when creating the journal lines.</param>
    /// <param name = "_inventJournalTable">The journal to add the lines.</param>
    /// <param name = "_workTable">The work header for the work lines.</param>
    /// <param name = "_userId">The user id of the user performing the action.</param>
    /// <returns>The total inventory handling qty for which work was created.</returns>
    private InventHandlingQty createLPWarehouseTransferPickWorkAndJournalLines(
        WHSLicensePlateId  _licensePlateId,
        InventDim          _inventDimTo,
        InventJournalTable _inventJournalTable,
        WHSWorkTable       _workTable,
        WHSUserId          _userId)
    {
        InventSum inventSum;
        InventDim inventDimFrom;
        InventQty capturedWeight;

        InventHandlingQty runningQty;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            while select ItemId, InventDimId from inventSum
           where inventSum.ClosedQty      == NoYes::No
           && inventSum.PhysicalInvent > 0
           && inventSum.LicensePlateId == _licensePlateId
            {
                inventDimFrom = InventDim::find(inventSum.InventDimId);

                InventHandlingQty inventQty = WHSInventOnHand::getWorkPhysicalInventByInventDim(inventSum.ItemId, inventDimFrom);

                runningQty += inventQty;
                
                this.createTransferJournalLine(
                    _inventJournalTable,
                     inventSum.ItemId,
                    inventQty,
                    capturedWeight,
                    inventDimFrom.InventDimId,
                    this.copyInventDimWithNewLocationDimensions(inventDimFrom, _inventDimTo).InventDimId);

                WHSWorkLine pickWorkLine =
                    this.createTransferPickWorkLine(
                    _workTable,
                    inventSum.ItemId,
                    inventQty,
                    capturedWeight,
                    inventDimFrom,
                    _userId,
                    warehouseTransferWorkLineNumCounter);

                this.createTransferWorkTrans(_workTable, pickWorkLine, _userId);

                warehouseTransferWorkLineNumCounter++;
            }
        }
        else
        {
            while select ItemId from inventSum
            where inventSum.ClosedQty == NoYes::No
                && inventSum.PhysicalInvent > 0
            join inventDimFrom
            where inventDimFrom.InventDimId == inventSum.InventDimId
                && inventDimFrom.LicensePlateId == _licensePlateId
            {
                InventHandlingQty inventQty = WHSInventOnHand::getWorkPhysicalInventByInventDim(inventSum.ItemId, inventDimFrom);

                runningQty += inventQty;

                this.createTransferJournalLine(
                    _inventJournalTable,
                    inventSum.ItemId,
                    inventQty,
                    capturedWeight,
                    inventDimFrom.InventDimId,
                    this.copyInventDimWithNewLocationDimensions(inventDimFrom, _inventDimTo).InventDimId);
                
                WHSWorkLine pickWorkLine =
                this.createTransferPickWorkLine(
                    _workTable,
                    inventSum.ItemId,
                    inventQty,
                    capturedWeight,
                    inventDimFrom,
                    _userId,
                    warehouseTransferWorkLineNumCounter);

                this.createTransferWorkTrans(_workTable, pickWorkLine, _userId);

                warehouseTransferWorkLineNumCounter++;
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeIfNeededWarehouseTransferHeaders</Name>
				<Source><![CDATA[
    private container initializeIfNeededWarehouseTransferHeaders(
        InventJournalTable _inventJournalTable,
        WHSWorkTable       _workTable,
        InventDim          _fromInventDim)
    {
        InventJournalTable inventJournalTable = _inventJournalTable;
        WHSWorkTable       workTable          = _workTable;

        if (!inventJournalTable)
        {
            inventJournalTable = this.createTransferJournalHeader(WHSParameters::find().DefaultWhseTransJournal);
        }
        
        if (!workTable)
        {
            workTable  = this.createTransferWorkHeader(inventJournalTable, _fromInventDim);
        }

        return [inventJournalTable, workTable];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWarehouseTransferJournalLinesForNestedLPs</Name>
				<Source><![CDATA[
    private InventHandlingQty createWarehouseTransferJournalLinesForNestedLPs(
        WHSLicensePlateId  _parentLicensePlateId,
        InventDim          _fromInventDim,
        InventDim          _toInventDim,
        WHSUserId          _userId,
        InventJournalTable _inventJournalTable,
        WHSWorkTable       _workTable)
    {
        InventHandlingQty runningQty;

        WHSLicensePlate childLicensePlate;

        while select LicensePlateId from childLicensePlate
            where childLicensePlate.LicensePlateParent == _parentLicensePlateId
        {
            // Create movement work for the child license plate nest.
            runningQty += this.createAndPostNestedWarehouseTransferJournal(childLicensePlate.LicensePlateId,
                                                                _fromInventDim,
                                                                _toInventDim,
                                                                _userId,
                                                                _inventJournalTable,
                                                                _workTable);
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWarehouseTransferJournalIfDone</Name>
				<Source><![CDATA[
    private void postWarehouseTransferJournalIfDone(
        InventDim          _toInventDim,
        InventHandlingQty  _runningQty,
        WHSUserId          _userId,
        InventJournalTable _inventJournalTable,
        WHSWorkTable       _workTable)
    {
        WHSWorkLine putWorkLine = this.createTransferPutWorkLineForNestedLP(_workTable, _runningQty, _toInventDim, _userId);
        this.createTransferWorkTrans(_workTable, putWorkLine, _userId);

        using (WHSInventCheckLocationAndLPContext context = WHSInventCheckLocationAndLPContext::construct())
        {
            context.parmSkipLPLocationValidation(true);
            this.postTransferJournal(_inventJournalTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostNestedWarehouseTransferJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates movement work for the child license plate nest.
    /// </summary>
    /// <param name = "_parentLicensePlateId">The license plate id we are transferring.</param>
    /// <param name = "_fromInventDim">The from InventDim to be used when creating the journal and work lines.</param>
    /// <param name = "_toInventDim">The to inventDim to be used when creating the journal lines.</param>
    /// <param name = "_userId">The user id of the user performing the action.</param>
    /// <param name = "_inventJournalTable">The journal to add the lines.</param>
    /// <param name = "_workTable">The work header for the work lines.</param>
    /// <returns>The total inventory handling qty for which work was created.</returns>
    [Hookable(false)]
    internal InventHandlingQty createAndPostNestedWarehouseTransferJournal(
        WHSLicensePlateId  _parentLicensePlateId,
        InventDim          _fromInventDim,
        InventDim          _toInventDim,
        WHSUserId          _userId,
        InventJournalTable _inventJournalTable  = null,
        WHSWorkTable       _workTable           = null)
    {
        ttsbegin;

        InventJournalTable inventJournalTable;
        WHSWorkTable       workTable;
        
        InventHandlingQty  runningQty;

        [inventJournalTable, workTable] =
            this.initializeIfNeededWarehouseTransferHeaders(_inventJournalTable, _workTable, _fromInventDim);

        runningQty += this.createLPWarehouseTransferPickWorkAndJournalLines(
                                                                _parentLicensePlateId,
                                                                _toInventDim,
                                                                inventJournalTable,
                                                                workTable,
                                                                _userId);

        runningQty += this.createWarehouseTransferJournalLinesForNestedLPs(
                                                                _parentLicensePlateId,
                                                                _fromInventDim,
                                                                _toInventDim,
                                                                _userId,
                                                                inventJournalTable,
                                                                workTable);
        
        if (!_inventJournalTable)
        {
            this.postWarehouseTransferJournalIfDone(_toInventDim, runningQty, _userId, inventJournalTable, workTable);
        }

        ttscommit;

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferPutWorkLineForNestedLP</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSWorkLine createTransferPutWorkLineForNestedLP(
        WHSWorkTable _workTable,
        Qty          _runningQty,
        InventDim    _inventDimTo,
        WHSUserId    _userId)
    {
        WHSWorkLine putWorkLine;
        putWorkLine.WorkId                     = _workTable.WorkId;
        putWorkLine.LineNum                    = warehouseTransferWorkLineNumCounter;
        putWorkLine.WorkStatus                 = WHSWorkStatus::Closed;
        putWorkLine.WorkType                   = WHSWorkType::Put;
        putWorkLine.WMSLocationId              = _inventDimTo.wMSLocationId;
        putWorkLine.ItemId                     = '';
        putWorkLine.InventDimId                = InventDim::inventDimIdBlank();
        putWorkLine.InventQtyRemain            = 0;
        putWorkLine.InventQtyWork              = _runningQty;
        putWorkLine.QtyWork                    = _runningQty;
        putWorkLine.CapturedWeight             = 0; // As we don't support catch weight for this .
        putWorkLine.UnitId                     = '';
        putWorkLine.UserId                     = _userId;
        putWorkLine.WorkInProcessUTCDateTime   = DateTimeUtil::utcNow();
        putWorkLine.WorkClosedUTCDateTime      = putWorkLine.WorkInProcessUTCDateTime;
        putWorkLine.insert();

        return putWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    internal WHSInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimFromForQuarantineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves before quarantine inventory dimensions.
    /// </summary>
    /// <param name = "_inventDim">Initial dimensions.</param>
    /// <param name = "_fromInventStatusId">Initial inventory status before quarantine.</param>
    /// <returns>Before quarantien inventory dimensions.</returns>
    [Hookable(false)]
    internal InventDim initializeInventDimFromForQuarantineWork(InventDim _inventDim, WHSInventStatusId _fromInventStatusId)
    {
        return _inventDim.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimParmForQuarantineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves inventory dimensions criteria for quarantine work by inventory dimensions.
    /// </summary>
    /// <param name = "_inventDim">Inventory dimensions.</param>
    /// <returns>Inventory dimensions for quarantine work.</returns>
    [Hookable(false)]
    internal InventDimParm initializeInventDimParmForQuarantineWork(InventDim _inventDim)
    {
        InventDimParm inventDimParmCriteria;

        inventDimParmCriteria.setAllStorageDimensions();
        inventDimParmCriteria.InventStatusFlag = NoYes::No;

        return inventDimParmCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQuarantineDimIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets before and after dimensions of the quarantine work.
    /// </summary>
    /// <param name="_workQuarantine">
    /// Quarantine transaction.
    /// </param>
    /// <param name="_inventDim">
    /// Initial dimensions to be modified.
    /// </param>
    /// <param name="_statusFrom">
    /// Initial inventory status before quarantine.
    /// </param>
    /// <param name="_statusTo">
    /// Final inventory status after quarantine.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate ID.
    /// </param>
    [Hookable(false)]
    internal void setQuarantineDimIds(WHSWorkQuarantine     _workQuarantine,
                                      InventDim             _inventDim,
                                      WHSInventStatusId     _statusFrom,
                                      WHSInventStatusId     _statusTo,
                                      WHSLicensePlateId     _licensePlateId)
    {
        _workQuarantine.setDimIds(_inventDim, _statusFrom, _statusTo, _licensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureTargetLicensePlateOnWork</Name>
				<Source><![CDATA[
    private void ensureTargetLicensePlateOnWork(WHSWorkId _workId, WHSLicensePlateId _licensePlateId)
    {
        WHSWorkTable workTable = WHSWorkTable::find(_workId);
        // Fill the target LP if it is empty and work is Transfer Issue or Sales picking.
        // It is used for cross docking process to create ASN for the transfer order receiving process
        if (!workTable.TargetLicensePlateId && this.isWorkTransTypeAllowingAssigningTargetLPForHandledByLP(workTable))
        {
            WHSWorkTable::addTargetLicensePlate(_workId, _licensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkTransTypeAllowingAssigningTargetLPForHandledByLP</Name>
				<Source><![CDATA[
    private boolean isWorkTransTypeAllowingAssigningTargetLPForHandledByLP(WHSWorkTable _workTable)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(_workTable.WorkTransType);
        return workTransactionType.isAllowingAssigningTargetLPForHandledByLP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowAssignTargetLPToWorkTableHandledByLP</Name>
				<Source><![CDATA[
    private boolean allowAssignTargetLPToWorkTableHandledByLP(WHSWorkTable        _workTable,
                                                              WHSWorkLine         _workLine,
                                                              WHSLicensePlateId   _licensePlateId)
    {
        boolean noTargetLP = !_workTable.TargetLicensePlateId;

        return noTargetLP
            && this.isWorkTransTypeAllowingAssigningTargetLPForHandledByLP(_workTable)
            && (this.isWholeLicensePlate(_licensePlateId, _workLine, true) || WHSWorkExecute::validateOverPick(_workLine, _licensePlateId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLicensePlateIsApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that license plate is valid and can be used.
    /// </summary>
    /// <param name = "_licensePlateId">
    /// A license plate Id.
    /// </param>
    /// <param name = "_uomStructure">
    /// A unit structure.
    /// </param>
    /// <param name = "_inventLocationId">
    /// An inventory location Id.
    /// </param>
    /// <exception cref="Exception::Error">
    /// License plate is invalid or cannot be used.
    /// </exception>
    public static void validateLicensePlateIsApplicable(
        WHSLicensePlateId _licensePlateId,
        WHSUOMStructure _uomStructure,
        InventLocationId _inventLocationId)
    {
        if (!_uomStructure)
        {
            throw error("@WAX691");
        }
        else if (_uomStructure.createdReceiptWorkId())
        {
            throw error("@WAX3347");
        }
        else if (_uomStructure.LicensePlateParent)
        {
            throw error("@WAX5605");
        }
        else if (!_uomStructure.Module)
        {
            throw error("@WAX:PackingStructureMissingModule");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLicensePlateValidStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a unit structure and validates that a proper warehouse is used.
    /// </summary>
    /// <param name = "_licensePlateId">
    /// A license plate Id.
    /// </param>
    /// <param name = "_currentWarehouseId">
    /// A current warehouse.
    /// </param>
    /// <param name = "_createWork">
    /// True if a work supposed to be created.
    /// </param>
    /// <returns>
    /// A unit structure.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Runs from a wrong warehouse.
    /// </exception>
    [Hookable(false)]
    internal WHSUOMStructure getLicensePlateValidStructure(
        WHSLicensePlateId _licensePlateId, 
        InventLocationId  _currentWarehouseId, 
        boolean           _createWork)
    {
        WHSUOMStructure uomStructure = WHSUOMStructure::findFirstByLicensePlate(_licensePlateId);

        switch (uomStructure.Module)
        {
            case WHSModule::Transfer:
                WHSOrderNum transferOrderId = WHSShipmentTable::find(uomStructure.ShipmentId).OrderNum;
                if (transferOrderId)
                {
                    InventLocationId plannedWarehouseId = InventTransferTable::find(transferOrderId).InventLocationIdTo;

                    if (plannedWarehouseId != _currentWarehouseId)
                    {
                        throw error(strFmt("@WAX:WhsLPReceivingWrongWarehouseWithInfo", plannedWarehouseId));
                    }
                }
                else
                {
                    InventLocationId toWarehouse = WhsWorkExecute::findToWarehouseForASNTransfer(uomStructure);

                    if (toWarehouse != _currentWarehouseId)
                    {                       
                        throw error(strFmt("@WAX:WhsLPReceivingWrongWarehouseWithInfo", toWarehouse));
                    }
                }
                break;

            case WHSModule::Purch:
                this.validateUOMStructureForExternalInboundShipment(uomStructure, _currentWarehouseId, _createWork);                     
                                
                break;

            default:
                this.validateUOMStructureDefault(uomStructure, _currentWarehouseId, _createWork);
                break;
        }

        return uomStructure;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findToWarehouseForASNTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the to warehouse for an ASN transfer.
    /// </summary>
    /// <param name = "_uomStructure">The UOM structure.</param>
    /// <returns>The to warehouse.</returns>
    [Hookable(false)]
    internal static InventLocationId findToWarehouseForASNTransfer(WHSUOMStructure _uomStructure)
    {
        InventTransferTable     transferTable;
        WHSASNItem              asnItem;
        WHSLoadLine             loadLine;

        // If shipment has multiple orders its orderNum will be blank.
        select firstOnly InventLocationIdTo from transferTable
            exists join loadLine
                where loadLine.OrderNum         == transferTable.TransferId
                &&    loadLine.InventTransType  == InventTransType::TransferOrderShip
            exists join asnItem
                where asnItem.LoadLineRefRecId  == loadLine.RecId
                &&    asnItem.Module            == _uomStructure.Module
                &&    asnItem.LicensePlateId    == _uomStructure.LicensePlateId;

        return transferTable.InventLocationIdTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentInventLocationId</Name>
				<Source><![CDATA[
    internal InventLocationId getCurrentInventLocationId(WHSUserId _userId)
    {
        InventLocationId    currentWarehouseId;
        
        if (defaultInventLocationId)
        {
            currentWarehouseId = defaultInventLocationId;
        }
        else
        {
            currentWarehouseId = WHSWorkUserSession::find(_userId).InventLocationId;
        }

        return currentWarehouseId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultInventLocationId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public InventLocationId parmDefaultInventLocationId(InventLocationId _inventLocationId = defaultInventLocationId)
    {
        defaultInventLocationId = _inventLocationId;
        return defaultInventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUOMStructureForExternalInboundShipment</Name>
				<Source><![CDATA[
    internal void validateUOMStructureForExternalInboundShipment(
        WHSUOMStructure  _uomStructure,
        InventLocationId _currentWarehouseId,
        boolean          _createWork)
    {
        if (_uomStructure && _createWork)
        {
            InventLocationId plannedWarehouseId = WHSShipmentTable::find(_uomStructure.ShipmentId).InventLocationId;
            InventLocationId currentWarehouseId = _currentWarehouseId;

            if (!WHSUOMStructureReceiptHandler::isReceiptAtPlannedWarehouseOrAtOtherWarehouseAllowed(plannedWarehouseId, currentWarehouseId))
            {
                if (!WHSUOMStructure::findFirstByLicensePlateModuleInventLocationId(_uomStructure.LicensePlateId, _uomStructure.Module, currentWarehouseId))
                {
                    throw error(strFmt("@WAX:WhsLPReceivingWrongWarehouseWithInfo", plannedWarehouseId));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUOMStructureDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extension point for validating non Purchase or Transfer UOM structures.
    /// </summary>
    /// <param name = "_uomStructure">The UOM structure that was found.</param>
    /// <param name = "_currentWarehouseId">The warehouse the mobile device user is in.</param>
    /// <param name = "_createWork">True if this is a work creation process; otherwise false.</param>
    protected void validateUOMStructureDefault(
        WHSUOMStructure  _uomStructure,
        InventLocationId _currentWarehouseId,
        boolean          _createWork)
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>