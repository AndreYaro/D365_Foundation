<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjInvoiceJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjInvoiceJournalPost extends FormletterJournalPost
{
    boolean                             voucherEqualsNumber;
    ProjInvoiceJour                     projInvoiceJour;
    ProjInvoiceTable                    projInvoiceTable;
    ProjInvoiceParmTable                projInvoiceParmTable;

    boolean                             fixedExchRate;
    boolean                             creditNote;
    ProjProposalTotals                  projProposalTotals;

    RecordSortedList                    recordListProjProposalCost;
    RecordSortedList                    recordListProjProposalEmpl;
    RecordSortedList                    recordListProjProposalRevenue;
    RecordSortedList                    recordListProjProposalOnAcc;
    RecordSortedList                    recordListProjProposalItem;
    RecordInsertList                    recordInsertListSpecTrans;

    LedgerVoucher                       ledgerVoucherSMA;
    TransactionTxt                      transactionTxtSMA;
    Voucher                             voucherSMA;

    NumberSequenceReference             voucherSequenceReference;
    NumberSequenceReference             numberSequenceReference;
    SalesFormLetter_InvoiceProject      salesFormLetter;

    ProjBudgetTransaction               projBudgetTransactionNormal, projBudgetTransactionReverse;
    ProjBudgetTransactionManager        projBudgetTransactionManager;

    RecordInsertList                    recordInsertListCustInvoicePackingSlipMatch;
    // <GBR>
    TmpInvoiceCancel_BR                 tmpInvoiceCancel;
    // </GBR>

    TaxParameters                       taxParameters;
    MainAccount                         postingMainAccount;

    // <GIN>
    AmountCur                           taxCustomsDuty;
    // </GIN>
    PaymTerm                            projectInvoicePaymTerm;
    CustTrans                           custTrans;
    private ProjTransStatus             transStatus;
    private boolean                     advanceInvoicePosting;
    private boolean                     advanceInvoiceSettlement;
    private boolean                     countryRegion_PL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);

    private int numOfInvEmpl;
    private int numOfInvCost;
    private int numOfInvItem;
    private int numOfInvRevenue;
    private int numOfInvOnAcc;
    private int numOfInvSalesLine;

    #ISOCountryRegionCodes

    // <GEERU>
    boolean                             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
    // </GEERU>
    private TransDate ledgerTransDate;
    private int totalOnAccDeductionRecords;
    
    // This flight provides regression protection for the description update for tax transactions when posting invoice proposal for an expense journal.
    // Created 10.0.19
    // Default state: Off
    private static const str projUpdateExpenseSalesTaxVoucherDescForCostTransFlight = 'ProjUpdateExpenseSalesTaxVoucherDescForCostTransFlight';
        
    private boolean isCreditInvoicingPrintingFlightEnabled = ProjInvoicePrintingCreditInvoicingFlight::instance().isEnabled();
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accrueJournal</Name>
				<Source><![CDATA[
    protected void accrueJournal()
    {
        SMAAccrueGenerator smaAccrueGenerator = new SMAAccrueGenerator(projInvoiceJour.ProjInvoiceId);
        smaAccrueGenerator.parmInvoiceDate(projInvoiceJour.InvoiceDate);

        smaAccrueGenerator.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a record to the <c>InventReportDimHistory</c> table.
    /// </summary>
    /// <param name="_journalline">
    /// A journal line record.
    /// </param>
    protected void addToInventReportDimHistory(Common _journalline)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateVoucher</Name>
				<Source><![CDATA[
    protected NumberSeq allocateVoucher()
    {
        RefRecId                invoiceNumber;
        RefRecId                invoiceVoucher;
        NumberSequenceDatatype  numberDatatype;
        NumberSequenceDatatype  voucherDatatype;
        RefRecId                scopeId = NumberSeqScopeFactory::createDefaultScope().getId();
        NumberSeq               tmpNumberSeq;
        ProjProposalCost        tmpProjProposalCost;
        ProjProposalEmpl        tmpProjProposalEmpl;
        ProjProposalOnAcc       tmpProjProposalOnAcc;
        ProjProposalRevenue     tmpProjProposalRevenue;
        ProjProposalItem        tmpProjProposalItem;
        #ISOCountryRegionCodes

        creditNote = this.creditNote();
        switch (projProposalJour.InvoiceType)
        {
            case ProjInvoiceType::Invoice :
            case ProjInvoiceType::OnAccount:
                if (projProposalJour.NumberSequenceGroupId)
                {
                    if (creditNote)
                    {
                        numberDatatype = NumberSequenceDatatype::find(ProjParameters::numRefProjNormalCreditNoteId().NumberSequenceDatatype);
                        voucherDatatype = NumberSequenceDatatype::find(ProjParameters::numRefProjNormalCreditNoteVoucher().NumberSequenceDatatype);

                        invoiceNumber = NumberSequenceGroupRef::findNaturalKey(numberDatatype.RecId, scopeId, projProposalJour.NumberSequenceGroupId).NumberSequenceId;

                        if (!invoiceNumber)
                        {
                            invoiceNumber = ProjParameters::numRefProjNormalCreditNoteId().NumberSequenceId;
                        }

                        if (ProjParameters::numRefProjNormalCreditNoteVoucher().AllowSameAs)
                        {
                            voucherEqualsNumber = true;
                            invoiceVoucher      = invoiceNumber;
                        }
                        else
                        {
                            invoiceVoucher = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, projProposalJour.NumberSequenceGroupId).NumberSequenceId;

                            if (!invoiceVoucher)
                            {
                                invoiceVoucher = ProjParameters::numRefProjNormalCreditNoteVoucher().NumberSequenceId;
                            }
                        }
                    }
                    else
                    {
                        numberDatatype = NumberSequenceDatatype::find(ProjParameters::numRefProjNormalCreditNoteId().NumberSequenceDatatype);
                        voucherDatatype = NumberSequenceDatatype::find(ProjParameters::numRefProjNormalCreditNoteVoucher().NumberSequenceDatatype);

                        invoiceNumber = NumberSequenceGroupRef::findNaturalKey(numberDatatype.RecId, scopeId, projProposalJour.NumberSequenceGroupId).NumberSequenceId;

                        if (!invoiceNumber)
                        {
                            invoiceNumber = ProjParameters::numRefProjNormalInvoiceId().NumberSequenceId;
                        }

                        if (ProjParameters::numRefProjNormalInvoiceVoucher().AllowSameAs)
                        {
                            voucherEqualsNumber = true;
                            invoiceVoucher      = invoiceNumber;
                        }
                        else
                        {
                            invoiceVoucher = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, projProposalJour.NumberSequenceGroupId).NumberSequenceId;

                            if (!invoiceVoucher)
                            {
                                invoiceVoucher = ProjParameters::numRefProjNormalInvoiceVoucher().NumberSequenceId;
                            }
                        }
                    }

                    tmpNumberSeq = NumberSeq::newGetVoucherFromId(invoiceVoucher);
                }
                else
                {
                    if (creditNote)
                    {
                        numberSequenceReference  = ProjParameters::numRefProjNormalCreditNoteId();
                        voucherSequenceReference = ProjParameters::numRefProjNormalCreditNoteVoucher();

                        tmpNumberSeq = NumberSeq::newGetVoucher(ProjParameters::numRefProjNormalCreditNoteVoucher());
                    }
                    else
                    {
                        numberSequenceReference  = ProjParameters::numRefProjNormalInvoiceId();
                        voucherSequenceReference = ProjParameters::numRefProjNormalInvoiceVoucher();

                        tmpNumberSeq = NumberSeq::newGetVoucher(ProjParameters::numRefProjNormalInvoiceVoucher());
                    }
                }
                break;
        }

        // Italian functionality of VAT books and VAT book sections
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00028, funcName());
            if (! TaxBookSection::checkTaxBookSection(tmpNumberSeq.parmNumberSequenceId(), projProposalJour .InvoiceDate))
            {
                throw error("@SYS21533");
            }

            while select TaxGroupId, TaxItemGroupId from tmpProjProposalCost
                where tmpProjProposalCost.ProposalId == projProposalJour.ProposalId
            {
                if (! TaxGroupData::checkTaxGroups(tmpProjProposalCost.TaxGroupId, tmpProjProposalCost.TaxItemGroupId))
                {
                    throw error("@SYS21533");
                }
            }

            while select TaxGroupId, TaxItemGroupId from tmpProjProposalEmpl
                where tmpProjProposalEmpl.ProposalId == projProposalJour.ProposalId
            {
                if (! TaxGroupData::checkTaxGroups(tmpProjProposalEmpl.TaxGroupId, tmpProjProposalEmpl.TaxItemGroupId))
                {
                    throw error("@SYS21533");
                }
            }

            while select TaxGroupId, TaxItemGroupId from tmpProjProposalOnAcc
                where tmpProjProposalOnAcc.ProposalId == projProposalJour.ProposalId
            {
                if (! TaxGroupData::checkTaxGroups(tmpProjProposalOnAcc.TaxGroupId, tmpProjProposalOnAcc.TaxItemGroupId))
                {
                    throw error("@SYS21533");
                }
            }

            while select TaxGroupId, TaxItemGroupId from tmpProjProposalRevenue
                where tmpProjProposalRevenue.ProposalId == projProposalJour.ProposalId
            {
                if (! TaxGroupData::checkTaxGroups(tmpProjProposalRevenue.TaxGroupId, tmpProjProposalRevenue.TaxItemGroupId))
                {
                    throw error("@SYS21533");
                }
            }

            while select TaxGroupId, TaxItemGroupId from tmpProjProposalItem
                where tmpProjProposalItem.ProposalId == projProposalJour.ProposalId
            {
                if (! TaxGroupData::checkTaxGroups(tmpProjProposalItem.TaxGroupId, tmpProjProposalItem.TaxItemGroupId))
                {
                    throw error("@SYS21533");
                }
            }
        }

        return tmpNumberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDueDateFromDeliveryDate_ES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the due date based on the delivery date.
    /// </summary>
    /// <param name="_deliveryDate">
    /// The delivery date.
    /// </param>
    /// <param name="_paymTerm">
    /// The <c>PaymTerm</c> record; optional.
    /// </param>
    /// <param name="_paymDayId">
    /// The payment day identifier; optional.
    /// </param>
    /// <param name="_dueDateLimit">
    /// The number of days the due date can be past the delivery date; optional.
    /// </param>
    /// <returns>
    /// The due date.
    /// </returns>
    protected TransDate calculateDueDateFromDeliveryDate_ES(
        TransDate           _deliveryDate,
        PaymTerm            _paymTerm = null,
        PaymDayId           _paymDayId = '',
        PaymDueDateLimit_ES _dueDateLimit = null)
    {
        PaymTerm            paymTermLocal;
        PaymDueDateLimit_ES dueDateLimitLocal;
        PaymDueDateLimit_ES dueDateLimitTermsOfPayment;
        PaymDayId           paymDayIdLocal;

        paymTermLocal = _paymTerm;
        if (!paymTermLocal)
        {
            paymTermLocal = this.findProjectInvoicePaymTerm();
        }

        TransDate deliveryDateLocal = _deliveryDate;
        if (!paymTermLocal.UseDeliveryDateForDueDate_ES)
        {
            deliveryDateLocal = projInvoiceJour.InvoiceDate;
        }

        // Due date limit from terms of payment.
        dueDateLimitTermsOfPayment = PaymDueDateLimit_ES::getCurrentValues(paymTermLocal.DueDateLimitGroupId_ES);
        dueDateLimitLocal = _dueDateLimit;
        if (!dueDateLimitLocal ||
            (dueDateLimitTermsOfPayment &&
             dueDateLimitTermsOfPayment.getLastValidDate(deliveryDateLocal) < dueDateLimitLocal.getLastValidDate(deliveryDateLocal)))
        {
            dueDateLimitLocal = dueDateLimitTermsOfPayment;
        }

        paymDayIdLocal = _paymDayId;
        if (!paymDayIdLocal)
        {
            // Payment day id from project.
            paymDayIdLocal = projInvoiceJour.PaymDayId;
        }

        return paymTermLocal.due(deliveryDateLocal, paymDayIdLocal, false, dueDateLimitLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostEndDisc</Name>
				<Source><![CDATA[
    protected boolean canPostEndDisc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    protected boolean canPostLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostRoundOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether end roundings can be posted.
    /// </summary>
    /// <returns>
    /// true if roundings can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostRoundOff()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTax</Name>
				<Source><![CDATA[
    protected boolean canPostTax()
    {
        boolean ret = true;

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled())
        {
            TaxTable        taxTableRealized;
            TaxTable        taxTableUnrealized;

            TmpTaxWorkTrans tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();

            select firstonly TaxCode from tmpTaxWorkTrans
                join taxTableRealized
                    where ((taxTableRealized.TaxType_TH == TaxType_TH::Normal && taxTableRealized.PaymentTaxCode  == '')
                            || taxTableRealized.TaxType_TH == TaxType_TH::AverageRealized)
                        && taxTableRealized.TaxCode == tmpTaxWorkTrans.TaxCode;

            if (taxTableRealized)
            {
                select firstonly TaxCode from tmpTaxWorkTrans
                    join taxTableUnrealized
                        where ((taxTableUnrealized.TaxType_TH == TaxType_TH::Normal && taxTableUnrealized.PaymentTaxCode != '')
                                || taxTableUnrealized.TaxType_TH == TaxType_TH::AverageUnrealized)
                            && taxTableUnrealized.TaxCode == tmpTaxWorkTrans.TaxCode;

                if (taxTableUnrealized)
                {
                    // Both realized VAT and unrealized VAT exist in current posting invoice.
                    ret = checkFailed("@SYS4082809");
                }
            }
        }
        // </GTH>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCashDisc</Name>
				<Source><![CDATA[
    protected void createCashDisc()
    {
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerDimensionDefaultAccount   paidLedgerDimensionDefault;
        LedgerDimensionAccount          paidLedgerDimensionAccount;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerDimensionDefaultAccount   custCashDiscDefaultAccount;

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        paidLedgerDimensionDefault = CashDisc::find(projInvoiceJour.CashDiscCode).PaidLedgerDimension;

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(projInvoiceJour.ExchRate);
        exchangeRateHelper.parmExchangeRate2(projInvoiceJour.ExchrateSecondary);

        if (paidLedgerDimensionDefault)
        {
            paidLedgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(paidLedgerDimensionDefault, projInvoiceJour.DefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                         ledgerVoucherObject,
                                         LedgerPostingType::CustCashDisc,
                                         paidLedgerDimensionAccount,
                                         projInvoiceJour.CurrencyId,
                                         projInvoiceJour.CashDisc,
                                         exchangeRateHelper);
            ledgerVoucherTransObject.parmSourceTableId(projInvoiceJour.TableId);
            ledgerVoucherTransObject.parmSourceRecId(projInvoiceJour.RecId);
        }
        else
        {
            custCashDiscDefaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::CustCashDisc);
            if (custCashDiscDefaultAccount)
            {
                paidLedgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(custCashDiscDefaultAccount, projInvoiceJour.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                             ledgerVoucherObject,
                                             LedgerPostingType::CustCashDisc,
                                             paidLedgerDimensionAccount,
                                             projInvoiceJour.CurrencyId,
                                             projInvoiceJour.CashDisc,
                                             exchangeRateHelper);
                ledgerVoucherTransObject.parmSourceTableId(projInvoiceJour.TableId);
                ledgerVoucherTransObject.parmSourceRecId(projInvoiceJour.RecId);
            }
            else
            {
                throw error("@SYS99048");
            }
        }

        ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExportDocument_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates export document.
    /// </summary>
    protected void createExportDocument_CN()
    {
        TaxIntgrExportDocumentGenerator_CN::generate(
            projInvoiceJour.RecId,
            projInvoiceJour.TableId,
            projProposalJour.RecId,
            projProposalJour.TableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOnAccountCreditNote</Name>
				<Source><![CDATA[
    protected void createOnAccountCreditNote()
    {
        ProjOnAccTrans      projOnAccTrans;
        ProjOnAccTransSale  projOnAccTransSale;
        ProjOnAccTrans      projOnAccTransOrig;
        ProjOnAccTrans      projOnAccTransNew;
        ProjOnAccTransSale  projOnAccTransSaleNew;

        ProjProposalOnAcc       projProposalOnAcc;
        ProjProposalOnAccDetail projProposalOnAccDetail;
        ProjProposalOnAcc       projProposalOnAccNew;
        ProjProposalOnAccDetail projProposalOnAccDetailNew;
        ProjInvoiceOnAcc        projInvoiceOnAcc;
        ProjInvoiceJour         onAccountInvoiceJour;

        ProjProposalJour    creditProposalJour;
        ProjProposalTotals  creditProposalTotals;
        ProjFormLetter      creditFormLetter;

        ParmId              creditParmId;
        ProjTable           projTable;

        ProjInvoiceJour     creditInvoiceJour;

        CustTrans           custTransLocal;
        CustTransOpen       custTransOpen;

        SpecTransManager    specTransManager;

        AmountCur           amountCur;

        // Not implemented for proforma invoices

        if (proforma)
        {
            return;
        }

        // This is only active on normal invoices and if the payment criteria is selected
        if (projProposalJour.InvoiceType == ProjInvoiceType::OnAccount ||
            ProjParameters::find().OnAccountPaymentCriteria == NoYes::No)
        {
            return;
        }

        //
        // Process all on account invoicing offset postings on time and material projects
        // Exclude deduction records created from Cash Advances (PSAIsOnAccount)
        //
        while select projProposalOnAcc
            where projProposalOnAcc.ProposalId == projProposalJour.ProposalId
            join projOnAccTrans
                group by CurrencyId, ProjID, TaxGroupId, TaxItemGroupId
                where projOnAccTrans.TransId == projProposalOnAcc.TransId &&
                      projOnAccTrans.TransactionOrigin == ProjOrigin::Deduction &&
                      projOnAccTrans.PSAIsOnAccount == NoYes::No &&
                      projOnAccTrans.PSARefRecId == 0
                join projTable
                    where projTable.ProjId == projOnAccTrans.ProjID &&
                         (projTable.Type == ProjType::TimeMaterial ||
                          projTable.Type == ProjType::Time)
            join projProposalOnAccDetail
                where projProposalOnAccDetail.ProposalRefRecId == projProposalOnAcc.RecId
                join sum(Amount) from projOnAccTransSale
                    where projOnAccTransSale.RecId == projProposalOnAccDetail.SaleRefRecId &&
                        projOnAccTransSale.Amount < 0
        {
            amountCur = 0;

            // Sum up amount of on account invoices which is paid
            while select projInvoiceOnAcc
                where projInvoiceOnAcc.ProjId           == projOnAccTrans.ProjID        &&
                      projInvoiceOnAcc.CurrencyId       == projOnAccTrans.CurrencyId
                join RecId from projOnAccTransOrig
                    where projOnAccTransOrig.TransId             == projInvoiceOnAcc.TransId &&
                          (projOnAccTransOrig.TransactionOrigin  == ProjOrigin::Milestone ||
                           projOnAccTransOrig.TransactionOrigin  == ProjOrigin::Prepayment)
                    join InvoiceAmount, InvoiceDate, LedgerVoucher, ProjInvoiceId from onAccountInvoiceJour
                        where onAccountInvoiceJour.ProjInvoiceId == projInvoiceOnAcc.ProjInvoiceId &&
                              onAccountInvoiceJour.InvoiceAmount != 0
                        join RecId from custTransLocal
                            where custTransLocal.TransDate == onAccountInvoiceJour.InvoiceDate &&
                                  custTransLocal.Voucher   == onAccountInvoiceJour.LedgerVoucher &&
                                  custTransLocal.Invoice   == onAccountInvoiceJour.ProjInvoiceId
            {
                // Get the payment ratio of the invoice
                select sum(AmountCur) from custTransOpen
                    where custTransOpen.RefRecId == custTransLocal.RecId;

                amountCur += CurrencyExchangeHelper::amount(projInvoiceOnAcc.lineAmount() * (1 - custTransOpen.AmountCur / onAccountInvoiceJour.InvoiceAmount), projOnAccTrans.CurrencyId);
            }

            // Deduct already offset amount
            while select projInvoiceOnAcc
                where projInvoiceOnAcc.ProjId           == projOnAccTrans.ProjID        &&
                      projInvoiceOnAcc.CurrencyId       == projOnAccTrans.CurrencyId    &&
                      projInvoiceOnAcc.TaxGroupId       == projOnAccTrans.TaxGroupId    &&
                      projInvoiceOnAcc.TaxItemGroupId   == projOnAccTrans.TaxItemGroupId
                exists join  projOnAccTransOrig
                    where projOnAccTransOrig.TransId            == projInvoiceOnAcc.TransId &&
                          projOnAccTransOrig.TransactionOrigin  == ProjOrigin::Deduction
            {
                amountCur -= projInvoiceOnAcc.lineAmount();
            }

            // Checking for existing credit note with payment criteria enabled
            // If credit note already exists skip duplicate credit note creation
            select firstonly RecId from projInvoiceOnAcc
                where projInvoiceOnAcc.ProjId == projOnAccTrans.ProjID
                   && projInvoiceOnAcc.CurrencyId == projOnAccTrans.CurrencyId
                exists join projOnAccTransNew
                   where projOnAccTransNew.TransactionOrigin == ProjOrigin::Deduction
                     && projOnAccTransNew.ProjID == projOnAccTrans.ProjID
                     && projOnAccTransNew.TransId == projInvoiceOnAcc.TransId
                exists join projOnAccTransSaleNew
                   where projOnAccTransSaleNew.TransId == projOnAccTransNew.TransId
                     && (projOnAccTransSaleNew.TransStatus == ProjTransStatus::CreditnoteProposal
                || projOnAccTransSaleNew.TransStatus == ProjTransStatus::InvoiceProposal);
            if (projInvoiceOnAcc.RecId)
            {
                return;
            }

            // If the offset transaction is not paid fully, make a credit note for the difference
            if (projOnAccTransSale.Amount + amountCur < 0)
            {
                // Create a proposal header for the credit note
                if (!creditProposalJour)
                {
                    creditProposalJour.data(projProposalJour);
                    creditProposalJour.ProposalId   = NumberSeq::newGetNum( ProjParameters::numRefProjProposalId()).num();
                    creditProposalJour.InvoiceType  = ProjInvoiceType::OnAccount;
                    creditProposalJour.insert();
                }

                // Create a on account transaction for the credit note
                projOnAccTransNew.clear();
                projOnAccTransNew.initValue();
                projOnAccTransNew.ProjID                = projOnAccTrans.ProjID;
                projOnAccTransNew.CurrencyId            = projOnAccTrans.CurrencyId;
                projOnAccTransNew.TransDate             = projProposalJour.InvoiceDate;
                projOnAccTransNew.TaxGroupId            = projOnAccTrans.TaxGroupId;
                projOnAccTransNew.TaxItemGroupId        = projOnAccTrans.TaxItemGroupId;

                if (ProjTable::find(projOnAccTrans.ProjID).Type == ProjType::TimeMaterial)
                {
                    projOnAccTransNew.TransactionOrigin = ProjOrigin::Prepayment;
                }
                else
                {
                    projOnAccTransNew.TransactionOrigin = ProjOrigin::Milestone;
                }

                projOnAccTransNew.Description           = "@SYS98513";
                projOnAccTransNew.insert();

                projOnAccTransSaleNew.clear();
                projOnAccTransSaleNew.initValue();
                projOnAccTransSaleNew.initFromProjOnAccTrans(projOnAccTransNew);
                projOnAccTransSaleNew.Amount = amountCur + projOnAccTransSale.Amount;
                projOnAccTransSaleNew.TransStatus = ProjTransStatus::Invoiced;
                projOnAccTransSaleNew.doInsert();

                // <GTE>
                if (TaxIntegrationUtils::isTaxInformationEnabled())
                {
                    projTable = ProjTable::find(projOnAccTrans.ProjID);
                    TransTaxInformationHelper::copyTransTaxInformation(projTable, projOnAccTransSaleNew);
                }
                // </GTE>

                // Create a proposal line for the credit note
                projProposalOnAccNew.clear();
                projProposalOnAccNew                    =  ProjProposalOnAcc::initProposaleFromTrans(projOnAccTransNew);
                projProposalOnAccNew.ProposalId         = creditProposalJour.ProposalId;
                projProposalOnAccNew.insert();

                // <GEEPL>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    TaxServiceTariff::insertTaxServiceTariffForNewParent(projOnAccTransNew.TableId, projOnAccTransNew.RecId, projProposalOnAccNew.TableId, projProposalOnAccNew.RecId);
                }
                // </GEEPL>

                projProposalOnAccDetailNew.clear();
                projProposalOnAccDetailNew              =  ProjProposalOnAccDetail::initProposaleFromTrans(projOnAccTransSaleNew);
                projProposalOnAccDetailNew.ProposalRefRecId = projProposalOnAccNew.RecId;
                projProposalOnAccDetailNew.insert();

                // Create an on account transaction for the offset on the original invoice
                projOnAccTransNew.TransId               = ProjParameters::newTransId();
                projOnAccTransNew.Description           = "@SYS98513";
                projOnAccTransNew.TransactionOrigin     = ProjOrigin::Deduction;
                projOnAccTransNew.insert();

                projOnAccTransSaleNew.TransId = projOnAccTransNew.TransId;
                projOnAccTransSaleNew.Amount = -(amountCur + projOnAccTransSale.Amount);
                projOnAccTransSaleNew.TransStatus = ProjTransStatus::Invoiced;
                projOnAccTransSaleNew.insert();

                // <GIN>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                {
                    projTable = ProjTable::find(projOnAccTrans.ProjID);
                    TransTaxInformationHelper::copyTransTaxInformation(projTable, projOnAccTransSaleNew);
                }
                // </GIN>

                // Create a proposal line for the offset on the original invoice

                projProposalOnAccNew.clear();
                projProposalOnAccNew                    = ProjProposalOnAcc::initProposaleFromTrans(projOnAccTransNew);
                projProposalOnAccNew.ProposalId         = projProposalJour.ProposalId;
                projProposalOnAccNew.insert();

                // <GEEPL>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    TaxServiceTariff::insertTaxServiceTariffForNewParent(projOnAccTransNew.TableId, projOnAccTransNew.RecId, projProposalOnAccNew.TableId, projProposalOnAccNew.RecId);
                }
                // </GEEPL>

                projProposalOnAccDetailNew.clear();
                projProposalOnAccDetailNew              =  ProjProposalOnAccDetail::initProposaleFromTrans(projOnAccTransSaleNew);
                projProposalOnAccDetailNew.ProposalRefRecId = projProposalOnAccNew.RecId;
                projProposalOnAccDetailNew.insert();
            }
        }

        // Calculcate totals and post the credit note if any corrections
        if (creditProposalJour)
        {
            // Calculate totals and update the <ProjInvoiceJour> by considering the newly created on-account transactions
            ttsbegin;

            select firstonly forupdate projInvoiceJour
                where projInvoiceJour.ProposalId == projProposalJour.ProposalId;

            if (projInvoiceJour)
            {
                projProposalTotals = new ProjProposalTotals(projProposalJour, projInvoiceJour.ParmId);
                projProposalTotals.calc();

                projInvoiceJour.Qty = projProposalTotals.projInvoiceItemQty();
                projInvoiceJour.Weight = projProposalTotals.projInvoiceItemWeight();
                projInvoiceJour.Volume = projProposalTotals.projInvoiceItemVolume();
                projInvoiceJour.SumTax = projProposalTotals.projInvoiceTaxTotal();
                projInvoiceJour.EndDisc = projProposalTotals.projInvoiceEndDisc();
                projInvoiceJour.CashDisc = projProposalTotals.projInvoiceCashDisc();
                projInvoiceJour.CostValue = projProposalTotals.projInvoiceCostValue();
                projInvoiceJour.SumMarkup = projProposalTotals.projInvoiceMarkup();
                projInvoiceJour.InvoiceAmount = projProposalTotals.projInvoiceTotalAmount();
                projInvoiceJour.InvoiceRoundOff = projProposalTotals.projInvoiceRoundOff();
                projInvoiceJour.SalesOrderbalance = projProposalTotals.projInvoiceBalance();

                projInvoiceJour.update();
            }

            ttscommit;

            creditProposalTotals = new ProjProposalTotals(creditProposalJour);
            creditProposalTotals.calc();

            creditProposalJour.CostValue           = creditProposalTotals.projInvoiceCostValue();
            creditProposalJour.CashDisc            = creditProposalTotals.projInvoiceCashDisc();
            creditProposalJour.InvoiceRoundOff     = creditProposalTotals.projInvoiceRoundOff();
            creditProposalJour.InvoiceAmount       = creditProposalTotals.projInvoiceTotalAmount();
            creditProposalJour.OnAccountAmount     = creditProposalTotals.projOnAccAmount();

            creditProposalJour.calcDue();
            creditProposalJour.calcCashDiscDate();
            creditProposalJour.update();

            creditFormLetter = ProjFormLetter::construct(DocumentStatus::ProjectInvoice);
            creditParmId     = creditFormLetter.parmId();
            creditFormLetter.unpack(formLetter.pack());
            creditFormLetter.parmId(creditParmId);
            creditFormLetter.createParmLine(creditProposalJour);
            creditFormLetter.runOperation();

            // Make open transaction records for the created creditnote

            select firstonly InvoiceDate, ProjInvoiceId, InvoiceAccount from creditInvoiceJour
                where creditInvoiceJour.ProposalId      == creditProposalJour.ProposalId     &&
                      creditInvoiceJour.InvoiceAccount  == creditProposalJour.InvoiceAccount &&
                      creditInvoiceJour.InvoiceDate     == creditProposalJour.InvoiceDate;

            select firstonly AccountNum, CurrencyCode, RecId from custTransLocal
                where custTransLocal.TransDate   == creditInvoiceJour.InvoiceDate    &&
                      custTransLocal.Invoice     == creditInvoiceJour.ProjInvoiceId  &&
                      custTransLocal.AccountNum  == creditInvoiceJour.InvoiceAccount;

            projTable = ProjTable::find(projOnAccTransNew.ProjID);

            specTransManager = SpecTransManager::newFromSpec(projTable, false);

            while select custTransOpen
                where custTransOpen.AccountNum == custTransLocal.AccountNum &&
                      custTransOpen.RefRecId   == custTransLocal.RecId
            {
                specTransManager.insert(custTransOpen.company(), custTransOpen.TableId, custTransOpen.RecId, custTransOpen.AmountCur, custTransLocal.CurrencyCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPayment</Name>
				<Source><![CDATA[
    protected void createPayment()
    {
        CustTrans custTransLocal;

        projInvoiceJour.CustVendInvoiceJour::custVendTrans(custTransLocal);

        if (CustPaymModeTable::find(custTransLocal.PaymMode).PaymOnInvoice)
        {
            CustVendPaymInvoiceWithJournal::construct(projInvoiceJour).run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentSched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a payment schedule.
    /// </summary>
    protected void createPaymentSched()
    {
        if (projProposalJour.Paymentsched && !CustPaymSched::exist(projProposalJour.TableId,projProposalJour.RecId))
        {
            CustVendPaymSched custVendPaymSched = CustVendPaymSched::construct(SysModule::Project, projProposalJour);
            custVendPaymSched.copyPaymSched(PaymSched::find(projProposalJour.Paymentsched));
            projProposalJour.createPaymentSchedule();
        }

        if (CustPaymSched::exist(projInvoiceParmTable.TableId, projInvoiceParmTable.RecId))
        {
            projInvoiceParmTable.copyPaymentSched(projInvoiceJour);
        }
        else if (CustPaymSched::exist(projProposalJour.TableId, projProposalJour.RecId) && !CustPaymSched::exist(projInvoiceJour.TableId,projInvoiceJour.RecId))
        {
            projProposalJour.copyPaymentSched(projInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceCost</Name>
				<Source><![CDATA[
    protected void createProjInvoiceCost()
    {
        ProjProposalCost            projProposalCost;
        ProjCostTrans               projCostTrans;
        ProjProposalCostDetail      projProposalCostDetail;
        ProjCostTransSale           projCostTransSale;

        recordListProjProposalCost.first(projProposalCost);

        while (projProposalCost)
        {
            numOfInvCost++;
            
            ProjTransCostProposal projTransCostProposal = ProjTrans::newProjProposalCost(projProposalCost);

            ProjPost projPostInvoiceCost = ProjPost::newEnterSalesAccrued_Proposal(projProposalCost, ledgerVoucher);

            this.validateNoTax(projTransCostProposal);

            // <GEERU>
            if (countryRegion_RU)
            {
                projPostInvoiceCost.parmTax_RU(this.tax());
            }
            // </GEERU>
            projPostInvoiceCost.postTrans();

            boolean useBudgeting = ProjTable::find(projTransCostProposal.projId()).UseBudgeting;

            while select projProposalCostDetail
                where projProposalCostDetail.ProposalRefRecId == projProposalCost.RecId
                    join projCostTransSale
                        where projCostTransSale.RecId == projProposalCostDetail.SaleRefRecId
                            join projCostTrans
                                where projCostTrans.TransId == projCostTransSale.TransId
            {
                // Budget Checking
                if (useBudgeting)
                {
                    if (this.reverseProjBudgetTransaction(projCostTransSale.TransId))
                    {
                        projBudgetTransactionReverse = ProjBudgetTransaction::construct(projCostTransSale);
                    }

                    projBudgetTransactionNormal = ProjBudgetTransaction::construct(projProposalCostDetail);

                    boolean canJournalBeInvoiced = this.projAdjustBudget();

                    if (!canJournalBeInvoiced)
                    {
                        throw Exception::Error;
                    }
                }

                this.transStatus = projCostTransSale.TransStatus;

                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());

                this.postProjPostCostProposalSale(projProposalCost, projCostTrans, projProposalCostDetail, projCostTransSale, projPostInvoiceCost);

                container con = ProjCostTransCost::findForSalesRefRecId(projProposalCostDetail.SaleRefRecId);
                Query query = new Query(con);
                QueryRun queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    ProjCostTransCost projCostTransCost = queryRun.get(tableNum(ProjCostTransCost));

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        this.setTaxTo(ProjPost::newEnterCost_ProposalDetail(
                            projProposalCost,
                            projProposalCostDetail,
                            projCostTrans,
                            projCostTransCost,
                            ledgerVoucher,
                            this.transStatus)).postTrans();
                    }
                    else
                    {
                        // </GEERU>
                        ProjPost::newEnterCost_ProposalDetail(
                            projProposalCost,
                            projProposalCostDetail,
                            projCostTrans,
                            projCostTransCost,
                            ledgerVoucher,
                            this.transStatus).postTrans();
                        // <GEERU>
                    }
                    // </GEERU>
                    if (this.transStatus != ProjTransStatus::CreditnoteProposal)
                    {
                        if (this.validateProjCostLedgerStatus(projCostTransCost))
                        {
                            // <GEERU>
                            if (countryRegion_RU)
                            {
                                this.setTaxTo(
                                    ProjPost::newEnterCost_TrxDetail(
                                        projCostTrans, projCostTransCost, ledgerVoucher,
                                        ProjLedgerStatus::Operations, ProjOrigin::Invoice
                                    )
                                ).postTrans();
                            }
                            else
                            {
                                // </GEERU>
                                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucher, ProjLedgerStatus::Operations, ProjOrigin::Invoice).postTrans();
                                // <GEERU>
                            }
                            // </GEERU>
                        }
                    }
                }
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projTransCostProposal.transDate()));
            }

            if (!recordListProjProposalCost.next(projProposalCost))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjPostCostProposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts ledger journal entries for the sales transaction.
    /// </summary>
    /// <param name = "_projProposalCost">
    /// A <c>ProjProposalCost</c> record.
    /// </param>
    /// <param name = "_projCostTrans">
    /// A <c>ProjCostTrans</c> record.
    /// </param>
    /// <param name = "_projProposalCostDetail">
    /// A <c>ProjProposalCostDetail</c> record.
    /// </param>
    /// <param name = "_projCostTransSale">
    /// A <c>ProjCostTransSale</c> record.
    /// </param>
    /// <param name = "_projPostInvoiceCost">
    /// A <c>ProjPost</c> class instance.
    /// </param>
    protected void postProjPostCostProposalSale(ProjProposalCost _projProposalCost,
        ProjCostTrans _projCostTrans,
        ProjProposalCostDetail _projProposalCostDetail,
        ProjCostTransSale _projCostTransSale,
        ProjPost _projPostInvoiceCost)
    {
        ProjTransCostProposalSale projTransCostProposalSale = ProjTrans::newProjProposalCostSale(_projProposalCost, _projProposalCostDetail, _projCostTransSale);

        ProjPost projPostCostProposalSale = ProjPost::newEnterSalesAccrued_ProposalDetail(
                                                _projProposalCost,
                                                _projProposalCostDetail,
                                                _projCostTrans,
                                                _projCostTransSale,
                                                ledgerVoucher,
                                                projTransCostProposalSale.ledgerSalesPosted());
        projPostCostProposalSale.parmTaxParentReferenceRecId(_projPostInvoiceCost.newTrans().RecId);
        projPostCostProposalSale.parmTaxParentReferenceTableId(_projPostInvoiceCost.newTrans().TableId);
        // <GEERU>
        if (countryRegion_RU)
        {
            projPostCostProposalSale.parmTax_RU(this.tax());
        }
        // </GEERU>
        projPostCostProposalSale.postTrans();
        
        if (isFlightEnabled(projUpdateExpenseSalesTaxVoucherDescForCostTransFlight))
        {
            GeneralJournalAccountEntry generalJournalAccountEntry;
            GeneralJournalEntry generalJournalEntry;
        
            ttsbegin;
            select forupdate generalJournalAccountEntry
            exists join generalJournalEntry
                where generalJournalEntry.SubledgerVoucher == _projCostTrans.VoucherJournal
                    && generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    && generalJournalAccountEntry.PostingType == LedgerPostingType::Tax
                    && generalJournalAccountEntry.Text == '';

            // Update description of sales tax line with project-invoiced revenue line description for expense journal.
            if (generalJournalAccountEntry)
            {
                TransactionTxt transactionTxtForExpense = TransactionTxt::construct();
                transactionTxtForExpense.setType(ProjParameters::find().DisplayDefaultDescriptionTextOfProjectSalesTax == NoYes::Yes ? LedgerTransTxt::ProjectSalesTax : this.defaultLedgerTransactionText());
                transactionTxtForExpense.setLanguage(projInvoiceJour.LanguageId);
                transactionTxtForExpense.setVoucher(projProposalJour.LedgerVoucher ? projProposalJour.LedgerVoucher : projInvoiceJour.LedgerVoucher);

                // If multiple funding sources are present for the project expense journal,
                // sales line tax description should only hold transaction date and voucher.
                if (ProjFundingSource::numberOfFundingSources(projInvoiceTable.ProjInvoiceProjId) == 1)
                {
                    transactionTxtForExpense.setFormLetter(projInvoiceJour.ProjInvoiceId);
                    transactionTxtForExpense.setCustVendName(projProposalJour.DeliveryName ? projProposalJour.DeliveryName : projInvoiceJour.DeliveryName);
                    transactionTxtForExpense.setKey1(projInvoiceJour.ProjInvoiceProjId);
                    transactionTxtForExpense.setKey2(projInvoiceJour.InvoiceAccount);
                    transactionTxtForExpense.setKey3(CustTable::groupId(projInvoiceJour.InvoiceAccount));
                }
                generalJournalAccountEntry.Text = transactionTxtForExpense.txt();
                generalJournalAccountEntry.update();
            }
            ttscommit;
        }

        this.updateActualsOnPosting(_projCostTrans.TransId, _projPostInvoiceCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActualsOnPosting</Name>
				<Source><![CDATA[
    private void updateActualsOnPosting(ProjTransIdBase _transId, ProjPost _projPost)
    {
        if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            ProjActualsInvoicePostingUpdateParameters projActualsInvoicePostingUpdateParameters = ProjActualsInvoicePostingUpdateParameters::construct();
            projActualsInvoicePostingUpdateParameters.voucher = this.voucher;
            projActualsInvoicePostingUpdateParameters.accountingAmount = _projPost.ledgerSalesAmount();
            projActualsInvoicePostingUpdateParameters.exchRate = _projPost.exchRateSales();
            projActualsInvoicePostingUpdateParameters.taxAmount = _projPost.parmTaxAmountCur();
            projActualsInvoicePostingUpdateParameters.invoiceProposalLineTransId = _transId;
            projActualsInvoicePostingUpdateParameters.invoiceProposalId = _projPost.parmProjTrans().proposalId();

            if (projActualsInvoicePostingUpdateParameters.taxAmount == 0 &&
                _projPost.parmProjTrans().taxGroup() &&
                _projPost.parmProjTrans().taxItemGroup())
            {
                TableId proposalTransTableId;
                RecId proposalTransRecId;
                switch (_projPost.parmProjTrans().transType())
                {
                    case ProjTransType::Cost:
                        ProjProposalCost projProposalCost = ProjProposalCost::find(_projPost.parmProjTrans().transId(), _projPost.parmProjTrans().proposalId());
                        proposalTransTableId = tableName2Id(tableStr(ProjProposalCost));
                        proposalTransRecId = projProposalCost.RecId;
                        break;

                    case ProjTransType::Hour:
                        ProjProposalEmpl projProposalEmpl = ProjProposalEmpl::find(_projPost.parmProjTrans().transId(), _projPost.parmProjTrans().proposalId());
                        proposalTransTableId = tableName2Id(tableStr(ProjProposalEmpl));
                        proposalTransRecId = projProposalEmpl.RecId;
                        break;
                    
                    /* TODO: Item for CE integration is to be implemented. */
                    case ProjTransType::Item:
                        break;

                    case ProjTransType::Revenue:
                        ProjProposalRevenue projProposalRevenue = ProjProposalRevenue::find(_projPost.parmProjTrans().transId(), _projPost.parmProjTrans().proposalId());
                        proposalTransTableId = tableName2Id(tableStr(ProjProposalRevenue));
                        proposalTransRecId = projProposalRevenue.RecId;
                        break;

                    case ProjTransType::OnAccount:
                        ProjProposalOnacc projProposalOnacc = ProjProposalOnacc::find(_projPost.parmProjTrans().transId(), _projPost.parmProjTrans().proposalId());
                        proposalTransTableId = tableName2Id(tableStr(ProjProposalOnacc));
                        proposalTransRecId = projProposalOnacc.RecId;
                        break;
                }

                projActualsInvoicePostingUpdateParameters.taxAmount = this.tax().totalTaxAmountSingleLine(proposalTransTableId, proposalTransRecId, true, true);
            }
            
            this.updateActualsV2(projActualsInvoicePostingUpdateParameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActuals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the actuals record with the invoice posting details from the <c>ProjActualsInvoicePostingUpdateParameters</c> class.
    /// </summary>
    /// <param name = "_transId">The project trans Id of the invoice proposal line.</param>
    /// <param name = "_projActualsInvoicePostingUpdateParameters">The object that holds the posting data that is to be updated on to the actuals.</param>
    [SysObsolete('updateActuals is obsolete, use updateActualsV2 method instead.', true, 03\03\2023)]
    protected void updateActuals(ProjTransIdBase _transId, ProjActualsInvoicePostingUpdateParameters _projActualsInvoicePostingUpdateParameters)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActualsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the actuals record with the invoice posting details from the <c>ProjActualsInvoicePostingUpdateParameters</c> class.
    /// </summary>
    /// <param name = "_projActualsInvoicePostingUpdateParameters">The object that holds the posting data that is to be updated on to the actuals.</param>
    protected void updateActualsV2(ProjActualsInvoicePostingUpdateParameters _projActualsInvoicePostingUpdateParameters)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceEmpl</Name>
				<Source><![CDATA[
    protected void createProjInvoiceEmpl()
    {
        ProjProposalEmpl                projProposalEmpl;
        ProjEmplTrans                   projEmplTrans;
        ProjTrans                       projTransEmplProposal;
        ProjProposalEmplDetail          projProposalEmplDetail;
        ProjEmplTransSale               projEmplTransSale;
        boolean                         isCreditNote;

        PSAIndirectComponentTrans       psaIndirectComponentTrans;

        recordListProjProposalEmpl.first(projProposalEmpl);

        while (projProposalEmpl)
        {
            numOfInvEmpl++;
            
            projTransEmplProposal = ProjTrans::newProjProposalEmpl(projProposalEmpl);

            ProjPost projPostInvoiceEmpl = ProjPost::newEnterSalesAccrued_Proposal(projProposalEmpl, ledgerVoucher);

            this.validateNoTax(projTransEmplProposal);

            // <GEERU>
            if (countryRegion_RU)
            {
                projPostInvoiceEmpl.parmTax_RU(this.tax());
            }
            // </GEERU>
            projPostInvoiceEmpl.postTrans();

            ProjTable projTable = ProjTable::find(projTransEmplProposal.projId());

            while select projProposalEmplDetail
                where projProposalEmplDetail.ProposalRefRecId == projProposalEmpl.RecId
                    join projEmplTransSale
                        where projEmplTransSale.RecId == projProposalEmplDetail.SaleRefRecId
                            join projEmplTrans
                                where projEmplTrans.TransId == projEmplTransSale.TransId
            {
                //Project Budget Checking
                if (projTable.UseBudgeting)
                {
                    if (this.reverseProjBudgetTransaction(projEmplTransSale.TransId))
                    {
                        projBudgetTransactionReverse = ProjBudgetTransaction::construct(projEmplTransSale);
                    }

                    projBudgetTransactionNormal = ProjBudgetTransaction::construct(projProposalEmplDetail);

                    boolean canJournalBeInvoiced = this.projAdjustBudget();

                    if (!canJournalBeInvoiced)
                    {
                        throw Exception::Error;
                    }
                }
                ProjTransStatus projTransStatus = projEmplTransSale.TransStatus;

                NoYes emplTransTurnover = ProjRevRecHelper::postWIPEmplForProject(projTable);
                if (projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal)
                {
                    isCreditNote = true;
                    projEmplTransSale.LedgerSalesPosted = emplTransTurnover;
                }

                if (emplTransTurnover &&
                    (projEmplTransSale.psaIndirectRevenue > 0 ||
                    (projEmplTransSale.PSAIndirectRevenue < 0 && ProjIndirectCostAccruedRevenueReversalFlight::instance().isEnabled())))
                {
                    ProjPost psaProjPostEmplIndirectSalesAccrued = ProjPost::psaReverseProjIndirectRevenue(
                                                projProposalEmpl,
                                                projProposalEmplDetail,
                                                projEmplTrans,
                                                projEmplTransSale,
                                                ledgerVoucher);

                    psaProjPostEmplIndirectSalesAccrued.parmTaxParentReferenceRecId(projPostInvoiceEmpl.newTrans().RecId);
                    psaProjPostEmplIndirectSalesAccrued.parmTaxParentReferenceTableId(projPostInvoiceEmpl.newTrans().TableId);
                    psaProjPostEmplIndirectSalesAccrued.postTrans();
                }
                
                if (transactionTxt.txt())
                {
                    ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
                    ledgerVoucher.findLedgerVoucherObject().parmHasDefaultDescription(true);
                }

                this.postProjPostEmplProposalSale(projProposalEmpl, projEmplTrans, projProposalEmplDetail, projEmplTransSale, projPostInvoiceEmpl);

                if (ProjInvoiceTable::find(PSAContractLineItems::find(projProposalEmpl.psaContractLineNum).ProjInvoiceProjId).psaContractLines == NoYes::Yes)
                {
                    if (PSAContractLineItems::find(projProposalEmpl.psaContractLineNum).IncludeIndirectCost == NoYes::Yes)
                    {
                        ProjPost::psaNewEnterIndirectSalesAccrued(projProposalEmpl, ledgerVoucher, projTransEmplProposal.ledgerSalesPosted(), false, isCreditNote).postTrans();
                    }
                }
                else
                {
                    ProjPost::psaNewEnterIndirectSalesAccrued(projProposalEmpl, ledgerVoucher, projTransEmplProposal.ledgerSalesPosted(), false, isCreditNote).postTrans();
                }

                container con = ProjEmplTransCost::findForSalesRefRecId(projProposalEmplDetail.SaleRefRecId);
                ProjLedgerStatus emplLedgerStatus = ProjRevRecHelper::getEmplLedgerStatus(projEmplTrans.projTable());

                Query query = new Query(con);
                QueryRun queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    ProjEmplTransCost projEmplTransCost = queryRun.get(tableNum(ProjEmplTransCost));
                    
                    // Indirect costs for credit note
                    if (projTransStatus == ProjTransStatus::CreditnoteProposal &&
                        projEmplTransCost.LedgerStatusCost == ProjLedgerStatus::Operations &&
                        emplLedgerStatus == ProjLedgerStatus::BalanceSheet)
                    {
                        while select psaIndirectComponentTrans
                            where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                                  psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                                  psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                        {
                            ProjPost::newEnterCost_TrxDetail(projEmplTrans,
                                                             projEmplTransCost,
                                                             ledgerVoucher,
                                                             ProjLedgerStatus::BalanceSheet,
                                                             ProjOrigin::Invoice,
                                                             false,
                                                             false,
                                                             psaIndirectComponentTrans).postTrans();
                        }
                    }

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        this.setTaxTo(
                            ProjPost::newEnterCost_ProposalDetail(
                                projProposalEmpl,
                                projProposalEmplDetail,
                                projEmplTrans,
                                projEmplTransCost,
                                ledgerVoucher,
                                projTransStatus
                           )
                        ).postTrans();
                    }
                    else
                    {
                        // </GEERU>
                        ProjPost::newEnterCost_ProposalDetail(
                            projProposalEmpl,
                            projProposalEmplDetail,
                            projEmplTrans,
                            projEmplTransCost,
                            ledgerVoucher,
                            projTransStatus).postTrans();
                        // <GEERU>
                    }
                    //</GEERU>

                    if ((projTransStatus != ProjTransStatus::CreditnoteProposal))
                    {
                        if (projEmplTransCost.LedgerStatusCost == ProjLedgerStatus::None ||
                            projEmplTransCost.LedgerStatusCost == ProjLedgerStatus::BalanceSheet)
                        {
                            while select psaIndirectComponentTrans
                                where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                                    psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                                    psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                            {
                                // <GEERU>
                                if (countryRegion_RU)
                                {
                                    this.setTaxTo(
                                        ProjPost::newEnterCost_TrxDetail(
                                            projEmplTrans, projEmplTransCost, ledgerVoucher,
                                            ProjLedgerStatus::Operations, ProjOrigin::Invoice,
                                            false, false, psaIndirectComponentTrans
                                        )
                                    ).postTrans();
                                }
                                else
                                {
                                    // </GEERU>
                                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucher, ProjLedgerStatus::Operations, ProjOrigin::Invoice,
                                            false, false, psaIndirectComponentTrans).postTrans();
                                    // <GEERU>
                                }
                                //</GEERU>
                            }

                            // <GEERU>
                            if (countryRegion_RU)
                            {
                                this.setTaxTo(
                                    ProjPost::newEnterCost_TrxDetail(
                                        projEmplTrans, projEmplTransCost, ledgerVoucher,
                                        ProjLedgerStatus::Operations, ProjOrigin::Invoice
                                    )
                                ).postTrans();
                            }
                            else
                            {
                                // </GEERU>
                                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucher, ProjLedgerStatus::Operations, ProjOrigin::Invoice).postTrans();
                                // <GEERU>
                            }
                            //</GEERU>
                        }
                    }
                    //creditnote for none ledger group must be redrawn
                    else if (projTransStatus == ProjTransStatus::CreditnoteProposal         &&
                             projEmplTransCost.LedgerStatusCost == ProjLedgerStatus::Operations &&
                             emplLedgerStatus == ProjLedgerStatus::None)
                    {
                        if (projEmplTransCost.LedgerStatusCost == ProjLedgerStatus::Operations)
                        {
                            while select psaIndirectComponentTrans
                                where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                                    psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                                    psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                            {
                                // <GEERU>
                                if (countryRegion_RU)
                                {
                                    this.setTaxTo(
                                        ProjPost::newEnterCost_TrxDetail(
                                            projEmplTrans, projEmplTransCost, ledgerVoucher,
                                            ProjLedgerStatus::None, ProjOrigin::Invoice,
                                            false, false, psaIndirectComponentTrans)
                                    ).postTrans();
                                }
                                else
                                {
                                    // </GEERU>
                                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucher, ProjLedgerStatus::None, ProjOrigin::Invoice,
                                            false, false, psaIndirectComponentTrans).postTrans();
                                    // <GEERU>
                                }
                                //</GEERU>
                            }

                            // <GEERU>
                            if (countryRegion_RU)
                            {
                                this.setTaxTo(
                                    ProjPost::newEnterCost_TrxDetail(
                                        projEmplTrans, projEmplTransCost, ledgerVoucher,
                                        ProjLedgerStatus::None, ProjOrigin::Invoice)
                                ).postTrans();
                            }
                            else
                            {
                                // </GEERU>
                                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucher, ProjLedgerStatus::None, ProjOrigin::Invoice).postTrans();
                                // <GEERU>
                            }
                            //</GEERU>
                        }
                    }
                }
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projTransEmplProposal.transDate()));
            }

            if (!recordListProjProposalEmpl.next(projProposalEmpl))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjPostEmplProposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts ledger journal entries for the employee transaction.
    /// </summary>
    /// <param name = "_projProposalEmpl">
    /// A <c>ProjProposalEmpl</c> record.
    /// </param>
    /// <param name = "_projEmplTrans">
    /// A <c>ProjEmplTrans</c> record.
    /// </param>
    /// <param name = "_projProposalEmplDetail">
    /// A <c>ProjProposalEmplDetail</c> record.
    /// </param>
    /// <param name = "_projEmplTransSale">
    /// A <c>ProjEmplTransSale</c> record.
    /// </param>
    /// <param name = "_projPostInvoiceEmpl">
    /// A <c>ProjPost</c> class instance.
    /// </param>
    protected void postProjPostEmplProposalSale(ProjProposalEmpl _projProposalEmpl,
        ProjEmplTrans _projEmplTrans,
        ProjProposalEmplDetail _projProposalEmplDetail,
        ProjEmplTransSale _projEmplTransSale,
        ProjPost _projPostInvoiceEmpl)
    {
        ProjTrans projTransEmplProposalSale = ProjTrans::newProjProposalEmplSale(_projProposalEmpl, _projProposalEmplDetail, _projEmplTransSale);

        ProjPost projPostEmplProposalSale  = ProjPost::newEnterSalesAccrued_ProposalDetail(
                                                _projProposalEmpl,
                                                _projProposalEmplDetail,
                                                _projEmplTrans,
                                                _projEmplTransSale,
                                                ledgerVoucher,
                                                projTransEmplProposalSale.ledgerSalesPosted());
        projPostEmplProposalSale.parmTaxParentReferenceRecId(_projPostInvoiceEmpl.newTrans().RecId);
        projPostEmplProposalSale.parmTaxParentReferenceTableId(_projPostInvoiceEmpl.newTrans().TableId);
        // <GEERU>
        if (countryRegion_RU)
        {
            projPostEmplProposalSale.parmTax_RU(this.tax());
        }
        // </GEERU>
        projPostEmplProposalSale.postTrans();

        this.updateActualsOnPosting(_projEmplTrans.TransId, _projPostInvoiceEmpl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceItem</Name>
				<Source><![CDATA[
    protected void createProjInvoiceItem()
    {
        ProjProposalItem                    projProposalItem;
        ProjItemTrans                       projItemTrans;
        ProjProposalItemDetail              projProposalItemDetail;
        ProjItemTransSale                   projItemTransSale;
        boolean                             checkEnterCostValue;

        recordListProjProposalItem.first(projProposalItem);

        while (projProposalItem)
        {
            numOfInvItem++;

            this.postStockedItemInventFinancialForItemRequirements(projProposalItem);

            ProjTrans projTransItemProposal = ProjTrans::newProjProposalItem(projProposalItem);
            ProjLedgerStatus projLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(ProjTable::find(projTransItemProposal.projId()));

            this.validateNoTax(projTransItemProposal);

            ProjPost projPostInvoiceItem = ProjPost::newEnterSalesAccrued_Proposal(projProposalItem, ledgerVoucher);
            // <GEERU>
            if (countryRegion_RU)
            {
                projPostInvoiceItem.parmTax_RU(this.tax());
            }
            // </GEERU>
            projPostInvoiceItem.postTrans();

            this.matchInvoicePackingSlip(projProposalItem, projPostInvoiceItem.newTrans());

            boolean useBudgeting = ProjTable::find(projTransItemProposal.projId()).UseBudgeting;

            while select projProposalItemDetail
                where projProposalItemDetail.ProposalRefRecId == projProposalItem.RecId
                    join projItemTransSale
                        where projItemTransSale.RecId == projProposalItemDetail.SaleRefRecId
                            join projItemTrans
                                where projItemTrans.ProjTransId == projItemTransSale.ProjTransId
            {
                // Project Budget Checking
                if (useBudgeting)
                {

                    if (this.reverseProjBudgetTransaction(projItemTransSale.ProjTransId))
                    {
                        projBudgetTransactionReverse = ProjBudgetTransaction::construct(projItemTransSale);
                    }

                    projBudgetTransactionNormal = ProjBudgetTransaction::construct(projProposalItemDetail);

                    boolean canJournalBeInvoiced = true;

                    boolean isCredit = projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal;
					
                    if(!isCredit)
                    {
                        canJournalBeInvoiced = this.projAdjustBudget();
                    }

                    // When canJournalBeInvoiced is set to false we are throwing an execption here. but error info will be logged
                    // before this exception in projAdjustBudget, based on project status and budget validation we perform. 
                    if (!canJournalBeInvoiced)
                    {
                        throw Exception::Error;
                    }
                }

                ProjTransStatus projTransStatus = projItemTransSale.TransStatus;
                if (projTransStatus == ProjTransStatus::CreditnoteProposal && projLedgerStatus == ProjLedgerStatus::BalanceSheet)
                {
                    checkEnterCostValue = true;
                }

                if (transactionTxt != null && transactionTxt.txt())
                {
                    ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
                    ledgerVoucher.findLedgerVoucherObject().parmHasDefaultDescription(true);
                }

                this.postProjPostItemProposalSale(projProposalItem, projItemTrans, projProposalItemDetail, projItemTransSale, projPostInvoiceItem);

                container con = ProjItemTransCost::findForSalesRefRecId(projProposalItemDetail.SaleRefRecId);
                Query query = new Query(con);
                QueryRun queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    ProjItemTransCost projItemTransCost = queryRun.get(tableNum(ProjItemTransCost));

                    if ((projItemTransCost.LedgerStatusCost == ProjLedgerStatus::BalanceSheet) || (checkEnterCostValue))
                    {
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            this.setTaxTo(ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucher, ProjLedgerStatus::Operations, ProjOrigin::Invoice,false,checkEnterCostValue))
                                .postTrans();
                        }
                        else
                        {
                            // </GEERU>
                            ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucher, ProjLedgerStatus::Operations, ProjOrigin::Invoice,false,checkEnterCostValue).postTrans();
                            // <GEERU>
                        }
                        // </GEERU>
                    }
                }
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(
                    this.calculateDueDateFromDeliveryDate_ES(
                        projTransItemProposal.transDate(),
                        null,
                        '',
                        PaymDueDateLimit_ES::getCurrentValues(InventItemGroup::find(
                            InventItemGroupItem::findByItemIdLegalEntity(projTransItemProposal.itemId()).ItemGroupId).DueDateLimitGroupId_ES)));
            }

            if (!recordListProjProposalItem.next(projProposalItem))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postStockedItemInventFinancialForItemRequirements</Name>
				<Source><![CDATA[
    private void postStockedItemInventFinancialForItemRequirements(ProjProposalItem _projproposalItem)
    {
        ProjItemTrans projItemTrans = ProjItemTrans::find(_projproposalItem.ProjTransId);
        
        if (projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement 
            && ProjItemTrans::isStocked(projItemTrans.InventTransId))
        {
            //Inventory financial posting for adjusted project transactions needs to be handled separately
            if (projItemTrans.AdjRefTransId)
            {
                projItemTrans.selectForUpdate(true);
                this.postInventoryFinancialForAdjustedItemReqPackingSlipTrans(_projproposalItem, projItemTrans);
            }
            else if (projItemTrans.TransIdPackSlip != '') // TransIdPackSlip has a value only if item req packing slip is posted with ProjCancelItemReqPackingSlipFeature on
            {
                this.postInventoryFinancialForItemReqPackingSlip(_projproposalItem, projItemTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventoryFinancialForItemReqPackingSlip</Name>
				<Source><![CDATA[
    private void postInventoryFinancialForItemReqPackingSlip(ProjProposalItem _projproposalItem, ProjItemTrans _projItemTrans)
    {
        boolean financePosted = false;
        ProjItemTransSale projItemTransSale;
        InventTrans inventTransLoc;
        InventTransOrigin inventTransOriginLoc;
        CustPackingSlipTrans custPackingSlipTrans;
        
        ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(ProjInvoiceJournalPost));
        using (var activityContext = logger.projOpsManagementActivity().projItemReqInvProposalPostingContext())
        {
            SalesLine salesLine = SalesLine::findInventTransId(_projproposalItem.InventTransId, true);
            ProjFundingSourceRefId fundingSourceId = salesLine.ProjFundingSource ? salesLine.ProjFundingSource : SalesTable::find(salesLine.SalesId).FundingSource;
                
            if (fundingSourceId)
            {
                select firstonly TransStatus from projItemTransSale
                    where projItemTransSale.ProjTransId == _projproposalItem.ProjTransId
                        && projItemTransSale.FundingSource == fundingSourceId;
            }
            else
            {
                select firstonly TransStatus from projItemTransSale where projItemTransSale.ProjTransId == _projproposalItem.ProjTransId;
            }

            // ProjCancelItemReqPackingSlipFeature does not allow updating inventory after one invoice proposal is posted
            // Inventory is not updated when credit note is posted
            if (salesLine.SalesType == SalesType::ItemReq
                && projItemTransSale.TransStatus == ProjTransStatus::InvoiceProposal)
            {
                select firstonly custPackingSlipTrans
                    where custPackingSlipTrans.InventTransId == _projproposalItem.InventTransId
                join RecId from inventTransOriginLoc
                    where inventTransOriginLoc.InventTransId == custPackingSlipTrans.InventTransId
                join StatusIssue, StatusReceipt from inventTransLoc
                    where inventTransLoc.InventTransOrigin == inventTransOriginLoc.RecId
                        && inventTransLoc.PackingSlipId == custPackingSlipTrans.PackingSlipId
                        && inventTransLoc.ProjAdjustRefId == _projItemTrans.ProjAdjustRefId;

                logger.logInformation(strFmt("Inventory financial posting for item req packing slip transaction TransID: %1, PackingSlipId: %2, TransIdPackSlip: %3, TransStatus:%4, InventTransId: %5, StatusIssue: %6, StatusReceipt: %7", _projItemTrans.ProjTransId, custPackingSlipTrans.PackingSlipId, _projItemTrans.TransIdPackSlip, projItemTransSale.TransStatus, _projItemTrans.InventTransId, inventTransLoc.StatusIssue, inventTransLoc.StatusReceipt));

                if (custPackingSlipTrans.PackingSlipId
                    && (inventTransLoc.StatusIssue == StatusIssue::Deducted || inventTransLoc.StatusReceipt == StatusReceipt::Received))
                {
                    InventMovement inventMovement = InventMovement::construct(salesLine);
                    SalesParmLine salesParmLine = SalesParmLine::findRecId(custPackingSlipTrans.ParmLine);

                    InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newDeliveredSalesPackingSlipProject(inventMovement,
                                                                                                                        ledgerVoucher,
                                                                                                                        _projproposalItem.projProposalJour().ProjInvoiceId,
                                                                                                                        custPackingSlipTrans,
                                                                                                                        salesParmLine.physicalReduction(this.parmReduceOnHand()));
                    inventUpd_Financial.updateNow();
                    financePosted = true;
                    logger.logInformation(strFmt("Inventory financial posting successful for TransId: %1", _projItemTrans.ProjTransId));
                }
                else if (custPackingSlipTrans.PackingSlipId
                        && (inventTransLoc.StatusIssue == StatusIssue::Sold || inventTransLoc.StatusReceipt == StatusReceipt::Purchased))
                {
                    // Previous invoice proposal posting has already performed inventory financial posting
                    financePosted = true;
                    logger.logInformation(strFmt("Inventory financial already posted for TransId: %1", _projItemTrans.ProjTransId));
                }
                if (!financePosted)
                {
                    logger.logError(strFmt("Issue transaction not in expected state for TransIdPackSlip:%1, ProjTransId:%2, InventTransId:%3, PackingSlipId: %4, ProposalId:%5", _projItemTrans.TransIdPackSlip, _projproposalItem.ProjTransId, _projproposalItem.InventTransId, custPackingSlipTrans.PackingSlipId, _projproposalItem.ProposalId));
                
                    throw Error(strFmt("@Proj:InventoryFinancialPostingFailed", _projproposalItem.ProposalId, _projproposalItem.ItemId, _projproposalItem.InventTransId, custPackingSlipTrans.PackingSlipId));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventoryFinancialForAdjustedItemReqPackingSlipTrans</Name>
				<Source><![CDATA[
    private void postInventoryFinancialForAdjustedItemReqPackingSlipTrans(ProjProposalItem _projproposalItem, ProjItemTrans _projItemTrans)
    {
        boolean financePosted = false;
        ProjItemTransSale projItemTransSale;
        InventTrans inventTransLoc;
        InventTransOrigin inventTransOriginLoc;

        ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(ProjInvoiceJournalPost));
        using (var activityContext = logger.projOpsManagementActivity().projItemReqInvProposalPostingContext())
        {
            select firstonly TransStatus from projItemTransSale where projItemTransSale.ProjTransId == _projItemTrans.ProjTransId;

            if (projItemTransSale.TransStatus == ProjTransStatus::InvoiceProposal)
            {
                ProjItemTrans rootProjItemTrans;
                select firstonly TransIdPackSlip, ProjTransId from rootProjItemTrans
                    where rootProjItemTrans.AdjRefTransId == ''
                        && rootProjItemTrans.ProjTransIDRef == _projItemTrans.ProjTransIDRef
                        && rootProjItemTrans.TransIdPackSlip != ''; // TransIdPackSlip has a value only if item req packing slip is posted with ProjCancelItemReqPackingSlipFeature on

                // ProjCancelItemReqPackingSlipFeature does not allow updating inventory after one invoice proposal is posted
                // Inventory is not updated when credit note is posted
                if (rootProjItemTrans.TransIdPackSlip)
                {
                    select firstonly RecId from inventTransOriginLoc
                        where inventTransOriginLoc.InventTransId == _projItemTrans.InventTransId
                    join StatusIssue, StatusReceipt from inventTransLoc
                        where inventTransLoc.InventTransOrigin == inventTransOriginLoc.RecId
                            && inventTransLoc.ProjAdjustRefId == _projItemTrans.ProjAdjustRefId;

                    logger.logInformation(strFmt("Inventory financial posting for adjusted transaction TransID: %1, Root TransId: %2, Root TransIdPackSlip: %3, TransStatus:%4, InventTransId: %5, StatusIssue: %6, StatusReceipt: %7", _projItemTrans.ProjTransId, rootProjItemTrans.ProjTransId, rootProjItemTrans.TransIdPackSlip, projItemTransSale.TransStatus, _projItemTrans.InventTransId, inventTransLoc.StatusIssue, inventTransLoc.StatusReceipt));

                    if (inventTransLoc.StatusIssue == StatusIssue::Deducted || inventTransLoc.StatusReceipt == StatusReceipt::Received)
                    {
                        InventMov_ProjItemTrans invent_Mov = InventMov_ProjItemTrans::newFromProjItemTrans(_projItemTrans);
                        invent_Mov.parmInventRefTransId(_projItemTrans.InventTransId);
                      
                        this.updateItemRequirementForAdjustedProjItemTrans(_projItemTrans);

                        //Post inventory financial for inventory transaction with reference category project
                        InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newAdjustProjItemTrans(invent_Mov, ledgerVoucher, -_projItemTrans.TotalCostAmountCur);
                        inventUpd_Financial.updateNow();
                        financePosted = true;

                        logger.logInformation(strFmt("Inventory financial posting successful for TransId: %1", _projItemTrans.ProjTransId));
                    }
                    else if (inventTransLoc.StatusIssue == StatusIssue::Sold || inventTransLoc.StatusReceipt == StatusReceipt::Purchased)
                    {
                        financePosted = true;
                        logger.logInformation(strFmt("Inventory financial already posted for TransId: %1", _projItemTrans.ProjTransId));
                    }

                    if (!financePosted)
                    {
                        logger.logError(strFmt("Issue transaction not in expected state for Adjusted transaction ProjTransId:%1, InventTransId:%2, ProjAdjustRefId:%3, ProposalId:%4", _projItemTrans.ProjTransId, _projItemTrans.InventTransId, _projItemTrans.ProjAdjustRefId, _projproposalItem.ProposalId));
                
                        throw Error(strFmt("@Proj:InventoryFinancialPostingFailed", _projproposalItem.ProposalId, _projItemTrans.ItemId, _projItemTrans.InventTransId, ''));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemRequirementForAdjustedProjItemTrans</Name>
				<Source><![CDATA[
    private void updateItemRequirementForAdjustedProjItemTrans(ProjItemTrans _projItemTrans)
    {
        if (ProjUpdateItemRequirementStatusWhenAdjustedFlight::instance().isEnabled() && _projItemTrans.AdjRefTransId)
        {        
            // ProjTransIdRef is the ProjTransId from the original ProjItemTrans and links to the salesline.
            SalesLine salesOrderLine;
            select firstonly forupdate salesOrderLine 
                where salesOrderLine.ProjTransId == _projItemTrans.ProjTransIdRef;

            if (salesOrderLine)
            {
                // When a ProjItemTrans record is created for an Item Requirement, both Qty and SalesQty fields are assigned to the sales quantity.
                // When a ProjItemTrans record is adjusted, the SalesQty is currently not copied to the adjusted ProjItemTrans record, so we need to use Qty.  
                SalesQty salesQtyImpacted = _projItemTrans.Qty;          
                salesOrderLine.RemainSalesFinancial += -salesQtyImpacted;

                if (salesOrderLine.RemainSalesFinancial)
                {
                    InventQty inventQtyImpacted = salesOrderLine.unitConvertSales2Invent(salesQtyImpacted);
                    salesOrderLine.RemainInventFinancial += -inventQtyImpacted;
                }
                else
                {
                    salesOrderLine.RemainInventFinancial = 0;
                }

                ttsbegin;
                salesOrderLine.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjPostItemProposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts ledger journal entries for the item transaction.
    /// </summary>
    /// <param name = "_projProposalItem">
    /// A <c>ProjProposalItem</c> record.
    /// </param>
    /// <param name = "_projItemTrans">
    /// A <c>ProjItemTrans</c> record.
    /// </param>
    /// <param name = "_projProposalItemDetail">
    /// A <c>ProjProposalItemDetail</c> record.
    /// </param>
    /// <param name = "_projItemTransSale">
    /// A <c>ProjItemTransSale</c> record.
    /// </param>
    /// <param name = "_projPostInvoiceItem">
    /// A <c>ProjPost</c> class instance.
    /// </param>
    protected void postProjPostItemProposalSale(ProjProposalItem _projProposalItem,
        ProjItemTrans _projItemTrans,
        ProjProposalItemDetail _projProposalItemDetail,
        ProjItemTransSale _projItemTransSale,
        ProjPost _projPostInvoiceItem)
    {
        ProjTrans projTransItemProposalSale = ProjTrans::newProjProposalItemSale(_projProposalItem, _projProposalItemDetail, _projItemTransSale);

        ProjPost projPostItemProposalSale  = ProjPost::newEnterSalesAccrued_ProposalDetail(
                                                _projProposalItem,
                                                _projProposalItemDetail,
                                                _projItemTrans,
                                                _projItemTransSale,
                                                ledgerVoucher,
                                                projTransItemProposalSale.ledgerSalesPosted());
        projPostItemProposalSale.parmTaxParentReferenceRecId(_projPostInvoiceItem.newTrans().RecId);
        projPostItemProposalSale.parmTaxParentReferenceTableId(_projPostInvoiceItem.newTrans().TableId);
        // <GEERU>
        if (countryRegion_RU)
        {
            projPostItemProposalSale.parmTax_RU(this.tax());
        }
        // </GEERU>
        projPostItemProposalSale.postTrans();

        this.updateActualsOnPosting(_projItemTrans.ProjTransId, _projPostInvoiceItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAdvanceInvoice</Name>
				<Source><![CDATA[
    private void postAdvanceInvoice(ProjProposalOnAcc _proposalOnAcc)
    {
        ProjAdvancesSettle::linkWithProjInvoiceJour(_proposalOnAcc.projOnAccTrans().RecId, projInvoiceJour.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleAdvanceInvoice</Name>
				<Source><![CDATA[
    private void settleAdvanceInvoice(ProjProposalOnAcc _proposalOnAcc)
    {
        ProjInvoiceParmTable invoiceParmTable = this.parmParmTable() as ProjInvoiceParmTable;
        ProjAdvancesSettle::settleAgainstProjInvoiceJour(_proposalOnAcc.projOnAccTrans().RecId, projInvoiceJour.RecId, invoiceParmTable.VatDueDate_W);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOrSettleAdvanceInvoiceForOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Perform posting/settlement of an advance invoice for the provided proposal on account. If the ProjProposalJour
    /// record is created in a customer advance scenario, the advance invoice will be posted, otherwise, if in a settlement
    /// context, an advance invoice will be settled if it exists
    /// </summary>
    /// <param name = "_projProposalOnAcc">The record to process advance invoice for</param>
    private void postOrSettleAdvanceInvoiceForOnAcc(ProjProposalOnAcc _projProposalOnAcc)
    {
        if (countryRegion_PL)
        {
            if (advanceInvoicePosting)
            {
                this.postAdvanceInvoice(_projProposalOnAcc);
            }

            if (advanceInvoiceSettlement)
            {
                this.settleAdvanceInvoice(_projProposalOnAcc);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceOnAcc</Name>
				<Source><![CDATA[
    protected void createProjInvoiceOnAcc()
    {
        ProjProposalOnAcc           projProposalOnAcc;
        ProjOnAccTrans              projOnAccTrans;
        ProjProposalOnAccDetail     projProposalOnAccDetail;
        ProjOnAccTransSale          projOnAccTransSale;

        recordListProjProposalOnAcc.first(projProposalOnAcc);

        while (projProposalOnAcc)
        {
            this.postOrSettleAdvanceInvoiceForOnAcc(projProposalOnAcc);

            numOfInvOnAcc++;

            ProjPost projPostInvoiceOnAcc = ProjPost::newEnterOnAcc(projProposalOnAcc, ledgerVoucher);
            // <GEERU>
            if (countryRegion_RU)
            {
                projPostInvoiceOnAcc.parmTax_RU(this.tax());
            }
            // </GEERU>
            projPostInvoiceOnAcc.postTrans();

            while select projProposalOnAccDetail
                where projProposalOnAccDetail.ProposalRefRecId == projProposalOnAcc.RecId
                    join projOnAccTransSale
                        where projOnAccTransSale.RecId == projProposalOnAccDetail.SaleRefRecId
                            join projOnAccTrans
                                where projOnAccTrans.TransId == projOnAccTransSale.TransId
            {
                if (transactionTxt != null && transactionTxt.txt())
                {
                    ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
                    ledgerVoucher.findLedgerVoucherObject().parmHasDefaultDescription(true);
                }
                else
                {
                    ledgerVoucher.findLedgerVoucherObject().lastTransTxt(projOnAccTrans.Description);
                }

                this.postProjPostOnAccProposalSale(projProposalOnAcc, projOnAccTrans, projProposalOnAccDetail, projOnAccTransSale, projPostInvoiceOnAcc);
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projProposalOnAcc.transDate()));
            }

            if (!recordListProjProposalOnAcc.next(projProposalOnAcc))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOnAccDeductLedgerTransDate</Name>
				<Source><![CDATA[
    internal TransDate parmOnAccDeductLedgerTransDate(TransDate _ledgerTransDate = ledgerTransDate)
    {
        ledgerTransDate = _ledgerTransDate;
        return _ledgerTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjPostOnAccProposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts ledger journal entries for the on-account transaction.
    /// </summary>
    /// <param name = "_projProposalOnAcc">
    /// A <c>ProjProposalOnAcc</c> record.
    /// </param>
    /// <param name = "_projOnAccTrans">
    /// A <c>ProjOnAccTrans</c> record.
    /// </param>
    /// <param name = "_projProposalOnAccDetail">
    /// A <c>ProjProposalOnAccDetail</c> record.
    /// </param>
    /// <param name = "_projOnAccTransSale">
    /// A <c>ProjOnAccTransSale</c> record.
    /// </param>
    /// <param name = "_projPostInvoiceOnAcc">
    /// A <c>ProjPost</c> class instance.
    /// </param>
    protected void postProjPostOnAccProposalSale(ProjProposalOnAcc _projProposalOnAcc,
        ProjOnAccTrans _projOnAccTrans,
        ProjProposalOnAccDetail _projProposalOnAccDetail,
        ProjOnAccTransSale _projOnAccTransSale,
        ProjPost _projPostInvoiceOnAcc)
    {
        ProjTransOnAccProposalSale projTransOnAccProposalSale = ProjTrans::newProjProposalOnAccSale(_projProposalOnAcc, _projProposalOnAccDetail, _projOnAccTransSale);

        ProjPost projPostOnAccProposalSale = ProjPost::newEnterOnAccSale(
                                                _projProposalOnAcc,
                                                _projProposalOnAccDetail,
                                                _projOnAccTrans,
                                                _projOnAccTransSale,
                                                ledgerVoucher);

        if (_projOnAccTrans.TransactionOrigin == ProjOrigin::Deduction &&
            _projOnAccTrans.PSAIsOnAccount == NoYes::Yes &&
            _projPostInvoiceOnAcc.parmProjTrans().transType() == ProjTransType::OnAccount)
        {
            totalOnAccDeductionRecords++;

            ProjOnAccTransSale projOnAccTransSaleDeduct;
            select firstonly RecId, LedgerTransdate from projOnAccTransSaleDeduct
                where projOnAccTransSaleDeduct.TransId == _projPostInvoiceOnAcc.parmProjTrans().transId();

            this.parmOnAccDeductLedgerTransDate(projOnAccTransSaleDeduct.LedgerTransdate);
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            projPostOnAccProposalSale.parmTax_RU(this.tax());
        }
        // </GEERU>
        projPostOnAccProposalSale.parmTaxParentReferenceRecId(_projPostInvoiceOnAcc.newTrans().RecId);
        projPostOnAccProposalSale.parmTaxParentReferenceTableId(_projPostInvoiceOnAcc.newTrans().TableId);
        projPostOnAccProposalSale.postTrans();

        this.updateActualsOnPosting(_projOnAccTrans.TransId, _projPostInvoiceOnAcc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceRevenue</Name>
				<Source><![CDATA[
    protected void createProjInvoiceRevenue()
    {
        ProjProposalRevenue projProposalRevenue;
        boolean             reversalAccrual = false;

        recordListProjProposalRevenue.first(projProposalRevenue);

        while (projProposalRevenue)
        {
            numOfInvRevenue++;

            ProjTransRevenueProposal projTransRevenueProposal = ProjTrans::newProjProposalRevenue(projProposalRevenue);

            ProjPost projPostInvoiceRevenue = ProjPost::newEnterSalesAccrued_Proposal(projProposalRevenue, ledgerVoucher);

            this.validateNoTax(projTransRevenueProposal);
            // <GEERU>
            if (countryRegion_RU)
            {
                projPostInvoiceRevenue.parmTax_RU(this.tax());
            }
            // </GEERU>
            projPostInvoiceRevenue.postTrans();

            ProjRevenueTrans                projRevenueTrans;
            ProjProposalRevenueDetail       projProposalRevenueDetail;
            ProjRevenueTransSale            projRevenueTransSale;

            while select projProposalRevenueDetail
                where projProposalRevenueDetail.ProposalRefRecId == projProposalRevenue.RecId
            {
                select firstonly projRevenueTransSale
                        where projRevenueTransSale.RecId == projProposalRevenueDetail.SaleRefRecId
                            join projRevenueTrans
                                where projRevenueTrans.TransId == projRevenueTransSale.TransId;

                if (projRevenueTransSale.RecId && projRevenueTrans.RecId)
                {
                    ProjTransStatus projTransStatus = projRevenueTransSale.TransStatus;

                    if(transactionTxt != null && transactionTxt.txt())
                    {
                        ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
                        ledgerVoucher.findLedgerVoucherObject().parmHasDefaultDescription(true);
                    }

                    this.postProjPostRevenueProposalSale(projProposalRevenue, projRevenueTrans, projProposalRevenueDetail, projRevenueTransSale, projPostInvoiceRevenue, projTransRevenueProposal);

                    if (projTransStatus == ProjTransStatus::CreditnoteProposal && projProposalRevenue.projRevenueTrans().smaSubscriptionId)
                    {
                        this.reverseSubscriptionAccruals(projProposalRevenue, projTransRevenueProposal);
                        reversalAccrual = true;
                    }
                
                    if (reversalAccrual)
                    {
                        this.deleteSubscriptionAccruals(projProposalRevenue.TransId);
                        reversalAccrual = false;
                    }
                }
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projTransRevenueProposal.transDate()));
            }

            if (!recordListProjProposalRevenue.next(projProposalRevenue))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSubscriptionAccruals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Delete the SMAAccruePeriodLines when reversed using the _TransId.
    /// </summary>
    /// <param name="_TransId">
    ///    The Trans Id.
    /// </param>
    private void deleteSubscriptionAccruals(ProjRevenueTransId _TransId)
    {
        SMAAccruePeriodLine     smaAccruePeriodLine;
        
        delete_from smaAccruePeriodLine
            where smaAccruePeriodLine.ProjRevenueTransId == _TransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjPostRevenueProposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts ledger journal entries for the revenue transaction.
    /// </summary>
    /// <param name = "_projProposalRevenue">
    /// A <c>ProjProposalRevenue</c> record.
    /// </param>
    /// <param name = "_projRevenueTrans">
    /// A <c>ProjRevenueTrans</c> record.
    /// </param>
    /// <param name = "_projProposalRevenueDetail">
    /// A <c>ProjProposalRevenueDetail</c> record.
    /// </param>
    /// <param name = "_projRevenueTransSale">
    /// A <c>ProjRevenueTransSale</c> record.
    /// </param>
    /// <param name = "_projPostInvoiceRevenue">
    /// A <c>ProjPost</c> class instance.
    /// </param>
    /// <param name = "_projTransRevenueProposal">
    /// A <c>ProjTransRevenueProposal</c> class instance.
    /// </param>
    protected void postProjPostRevenueProposalSale(ProjProposalRevenue _projProposalRevenue,
        ProjRevenueTrans _projRevenueTrans,
        ProjProposalRevenueDetail _projProposalRevenueDetail,
        ProjRevenueTransSale _projRevenueTransSale,
        ProjPost _projPostInvoiceRevenue,
        ProjTransRevenueProposal _projTransRevenueProposal)
    {
        ProjTransRevenueProposalSale projTransRevenueProposalSale = ProjTrans::newProjProposalRevenueSale(_projProposalRevenue, _projProposalRevenueDetail, _projRevenueTransSale);

        ProjPost projPostRevenueProposalSale = this.createProjInvoiceRevenue_GetProjPostRevenueProposalSale(
                                                    _projPostInvoiceRevenue,
                                                    _projProposalRevenue,
                                                    _projRevenueTrans,
                                                    _projProposalRevenueDetail,
                                                    _projRevenueTransSale,
                                                    projTransRevenueProposalSale,
                                                    _projTransRevenueProposal);

        // <GEERU>
        if (countryRegion_RU)
        {
            projPostRevenueProposalSale.parmTax_RU(this.tax());
        }
        // </GEERU>

        projPostRevenueProposalSale.postTrans();

        this.updateActualsOnPosting(_projRevenueTrans.TransId, _projPostInvoiceRevenue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts tax and tax document for project invoice proposal.
    /// </summary>
    protected void postTaxGTE()
    {
        // <GIN>
        #ISOCountryRegionCodes
        // <GIN>

        ITaxableDocument                   taxableDocumentOnAcc;
        TaxEngineProjOnAcctTransHeader     onAccHeader;
        ITaxableDocument                   taxableDocumentRevenue;
        TaxEngineProjRevenueTransHeader    revenueHeader;
        ITaxableDocument                   taxableDocumentCost;
        TaxEngineProjCostTransHeader       costHeader;
        ITaxableDocument                   taxableDocumentItem;
        TaxEngineProjItemTransHeader       itemHeader;
        ITaxableDocument                   taxableDocumentEmpl;
        TaxEngineProjEmplTransHeader       emplHeader;
        ITaxableDocument                   taxableDocumentItemSO;
        TaxEngineProjItemSOTransHeader     itemSOHeader;
        TaxEngineProjRevenueSubTransHeader revenueSubHeader;
        ITaxableDocument                   taxableDocumentRevenueSub;

        onAccHeader          = TaxEngineProjOnAcctTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentOnAcc = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(onAccHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentOnAcc);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentOnAcc.getTransactionTableId(), taxableDocumentOnAcc.getTransactionRecordId()], ledgerVoucher);
        }

        revenueHeader          = TaxEngineProjRevenueTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentRevenue = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(revenueHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentRevenue);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentRevenue.getTransactionTableId(), taxableDocumentRevenue.getTransactionRecordId()], ledgerVoucher);
        }

        costHeader          = TaxEngineProjCostTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentCost = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(costHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentCost);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentCost.getTransactionTableId(), taxableDocumentCost.getTransactionRecordId()], ledgerVoucher);
        }

        itemHeader          = TaxEngineProjItemTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentItem = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(itemHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentItem);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentItem.getTransactionTableId(), taxableDocumentItem.getTransactionRecordId()], ledgerVoucher);
        }

        itemSOHeader          = TaxEngineProjItemSOTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentItemSO = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(itemSOHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentItemSO);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentItemSO.getTransactionTableId(), taxableDocumentItemSO.getTransactionRecordId()], ledgerVoucher);
        }

        emplHeader          = TaxEngineProjEmplTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentEmpl = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(emplHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentEmpl);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentEmpl.getTransactionTableId(), taxableDocumentEmpl.getTransactionRecordId()], ledgerVoucher);
        }

        revenueSubHeader            = TaxEngineProjRevenueSubTransHeader::findOrCreateByProjProposalJour(projProposalJour);
        taxableDocumentRevenueSub   = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(revenueSubHeader));
        TaxBusinessService::postTax(ledgerVoucher, taxableDocumentRevenueSub);
        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocumentRevenueSub.getTransactionTableId(), taxableDocumentRevenueSub.getTransactionRecordId()], ledgerVoucher);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (TaxSolutionScopeParameters::find().TaxDocumentPostingMode == TaxDocumentPostingMode::Synchronous)
            {
                TaxEnginePostingProcessor::updateTaxDocExtensionForProj([projProposalJour.RecId]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceRevenue_GetProjPostRevenueProposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>ProjPost</c> instance for the <c>createProjInvoiceRevenue</c> method.
    /// </summary>
    /// <param name = "_projPostInvoiceRevenue">
    /// A <c>ProjPost</c> class instance.
    /// </param>
    /// <param name = "_projProposalRevenue">
    /// A <c>ProjProposalRevenue</c> record.
    /// </param>
    /// <param name = "_projRevenueTrans">
    /// A <c>ProjRevenueTrans</c> record.
    /// </param>
    /// <param name = "_projProposalRevenueDetail">
    /// A <c>ProjProposalRevenueDetail</c> record.
    /// </param>
    /// <param name = "_projRevenueTransSale">
    /// A <c>ProjRevenueTransSale</c> record.
    /// </param>
    /// <param name = "_projTransRevenueProposalSale">
    /// A <c>ProjTransRevenueProposalSale</c> class instance.
    /// </param>
    /// <param name = "_projTransRevenueProposal">
    /// A <c>ProjTransRevenueProposal</c> class instance.
    /// </param>
    /// <returns>
    /// A <c>ProjPost</c> class instance.
    /// </returns>
    protected ProjPost createProjInvoiceRevenue_GetProjPostRevenueProposalSale(
        ProjPost _projPostInvoiceRevenue,
        ProjProposalRevenue _projProposalRevenue,
        ProjRevenueTrans _projRevenueTrans,
        ProjProposalRevenueDetail _projProposalRevenueDetail,
        ProjRevenueTransSale _projRevenueTransSale,
        ProjTransRevenueProposalSale _projTransRevenueProposalSale,
        ProjTransRevenueProposal _projTransRevenueProposal)
    {
        ProjPost projPostRevenueProposalSale = ProjPost::newEnterSalesAccrued_ProposalDetail(
                                                            _projProposalRevenue,
                                                            _projProposalRevenueDetail,
                                                            _projRevenueTrans,
                                                            _projRevenueTransSale,
                                                            ledgerVoucher,
                                                            _projTransRevenueProposalSale.ledgerSalesPosted());

        projPostRevenueProposalSale.parmTaxParentReferenceRecId(_projPostInvoiceRevenue.newTrans().RecId);
        projPostRevenueProposalSale.parmTaxParentReferenceTableId(_projPostInvoiceRevenue.newTrans().TableId);

        return projPostRevenueProposalSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a project invoice sales order line.
    /// </summary>
    protected void createProjInvoiceSalesLine()
    {
        salesFormLetter = SalesFormLetter::construct(DocumentStatus::ProjectInvoice);

        salesFormLetter.setNumAndVoucher(projInvoiceJour.ProjInvoiceId, voucher);
        salesFormLetter.setLedgerVoucher(ledgerVoucher);
        salesFormLetter.parmDeleteFullyInvoiced(true);
        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            salesFormLetter.parmProjInvoiceParmTable(projInvoiceParmTable);
        }
        // </GEEU>

        if (formletter is ProjFormLetter_Invoice)
        {
            ProjFormLetter_Invoice projFormLetter = formletter as ProjFormLetter_Invoice;
            salesFormLetter.parmCheckCreditMax(projFormLetter.parmCheckCreditMax());
        }

        this.salesFromFormletterParmDelegate(formletter, salesFormLetter);

        salesFormLetter.update(projProposalJour, projInvoiceJour.InvoiceDate, SalesUpdate::DeliverNow);

        ProjItemTransSale projItemTransSale;
        ProjProposalItem projProposalItemLoc;

        update_recordset projItemTransSale
            setting TransStatus = ProjTransStatus::Posted
        exists join projProposalItemLoc
            where projItemTransSale.ProjTransId == projProposalItemLoc.ProjTransId &&
                projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal &&
                projProposalItemLoc.ProposalId == projProposalJour.ProposalId &&
                projProposalItemLoc.ItemType == ProjItemType::SalesOrder;

        numOfInvSalesLine += projItemTransSale.RowCount();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            ProjProposalItem projProposalItem;

            while select SalesId from projProposalItem
                where projProposalItem.ProposalId == projProposalJour.ProposalId &&
                    projProposalItem.ItemType   == ProjItemType::SalesOrder
            {
                numOfInvSalesLine++;

                SalesTable salesTable = SalesTable::find(projProposalItem.SalesId);
                paymTerm paymTerm = PaymTerm::find(salesTable.Payment);
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(
                                            salesTable.ReceiptDateConfirmed,
                                            paymTerm,
                                            salesTable.paymDayId(),
                                            PaymDueDateLimit_ES::getItemDueDateLimit(salesTable, salesFormLetter.parmId())));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    protected NoYes creditNote()
    {
        creditNote = projProposalTotals.isCreditNote();

        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInvoicePostEvent</Name>
				<Source><![CDATA[
    private void runInvoicePostEvent()
    {
        InvoicePostedBusinessEvent::newFromInvoiceJour(InvoicePostedBusinessEventEntityType::ProjectInvoiceEntity, projInvoiceJour).send();
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLedgerTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default ledger transaction text.
    /// </summary>
    /// <returns>
    /// A transaction text.
    /// </returns>
    protected LedgerTransTxt defaultLedgerTransactionText()
    {
        return (creditNote  ? LedgerTransTxt::ProjectCreditNoteLedger : LedgerTransTxt::ProjectInvoiceLedger);
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    protected DocumentStatus documentStatus()
    {
        return DocumentStatus::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes the posting process.
    /// </summary>
    protected void endLedgerVoucher()
    {
        // <GEERU>
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher ? ledgerVoucher.findLedgerVoucherObject() : null;
        LedgerBondClient_RU ledgerBondClient    = ledgerVoucherObject ? ledgerVoucherObject.ledgerBondClient_RU() : null;

        if (ledgerBondClient && ledgerBondClient.findVRefByPostingType(LedgerPostingType::CustBalance))
        {
            ledgerBondClient.bondVRef2Log(ledgerBondClient.findVRefByPostingType(LedgerPostingType::CustBalance));
        }
        // </GEERU>

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPostingSettlingParmeters</Name>
				<Source><![CDATA[
    private void setPostingSettlingParmeters()
    {
        ProjAdvanceInvoicePosting postingTable;

        select firstonly AdvanceInvoicePosting, AdvanceInvoiceSettlement from postingTable
            where postingTable.ProjProposalJour == this.parmProjProposalJour().RecId;

        advanceInvoicePosting = postingTable.AdvanceInvoicePosting == NoYes::Yes;
        advanceInvoiceSettlement = postingTable.AdvanceInvoiceSettlement == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLines</Name>
				<Source><![CDATA[
    protected void endLines()
    {
        numOfInvEmpl = 0;
        numOfInvCost = 0;
        numOfInvItem = 0;
        numOfInvRevenue = 0;
        numOfInvOnAcc = 0;
        numOfInvSalesLine = 0;

        if (countryRegion_PL)
        {
            if (!this.parmProjProposalJour())
            {
                throw error("@ApplicationSuite_Localization:ProjProposalJourRequired");
            }

            this.setPostingSettlingParmeters();
        }

        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjInvoiceJournalPost));

        using (SysInstrumentationActivityContext activityContext = logger.projOpsFinActivity().activityContext(ProjOpsFinancialsInstrumentationActivites::InvPosting))
        {
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::IsBatch, any2Str(postingInBatch));
            activityContext.addCustomProperty(ProjOpsFinancialsInstrumentationActivites::InvPostingProforma, any2Str(proforma));
            
            if (proforma)
            {
                this.insertProforma();
            }
            else
            {
                recordInsertListCustInvoicePackingSlipMatch = new RecordInsertList(tableNum(CustInvoicePackingSlipQuantityMatch));

                this.initProposalUpdate();
                this.createProjInvoiceEmpl();
                this.createProjInvoiceCost();
                this.createProjInvoiceRevenue();
                this.createProjInvoiceItem();
                this.createProjInvoiceOnAcc();
                this.createProjInvoiceSalesLine();

                recordInsertListCustInvoicePackingSlipMatch.insertDatabase();
            }

            // <GTE>
            if (TaxIntegrationUtils::isTransitDocumentEnabled())
            {
                this.transitProjectTrans();
            }
            // </GTE>

            activityContext.addCustomProperty(
                ProjOpsFinancialsInstrumentationActivites::InvPostingNumberOfHourTransactions, 
                int2Str(numOfInvEmpl));
            activityContext.addCustomProperty(
                ProjOpsFinancialsInstrumentationActivites::InvPostingNumberOfCostTransactions, 
                int2Str(numOfInvCost));
            activityContext.addCustomProperty(
                ProjOpsFinancialsInstrumentationActivites::InvPostingNumberOfItemTransactions, 
                int2Str(numOfInvItem));
            activityContext.addCustomProperty(
                ProjOpsFinancialsInstrumentationActivites::InvPostingNumberOfRevenueTransactions, 
                int2Str(numOfInvRevenue));
            activityContext.addCustomProperty(
                ProjOpsFinancialsInstrumentationActivites::InvPostingNumberOfOnAccTransactions, 
                int2Str(numOfInvOnAcc));
            activityContext.addCustomProperty(
                ProjOpsFinancialsInstrumentationActivites::InvPostingNumberOfSalesOrderTransactions, 
                int2Str(numOfInvSalesLine));

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the posting.
    /// </summary>
    protected void endPost()
    {
        if (projInvoiceJour.CashDiscCode && TaxParameters::canApplyCashDiscOnInvoice_ES())
        {
            this.createCashDisc();
        }

        this.createPaymentSched();

        this.createPayment();

        //<GMX>
        if (!this.isProforma() && (EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled()))
        {
            this.insertEInvoice_MX();
        }
        //</GMX>

        // <GCN>
        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            this.createExportDocument_CN();
        }
        // </GCN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFI]) && !projInvoiceJour.PaymId)
        {
            ProjInvoiceJour projInvoiceJourLoc = ProjInvoiceJour::findRecId(projInvoiceJour.RecId, true);
       
            projInvoiceJourLoc.PaymId =  projInvoiceJourLoc.invoiceReferenceNumberFI();
            projInvoiceJourLoc.update();
        }

        if (countryRegion_PL)
        {
            ProjAdvanceInvoicePosting::deleteForProjProposalJour(this.parmProjProposalJour().RecId);
        }

        this.runInvoicePostEvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the update of the selected records.
    /// </summary>
    /// <remarks>
    /// The <c>endUpdate</c> method in the derived classes contains the code to end the posting of the
    /// selected records that are posted by the derived <c>FormLetter</c> class. For example the
    /// <c>endUpdate</c> method in the <c>SalesFormLetter</c> class ends the update for the selected sales
    /// orders. The <c>endUpdate</c> method is added to the <c>FormLetter</c> class so that you can run the
    /// <c>endUpdate</c> method when you post in batch. The <c>endUpdate</c> method is called from the
    /// <c>run</c> method in the abstract classes that are derived from the <c>FormLetter</c> class, and
    /// from the <c>run</c> method in the <c>FormLetterEndMultiThread</c> class.
    /// </remarks>
    void endUpdate()
    {
        this.accrueJournal();

        super();

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.postEndPostBR();
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSet</Name>
				<Source><![CDATA[
    private void exchRateSet()
    {
        if (ProjInvoiceCurrency::exist(projInvoiceJour.ProjInvoiceProjId,projInvoiceJour.CurrencyId))
        {
            fixedExchRate = true;
        }
        else
        {
            fixedExchRate = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjectInvoicePaymTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PaymTerm</c> record for the project.
    /// </summary>
    /// <returns>
    /// The <c>PaymTerm</c> record; otherwise an empty record.
    /// </returns>
    protected PaymTerm findProjectInvoicePaymTerm()
    {
        if (!projectInvoicePaymTerm)
        {
            projectInvoicePaymTerm = PaymTerm::find(projInvoiceJour.Payment);
        }

        return projectInvoicePaymTerm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterType</Name>
				<Source><![CDATA[
    protected FormletterType formletterType()
    {
        return FormletterType::Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a voucher number.
    /// </summary>
    /// <returns>
    /// A voucher number.
    /// </returns>
    protected Num getVoucher()
    {
        return projInvoiceJour.LedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class.
    /// </summary>
    public void init()
    {
        projProposalJour = ProjProposalJour::find(projInvoiceJour.ProposalId,true);
        projInvoiceTable = ProjInvoiceTable::find(projInvoiceJour.ProjInvoiceProjId);

        if (this.parmTotals())
        {
            projProposalTotals = this.parmTotals() as ProjProposalTotals;
        }
        else
        {
            projProposalTotals = new ProjProposalTotals(projProposalJour, projInvoiceJour.ParmId);
            projProposalTotals.calc();
        }

        this.createOnAccountCreditNote();

        this.tax(projProposalTotals.tax());

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            this.taxWithholdCalculation_IN(projProposalTotals.taxWithholdCalculation_IN());
        }
        // </GIN>

        creditNote = this.creditNote();

        super();

        transactionTxt = this.initTransactionTxtProjProposalJour(creditNote  ? LedgerTransTxt::ProjectCreditNoteLedger : LedgerTransTxt::ProjectInvoiceLedger);

        recordListProjProposalCost      = projProposalTotals.recordListProjProposalcost();
        recordListProjProposalEmpl      = projProposalTotals.recordListProjProposalEmpl();
        recordListProjProposalRevenue   = projProposalTotals.recordListProjProposalRevenue();
        recordListProjProposalItem      = projProposalTotals.recordListProjProposalItem_Project();
        recordListProjProposalOnAcc     = projProposalTotals.recordListProjProposalOnAcc();

        recordInsertListSpecTrans = new RecordInsertList(tableNum(SpecTrans));

        taxParameters = TaxParameters::find();

        // <GMY>
        if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
        {
            this.checkBeforePost_MY();
        }
        // </GMY>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>Markup</c> object.
    /// </summary>
    protected void initMarkup()
    {
        markup = new Markup(projInvoiceJour.CurrencyId);
        markup.parmExchRate(this.markUpfixedExchRate(), this.markUpFixedExchRateSecondary(), this.markUpFixedEuroTriangulation());
        // <GEERU>
        markup.transDate(projInvoiceParmTable.InvoiceDate);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProposalUpdate</Name>
				<Source><![CDATA[
    protected void initProposalUpdate()
    {
        projProposalJour.InvoiceDate        = projInvoiceJour.InvoiceDate;
        projProposalJour.ProjInvoiceId      = projInvoiceJour.ProjInvoiceId;
        projProposalJour.ExchRate           = projInvoiceJour.ExchRate;
        projProposalJour.ExchrateSecondary  = projInvoiceJour.ExchrateSecondary;
        projProposalJour.Triangulation      = projInvoiceJour.Triangulation;

        projProposalJour.update();

        // <GEEU>
        if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByBusinessProcess(TaxIntegrationBusinessProcess::Project))
        {
            TaxSpecificExchangeRateHelper::transferTaxSpecificExchangeRateType(
                projProposalJour.TableId,
                projProposalJour.RecId,
                projInvoiceJour.TableId,
                projInvoiceJour.RecId);
        }
        else if (TaxParameters::isBankExchRateEnabled_W()
            && projInvoiceJour.CurrencyId != Ledger::accountingCurrency())
        {
            SalesTaxExchangeRateHelper::changeSourceRecord(projProposalJour.TableId, projProposalJour.RecId, projInvoiceJour.TableId, projInvoiceJour.RecId);
        }
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TransactionTxt</c> object.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    /// A ledger transaction text.
    /// </param>
    /// <returns>
    /// An instance of the <c>TransactionTxt</c> object.
    /// </returns>
    protected TransactionTxt initTransactionTxt(LedgerTransTxt _ledgerTransTxt)
    {
        transactionTxt = TransactionTxt::construct();

        transactionTxt.setType          (_ledgerTransTxt);
        transactionTxt.setLanguage      (projInvoiceJour.LanguageId);
        transactionTxt.setVoucher       (voucher);
        transactionTxt.setFormLetter    (projInvoiceJour.ProjInvoiceId);
        transactionTxt.setKey1          (projInvoiceJour.ProjInvoiceProjId);
        transactionTxt.setKey2          (projInvoiceJour.InvoiceAccount);
        transactionTxt.setKey3          (CustTable::groupId(projInvoiceJour.InvoiceAccount));
        
        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxtProjProposalJour</Name>
				<Source><![CDATA[
    protected TransactionTxt initTransactionTxtProjProposalJour(LedgerTransTxt _ledgerTransTxt)
    {
        transactionTxt = TransactionTxt::construct();
        
        transactionTxt.setType          (_ledgerTransTxt);
        transactionTxt.setLanguage      (projProposalJour.LanguageId);
        transactionTxt.setVoucher       (projProposalJour.LedgerVoucher ? projProposalJour.LedgerVoucher : projInvoiceJour.LedgerVoucher);
        transactionTxt.setFormLetter    (projProposalJour.ProjInvoiceId);
        transactionTxt.setCustVendName  (projProposalJour.DeliveryName ? projProposalJour.DeliveryName : projInvoiceJour.DeliveryName);
        transactionTxt.setKey1          (projProposalJour.ProjInvoiceProjId);
        transactionTxt.setKey2          (projProposalJour.InvoiceAccount);
        transactionTxt.setKey3          (CustTable::groupId(projProposalJour.InvoiceAccount));

        if (TransactionTextContext::isTypeSupported(_ledgerTransTxt))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_ledgerTransTxt);
            transactionTextContext.setTableBuffer(ProjInvoiceJour);
            transactionTextContext.setTableBuffer(projProposalJour);
            transactionTextContext.setTableBuffer(projInvoiceTable);
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustomerRetention</Name>
				<Source><![CDATA[
    public void insertCustomerRetention()
    {
        PSACustomerInvoiceRetain    psaCustomerInvoiceRetain;
        PSAProjProposalProj         psaProjProposalProj;

        while select psaProjProposalProj
            where psaProjProposalProj.ProjProposalId == projInvoiceJour.ProposalId
        {
            psaCustomerInvoiceRetain.clear();
            psaCustomerInvoiceRetain.InvoicedNow        = psaProjProposalProj.InvoicedNow + psaProjProposalProj.calcTotalIndirectComponentInvoice(psaProjProposalProj);
            psaCustomerInvoiceRetain.ProjId             = psaProjProposalProj.ProjId;
            psaCustomerInvoiceRetain.ProjProposalId     = psaProjProposalProj.ProjProposalId;
            psaCustomerInvoiceRetain.ContractLineNum    = psaProjProposalProj.ContractLineNum;
            psaCustomerInvoiceRetain.FundingSource      = psaProjProposalProj.FundingSource;
            psaCustomerInvoiceRetain.RetainedAmount     = psaProjProposalProj.RetainedNow;
            psaCustomerInvoiceRetain.ReleasedAmount     = psaProjProposalProj.ReleasedAmount;
            psaCustomerInvoiceRetain.ProjInvoiceId      = projInvoiceJour.ProjInvoiceId;
            psaCustomerInvoiceRetain.ProjInvoiceDate    = projInvoiceJour.InvoiceDate;
            psaCustomerInvoiceRetain.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEInvoice_MX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the electronic invoice information
    /// </summary>
    protected void insertEInvoice_MX()
    {
        EInvoicePost_MX   eInvoicePost;

        eInvoicePost = EInvoicePost_MX::construct(projInvoiceJour, numberSeq.parmNumberSequenceId(), projInvoiceParmTable);

        eInvoicePost.createElectronicInvoiceJour();

        if (this.parmSendByMail_MX())
        {
            eInvoicePost.createXMLFileAndPopulateSysMailTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProforma</Name>
				<Source><![CDATA[
    protected void insertProforma()
    {
        ProjInvoiceRevenue          projInvoiceRevenue;
        ProjInvoiceRevenueDetail    projInvoiceRevenueDetail;
        ProjProposalRevenue         projProposalRevenue;
        ProjProposalRevenueDetail   projProposalRevenueDetail;
        ProjRevenueTransSale        projRevenueTransSale;

        ProjInvoiceOnAcc            projInvoiceOnAcc;
        ProjInvoiceOnAccDetail      projInvoiceOnAccDetail;
        ProjProposalOnAcc           projProposalOnAcc;
        ProjProposalOnAccDetail     projProposalOnAccDetail;
        ProjOnAccTransSale          projOnAccTransSale;

        ProjInvoiceEmpl             projInvoiceEmpl;
        ProjInvoiceEmplDetail       projInvoiceEmplDetail;
        ProjProposalEmpl            projProposalEmpl;
        ProjProposalEmplDetail      projProposalEmplDetail;
        ProjEmplTransSale           projEmplTransSale;

        ProjInvoiceCost             projInvoiceCost;
        ProjInvoiceCostDetail       projInvoiceCostDetail;
        ProjProposalCost            projProposalCost;
        ProjProposalCostDetail      projProposalCostDetail;
        ProjCostTransSale           projCostTransSale;

        ProjInvoiceItem             projInvoiceItem;
        ProjInvoiceItemDetail       projInvoiceItemDetail;
        ProjProposalItem            projProposalItem;
        ProjProposalItemDetail      projProposalItemDetail;

        SalesTable                  salesTable;

        // <GEECZ>
        boolean                     countryRegion_CZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>

        projInvoiceTable = projProposalJour.projInvoiceTable();

        // Description: Number and voucher must be initialized to be assigned to fields in a record in ProjInvoiceJour
        //              Else : record in ProjInvoiceJour wouldn't be unique because number and voucher would be blank

        // numer should not be assigned if invoice is not posted
        //  if (!this.proforma())

        if (!this.isProforma())
        {
            numberSeq = this.allocateVoucher();
            voucher   =  this.getVoucher();
        }

        this.exchRateSet();

        while select projProposalEmpl where projProposalEmpl.ProposalId == projProposalJour.ProposalId
        {
            numOfInvEmpl++;

            projInvoiceEmpl                 = ProjInvoiceEmpl::initInvoiceFromProposale(projProposalEmpl);
            projInvoiceEmpl.ProjInvoiceId   = projInvoiceJour.ProjInvoiceId;
            projInvoiceEmpl.InvoiceDate     = projInvoiceJour.InvoiceDate;
            projInvoiceEmpl.insert();

            Docu::copy(projProposalEmpl, projInvoiceEmpl);

            while select projProposalEmplDetail
                where projProposalEmplDetail.ProposalRefRecId == projProposalEmpl.RecId
                    join projEmplTransSale
                        where projEmplTransSale.RecId == projProposalEmplDetail.SaleRefRecId
            {
                projInvoiceEmplDetail.clear();
                projInvoiceEmplDetail = ProjInvoiceEmplDetail::initInvoiceFromProposale(projProposalEmpl, projProposalEmplDetail, projEmplTransSale);
                projInvoiceEmplDetail.InvoiceRefRecId = projInvoiceEmpl.RecId;
                if (projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                        && isCreditInvoicingPrintingFlightEnabled)
                {
                    projInvoiceEmplDetail.RefRecId = this.getOriginalInvoiceRefRecId_Empl(projProposalEmplDetail.RecId);
                }
                projInvoiceEmplDetail.insert();

                // <GEECZ>
                // This section has a side affect of modifying records when doing a 
                // print preview. The flight addresses this issue and the problem
                // that this code is limited to a single localization.
                //
                // It also has a peformance issue of updating the record which was just created.
                if (countryRegion_CZ
                    &&  projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                    && !isCreditInvoicingPrintingFlightEnabled)
                {
                    this.projInvoiceEmplUpdate_CZ(projEmplTransSale.RecId);
                }
                // </GEECZ>

            }


            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projInvoiceEmpl.TransDate));
            }
        }

        while select projProposalCost where projProposalCost.ProposalId == projProposalJour.ProposalId
        {
            numOfInvCost++;

            projInvoiceCost                 = ProjInvoiceCost::initInvoiceFromProposal(projProposalCost);
            projInvoiceCost.ProjInvoiceId   = projInvoiceJour.ProjInvoiceId;
            projInvoiceCost.InvoiceDate     = projInvoiceJour.InvoiceDate;
            projInvoiceCost.insert();

            Docu::copy(projProposalCost, projInvoiceCost);

            while select projProposalCostDetail
                where projProposalCostDetail.ProposalRefRecId == projProposalCost.RecId
                    join projCostTransSale
                        where projCostTransSale.RecId == projProposalCostDetail.SaleRefRecId
            {
                projInvoiceCostDetail.clear();
                projInvoiceCostDetail = ProjInvoiceCostDetail::initInvoiceFromProposal(projProposalCost, projProposalCostDetail, projCostTransSale);
                projInvoiceCostDetail.InvoiceRefRecId = projInvoiceCost.RecId;
                if (projCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                        && isCreditInvoicingPrintingFlightEnabled)
                {
                    projInvoiceCostDetail.RefRecId = this.getOriginalInvoiceRefRecId_Cost(projProposalCostDetail.RecId);
                }
                projInvoiceCostDetail.insert();

                // <GEECZ>
                // This section has a side affect of modifying records when doing a
                // print preview. The flight addresses this issue and the problem
                // that this code is limited to a single localization.
                //
                // It also has a peformance issue of updating the record which was just created.
                if (countryRegion_CZ
                    &&  projCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                    && !isCreditInvoicingPrintingFlightEnabled)

                {
                    this.projInvoiceCostUpdate_CZ(projCostTransSale.RecId);
                }
                // </GEECZ>
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projInvoiceCost.TransDate));
            }
        }

        while select projProposalOnAcc where projProposalOnAcc.ProposalId == projProposalJour.ProposalId
        {
            numOfInvOnAcc++;

            projInvoiceOnAcc                = ProjInvoiceOnAcc::initInvoiceFromProposale(projProposalOnAcc);
            projInvoiceOnAcc.ProjInvoiceId  = projInvoiceJour.ProjInvoiceId;
            projInvoiceOnAcc.InvoiceDate    = projInvoiceJour.InvoiceDate;
            projInvoiceOnAcc.insert();

            Docu::copy(projProposalOnAcc, projInvoiceOnAcc);

            while select projProposalOnAccDetail
                where projProposalOnAccDetail.ProposalRefRecId == projProposalOnAcc.RecId
                    join projOnAccTransSale
                        where projOnAccTransSale.RecId == projProposalOnAccDetail.SaleRefRecId
            {
                projInvoiceOnAccDetail.clear();
                projInvoiceOnAccDetail = ProjInvoiceOnAccDetail::initInvoiceFromProposale(projProposalOnAcc, projProposalOnAccDetail, projOnAccTransSale);
                projInvoiceOnAccDetail.InvoiceRefRecId = projInvoiceOnAcc.RecId;
                if (projOnAccTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                        && isCreditInvoicingPrintingFlightEnabled)
                {
                    projInvoiceOnAccDetail.RefRecId = this.getOriginalInvoiceRefRecId_OnAcc(projProposalOnAccDetail.RecId);
                }
                projInvoiceOnAccDetail.insert();
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projInvoiceOnAcc.TransDate));
            }

            // <GEECZ>
            // This section has a side affect of modifying records when doing a
            // print preview. The flight addresses this issue and the problem
            // that this code is limited to a single localization.
            //
            // It also has a peformance issue of updating the record which was just created.
            if (countryRegion_CZ
                &&  projOnAccTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                && !isCreditInvoicingPrintingFlightEnabled)
            {
                this.projInvoiceOnAccUpdate_CZ(projOnAccTransSale.RecId);
            }
            // </GEECZ>
        }

        while select projProposalRevenue where projProposalRevenue.ProposalId == projProposalJour.ProposalId
        {
            numOfInvRevenue++;

            projInvoiceRevenue                  = ProjInvoiceRevenue::initInvoiceFromProposale(projProposalRevenue);
            projInvoiceRevenue.ProjInvoiceId    = projInvoiceJour.ProjInvoiceId;
            projInvoiceRevenue.InvoiceDate      = projInvoiceJour.InvoiceDate;
            projInvoiceRevenue.insert();

            Docu::copy(projProposalRevenue, projInvoiceRevenue);

            while select projProposalRevenueDetail
                where projProposalRevenueDetail.ProposalRefRecId == projProposalRevenue.RecId
                    join projRevenueTransSale
                        where projRevenueTransSale.RecId == projProposalRevenueDetail.SaleRefRecId
            {
                projInvoiceRevenueDetail.clear();
                projInvoiceRevenueDetail = ProjInvoiceRevenueDetail::initInvoiceFromProposale(projProposalRevenue, projProposalRevenueDetail, projRevenueTransSale);
                projInvoiceRevenueDetail.InvoiceRefRecId = projInvoiceRevenue.RecId;
                if (projRevenueTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                        && isCreditInvoicingPrintingFlightEnabled)
                {
                    projInvoiceRevenueDetail.RefRecId = this.getOriginalInvoiceRefRecId_Revenue(projProposalRevenueDetail.RecId);
                }
                projInvoiceRevenueDetail.insert();

                // <GEECZ>
                // This section has a side affect of modifying records when doing a
                // print preview. The flight addresses this issue and the problem
                // that this code is limited to a single localization.
                //
                // It also has a peformance issue of updating the record which was just created.
                if (countryRegion_CZ
                    &&  projRevenueTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                    && !isCreditInvoicingPrintingFlightEnabled)
                {
                    this.projInvoiceRevenueUpdate_CZ(projRevenueTransSale.RecId);
                }
                // </GEECZ>
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projInvoiceRevenue.TransDate));
            }
        }

        while select projProposalItem where projProposalItem.ProposalId == projProposalJour.ProposalId
        {
            switch (projProposalItem.ItemType)
            {
                case ProjItemType::Project:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);
                    break;

                case ProjItemType::InventJournal:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
                    {
                        this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projInvoiceItem.TransDate,
                                                                                null,
                                                                                '',
                                                                                PaymDueDateLimit_ES::getCurrentValues(InventItemGroup::find(
                                                                                    InventItemGroupItem::findByItemIdLegalEntity(
                                                                                            projInvoiceItem.ItemId).ItemGroupId).DueDateLimitGroupId_ES)));
                    }
                    break;

                case ProjItemType::PurchOrder:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
                    {
                        this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(projInvoiceItem.TransDate,
                                                                    null,
                                                                    '',
                                                                    PaymDueDateLimit_ES::getCurrentValues(
                                                                    InventItemGroup::find(InventItemGroupItem::findByItemIdLegalEntity(
                                                                    projInvoiceItem.ItemId).ItemGroupId).DueDateLimitGroupId_ES)));
                    }
                    break;

                case ProjItemType::VendorInvoice:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);
                    break;

                case ProjItemType::SalesOrder:
                    numOfInvSalesLine++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_SalesOrder(projProposalItem);

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
                    {
                        salesTable = SalesTable::find(projInvoiceItem.SalesId);

                        this.updateDueDate_ES(this.calculateDueDateFromDeliveryDate_ES(salesTable.ReceiptDateConfirmed,
                                                                    PaymTerm::find(salesTable.Payment),
                                                                    salesTable.paymDayId(),
                                                                    PaymDueDateLimit_ES::getCurrentValues(
                                                                    InventItemGroup::find(
                                                                    InventItemGroupItem::findByItemIdLegalEntity(projInvoiceItem.ItemId).ItemGroupId).DueDateLimitGroupId_ES)));
                    }
                    break;

                case ProjItemType::Production:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);
                    break;

                case ProjItemType::ProdLine:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);
                    break;

                case ProjItemType::BeginningBalance:
                    numOfInvItem++;
                    projInvoiceItem                 = ProjInvoiceItem::initInvoice_Project(projProposalItem);
                    break;
            }

            projInvoiceItem.ProjInvoiceId   = projInvoiceJour.ProjInvoiceId;
            projInvoiceItem.InvoiceDate     = projInvoiceJour.InvoiceDate;
            projInvoiceItem.insert();

            Docu::copy(projProposalItem, projInvoiceItem);

            while select projProposalItemDetail
                where projProposalItemDetail.ProposalRefRecId == projProposalItem.RecId
            {
                projInvoiceItemDetail.clear();
                projInvoiceItemDetail = this.populateInvoiceItemDetails(projInvoiceItemDetail, projProposalItemDetail, projProposalItem);

                projInvoiceItemDetail.InvoiceRefRecId = projInvoiceItem.RecId;
                if (isCreditInvoicingPrintingFlightEnabled)
                {
                    ProjItemTransSale projItemTransSale = ProjItemTransSale::find(projProposalItemDetail.SaleRefRecId);
                    if (projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal)
                    {
                        projInvoiceItemDetail.RefRecId = ProjInvoiceItemDetail::getOriginalInvoiceRefRecId(projItemTransSale.RecId);
                    }
                }
                projInvoiceItemDetail.insert();

                // <GEECZ>
                // This section has a side affect of modifying records when doing a
                // print preview. The flight addresses this issue and the problem
                // that this code is limited to a single localization.
                //
                // It also has a peformance issue of updating the record which was just created.
                if (countryRegion_CZ
                    &&  projProposalItemDetail.projItemTransSale().TransStatus  == ProjTransStatus::CreditnoteProposal
                    && !isCreditInvoicingPrintingFlightEnabled)
                {
                    this.projInvoiceItemUpdate_CZ(projProposalItemDetail.SaleRefRecId);
                }
                // </GEECZ>
            }
        }

        // This line updates the invoice lines with the tax code and tax amount but does not post the tax since it is only a proforma invoice.
        this.postTax(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInvoiceItemDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Logic to initialize data in <c>ProjInvoiceItemDetail</c>.
    /// </summary>
    /// <param name = "_projInvoiceItemDetail">
    ///     A <c>ProjInvoiceItemDetail</c> buffer variable.
    /// </param>
    /// <param name = "_projProposalItemDetail">
    ///     A <c>ProjProposalItemDetail</c> buffer variable.
    /// </param>
    /// <param name = "_projProposalItem">
    ///     A <c>ProjProposalItem</c> buffer variable.
    /// </param>
    /// <returns>
    ///     Returns <c>ProjInvoiceItemDetail</c> updated table buffer.
    /// </returns>
    protected ProjInvoiceItemDetail populateInvoiceItemDetails(ProjInvoiceItemDetail _projInvoiceItemDetail, ProjProposalItemDetail _projProposalItemDetail, ProjProposalItem _projProposalItem)
    {
        switch (_projProposalItem.ItemType)
        {
            case ProjItemType::Project:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;

            case ProjItemType::InventJournal:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;

            case ProjItemType::PurchOrder:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;

            case ProjItemType::VendorInvoice:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;

            case ProjItemType::SalesOrder:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_SalesOrder(_projProposalItem, _projProposalItemDetail);
                break;

            case ProjItemType::Production:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;

            case ProjItemType::ProdLine:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;

            case ProjItemType::BeginningBalance:
                _projInvoiceItemDetail = ProjInvoiceItemDetail::initInvoice_Project(_projProposalItem, _projProposalItemDetail, _projProposalItemDetail.projItemTransSale());
                break;
        }
        return _projInvoiceItemDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordList()
    {
        super();

        if (!proforma)
        {
            recordInsertListSpecTrans.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table ID for the journal line table.
    /// </summary>
    /// <returns>
    /// A table ID.
    /// </returns>
    protected TableId journalLineTableId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUpFixedEuroTriangulation</Name>
				<Source><![CDATA[
    protected UnknownNoYes markUpFixedEuroTriangulation()
    {
        UnknownNoYes    retValue = UnknownNoYes::Unknown;

        if (ProjInvoiceCurrency::exist(projProposalJour.ProjInvoiceProjId,projProposalJour.CurrencyId))
        {
            retValue = UnknownNoYes::No;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUpfixedExchRate</Name>
				<Source><![CDATA[
    protected CustExchRate markUpfixedExchRate()
    {
        CustExchRate    retValue = 0;

        if (ProjInvoiceCurrency::exist(projProposalJour.ProjInvoiceProjId,projProposalJour.CurrencyId))
        {
            retValue = ProjInvoiceCurrency::find(projProposalJour.ProjInvoiceProjId,projProposalJour.CurrencyId).ExchRate;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUpFixedExchRateSecondary</Name>
				<Source><![CDATA[
    protected ExchrateSecondary markUpFixedExchRateSecondary()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchInvoicePackingSlip</Name>
				<Source><![CDATA[
    protected void matchInvoicePackingSlip(ProjProposalItem _projProposalItem, ProjInvoiceItem _projInvoiceItem)
    {
        TradeNotStockedPostCheck        notStockedPostCheck;
        ProjItemTrans                   projItemTrans;
        ProjItemTrans                   projItemTransTop;
        SalesLine                       salesLine;
        SalesTable                      salesTable;
        CustPackingSlipTrans            custPackingSlipTrans;
        CustPackingSlipJour             custPackingSlipJour;
        SalesParmLine                   salesParmLine;
        SalesParmSubLine                salesParmSubLine;
        SalesInvoicePostNotStockedProj  salesInvoicePostNotStockedProj;
        SalesLineType                   salesLineType;
        RefRecId                        sourceDocumentHeaderRecId;
        RefRecId                        sourceDocumentLineRecId;
        SourceDocumentHeader            sourceDocumentHeader;
        SourceDocumentLine              sourceDocumentLine;
        SalesQuantity                   salesQuantity;

        TradeNotStockedPostCheck createNotStockedPostCheck()
        {
            return TradeNotStockedPostCheck::newSalesLine(salesLine, projItemTransTop.Qty, salesParmLine.RemainAfter, salesParmLine.RemainBefore);
        }

        boolean checkNotStockedLineBeforePosting(TradeNotStockedPostCheck _notStockedPostCheck)
        {
            return _notStockedPostCheck.checkUpdatePhysicalBeforePosting();
        }

        void updateInventory(SalesParmLine  _salesParmLine, RefRecId _sourceDocumentLineRecId)
        {
            List                    list;
            Counter                 subLines;
            ListEnumerator          le;
            SalesQty                salesQtyLeft;
            InventQty               inventQtyLeft;
            SalesQty                deliverNow;
            InventQty               inventNow;
            CustPackingSlipTrans    localCustPackingSlipTrans;
            SalesParmSubLine        localSalesParmSubLine;

            list = SalesParmSubLine::buildSalesParmSubLineList(_salesParmLine.RecId);

            subLines        = list.elements();
            le              = list.getEnumerator();
            salesQtyLeft    = _salesParmLine.DeliverNow;
            inventQtyLeft   = _salesParmLine.InventNow;

            while (le.moveNext())
            {
                localSalesParmSubLine = le.current();

                if (subLines == 1)
                {
                    deliverNow = salesQtyLeft;
                    inventNow  = inventQtyLeft;
                }
                else
                {
                    deliverNow = localSalesParmSubLine.DeliverNow;
                    inventNow  = localSalesParmSubLine.InventNow;
                }

                subLines--;

                localCustPackingSlipTrans = CustPackingSlipTrans::findRecId(localSalesParmSubLine.JournalRefRecId,true);
                CustInvoicePackingSlipQuantityMatch::matchPackingSlipTransSourceDocumentLine(recordInsertListCustInvoicePackingSlipMatch, _sourceDocumentLineRecId, localCustPackingSlipTrans, deliverNow, inventNow);

                salesQtyLeft  -= localSalesParmSubLine.DeliverNow;
                inventQtyLeft -= localSalesParmSubLine.InventNow;
            }
        }

        projItemTrans = _projProposalItem.projItemTrans();
        if (projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement)
        {
            projItemTransTop = projItemTrans;
            while (projItemTransTop.AdjRefTransId)
            {
                projItemTransTop = ProjItemTrans::find(projItemTransTop.AdjRefTransId);
            }

            salesLine = SalesLine::findInventTransId(projItemTransTop.InventTransId, true);

            while select custPackingSlipTrans
                where custPackingSlipTrans.InventTransId == salesLine.InventTransId &&
                    custPackingSlipTrans.FullyMatched  == NoYes::No
                exists join custPackingSlipJour
                where custPackingSlipJour.SalesId == custPackingSlipTrans.SalesId
                    && custPackingSlipJour.PackingSlipId == custPackingSlipTrans.PackingSlipId
                    && custPackingSlipJour.DeliveryDate == custPackingSlipTrans.DeliveryDate
                    && custPackingSlipJour.LedgerVoucher == projItemTransTop.VoucherPackingSlip
            {
                if (!salesParmLine)
                {
                    salesParmLine.clear();
                    salesParmLine.InventTransId = _projProposalItem.InventTransId;

                    salesQuantity = SalesQuantity::construct(DocumentStatus::Invoice);
                    [salesParmLine.DeliverNow, salesParmLine.RemainBefore, salesParmLine.RemainAfter] =
                        salesQuantity.qtySales(
                                        salesLine,
                                        SalesUpdate::PackingSlip,
                                        projItemTransTop.Qty);

                    if (salesLine.isStocked())
                    {
                        [salesParmLine.InventNow, salesParmLine.RemainBeforeInvent, salesParmLine.RemainAfterInvent] =
                            salesQuantity.qtyInvent(
                                            salesLine,
                                            SalesUpdate::PackingSlip,
                            EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(projItemTransTop.ItemId,
                                                                                                  projItemTransTop.InventDimId,
                                                                                                  projItemTransTop.Qty,
                                                                                                  projItemTransTop.SalesUnit,
                                                                                                  InventTable::find(projItemTransTop.ItemId).inventUnitId(),
                                                                                                  NoYes::Yes));
                    }

                    salesParmLine.doInsert();
                }

                salesParmSubLine.clear();
                salesParmSubLine.LineRefRecId = salesParmLine.RecId;
                salesParmSubLine.initFromCustPackingSlipTrans(custPackingSlipTrans);
                salesParmSubLine.doInsert();
            }

            if (salesParmLine)
            {
                if (!salesLine.isStocked())
                {
                    notStockedPostCheck = createNotStockedPostCheck();

                    if (notStockedPostCheck
                        && !checkNotStockedLineBeforePosting(notStockedPostCheck))
                    {
                        throw error("@SYS21533");
                    }

                    salesInvoicePostNotStockedProj = SalesInvoicePostNotStockedProj::construct(_projProposalItem,
                                                                                salesLine,
                                                                                salesParmLine,
                                                                                recordInsertListCustInvoicePackingSlipMatch,
                                                                                projInvoiceJour.SourceDocumentHeader);

                    // RemainSalesFinancial is updated while posting the non stocked item
                    salesInvoicePostNotStockedProj.postNotStocked();

                    if (notStockedPostCheck
                        && !this.checkNotStockedLineAfterNotStockedPosting(notStockedPostCheck, salesInvoicePostNotStockedProj))
                    {
                        throw error("@SYS21533");
                    }

                    _projInvoiceItem.QtyPhysical = salesInvoicePostNotStockedProj.parmInvoiceUpdatedOnly();

                    sourceDocumentHeaderRecId = salesInvoicePostNotStockedProj.parmSourceDocumentHeaderRecId();
                    sourceDocumentLineRecId = salesInvoicePostNotStockedProj.parmSourceDocumentLineRecId();
                }
                else
                {
                    sourceDocumentHeaderRecId = projInvoiceJour.SourceDocumentHeader;
                    if (!sourceDocumentHeaderRecId)
                    {
                        sourceDocumentHeader = SourceDocumentHeader::insertSourceDocument(
                                                                        tableNum(ProjInvoiceJour),
                                                                        enumStr(SourceDocument_ProjectInvoice),
                                                                        SourceDocument_ProjectInvoice::ProjectInvoice);

                        sourceDocumentHeaderRecId = sourceDocumentHeader.RecId;
                    }

                    sourceDocumentLine = SourceDocumentLine::insertSourceDocumentLine(
                                                                sourceDocumentHeaderRecId,
                                                                tableNum(ProjInvoiceItem),
                                                                enumStr(SourceDocumentLine_ProjectInvoice),
                                                                SourceDocumentLine_ProjectInvoice::ProjectItemInvoiceLine,
                                                                DateTimeUtil::date(
                                                                    DateTimeUtil::applyTimeZoneOffset(
                                                                        sourceDocumentHeader.CreatedDateTime,
                                                                        DateTimeUtil::getUserPreferredTimeZone())));

                    sourceDocumentLineRecId = sourceDocumentLine.RecId;

                    updateInventory(salesParmLine, sourceDocumentLineRecId);
                }

                if (!projInvoiceJour.SourceDocumentHeader && sourceDocumentHeaderRecId)
                {
                    projInvoiceJour.SourceDocumentHeader = sourceDocumentHeaderRecId;
                    projInvoiceJour.doUpdate();
                }

                _projInvoiceItem.SourceDocumentLine = sourceDocumentLineRecId;
                _projInvoiceItem.doUpdate();

                salesLineType = salesLine.type();
                salesLineType.updateSalesLine(null);
                salesLine.doUpdate();

                salesTable = salesLine.salesTable(true);
                salesTable.updateDocumentStatus(DocumentStatus::Invoice);
                salesTable.updateBackStatus();
                salesTable.updateSalesType();

                delete_from salesParmSubLine
                    where salesParmSubLine.LineRefRecId == salesParmLine.RecId;

                salesParmLine.doDelete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotStockedLineAfterNotStockedPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the physical update of the not stocked order line after posting.
    /// </summary>
    /// <param name="_notStockedPostCheck">
    /// The <c>TradeNotStockedPostCheck</c> that carries information for validation.
    /// </param>
    /// <param name="_salesInvoicePostNotStockedProj">
    /// The <c>SalesInvoicePostNotStockedProj</c> that carries information for validation.
    /// </param>
    /// <returns>
    /// true if the <c>TradeNotStockedPostCheck</c> is validated; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean checkNotStockedLineAfterNotStockedPosting(
        TradeNotStockedPostCheck _notStockedPostCheck,
        SalesInvoicePostNotStockedProj _salesInvoicePostNotStockedProj)
    {
        _notStockedPostCheck.parmQtyPhysicalToBeJournalUpdated(_salesInvoicePostNotStockedProj.parmInvoiceUpdatedOnly());

        return _notStockedPostCheck.checkUpdatePhysicalAfterPosting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveSpecTrans</Name>
				<Source><![CDATA[
    protected void moveSpecTrans(ProjInvoiceJour _projInvoiceJour)
    {
        ProjTable   projTable;
        SpecTrans   specTrans;

        while select crossCompany TableId, RecId, DataAreaId from projTable
            where projTable.ProjInvoiceProjId == _projInvoiceJour.ProjInvoiceProjId
            join forupdate specTrans
                where specTrans.SpecTableId == projTable.TableId &&
                      specTrans.SpecRecId   == projTable.RecId &&
                      specTrans.SpecCompany == projTable.DataAreaId
        {
            specTrans.SpecTableId   = _projInvoiceJour.TableId;
            specTrans.SpecRecId     = _projInvoiceJour.RecId;
            specTrans.SpecCompany   = _projInvoiceJour.company();
            specTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = projInvoiceJour)
    {
        projInvoiceJour = _journalTable as ProjInvoiceJour;

        return projInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = projInvoiceParmTable)
    {
        projInvoiceParmTable = _parmTable as ProjInvoiceParmTable;

        return projInvoiceParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorno</Name>
				<Source><![CDATA[
    public boolean parmStorno(boolean _storno = false)
    {
        boolean ret;
        ProjFormLetter projFormLetter = this.parmFormletter() as ProjFormLetter;

        ret = projFormLetter.storno() && LedgerParameters::find().TransactionReversalCorrection;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs customer and vendor related postings.
    /// </summary>
    protected void postCustVend()
    {
        CustVoucherProject projVoucher = this.createProjVoucher();

        this.postLedgerVoucher(projVoucher);
        
        this.insertCustomerRetention();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the customer or vendor voucher.
    /// </summary>
    /// <param name="_projVoucher">
    /// An instance of <c>CustVoucherProject</c> class to post.
    /// </param>
    protected void postLedgerVoucher(CustVoucherProject _projVoucher)
    {
        // Treat a cust or vendor voucher as correction when GL correction flag on and it is a credit note proposal.
        if (this.transStatus == ProjTransStatus::CreditnoteProposal && LedgerParameters::find().TransactionReversalCorrection)
        {
            custTrans.Correct = NoYes::Yes;

            LedgerVoucherObject ledgerVoucherObj = ledgerVoucher.findLedgerVoucherObject();
            if (ledgerVoucherObj)
            {
                ledgerVoucherObj.parmIsCorrectionDefault(true);
            }
        }
        
        _projVoucher.post(ledgerVoucher, custTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>CustVoucherProject</c> instance to post.
    /// </summary>
    /// <returns>
    /// A <c>CustVoucherProject</c> instance.
    /// </returns>
    protected CustVoucherProject createProjVoucher()
    {
        LedgerTransTxt ledgerTransTxt;

        if (creditNote)
        {
            ledgerTransTxt = LedgerTransTxt::ProjectCreditNoteCust;
        }
        else
        {
            ledgerTransTxt = LedgerTransTxt::ProjectInvoiceCust;
        }

        this.moveSpecTrans(projInvoiceJour);

        SettlementType setType = SettlementType::SelectedTransact;

        CustVoucherProject projVoucher = CustVendVoucher::constructProject(projInvoiceJour.InvoiceAccount,
            // < positive when withhold and negative when release split and combine AR accounts >
            projInvoiceJour.InvoiceAmount,
            projInvoiceJour.CurrencyId,
            ledgerTransTxt,
            projInvoiceJour.DefaultDimension,
            projInvoiceJour.PostingProfile,
            LedgerPostingType::CustBalance,
            projInvoiceJour.Payment,
            setType,
            HcmWorker::userId2Worker(curUserId()),
            NoYes::Yes,
            projInvoiceJour.ProjInvoiceId,
            projInvoiceJour.CashDiscDate,
            projInvoiceJour.CashDisc,
            projInvoiceJour.DueDate,
            projInvoiceJour,
            TypeOfCreditmaxCheck::None,
            projInvoiceJour.CashDiscCode,
            projInvoiceJour.OrderAccount);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            projVoucher.parmAmountCur(projProposalTotals.custTransAmount_BR());
        }
        // </GBR>

        projVoucher.parmFixedExchRate(fixedExchRate);
        projVoucher.parmExchRate(projInvoiceJour.ExchRate);
        projVoucher.parmExchRateSecondary(projInvoiceJour.ExchrateSecondary);

        if (projInvoiceJour.projInvoiceProjId != '')
        {
            ProjInvoiceCurrency projInvoiceCurrency = ProjInvoiceCurrency::getFixedRateAgreementForReportingCurrency(projInvoiceJour.projInvoiceProjId);

            if (projInvoiceCurrency)
            {
                // Setting the reporting exchange rate from fixed exchange rate defined in contract.
                projVoucher.parmReportingCurrencyExchRate(ProjInvoiceCurrency::applyReciprocalForFixedExchangeRate(Ledger::defaultExchangeRateType(), projInvoiceJour.CurrencyId,
                    projInvoiceCurrency.CurrencyId, projInvoiceJour.InvoiceDate, projInvoiceCurrency));
            }
        }

        projVoucher.setInvoiceJournal(projInvoiceJour);
        projVoucher.parmBypassCreditCheck(projInvoiceJour.creditCardBypassCreditLimit());
        projVoucher.parmFormLetter(projInvoiceJour.InvoiceAccount);
        projVoucher.parmThirdPartyBankAccountId(CustTable::find(projInvoiceJour.OrderAccount).BankAccount);

        CustTransRefType refType;

        if (projInvoiceJour.InvoiceAmount < 0)
        {
            refType = CustTransRefType::CreditNote;
        }
        else
        {
            refType = CustTransRefType::Invoice;
        }

        projVoucher.setTransRef(refType, projInvoiceJour.ProjInvoiceId);
        projVoucher.parmDirectDebitMandateRecId(projInvoiceJour.DirectDebitMandate);

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            projVoucher.parmTaxWithholdAmount_IN(projProposalTotals.parmTaxWithholdAmount_IN());
        }
        
        if (projVoucher.parmTransRefType() == CustTransRefType::CreditNote)
        {
            boolean enableCreditNoteUseOrigInvoiceDateForExchRateFlight = FeatureStateProvider::isFeatureEnabled(ProjCreditNoteUseOrigInvoiceDateForExchRateFlight::instance());
            // When posting credit note or invoice proposal which involve customer advance
            // then exchange rate should be taken for <c>ledgerTransDate</c>
            if (ledgerTransDate)
            {
                // Checks for deduction records and sets the exchange rate and ledger transaction date
                PSAProjProposalProj psaProjProposalProjNonDeduct;
                ProjTable projTable;
                select firstonly RecId from psaProjProposalProjNonDeduct
                    where psaProjProposalProjNonDeduct.ProjProposalId == projInvoiceJour.ProposalId
                        && psaProjProposalProjNonDeduct.IsPreBill == NoYes::No
                    exists join projTable
                    where projTable.ProjId == psaProjProposalProjNonDeduct.ProjId
                        && projTable.ProjInvoiceProjId == projInvoiceJour.ProjInvoiceProjId;
                if (!psaProjProposalProjNonDeduct.RecId)
                {
                    // Checks whether multiple deduction records are being processed then we can pass total accounting and reporting amounts.
                    if (totalOnAccDeductionRecords > 1)
                    {
                        this.setAccountingAndReportingCurrencyBalances(projVoucher);
                    }
                    else
                    {
                        projVoucher.parmExchangeRateDate(ledgerTransDate);
                        projVoucher.parmExchRate(ExchangeRateHelper::exchRate(projInvoiceJour.CurrencyId, ledgerTransDate));
                    }
                }
                else if (enableCreditNoteUseOrigInvoiceDateForExchRateFlight)
                {
                    // When <c>ProjCreditNoteUseOrigInvoiceDateForExchRateFlight</c> flight is enabled
                    // then system considers accounting and reporting amounts of  original transaction for credit note transactions.
                    this.setAccountingAndReportingCurrencyBalances(projVoucher);
                }
            }
            else if (enableCreditNoteUseOrigInvoiceDateForExchRateFlight)
            {
                // When <c>ProjCreditNoteUseOrigInvoiceDateForExchRateFlight</c> flight is enabled
                // then system considers accounting and reporting amounts of  original transaction for credit note transactions.
                this.setAccountingAndReportingCurrencyBalances(projVoucher);
            }
        }

        return projVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPostBR</Name>
				<Source><![CDATA[
    private void postEndPostBR()
    {
        this.updateProjInvoiceTransTaxWithholdGroup();

        this.postFiscalDocument_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFiscalDocument_BR</Name>
				<Source><![CDATA[
    private void postFiscalDocument_BR()
    {
        FiscalDocumentPost_BR   fiscalDocumentPost;
        ProjInvoiceJour         projInvoiceJourToCancel;

        if (projProposalJour.InvoiceType == ProjInvoiceType::DebitNote_BR)
        {
            return;
        }

        if (!this.creditNote())
        {
            if (projInvoiceJour.isProforma())
            {
                fiscalDocumentPost = new FiscalDocumentPost_BR(
                    FiscalDocumentParmDataCreator_BR::fromProjectProFormaInvoice(projInvoiceJour, projProposalTotals, projInvoiceTable, projProposalJour, journalTmpTaxWorkTrans));
            }
            else
            {
                fiscalDocumentPost = new FiscalDocumentPost_BR(
                    FiscalDocumentParmDataCreator_BR::fromProjectInvoice(projInvoiceJour, projProposalTotals, projInvoiceTable, projProposalJour));
            }

            fiscalDocumentPost.run();
        }
        else
        {
            select  RecId,
                    LedgerVoucher,
                    InvoiceDate,
                    ReasonTableRef from projInvoiceJourToCancel
                where projInvoiceJourToCancel.ProposalId == tmpInvoiceCancel.RefProposalId;

            if (tmpInvoiceCancel.RecId)
            {
                FiscalDocumentPost_BR::cancelFiscalDocument(FiscalDocument_BR::findByRef(projInvoiceJourToCancel.TableId, projInvoiceJourToCancel.RecId),
                                                            projInvoiceJour.LedgerVoucher,
                                                            projInvoiceJourToCancel.InvoiceDate,
                                                            '',
                                                            ReasonTableRef::find(projInvoiceJourToCancel.ReasonTableRef).ReasonComment);

                delete_from tmpInvoiceCancel
                    where projInvoiceJourToCancel.ProposalId == tmpInvoiceCancel.RefProposalId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkUpJour</Name>
				<Source><![CDATA[
    private void postMarkUpJour(SalesTable _salesTableMarkup)
    {
        markup.postInvoice(1,
                           projProposalTotals.orderBalance(_salesTableMarkup.RecId),
                           _salesTableMarkup,
                           ledgerVoucher,
                           _salesTableMarkup.DefaultDimension,
                           projInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    protected void postMarkupTable()
    {
        QueryRun            queryRun;
        SalesTable          salesTableMarkup;

        queryRun = new QueryRun(projProposalJour.querySalesTable(false));

        while (queryRun.next())
        {
            if (queryRun.changed(tableNum(SalesTable)))
            {
                salesTableMarkup = queryRun.get(tableNum(SalesTable));
                if (salesTableMarkup)
                {
                    this.postMarkUpJour(salesTableMarkup);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projAdjustBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the budget of the project.
    /// </summary>
    /// <returns>
    ///    true if the  budget was adjusted; otherwise, false.
    /// </returns>
    private boolean projAdjustBudget()
    {
        boolean isBudgetadjusted = false; 
		boolean isBudgetReversed = true;

        if (projBudgetTransactionReverse)
        {
            projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransactionReverse);
            isBudgetReversed = projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement);
        }

        if (isBudgetReversed && projBudgetTransactionNormal)
        {
            projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransactionNormal);
            isBudgetadjusted = projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement);
        }

        return isBudgetadjusted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceCostUpdate_CZ</Name>
				<Source><![CDATA[
    private void projInvoiceCostUpdate_CZ(RefRecId _saleRefRecId)
    {
        ProjInvoiceCostDetail     projInvoiceCostDetailOriginal;
        ProjInvoiceCostDetail     projInvoiceCostDetailReverse;

        ttsbegin;

        select forupdate RefRecId from projInvoiceCostDetailOriginal
            where  projInvoiceCostDetailOriginal.SaleRefRecId == _saleRefRecId
               && !projInvoiceCostDetailOriginal.RefRecId;

        select forupdate RefRecId from projInvoiceCostDetailReverse
            where  projInvoiceCostDetailReverse.SaleRefRecId == _saleRefRecId
               &&  projInvoiceCostDetailReverse.RecId != projInvoiceCostDetailOriginal.RecId
               && !projInvoiceCostDetailReverse.RefRecId;

        projInvoiceCostDetailReverse.RefRecId = projInvoiceCostDetailOriginal.RecId;

        projInvoiceCostDetailOriginal.RefRecId = projInvoiceCostDetailReverse.RecId;

        projInvoiceCostDetailReverse.update();
        projInvoiceCostDetailOriginal.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalInvoiceRefRecId_Empl</Name>
				<Source><![CDATA[
    private RecId getOriginalInvoiceRefRecId_Empl(RefRecId _saleRefRecId)
    {
        ProjInvoiceEmplDetail projInvoiceEmplDetail;

        // Attempt to get the last invoice which should not be a credit memo
        select firstonly RefRecId from projInvoiceEmplDetail
            where  projInvoiceEmplDetail.SaleRefRecId == _saleRefRecId
                && !projInvoiceEmplDetail.RefRecId;

        return projInvoiceEmplDetail.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalInvoiceRefRecId_Cost</Name>
				<Source><![CDATA[
    private RecId getOriginalInvoiceRefRecId_Cost(RefRecId _saleRefRecId)
    {
        ProjInvoiceCostDetail projInvoiceCostDetail;

        // Attempt to get the last invoice which should not be a credit memo
        select firstonly RefRecId from projInvoiceCostDetail
            where  projInvoiceCostDetail.SaleRefRecId == _saleRefRecId
                && !projInvoiceCostDetail.RefRecId;

        return projInvoiceCostDetail.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalInvoiceRefRecId_Revenue</Name>
				<Source><![CDATA[
    private RecId getOriginalInvoiceRefRecId_Revenue(RefRecId _saleRefRecId)
    {
        ProjInvoiceRevenueDetail projInvoiceRevenueDetail;

        // Attempt to get the last invoice which should not be a credit memo
        select firstonly RefRecId from projInvoiceRevenueDetail
            where  projInvoiceRevenueDetail.SaleRefRecId == _saleRefRecId
                && !projInvoiceRevenueDetail.RefRecId;

        return projInvoiceRevenueDetail.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalInvoiceRefRecId_OnAcc</Name>
				<Source><![CDATA[
    private RecId getOriginalInvoiceRefRecId_OnAcc(RefRecId _saleRefRecId)
    {
        ProjInvoiceOnAccDetail projInvoiceOnAccDetail;

        // Attempt to get the last invoice which should not be a credit memo
        select firstonly RefRecId from projInvoiceOnAccDetail
            where  projInvoiceOnAccDetail.SaleRefRecId == _saleRefRecId
                && !projInvoiceOnAccDetail.RefRecId;

        return projInvoiceOnAccDetail.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceEmplUpdate_CZ</Name>
				<Source><![CDATA[
    private void projInvoiceEmplUpdate_CZ(RefRecId _saleRefRecId)
    {
        ProjInvoiceEmplDetail     projInvoiceEmplDetailOriginal;
        ProjInvoiceEmplDetail     projInvoiceEmplDetailReverse;

        ttsbegin;

        select forupdate RefRecId from projInvoiceEmplDetailOriginal
            where  projInvoiceEmplDetailOriginal.SaleRefRecId == _saleRefRecId
               && !projInvoiceEmplDetailOriginal.RefRecId;

        select forupdate RefRecId from projInvoiceEmplDetailReverse
            where  projInvoiceEmplDetailReverse.SaleRefRecId == _saleRefRecId
               &&  projInvoiceEmplDetailReverse.RecId != projInvoiceEmplDetailOriginal.RecId
               && !projInvoiceEmplDetailReverse.RefRecId;

        projInvoiceEmplDetailReverse.RefRecId = projInvoiceEmplDetailOriginal.RecId;

        projInvoiceEmplDetailOriginal.RefRecId = projInvoiceEmplDetailReverse.RecId;

        projInvoiceEmplDetailReverse.update();
        projInvoiceEmplDetailOriginal.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceItemUpdate_CZ</Name>
				<Source><![CDATA[
    private void projInvoiceItemUpdate_CZ(RefRecId _saleRefRecId)
    {
        ProjInvoiceItemDetail       projInvoiceItemDetailOriginal;
        ProjInvoiceItemDetail       projInvoiceItemDetailReverse;

        ttsbegin;
        select forupdate RefRecId from projInvoiceItemDetailOriginal
            where  projInvoiceItemDetailOriginal.SaleRefRecId == _saleRefRecId
               && !projInvoiceItemDetailOriginal.RefRecId;

        select forupdate RefRecId from projInvoiceItemDetailReverse
            where  projInvoiceItemDetailReverse.SaleRefRecId == _saleRefRecId
               &&  projInvoiceItemDetailReverse.RecId != projInvoiceItemDetailOriginal.RecId
               && !projInvoiceItemDetailReverse.RefRecId;

        projInvoiceItemDetailReverse.RefRecId = projInvoiceItemDetailOriginal.RecId;

        projInvoiceItemDetailOriginal.RefRecId = projInvoiceItemDetailReverse.RecId;

        projInvoiceItemDetailReverse.update();
        projInvoiceItemDetailOriginal.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceOnAccUpdate_CZ</Name>
				<Source><![CDATA[
    private void projInvoiceOnAccUpdate_CZ(RefRecId _saleRefRecId)
    {
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetailOriginal;
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetailReverse;

        ttsbegin;

        select forupdate RefRecId from projInvoiceOnAccDetailOriginal
            where  projInvoiceOnAccDetailOriginal.SaleRefRecId == _saleRefRecId
               && !projInvoiceOnAccDetailOriginal.RefRecId;

        select forupdate RefRecId from projInvoiceOnAccDetailReverse
            where  projInvoiceOnAccDetailReverse.SaleRefRecId == _saleRefRecId
               &&  projInvoiceOnAccDetailReverse.RecId != projInvoiceOnAccDetailOriginal.RecId
               && !projInvoiceOnAccDetailReverse.RefRecId;

        projInvoiceOnAccDetailReverse.RefRecId = projInvoiceOnAccDetailOriginal.RecId;

        projInvoiceOnAccDetailOriginal.RefRecId = projInvoiceOnAccDetailReverse.RecId;

        projInvoiceOnAccDetailReverse.update();
        projInvoiceOnAccDetailOriginal.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceRevenueUpdate_CZ</Name>
				<Source><![CDATA[
    private void projInvoiceRevenueUpdate_CZ(RefRecId _saleRefRecId)
    {
        ProjInvoiceRevenueDetail     projInvoiceRevenueDetailOriginal;
        ProjInvoiceRevenueDetail     projInvoiceRevenueDetailReverse;

        ttsbegin;

        select forupdate RefRecId from projInvoiceRevenueDetailOriginal
            where  projInvoiceRevenueDetailOriginal.SaleRefRecId == _saleRefRecId
               && !projInvoiceRevenueDetailOriginal.RefRecId;

        select forupdate RefRecId from projInvoiceRevenueDetailReverse
            where  projInvoiceRevenueDetailReverse.SaleRefRecId == _saleRefRecId
               &&  projInvoiceRevenueDetailReverse.RecId != projInvoiceRevenueDetailOriginal.RecId
               && !projInvoiceRevenueDetailReverse.RefRecId;

        projInvoiceRevenueDetailReverse.RefRecId = projInvoiceRevenueDetailOriginal.RecId;

        projInvoiceRevenueDetailOriginal.RefRecId = projInvoiceRevenueDetailReverse.RecId;

        projInvoiceRevenueDetailReverse.update();
        projInvoiceRevenueDetailOriginal.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseProjBudgetTransaction</Name>
				<Source><![CDATA[
    private boolean reverseProjBudgetTransaction(ProjTransIdBase _projTransId)
    {
        ProjBudgetReductionHistory  projBudgetReductionHistory;
        boolean                     reverseTransaction = false;

        projBudgetReductionHistory = ProjBudgetReductionHistory::findByProjTransId(_projTransId);
        
        if (projBudgetReductionHistory && projBudgetReductionHistory.SalesAmountReduced != 0)
        {
            reverseTransaction = true;
        }

        return reverseTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSubscriptionAccruals</Name>
				<Source><![CDATA[
    protected void reverseSubscriptionAccruals(
        ProjProposalRevenue         projProposalRevenue,
        ProjTransRevenueProposal    projTransRevenueProposal)
    {
        SMAAccruePeriodLine     smaAccruePeriodLine;
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        FiscalCalendarYear      fiscalCalendarYear;
        RecId                   calendarRecId;
        ProjRevenueTransId      projRevenueTransId  = projProposalRevenue.TransId;
        List                    smaAccruePeriodLineList;
        TransDate               smaAccruePeriodLinePostingDate;
        boolean                 delete = true;

        // This function posts SMAAccruePeriodLines from _linesList using _postingDate.
        void postLinesFromList(List _linesList, TransDate _postingDate)
        {
            SMAAccruePeriodLine     line;
            ListEnumerator          linesListEnumerator = _linesList.getEnumerator();

            this.smaInitVoucher(projRevenueTransId, _postingDate);
            while (linesListEnumerator.moveNext())
            {
                line = linesListEnumerator.current();
                ProjPost::newEnterSMAAccrued(line, ledgerVoucherSMA, true, line.PostingDate, false).postTrans();
            }
            ledgerVoucherSMA.end();
            delete = false;
        }

        switch (SMAParametersSubscription::find().SubReverseAccruedOnCredit)
        {
            case  SMAReverseAccruedOnCredit::Manual :
                if ((select count(RecId) from smaAccruePeriodLine
                        where smaAccruePeriodLine.ProjRevenueTransId  == projRevenueTransId
                           && smaAccruePeriodLine.PostingDate).RecId != 0)
                {
                    throw error("@SYS84341");
                }
                break;

            case SMAReverseAccruedOnCredit::PostingDate :
                smaAccruePeriodLineList = new List(Types::Record);

                smaAccruePeriodLinePostingDate = dateNull();

                while select smaAccruePeriodLine
                    order by smaAccruePeriodLine.PostingDate
                    where smaAccruePeriodLine.ProjRevenueTransId  == projRevenueTransId
                       && smaAccruePeriodLine.PostingDate         != dateNull()
                {
                    calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
                    fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(calendarRecId, smaAccruePeriodLine.Todate);

                    select firstonly fiscalCalendarPeriod
                        where   fiscalCalendarPeriod.EndDate    >= smaAccruePeriodLine.Todate &&
                                fiscalCalendarPeriod.StartDate  <= smaAccruePeriodLine.Todate &&
                                fiscalCalendarPeriod.Type       == FiscalPeriodType::Operating &&
                                fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId;

                    if (fiscalCalendarPeriod.currentLedgerPeriodStatus() !=  FiscalPeriodStatus::Open)
                    {
                        this.smaInitVoucher(projRevenueTransId,smaAccruePeriodLine.PostingDate);
                        ProjPost::newEnterSMAAccrued(smaAccruePeriodLine, ledgerVoucherSMA, true,smaAccruePeriodLine.PostingDate,false).postTrans();
                        ledgerVoucherSMA.end();
                    }
                    // If posting date is the same as previous line add it to list
                    // and process in a single voucher later on.
                    else if (smaAccruePeriodLine.PostingDate == smaAccruePeriodLinePostingDate)
                    {
                        smaAccruePeriodLineList.addEnd(smaAccruePeriodLine);
                    }
                    // If the date is different then process already accumulated lines
                    // and add current line to new accumulation list.
                    else
                    {
                        if (!smaAccruePeriodLineList.empty())
                        {
                            postLinesFromList(smaAccruePeriodLineList, smaAccruePeriodLinePostingDate);
                            smaAccruePeriodLineList = new List(Types::Record);
                        }

                        smaAccruePeriodLineList.addEnd(smaAccruePeriodLine);
                        smaAccruePeriodLinePostingDate = smaAccruePeriodLine.PostingDate;
                    }
                }

                // Process accrue lines
                if (!smaAccruePeriodLineList.empty())
                {
                    postLinesFromList(smaAccruePeriodLineList, smaAccruePeriodLinePostingDate);
                }

                break;

            case SMAReverseAccruedOnCredit::InvoiceDate :
                this.smaInitVoucher(projRevenueTransId,projInvoiceJour.InvoiceDate);
                while select smaAccruePeriodLine
                    where smaAccruePeriodLine.ProjRevenueTransId    == projRevenueTransId
                       && smaAccruePeriodLine.PostingDate           != dateNull()
                {
                    ProjPost::newEnterSMAAccrued(smaAccruePeriodLine, ledgerVoucherSMA, true,smaAccruePeriodLine.PostingDate,false).postTrans();
                }
                ledgerVoucherSMA.end();

                break;
        }

        if (delete)
        {
            delete_from smaAccruePeriodLine
               where smaAccruePeriodLine.ProjRevenueTransId == projRevenueTransId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundingOffSign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a rounding sign.
    /// </summary>
    /// <returns>
    /// The rounding sign.
    /// </returns>
    protected int roundingOffSign()
    {
        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>ProjPost</c> object that has a <c>Tax</c> object that is assigned to it.
    /// </summary>
    /// <param name="_post">
    /// The <c>ProjPost</c> parameter that will have a <c>Tax</c> object assigned to it.
    /// </param>
    /// <returns>
    /// The <c>ProjPost</c> object.
    /// </returns>
    /// <remarks>
    /// This is a localized method for Eastern Europe.
    /// </remarks>
    protected ProjPost setTaxTo(ProjPost _post)
    {
        _post.parmTax_RU(this.tax());
        return _post;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaInitVoucher</Name>
				<Source><![CDATA[
    protected void smaInitVoucher(
        ProjRevenueTransId  _projRevenueTransId,
        TransDate           _transDate)
    {
        LedgerVoucherObject         ledgerVoucherObject;
        ProjTrans                   projTrans;
        ProjRevenueTrans            projRevenueTrans;
        ProjLedger                  projLedger;

        projRevenueTrans    = ProjRevenueTrans::find(_projRevenueTransId, true) ;
        voucherSMA            = NumberSeq::newGetNum(ProjParameters::numRefProjPeriodVoucher()).num();
        projTrans           = ProjTrans::newProjRevenueTrans(projRevenueTrans);
        projLedger          = ProjLedger::newProjectSales(projTrans, projTrans.transId(),
                                                          projRevenueTrans.TransactionOrigin,
                                                          ProjOrigin::Subscription);

        transactionTxtSMA      = TransactionTxt::construct(LedgerTransTxt::SMASubscription,
                                                 CompanyInfo::languageId(),
                                                 _transDate,
                                                 projTrans.transId(),
                                                 voucherSMA);

        ledgerVoucherSMA       = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                           SysModule::Project,
                                                           ProjParameters::numRefProjPeriodVoucher().numberSequenceTable().NumberSequence,
                                                           TransactionLogType::SMASubscription,
                                                           transactionTxtSMA.txt());

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherSMA,
                                                              _transDate,
                                                              SysModule::Project,
                                                              LedgerTransType::Project);

        ledgerVoucherSMA.addVoucher(ledgerVoucherObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source line record for the current journal line.
    /// </summary>
    /// <returns>
    /// A source line record.
    /// </returns>
    protected Common sourceLine()
    {
        Common ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source header record for the journal header.
    /// </summary>
    /// <returns>
    /// A source header record.
    /// </returns>
    protected Common sourceTable()
    {
        Common ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tradeCalcTax</Name>
				<Source><![CDATA[
    protected Object tradeCalcTax()
    {
        return SalesCalcTax::construct(this.parmJournalTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>TransTxt</c> object.
    /// </summary>
    /// <returns>
    /// An instance of the <c>TransTxt</c> object.
    /// </returns>
    protected TransTxt transactionLogTxt()
    {
        return "@SYS50149";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    protected TransactionLogType transactionLogType()
    {
        return TransactionLogType::ProjInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitCostTrans</Name>
				<Source><![CDATA[
    private void transitCostTrans()
    {
        TaxEngineProjCostJourHeader     jourHeader;
        TaxEngineProjCostTransHeader    transHeader;
        TransitDocumentManager_IN       transitManager;
        ProjInvoiceCost                 projInvoiceCostTransitTo;
        ProjProposalCost                ProjProposalCostTransitFrom;
        boolean                         isHeaderTransited = false;

        while select ProjProposalCostTransitFrom
            where ProjProposalCostTransitFrom.ProposalId == projProposalJour.ProposalId
            join projInvoiceCostTransitTo
                where projInvoiceCostTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                    && projInvoiceCostTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                    && projInvoiceCostTransitTo.TransId == ProjProposalCostTransitFrom.TransId
        {
            if (!isHeaderTransited)
            {
                transHeader = TaxEngineProjCostTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                jourHeader  = TaxEngineProjCostJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(transHeader, jourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalCostTransitFrom, projInvoiceCostTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitEmplTrans</Name>
				<Source><![CDATA[
    private void transitEmplTrans()
    {
        TaxEngineProjEmplJourHeader     jourHeader;
        TaxEngineProjEmplTransHeader    transHeader;
        TransitDocumentManager_IN       transitManager;
        ProjInvoiceEmpl                 projInvoiceEmplTransitTo;
        ProjProposalEmpl                ProjProposalEmplTransitFrom;
        boolean                         isHeaderTransited = false;

        while select ProjProposalEmplTransitFrom
            where ProjProposalEmplTransitFrom.ProposalId == projProposalJour.ProposalId
            join projInvoiceEmplTransitTo
                where projInvoiceEmplTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                    && projInvoiceEmplTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                    && projInvoiceEmplTransitTo.TransId == ProjProposalEmplTransitFrom.TransId
        {
            if (!isHeaderTransited)
            {
                transHeader  = TaxEngineProjEmplTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                jourHeader   = TaxEngineProjEmplJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(transHeader, jourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalEmplTransitFrom, projInvoiceEmplTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitItemSOTrans</Name>
				<Source><![CDATA[
    private void transitItemSOTrans()
    {
        TaxEngineProjItemSOJourHeader   jourHeader;
        TaxEngineProjItemSOTransHeader  transHeader;
        TransitDocumentManager_IN       transitManager;
        ProjInvoiceItem                 projInvoiceItemTransitTo;
        ProjProposalItem                ProjProposalItemTransitFrom;
        boolean                         isHeaderTransited = false;

        while select ProjProposalItemTransitFrom
            where ProjProposalItemTransitFrom.ProposalId == projProposalJour.ProposalId
            && ProjProposalItemTransitFrom.ItemType == ProjItemType::SalesOrder
                join projInvoiceItemTransitTo
                    where projInvoiceItemTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                        && projInvoiceItemTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                        && projInvoiceItemTransitTo.ProjTransId == ProjProposalItemTransitFrom.ProjTransId
        {
            if (!isHeaderTransited)
            {
                transHeader  = TaxEngineProjItemSOTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                jourHeader   = TaxEngineProjItemSOJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(transHeader, jourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalItemTransitFrom, projInvoiceItemTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitItemTrans</Name>
				<Source><![CDATA[
    private void transitItemTrans()
    {
        TaxEngineProjItemJourHeader     jourHeader;
        TaxEngineProjItemTransHeader    transHeader;
        TransitDocumentManager_IN       transitManager;
        ProjInvoiceItem                 projInvoiceItemTransitTo;
        ProjProposalItem                ProjProposalItemTransitFrom;
        ITaxableDocument                taxableDocumentItemSO;
        boolean                         isHeaderTransited = false;

        while select ProjProposalItemTransitFrom
            where ProjProposalItemTransitFrom.ProposalId == projProposalJour.ProposalId
                && ProjProposalItemTransitFrom.ItemType != ProjItemType::SalesOrder
            join projInvoiceItemTransitTo
                where projInvoiceItemTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                    && projInvoiceItemTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                    && projInvoiceItemTransitTo.ProjTransId == ProjProposalItemTransitFrom.ProjTransId
        {
            if (!isHeaderTransited)
            {
                transHeader = TaxEngineProjItemTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                jourHeader  = TaxEngineProjItemJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(transHeader, jourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalItemTransitFrom, projInvoiceItemTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitOnAccTrans</Name>
				<Source><![CDATA[
    private void transitOnAccTrans()
    {
        TaxEngineProjOnAcctJourHeader   onAccJourHeader;
        TaxEngineProjOnAcctTransHeader  onAcctransHeader;
        TransitDocumentManager_IN       transitManager;
        ProjInvoiceOnAcc                projInvoiceOnAccTransitTo;
        ProjProposalOnAcc               ProjProposalOnAccTransitFrom;
        boolean                         isHeaderTransited = false;

        while select ProjProposalOnAccTransitFrom
            where ProjProposalOnAccTransitFrom.ProposalId == projProposalJour.ProposalId
            join projInvoiceOnAccTransitTo
                where projInvoiceOnAccTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                    && projInvoiceOnAccTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                    && projInvoiceOnAccTransitTo.TransId == ProjProposalOnAccTransitFrom.TransId
        {
            if (!isHeaderTransited)
            {
                onAccTransHeader = TaxEngineProjOnAcctTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                onAccJourHeader  = TaxEngineProjOnAcctJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(onAcctransHeader, onAccJourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalOnAccTransitFrom, projInvoiceOnAccTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitProjectTrans</Name>
				<Source><![CDATA[
    private void transitProjectTrans()
    {
        this.transitOnAccTrans();
        this.transitRevenueTrans();
        this.transitCostTrans();
        this.transitItemTrans();
        this.transitEmplTrans();
        this.transitItemSOTrans();
        this.transitRevenueTransSub();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitRevenueTrans</Name>
				<Source><![CDATA[
    private void transitRevenueTrans()
    {
        TaxEngineProjRevenueJourHeader      jourHeader;
        TaxEngineProjRevenueTransHeader     transHeader;
        TransitDocumentManager_IN           transitManager;
        ProjInvoiceRevenue                  projInvoiceRevenueTransitTo;
        ProjProposalRevenue                 ProjProposalRevenueTransitFrom;
        ProjRevenueTrans                    projRevenueTrans;
        boolean                             isHeaderTransited = false;

        while select ProjProposalRevenueTransitFrom
            where ProjProposalRevenueTransitFrom.ProposalId == projProposalJour.ProposalId
            join projInvoiceRevenueTransitTo
                where projInvoiceRevenueTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                    && projInvoiceRevenueTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                    && projInvoiceRevenueTransitTo.TransId == ProjProposalRevenueTransitFrom.TransId
            join projRevenueTrans
                where projRevenueTrans.TransId == ProjProposalRevenueTransitFrom.TransId
                    && ProjProposalRevenueTransitFrom.ProposalId == projProposalJour.ProposalId
                    && (projRevenueTrans.TransactionOrigin == ProjOrigin::FeeJournal
                        || ProjRevenueTrans.TransactionOrigin == ProjOrigin::ProjAdvancedJournal)
        {
            if (!isHeaderTransited)
            {
                transHeader = TaxEngineProjRevenueTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                jourHeader  = TaxEngineProjRevenueJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(transHeader, jourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalRevenueTransitFrom, projInvoiceRevenueTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitRevenueTransSub</Name>
				<Source><![CDATA[
    private void transitRevenueTransSub()
    {
        TaxEngineProjRevenueSubJourHeader   jourHeader;
        TaxEngineProjRevenueSubTransHeader  transHeader;
        TransitDocumentManager_IN           transitManager;
        ProjInvoiceRevenue                  projInvoiceRevenueTransitTo;
        ProjProposalRevenue                 ProjProposalRevenueTransitFrom;
        ProjRevenueTrans                    projRevenueTrans;
        boolean                             isHeaderTransited = false;

        while select ProjProposalRevenueTransitFrom
            where ProjProposalRevenueTransitFrom.ProposalId == projProposalJour.ProposalId
            join projInvoiceRevenueTransitTo
                where projInvoiceRevenueTransitTo.InvoiceDate == projProposalJour.InvoiceDate
                    && projInvoiceRevenueTransitTo.ProjInvoiceId == projProposalJour.ProjInvoiceId
                    && projInvoiceRevenueTransitTo.TransId == ProjProposalRevenueTransitFrom.TransId
            join projRevenueTrans
                where projRevenueTrans.TransId == ProjProposalRevenueTransitFrom.TransId
                    && ProjProposalRevenueTransitFrom.ProposalId == projProposalJour.ProposalId
                    && projRevenueTrans.TransactionOrigin        == ProjOrigin::Subscription
        {
            if (!isHeaderTransited)
            {
                transHeader  = TaxEngineProjRevenueSubTransHeader::findOrCreateByProjProposalJour(projProposalJour);
                jourHeader   = TaxEngineProjRevenueSubJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);

                transitManager = TransitDocumentManager_IN::newManager();
                transitManager.transit(transHeader, jourHeader);
                isHeaderTransited = true;
            }
            transitManager.transit(projProposalRevenueTransitFrom, projInvoiceRevenueTransitTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction Date.
    /// </summary>
    /// <returns>
    /// A transaction date.
    /// </returns>
    protected TransDate updateDate()
    {
        return projInvoiceJour.InvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDueDate_ES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the due date for the <c>projInvoiceJour</c> record.
    /// </summary>
    /// <param name="_dueDate">
    /// The due date.
    /// </param>
    protected void updateDueDate_ES(TransDate _dueDate)
    {
        if (!projInvoiceJour.DueDate ||
           (_dueDate && _dueDate < projInvoiceJour.DueDate))
        {
            ProjProposalItem projProposalItem_SalesOrder;
            select firstonly RecId from projProposalItem_SalesOrder
            where projProposalItem_SalesOrder.ProposalId == projProposalJour.ProposalId &&
                projProposalItem_SalesOrder.ItemType == ProjItemType::SalesOrder;

            if (projProposalItem_SalesOrder.RecId != 0)
            {
                ProjInvoiceJour projInvoiceJourLoc = ProjInvoiceJour::findRecId(projInvoiceJour.RecId, true);
                projInvoiceJourLoc.DueDate = _dueDate;
                projInvoiceJourLoc.update();
            }
            else
            {
                projInvoiceJour.DueDate = _dueDate;
                projInvoiceJour.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal header.
    /// </summary>
    protected void updateJournalTable()
    {
        projInvoiceJour.update();
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            projInvoiceJour.reread();
        }
        this.insertCreditInvoicingJour(projInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjInvoiceTransTaxWithholdGroup</Name>
				<Source><![CDATA[
    private void updateProjInvoiceTransTaxWithholdGroup()
    {
        ProjInvoiceTransTaxWithholdGroups_BR projInvoiceTransTaxWithholdGroups;
        TaxWithholdGroup taxWithholdGroup;

        taxWithholdGroup = CustTable::find(projInvoiceJour.InvoiceAccount).TaxWithholdGroup_TH;

        update_recordset projInvoiceTransTaxWithholdGroups
            setting TaxWithholdGroup = taxWithholdGroup
            where projInvoiceTransTaxWithholdGroups.ProjInvoiceJour == projInvoiceJour.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the source table for the journal header.
    /// </summary>
    protected void updateSourceTable()
    {
        // <GBR>
        ProjProposalJour projProposalJourlocal;

        // The code is used for Debit note feature cration, cacellation and Invoice cancellation.
        if (BrazilParameters::isEnabled())
        {
            select * from tmpInvoiceCancel
                where tmpInvoiceCancel.ProposalId == projProposalJour.ProposalId;

            if (ProjParameters::find().EnableInvoiceProposalWorkflow == NoYes::No)
            {
                if (tmpInvoiceCancel.RecId)
                {
                    ttsbegin;

                    select forupdate projProposalJourlocal
                        where projProposalJourlocal.ProposalId == tmpInvoiceCancel.RefProposalId;

                    if (projProposalJourlocal.LineProperty == ProjLinePropertyCode::DebitNote_BR)
                    {
                        projProposalJourlocal.LineProperty = ProjLinePropertyCode::DebitNoteCanceled_BR;
                    }
                    else
                    {
                        projProposalJourlocal.LineProperty = ProjLinePropertyCode::InvoiceCanceled_BR;
                    }
                    projProposalJourlocal.update();

                    ttscommit;

                    if (projProposalJour.LineProperty == ProjLinePropertyCode::DebitNoteCanceled_BR ||
                        projProposalJour.InvoiceType == ProjInvoiceType::DebitNote_BR)
                    {
                        info(strFmt("@GLS510033", projProposalJourlocal.ProjInvoiceId));
                    }
                    else
                    {
                        info(strFmt("@GLS510003", projProposalJourlocal.ProjInvoiceId));
                    }
                }
            }

            if (projProposalJour.InvoiceType == ProjInvoiceType::DebitNote_BR)
            {
                projProposalJour.LineProperty        = ProjLinePropertyCode::DebitNote_BR;
            }
            else
            {
                projProposalJour.LineProperty        = ProjLinePropertyCode::Invoiced;
            }
        }
        else
        {
            // </GBR>
            projProposalJour.LineProperty        = ProjLinePropertyCode::Invoiced;
            // <GBR>
        }
        // </GBR>
        projProposalJour.LedgerVoucher       = projInvoiceJour.LedgerVoucher;
        projProposalJour.SalesOrderbalance   = projInvoiceJour.SalesOrderbalance;
        projProposalJour.update();

    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the <c>MainAccount</c> record that is part of the specified ledger dimension.
    /// </summary>
    /// <param name = "_projTrans">
    ///     An instance of <c>ProjTrans</c> class.
    /// </param>
    /// <returns>
    ///     The main account.
    /// </returns>
    [Wrappable(true)]
    protected final MainAccount getPostingMainAccount(ProjTrans _projTrans)
    {
        MainAccount mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(
                                            ProjPosting::getLedgerDimension(ProjAccountType::RevenueAccount,
                                            _projTrans.projId(),
                                            _projTrans.categoryId(),
                                            _projTrans.fundingSource(),
                                            false,
                                            true,
                                            _projTrans.taxGroup()));

        return mainAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoTax</Name>
				<Source><![CDATA[
    private void validateNoTax(ProjTrans projTrans)
    {
        if (taxParameters.ValidateTaxCode)
        {
            postingMainAccount = this.getPostingMainAccount(projTrans);

            if (!Tax::checkNoTax(postingMainAccount,
                                    projTrans.taxGroup(),
                                    projTrans.taxItemGroup()))
            {
                throw error("@SYS21533");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxExport_CN</Name>
				<Source><![CDATA[
    private boolean validateTaxExport_CN()
    {
        TaxValidateForTaxIntegration_CN    taxValidateForTaxIntegration;
        boolean returnValue;

        returnValue = true;
        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            taxValidateForTaxIntegration = TaxValidateForTaxIntegration_CN::construct(projProposalJour);
            returnValue = taxValidateForTaxIntegration.validate();
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProjInvoiceJournalPost construct()
    {
        return new ProjInvoiceJournalPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePost_MY</Name>
				<Source><![CDATA[
    private void checkBeforePost_MY()
    {
        // <GMY>
        AmountCur totalAmount = projProposalTotals.projInvoiceTotalAmount();

        if (totalAmount < 0 || (totalAmount >= 0 && projProposalJour.hasLinesWithReference_MY()))
        {
            if (!projProposalJour.ReasonTableRef)
            {
                throw error("@SYP4860740");
            }
        }
        // </GMY>
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return ledger Voucher Object accounting date and the vouchre information.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    /// Reference of LedgerVoucherObject.
    /// </param>
    /// <returns>
    /// Return Accounting date and voucher.
    ///</returns>
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        container ret;

        ret = [_ledgerVoucherObject.parmAccountingDate(), _ledgerVoucherObject.parmSubLedgerVoucher()];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditInvoicingJour</Name>
				<Source><![CDATA[
    protected void insertCreditInvoicingJour(ProjInvoiceJour _projInvoiceJour)
    {
        CustVendCreditInvoicingTable    custVendCreditInvoicingTable;
        CustVendCreditInvoicingJour     custVendCreditInvoicingJour;
        ProjInvoiceEmpl                 projInvoiceEmpl;
        ProjInvoiceEmplDetail           projInvoiceEmplDetail;

        select firstonly TableId, RefRecId from projInvoiceEmplDetail
            exists join projInvoiceEmpl
                where projInvoiceEmpl.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                    && projInvoiceEmpl.InvoiceDate == _projInvoiceJour.InvoiceDate
                    && projInvoiceEmpl.RecId == projInvoiceEmplDetail.InvoiceRefRecId;
        if (projInvoiceEmplDetail)
        {
            custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(projInvoiceEmplDetail.TableId,
                                                                                projInvoiceEmplDetail.RefRecId,
                                                                                true);
        }

        if (!custVendCreditInvoicingTable)
        {
            ProjInvoiceCost                 projInvoiceCost;
            ProjInvoiceCostDetail           projInvoiceCostDetail;

            select firstonly TableId, RefRecId from projInvoiceCostDetail
                exists join projInvoiceCost
                    where projInvoiceCost.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                        && projInvoiceCost.InvoiceDate == _projInvoiceJour.InvoiceDate
                        && projInvoiceCost.RecId == projInvoiceCostDetail.InvoiceRefRecId;
            if (projInvoiceCostDetail)
            {
                custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(projInvoiceCostDetail.TableId,
                                                                                projInvoiceCostDetail.RefRecId,
                                                                                true);
            }
        }

        if (!custVendCreditInvoicingTable)
        {
            ProjInvoiceItem                 projInvoiceItem;
            ProjInvoiceItemDetail           projInvoiceItemDetail;

            select firstonly TableId, RefRecId from projInvoiceItemDetail
                exists join projInvoiceItem
                    where projInvoiceItem.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                        && projInvoiceItem.InvoiceDate == _projInvoiceJour.InvoiceDate
                        && projInvoiceItem.RecId == projInvoiceItemDetail.InvoiceRefRecId;
            if (projInvoiceItemDetail)
            {
                custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(projInvoiceItemDetail.TableId,
                                                                                projInvoiceItemDetail.RefRecId,
                                                                                true);
            }
        }

        if (!custVendCreditInvoicingTable)
        {
            ProjInvoiceRevenue              projInvoiceRevenue;
            ProjInvoiceRevenueDetail        projInvoiceRevenueDetail;

            select firstonly TableId, RefRecId from projInvoiceRevenueDetail
                exists join projInvoiceRevenue
                    where projInvoiceRevenue.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                        && projInvoiceRevenue.InvoiceDate == _projInvoiceJour.InvoiceDate
                        && projInvoiceRevenue.RecId == projInvoiceRevenueDetail.InvoiceRefRecId;
            if (projInvoiceRevenueDetail)
            {
                custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(projInvoiceRevenueDetail.TableId,
                                                                                projInvoiceRevenueDetail.RefRecId,
                                                                                true);
            }
        }

        if (!custVendCreditInvoicingTable)
        {
            ProjInvoiceOnAcc                projInvoiceOnAcc;
            ProjInvoiceOnAccDetail          projInvoiceOnAccDetail;

            select firstonly TableId, RefRecId from projInvoiceOnAccDetail
                exists join projInvoiceOnAcc
                    where projInvoiceOnAcc.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                        && projInvoiceOnAcc.InvoiceDate == _projInvoiceJour.InvoiceDate
                        && projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId;
            if (projInvoiceOnAccDetail)
            {
                custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(projInvoiceOnAccDetail.TableId,
                                                                            projInvoiceOnAccDetail.RefRecId,
                                                                            true);
            }
        }

        if (custVendCreditInvoicingTable)
        {
            custVendCreditInvoicingJour.insertFromCustVendCreditInvoicingTable(custVendCreditInvoicingTable,
                                                                            projInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post current tax doucment.
    /// </summary>
    /// <param name="_checkLedgerVoucher">
    /// A Boolean value that indicates whether checking the LedgerVoucher; optional.
    /// </param>
    public void postTaxDocument(boolean _checkLedgerVoucher = true)
    {
        List taskList = new List(Types::AnyType);
        System.AggregateException aggregateException;
        System.Exception innerException;
        TableId transactionTableId;
        RecId transactionRecId;

        if (taxDocumentLedgerVoucherMap)
        {
            MapEnumerator mapEnumerator = taxDocumentLedgerVoucherMap.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                [transactionTableId, transactionRecId] = mapEnumerator.currentKey();

                DictTable dictTable = new DictTable(transactionTableId);
                Common common = dictTable.makeRecord();

                select firstonly common
                    where common.RecId == transactionRecId;

                if (common.RecId)
                {
                    TaxBusinessService::postTaxDocument(
                        TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(common)),
                        mapEnumerator.currentValue(),
                        NoYes::Yes,
                        taskList);
                }
            }
        }

        try
        {
            if (taskList.elements() > 0)
            {
                var taskArray = new System.Threading.Tasks.Task[taskList.elements()]();
                ListEnumerator enumerator = taskList.getEnumerator();
                var arrayIndex = 0;

                while (enumerator.moveNext())
                {
                    taskArray.setValue(enumerator.current(), arrayIndex);
                    arrayIndex++;
                }

                System.Threading.Tasks.Task::WaitAll(taskArray);
            }
        }
        catch(aggregateException)
        {
            throw error (innerException.Message);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (TaxSolutionScopeParameters::find().TaxDocumentPostingMode == TaxDocumentPostingMode::Asynchronous)
            {
                TaxEnginePostingProcessor::updateTaxDocExtensionForProjForAsync(projProposalJour.RecId);
            }
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesFromFormletterParmDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///  A delegate that is called in the createJournal mwthod before jornal header is inserted.
    /// </summary>
    /// <param name = "_formLetter">
    /// An instance of <c>FormLetter</c> class.
    /// </param>
    /// <param name = "_salesFormLetter">
    /// An instance of <c>SalesFormLetter_InvoiceProject</c> class.
    /// </param>
    delegate void salesFromFormletterParmDelegate(
        FormLetter _formLetter,
        SalesFormLetter_InvoiceProject _salesFormLetter)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountingAndReportingCurrencyBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets accounting and reporting currency amounts of original transaction for credit note transaction.
    /// </summary>
    /// <param name = "_projVoucher">
    /// An instance of <c>CustVoucherProject</c> class.
    /// </param>
    private void setAccountingAndReportingCurrencyBalances(CustVoucherProject _projVoucher)
    {
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        if (ledgerVoucherObject)
        {
            _projVoucher.parmAmountMST(-ledgerVoucherObject.parmTotalAccountingCurrencyBalance());
            _projVoucher.parmReportingCurrencyAmount(-ledgerVoucherObject.parmTotalReportingCurrencyBalance());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjCostLedgerStatus</Name>
				<Source><![CDATA[
    protected boolean validateProjCostLedgerStatus(ProjCostTransCost _projCostTransCost)
    {
        return _projCostTransCost.LedgerStatusCost != ProjLedgerStatus::Operations;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>