<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanConversionCostUpd</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    This class handles the update of the conversion cost for Lean scenarios.It adds direct
///    manufacturing transactions to ledger.It also adds indirect cost transactions to ledger.Plays a role
///    when clearing material issues WIP and post indirect cost for not updated materials.
/// </summary>
public class LeanConversionCostUpd
{
    // Global variables
    CurrencyCode                            currencyCode;

    // Caller parameter
    LedgerVoucher                           ledgerVoucher;
    LeanProductionFlowReference             productionFlowReference;
    LeanCostingFacadeBase                   leanCostingFacade;

    Map                                     inventSiteConsumptionMap;      // Holds for each site the consumption for which indirect cost should be calculated
    Map                                     inventSiteFinishedMap;         // Holds for each site the finished goods for which indirect cost should be calculated
    Map                                     inventSiteRouteMap;            // Holds for each site the route consumption for which indirect cost should be calculated
    Map                                     inventSiteServiceMap;          // Holds for each site the outsourced services consumption for which indirect cost should be calculated

    KanbanJob                               kanbanJob;
    // <GEERU>
    #ISOCountryRegionCodes
    boolean                                 countryRegion_RU;
    // </GEERU>
    boolean                                 reversal;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addDirectManufacturingConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a direct manufacturing cost <c>ProdRouteTrans</c> record to the corresponding map based on the
    ///    site.
    /// </summary>
    /// <param name="_inventSiteId">
    ///    The site ID that is used to get the corresponding map that will be used for calculating indirect
    ///    cost for direct manufacturing.
    /// </param>
    /// <param name="_prodRouteTrans">
    ///    The direct manufacturing cost record.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addDirectManufacturingConsumption(
        InventSiteId        _inventSiteId,
        ProdRouteTrans      _prodRouteTrans
        )
    {
        this.addProdRouteTransConsumption(_inventSiteId, _prodRouteTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectManufacturingToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds direct manufacturing cost to General Ledger.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addDirectManufacturingToLedger()
    {
        ProdRouteTrans      prodRouteTrans;

        while select sum(Amount) from prodRouteTrans
            group by DefaultDimension,
                     PostingWIPIssue, wipIssueLedgerDimension,
                     PostingWIPValuation, wipValuationLedgerDimension,
                     PostingCalcIssue, IssueLedgerDimension,
                     PostingCalcIssueOffset, IssueOffsetLedgerDimension
            where prodRouteTrans.VoucherWIP      == ledgerVoucher.lastVoucher()
               && prodRouteTrans.DateWIP         == ledgerVoucher.lastTransDate()
               && prodRouteTrans.WrkCtrId
        {
            CostAmount routeCostAmount = CurrencyExchangeHelper::amount(prodRouteTrans.Amount);

            this.addLedger(prodRouteTrans.PostingWIPValuation,
                           prodRouteTrans.wipValuationLedgerDimension,
                           routeCostAmount,
                           reversal);

            this.addLedger(prodRouteTrans.PostingWIPIssue,
                           prodRouteTrans.wipIssueLedgerDimension,
                           -routeCostAmount,
                           reversal);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectMaterialConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds direct material consumption to the internal map for calculating indirect cost on it.
    /// </summary>
    /// <param name="_inventItemPrice">
    /// The item price used for the consumption.
    /// </param>
    /// <param name="_qty">
    /// The quantity consumed.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void addDirectMaterialConsumption(
        InventItemPrice        _inventItemPrice,
        Qty                    _qty
        )
    {
        InventSiteId                    inventSiteId = _inventItemPrice.inventDim().InventSiteId;
        InventItemCostGroupRollupList   totalCostGroupRollupList,
                                        currentCostGroupRollupList;
        Map                             itemCostGroupRollupListMap;               // Holds for each item the rollup list and total qty
        CostBreakdownInsertionRule      costBreakdownInsertionRule = CostBreakdownInsertionRule::construct();

        if (!inventSiteConsumptionMap)
        {
            inventSiteConsumptionMap = new Map(Types::String, Types::Class);
        }

        // Retrieve the map with the items and rollups
        if (inventSiteConsumptionMap.exists(inventSiteId))
        {
            itemCostGroupRollupListMap = inventSiteConsumptionMap.lookup(inventSiteId);
        }
        else
        {
            itemCostGroupRollupListMap = new Map(Types::String, Types::Class);
        }

        costBreakdownInsertionRule.parmItemId(_inventItemPrice.ItemId);
        if (costBreakdownInsertionRule.mustInsertCostBreakdown())
        {
            currentCostGroupRollupList = InventItemCostGroupRollupList::newStdCostList(_inventItemPrice.RecId, _qty);
        }
        else
        {
            currentCostGroupRollupList = InventItemCostGroupRollupList::newStdCostListWithoutBreakdown(_inventItemPrice.RecId, _qty);
        }

        // Now check if for this item an entry already exist
        if (itemCostGroupRollupListMap.exists(_inventItemPrice.ItemId))
        {
            // Item has been seen before, get the list
            totalCostGroupRollupList = itemCostGroupRollupListMap.lookup(_inventItemPrice.ItemId);

            // Merge the two lists
            totalCostGroupRollupList.summarizeList(currentCostGroupRollupList);
        }
        else
        {
            totalCostGroupRollupList = currentCostGroupRollupList;
        }

        // Save the consumption for this item
        itemCostGroupRollupListMap.insert(_inventItemPrice.ItemId, totalCostGroupRollupList);

        // Now add the consumption for this site
        inventSiteConsumptionMap.insert(inventSiteId, itemCostGroupRollupListMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectMaterialFinished</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void addDirectMaterialFinished(
        InventItemPrice        _inventItemPrice,
        Qty                    _qty
        )
    {
        InventSiteId    inventSiteId = _inventItemPrice.inventDim().InventSiteId;
        Qty             totalQty;
        Map             itemQtyMap;                  // Holds for each item the total qty

        if (!inventSiteFinishedMap)
        {
            inventSiteFinishedMap = new Map(Types::String, Types::Class);
        }

        // Retrieve the map with the items and rollups
        if (inventSiteFinishedMap.exists(inventSiteId))
        {
            itemQtyMap = inventSiteFinishedMap.lookup(inventSiteId);
        }
        else
        {
            itemQtyMap = new Map(Types::String, Types::Real);
        }

        // Now check if for this item an entry already exist
        if (itemQtyMap.exists(_inventItemPrice.ItemId))
        {
            // Item has been seen before, get the qty
            totalQty = itemQtyMap.lookup(_inventItemPrice.ItemId);
            totalQty += _qty;
        }
        else
        {
            totalQty = _qty;
        }

        // Save the finished qty for this item
        itemQtyMap.insert(_inventItemPrice.ItemId, totalQty);

        // Now add the consumption for this site
        inventSiteFinishedMap.insert(inventSiteId, itemQtyMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectOutsourcing</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void addDirectOutsourcing(
        LeanProductionFlowReferenceRefRecId _productionFlowReferanceRecId,
        LeanServiceItemId                   _itemId,
        InventDimId                         _inventDimId,
        Qty                                 _quantity,
        Price                               _price,
        TableId                             _originId,
        RefRecId                            _originRefRecId,
        DimensionDefault                    _defaultDimension,
        SourceDocumentLineRefRecId          _sourceDocumentLineRefRecId)
    {
        InventSiteId inventSiteId = InventDim::find(_inventDimId).InventSiteId;

        LeanCostOutsourcing leanCostOutsourcing = this.getLeanCostOutsourcing(_originId);
        leanCostOutsourcing.parmProductionFlowReferenceRecId(_productionFlowReferanceRecId);
        leanCostOutsourcing.parmServiceItemId(_itemId);
        leanCostOutsourcing.parmServiceInventDimId(_inventDimId);
        leanCostOutsourcing.parmQuantity(_quantity);
        leanCostOutsourcing.parmPrice(_price);
        leanCostOutsourcing.parmOriginRefRecId(_originRefRecId);
        leanCostOutsourcing.parmDefaultDimension(_defaultDimension);
        leanCostOutsourcing.parmSourceDocumentLineRefRecId(_sourceDocumentLineRefRecId);

        if (leanCostOutsourcing.mustRecordCost())
        {
            this.addDirectOutsourcingToInternalMap(inventSiteId, leanCostOutsourcing);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectOutsourcingToInternalMap</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addDirectOutsourcingToInternalMap(
        InventSiteId        _inventSiteId,
        LeanCostOutsourcing _leanCostOutsourcing)
    {
        List                directOursourcingWIPList;

        if (!inventSiteServiceMap)
        {
            inventSiteServiceMap = new Map(Types::String, Types::Class);
        }

        if (inventSiteServiceMap.exists(_inventSiteId))
        {
            directOursourcingWIPList = inventSiteServiceMap.lookup(_inventSiteId);
        }
        else
        {
            directOursourcingWIPList = new List(Types::Class);
        }

        directOursourcingWIPList.addEnd(_leanCostOutsourcing);

        inventSiteServiceMap.insert(_inventSiteId, directOursourcingWIPList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectOutsourcingToLedger</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addDirectOutsourcingToLedger()
    {
        // Direct outsourcing is already posted to ledger by the distributions
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new ledger posting.
    /// </summary>
    /// <param name="_ledgerPostingType">
    ///    The posting type that is used for posting.
    /// </param>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension that is used for posting.
    /// </param>
    /// <param name="_costAmount">
    ///    The amount to post.
    /// </param>
    /// <param name="_skipValidation">
    ///    Skip dimension validation.
    /// </param>
    /// <remarks>
    ///    Merges the ledger dimension default account and the default dimension into a ledger dimension
    ///    account and uses the merged account for posting.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    An error when posting.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addLedger(
        LedgerPostingType             _ledgerPostingType,
        LedgerDimensionAccount        _ledgerDimension,
        CostAmount                    _costAmount,
        boolean                       _skipValidation
        )
    {
        LedgerVoucherObject      ledgerVoucherObject      = ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper   currencyExchHelper       = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::current()),
                                                                                                    ledgerVoucherObject.parmAccountingDate());
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                  ledgerVoucherObject,
                                                                  _ledgerPostingType,
                                                                  _ledgerDimension,
                                                                  currencyCode,
                                                                  _costAmount,
                                                                  currencyExchHelper);

        ledgerVoucherTransObject.parmSkipDimensionValidation(_skipValidation);

        if (!ledgerVoucher.addTrans(ledgerVoucherTransObject))
        {
            throw error("@SYS21533");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProdRouteTransConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a <c>ProdRouteTrans</c> record to the internal map for calculating indirect cost when
    ///    finishing.
    /// </summary>
    /// <param name="_inventSiteId">
    ///    The invent site ID.
    /// </param>
    /// <param name="_prodRouteTrans">
    ///    The <c>ProdRouteTrans</c> record
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void addProdRouteTransConsumption(
        InventSiteId        _inventSiteId,
        ProdRouteTrans      _prodRouteTrans
        )
    {
        RecordSortedList        totalRouteTransList;
        Map                     siteTransListPerProductionFlowMap;
        Map                     jobTypeRouteTransListMap;               // Holds for each jobType the route trans list

        PlanName productionFlowName = _prodRouteTrans.TransRefId;

        if (!inventSiteRouteMap)
        {
            inventSiteRouteMap = new Map(Types::String, Types::Class);
        }

        // Retrieve the map with the items and rollups
        if (inventSiteRouteMap.exists(_inventSiteId))
        {
            siteTransListPerProductionFlowMap = inventSiteRouteMap.lookup(_inventSiteId);
        }
        else
        {
            siteTransListPerProductionFlowMap = new Map(Types::String, Types::Class);
        }

        if (siteTransListPerProductionFlowMap.exists(productionFlowName))
        {
            jobTypeRouteTransListMap = siteTransListPerProductionFlowMap.lookup(productionFlowName);
        }
        else
        {
            jobTypeRouteTransListMap = new Map(Types::Enum, Types::Class);
        }

        // Now check if for this item an entry already exist
        if (jobTypeRouteTransListMap.exists(RouteJobType::Process))
        {
            // Item has been seen before, get the list
            totalRouteTransList = jobTypeRouteTransListMap.lookup(RouteJobType::Process);
            totalRouteTransList.ins(_prodRouteTrans, true);

            // Save the consumption for this item
            jobTypeRouteTransListMap.insert(RouteJobType::Process, totalRouteTransList);
        }
        else
        {
            // Item does not exist, add it
            totalRouteTransList = new RecordSortedList(tableNum(ProdRouteTrans));
            totalRouteTransList.sortOrder(fieldNum(ProdRouteTrans, RecId));
            totalRouteTransList.ins(_prodRouteTrans, true);
        }

        jobTypeRouteTransListMap.insert(RouteJobType::Process, totalRouteTransList);

        siteTransListPerProductionFlowMap.insert(productionFlowName, jobTypeRouteTransListMap);

        // Now add the consumption for this site
        inventSiteRouteMap.insert(_inventSiteId, siteTransListPerProductionFlowMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOnDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Controls whether the validation of the <c>LedgerVoucher</c> date is performed including the date,
    ///    or just before the date.
    /// </summary>
    /// <returns>
    ///    true if the date is included; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean checkOnDate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the transaction date of the <c>LedgerVoucher</c> object.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    ///    Transactions are not allowed for the production flow because an end of period backflush costing
    ///    calculation has already been run.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void checkTransDate()
    {
        if (!LeanCosting::checkOpen(ledgerVoucher.lastTransDate(), this.checkOnDate()))
        {
            throw error(strFmt("@SYS309843", productionFlowReference.planReference().PlanName, date2StrUsr(ledgerVoucher.lastTransDate(), DateFlags::FormatAll)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostUnusedOutsourcing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and posts a new <c>ProdRouteTrans</c> record for the unused subcontracted service item for
    ///    a production flow.
    /// </summary>
    /// <param name="_productionFlowReferenceRecId">
    ///    The production flow reference
    /// </param>
    /// <param name="_serviceItemId">
    ///    The service item ID.
    /// </param>
    /// <param name="_inventDimId">
    ///    The invent dimension ID.
    /// </param>
    /// <param name="_transactionQuantity">
    ///    The quantity of unused service item.
    /// </param>
    /// <param name="_price">
    ///    The price for the unused quantity.
    /// </param>
    /// <returns>
    ///    The new <c>ProdRouteTrans</c> record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ProdRouteTrans createAndPostUnusedOutsourcing(
        RefRecId            _productionFlowReferenceRecId,
        LeanServiceItemId   _serviceItemId,
        InventDimId         _inventDimId,
        UnitQty             _transactionQuantity,
        Price               _price)
    {
        ProdRouteTrans          prodRouteTrans;

        ProdGroup prodGroup = leanCostingFacade.getProductionGroup(_productionFlowReferenceRecId);

        ttsbegin;

        // Outsourced item
        prodRouteTrans.ServiceItemId = _serviceItemId;
        prodRouteTrans.ServiceInventDimId = _inventDimId;

        prodRouteTrans.DefaultDimension = prodRouteTrans.mergeDimension(
            InventTable::find(_serviceItemId, false).DefaultDimension,
            LeanProductionFlowReference::find(_productionFlowReferenceRecId).planReference().DefaultDimension);

        // Link to production flow
        prodRouteTrans.TransRefId   = LeanProductionFlowReference::find(_productionFlowReferenceRecId).planReference().PlanName;
        prodRouteTrans.TransRefType = ProdTransRefType::ProductionFlow;

        // Default values
        prodRouteTrans.JobType      = RouteJobType::Process;
        prodRouteTrans.TransType    = ProdRouteTransType::Qty;
        prodRouteTrans.ExecutedPct  = 100;

        // Voucher and TransDate
        prodRouteTrans.DateWIP      = ledgerVoucher.lastTransDate();
        prodRouteTrans.VoucherWIP   = ledgerVoucher.lastVoucher();
        prodRouteTrans.Calculated    = NoYes::No;

        // Set the accounts
        prodRouteTrans.PostingWIPValuation = LedgerPostingType::ProdLeanWIPServiceReceipt;
        prodRouteTrans.PostingWIPIssue = LedgerPostingType::ProdLeanWIPServiceClearing;

        if (prodGroup &&
            ((prodGroup.LeanWIPServiceReceiptLedgerDimension && prodGroup.LeanWIPServiceClearingLedgerDimension)
            || ProdParameters::find().ProdPostingType == ProdPostingType::ProdGroup))
        {
            prodRouteTrans.wipValuationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.LeanWIPServiceReceiptLedgerDimension, prodRouteTrans.DefaultDimension);
            prodRouteTrans.wipIssueLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.LeanWIPServiceClearingLedgerDimension, prodRouteTrans.DefaultDimension);
        }
        else
        {
            prodRouteTrans.wipValuationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::ProdLeanWIPServiceReceipt, _serviceItemId)), prodRouteTrans.DefaultDimension);
            prodRouteTrans.wipIssueLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::ProdLeanWIPServiceClearing, _serviceItemId)), prodRouteTrans.DefaultDimension);
        }

        // Cost
        Amount transactionAmount = _transactionQuantity * _price;
        prodRouteTrans.QtyGood = _transactionQuantity;
        prodRouteTrans.Amount = transactionAmount;
        prodRouteTrans.QtyPrice = _price;

        prodRouteTrans.insert();

        // Post transaction
        this.addLedger(prodRouteTrans.PostingWIPValuation,
                    prodRouteTrans.wipValuationLedgerDimension,
                    prodRouteTrans.Amount,
                    true);
        this.addLedger(prodRouteTrans.PostingWIPIssue,
                    prodRouteTrans.wipIssueLedgerDimension,
                    -prodRouteTrans.Amount,
                    true);

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerVoucher.bondLast2_RU();
        }
        // </GEERU>

        // Make sure that indirect cost will be calculated for this transaction
        prodRouteTrans.Amount = -prodRouteTrans.Amount;

        this.addProdRouteTransConsumption(InventDim::find(_inventDimId).InventSiteId, prodRouteTrans);

        ttscommit;

        return prodRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">An inventory account type.</param>
    /// <param name="_itemId">An item Id.</param>
    /// <returns>The built parameter instance.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventPostingItemLedgerDimensionParameters buildItemLedgerDimensionParameter(
        InventAccountType   _inventAccountType,
        ItemId              _itemId)
    {
        return InventPostingItemLedgerDimensionParameters::newFromParameters(_inventAccountType, _itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDirectManufacturingCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates direct manufacturing cost records per site and per finished good.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createDirectManufacturingCost()
    {
        // Basis for the direct manufacturing are the reported finished good qty's
        if (inventSiteFinishedMap && inventSiteFinishedMap.elements() != 0)
        {
            RecordInsertList routeTransInsertList = new RecordInsertList(tableNum(ProdRouteTrans));
            systemSequence systemSequence = new systemSequence();
            systemSequence.suspendRecIds(tableNum(ProdRouteTrans));
            MapEnumerator inventSiteFinishedMapEnum = inventSiteFinishedMap.getEnumerator();

            while (inventSiteFinishedMapEnum.moveNext())
            {
                Map itemQtyMap = inventSiteFinishedMapEnum.currentValue();
                MapEnumerator itemQtyMapEnum = itemQtyMap.getEnumerator();

                while (itemQtyMapEnum.moveNext())
                {
                    this.createProdRouteTrans(routeTransInsertList, systemSequence, itemQtyMapEnum.currentKey(), inventSiteFinishedMapEnum.currentKey(), itemQtyMapEnum.currentValue());
                }
            }

            // insert the transactions to the DB
            routeTransInsertList.insertDatabase();
            systemSequence.removeRecIdSuspension(tableNum(ProdRouteTrans));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIndirectConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates indirect cost for all consumptions in the indirect cost map.
    /// </summary>
    /// <param name="_inventCostProdIndirect">
    /// The <c>InventCostProdIndirect</c> object that calculates indirect cost.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createIndirectConsumption(InventCostProdIndirect _inventCostProdIndirect)
    {
        if (inventSiteConsumptionMap && inventSiteConsumptionMap.elements() != 0)
        {
            MapEnumerator inventSiteIndirectMapEnum = inventSiteConsumptionMap.getEnumerator();

            while (inventSiteIndirectMapEnum.moveNext())
            {
                Map itemCostGroupListMap = inventSiteIndirectMapEnum.currentValue();

                _inventCostProdIndirect.calcInvent(InventCostProdIndirectData_Invent::newConsumptionFromLeanProductionFlow(productionFlowReference.planReference().PlanName,
                                                  leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId),
                                                  inventSiteIndirectMapEnum.currentKey(),
                                                  NoYes::Yes,
                                                  itemCostGroupListMap));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIndirectFinished</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates indirect cost for finished goods in the finished items indirect cost map.
    /// </summary>
    /// <param name="_inventCostProdIndirect">
    ///    The <c>InventCostProdIndirect</c> object that calculates indirect cost.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createIndirectFinished(InventCostProdIndirect _inventCostProdIndirect)
    {
        if (inventSiteFinishedMap && inventSiteFinishedMap.elements() != 0)
        {
            MapEnumerator inventSiteIndirectMapEnum = inventSiteFinishedMap.getEnumerator();

            while (inventSiteIndirectMapEnum.moveNext())
            {
                Map itemQtyMap = inventSiteIndirectMapEnum.currentValue();
                MapEnumerator itemQtyMapEnum = itemQtyMap.getEnumerator();

                while (itemQtyMapEnum.moveNext())
                {
                    _inventCostProdIndirect.calcInvent(InventCostProdIndirectData_Invent::newFinishedFromLeanProductionFlow(productionFlowReference.planReference().PlanName,
                                                      leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId),
                                                      inventSiteIndirectMapEnum.currentKey(),
                                                      NoYes::Yes,
                                                      itemQtyMapEnum.currentKey(),
                                                      itemQtyMapEnum.currentValue()));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIndirectRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates indirect cost for all route transactions in the route indirect cost map.
    /// </summary>
    /// <param name="_inventCostProdIndirect">
    /// The <c>InventCostProdIndirect</c> object that calculates indirect cost.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createIndirectRoute(InventCostProdIndirect _inventCostProdIndirect)
    {
        if (inventSiteRouteMap && inventSiteRouteMap.elements() != 0)
        {
            MapEnumerator inventSiteIndirectMapEnum = inventSiteRouteMap.getEnumerator();

            while (inventSiteIndirectMapEnum.moveNext())
            {
                Map siteTransListPerProductionFlowMap = inventSiteIndirectMapEnum.currentValue();
                MapEnumerator productionFlowMapEnum = siteTransListPerProductionFlowMap.getEnumerator();

                while (productionFlowMapEnum.moveNext())
                {
                    Map jobTypeRouteTransListMap = productionFlowMapEnum.currentValue();

                    _inventCostProdIndirect.calcRoute(
                        InventCostProdIndirectData_Route::newConsumptionFromLeanProductionFlow(
                            productionFlowMapEnum.currentKey(),
                            leanCostingFacade.getDefaultDimensions(LeanProductionFlowReference::findPlanReferenceName(productionFlowMapEnum.currentKey()).RecId),
                            inventSiteIndirectMapEnum.currentKey(),
                            jobTypeRouteTransListMap));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdRouteTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a list of <c>ProdRouteTrans</c> records for each resource consumption reported by the
    ///    <c>LeanCostingFacade.getResourcesUsageKanbanJob</c> method.Updates the indirect cost for the
    ///    records in the list.
    /// </summary>
    /// <param name="_routeTransInsertList">
    ///    The list that will hold the <c>ProdRouteTrans</c> records.
    /// </param>
    /// <param name="_systemSequence">
    ///    The <c>SystemSequence</c> that is used for reserving <c>RecID</c> values for each
    ///    <c>ProdRouteTrans</c> record in the list.
    /// </param>
    /// <param name="_finishedGood">
    ///    The ID of the finished good for which we get the resource consumption.
    /// </param>
    /// <param name="_inventSiteId">
    ///    The site ID.
    /// </param>
    /// <param name="_finishedQty">
    ///    The quantity of finished good produced.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createProdRouteTrans(
        RecordInsertList    _routeTransInsertList,
        systemSequence      _systemSequence,
        ItemId              _finishedGood,
        InventSiteId        _inventSiteId,
        Qty                 _finishedQty
        )
    {
        Map                         resourceUsageMap = leanCostingFacade.getResourcesUsageKanbanJob(kanbanJob);
        MapEnumerator               resourceUsageMapEnum = resourceUsageMap.getEnumerator();

        while (resourceUsageMapEnum.moveNext())
        {
            // init the record
            ProdRouteTrans prodRouteTrans = this.initProdRouteTrans(resourceUsageMapEnum.currentKey(), resourceUsageMapEnum.currentValue() * sign(_finishedQty), _inventSiteId);

            prodRouteTrans.RecId = _systemSequence.reserveValues(1, tableNum(ProdRouteTrans));
            _routeTransInsertList.add(prodRouteTrans);

            // Now update the indirect cost for the routes
            this.addDirectManufacturingConsumption(_inventSiteId, prodRouteTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLeanSubcontractingPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Triggers direct and indirect outsourcing cost creation.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void endLeanSubcontractingPosting()
    {
        this.processDirectOutsourcing();

        this.processIndirect();

        this.reset();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLeanCostOutsourcing</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected LeanCostOutsourcing getLeanCostOutsourcing(TableId    _originId)
    {
        return LeanCostOutsourcing::constructForOrigin(
            _originId,
            this,
            leanCostingFacade,
            ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdRouteTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new <c>ProdRouteTrans</c> record.
    /// </summary>
    /// <param name="_resource">
    ///    The resource that is used for conversion cost.
    /// </param>
    /// <param name="_hours">
    ///    The hours consumed.
    /// </param>
    /// <param name="_inventSiteId">
    ///    The site ID.
    /// </param>
    /// <returns>
    ///    An initialized <c>ProdRouteTrans</c> record for the conversion cost.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected ProdRouteTrans initProdRouteTrans(
        BOMCalcResource             _resource,
        Hours                       _hours,
        InventSiteId                _inventSiteId
        )
    {
        ProdRouteTrans          prodRouteTrans;
        ProdGroup               prodGroup         = leanCostingFacade.getProductionGroup(productionFlowReference.RecId);
        WrkCtrTable             wrkCtrTable       = WrkCtrTable::find(_resource);
        RouteCostCategory       routeCostCategory = RouteCostCategory::find(wrkCtrTable.ProcessCategoryId);

        prodRouteTrans.WrkCtrId   = wrkCtrTable.WrkCtrId;
        prodRouteTrans.DefaultDimension = leanCostingFacade.mergeDefaultDimensions(productionFlowReference.RecId, wrkCtrTable.DefaultDimension);

        // Link to production flow
        prodRouteTrans.TransRefId   = productionFlowReference.planReference().PlanName;

        // Default values
        prodRouteTrans.TransRefType = ProdTransRefType::ProductionFlow;
        prodRouteTrans.JobType      = RouteJobType::Process;
        prodRouteTrans.TransType    = ProdRouteTransType::Time;
        prodRouteTrans.ExecutedPct  = 100;

        // Voucher and TransDate
        prodRouteTrans.DateWIP      = ledgerVoucher.lastTransDate();
        prodRouteTrans.VoucherWIP   = ledgerVoucher.lastVoucher();

        // Set the accounts
        prodRouteTrans.CategoryId            = routeCostCategory.CostCategoryId;
        prodRouteTrans.PostingWIPValuation   = LedgerPostingType::ProdWIPValuation;
        prodRouteTrans.PostingWIPIssue       = LedgerPostingType::ProdWIPIssue;

        if (prodGroup &&
            ((prodGroup.wipValuationLedgerDimension && prodGroup.wipIssueLedgerDimension)
            || ProdParameters::find().ProdPostingType == ProdPostingType::ProdGroup))
        {
            prodRouteTrans.wipValuationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
            prodRouteTrans.wipIssueLedgerDimension     = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
        }
        else
        {
            if (ProdParameters::find().ProdPostingType == ProdPostingType::ItemWrkCtr)
            {
                prodRouteTrans.wipValuationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(wrkCtrTable.wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
                prodRouteTrans.wipIssueLedgerDimension     = LedgerDimensionFacade::serviceCreateLedgerDimension(wrkCtrTable.wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
            }
            else
            {
                prodRouteTrans.wipValuationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(routeCostCategory.wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
                prodRouteTrans.wipIssueLedgerDimension     = LedgerDimensionFacade::serviceCreateLedgerDimension(routeCostCategory.wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
            }
        }

        // Cost
        prodRouteTrans.HourPrice             = routeCostCategory.costPrice(_inventSiteId);
        prodRouteTrans.Hours                 = _hours;
        prodRouteTrans.Amount = prodRouteTrans.calcAmount();

        // Set resource related fields after the date has been set
        prodRouteTrans.initFromWrkCtrId(wrkCtrTable.WrkCtrId);

        return prodRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void new()
    {
        currencyCode = CompanyInfoHelper::standardCurrency();
        // <GEERU>
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKanbanJob</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanJob parmKanbanJob(KanbanJob _kanbanJob = kanbanJob)
    {
        kanbanJob = _kanbanJob;

        return kanbanJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanCostingFacade</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected LeanCostingFacadeBase parmLeanCostingFacade(LeanCostingFacadeBase _leanCostingFacade = leanCostingFacade)
    {
        leanCostingFacade = _leanCostingFacade;
        return leanCostingFacade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductionFlowReference</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected LeanProductionFlowReference parmProductionFlowReference(LeanProductionFlowReference _productionFlowReference = productionFlowReference)
    {
        productionFlowReference = _productionFlowReference;

        return productionFlowReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversal</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmReversal(boolean _reversal  = reversal)
    {
        reversal = _reversal;
        return reversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDirectManufacturing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates direct manufacturing cost and adds it to the General Ledger.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void processDirectManufacturing()
    {
        // Create the route transactions based on the finished goods
        this.createDirectManufacturingCost();

        // Now add the postings for the routes
        this.addDirectManufacturingToLedger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDirectOutsourcing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>ProdRouteTrans</c> records for the direct outsourcing cost.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void processDirectOutsourcing()
    {
        if (inventSiteServiceMap && inventSiteServiceMap.elements() != 0)
        {
            RecordInsertList routeTransInsertList = new RecordInsertList(tableNum(ProdRouteTrans));
            systemSequence systemSequence = new systemSequence();
            systemSequence.suspendRecIds(tableNum(ProdRouteTrans));
            MapEnumerator inventSiteServiceMapEnum = inventSiteServiceMap.getEnumerator();

            while (inventSiteServiceMapEnum.moveNext())
            {
                List directOursourcingWIPList = inventSiteServiceMapEnum.currentValue();
                ListEnumerator directOursourcingWIPListEnum = directOursourcingWIPList.getEnumerator();

                while (directOursourcingWIPListEnum.moveNext())
                {
                    LeanCostOutsourcing outsourcingCostBuilder = directOursourcingWIPListEnum.current();

                    outsourcingCostBuilder.createOutsourcingCost(systemSequence,
                        routeTransInsertList,
                        inventSiteServiceMapEnum.currentKey());
                }
            }

            // insert the transactions to the DB
            routeTransInsertList.insertDatabase();
            systemSequence.removeRecIdSuspension(tableNum(ProdRouteTrans));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIndirect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates indirect cost and adds it to the General Ledger.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void processIndirect()
    {
        InventCostProdIndirect      inventCostProdIndirect = InventCostProdIndirect::newFromLedgerVoucher(ledgerVoucher);

        this.createIndirectConsumption(inventCostProdIndirect);
        this.createIndirectFinished(inventCostProdIndirect);
        this.createIndirectRoute(inventCostProdIndirect);

        // Write the indirect to the database and add them to GL
        inventCostProdIndirect.finalizeCalc(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the indirect cost maps.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void reset()
    {
        inventSiteConsumptionMap = null;
        inventSiteFinishedMap    = null;
        inventSiteRouteMap       = null;
        inventSiteServiceMap     = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates conversion cost and resets the internal indirect cost maps.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateNow()
    {
        if (!this.validate())
        {
            throw error("@SYS18447");
        }

        // First the routes, because these might add additional indirect cost
        this.processDirectManufacturing();
        this.processDirectOutsourcing();

        // All the indirect cost are there, update them
        this.processIndirect();

        this.reset();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates class parameters.
    /// </summary>
    /// <returns>
    ///    true if the specified parameters are valid; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean validate()
    {
        boolean result = true;

        if (kanbanJob)
        {
            result = kanbanJob.checkValid(kanbanJob.RecId);
        }

        if (   result
            && productionFlowReference
            && productionFlowReference.legalEntity() != CompanyInfo::current())
        {
            result = checkFailed("@SYS332729");
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected static LeanConversionCostUpd construct()
    {
        return new LeanConversionCostUpd();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>LeanConversionCostUpd</c> class and initializes the voucher and
    ///    facade properties.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher.
    /// </param>
    /// <param name="_leanCostingFacade">
    ///    The lean costing facade object.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>LeanConversionCostUpd</c> class.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanConversionCostUpd constructForVoucher(
        LedgerVoucher                   _ledgerVoucher,
        LeanCostingFacadeBase           _leanCostingFacade
        )
    {
        LeanConversionCostUpd       costUpd = LeanConversionCostUpd::construct();

        if (!_leanCostingFacade)
        {
            _leanCostingFacade = LeanCostingFacade::construct();
        }

        costUpd.parmLedgerVoucher(_ledgerVoucher);
        costUpd.parmLeanCostingFacade(_leanCostingFacade);

        costUpd.checkTransDate();

        return costUpd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new <c>LeanConversionCostUpd</c> object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object that is used for posting ledger transactions.
    /// </param>
    /// <param name="_leanProductionFlowReference">
    ///    The production flow reference for which conversion cost is posted.
    /// </param>
    /// <param name="_leanCostingFacade">
    ///    The lean costing facade object to use for receiving resource consumptions.
    /// </param>
    /// <param name="_kanbanJob">
    ///    The kanban job for which the conversion cost is to be recorded.
    /// </param>
    /// <returns>
    ///    A new <c>LeanConversionCostUpd</c> object.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanConversionCostUpd newFromParameters(
        LedgerVoucher                   _ledgerVoucher,
        LeanProductionFlowReference     _leanProductionFlowReference,
        LeanCostingFacadeBase           _leanCostingFacade,
        KanbanJob                       _kanbanJob
        )
    {
        LeanConversionCostUpd       costUpd = LeanConversionCostUpd::construct();

        if (!_leanCostingFacade)
        {
            _leanCostingFacade = LeanCostingFacade::construct();
        }

        costUpd.parmLedgerVoucher(_ledgerVoucher);
        costUpd.parmProductionFlowReference(_leanProductionFlowReference);
        costUpd.parmLeanCostingFacade(_leanCostingFacade);
        costUpd.parmKanbanJob(_kanbanJob);

        costUpd.checkTransDate();

        return costUpd;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>