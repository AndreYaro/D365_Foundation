<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMov_ProdLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventMov_ProdLine</c> class is used when you work with the production <c>BOM</c> records.
/// </summary>
[InventMovementFactoryAttribute(tableStr(ProdBOM))]
class InventMov_ProdLine extends InventMovement
{
    ProdBOM         prodBOM;
    ProdTable       projProdTable;
    private boolean isSkipMandatoryInventoryOwnerForAllInventTransCheckFlightEnabled;
    
    protected boolean mustCheckIfInventoryOwnerIsMandatory;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>pdsCWReserveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight reserve quantity.
    /// </summary>
    /// <returns>The catch weight reserve quantity.</returns>
    public PdsCWInventQty pdsCWReserveQty()
    {
        if (this.pdsCWItem())
        {
            return prodBOM.pdsCWReserveQty();
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoReserveOnOrderChangeInventDim</Name>
				<Source><![CDATA[
    public boolean canAutoReserveOnOrderChangeInventDim()
    {
        return this.canBeReserved() && this.mustBeAutoReserved();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountBalanceSheet()
    {
        if (! cacheAccountBalanceSheet)
        {
            if (prodBOM.prodTable().ProdPostingType   == ProdPostingType::ProdGroup)
            {
                cacheAccountBalanceSheet = ProdGroup::find(prodBOM.prodTable().ProdGroupId).IssueLedgerDimension;
            }
            else
            {
                if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                {
                    cacheAccountBalanceSheet = InventPosting::itemExtendParm_CN(
                        InventAccountType::ProdIssue,
                        InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                        prodBOM.ItemId,
                        this.inventTable().itemGroupId());
                }
                else
                {
                    cacheAccountBalanceSheet = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdIssue));
                }
            }
        }

        return cacheAccountBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventPostingItemLedgerDimensionParameters</Name>
				<Source><![CDATA[
    public InventPostingItemLedgerDimensionParameters createInventPostingItemLedgerDimensionParameters(
        InventAccountType   _inventAccountType,
        ItemGroupId         _itemGroupId = this.inventTable().itemGroupId())
    {
        InventPostingItemLedgerDimensionParameters searchParameters = super(_inventAccountType, _itemGroupId);

        searchParameters.ItemId = prodBOM.ItemId;

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperations()
    {
        if (! cacheAccountOperations)
        {
            if (prodBOM.prodTable().ProdPostingType   == ProdPostingType::ProdGroup)
            {
                cacheAccountOperations = ProdGroup::find(prodBOM.prodTable().ProdGroupId).IssueOffsetLedgerDimension;
            }
            else
            {
                cacheAccountOperations = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdIssueOffsetAccount));
            }
        }

        return cacheAccountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysical()
    {
        if (! cacheAccountPhysical)
        {
            if (prodBOM.prodTable().ProdPostingType   == ProdPostingType::ProdGroup)
            {
                cacheAccountPhysical = ProdGroup::find(prodBOM.prodTable().ProdGroupId).PicklistLedgerDimension;
            }
            else
            {
                if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                {
                    cacheAccountPhysical = InventPosting::itemExtendParm_CN(
                        InventAccountType::ProdPicklist,
                        InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                        prodBOM.ItemId,
                        this.inventTable().itemGroupId());
                }
                else
                {
                    cacheAccountPhysical = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdPicklist));
                }
            }
        }

        return cacheAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the check to verify if the reservation update is necessary.
    /// For warehouse enabled catch weight items used in production, the catch weight inventory values should be checked instead of the weight.
    /// </summary>
    /// <returns>true, if the reservation update is necessary; otherwise, false.</returns>
    protected boolean mustUpdateReservation()
    {
        if (PdsGlobal::pdsIsCWItem(this.itemId()))
        {
            return this.transIdSum().pdsCWOnOrder() != 0;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ActivityNumber : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainFinancialUnit</Name>
				<Source><![CDATA[
    public void addRemainFinancialUnit(
        UnitQty         _qtyUnit,
        InventQty       _qty)
    {
        prodBOM.RemainBOMFinancial += -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    public void addRemainPhysical(InventQty _inventQty)
    {
        prodBOM.RemainInventPhysical+= -_inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void addRemainPhysicalUnit(UnitQty _qtyUnit)
    {
        prodBOM.RemainBOMPhysical += -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustInventDimReservationCriteria</Name>
				<Source><![CDATA[
    public InventDim adjustInventDimReservationCriteria(
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm)
    {
        InventDimParm   tmpInventDimParm;

        InventDim tmpInventDim = WHSInvent::adjustDimsForProdPick(_inventDimCriteria, this.itemId());

        tmpInventDimParm.initFromInventDim(tmpInventDim);

        _inventDimParm = InventDimParm::andParms(_inventDimParm, tmpInventDimParm);

        return tmpInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTransactionInventDimEstimated</Name>
				<Source><![CDATA[
    public InventDim adjustTransactionInventDimEstimated()
    {
        InventDim tmpInventDim = WHSInvent::adjustDimsForProdPick(this.inventdim(), this.itemId());

        // Release has been done, estimation without WMSLocation. Try to find the WMSLocation from work center.
        if (this.isItemWHSEnabled()
            && !tmpInventDim.wmsLocationId
            && prodBOM.WrkCtrConsumption
            && prodBOM.prodTable().status().isAfterOrEqualTo(ProdStatus::Released))
        {
            WMSLocation wmsLocation = WHSProdTable::getWorkCenterWMSLocationFromProdId(prodBOM.ProdId, prodBOM.OprNum, tmpInventDim.InventDimId);

            // Only specify the location if LP is already set or not needed.
            if (tmpInventDim.LicensePlateId || !wmsLocation.whsLocationIsLPControlled())
            {
                if (wmsLocation.inventLocationId && tmpInventDim.InventLocationId != wmsLocation.inventLocationId)
                {
                    tmpInventDim.InventLocationId = wmsLocation.inventLocationId;
                }

                tmpInventDim.wMSLocationId = wmsLocation.wMSLocationId;
                tmpInventDim = InventDim::findOrCreate(tmpInventDim);
            }
        }

        return tmpInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assemblyInventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the assembly inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <returns>
    ///    The ID of the assembly inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId assemblyInventTransOriginId()
    {
        InventTransId assemblyInventTransId = prodBOM.prodTable().InventTransId;

        if (!assemblyInventTransId)
        {
            throw error("@SYS23151");
        }

        return InventTransOrigin::findByInventTransId(assemblyInventTransId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDispReservationBlockedFieldId</Name>
				<Source><![CDATA[
    public FieldId batchDispReservationBlockedFieldId()
    {
        return fieldNum(PdsDispositionMaster, PdsProdBlockReserve);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCommittedCostBeReversed</Name>
				<Source><![CDATA[
    public boolean canCommittedCostBeReversed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveReservedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement type can have WHS work created that takes over reserving the lower levels of the hierarchy.
    /// </summary>
    /// <returns>
    /// This method return true for this type of movement if the movement item is WHS enabled.
    /// </returns>
    public boolean canHaveReservedWork()
    {
        return this.isItemWHSEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotSubDelivery</Name>
				<Source><![CDATA[
    protected boolean checkNotSubDelivery(
        InventQty       _physicalNow,
        InventQty       _remainPhysicalNow,
        boolean         _isPhysicalUpdate
        , PdsCWInventQty  _pdsCWPhysicalNow
        , PdsCWInventQty  _pdsCWRemainPhysicalNow
        )
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimated</Name>
				<Source><![CDATA[
    public boolean checkUpdateEstimated(
        InventUpd_Estimated     _updateNow,
        InventMovement          _this_orig)
    {
        ProdTable prodTable= prodBOM.prodTable();

        if  (! prodTable.status().inventCheckUpdEst())
        {
            return false;
        }

        return super(_updateNow, _this_orig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysical</Name>
				<Source><![CDATA[
    public boolean checkUpdatePhysical(InventUpd_Physical _updateNow)
    {
        return super(_updateNow) && this.checkMandatoryInventoryOwnerOnAllInventTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateFinancial</Name>
				<Source><![CDATA[
    public boolean checkUpdateFinancial(InventUpd_Financial _updateNow)
    {
        return super(_updateNow) && this.checkMandatoryInventoryOwnerOnAllInventTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMandatoryInventoryOwnerOnAllInventTrans</Name>
				<Source><![CDATA[
    private boolean checkMandatoryInventoryOwnerOnAllInventTrans()
    {
        boolean ret = true;

        InventOwnerId mandatoryOwnerId = this.getInventoryOwnerId();

        if (isSkipMandatoryInventoryOwnerForAllInventTransCheckFlightEnabled && this.skipCheckMandatoryInventoryOwnerOnAllInventTrans())
        {
            return ret;
        }

        InventTrans inventTrans;
        InventDim transInventDim;

        select firstonly TableId from inventTrans
            where inventTrans.InventTransOrigin == this.inventTransOriginId()
                && inventTrans.TransChildType   == this.transChildType()
                && inventTrans.TransChildRefId  == this.transChildRefId()
            join InventOwnerId_RU from transInventDim
                where transInventDim.inventDimId         == inventTrans.inventDimId
                    && transInventDim.InventOwnerId_RU   != ''
                    && transInventDim.InventOwnerId_RU   != mandatoryOwnerId;

        if (transInventDim.InventOwnerId_RU)
        {
            ret = checkFailed(strFmt("@SCM:SpecifiedInventoryOwnerIsNotAllowedInThisProcess", transInventDim.InventOwnerId_RU, mandatoryOwnerId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCheckMandatoryInventoryOwnerOnAllInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory owner will be checked on all inventory transactions.
    /// </summary>
    /// <returns>
    /// true if the check will be skipped; otherwise, false.
    /// </returns>
    public boolean skipCheckMandatoryInventoryOwnerOnAllInventTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBePhysicalUpdated</Name>
				<Source><![CDATA[
    public boolean canInventTransBePhysicalUpdated(InventTrans _inventTrans)
    {
        return this.forceCheckUpdateInventOwnerId(_inventTrans.inventDim()) && super(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeFinancialUpdated</Name>
				<Source><![CDATA[
    public boolean canInventTransBeFinancialUpdated(InventTrans _inventTrans)
    {
        return this.forceCheckUpdateInventOwnerId(_inventTrans.inventDim()) && super(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceCheckUpdateInventOwnerId</Name>
				<Source><![CDATA[
    private boolean forceCheckUpdateInventOwnerId(InventDim _inventDim)
    {
        mustCheckIfInventoryOwnerIsMandatory = true;
        boolean ret = this.checkUpdateInventOwnerId(_inventDim);
        mustCheckIfInventoryOwnerIsMandatory = false;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMandatoryInventoryOwner</Name>
				<Source><![CDATA[
    public boolean hasMandatoryInventoryOwner()
    {
        if (isConfigurationKeyEnabled(configurationKeyNum(ConsignmentInbound)))
        {
            return mustCheckIfInventoryOwnerIsMandatory;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    public void createOriginOwnerRelationship()
    {
        InventTransOriginId originId = this.inventTransOriginId();

        if (originId && prodBOM.RecId)
        {
            InventTransOriginProdBOM::writeOriginOwnerRelationship(prodBOM.DataAreaId, prodBOM.InventTransId, originId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the relationship between the inventory transactions originator and the owner that
    ///    corresponds.
    /// </summary>
    public void deleteOriginOwnerRelationship()
    {
        if (prodBOM.RecId)
        {
            InventTransOriginProdBOM::deleteOwnerRelationship(prodBOM.DataAreaId, prodBOM.InventTransId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpiryCheckDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date to check the expiry date of an inventory batch against.
    /// </summary>
    /// <returns>
    /// The date to check the expiry date against.
    /// </returns>
    /// <remarks>
    /// The base method is overridden.
    /// If feature <c>ProdBatchExpirationDateForRawMaterialsValidationFeature</c> is on then returns 
    /// raw material date; otherwise the transaction date of the production order.
    /// </remarks>
    public TransDate getExpiryCheckDate()
    {
        return prodBOM.RawMaterialDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDimParmAutoReserv</Name>
				<Source><![CDATA[
    public InventDimParm initDimParmAutoReserv(
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm = null)
    {
        if (this.transChildType())
        {
            _inventDimParm.initFromInventDim(_inventDimCriteria);
            return _inventDimParm;
        }

        return super(_inventDimCriteria,_inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        return prodBOM.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The new value of the ID of the inventory transaction originator.
    /// </param>
    /// <returns>
    ///    The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginId(InventTransOriginId _inventTransOriginId = inventTransOriginId)
    {
        if (_inventTransOriginId != inventTransOriginId)
        {
            inventTransOriginId = _inventTransOriginId;
        }
        else
        {
            if (!inventTransOriginId)
            {
                inventTransOriginId = InventTransOriginProdBOM::findInventTransOriginId(prodBOM.DataAreaId, prodBOM.InventTransId);
            }
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId  itemId()
    {
        return prodBOM.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    ///    zero if the whole movement is not marked; otherwise, the ID of the transaction origin.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        return InventTransOrigin::findByInventTransId(prodBOM.InventRefTransId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrBackOrderStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the backorder status.
    /// </summary>
    /// <returns>
    /// The backorder status.
    /// </returns>
    ProdBackStatus mcrBackOrderStatus()
    {
        return prodBOM.BackorderStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeAutoReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>inventMovement</c> object must be automatically reserved.
    /// </summary>
    /// <returns>
    ///    A default Boolean value from the <c>inventType</c> class hierarchy.
    /// </returns>
    /// <remarks>
    ///    This method is often called together with the <c>canBeReserved</c> method, which returns a default
    ///    Boolean value from the <c>inventType</c> class hierarchy.
    /// </remarks>
    public boolean  mustBeAutoReserved()
    {
        if (!this.inventTable().inventItemType().canBeAutoReserved())
        {
            return false;
        }

        return prodBOM.mustBeAutoReserved();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean  mustBeBookedPhysically()
    {
        if (this.prodTable().isProjMethodConsumed())
        {
            if (!this.mustDoProjPhysicalPosting())
            {
                return false;
            }
            return this.inventModelGroup().PostOnhandFinancial;
        }

        if (this.inventModelType().mustAlwaysBeBookedPhysically() || ProdParametersDim::find(prodBOM.InventDimId).PostPickList)
        {
            return super();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCostControlled</Name>
				<Source><![CDATA[
    public boolean mustBeCostControlled()
    {
        if (this.projId()!='' && projProdTable.isProjMethodConsumed())
        {
            if (ProjParameters::find().TrackCommittedCostProduction)
            {
                return true;
            }

            if (prodBOM.orig().RemainBOMPhysical > 0 && prodBOM.RemainBOMPhysical == 0) //Reset the status to create while cost control parameter is disabled
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBePicked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions that are related to this movement must be picked.
    /// </summary>
    /// <returns>
    ///    true if the transactions must be picked; otherwise, false.
    /// </returns>
    public boolean mustBePicked()
    {
        boolean ret = super();

        if (ret)
        {
            ret = (!this.inventdim().inventLocation().VendAccount);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRemainControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeRemainControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeUnitControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeUnitControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeUpdatedExpected</Name>
				<Source><![CDATA[
    public boolean mustBeUpdatedExpected()
    {
        if (! prodBOM.type().mustInventUpdEstimated())
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPhysicalAdjust</Name>
				<Source><![CDATA[
    public boolean mustDoProjPhysicalAdjust()
    {
        if (this.prodTable().isProjMethodConsumed() && this.mustDoProjPhysicalPosting())
        {
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPhysicalPosting</Name>
				<Source><![CDATA[
    public boolean mustDoProjPhysicalPosting()
    {
        return (prodBOM.isProjMethodConsumed() && !prodBOM.prodTableRef().isProjMethodConsumed());
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(
        ProdBOM         _prodBOM,
        InventType      _inventType = ProdBOMType::construct(_prodBOM))
    {
        prodBOM  = _prodBOM;

        super(prodBOM,_inventType);
        isSkipMandatoryInventoryOwnerForAllInventTransCheckFlightEnabled = InventMovProdLineSkipMandatoryInventoryOwnerForAllInventTransCheckFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    public InventMovement newMovement_Orig()
    {
        if (!prodBOM.RecId)
        {
            return null;
        }
        return InventMov_ProdLine::newFromProdBOM(prodBOM.orig(), ProdBOMType::construct(prodBOM.orig()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount offsetAccountPhysical()
    {
        if (! cacheOffsetAccountPhysical)
        {
            if (this.prodTable().isProjMethodConsumed())
            {
                cacheOffsetAccountPhysical = ProjPosting::getInventLedgerDimension(ProjAccountType::CostAccount,
                                                                     this.projId(),
                                                                     this.projCategoryId());
            }
            else
            {
                if (prodBOM.prodTable().ProdPostingType   == ProdPostingType::ProdGroup)
                {
                    cacheOffsetAccountPhysical = ProdGroup::find(prodBOM.prodTable().ProdGroupId).PickListOffsetLedgerDimension;
                }
                else
                {
                    cacheOffsetAccountPhysical = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::ProdPicklistOffsetAccount));
                }
            }
        }

        return cacheOffsetAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsConsiderRestrictReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the batch disposition functionality should be considered reservation.
    /// </summary>
    /// <returns>
    /// Always returns true;
    /// </returns>
    public boolean pdsConsiderRestrictReservation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the catch weight remain financial quantity.
    /// </summary>
    /// <param name="_qty">
    /// The catch weight quantity to add to remain financial.
    /// </param>
    public void pdsCWAddRemainFinancial(PdsCWInventQty _qty)
    {
        prodBOM.PdsCWRemainFinancial += -_qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds catch weight remain physical quantity.
    /// </summary>
    /// <param name="_qty">
    /// The catch weight quantity to add to remain physical.
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty _qty)
    {
        prodBOM.PdsCWRemainPhysical+= -_qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight remain physical quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    public PdsCWInventQty pdsCWRemainPhysical()
    {
        return -prodBOM.PdsCWRemainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight remain physical quantity.
    /// </summary>
    /// <param name="_qty">
    /// The catch weight quantity to set remain physical.
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _qty)
    {
        prodBOM.PdsCWRemainPhysical = -_qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight transaction quantity.
    /// </summary>
    /// <param name="_qty">
    /// A <c>PdsCWInventQty</c> value.
    /// </param>
    public void pdsCWSetTransQty(PdsCWInventQty _qty)
    {
        prodBOM.PdsCWInventCalc = -_qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight transaction quantity.
    /// </summary>
    /// <returns>
    /// The catch weight transaction quantity.
    /// </returns>
    public InventQty  pdsCWTransQty()
    {
        return -prodBOM.PdsCWInventCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight unit ID.
    /// </summary>
    /// <returns>
    /// The catch weight unit ID.
    /// </returns>
    public PdsCWUnitId pdsCWUnitId()
    {
        return prodBOM.pdsCWUnitId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMustConsiderBatchAttrib</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if batch attributes should be concerned for reservation
    /// </summary>
    /// <returns>
    /// Value of pdsUseBAForRes class variable
    /// </returns>
    /// <remarks>
    /// Variable set through parm method.
    /// </remarks>
    public PdsBatchAttribAutoRes pdsMustConsiderBatchAttrib()
    {
        return pdsUseBAForRes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerPostingType postingBalanceSheet()
    {
        return LedgerPostingType::ProdIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOffsetPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOffsetPhysical()
    {
        if (this.prodTable().isProjMethodConsumed())
        {
            return LedgerPostingType::ProjCost;
        }

        return LedgerPostingType::ProdPicklistOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOperations()
    {
        return LedgerPostingType::ProdIssueOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysical()
    {
        return LedgerPostingType::ProdPicklist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodTable</Name>
				<Source><![CDATA[
    protected ProdTable prodTable()
    {
        if (!projProdTable)
        {
            projProdTable = prodBOM.prodTable();
        }

        return projProdTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId projCategoryId()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjCategoryId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    public ProjId projId()
    {
        return (this.prodTable().isProjMethodConsumed() ? this.prodTable().ProjId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    public ProjLinePropertyId projLinePropertyId()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjLinePropertyId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesCurrencyId</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode projSalesCurrencyId()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjSalesCurrencyId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesPrice</Name>
				<Source><![CDATA[
    public ProjSalesPriceCost projSalesPrice()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjSalesPrice : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxGroupId</Name>
				<Source><![CDATA[
    public ProjTaxGroup projTaxGroupId()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjTaxGroupId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxItemGroupId</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup projTaxItemGroupId()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjTaxItemGroupId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransIdRef</Name>
				<Source><![CDATA[
    public ProjTransIdBase projTransIdRef()
    {
        return (this.prodTable().isProjMethodConsumed() ? prodBOM.ProjTransId : '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainFinancialUnit</Name>
				<Source><![CDATA[
    public UnitQty     remainFinancialUnit()
    {
        return -prodBOM.RemainBOMFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    public InventQty   remainPhysical()
    {
        return -prodBOM.RemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty      remainPhysicalUnit()
    {
        return -prodBOM.RemainBOMPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveQty</Name>
				<Source><![CDATA[
    public InventQty   reserveQty()
    {
        return prodBOM.reserveQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    public void setInventDimId(InventDimId _dimId)
    {
        prodBOM.InventDimId = _dimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventRefFields</Name>
				<Source><![CDATA[
    public boolean setInventRefFields(
        InventRefType           _inventRefType,
        InventRefId             _inventRefId,
        InventTransOriginId     _markingRefInventTransOrigin
        )
    {
        ProdTable       prodTable;

        InventTransId   markingRefInventTransId = InventTransOrigin::find(_markingRefInventTransOrigin).InventTransId;
        boolean         updateProdTable = true;

        if (prodBOM.prodTable().status().isBefore(ProdStatus::Completed))
        {
            if (_inventRefType          != prodBOM.InventRefType  ||
                _inventRefId            != prodBOM.InventRefId    ||
                markingRefInventTransId != prodBOM.InventRefTransId)
            {
                if (_inventRefType == InventRefType::None &&
                    !_inventRefId &&
                    !markingRefInventTransId)
                {
                    updateProdTable = false;
                }

                if (prodBOM.InventRefType == InventRefType::Production &&
                    updateProdTable)
                {
                    prodTable = ProdTable::find(prodBOM.InventRefId,true);
                    if (prodTable.RecId && prodTable.CollectRefProdId != prodTable.ProdId)
                    {
                        prodTable.CollectRefProdId    = prodTable.ProdId;
                        prodTable.CollectRefLevel     = 0;
                        prodTable.doUpdate();

                        prodTable.updateCollectRefProdId();
                    }
                }

                prodBOM.InventRefType       = _inventRefType;
                prodBOM.InventRefId         = _inventRefId;
                prodBOM.InventRefTransId    = markingRefInventTransId;

                // update related prodCalcTrans record
                ProdCalcTrans prodCalcTrans = prodBOM.prodCalcTrans(true);
                if (prodCalcTrans.RecId)
                {
                    prodCalcTrans.initFromProdBOM(prodBOM);
                    prodCalcTrans.update();
                }

                if (prodBOM.InventRefType == InventRefType::Production && (prodBOM.ProdLineType == BOMType::PeggedSupply || (prodBOM.ProdLineType == BOMType::Item && CostTakeMarkedItemAsPeggedSupplyFlight::instance().isEnabled())))
                {
                    prodTable = ProdTable::find(prodBOM.InventRefId,true);
                    if (prodTable.RecId             &&
                        prodTable.InventRefType     == InventRefType::ProdLine &&
                        prodTable.InventRefTransId  == prodBOM.InventTransId)
                    {
                        ProdTable prodTableParent = ProdTable::find(prodBOM.ProdId,true);
                        if (prodTableParent.RecId)
                        {
                            // update prodBOM marking reference before checking circularity
                            this.updateDoBuffer();      

                            prodTable.CollectRefLevel     = prodTableParent.CollectRefLevel  + 1;
                            prodTable.CollectRefProdId    = prodTableParent.CollectRefProdId;
                            prodTable.doUpdate();

                            prodTable.updateCollectRefProdId();
                        }
                    }
                }
            }

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    public void setRemainPhysical(InventQty  _inventQty)
    {
        prodBOM.RemainInventPhysical = -_inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void setRemainPhysicalUnit(UnitQty _qtyUnit)
    {
        prodBOM.RemainBOMPhysical = -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQty</Name>
				<Source><![CDATA[
    public void setTransQty(InventQty  _qtyInvent)
    {
        prodBOM.QtyInventCalc = -_qtyInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQtyUnit</Name>
				<Source><![CDATA[
    void setTransQtyUnit(UnitQty  _qtyUnit)
    {
        prodBOM.QtyBOMCalc     = -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate()
    {
        return prodBOM.RawMaterialDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    public InventTransId transId()
    {
        return prodBOM.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transInventRefType</Name>
				<Source><![CDATA[
    public InventRefType transInventRefType()
    {
        return InventRefType::ProdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    public InventQty   transQty()
    {
        return -prodBOM.QtyInventCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQtyUnit</Name>
				<Source><![CDATA[
    public UnitQty      transQtyUnit()
    {
        return -prodBOM.QtyBOMCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRefId</Name>
				<Source><![CDATA[
    public InventTransRefId transRefId()
    {
        return prodBOM.ProdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSchedTime</Name>
				<Source><![CDATA[
    public SchedTime transSchedTime()
    {
        return prodBOM.RawMaterialTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    public InventTransType transType()
    {
        return InventTransType::ProdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transUnitId</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol transUnitId()
    {
        return prodBOM.UnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBuffer</Name>
				<Source><![CDATA[
    public void updateBuffer(boolean _updateReservation = true)
    {
        ProdBOMType prodBOMType = inventType;
        prodBOMType.setBackStatus();

        InventUpd_Estimated estimated = InventUpd_Estimated::newInventMovement(this);
        estimated.updateNow();

        prodBOM.doUpdate();

        if (estimated && _updateReservation)
        {
            estimated.updateReservation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDoBuffer</Name>
				<Source><![CDATA[
    public void updateDoBuffer()
    {
        ProdBOMType prodBOMType = inventType;
        prodBOMType.setBackStatus();

        buffer.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPhysical</Name>
				<Source><![CDATA[
    public void updateLedgerPhysical(
        LedgerVoucher       _ledgerVoucher,
        InventTrans         _inventTrans,
        InventUpdate        _updateNow,
        InventOnhand        _inventOnhand,
        InventTrans         _inventTransUpd = _inventTrans)
    {
        // <GEERU>
        super(_ledgerVoucher, _inventTrans, _updateNow, _inventOnhand, _inventTransUpd);
        // </GEERU>

        if (this.mustDoProjPhysicalPosting()
         && _inventTrans.isUpdatedFinancial()
         && _inventTrans.CostAmountPhysical && bookedPhysically != UnknownNoYes::No )
        {
            InventTransPosting inventTransPosting = _inventTrans.inventTransPostingPhysical();
            if (!inventTransPosting.IsPosted
              && ProjPost::checkCreateProjCost(_inventTrans.ItemId,_inventTrans.ProjId))
            {
                ProjPost::newInventNeverLedger(_inventTrans,
                    _ledgerVoucher.lastTransDate(),
                    _ledgerVoucher.lastVoucher(),
                    -_inventTrans.CostAmountPhysical,
                    true,
                    ProjItemTransCostType::Accrued).postTrans();//Reverse Accrued
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimOwnerId</Name>
				<Source><![CDATA[
    public boolean updateAutoDimOwnerId()
    {
        if (isConfigurationKeyEnabled(configurationKeyNum(ConsignmentInbound)))
        {
            return false;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>InventMov_ProdLine</c> class based on the specified record.
    /// </summary>
    /// <param name="_prodBOM">
    ///    The record from the <c>ProdBOM</c> table for which the class is instantiated.
    /// </param>
    /// <param name="_inventType">
    ///    The associated <c>InventType</c> class.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventMov_ProdLine</c> class.
    /// </returns>
    public static InventMov_ProdLine newFromProdBOM(
        ProdBOM         _prodBOM,
        InventType      _inventType = ProdBOMType::construct(_prodBOM))
    {
        return new InventMov_ProdLine(_prodBOM, _inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReturnToDimOnSourceDocumentLine</Name>
				<Source><![CDATA[
    public boolean mustReturnToDimOnSourceDocumentLine()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearInventRefFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets reference fields based on owner so that they do not reference anything.
    /// </summary>
    public void clearInventRefFields()
    {
        // If reference is a line on a Purchase order in Draft state the line may not have InventTrans, but we still need to clear the InventRef fields on prodBom
        if (this.markingRefInventTransOrigin() || this.isReferenceDraftOrDeletedPurchaseOrderLine())
        {
            this.setInventRefFields(InventRefType::None, '', 0);
            this.updateDoBuffer();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReferenceDraftOrDeletedPurchaseOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the reference is a draft purchase order line (which does not have inventory transactions) or a deleted purchase order line which was
    /// never versioned (and therefore never had inventory transactions)
    /// </summary>
    /// <returns>true if the reference is a draft or deleted purchase line; otherwise, false</returns>
    /// <remarks>
    /// If change management is enabled on a purchase order, and a line on the order has not yet been through approval, the line does not have any inventory transactions.
    /// If the line has been deleted before it was versioned, it no longer exists; If it was deleted after it was versioned it was soft-deleted (exists with IsDeleted flag)
    /// </remarks>
    private boolean isReferenceDraftOrDeletedPurchaseOrderLine()
    {
        if (prodBOM.InventRefType == InventRefType::Purch
            && prodBOM.InventRefTransId
            && prodBOM.InventRefId
            && PurchTable::find(prodBOM.InventRefId).ChangeRequestRequired) // DocumentState of Purchase order can be Draft or InReview. Need to check versioning on line level.
        {
            PurchLine purchLine = PurchLine::findInventTransId(prodBOM.InventRefTransId);

            // If no PurchLine was found then either the line was versioned and has the IsDeleted flag set, or it was in Draft and hard deleted
            // If one was found check if it has been versioned
            if (!purchLine || !purchLine.isVersioned())
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canForceActualCatchWeightQuantityReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that actual consumption catch weight quantity is requested for reservation.
    /// </summary>
    /// <returns>True if an actual consumption catch weight quantity is requested for reservation; otherwise false.</returns>
    internal boolean canForceActualCatchWeightQuantityReservation()
    {
        return PdsGlobal::pdsIsCWItem(prodBOM.ItemId)
            && this.mustBeAutoReserved();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>