<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PmfFormCtrl</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>PmfFormCtrl</c> class is the base class for all Process-related form control classes.
/// </summary>
/// <remarks>
/// These classes are used to separate the business logic functionality that may be shared between
/// forms from the forms themselves. In additionl, this separation provides better ease in migrating
/// changes between different product versions by reducing the changes in form code itself.
/// </remarks>
class PmfFormCtrl implements ButtonStateProvider
{
    FormRun             formRun;
    FormDataSource      formDS;

    Array               subFormCtrls;

    Common              buffer;

    FormButtonManager   formButtonManager;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addSubFormCtrl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds another <c>PmfFormCtrl</c> object as a sub-control.
    /// </summary>
    /// <param name="_ctrl">
    /// A sub-control object that will be managed by this control.
    /// </param>
    /// <remarks>
    /// The base <c>PmfFormCtrl</c> class can hold references to zero or more 'sub-control' classes. The
    /// base event methods in the base class will delegate automatically to the same event method in all
    /// sub-control classes. For example, when the <c>PmfFormCtrl.initPost</c> method is called, the
    /// default functionality will loop through all sub-control classes and call
    /// <c>PmfFormCtrl.initPost</c> on them. All concrete sub-classes that override and event method must
    /// call the super event method to make sure that this behavior continues to operate correctly.
    /// </remarks>
    public void addSubFormCtrl(PmfFormCtrl _ctrl)
    {
        if (!subFormCtrls)
        {
            subFormCtrls = new Array(Types::Class);
        }

        subFormCtrls.value(subFormCtrls.lastIndex()+1,_ctrl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>args</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the arguments from the associated <c>FormRun</c> object.
    /// </summary>
    /// <returns>
    /// An arguments object.
    /// </returns>
    public Args args()
    {
        return formRun.args();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPmfEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the process industries functionality is enabled
    /// </summary>
    /// <returns>
    /// true, if the configuration key is enabled
    /// </returns>
    /// <remarks>
    /// The method is required to feed into the button manager.
    /// </remarks>
    public boolean isPmfEnabled()
    {
        return #PmfEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCatchWeightEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the catch weight functionality is enabled.
    /// </summary>
    /// <returns>true, if the Catch weight configuration key is enabled.</returns>
    public boolean isCatchWeightEnabled()
    {
        return #PDSCatchweightEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a reference to the caller of the associated <c>FormRun</c> object.
    /// </summary>
    /// <returns>
    /// An object reference to the caller.
    /// </returns>
    public Object caller()
    {
        return this.parmFormRun().args().caller();
    }

]]></Source>
			</Method>
			<Method>
				<Name>callerBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the specified record buffer to the associated <c>FormRun</c> object.
    /// </summary>
    /// <returns>
    /// A record buffer specified the arguments to the form.
    /// </returns>
    /// <remarks>
    /// public Record callerBuffer()
    /// </remarks>
    public Common callerBuffer()
    {
        return formRun.args().record();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRecVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the record version of the buffer is the same as the record version of the same
    /// record in the database.
    /// </summary>
    /// <param name="_buffer">
    /// The record buffer to check.
    /// </param>
    /// <returns>
    /// true if the record version is the same; otherwise, false .
    /// </returns>
    public boolean checkRecVersion(Common _buffer)
    {
        Common      common;
        DictTable   dictTable;

        dictTable = new DictTable(_buffer.TableId);
        common = dictTable.makeRecord();

        select firstonly RecVersion from common
            where common.RecId == _buffer.RecId;

        return common.RecVersion == _buffer.RecVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the advanced caching.
    /// </summary>
    /// <remarks>
    /// When the next refresh action is performed, the rules that are relevant for the refresh will be
    /// evaluated.The base implementation of this method does nothing. This method is required by the
    /// <c>ButtonStateProvider</c> interface.
    /// </remarks>
    public void clearCache()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceActivePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the standard code in the <c>active</c> form data source event.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void dataSourceActivePost()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceActivePost();
            }
        }

        this.updateDesign();
        this.refreshManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceCreatePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the standard code in the <c>create</c> form data source event.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void dataSourceCreatePre()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceCreatePre();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceDeletePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the standard code in the <c>delete</c> form data source event.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void dataSourceDeletePost()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceDeletePost();
            }
        }

        this.updateDesign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceInitPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the standard code in the <c>init</c> form data source event.
    /// </summary>
    /// <param name="_buffer">
    /// A record buffer for the data source.
    /// </param>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this
    /// object.When the associated form data source parameter has not been assigned to this control object,
    /// it will automatically be assigned from the data source of the specified record buffer.
    /// </remarks>
    public void dataSourceInitPost(Common _buffer)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceInitPost(_buffer);
            }
        }
        buffer = _buffer;
        if (!formDS)
        {
            formDS = FormDataUtil::getFormDataSource(_buffer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceInitValuePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the standard code in the <c>initValue</c> form data source event.
    /// </summary>
    /// <param name="_buffer">
    /// A record buffer for the data source.
    /// </param>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this
    /// object.When the associated form data source parameter has not been assigned to this control object,
    /// it will automatically be assigned from the data source of the specified record buffer.
    /// </remarks>
    public void dataSourceInitValuePre(Common _buffer)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceInitValuePre(_buffer);
            }
        }
        buffer = _buffer;
        if (!formDS)
        {
            formDS = FormDataUtil::getFormDataSource(_buffer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceLinkActivePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the standard code in the <c>linkActive</c> form data source event.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this
    /// object.After calling all the sub-control event methods, this method will call the
    /// <c>PmfFormCtrl.updateDesign</c> method to update any form controls that are based on the new active
    /// record.
    /// </remarks>
    public void dataSourceLinkActivePost()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceLinkActivePost();
            }
        }

        this.updateDesign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceLinkActivePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes before the standard code in the <c>linkActive</c> form data source event.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this
    /// object.After calling all the sub-control event methods, this method will call the
    /// <c>PmfFormCtrl.updateDesign</c> method to update any form controls that are based on the new active
    /// record.
    /// </remarks>
    public void dataSourceLinkActivePre()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceLinkActivePre();
            }
        }

        this.updateDesign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceValidateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the deletion in a data source.
    /// </summary>
    /// <returns>
    /// true if the deletion is valid; otherwise, false .
    /// </returns>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this
    /// object.If the call to this method in any sub-control returns false, this method will return false
    /// and no subsequent sub-controls will be executed.
    /// </remarks>
    public boolean dataSourceValidateDelete()
    {
        PmfFormCtrl subCtrl;
        int         i;
        boolean     ret = true;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                ret = ret && subCtrl.dataSourceValidateDelete();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceValidateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation on a write to a data source.
    /// </summary>
    /// <returns>
    /// true if the write is valid; otherwise, false .
    /// </returns>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this
    /// object.If the call to this method in any sub-control returns false, this method will return false
    /// and no subsequent sub-controls will be executed.
    /// </remarks>
    public boolean dataSourceValidateWrite()
    {
        PmfFormCtrl subCtrl;
        int         i;
        boolean     ret = true;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                ret = ret && subCtrl.dataSourceValidateWrite();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceWritePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after a write to a data source is performed.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void dataSourceWritePost()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceWritePost();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceWritePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes before a write to a data source is performed.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void dataSourceWritePre()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.dataSourceWritePre();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineButtonStates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements advanced caching for specific rules.
    /// </summary>
    /// <param name="_ruleFunctionName">
    /// A String that identifies the rule for which to perform advanced caching.
    /// </param>
    /// <remarks>
    /// This method is called by an instance of the <c>FormButtonManager</c> class on the rule class that
    /// implements the <c>ButtonStateProvider</c> interface.
    /// </remarks>
    public void determineButtonStates(str _ruleFunctionName)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableDSField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the specified field in the data source.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of field to enable or disable.
    /// </param>
    /// <param name="_enable">
    /// true to enable the field for input; otherwise, false.
    /// </param>
    /// <remarks>
    /// This is a convenience method to enable, to disable, or to assign the <c>skip</c> property for a
    /// field in the associated data source. The form data source must be specified through one of the data
    /// source event methods or explicitly through the <c>PmfFormCtrl.setDatasources</c> method before it
    /// calls this method. The field ID must be valid for the table that is referenced by this data
    /// source.When the specified field is disabled for input, the skip attribute is enabled.
    /// </remarks>
    protected void enableDSField(fieldId _fieldId, boolean _enable)
    {
        formDS.object(_fieldId).allowEdit(_enable);
        formDS.object(_fieldId).skip(!_enable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableFormControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the specified form control.
    /// </summary>
    /// <param name="_name">
    /// The name of the form control.
    /// </param>
    /// <param name="_enable">
    /// true to enable the field for input; otherwise, false.
    /// </param>
    /// <remarks>
    /// This is a convenience method to enable, to disable, or to assign the <c>skip</c> property for a
    /// control on the associated form. If the referenced control does not exist on the form, this method
    /// does nothing.When the specified field is disabled for input, the <c>skip</c> attribute is enabled.
    /// </remarks>
    protected void enableFormControl(identifierName _name, boolean _enable)
    {
        FormControl control;

        control = formRun.design().controlName(_name);
        if (control)
        {
            control.allowEdit(_enable);
            control.skip(!_enable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a lookup for a specified field.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the field to look up.
    /// </param>
    /// <param name="_formControl">
    /// A form control object reference for the focus control that will receive the result of the lookup.
    /// </param>
    /// <param name="_filterStr">
    /// A filter String that is passed to the lookup class.
    /// </param>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void fieldLookup(
        fieldId     _fieldId,
        FormControl _formControl,
        str         _filterStr)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.fieldLookup(_fieldId, _formControl, _filterStr);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes when a field is modified.
    /// </summary>
    /// <param name="_fieldId">
    /// The Field ID of the field that was modified.
    /// </param>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void fieldModified(fieldId _fieldId)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i) as PmfFormCtrl;
                subCtrl.fieldModified(_fieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldValidate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation on a specified field.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the field to validate.
    /// </param>
    /// <returns>
    /// true if the value is valid; false otherwise.
    /// </returns>
    /// <remarks>
    /// The base implementation calls the same method on all PmfFormCtrl assigned as sub-controls to this
    /// object. All child classes must call this parent method if they override this method. The form only
    /// must call this event method if there is actual code associated with the event method or any of the
    /// sub-controls associated with this object.If the call to this method in any sub-control returns
    /// false, this method will return false and no subsequent sub-controls will be executed.
    /// </remarks>
    public boolean fieldValidate(fieldId _fieldId)
    {
        PmfFormCtrl subCtrl;
        int         i;
        boolean     ret = true;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                ret = ret && subCtrl.fieldValidate(_fieldId);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after a call to the <c>init</c> method.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method if there is actual code
    /// associated with the event method or any of the sub-controls associated with this object.The base
    /// implementation automatically calls the <c>PmfFormCtrl.refreshManager</c> method to make sure that
    /// any associated instances of the <c>FormButtonManager</c> class have been correctly initialized.
    /// </remarks>
    public void initPost()
    {
        if (!this.parmFormRun())
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        this.registerCtrlRules();

        if (subFormCtrls)
        {
            for (int i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                PmfFormCtrl subCtrl = subFormCtrls.value(i);
                subCtrl.initPost();
            }
        }

        this.refreshManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerCtrlRules</Name>
				<Source><![CDATA[
    /// <summary>
    /// Register control rules that change the control appearance after the form has been initialized.
    /// </summary>
    protected void registerCtrlRules()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes before a call to the <c>init</c> method.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> objects that
    /// are assigned as sub-controls to this object. All child classes must call this parent method when
    /// they override this method. The form must only call this event method when there is actual code that
    /// is associated with the event method or any of the sub-controls that are associated with this object.
    /// </remarks>
    public void initPre()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.initPre();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>menuItemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the command name that is defined in the arguments of the class.
    /// </summary>
    /// <returns>
    /// The command name.
    /// </returns>
    public str menuItemName()
    {
        if (!formRun)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return formRun.args().menuItemName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get or set the primary table buffer that this control will manage.
    /// </summary>
    /// <param name="_buffer">Optional. Table buffer to assign.</param>
    /// <returns>Current table buffer assigned to this control.</returns>
    /// <remarks>
    /// When setting the buffer, the base implementation calls the same method
    /// on all PmfFormCtrl assigned as
    /// sub-controls to this object. All child classes must call this parent method
    /// if they override this method. The form only needs to call this event
    /// method if there is actual code associated with the event method or any of the
    /// sub-controls associated with this object.
    /// <syntax>
    /// public Common parmBuffer(Common _buffer = buffer)
    /// </syntax>
    /// </remarks>
    public Common parmBuffer(Common _buffer = buffer)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (!prmisdefault(_buffer))
        {
            buffer = _buffer;
            if (subFormCtrls)
            {
                for (i = 1; i <= subFormCtrls.lastIndex(); i++)
                {
                    subCtrl = subFormCtrls.value(i);
                    subCtrl.parmBuffer(_buffer);
                }
            }
        }

        return buffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get or set the primary form data source that this control will manage.
    /// </summary>
    /// <param name="_formDS">Optional. Form data source to assign.</param>
    /// <returns>Current form data source assigned to this control.</returns>
    /// <remarks>
    /// When setting the data source, the base implementation calls the same method
    /// on all PmfFormCtrl assigned as
    /// sub-controls to this object. All child classes must call this parent method
    /// if they override this method. The form only needs to call this event
    /// method if there is actual code associated with the event method or any of the
    /// sub-controls associated with this object.
    /// <syntax>
    /// public FormDataSource parmFormDataSource(FormDataSource _formDS)
    /// </syntax>
    /// </remarks>
    public FormDataSource parmFormDataSource(FormDataSource _formDS = formDS)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (!prmisdefault(_formDS))
        {
            formDS = _formDS;
            if (subFormCtrls)
            {
                for (i = 1; i <= subFormCtrls.lastIndex(); i++)
                {
                    subCtrl = subFormCtrls.value(i);
                    subCtrl.parmFormDataSource(_formDS);
                }
            }
        }

        return formDS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get or set the FormRun that this control will manage.
    /// </summary>
    /// <param name="_formRun">Optional. FormRun object to assign.</param>
    /// <returns>Current FormRun object assigned to this control.</returns>
    /// <remarks>
    /// When setting the FormRun, the base implementation calls the same method
    /// on all PmfFormCtrl assigned as
    /// sub-controls to this object. All child classes must call this parent method
    /// if they override this method. The form only needs to call this event
    /// method if there is actual code associated with the event method or any of the
    /// sub-controls associated with this object.
    /// <syntax>
    /// public FormRun parmFormRun(FormRun _formRun = formRun)
    /// </syntax>
    /// </remarks>
    public FormRun parmFormRun(FormRun _formRun = formRun)
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (!prmisdefault(_formRun))
        {
            formRun = _formRun;
            if (subFormCtrls)
            {
                for (i = 1; i <= subFormCtrls.lastIndex(); i++)
                {
                    subCtrl = subFormCtrls.value(i);
                    subCtrl.parmFormRun(_formRun);
                }
            }
        }

        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshManager</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes all the buttons that are registered by using the <c>FormButtonManager</c> that is
    /// associated with this form control.
    /// </summary>
    /// <param name="_clearCache">
    /// A Boolean value that indicates whether the rule values cache should be cleared and the rules should
    /// be evaluated; optional.
    /// </param>
    /// <param name="_internalCall">
    /// A Boolean value that indicates whether the method is called by the instance of the
    /// <c>FormButtonManager</c> class internally; optional.
    /// </param>
    /// <remarks>
    /// A call to this method is equivalent to triggering an update for all the registered groups.
    /// </remarks>
    protected void refreshManager(
        boolean     _clearCache = true,
        boolean     _internalCall = false)
    {
        if (formButtonManager)
        {
            formButtonManager.refresh(_clearCache, _internalCall);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerCtrlRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers a handling rule for the current object.
    /// </summary>
    /// <param name="_formGroupControl">
    /// The group control of the form for which to register the rule.
    /// </param>
    /// <param name="_formControl">
    /// The form control for which to register the rule.
    /// </param>
    /// <param name="_ruleFunctionName">
    /// The rule function to register
    /// </param>
    /// <param name="_ruleEffect">
    /// The effect to set; optional.
    /// </param>
    /// <param name="_ruleValueStr">
    /// The value to set for the effect; optional.
    /// </param>
    /// <returns>
    /// true if the rule has been registered
    /// </returns>
    /// <remarks>
    /// This method is not an event and should not be executed recursively. A particular [rule, control]
    /// must only be handled by one manager.
    /// </remarks>
    protected boolean registerCtrlRule(
        FormControl             _formGroupControl,
        FormControl             _formControl,
        str                     _ruleFunctionName,
        ButtonRuleEffectType    _ruleEffect = ButtonRuleEffectType::Enabled,
        str                     _ruleValueStr = "")
    {
        if (!formButtonManager || !formButtonManager.parmRuleImplementer())
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return formButtonManager.registerButtonRule(
                _formGroupControl,
                _formControl,
                _ruleFunctionName,
                _ruleEffect,
                _ruleValueStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCaption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets caption on the form.
    /// </summary>
    protected void setCaption()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerCtrlRuleNoGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers a handling rule for the current object.
    /// </summary>
    /// <param name="_formControl">
    /// The form control for which to register the rule.
    /// </param>
    /// <param name="_ruleFunctionName">
    /// The rule function to register.
    /// </param>
    /// <param name="_ruleEffect">
    /// The effect to set; optional.
    /// </param>
    /// <param name="_ruleValueStr">
    /// The value to set for the effect; optional
    /// </param>
    /// <returns>
    /// true if the rule has been registered; otherwise, false .
    /// </returns>
    /// <remarks>
    /// This method is not an event and should not be executed recursively. A particular [rule, control]
    /// must only be handled by one manager.
    /// </remarks>
    protected boolean registerCtrlRuleNoGroup(
        FormControl             _formControl,
        str                     _ruleFunctionName,
        ButtonRuleEffectType    _ruleEffect = ButtonRuleEffectType::Enabled,
        str                     _ruleValueStr       = "")
    {
        if (!formButtonManager || !formButtonManager.parmRuleImplementer())
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return formButtonManager.registerButtonRule(
                _formControl, //Ignore group
                _formControl,
                _ruleFunctionName,
                _ruleEffect,
                _ruleValueStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes before a call to the <c>run</c> method.
    /// </summary>
    /// <remarks>
    /// The base implementation of this method calls the same method on all <c>PmfFormCtrl</c> instances
    /// that are assigned as sub-controls to the currently selected object. All child classes must call
    /// this parent method when they override this method. The form is only required to call this event
    /// method when there is actual code that is associated with the event method or any of the
    /// sub-controls that are associated with the current object.
    /// </remarks>
    public void runPre()
    {
        PmfFormCtrl subCtrl;
        int         i;

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.runPre();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDatasources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the data sources that are used in the rule computation process.
    /// </summary>
    /// <param name="_datasources1">
    /// A table buffer that belongs to the first data source instance.
    /// </param>
    /// <param name="_datasources2">
    /// A table buffer that belongs to the second data source instance.
    /// </param>
    /// <param name="_datasources3">
    /// A table buffer that belongs to the third data source instance.
    /// </param>
    /// <param name="_datasources4">
    /// A table buffer that belongs to the fourth data source instance.
    /// </param>
    /// <param name="_datasources5">
    /// A table buffer that belongs to the fifth data source instance.
    /// </param>
    /// <remarks>
    /// Up to five data sources can be specified. When the implementation requires more data sources,
    /// additional custom methods should be implemented on the rule implementer class.The method is called
    /// by the <c>FormButtonManager</c> class on the rule class that implements the
    /// <c>ButtonStateProvider</c> interface.The base implementation sets the stored buffer and data source
    /// automatically by using the value of the first parameter.The class then calls the same method on all
    /// sub-controls that are associated with this control.
    /// </remarks>
    public void setDatasources(
        Common  _datasources1,
        Common  _datasources2 = null,
        Common  _datasources3 = null,
        Common  _datasources4 = null,
        Common  _datasources5 = null)
    {
        PmfFormCtrl subCtrl;
        int         i;

        buffer = _datasources1;
        formDS = FormDataUtil::getFormDataSource(_datasources1);

        if (subFormCtrls)
        {
            for (i = 1; i <= subFormCtrls.lastIndex(); i++)
            {
                subCtrl = subFormCtrls.value(i);
                subCtrl.setDatasources(
                    _datasources1,
                    _datasources2,
                    _datasources3,
                    _datasources4,
                    _datasources5);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDesign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the controls on the form.
    /// </summary>
    /// <remarks>
    /// This method is typically called when there are changes to the data sources, buffers, or other
    /// control state variables that may affect the visual components to which the user has access.The base
    /// implementation of this method does nothing.
    /// </remarks>
    public void updateDesign()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>visibleDSField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified field in the data source is visible.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the field to display.
    /// </param>
    /// <param name="_visible">
    /// true to display the field; false to hide the field.
    /// </param>
    protected void visibleDSField(fieldId _fieldId, boolean _visible)
    {
        formDS.object(_fieldId).visible(_visible);
    }

]]></Source>
			</Method>
			<Method>
				<Name>visibleFormControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visible property of a specified form control.
    /// </summary>
    /// <param name="_name">
    /// The name of the form control.
    /// </param>
    /// <param name="_visible">
    /// A Boolean value that indicates whether the control should be visible.
    /// </param>
    protected void visibleFormControl(identifierName _name, boolean _visible)
    {
        FormControl control;

        control = formRun.design().controlName(_name);
        if (control)
        {
            control.visible(_visible);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomQtyModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for a valid unit of measure conversion setup when BOM quantity is modified.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    internal void bomQtyModified(BOM _bom)
    {
        _bom.pmfCheckUnitConversion();
        BOM pmfBom;
        while select pmfBom
            where pmfBom.BOMId == _bom.BOMId
            &&    pmfBom.PmfPctEnable == NoYes::Yes
            &&    pmfBom.RecId != _bom.RecId
        {
            pmfBom.pmfCheckUnitConversion();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pctEnableModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the BOM quantity when percentage controlled is enabled.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    /// <param name = "_bomVersion">
    ///  The current BOMVersion record.
    /// </param>
    internal void pctEnableModified(BOM _bom, BOMVersion _bomVersion)
    {
        if (!_bom.PmfPctEnable)
        {
            _bom.PmfFormulaPct = 0;
            _bom.PmfScalable = NoYes::No;
        }
        else
        {
            _bom.BOMQtySerie = _bom.pmfsetBomQtySeries(_bomVersion);
            BOMVersion  bomVersionCalc = BOMVersion::findVersionCalculation(_bom.BOMId);

            this.formulaPctModified(_bom, bomVersionCalc ? bomVersionCalc : _bomVersion);
            _bom.PmfScalable = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formulaPctModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the BOM quantity when percentage is modified.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    /// <param name = "_bomVersion">
    /// The current BOMVersion record.
    /// </param>
    internal void formulaPctModified(BOM _bom, BOMVersion _bomVersion)
    {
        _bom.bomQty = _bom.pmfBOMPctQty(_bomVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>scalableModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the correct BOM quantity series value when scalable is modified.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    /// <param name = "_bomVersion">
    /// The current BOMVersion record.
    /// </param>
    internal void scalableModified(BOM _bom, BOMVersion _bomVersion)
    {
        _bom.BOMQtySerie = _bom.pmfsetBomQtySeries(_bomVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitIdModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the BOM quantity/formula size when unit of measure is modified.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    /// <param name = "_bomVersion">
    /// The current BOMVersion record.
    /// </param>
    /// <param name = "_formDataSource">
    /// Current form data source.
    /// </param>
    internal void unitIdModified(BOM _bom, BOMVersion _bomVersion, FormDataSource _formDataSource)
    {
        if (_bom.PmfPctEnable)
        {
            this.formulaPctModified(_bom, _bomVersion);
        }
        else
        {
            this.pmfUpdateFormulaSizeIfQtyDiffers(_bom, _bomVersion, _formDataSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfUpdateFormulaSizeIfQtyDiffers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the formula size if the last known BOMQty value differs from the current one.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    /// <param name = "_bomVersion">
    /// The current BOMVersion record.
    /// </param>
    /// <param name = "_formDataSource">
    /// Current form data source.
    /// </param>
    internal void pmfUpdateFormulaSizeIfQtyDiffers(BOM _bom, BOMVersion _bomVersion, FormDataSource _formDataSource)
    {
        if (_bom.orig().bomQty != _bom.BOMQty)
        {
            this.pmfModifiedBOMFormulaSize(_bom, _bomVersion, _formDataSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfModifiedBOMFormulaSize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the change of the formula size on the version.
    /// </summary>
    /// <param name = "_bom">
    /// The current BOM record.
    /// </param>
    /// <param name = "_bomVersion">
    /// The current BOMVersion record.
    /// </param>
    /// <param name = "_formDataSource">
    /// Current form data source.
    /// </param>
    internal void pmfModifiedBOMFormulaSize(BOM _bom, BOMVersion _bomVersion, FormDataSource _formDataSource)
    {
        if (_bom.RecId && _bom.PmfScalable)
        {
            ttsbegin;

            BOM bomOrig = _bom.orig();

            BOMQty ratio = bomOrig.bomQty ? _bom.bomQty / bomOrig.bomQty : 1;

            BOMVersion bomVerUpd = bomVersion::findVersionCalculation(_bom.BOMId, true);

            if (bomVerUpd)
            {
                bomVerUpd.PmfBatchSize = bomVerUpd.PmfBatchSize * ratio;
                bomVerUpd.PdsCWSize = bomVerUpd.PdsCWSize * ratio;
                bomVerUpd.update();

                _bom.selectForUpdate(true);
                _bom.BOMQtySerie = bomVerUpd.PmfBatchSize;
                _bom.update();
            }

            BOM pmfBOM;
            while select forupdate pmfBOM
                where pmfBOM.BOMId == _bomVersion.BOMId
                    && pmfBOM.RecId != _bom.RecId
                    && pmfBOM.PmfScalable == NoYes::Yes
            {
                if (bomVerUpd)
                {
                    pmfBOM.bomQtySerie  = bomVerUpd.PmfBatchSize;
                }

                if (pmfBOM.PmfPctEnable)
                {
                    this.formulaPctModified(pmfBOM, bomVerUpd);
                }
                else if (pmfBOM.PmfScalable)
                {
                    pmfBOM.bomQty   = pmfBOM.bomQty * ratio;
                    pmfBOM.PdsCWQty = pmfBOM.PdsCWQty * ratio;
                }

                pmfBOM.update();
            }

            ttscommit;

            _formDataSource.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static PmfFormCtrl construct()
    {
        return new PmfFormCtrl();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>