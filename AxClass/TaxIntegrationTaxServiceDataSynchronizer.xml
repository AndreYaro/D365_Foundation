<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxIntegrationTaxServiceDataSynchronizer</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.TaxCalculation.ApiContracts;

/// <summary>
/// The <c>TaxIntegrationTaxServiceDataSynchronizer</c> class is used for synchronizing the tax feature setup.
/// </summary>
internal class TaxIntegrationTaxServiceDataSynchronizer
{
    private const TaxMasterDataSource TaxMasterDataSourceTaxService = TaxMasterDataSource::TaxService;

    private TaxTable taxTableTempDB;
    private TaxData taxDataTempDB;
    private TaxCollectLimit taxCollectLimitTempDB;
    private TaxGroupData taxGroupDataTempDB;
    private TaxOnItem taxOnItemTempDB;

    private TaxIntegrationFeatureSetupId featureSetupId;
    private TaxIntegrationTaxServiceDataSyncLogger logger;
    private SysInstrumentationLogger instrumentationLogger;

    private TaxCalculationParameter taxCalculationParameter;
    private TaxIntegrationTaxServiceParameters taxIntegrationTaxServiceParameters;
    private TaxIntegrationFeatureSetupVersion featureSetupVersion;
    private TaxIntegrationFeatureSetupName featureSetupName;
    private TaxSolutionProviderType solutionProviderType;
    private boolean isNotifyUserCalculationParameterChange;

    private Solution taxSolution;
    private Solution customerTaxSolution;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        taxTableTempDB.setTempDB();
        taxDataTempDB.setTempDB();
        taxCollectLimitTempDB.setTempDB();
        taxGroupDataTempDB.setTempDB();
        taxOnItemTempDB.setTempDB();

        logger = TaxIntegrationTaxServiceDataSyncLogger::construct();
        instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(classStr(TaxIntegrationTaxServiceDataSynchronizer));
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWithParameterTable</Name>
				<Source><![CDATA[
    internal static TaxIntegrationTaxServiceDataSynchronizer constructWithParameterTable(
        TaxIntegrationFeatureSetupId _featureSetupId,
        TaxIntegrationFeatureSetupVersion _featureVersion,
        TaxIntegrationFeatureSetupName _featureSetupName,
        TaxIntegrationTaxServiceParameters _taxIntegrationTaxServiceParameters = TaxIntegrationTaxServiceParameters::find())
    {
        TaxIntegrationTaxServiceDataSynchronizer synchronizer = new TaxIntegrationTaxServiceDataSynchronizer();

        synchronizer.parmFeatureSetupId(_featureSetupId);
        synchronizer.featureSetupVersion = _featureVersion;
        synchronizer.featureSetupName = _featureSetupName;
        synchronizer.taxIntegrationTaxServiceParameters = _taxIntegrationTaxServiceParameters;

        return synchronizer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFeatureSetupId</Name>
				<Source><![CDATA[
    public TaxIntegrationFeatureSetupId parmFeatureSetupId(TaxIntegrationFeatureSetupId _featureSetupId = featureSetupId)
    {
        featureSetupId = _featureSetupId;

        return featureSetupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSolutionProviderType</Name>
				<Source><![CDATA[
    public TaxSolutionProviderType parmSolutionProviderType(TaxSolutionProviderType _solutionProviderType = solutionProviderType)
    {
        solutionProviderType = _solutionProviderType;

        return solutionProviderType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes the tax feature setup data from global repository.
    /// </summary>
    /// <returns>ture if the synchronization completes successfully; otherwise, false.</returns>
    internal boolean synchronize()
    {
        const int DefaultMutexTimeOutInMinutes = 600;
        const str TaxIntegrationTaxServiceDataSyncMutexName = classStr(TaxIntegrationTaxServiceDataSynchronizer) + '|' + methodStr(TaxIntegrationTaxServiceDataSynchronizer, synchronize);

        boolean syncCompleted;
        TaxEngineReentrantInterProcessMutex mutex = new TaxEngineReentrantInterProcessMutex(TaxIntegrationTaxServiceDataSyncMutexName);

        using (SysInstrumentationActivityContext activityContext = instrumentationLogger.activityContext(funcName(), TaxIntegrationTaxServiceConstants::InstrumentationNamespace))
        {
            if (mutex.TryAcquire(DefaultMutexTimeOutInMinutes))
            {
                try
                {
                    this.synchronizeTaxFeature();

                    if (!this.showPrompt() || this.promptForUserInput())
                    {
                        ttsbegin;
                        this.synchronizeToRealTable();
                        ttscommit;
                        syncCompleted = true;

                        this.notifyUserForCalculationParameterChange();
                    }
                }
                catch (Exception::CLRError)
                {
                    var clrException = CLRInterop::getLastException();

                    if (clrException)
                    {
                        instrumentationLogger.logError(strFmt('Failed to synchronize tax feature setup %1. Exception: %2', featureSetupId, clrException.ToString()));
                    }

                    error("@SYS331662");
                }
                catch (Exception::Break)
                {
                    instrumentationLogger.logInformation('Synchronization cancelled.');
                }
                catch
                {
                    instrumentationLogger.logError(strFmt('An error occurred while synchronizing tax feature setup %1', featureSetupId));
                    error("@TaxIntegration:SynchronizationError");
                }
                finally
                {
                    mutex.Release();
                }
            }
            else
            {
                syncCompleted = false;
                error("@TaxIntegration:PreventConcurrentTaxServiceDataSyncErrorMessage");
            }

            if (syncCompleted)
            {
                instrumentationLogger.logInformation('Synchronization completed.');

                // After synchronizing, the TaxCache need to be refresh.
                TaxCache::clearAllScopes();

                Filename logFileName = logger.log();
                if (logFileName)
                {
                    info(strFmt("@TaxIntegration:SynchronizationCompleted", logFileName));
                }
                else
                {
                    info("@TaxIntegration:SynchronizationCompletedWithoutDataChanged");
                }
            }
        }

        return syncCompleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeTaxFeature</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchroizes the tax feature setup data and populates the data into temp table.
    /// </summary>
    internal void synchronizeTaxFeature()
    {
        using (SysInstrumentationActivityContext activityContext = instrumentationLogger.activityContext(funcName(), TaxIntegrationTaxServiceConstants::InstrumentationNamespace))
        {
            this.retrieveAndVerifyTaxSolution(featureSetupId);

            activityContext.addCustomProperty(TaxIntegrationTaxServiceConstants::TaxFeatureSetupId, featureSetupId);
            activityContext.addCustomProperty(TaxIntegrationTaxServiceConstants::TaxFeatureSetupName, taxSolution.Name);

            TaxIntegrationITaxFeatureSetupTransformer taxFeatureSetupTransformer = TaxIntegrationTaxFeatureSetupTransformer::construct(taxSolution);
            TaxIntegrationTaxFeatureSetupSyncContract taxFeatureSetupSyncContract = taxFeatureSetupTransformer.convertTaxFeatureSetupToRecordList();

            this.populateTaxCaclulationParameter(taxSolution.Parameter);
            this.populateTaxCodeIntoTempTable(taxFeatureSetupSyncContract);
            this.populateTaxDataIntoTempTable(taxFeatureSetupSyncContract);
            this.populateTaxLimitIntoTempTable(taxFeatureSetupSyncContract);
            this.populateTaxGroupDataIntoTempTable(taxFeatureSetupSyncContract);
            this.populateTaxOnItemIntoTempTable(taxFeatureSetupSyncContract);
            this.postPopulate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveAndVerifyTaxSolution</Name>
				<Source><![CDATA[
    private void retrieveAndVerifyTaxSolution(TaxIntegrationFeatureSetupId _featureSetupId)
    {
        TaxEngineServicePlusProxy proxy = new TaxEngineServicePlusProxy();
        SolutionAggregator result = proxy.getTaxFeatureSetupById(_featureSetupId);
        taxSolution = result.Value;

        if (FeatureStateProvider::isFeatureEnabled(TaxServiceUniversalTaxRateAPIFeature::instance()))
        {
            TaxServiceFeatureTypes taxFeatureType = TaxServiceISVUtils::getTaxFeatureTypesFromSolution(taxSolution.TaxFeatureType);
            if (taxFeatureType == TaxServiceFeatureTypes::TaxFeature)
            {
                if (this.parmSolutionProviderType() == TaxSolutionProviderType::ISV)
                {
                    throw error(strFmt("@TaxIntegrationException:FeatureNotAllowedForProvider", taxFeatureType, "@TaxIntegration:TaxSolutionProvider"));
                }
            }
            else if (taxFeatureType == TaxServiceFeatureTypes::CustomerISVFeature)
            {
                if (this.parmSolutionProviderType() == TaxSolutionProviderType::Microsoft)
                {
                    throw error(strFmt("@TaxIntegrationException:FeatureNotAllowedForProvider", taxFeatureType, "@TaxIntegration:AdvancedTaxCalculation"));
                }

                if (TaxEngineServiceUpgradeToGTEPlusFlight::instance().isEnabled())
                {
                    this.validateKeyVaultParameter(taxSolution);
                }

                TaxServiceISVCustomizeFeatureGeneralSettings customizedISVFeatureSetting = taxSolution.TaxServiceCustomerISVFeature.CustomizeFeatureGeneralSettings;
                SolutionAggregator isvFeatureResult = proxy.getTaxFeatureSetupById(
                        strFmt(TaxIntegrationTaxServiceConstants::FeatureIdFormat, strLwr(customizedISVFeatureSetting.ISVFeatureGuid), customizedISVFeatureSetting.ISVFeatureVersion));

                customerTaxSolution = taxSolution;
                taxSolution = isvFeatureResult.Value;
            }
            else if (taxFeatureType == TaxServiceFeatureTypes::ISVFeature)
            {
                throw error(strFmt("@TaxIntegrationException:ISVFeatureCalcTaxNotAllowed", taxSolution.Name));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateKeyVaultParameter</Name>
				<Source><![CDATA[
    private void validateKeyVaultParameter(Solution _taxSolution)
    {
        if (_taxSolution != null
            && _taxSolution.TaxServiceCustomerISVFeature != null
            && _taxSolution.TaxServiceCustomerISVFeature.CustomizeFeatureGeneralSettings)
        {
            var isvGeneralSettings = _taxSolution.TaxServiceCustomerISVFeature.CustomizeFeatureGeneralSettings;
            if (isvGeneralSettings
                && isvGeneralSettings.ClientId
                && isvGeneralSettings.ClientSecret)
            {
                if (!KeyVaultCertificateTable::findByName(isvGeneralSettings.ClientId).RecId
                    || !KeyVaultCertificateTable::findByName(isvGeneralSettings.ClientSecret).RecId)
                {
                    if (Box::yesNo(strFmt("@TaxIntegration:KeyVaultCheckWhenAcitveISV", isvGeneralSettings.ClientId, isvGeneralSettings.ClientSecret, curext()), DialogButton::No) == DialogButton::No)
                    {
                        throw warning("@TaxIntegration:SynchronizationCancled");
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxCaclulationParameter</Name>
				<Source><![CDATA[
    private void populateTaxCaclulationParameter(TaxCalculationParameter _taxCalculationParameter)
    {
        this.taxCalculationParameter = _taxCalculationParameter;
        if (this.taxCalculationParameter && taxIntegrationTaxServiceParameters.DisableCalculationParameter == false)
        {
            // Just when DisableCalculationParameter change from false to true, user should be notified.
            this.isNotifyUserCalculationParameterChange = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxCodeIntoTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the tax codes into temporary table.
    /// </summary>
    /// <param name = "_taxFeatureSetupSyncContract">A instance of <c>TaxIntegrationTaxFeatureSetupSyncContract</c>.</param>
    private void populateTaxCodeIntoTempTable(TaxIntegrationTaxFeatureSetupSyncContract _taxFeatureSetupSyncContract)
    {
        ListEnumerator taxTableListEnumerator = _taxFeatureSetupSyncContract.getTaxTableList().getEnumerator();
        while (taxTableListEnumerator.moveNext())
        {
            TaxTable taxTableFromTaxService = taxTableListEnumerator.current();

            taxTableTempDB.clear();
            taxTableTempDB.TaxCode = taxTableFromTaxService.TaxCode;
            taxTableTempDB.TaxName = taxTableFromTaxService.TaxName;
            taxTableTempDB.TaxCurrencyCode = Ledger::accountingCurrency();
            taxTableTempDB.TaxBase = taxTableFromTaxService.TaxBase;
            taxTableTempDB.TaxOnTax = taxTableFromTaxService.TaxOnTax;
            taxTableTempDB.TaxUnit = taxTableFromTaxService.TaxUnit;
            taxTableTempDB.TaxPackagingTax = taxTableFromTaxService.TaxPackagingTax;
            taxTableTempDB.TaxIncludeInTax = taxTableFromTaxService.TaxIncludeInTax;

            taxTableTempDB.doInsert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxDataIntoTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the tax rates into temporary table.
    /// </summary>
    /// <param name = "_taxFeatureSetupSyncContract">A instance of <c>TaxIntegrationTaxFeatureSetupSyncContract</c>.</param>
    private void populateTaxDataIntoTempTable(TaxIntegrationTaxFeatureSetupSyncContract _taxFeatureSetupSyncContract)
    {
        ListEnumerator taxDataListEnumerator = _taxFeatureSetupSyncContract.getTaxDataList().getEnumerator();
        while (taxDataListEnumerator.moveNext())
        {
            TaxData taxDataFromTaxService = taxDataListEnumerator.current();

            taxDataTempDB.TaxCode = taxDataFromTaxService.TaxCode;
            taxDataTempDB.TaxFromDate = taxDataFromTaxService.TaxFromDate;
            taxDataTempDB.TaxToDate = taxDataFromTaxService.TaxToDate;
            taxDataTempDB.TaxLimitMin = taxDataFromTaxService.TaxLimitMin;
            taxDataTempDB.TaxLimitMax = taxDataFromTaxService.TaxLimitMax;
            taxDataTempDB.TaxValue = taxDataFromTaxService.TaxValue;
            taxDataTempDB.VATExemptPct = taxDataFromTaxService.VATExemptPct;
            taxDataTempDB.doInsert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxLimitIntoTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the tax limits into temporary table.
    /// </summary>
    /// <param name = "_taxFeatureSetupSyncContract">A instance of <c>TaxIntegrationTaxFeatureSetupSyncContract</c>.</param>
    private void populateTaxLimitIntoTempTable(TaxIntegrationTaxFeatureSetupSyncContract _taxFeatureSetupSyncContract)
    {
        ListEnumerator taxLimitListEnumerator = _taxFeatureSetupSyncContract.getTaxLimitList().getEnumerator();
        while (taxLimitListEnumerator.moveNext())
        {
            TaxCollectLimit taxLimitFromTaxService = taxLimitListEnumerator.current();

            taxCollectLimitTempDB.TaxCode = taxLimitFromTaxService.TaxCode;
            taxCollectLimitTempDB.TaxFromDate = taxLimitFromTaxService.TaxFromDate;
            taxCollectLimitTempDB.TaxToDate = taxLimitFromTaxService.TaxToDate;
            taxCollectLimitTempDB.TaxMin = taxLimitFromTaxService.TaxMin;
            taxCollectLimitTempDB.TaxMax = taxLimitFromTaxService.TaxMax;
            taxCollectLimitTempDB.doInsert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxGroupDataIntoTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the tax group setup into temporary table.
    /// </summary>
    /// <param name = "_taxFeatureSetupSyncContract">A instance of <c>TaxIntegrationTaxFeatureSetupSyncContract</c>.</param>
    private void populateTaxGroupDataIntoTempTable(TaxIntegrationTaxFeatureSetupSyncContract _taxFeatureSetupSyncContract)
    {
        ListEnumerator taxGroupDataListEnumerator = _taxFeatureSetupSyncContract.getTaxGroupDataList().getEnumerator();
        while (taxGroupDataListEnumerator.moveNext())
        {
            TaxGroupData taxGroupDataFromTaxService = taxGroupDataListEnumerator.current();

            taxGroupDataTempDB.TaxGroup = taxGroupDataFromTaxService.TaxGroup;
            taxGroupDataTempDB.TaxCode = taxGroupDataFromTaxService.TaxCode;
            taxGroupDataTempDB.ExemptTax = taxGroupDataFromTaxService.ExemptTax;
            taxGroupDataTempDB.TaxExemptCode = taxGroupDataFromTaxService.TaxExemptCode;
            taxGroupDataTempDB.UseTax = taxGroupDataFromTaxService.UseTax;

            if (ReverseChargeTaxSetupToggle::isReverseChargeUIEnabled())
            {
                taxGroupDataTempDB.ReverseCharge_W = taxGroupDataFromTaxService.ReverseCharge_W;
            }
            taxGroupDataTempDB.doInsert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxOnItemIntoTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the item sales tax group setup into temporary table.
    /// </summary>
    /// <param name = "_taxFeatureSetupSyncContract">A instance of <c>TaxIntegrationTaxFeatureSetupSyncContract</c>.</param>
    private void populateTaxOnItemIntoTempTable(TaxIntegrationTaxFeatureSetupSyncContract _taxFeatureSetupSyncContract)
    {
        ListEnumerator taxOnItemListEnumerator = _taxFeatureSetupSyncContract.getTaxOnItemList().getEnumerator();
        while (taxOnItemListEnumerator.moveNext())
        {
            TaxOnItem taxOnItemFromTaxService = taxOnItemListEnumerator.current();

            taxOnItemTempDB.TaxItemGroup = taxOnItemFromTaxService.TaxItemGroup;
            taxOnItemTempDB.TaxCode = taxOnItemFromTaxService.TaxCode;
            taxOnItemTempDB.doInsert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForUserInput</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts a dialog for user input.
    /// </summary>
    /// <returns>true if user finishes input and clicks confirm; otherwise, false.</returns>
    internal boolean promptForUserInput()
    {
        Args args;

        args = new Args(formStr(TaxIntegrationTaxServiceTaxCodes));
        args.parm(taxTableTempDB.getPhysicalTableName());

        FormRun formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait(true);

        if (formRun.closedOk())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a prompt dialog should be shown for user input.
    /// </summary>
    /// <returns>ture if need to prompt a dialog; otherwise, false.</returns>
    internal boolean showPrompt()
    {
        TaxTable taxTableExisting;

        select firstonly TaxCode, TaxName, TaxPeriod, TaxAccountGroup, TaxCurrencyCode from taxTableTempDB
            notexists join taxTableExisting
            where taxTableExisting.TaxCode == taxTableTempDB.TaxCode;

        return taxTableTempDB.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeToRealTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the data in temp table into real table.
    /// </summary>
    internal void synchronizeToRealTable()
    {
        this.synchronizeTaxTable();
        this.synchronizeTaxData();
        this.synchronizeTaxCollectLimit();
        this.synchronizeTaxGroup();
        this.synchronizeTaxItemGroup();
        this.sychronizeTaxIntegrationTaxServiceParameter();

        if (this.parmSolutionProviderType() == TaxSolutionProviderType::ISV)
        {
            this.sychronizeISVApiTypes();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sychronizeTaxIntegrationTaxServiceParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>TaxIntegrationTaxServiceParameters</c>.
    /// </summary>
    internal void sychronizeTaxIntegrationTaxServiceParameter()
    {
        taxIntegrationTaxServiceParameters.selectForUpdate(true);

        if (this.parmSolutionProviderType() == TaxSolutionProviderType::Microsoft)
        {
            taxIntegrationTaxServiceParameters.FeatureSetupId = this.featureSetupId;
            taxIntegrationTaxServiceParameters.FeatureSetupName = this.featureSetupName;
            taxIntegrationTaxServiceParameters.FeatureSetupVersion = this.featureSetupVersion;
            taxIntegrationTaxServiceParameters.DisableCalculationParameter = this.taxCalculationParameter != null;
            if (this.taxCalculationParameter)
            {
                // Solution.Parameter is not null means the calculation parameter is enabled on RCS, so the calculation parameter in TaxCalculationInput.Parameter is not used in runtime
                // In case new parameters need to add in the future, if they are using same switch in current RCS, Then add it into the TaxCalculationParameter in contracts.
                // if something is specified in F&O, then new parameter class should be introduced.
                taxIntegrationTaxServiceParameters.RoundOff = this.taxCalculationParameter.CurrencyRoundingTo;
                taxIntegrationTaxServiceParameters.RoundOffCalculationMethod = TaxIntegrationCalculationServiceUtils::taxCalculationMethodToTaxRoundOffCalculationMethod(this.taxCalculationParameter.CalculationMethod);
                taxIntegrationTaxServiceParameters.RoundOffPrinciple = TaxIntegrationCalculationServiceUtils::roundingPrincipleToTaxRoundOffPrinciple(this.taxCalculationParameter.RoundingPrinciple);
                taxIntegrationTaxServiceParameters.RoundOffType = TaxIntegrationCalculationServiceUtils::taxDocumentRoundingOffTypeToRoundOffType(this.taxCalculationParameter.CurrencyRoundingType);
            }
        }
        else if (this.parmSolutionProviderType() == TaxSolutionProviderType::ISV)
        {
            taxIntegrationTaxServiceParameters.ISVFeatureSetupId = this.featureSetupId;
            taxIntegrationTaxServiceParameters.ISVFeatureSetupName = this.featureSetupName;
            taxIntegrationTaxServiceParameters.ISVFeatureSetupVersion = this.featureSetupVersion;
        }

        taxIntegrationTaxServiceParameters.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeTaxTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the <c>TaxTable</c>.
    /// </summary>
    internal void synchronizeTaxTable()
    {
        logger.populateLogTableForTaxTable(taxTableTempDB, taxDataTempDB);

        TaxTable taxTable;
        TaxTable taxTableExisting;

        taxTable.skipDataMethods(true);

        // Update tax origin and tax on tax if the tax code exists and tax origin or tax on tax changed.
        update_recordset taxTable
            setting TaxOnTax = taxTableTempDB.TaxOnTax, TaxBase = taxTableTempDB.TaxBase, TaxUnit = taxTableTempDB.TaxUnit, TaxPackagingTax = taxTableTempDB.TaxPackagingTax, TaxIncludeInTax = taxTableTempDB.TaxIncludeInTax
            join TaxOnTax, TaxBase, TaxUnit, TaxPackagingTax, TaxIncludeInTax from taxTableTempDB
                where taxTableTempDB.TaxCode == taxTable.TaxCode
                    && (taxTableTempDB.TaxOnTax != taxTable.TaxOnTax 
                        || taxTableTempDB.TaxBase != taxTable.TaxBase
                        || taxTableTempDB.TaxUnit != taxTable.TaxUnit
                        || taxTableTempDB.TaxPackagingTax != taxTable.TaxPackagingTax
                        || taxTableTempDB.TaxIncludeInTax != taxTable.TaxIncludeInTax
                        );

        insert_recordset taxTable (TaxCode, TaxName, TaxPeriod, TaxAccountGroup, TaxCurrencyCode, Source, TaxType_JP, TaxType_MX, TaxType_TH, TaxBase, TaxOnTax, TaxUnit, TaxPackagingTax, TaxIncludeInTax)
            select TaxCode, TaxName, TaxPeriod, TaxAccountGroup, TaxCurrencyCode, TaxMasterDataSourceTaxService, TaxType_JP, TaxType_MX, TaxType_TH, TaxBase, TaxOnTax, TaxUnit, TaxPackagingTax, TaxIncludeInTax from taxTableTempDB
                notexists join taxTableExisting
                where taxTableExisting.TaxCode == taxTableTempDB.TaxCode;

        update_recordset taxTable
            setting NegativeTax = true
            where taxTable.NegativeTax == false
            exists join taxDataTempDB
                where taxDataTempDB.TaxCode == taxTable.TaxCode
                    && taxDataTempDB.TaxValue < 0;

        // If the tax code is configured in tax feature, then update the Source to TaxService
        update_recordset taxTable
            setting Source = TaxMasterDataSource::TaxService
            where taxTable.Source != TaxMasterDataSource::TaxService
            exists join taxTableTempDB
                where taxTableTempDB.TaxCode == taxTable.TaxCode;

        // To ensure tax master data (TaxTable/TaxGroup/TaxItmeGroup) with source = TaxService is consistent with current tax configuration
        // If the tax code is not yet used in new tax feature setup, update Source field to Manual
        update_recordset taxTable
            setting Source = TaxMasterDataSource::Manual
            where taxTable.Source == TaxMasterDataSource::TaxService
            notexists join taxTableTempDB
                where taxTableTempDB.TaxCode == taxTable.TaxCode;

    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeTaxData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the <c>TaxData</c>.
    /// </summary>
    internal void synchronizeTaxData()
    {
        TaxData taxData;
        TaxData taxDataChanging;
        TaxData taxDataExisting;

        taxDataChanging.setTempDB();

        // TaxData that created or updated in RCS
        insert_recordset taxDataChanging (TaxCode)
            select TaxCode from taxDataTempDB
                group by taxDataTempDB.TaxCode
                notexists join taxDataExisting
                where taxDataExisting.TaxCode == taxDataTempDB.TaxCode
                    && taxDataExisting.TaxFromDate == taxDataTempDB.TaxFromDate
                    && taxDataExisting.TaxToDate == taxDataTempDB.TaxToDate
                    && taxDataExisting.TaxLimitMin == taxDataTempDB.TaxLimitMin
                    && taxDataExisting.TaxLimitMax == taxDataTempDB.TaxLimitMax
                    && taxDataExisting.TaxValue == taxDataTempDB.TaxValue
                    && taxDataExisting.VATExemptPct == taxDataTempDB.VATExemptPct;

        // TaxData that removed in RCS
        insert_recordset taxDataChanging (TaxCode)
            select TaxCode from taxDataExisting
                group by taxDataExisting.TaxCode
                exists join taxTableTempDB
                    where taxTableTempDB.TaxCode == taxDataExisting.TaxCode
                notexists join taxDataTempDB
                    where taxDataTempDB.TaxCode == taxDataExisting.TaxCode
                        && taxDataTempDB.TaxFromDate == taxDataExisting.TaxFromDate
                        && taxDataTempDB.TaxToDate == taxDataExisting.TaxToDate
                        && taxDataTempDB.TaxLimitMin == taxDataExisting.TaxLimitMin
                        && taxDataTempDB.TaxLimitMax == taxDataExisting.TaxLimitMax
                        && taxDataTempDB.TaxValue == taxDataExisting.TaxValue
                        && taxDataTempDB.VATExemptPct == taxDataExisting.VATExemptPct;

        select firstonly RecId from taxDataChanging;
        if (taxDataChanging)
        {
            logger.populateLogTableForTaxData(taxDataTempDB, taxDataChanging);

            taxData.skipDeleteMethod(true);
            taxData.skipDataMethods(true);

            delete_from taxData
                exists join taxDataChanging
                where taxDataChanging.TaxCode == taxData.TaxCode;

            insert_recordset taxData (TaxCode, TaxFromDate, TaxToDate, TaxLimitMin, TaxLimitMax, TaxValue, VATExemptPct)
                select TaxCode, TaxFromDate, TaxToDate, TaxLimitMin, TaxLimitMax, TaxValue, VATExemptPct from taxDataTempDB
                    exists join taxDataChanging
                    where taxDataChanging.TaxCode == taxDataTempDB.TaxCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeTaxCollectLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the <c>TaxCollectLimit</c>.
    /// </summary>
    internal void synchronizeTaxCollectLimit()
    {
        TaxCollectLimit taxCollectLimit;
        TaxCollectLimit taxCollectLimitChanging;
        TaxCollectLimit taxCollectLimitExisting;

        taxCollectLimitChanging.setTempDB();

        insert_recordset taxCollectLimitChanging (TaxCode)
            select TaxCode from taxCollectLimitTempDB
                group by taxCollectLimitTempDB.TaxCode
                notexists join  taxCollectLimitExisting
                where taxCollectLimitExisting.TaxCode == taxCollectLimitTempDB.TaxCode
                    && taxCollectLimitExisting.TaxFromDate == taxCollectLimitTempDB.TaxFromDate
                    && taxCollectLimitExisting.TaxToDate == taxCollectLimitTempDB.TaxToDate
                    && taxCollectLimitExisting.TaxMin == taxCollectLimitTempDB.TaxMin
                    && taxCollectLimitExisting.TaxMax == taxCollectLimitTempDB.TaxMax;

        insert_recordset taxCollectLimitChanging (TaxCode)
            select TaxCode from taxCollectLimitExisting
                group by taxCollectLimitExisting.TaxCode
                exists join taxTableTempDB
                    where taxTableTempDB.TaxCode == taxCollectLimitExisting.TaxCode
                notexists join taxCollectLimitTempDB
                    where taxCollectLimitTempDB.TaxCode == taxCollectLimitExisting.TaxCode
                        && taxCollectLimitTempDB.TaxFromDate == taxCollectLimitExisting.TaxFromDate
                        && taxCollectLimitTempDB.TaxToDate == taxCollectLimitExisting.TaxToDate
                        && taxCollectLimitTempDB.TaxMin == taxCollectLimitExisting.TaxMin
                        && taxCollectLimitTempDB.TaxMax == taxCollectLimitExisting.TaxMax;

        select firstonly RecId from taxCollectLimitChanging;
        if (taxCollectLimitChanging)
        {
            logger.populateLogTableForTaxCollectLimit(taxCollectLimitTempDB, taxCollectLimitChanging);

            delete_from taxCollectLimit
                exists join taxCollectLimitChanging
                where taxCollectLimitChanging.TaxCode == taxCollectLimit.TaxCode;

            insert_recordset taxCollectLimit (TaxCode, TaxFromDate, TaxToDate, TaxMin, TaxMax)
                select TaxCode, TaxFromDate, TaxToDate, TaxMin, TaxMax from taxCollectLimitTempDB
                    exists join taxCollectLimitChanging
                    where taxCollectLimitChanging.TaxCode == taxCollectLimitTempDB.TaxCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the <c>TaxGroupData</c>.
    /// </summary>
    internal void synchronizeTaxGroup()
    {
        logger.populateLogTableForTaxGroupData(taxGroupDataTempDB);

        this.createAndUpdateTaxGroupHeader();
        this.createTaxExemptCode();

        TaxGroupData taxGroupData;
        TaxGroupData taxGroupDataExisting;

        taxGroupData.skipDataMethods(true);

        update_recordset taxGroupData
            setting ExemptTax = taxGroupDataTempDB.ExemptTax,
                    TaxExemptCode = taxGroupDataTempDB.TaxExemptCode,
                    UseTax = taxGroupDataTempDB.UseTax,
                    ReverseCharge_W = taxGroupDataTempDB.ReverseCharge_W
            join ExemptTax, TaxExemptCode, UseTax, ReverseCharge_W from taxGroupDataTempDB
                where taxGroupData.TaxCode == taxGroupDataTempDB.TaxCode
                    && taxGroupData.TaxGroup == taxGroupDataTempDB.TaxGroup
                    && (taxGroupData.ExemptTax != taxGroupDataTempDB.ExemptTax
                        || taxGroupData.TaxExemptCode != taxGroupDataTempDB.TaxExemptCode
                        || taxGroupData.UseTax != taxGroupDataTempDB.UseTax
                        || taxGroupData.ReverseCharge_W != taxGroupDataTempDB.ReverseCharge_W);

        insert_recordset taxGroupData (TaxCode, TaxGroup, ExemptTax, TaxExemptCode, UseTax, ReverseCharge_W)
            select TaxCode, TaxGroup, ExemptTax, TaxExemptCode, UseTax, ReverseCharge_W from taxGroupDataTempDB
                where taxGroupDataTempDB.TaxGroup != ''
                    && taxGroupDataTempDB.TaxCode != ''
                notexists join taxGroupDataExisting
                    where taxGroupDataExisting.TaxCode == taxGroupDataTempDB.TaxCode
                        && taxGroupDataExisting.TaxGroup == taxGroupDataTempDB.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndUpdateTaxGroupHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax group header and updated the <c>Source</c> field accordingly.
    /// </summary>
    private void createAndUpdateTaxGroupHeader()
    {
        TaxGroupHeading taxGroup;
        TaxGroupHeading taxGroupExisting;

        // Ensure that tax group heading exists.
        insert_recordset taxGroup (TaxGroup, Source)
            select TaxGroup, TaxMasterDataSourceTaxService from taxGroupDataTempDB
                group by taxGroupDataTempDB.TaxGroup
                notexists join taxGroupExisting
                    where taxGroupExisting.TaxGroup == taxGroupDataTempDB.TaxGroup;

        // If the tax group is configured in tax feature, then update the Source to TaxService
        update_recordset taxGroup
            setting Source = TaxMasterDataSource::TaxService
            where taxGroup.Source != TaxMasterDataSource::TaxService
            exists join taxGroupDataTempDB
                where taxGroupDataTempDB.TaxGroup == taxGroup.TaxGroup;

        // To ensure tax master data (TaxTable/TaxGroup/TaxItmeGroup) with source = TaxService is consistent with current tax configuration
        // If the tax group is not yet used in new tax feature setup, update Source field to Manual
        update_recordset taxGroup
            setting Source = TaxMasterDataSource::Manual
            where taxGroup.Source == TaxMasterDataSource::TaxService
            notexists join taxGroupDataTempDB
                where taxGroupDataTempDB.TaxGroup == taxGroup.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxExemptCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax exempt code.
    /// </summary>
    private void createTaxExemptCode()
    {
        TaxExemptCodeTable exemptCodeTable;
        TaxExemptCodeTable exemptCodeTableExisting;

        // Insert exempt code if not exist.
        insert_recordset exemptCodeTable (ExemptCode)
            select TaxExemptCode from taxGroupDataTempDB
                group by taxGroupDataTempDB.TaxExemptCode
                where taxGroupDataTempDB.TaxExemptCode != ''
                notexists join exemptCodeTableExisting
                    where exemptCodeTableExisting.ExemptCode == taxGroupDataTempDB.TaxExemptCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the <c>TaxOnItem</c>.
    /// </summary>
    internal void synchronizeTaxItemGroup()
    {
        logger.populateLogTableForTaxOnItem(taxOnItemTempDB);

        this.creatAndUpdateTaxItemGroupHeader();

        TaxOnItem taxOnItem;
        TaxOnItem taxOnItemExisting;

        taxOnItem.skipDataMethods();

        insert_recordset taxOnItem (TaxCode, TaxItemGroup)
            select TaxCode, TaxItemGroup from taxOnItemTempDB
                where taxOnItemTempDB.TaxItemGroup != ''
                    && taxOnItemTempDB.TaxCode != ''
                notexists join taxOnItemExisting
                    where taxOnItemExisting.TaxCode == taxOnItemTempDB.TaxCode
                        && taxOnItemExisting.TaxItemGroup == taxOnItemTempDB.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creatAndUpdateTaxItemGroupHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates item tax group header and updated the <c>Source</c> field accordingly.
    /// </summary>
    private void creatAndUpdateTaxItemGroupHeader()
    {
        TaxItemGroupHeading taxItemGroup;
        TaxItemGroupHeading taxItemGroupExisting;

        // Ensure that tax item group heading exists.
        insert_recordset taxItemGroup (TaxItemGroup, Source)
            select TaxItemGroup, TaxMasterDataSourceTaxService from taxOnItemTempDB
                group by taxOnItemTempDB.TaxItemGroup
                notexists join taxItemGroupExisting
                    where taxItemGroupExisting.TaxItemGroup == taxOnItemTempDB.TaxItemGroup;

        // If the tax item group is configured in tax feature, then update the Source to TaxService
        update_recordset taxItemGroup
            setting Source = TaxMasterDataSource::TaxService
            where taxItemGroup.Source != TaxMasterDataSource::TaxService
            exists join taxOnItemTempDB
                where taxOnItemTempDB.TaxItemGroup == taxItemGroup.TaxItemGroup;

        // To ensure tax master data (TaxTable/TaxGroup/TaxItmeGroup) with source = TaxService is consistent with current tax configuration
        // If the tax item group is not yet used in new tax feature setup, update Source field to Manual
        update_recordset taxItemGroup
            setting Source = TaxMasterDataSource::Manual
            where taxItemGroup.Source == TaxMasterDataSource::TaxService
            notexists join taxOnItemTempDB
                where taxOnItemTempDB.TaxItemGroup == taxItemGroup.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sychronizeISVApiTypes</Name>
				<Source><![CDATA[
    private void sychronizeISVApiTypes()
    {
        if (!customerTaxSolution || !taxSolution)
        {
            return;
        }

        str environmentName = customerTaxSolution.TaxServiceCustomerISVFeature.CustomizeFeatureGeneralSettings.Environment;

        System.Collections.IEnumerable isvEnvironments = taxSolution.TaxServiceISVFeature.ISVEnvironments;
        System.Collections.IEnumerator isvEnvListEnumerator = isvEnvironments.GetEnumerator();
        TaxServiceISVEnvironment isvEnvironment;

        while (isvEnvListEnumerator.MoveNext())
        {
            isvEnvironment = isvEnvListEnumerator.Current;

            if (isvEnvironment.Name == environmentName)
            {
                TaxIntegrationISVApiType isvAPIType;

                delete_from isvAPIType;

                System.Collections.IEnumerable isvAPIs = isvEnvironment.Apis;
                System.Collections.IEnumerator isvAPIListEnumerator = isvAPIs.GetEnumerator();

                while (isvAPIListEnumerator.MoveNext())
                {
                    TaxServiceISVApi isvAPI = isvAPIListEnumerator.Current;

                    isvAPIType.ISVApiType = TaxServiceISVUtils::getTaxServiceISVApiTypes(isvAPI.Type);
                    isvAPIType.insert();
                }
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>notifyUserForCalculationParameterChange</Name>
				<Source><![CDATA[
    private void notifyUserForCalculationParameterChange()
    {
        if (this.isNotifyUserCalculationParameterChange)
        {
            Box::info("@TaxIntegration:SynchronizationRoundingInfo");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPopulate</Name>
				<Source><![CDATA[
    private void postPopulate()
    {
        // Set NegativeTax to true if tax rate is negative for taxTable
        TaxTable taxTableExisting;
        update_recordset taxTableTempDB
            setting NegativeTax = true
            join RecId from taxTableExisting
                where taxTableExisting.NegativeTax == false
                    && taxTableExisting.TaxCode == taxTableTempDB.TaxCode
            exists join taxDataTempDB
                where taxDataTempDB.TaxCode == taxTableExisting.TaxCode
                    && taxDataTempDB.TaxValue < 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>