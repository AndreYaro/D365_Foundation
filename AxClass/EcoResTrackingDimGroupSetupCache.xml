<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EcoResTrackingDimGroupSetupCache</Name>
	<SourceCode>
		<Declaration><![CDATA[
class EcoResTrackingDimGroupSetupCache
{
    #Define.ActiveKey('Active')
    #Define.PrimaryKey('Primary')
    #Define.FinancialInventoryKey('FinancialInventory')
    #Define.PhysicalInventoryKey('PhysicalInventory')
    #Define.CoveragePlanByDimensionKey('CoveragePlanByDimension')
    #Define.PurchPriceKey('PurchPrice')
    #Define.SalesPriceKey('SalesPrice')
    #Define.ActiveAllGroupKey('ActiveAllGroup')
    #Define.ActivePhysicalAllGroupKey('ActivePhysicalAllGroup')
    #Define.AllPriceDiscKey('AllPriceDisc')
    #Define.AllCovKey('AllCovDisc')
    #Define.notAllowBlankReceiptKey('notAllowBlankReceipt')
    #Define.notAllowBlankIssueKey('notAllowBlankIssue')
    #Define.SalesProcessActivatedKey('SalesProcessActivated')
    #Define.SalesProcessActivatedNotAllowBlankIssueKey('SalesProcessActivatedNoAllowBlankIssue')
    #Define.AnySalesProcessActivatedKey('AnySalesProcessActivated')
    #Define.anyAllowBlankIssue('anyAllowBlankIssue')
    #Define.IsBlankReceiptAllowedForBatchOrSerialDimension('IsBlankReceiptAllowedForBatchOrSerialDimension')

    #Define.MandatoryKey('Mandatory')
    #Define.ConsistentKey('Consistent')

    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>active</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm active(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#ActiveKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyAllowBlankIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if any of the tracking dimensions for a group allows blank issue.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// The ID of the tracking dimension group.
    /// </param>
    /// <returns>
    /// true if any of the tracking dimensions allow blank issue; otherwise, false.
    /// </returns>
    public static boolean anyAllowBlankIssue(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container                               key     = [#anyAllowBlankIssue, _trackingDimensionGroup];
        boolean                                 anyAllowBlankIssue = false;

        SysGlobalObjectCache                    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope                  classScope              = EcoResTrackingDimGroupSetupCache::classScope();

        container packedCacheValue = sysGlobalObjectCache.find(classScope , key);

        if (!packedCacheValue || conLen(packedCacheValue) == 0)
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(_trackingDimensionGroup).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isAllowBlankIssueEnabled())
                {
                    anyAllowBlankIssue = true;
                    break;
                }
            }

            sysGlobalObjectCache.insert(classScope, key, [anyAllowBlankIssue]);
        }
        else
        {
            [anyAllowBlankIssue] = packedCacheValue;
        }

        return anyAllowBlankIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlankReceiptAllowedForBatchOrSerialDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if any of the serial or batch tracking dimensions for a group allows blank receipt.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// The ID of the tracking dimension group.
    /// </param>
    /// <returns>
    /// true if any of the serial or batch tracking dimensions allow blank receipt; otherwise, false.
    /// </returns>
    public static boolean isBlankReceiptAllowedForBatchOrSerialDimension(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container                               key     = [#IsBlankReceiptAllowedForBatchOrSerialDimension, _trackingDimensionGroup];
        boolean                                 isBlankReceiptAllowedForBatchOrSerialDimension = false;

        SysGlobalObjectCache                    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope                  classScope              = EcoResTrackingDimGroupSetupCache::classScope();

        container packedCacheValue = sysGlobalObjectCache.find(classScope , key);

        if (!packedCacheValue || conLen(packedCacheValue) == 0)
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(_trackingDimensionGroup).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();
                FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                if ((    inventDimFieldId == fieldnum(InventDim, InventBatchId)
                      || inventDimFieldId == fieldNum(InventDim, inventSerialId))
                && inventDimGroupFieldSetup.isActive()
                && inventDimGroupFieldSetup.isAllowBlankReceiptEnabled())
                {
                    isBlankReceiptAllowedForBatchOrSerialDimension = true;
                    break;
                }
            }

            sysGlobalObjectCache.insert(classScope, key, [isBlankReceiptAllowedForBatchOrSerialDimension]);
        }
        else
        {
            [isBlankReceiptAllowedForBatchOrSerialDimension] = packedCacheValue;
        }

        return isBlankReceiptAllowedForBatchOrSerialDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>classScope</Name>
				<Source><![CDATA[
    private static GlobalObjectCacheScope classScope()
    {
        return classStr(EcoResTrackingDimGroupSetupCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    public static void clearCache()
    {
        if (xGlobal::hasClient())
        {
            EcoResTrackingDimGroupSetupCache::clearCacheClient();
        }
        EcoResTrackingDimGroupSetupCache::clearCacheServer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheClient</Name>
				<Source><![CDATA[
    private static void clearCacheClient()
    {
        classfactory.globalObjectCache().clear(EcoResTrackingDimGroupSetupCache::classScope());
        InventDimGroupSetup::clearCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheServer</Name>
				<Source><![CDATA[
    private static void clearCacheServer()
    {
        classfactory.globalObjectCache().clear(EcoResTrackingDimGroupSetupCache::classScope());
        InventDimGroupSetup::clearCache();
        SalesPurchLineInterface::flushPriceDiscCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>consistent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and are considered as consistent dimensions.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm consistent(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        InventDimParm   inventDimParm;
        // <GEERU>
        container      key = [#ConsistentKey, _trackingDimensionGroup];

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
        }
        // </GEERU>

        return inventDimParm;   // No tracking dimensions can be marked as consistent.
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static EcoResTrackingDimGroupSetupCache construct()
    {
        return new EcoResTrackingDimGroupSetupCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>coveragePlanByDimensionEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and marked to be included when the master
    /// planning is being done.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm coveragePlanByDimensionEnabled(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#CoveragePlanByDimensionKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialInventoryEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and are marked as being part of financial
    /// inventory.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm financialInventoryEnabled(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#FinancialInventoryKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCachedInventDimParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a cached record.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// The storage dimension group for which to get the record.
    /// </param>
    /// <param name="_key">
    /// The key into the global cache.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer.
    /// </returns>
    /// <remarks>
    /// If the specified record is not found, it is initialized.
    /// </remarks>
    static protected InventDimParm getCachedInventDimParm(
        EcoResTrackingDimensionGroupRecId   _trackingDimensionGroup,
        container                           _key)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               packedRecordCache       = conNull();
        InventDimParm           inventDimParm;

        if (!_trackingDimensionGroup)
        {
            return inventDimParm;
        }

        while (packedRecordCache == conNull())
        {
            packedRecordCache = sysGlobalObjectCache.find(classScope , _key);
            if (!packedRecordCache || conLen(packedRecordCache) == 0)
            { // Not cached yet
                EcoResTrackingDimGroupSetupCache::initTrackingDimGroupCache(_trackingDimensionGroup);   // This will always initialize the cache.
                packedRecordCache = sysGlobalObjectCache.find(classScope , _key);                       // but the cache could be cleared by other processes, so finding an entry isn't guaranteed.
            }
        }

        [inventDimParm] = packedRecordCache;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an instance of the <c>InventDimGroupFieldSetup</c> class that matches the specified dimension
    /// field.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// The tracking dimension group for which to retrieve information.
    /// </param>
    /// <param name="_dimFieldId">
    /// The field ID of the inventory dimension field.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventDimGroupFieldSetup</c> class.
    /// </returns>
    static public InventDimGroupFieldSetup getFieldSetup(
        EcoResTrackingDimensionGroupRecId   _trackingDimensionGroup,
        FieldId                             _dimFieldId)
    {
        if (!_dimFieldId || !_trackingDimensionGroup || !InventDim::isFieldIdTrackingDimension(_dimFieldId))
        {
            return InventDimGroupFieldSetup::newNoValidField();
        }
        EcoResTrackingDimensionGroupFldSetup ecoResTrackingDimensionGroupFldSetup = EcoResTrackingDimensionGroupFldSetup::findByDimensionGroupFieldId(_trackingDimensionGroup, _dimFieldId);
        ecoResTrackingDimensionGroupFldSetup.DimensionFieldId = _dimFieldId; // Ensure that dimension field is still specified even if not found
        return InventDimGroupFieldSetup::newEcoResTrackingDimensionGroupFldSetup(ecoResTrackingDimensionGroupFldSetup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllActiveDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are active.
    /// </summary>
    /// <returns>
    /// An <c>InventDimParm</c> buffer with fields that contain the <c>NoYes::Yes</c> enumeration value for
    /// active dimension.
    /// </returns>
    /// <remarks>
    /// Information is gathered from all tracking dimensions in the system. A dimension that is active in
    /// at least one tracking dimension group will be returned as an active dimension.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllActiveDim()
    {
        EcoResTrackingDimensionGroup            ecoResTrackingDimensionGroup;
        InventDimParm                           inventDimParmInitAllActiveDim;

        while select RecId from ecoResTrackingDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(ecoResTrackingDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive())
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllActiveDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllActiveDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllActivePhysDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets information about which dimensions are active and physical.
    /// </summary>
    /// <returns>
    ///     An <c>InventDimParm</c> buffer with fields that contain the <c>NoYes::Yes</c> enumeration value for
    ///     active and physical dimension.
    /// </returns>
    /// <remarks>
    ///     Information is gathered from all tracking dimensions in the system. A dimension that is active and physical
    ///     in at least one tracking dimension group will be returned as an active and physical dimension.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllActivePhysDim()
    {
        EcoResTrackingDimensionGroup            ecoResTrackingDimensionGroup;
        InventDimParm                           inventDimParmInitAllActivePhysDim;

        while select RecId from ecoResTrackingDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(ecoResTrackingDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isPhysicalInventoryEnabled())
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllActivePhysDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllActivePhysDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllConsistentDim_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are consistent.
    /// </summary>
    /// <returns>
    ///    InventDimParm buffer with fields set to NoYes::Yes upon return for consistent dimensions.
    /// </returns>
    /// <remarks>
    ///     Infomation is gathered from all tracking dimensions in the system. It is enough that a dimension is
    ///    active and consistent in just one tracking dimension group to be returned as consistent.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllConsistentDim_RU()
    {
        EcoResTrackingDimensionGroup            ecoResTrackingDimensionGroup;
        InventDimParm                           inventDimParmInitAllConsistentDim;

        while select RecId from ecoResTrackingDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(ecoResTrackingDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();
                fieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isConsistent())
                {
                    fieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllConsistentDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllConsistentDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllCovDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are marked as part of master planning.
    /// </summary>
    /// <returns>
    /// An <c>InventDimParm</c> buffer with fields set to the <c>NoYes::Yes</c> enumeration value for
    /// dimensions that have master planning enabled.
    /// </returns>
    /// <remarks>
    /// Information is gathered from all tracking dimensions in the system. It is enough that a dimension
    /// is active and has the dimension marked in at least one tracking dimension group.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllCovDim()
    {
        EcoResTrackingDimensionGroup            ecoResTrackingDimensionGroup;
        InventDimParm                           inventDimParmInitAllCovDim;

        while select RecId from ecoResTrackingDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(ecoResTrackingDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isCoveragePlanByDimensionEnabled())
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllCovDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllCovDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllMandatoryDim_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as mandatory dimensions.
    ///    Infomation is gathered from all tracking dimension groups in the system. It is enough that a dimension
    ///    is active and marked as mandatory in just one tracking dimension group to be returned as Mandatory enabled.
    /// </summary>
    /// <returns>
    ///    InventDimParm buffer with fields set to NoYes::Yes for dimensions with Mandatory field enabled.
    /// </returns>
    static protected InventDimParm initInventDimParmInitAllMandatoryDim_RU()
    {
        EcoResTrackingDimensionGroup            ecoResTrackingDimensionGroup;
        InventDimParm                           inventDimParmInitAllMandatoryDim;

        while select RecId from ecoResTrackingDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(ecoResTrackingDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();
                fieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isMandatory())
                {
                    fieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllMandatoryDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllMandatoryDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllPriceDiscDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are marked as part of purchase or sales order price search.
    /// </summary>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that has fields set to the <c>NoYes::Yes</c> enumeration value for
    /// the dimensions that have price search enabled.
    /// </returns>
    /// <remarks>
    /// Information is gathered from all tracking dimensions in the system. It is enough that a dimension
    /// is active and is part of price search in at least one tracking dimension group.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllPriceDiscDim()
    {
        EcoResTrackingDimensionGroup            ecoResTrackingDimensionGroup;
        InventDimParm                           inventDimParmInitAllPriceDiscDim;

        while select RecId from ecoResTrackingDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(ecoResTrackingDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && (inventDimGroupFieldSetup.isSalesPriceSearchEnabled() || inventDimGroupFieldSetup.isPurchPriceSearchEnabled()))
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllPriceDiscDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllPriceDiscDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTrackingDimGroupCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes internal cache.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies a tracking dimension group for which to initialize cache.
    /// </param>
    static protected void initTrackingDimGroupCache(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        SysGlobalObjectCache    sysGlobalObjectCache                        = classfactory.globalObjectCache();
        globalObjectCacheScope  classScope                                  = EcoResTrackingDimGroupSetupCache::classScope();
        container               activeKey                                   = [#ActiveKey, _trackingDimensionGroup];
        container               salesProcessActivatedKey                    = [#SalesProcessActivatedKey, _trackingDimensionGroup];
        container               primaryKey                                  = [#PrimaryKey, _trackingDimensionGroup];
        container               financialInventoryKey                       = [#FinancialInventoryKey, _trackingDimensionGroup];
        container               physicalInventoryKey                        = [#PhysicalInventoryKey, _trackingDimensionGroup];
        container               coveragePlanByDimensionKey                  = [#CoveragePlanByDimensionKey, _trackingDimensionGroup];
        container               purchPriceKey                               = [#PurchPriceKey, _trackingDimensionGroup];
        container               salesPriceKey                               = [#SalesPriceKey, _trackingDimensionGroup];
        container               notAllowBlankReceiptKey                     = [#notAllowBlankReceiptKey, _trackingDimensionGroup];
        container               notAllowBlankIssueKey                       = [#notAllowBlankIssueKey, _trackingDimensionGroup];
        container               salesProcessActivatedNotAllowBlankIssueKey  = [#SalesProcessActivatedNotAllowBlankIssueKey, _trackingDimensionGroup];
        // <GEERU>
        container               mandatoryKey                                = [#MandatoryKey, _trackingDimensionGroup];
        container               consistentKey                               = [#ConsistentKey, _trackingDimensionGroup];
        // </GEERU>

        InventDimParm   isActive;
        InventDimParm   isSalesProcessActivated;
        InventDimParm   financialInventoryEnabled;
        InventDimParm   physicalInventoryEnabled;
        InventDimParm   primaryStockingEnabled;
        InventDimParm   purchPriceSearchEnabled;
        InventDimParm   salesPriceSearchEnabled;
        InventDimParm   coveragePlanByDimensionEnabled;
        InventDimParm   notAllowBlankReceipt;
        InventDimParm   notAllowBlankIssue;
        InventDimParm   salesProcessActivatedNotAllowBlankIssue;
        // <GEERU>
        InventDimParm   isMandatory;
        InventDimParm   isConsistent;
        // </GEERU>

        fieldId                                 dimParmFieldId;

        if (! _trackingDimensionGroup)
        {
            return;
        }

        purchPriceSearchEnabled.clear();
        salesPriceSearchEnabled.clear();
        coveragePlanByDimensionEnabled.clear();
        coveragePlanByDimensionEnabled.ItemIdFlag   = NoYes::Yes;
        isActive.clear();
        financialInventoryEnabled.clear();
        financialInventoryEnabled.ItemIdFlag        = NoYes::Yes;
        physicalInventoryEnabled.clear();
        primaryStockingEnabled.clear();
        notAllowBlankReceipt.clear();
        notAllowBlankIssue.clear();
        salesProcessActivatedNotAllowBlankIssue.clear();
        // <GEERU>
        isMandatory.clear();
        isConsistent.clear();
        // </GEERU>

        InventDimGroupFieldSetupEnumerator enumerator = EcoResTrackingDimGroupSetup::newDimensionGroup(_trackingDimensionGroup).getFieldSetupEnumerator();
        while (enumerator.moveNext())
        {
            InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

            if (inventDimGroupFieldSetup.isActive() || inventDimGroupFieldSetup.isSalesProcessActivated())
            {
                fieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
            }

            if (inventDimGroupFieldSetup.isActive())
            {
                isActive.(dimParmFieldId) = NoYes::Yes;

                if (inventDimGroupFieldSetup.isPurchPriceSearchEnabled())
                {
                    purchPriceSearchEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isSalesPriceSearchEnabled())
                {
                    salesPriceSearchEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isCoveragePlanByDimensionEnabled())
                {
                    coveragePlanByDimensionEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isFinancialInventoryEnabled())
                {
                    financialInventoryEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isPhysicalInventoryEnabled())
                {
                    physicalInventoryEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isPrimaryStockingEnabled())
                {
                    primaryStockingEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (!inventDimGroupFieldSetup.isAllowBlankReceiptEnabled())
                {
                    notAllowBlankReceipt.(dimParmFieldId) = NoYes::Yes;
                }

                if (!inventDimGroupFieldSetup.isAllowBlankIssueEnabled())
                {
                    notAllowBlankIssue.(dimParmFieldId) = NoYes::Yes;
                }
                // <GEERU>
                if (inventDimGroupFieldSetup.isMandatory())
                {
                    isMandatory.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isConsistent())
                {
                    isConsistent.(dimParmFieldId) = NoYes::Yes;
                }
                // </GEERU>
            }
            if (inventDimGroupFieldSetup.isSalesProcessActivated())
            {
                isSalesProcessActivated.(dimParmFieldId) = NoYes::Yes;

                if (!inventDimGroupFieldSetup.isAllowBlankIssueEnabled())
                {
                    salesProcessActivatedNotAllowBlankIssue.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        sysGlobalObjectCache.insert(classScope, activeKey, [isActive]);
        sysGlobalObjectCache.insert(classScope, salesProcessActivatedKey, [isSalesProcessActivated]);
        sysGlobalObjectCache.insert(classScope, primaryKey, [primaryStockingEnabled]);
        sysGlobalObjectCache.insert(classScope, financialInventoryKey, [financialInventoryEnabled]);
        sysGlobalObjectCache.insert(classScope, physicalInventoryKey, [physicalInventoryEnabled]);

        sysGlobalObjectCache.insert(classScope, coveragePlanByDimensionKey, [coveragePlanByDimensionEnabled]);
        sysGlobalObjectCache.insert(classScope, purchPriceKey, [purchPriceSearchEnabled]);
        sysGlobalObjectCache.insert(classScope, salesPriceKey, [salesPriceSearchEnabled]);
        sysGlobalObjectCache.insert(classScope, notAllowBlankReceiptKey, [notAllowBlankReceipt]);
        sysGlobalObjectCache.insert(classScope, notAllowBlankIssueKey, [notAllowBlankIssue]);
        sysGlobalObjectCache.insert(classScope, salesProcessActivatedNotAllowBlankIssueKey, [salesProcessActivatedNotAllowBlankIssue]);
        // <GEERU>
        sysGlobalObjectCache.insert(classScope, consistentKey, [isConsistent]);
        sysGlobalObjectCache.insert(classScope, mandatoryKey, [isMandatory]);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParm2InventDimParm</Name>
				<Source><![CDATA[
    static protected void inventDimParm2InventDimParm(
        InventDimParm   _toInventDimParm,
        InventDimParm   _fromInventDimParm)
    {
        ListEnumerator          dimFieldList = EcoResTrackingDimGroupSetup::dimFields().getEnumerator();

        while (dimFieldList.moveNext())
        {
            FieldId dimParmFieldId = InventDim::dim2dimParm(dimFieldList.current());
            if (_fromInventDimParm.(dimParmFieldId))
            {
                _toInventDimParm.(dimParmFieldId) = _fromInventDimParm.(dimParmFieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllActiveDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are active.
    /// </summary>
    /// <param name="_inventDimParmInitAllActiveDim">
    /// An <c>InventDimParm</c> buffer that has fields set to the <c>NoYes::Yes</c> enumeration value upon
    /// return for the active tracking dimension.
    /// </param>
    /// <remarks>
    /// Information is gathered from all tracking dimension groups in the system. A dimension that is
    /// active in at least one tracking dimension group will be returned as active.
    /// </remarks>
    static public void inventDimParmInitAllActiveDim(InventDimParm _inventDimParmInitAllActiveDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#ActiveAllGroupKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResTrackingDimGroupSetupCache::initInventDimParmInitAllActiveDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResTrackingDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllActiveDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllActivePhysicalDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets information about which dimensions are active and physical.
    /// </summary>
    /// <param name="_inventDimParmInitAllActivePhysicalDim">
    ///     An <c>InventDimParm</c> buffer that has fields set to the <c>NoYes::Yes</c> enumeration value upon
    ///     return for the active and physical tracking dimension.
    /// </param>
    /// <remarks>
    ///     Information is gathered from all tracking dimension groups in the system. A dimension that is
    ///     active and physical in at least one tracking dimension group will be returned as active and physical.
    /// </remarks>
    static public void inventDimParmInitAllActivePhysicalDim(InventDimParm _inventDimParmInitAllActivePhysicalDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#ActivePhysicalAllGroupKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResTrackingDimGroupSetupCache::initInventDimParmInitAllActivePhysDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResTrackingDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllActivePhysicalDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllConsistentDim_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are consistent.
    /// </summary>
    /// <param name="_inventDimParmInitAllConsistentDim">
    ///    InventDimParm buffer with fields set to NoYes::Yes upon return for consistent dimensions.
    /// </param>
    /// <remarks>
    ///     Infomation is gathered from all tracking dimensions in the system. It is enough that a dimension is
    ///    active and consistent in just one tracking dimension group to be returned as consistent.
    /// </remarks>
    static public void inventDimParmInitAllConsistentDim_RU(InventDimParm _inventDimParmInitAllConsistentDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        globalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#ConsistentKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conlen(packedRecordCache) == 0)
        {
            recordCache = EcoResTrackingDimGroupSetupCache::initInventDimParmInitAllConsistentDim_RU();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResTrackingDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllConsistentDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllCovDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about the dimensions that are marked as part of master planning.
    /// </summary>
    /// <param name="_inventDimParmInitAllCovDim">
    /// An <c>InventDimParm</c> buffer with fields set to the <c>NoYes::Yes</c> enumeration value upon
    /// return for dimensions that are part of master planning.
    /// </param>
    /// <remarks>
    /// Information is gathered from all tracking dimension groups in the system. It is enough that a
    /// dimension is active and marked as part of master planning in at least one tracking dimension group.
    /// </remarks>
    static public void inventDimParmInitAllCovDim(InventDimParm _inventDimParmInitAllCovDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#AllCovKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResTrackingDimGroupSetupCache::initInventDimParmInitAllCovDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResTrackingDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllCovDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllMandatoryDim_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as mandatory.
    /// </summary>
    /// <param name="_inventDimParmInitAllMandatoryDim">
    ///    InventDimParm buffer with fields set to NoYes::Yes upon return for dimensions which are marked as
    ///    mandatory.
    /// </param>
    /// <remarks>
    ///     Infomation is gathered from all tracking dimension group in the system. It is enough that a
    ///    dimension is active and are marked as mandatory in just one tracking dimension group to be returned
    ///    as mandatory.
    /// </remarks>
    static public void inventDimParmInitAllMandatoryDim_RU(InventDimParm _inventDimParmInitAllMandatoryDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        globalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#MandatoryKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conlen(packedRecordCache) == 0)
        {
            recordCache = EcoResTrackingDimGroupSetupCache::initInventDimParmInitAllMandatoryDim_RU();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResTrackingDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllMandatoryDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllPriceDiscDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the information about the dimensions that are marked as part of purchase or sales order price
    /// search.
    /// </summary>
    /// <param name="_inventDimParmInitAllPriceDiscDim">
    /// An <c>InventDimParm</c> buffer that has fields set to the <c>NoYes::Yes</c> enumeration value upon
    /// return for dimensions which are part of price searches.
    /// </param>
    /// <remarks>
    /// Information is gathered from all tracking dimensions in the system. It is enough that a dimension
    /// is active and is part of price search in at least one tracking dimension group.
    /// </remarks>
    static public void inventDimParmInitAllPriceDiscDim(InventDimParm _inventDimParmInitAllPriceDiscDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#AllPriceDiscKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResTrackingDimGroupSetupCache::initInventDimParmInitAllPriceDiscDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResTrackingDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllPriceDiscDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyTrackingGroupSalesProcessActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Queries whether any tracking dimension group has a sales process active dimension.
    /// </summary>
    /// <returns>
    ///    true if any tracking dimension group has a has a sales process active dimension; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Information is gathered from all tracking dimension groups in the system. It is enough that a
    ///    dimension is sales process active in at least one tracking dimension group.
    /// </remarks>
    static public boolean isAnyTrackingGroupSalesProcessActive()
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();
        container               key                     = [#AnySalesProcessActivatedKey];
        boolean                 isAnyTrackingGroupSalesProcessActive;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            isAnyTrackingGroupSalesProcessActive = (select EcoResTrackingDimensionGroupFldSetup
                                                        where EcoResTrackingDimensionGroupFldSetup.IsSalesProcessActivated == NoYes::Yes).recid != 0;

            sysGlobalObjectCache.insert(classScope, key, [isAnyTrackingGroupSalesProcessActive]);
        }
        else
        {
            [isAnyTrackingGroupSalesProcessActive] = packedRecordCache;
        }

        return isAnyTrackingGroupSalesProcessActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and marked as mandatory.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm mandatory(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        InventDimParm   inventDimParm;
        // <GEERU>
        container      key = [#MandatoryKey, _trackingDimensionGroup];

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
        }
        // </GEERU>

        return inventDimParm;   // No tracking dimensions can be marked as mandatory.
    }

]]></Source>
			</Method>
			<Method>
				<Name>notAllowBlankIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and that do not allow blank issue values.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm notAllowBlankIssue(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#notAllowBlankIssueKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>notAllowBlankReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the information about the dimensions that are active and do not allow for blank receipt
    /// values.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm notAllowBlankReceipt(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#notAllowBlankReceiptKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalInventoryEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about the dimensions that are active and marked as part of physical inventory.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm physicalInventoryEnabled(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#PhysicalInventoryKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>primaryStockingEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about whiche dimensions  are active and marked as primary stocking dimensions.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm primaryStockingEnabled(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#PrimaryKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchPriceSearchEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and are marked to be included during a
    /// search for purchase price.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm purchPriceSearchEnabled(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#PurchPriceKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPriceSearchEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and are marked to be included during a
    /// search for sales price.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    /// Specifies the tracking dimension group for which to retrieve information.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm salesPriceSearchEnabled(EcoResTrackingDimensionGroupRecId _trackingDimensionGroup)
    {
        container   key     = [#SalesPriceKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesProcessActivated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active for a process.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    ///    The specified product dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    A <c>InventDimParm</c> table that contains the requested information.
    /// </returns>
    static public InventDimParm salesProcessActivated(
        EcoResTrackingDimensionGroupRecId   _trackingDimensionGroup
        )
    {
        container   key     = [#SalesProcessActivatedKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesProcessActivatedNotAllowBlankIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are sales process active and that do not allow blank issue values.
    /// </summary>
    /// <param name="_trackingDimensionGroup">
    ///    The specified product dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    A <c>InventDimParm</c> table that contains the requested information.
    /// </returns>
    static public InventDimParm salesProcessActivatedNotAllowBlankIssue(
        EcoResTrackingDimensionGroupRecId   _trackingDimensionGroup
        )
    {
        container   key     = [#SalesProcessActivatedNotAllowBlankIssueKey, _trackingDimensionGroup];

        return EcoResTrackingDimGroupSetupCache::getCachedInventDimParm(_trackingDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyInventOwnerDimensionActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if there is any activated inventory owner dimension.
    /// </summary>
    /// <returns>
    ///    True represents that inventory owner dimension is activated, otherwise, false.
    /// </returns>
    [Wrappable(false), Hookable(false)]
    public static boolean isAnyInventOwnerDimensionActive()
    {
        const str CacheKeyStr = 'IsAnyInventOwnerDimensionActive';
        boolean   isAnyInventOwnerDimensionActive = false;
        container key = [CacheKeyStr];

        SysGlobalObjectCache   sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResTrackingDimGroupSetupCache::classScope();

        container packedCacheValue = sysGlobalObjectCache.find(classScope, key);

        if (!packedCacheValue || conLen(packedCacheValue) == 0)
        {
            EcoResTrackingDimensionGroupFldSetup ecoResTrackingDimensionGroupFldSetup;

            select firstonly RecId from ecoResTrackingDimensionGroupFldSetup
                where ecoResTrackingDimensionGroupFldSetup.DimensionFieldId == fieldNum(InventDim, InventOwnerId_RU)
                   && ecoResTrackingDimensionGroupFldSetup.IsActive;

            isAnyInventOwnerDimensionActive = (ecoResTrackingDimensionGroupFldSetup.RecId != 0);

            sysGlobalObjectCache.insert(classScope, key, [isAnyInventOwnerDimensionActive]);
        }
        else
        {
            [isAnyInventOwnerDimensionActive] = packedCacheValue;
        }

        return isAnyInventOwnerDimensionActive;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>