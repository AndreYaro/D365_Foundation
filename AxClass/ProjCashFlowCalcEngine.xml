<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjCashFlowCalcEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
// This class is the actual calculation engine for the results
class ProjCashFlowCalcEngine
{
    Query                   actualQuery;
    Query                   budgetQuery;
    QueryBuildDataSource    actualQuerySource, budgetQuerySource,
                            actualPaidQuerySource, actualNotPaidQuerySource, actualExpectedPaidQuerySource,
                            budgetPaidQuerySource, budgetNotPaidQuerySource, budgetExpectedPaidQuerySource,
                            projectReportQuerySource,
                            projectBudgetReportQuerySource;
    QueryBuildDataSource    projTableDataSource;
    QueryRun                actualQueryRun, budgetQueryRun;

    ProjCashFlow                projCashFlow;
    ProjTransPosting            projTransPosting;
    ProjTransBudget             projTransBudget;
    TmpProjCashFlowExcelPivot   tmpExcelExport;
    private boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

    // Variables in the param class
    boolean             fixedPrice;
    boolean             timeMaterial;
    boolean             internalCost;
    boolean             investment;
    boolean             timeProjects;

    boolean             hour;
    boolean             expenses;
    boolean             fee;
    boolean             onAcc;
    boolean             item;

    EmplItemId          emplItemId;
    ResourceRecId       resource;
    ResourceCategoryRecId resourceCategory;
    SMASubscriptionId   subscriptionId;
    SMASubscriptionGroupId
                        subscriptionGroupId;

    ProjCategoryId      categoryId;
    ProjCategoryGroupId categoryGroupId;
    CustAccount         custAccount;
    ProjId              projId;

    Num                 transId;

    TransDate           projectFromDate;
    TransDate           projectToDate;
    TransDate           paymentFromDate;
    TransDate           paymentToDate;
    TransDate           projectBreakDate;
    TransDate           paymentBreakDate;

    ProjActualBudget    actualBudgetDeviationSum;
    boolean             includedExpectedPayment;
    boolean             includedPaidPayment;
    ForecastModelId     forecastModelId;

    real                daysAddedToSalesPayment;
    real                daysAddedToCostPayment;

    TransDate           minimumCostPaymentDate;
    TransDate           minimumSalesPaymentDate;

    ProjSort            sorting1;
    ProjSort            sorting2;
    ProjSort            sorting3;

    ProjShowAmount        showAmount;
    Level                 projLevel;
    boolean               skipBlankId;
    boolean               skipZero;

    ProjListStateProjType
                        stateProjType;
    ProjListStateId     listId;

    ProjCashFlowReportType      reportType;

    AmountMST           actualCashOutFlow, actualCashInFlow, actualNetCashFlow,
                        budgetCashInFlow, budgetCashOutFlow, budgetNetCashFlow,
                        budgetCashOutflowValue, budgetNetCashFlowValue, budgetSalesCashInFlow,
                        cashOutFlowValue, cashPaidHourValue, cashPaidExpensesValue,
                        cashPaidItemValue,
                        deviationCashInFlow, deviationCashOutFlow, deviationNetCashFlow,
                        deviationCashOutFlowValue, deviationNetCashFlowValue, deviationSalesCashInFlow,
                        invoicedOnAccountValue, invoicedRevenueValue,
                        netCashFlowValue, salesCashInFlow;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addConditionsToActualExpectedPaidQuery</Name>
				<Source><![CDATA[
    // Add the conditions to the actual query for the Not Paid enum
    // The QueryDataBaseSource has been named actualNotPaidQuerySource but it indicates the
    // Expected Payment
    private void addConditionsToActualExpectedPaidQuery()
    {
        TransDate       costToDate;
        TransDate       salesToDate;

        // Set the date range as per the criteria/business logic
        // Check if minimum date or to date is bigger
        if (minimumCostPaymentDate <= paymentToDate)
        {
            costToDate = paymentToDate;
        }
        else
        {
            costToDate = minimumCostPaymentDate;
        }

        if (minimumSalesPaymentDate <= paymentToDate)
        {
            salesToDate = paymentToDate;
        }
        else
        {
            salesToDate = minimumSalesPaymentDate;
        }

        // Cost payments and Sales payments have a different criteria
        // CostSales enum = 1
        // If Payment date < today's date
        //    Payment date <= (To date - daysAddedToCostPayment) - Shift the range by the number of days
        //                                                         given by the user
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentDate)).value(
         strFmt('( (%1.%3 < %5) && (%1.%3 <= %4) && (%1.%2 == 1) )',
           actualQuerySource.name(),            fieldStr(ProjTransPosting, CostSales),
           fieldStr(ProjTransPosting, PaymentDate),    date2StrXpp(costToDate - daysAddedToCostPayment),
           date2StrXpp(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
           ));

        // CostSales enum = 1
        // If Payment date >= today's date
        //    Payment date <= (To date)
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentDate)).value(
         strFmt('( (%1.%3 >= %5) && (%1.%3 <= %4) && (%1.%2 == 1) )',
           actualQuerySource.name(),            fieldStr(ProjTransPosting, CostSales),
           fieldStr(ProjTransPosting, PaymentDate),    date2StrXpp(costToDate),
           date2StrXpp(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
           ));

        // Cost payments and Sales payments have a different criteria
        // CostSales enum = 2
        // If Payment date < today's date
        //    Payment date <= (To date - daysAddedToSalesPayment) - Shift the range by the number of days
        //                                                          given by the user
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentDate)).value(
    strFmt('( (%1.%3 < %5) && (%1.%3 <= %4) && (%1.%2 == 2) )',
           actualQuerySource.name(),            fieldStr(ProjTransPosting, CostSales),
           fieldStr(ProjTransPosting, PaymentDate),    date2StrXpp(costToDate - daysAddedToSalesPayment),
           date2StrXpp(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
           ));

        // CostSales enum = 2
        // If Payment date >= today's date
        //    Payment date <= (To date)
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentDate)).value(
    strFmt('( (%1.%3 >= %5) && (%1.%3 <= %4) && (%1.%2 == 2) )',
           actualQuerySource.name(),            fieldStr(ProjTransPosting, CostSales),
           fieldStr(ProjTransPosting, PaymentDate),    date2StrXpp(salesToDate),
           date2StrXpp(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
           ));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConditionsToActualPaidQuery</Name>
				<Source><![CDATA[
    // Add the conditions to the actual query for the Paid enum
    private void addConditionsToActualPaidQuery()
    {
        // This range is to the new column PaymentStatus
        // Project and payment date ranges
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentDate)).value(queryValue(paymentFromDate) + '..' + queryValue(paymentToDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForActuals</Name>
				<Source><![CDATA[
    // Assign the ranges/conditions on the form the actual query
    public void buildQueryForActuals(boolean _isReport = false, boolean _addTransRange = true)
    {
        QueryBuildFieldList queryBuildFieldList;

        actualQuery = new Query();
        actualQuerySource = actualQuery.addDataSource(tableNum(ProjTransPosting));

        if (_isReport)
        {
            // Report type
            switch (reportType)
            {
                case ProjCashFlowReportType::Project:
                    queryBuildFieldList = actualQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransPosting, ProjId));
                    break;

                case ProjCashFlowReportType::Category:
                    queryBuildFieldList = actualQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransPosting, CategoryId));
                    break;

                case ProjCashFlowReportType::Item:
                    queryBuildFieldList = actualQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransPosting, EmplItemId));
                    break;

                case ProjCashFlowReportType::Worker:
                    queryBuildFieldList = actualQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransPosting, Resource));
                    break;

                case ProjCashFlowReportType::ResourceCategory:
                    queryBuildFieldList = actualQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransPosting, ResourceCategory));
                    break;

                case ProjCashFlowReportType::Subscription:
                    queryBuildFieldList = actualQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransPosting, SubscriptionId));
                    break;
            }

            // We  add the sum amount for the report
            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, AmountMst));
        }
        else
        {
            // need to add fields for export to excel
            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, ProjId));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, CategoryId));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, EmplItemId));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, Resource));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, ResourceCategory));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, SubscriptionId));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, ActivityNumber));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, ProjTransType));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, ProjTransDate));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, TransactionOrigin));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, LedgerOrigin));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, Voucher));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, PostingType));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, AmountMst));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, PaymentStatus));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, PaymentDate));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, ProjFundingSource));

            queryBuildFieldList = actualQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, DefaultDimension));
        }

        // We set the conditions (except the payment date conditions) on the form to the parent query so that
        // it automatically reflects in the child queries
        // Set the elimination field
        actualQuerySource.addRange(fieldNum(ProjTransPosting, LedgerOrigin)).value(strFmt('(%1 != %2) && (%1 != %3)',
        fieldStr(ProjTransPosting, LedgerOrigin),
        enum2int(ProjOrigin::EliminateEstimate),
        enum2int(ProjOrigin::ReverseElimination)));

        // Choose the sort index
        switch (listId)
        {
            case ProjListStateId::Project:
                actualQuerySource.addSortIndex(indexNum(ProjTransPosting, ProjIdx));
                break;

            case ProjListStateId::Category:
                actualQuerySource.addSortIndex(indexNum(ProjTransPosting, CategoryIdx));
                break;

            case ProjListStateId::EmplItem:
                actualQuerySource.addSortIndex(indexNum(ProjTransPosting, EmplItemIdx));
                break;

            case ProjListStateId::TransId:
                actualQuerySource.addSortIndex(indexNum(ProjTransPosting, TransIdx));
                break;

            default:
                this.addSortIndexDefault();
                break;
        }

        // Project types
        if (!this.enableProjMultipleContractLinesForProjectFeature)
        {
            if (fixedPrice)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (timeMaterial)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (internalCost)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Internal));
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (investment)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (timeProjects)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        // Transaction types
        if (_addTransRange)
        {
            if (hour)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Hour));
            }

            if (expenses)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Cost));
            }

            if (fee)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Revenue));
            }

            if (onAcc)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::OnAccount));
            }

            if (item)
            {
                actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Item));
            }
        }

        // Project and payment date ranges
        // We add the Project dates entered by the user 'as is' to the parent query
        actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransDate)).value(queryValue(projectFromDate) + '..' + queryValue(projectToDate));

        // Add the paymentstatus range
        if (includedPaidPayment)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentStatus)).value(queryValue(ProjPaymentStatus::Paid));
        }

        if (includedExpectedPayment)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PaymentStatus)).value(queryValue(ProjPaymentStatus::ExpectedPayment));
        }

        if (projId)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjId)).value(queryValue(projId));
        }

        if (categoryId)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, CategoryId)).value(categoryId);
        }

        if (emplItemId)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, EmplItemId)).value(emplItemId);
        }

        if (resource)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, Resource)).value(queryValue(resource));
        }

        if (resourceCategory)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, ResourceCategory)).value(queryValue(resourceCategory));
        }

        if (subscriptionId)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            actualQuerySource.addRange(fieldNum(ProjTransPosting, TransId)).value(transId);
        }

        // Add the special conditions to the individual queries - Paid and Expected Paid
        this.addConditionsToActualExpectedPaidQuery();
        this.addConditionsToActualPaidQuery();

        if (custAccount)
        {
            projTableDataSource = actualQuerySource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(ProjTransPosting, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSortIndexDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds sorting index to the parent query.
    /// </summary>
    protected void addSortIndexDefault()
    {
        actualQuerySource.addSortIndex(indexNum(ProjTransPosting, TransIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForBudgetV2</Name>
				<Source><![CDATA[
    // Assign the ranges/conditions on the form the budget query
    public void buildQueryForBudgetV2(boolean _isReport = false, boolean _addTransRange = true)
    {
        QueryBuildFieldList     queryBuildFieldList;
        FieldId fieldId;
        ArrayIdx fieldArrayIdx;

        budgetQuery = new Query();
        budgetQuerySource = budgetQuery.addDataSource(tableNum(ProjTransBudget));

        // Add the fields to the query
        // Reporting query requires the proj id
        if (_isReport)
        {
            // Report type
            switch (reportType)
            {
                case ProjCashFlowReportType::Project:
                    // Project
                    queryBuildFieldList = budgetQuerySource.fields();
                    [fieldId, fieldArrayIdx]  = this.getFieldId();
                    queryBuildFieldList.addField(fieldId, SelectionField::Database, fieldArrayIdx);
                    queryBuildFieldList.addField(fieldNum(ProjTransBudget, ProjId));
                    break;

                case ProjCashFlowReportType::Category:
                    // Category report
                    queryBuildFieldList = budgetQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransBudget, CategoryId));
                    break;

                case ProjCashFlowReportType::Item:
                    queryBuildFieldList = budgetQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransBudget, EmplItemId));
                    break;

                case ProjCashFlowReportType::Worker:
                    queryBuildFieldList = budgetQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransBudget, Resource));
                    break;

                case ProjCashFlowReportType::ResourceCategory:
                    queryBuildFieldList = budgetQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransBudget, ResourceCategory));
                    break;

                case ProjCashFlowReportType::Subscription:
                    queryBuildFieldList = budgetQuerySource.fields();
                    queryBuildFieldList.addField(fieldNum(ProjTransBudget, SubscriptionId));
                    break;
            }

            // Sum
            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, AmountMst));
        }
        else
        {
            // need to add ProjId, CategoryId and EmplItemId fields for export to excel
            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, ProjId));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, CategoryId));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, EmplItemId));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, Resource));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, ResourceCategory));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, SubscriptionId));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, ActivityNumber));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, ProjTransType));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, ProjTransDate));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, PaymentStatus));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, PaymentDate));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, Voucher));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, PostingType));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, AmountMst));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, ProjFundingSource));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransPosting, DefaultDimension));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, LedgerDimension));

            queryBuildFieldList = budgetQuerySource.fields();
            queryBuildFieldList.addField(fieldNum(ProjTransBudget, LedgerTransDate));
        }

        // Set the elimination field
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, Elimination)).value('0');

        // Choose the sort index
        switch (listId)
        {
            case ProjListStateId::Project:
                budgetQuerySource.addSortIndex(indexNum(ProjTransBudget, ProjIdx));
                break;

            case ProjListStateId::Category:
                budgetQuerySource.addSortIndex(indexNum(ProjTransBudget, CategoryIdx));
                break;

            case ProjListStateId::EmplItem:
                budgetQuerySource.addSortIndex(indexNum(ProjTransBudget, EmplItemIdx));
                break;

            case ProjListStateId::TransId:
                budgetQuerySource.addSortIndex(indexNum(ProjTransBudget, TransIdx));
                break;

            default:
                budgetQuerySource.addSortIndex(indexNum(ProjTransBudget, TransIdx));
                break;
        }

        // Project types
        if (!this.enableProjMultipleContractLinesForProjectFeature)
        {
            if (fixedPrice)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (timeMaterial)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (internalCost)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Internal));
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (investment)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (timeProjects)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        // Transaction types
        if (_addTransRange)
        {
            if (hour)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
            }

            if (expenses)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
            }

            if (fee)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Revenue));
            }

            if (onAcc)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::OnAccount));
            }

            if (item)
            {
                budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
            }
        }
        
        // Add the ranges and conditions based on the calling form
        // We need to get these values to calculate results for only chosen rows
        if (projId)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(projId));
        }

        if (categoryId)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, CategoryId)).value(categoryId);
        }

        if (emplItemId)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, EmplItemId)).value(emplItemId);
        }

        if (resource)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, Resource)).value(queryValue(resource));
        }

        if (resourceCategory)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, ResourceCategory)).value(queryValue(resourceCategory));
        }

        if (subscriptionId)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, TransId)).value(transId);
        }

        // Project and payment date ranges
        // We add the Project dates entered by the user 'as is' to the parent query
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(queryValue(projectFromDate) + '..' + queryValue(projectToDate));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PaymentDate)).value(queryValue(paymentFromDate) + '..' + queryValue(paymentToDate));

        // Add the forecast model
        if (forecastModelId)
        {
            budgetQuerySource.addRange(fieldNum(ProjTransBudget, ModelId)).value(queryValue(forecastModelId));
        }

        // Add the paymentstatus range
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PaymentStatus)).value(queryValue(ProjPaymentStatus::Paid));

        if (custAccount)
        {
            projTableDataSource = budgetQuerySource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(ProjTransBudget, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearVariables</Name>
				<Source><![CDATA[
    // This method will initialize all the variables to 0
    private void clearVariables()
    {
        actualCashOutFlow = 0;
        actualCashInFlow = 0;
        actualNetCashFlow = 0;
        budgetCashInFlow = 0;
        budgetCashOutFlow = 0;
        budgetNetCashFlow = 0;
        budgetCashOutflowValue = 0;
        budgetNetCashFlowValue = 0;
        budgetSalesCashInFlow = 0;
        cashOutFlowValue = 0;
        cashPaidHourValue = 0;
        cashPaidExpensesValue = 0;
        cashPaidItemValue = 0;
        deviationCashInFlow = 0;
        deviationCashOutFlow = 0;
        deviationNetCashFlow = 0;
        deviationCashOutFlowValue = 0;
        deviationNetCashFlowValue = 0;
        deviationSalesCashInFlow = 0;
        invoicedOnAccountValue = 0;
        invoicedRevenueValue = 0;
        netCashFlowValue = 0;
        salesCashInFlow = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualCashInflow</Name>
				<Source><![CDATA[
    AmountMST getActualCashInflow()
    {
        // Build the query
        this.buildQueryForActuals();

        // Add the cash in flow specific ranges and conditions
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::PSAProjRetain));

        // Execute the query and get the values
        [actualCashInFlow] = this.getQueryValues(true, true, true);

        return actualCashInFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualCashOutflow</Name>
				<Source><![CDATA[
    AmountMST getActualCashOutflow()
    {
        QueryRun                            queryRun;
        ProjTransPosting                    locProjTransposting;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry                 generalJournalEntry,locGeneralJournalEntry;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        AmountMST                           retainedAmount;
        Voucher                             voucher;

        // Get the query
        this.buildQueryForActuals();

        // Add the cash in flow specific ranges and conditions
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));

        // Execute the query and get the values
        [actualCashOutFlow] = this.getQueryValues(true, false, true);

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            queryRun = new QueryRun(actualQuery);

            while (queryRun.next())
            {
                locProjTransposting = queryRun.get(tableNum(ProjTransPosting));

                while select firstonly GeneralJournalEntry,Voucher from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher           == locProjTransposting.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate    == locProjTransposting.ProjTransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == locProjTransposting.DataAreaId
                join RecId,DocumentNumber,DocumentDate from generalJournalEntry
                where generalJournalEntry.RecId  == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()

                {
                    if (voucher == subledgerVoucherGeneralJournalEntry.Voucher)
                    {
                        break;
                    }

                    select firstonly RecId from  locGeneralJournalEntry
                    where locGeneralJournalEntry.RecId != subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && locGeneralJournalEntry.DocumentNumber == generalJournalEntry.DocumentNumber
                    && locGeneralJournalEntry.DocumentDate   == generalJournalEntry.DocumentDate
                    join  TransactionCurrencyAmount,GeneralJournalEntry from generalJournalAccountEntry
                    where locGeneralJournalEntry.RecId          == generalJournalAccountEntry.GeneralJournalEntry
                      && generalJournalAccountEntry.PostingType == LedgerPostingType::PSAProjPurchRetain;

                    retainedAmount += generalJournalAccountEntry.TransactionCurrencyAmount;

                    voucher = locProjTransposting.Voucher;
                }
            }
            actualCashOutFlow += retainedAmount;
        }

        return actualCashOutFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualCashPaidExpensesValue</Name>
				<Source><![CDATA[
    AmountMST getActualCashPaidExpensesValue()
    {
        if (expenses)
        {
            // Get the query
            this.buildQueryForActuals(false, false);

            // Add the cash in flow specific ranges and conditions
            actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Cost));

            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));

            // Execute the query and get the values
            [cashPaidExpensesValue] = this.getQueryValues(true);

            return cashPaidExpensesValue;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualCashPaidHourValue</Name>
				<Source><![CDATA[
    AmountMST getActualCashPaidHourValue()
    {
        if (hour)
        {
            // Get the query
            this.buildQueryForActuals(false, false);

            // Add the cash in flow specific ranges and conditions
            actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Hour));

            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));

            // Execute the query and get the values
            [cashPaidHourValue] = this.getQueryValues(true);

            return cashPaidHourValue;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualCashPaidItemValue</Name>
				<Source><![CDATA[
    AmountMST getActualCashPaidItemValue()
    {
        if (item)
        {
            // Get the query
            this.buildQueryForActuals(false, false);

            // Add the cash in flow specific ranges and conditions
            actualQuerySource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Item));

            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
            actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));

            // Execute the query and get the values
            [cashPaidItemValue] = this.getQueryValues(true);

            return cashPaidItemValue;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualInvoicedOnaccountValue</Name>
				<Source><![CDATA[
    AmountMST getActualInvoicedOnaccountValue()
    {
        // Get the query
        this.buildQueryForActuals();

        // Add the cash in flow specific ranges and conditions
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));

        // Execute the query and get the values
        [invoicedOnAccountValue] = this.getQueryValues(true, true);

        return invoicedOnAccountValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualInvoicedRevenueValue</Name>
				<Source><![CDATA[
    AmountMST getActualInvoicedRevenueValue()
    {
        // Get the query
        this.buildQueryForActuals();

        // Add the cash in flow specific ranges and conditions
        actualQuerySource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));

        // Execute the query and get the values
        [invoicedRevenueValue] = this.getQueryValues(true, true);

        return invoicedRevenueValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCashInFlow</Name>
				<Source><![CDATA[
    AmountMST getBudgetCashInFlow(boolean _isReport = false)
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2(_isReport);
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false, true, true);
        amountMST   = amountMST;

        budgetCashInFlow = amountMST;

        return budgetCashInFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCashOutFlow</Name>
				<Source><![CDATA[
    AmountMST getBudgetCashOutFlow(boolean _isReport = false)
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2(_isReport);
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false, false, true);
        amountMST   = amountMST;

        budgetCashOutFlow = amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCashPaidExpensesValue</Name>
				<Source><![CDATA[
    AmountMST getBudgetCashPaidExpensesValue()
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2(false, false);
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false);
        amountMST   = amountMST;

        cashPaidExpensesValue = amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCashPaidHourValue</Name>
				<Source><![CDATA[
    AmountMST getBudgetCashPaidHourValue()
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2(false, false);
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false);
        amountMST   = amountMST;

        cashPaidHourValue = amountMST;

        return cashPaidHourValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCashPaidItemValue</Name>
				<Source><![CDATA[
    AmountMST getBudgetCashPaidItemValue()
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2(false, false);
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false);
        amountMST   = amountMST;

        cashPaidItemValue = amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetInvoicedOnaccountValue</Name>
				<Source><![CDATA[
    AmountMST getBudgetInvoicedOnaccountValue()
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2();
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false);
        amountMST   = amountMST;

        invoicedOnAccountValue = amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetInvoicedRevenueValue</Name>
				<Source><![CDATA[
    AmountMST getBudgetInvoicedRevenueValue()
    {
        AmountMST amountMST;

        // Get the query
        this.buildQueryForBudgetV2();
        // Add the cash in flow specific ranges and conditions
        budgetQuerySource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));

        // Execute the query and get the values
        [amountMST] = this.getQueryValues(false);
        amountMST   = amountMST;

        invoicedRevenueValue = amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldId</Name>
				<Source><![CDATA[
    // This method gives us the fieldId and array index to be added to the select and the group by clause
    container getFieldId()
    {
        container fieldCon;

        switch (stateProjType)
        {
            case ProjListStateProjType::Project:
                fieldCon = [fieldNum(ProjTable, ProjId), 1];
                break;

            case ProjListStateProjType::Customer:
                fieldCon = [fieldNum(ProjTable, CustAccount), 1];
                break;

            case ProjListStateProjType::ProjGroup:
                fieldCon = [fieldNum(ProjTable, ProjGroupId), 1];
                break;

            case ProjListStateProjType::WIPProject:
                fieldCon = [fieldNum(ProjTable, wipProject), 1];
                break;

            case ProjListStateProjType::InvoiceProject:
                fieldCon = [fieldNum(ProjTable, ProjInvoiceProjId), 1];
                break;

            case ProjListStateProjType::ResponsibleSales:
                fieldCon = [fieldNum(ProjTable, WorkerResponsibleSales), 1];
                break;

            case ProjListStateProjType::Responsible:
                fieldCon = [fieldNum(ProjTable, WorkerResponsible), 1];
                break;

            case ProjListStateProjType::ResponsibleFinancial:
                fieldCon = [fieldNum(ProjTable, WorkerResponsibleFinancial), 1];
                break;

            case ProjListStateProjType::Type:
                fieldCon = [fieldNum(ProjTable, Type), 1];
                break;

            case ProjListStateProjType::Sorting1:
                fieldCon = [fieldNum(ProjTable, SortingId), 1];
                break;

            case ProjListStateProjType::Sorting2:
                fieldCon = [fieldNum(ProjTable, SortingId), 2];
                break;

            case ProjListStateProjType::Sorting3:
                fieldCon = [fieldNum(ProjTable, SortingId), 3];
                break;

            case ProjListStateProjType::Asset:
                fieldCon = [fieldNum(ProjTable, AssetId), 1];
                break;
        }

        return fieldCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryValues</Name>
				<Source><![CDATA[
    // This method returns the query execution values
    // _isActual: indicates if its an actual or budget query
    // _inflow: indicates if its an inflow or outflow amount is calculated
    // _isExcelExport: indicates if its exporting to a temp file for Excel
    private container getQueryValues(boolean _isActual, boolean _inflow = false, boolean isExcelExport = false)
    {
        ProjTransPosting    locProjTransPosting;
        ProjTransBudget     locProjTransBudget;
        Common              transTable;
        AmountMST           amountMST, tmpAmt;

        // Execute the query
        if (_isActual)
        {
            actualQueryRun    = new QueryRun(actualQuery);

            // Iterate through the records of the query
            while (actualQueryRun.next())
            {
                locProjTransPosting = actualQueryRun.get(tableNum(ProjTransPosting));

                if (_inflow)
                {
                    tmpAmt = locProjTransPosting.AmountMst * -1;
                }
                else
                {
                    tmpAmt = locProjTransPosting.AmountMst;
                }

                amountMST += tmpAmt;

                if (isExcelExport)
                {
                    this.updateTmpExcelExport(locProjTransPosting, tmpAmt, _inflow);
                }
            }
        }

        else
        {
            budgetQueryRun    = new QueryRun(budgetQuery);
            // Iterate through the records of the query
            while (budgetQueryRun.next())
            {
                locProjTransBudget          = budgetQueryRun.getNo(1);

                if (_inflow)
                {
                    tmpAmt = locProjTransBudget.AmountMst * -1;
                }
                else
                {
                    tmpAmt = locProjTransBudget.AmountMst;
                }

                amountMST += tmpAmt;

                if (isExcelExport)
                {
                    transTable = budgetQueryRun.get(tableNum(ProjTransBudget));
                    this.updateTmpExcelExport(transTable, tmpAmt, _inflow);
                }
            }
        }

        return [amountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(ProjCashFlow _projCashFlow = null, ProjCashFlowReportType _type = ProjCashFlowReportType::Project)
    {
        projCashFlow = _projCashFlow;
        reportType = _type;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmActualQuerySource</Name>
				<Source><![CDATA[
    QueryBuildDataSource parmActualQuerySource(QueryBuildDataSource _actualQuerySource = actualQuerySource)
    {
        actualQuerySource = _actualQuerySource;

        return actualQuerySource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetQuerySource</Name>
				<Source><![CDATA[
    QueryBuildDataSource parmBudgetQuerySource(QueryBuildDataSource _budgetQuerySource = budgetQuerySource)
    {
        budgetQuerySource = _budgetQuerySource;

        return budgetQuerySource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSorting1</Name>
				<Source><![CDATA[
    ProjSort parmSorting1(ProjSort _sorting1 = sorting1)
    {
        sorting1  = _sorting1;

        return sorting1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSorting2</Name>
				<Source><![CDATA[
    ProjSort parmSorting2(ProjSort _sorting2 = sorting2)
    {
        sorting2  = _sorting2;

        return sorting2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSorting3</Name>
				<Source><![CDATA[
    ProjSort parmSorting3(ProjSort _sorting3 = sorting3)
    {
        sorting3  = _sorting3;

        return sorting3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStateProjType</Name>
				<Source><![CDATA[
    ProjListStateProjType parmStateProjType(ProjListStateProjType _stateProjType = stateProjType)
    {
        stateProjType  = _stateProjType;

        return stateProjType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpExcelExport</Name>
				<Source><![CDATA[
    public TmpProjCashFlowExcelPivot parmTmpExcelExport(TmpProjCashFlowExcelPivot _tmpExcelExport = tmpExcelExport)
    {
        tmpExcelExport = _tmpExcelExport;

        return tmpExcelExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setClientSettings</Name>
				<Source><![CDATA[
    void setClientSettings()
    {
        this.clearVariables();

        // Set the values as per those set by the client
        fixedPrice      =   projCashFlow.parmFixedPrice();
        timeMaterial    =   projCashFlow.parmTimeMaterial();
        internalCost    =   projCashFlow.parmInternalCost();
        investment      =   projCashFlow.parmInvestment();
        timeProjects    =   projCashFlow.parmTimeProject();

        hour            =   projCashFlow.parmHour();
        expenses        =   projCashFlow.parmExpenses();
        fee             =   projCashFlow.parmFee();
        onAcc           =   projCashFlow.parmOnAcc();
        item            =   projCashFlow.parmItem();

        resource        =   projCashFlow.parmResource();
        resourceCategory =  projCashFlow.parmResourceCategory();
        emplItemId      =   projCashFlow.parmEmplItemId();
        subscriptionId  =   projCashFlow.parmSubscriptionId();
        categoryId      =   projCashFlow.parmCategoryId();
        projId          =   projCashFlow.parmProjId();
        custAccount     =   projCashFlow.parmCustAccount();

        projectFromDate =   projCashFlow.parmProjectFromDate();
        projectToDate   =   projCashFlow.parmProjectToDate();
        paymentFromDate =   projCashFlow.parmPaymentFromDate();
        paymentToDate   =   projCashFlow.parmPaymentToDate();
        projectBreakDate =  projCashFlow.parmProjectBreakDate();
        paymentBreakDate =  projCashFlow.parmPaymentBreakDate();

        actualBudgetDeviationSum = projCashFlow.parmActualBudget();
        includedExpectedPayment  = projCashFlow.parmIncludedExpectedPayment();
        includedPaidPayment      = projCashFlow.parmIncludedPaidPayment();
        forecastModelId          = projCashFlow.parmForecastModelId();

        daysAddedToSalesPayment  = projCashFlow.parmDaysAddedToSalesPayment();
        daysAddedToCostPayment   = projCashFlow.parmDaysAddedToCostPayment();

        minimumCostPaymentDate   = projCashFlow.parmMinimumCostPaymentDate();
        minimumSalesPaymentDate  = projCashFlow.parmMinimumSalesPaymentDate();

        showAmount               = projCashFlow.parmShowAmount();
        stateProjType            = projCashFlow.parmStateProjType();
        projLevel                = projCashFlow.parmProjLevel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpExcelExport</Name>
				<Source><![CDATA[
    public void updateTmpExcelExport(Common _dataSource, AmountMST _cashFlowAmount, boolean _inflow = false)
    {
        ProjTransPosting            actual;
        ProjTransBudget             budget;
        ProjTable                   projTableInfo;
        ProjCategory                categoryInfo;
        PurchLine                   purchLine;
        ProjItemTrans               projItemTrans;
        SalesIdBase                 orderNumber;
        VendAccount                 vendor;
        ProjId                      projectId;
        ProjCategoryId              categId;
        VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project;
        VendInvoiceInfoLine         vendInvoiceInfoLine;
        VendInvoiceInfoTable        vendInvoiceInfoTable;

        if (_dataSource.TableId == tableNum(ProjTransPosting))
        {
            actual      = _dataSource;
            projectId   = actual.ProjId;
            categId     = actual.CategoryId;
        }
        else if (_dataSource.TableId == tableNum(ProjTransBudget))
        {
            budget      = _dataSource;
            projectId   = budget.ProjId;
            categId     = budget.CategoryId;
        }

        // Set project information
        projTableInfo = ProjTable::find(projectId);

        // Set category information
        categoryInfo = ProjCategory::find(categId);

        ttsbegin;

        switch (_dataSource.TableId)
        {
            case tableNum(ProjTransPosting):
                actual = _dataSource;

                orderNumber = '';
                vendor      = '';

                tmpExcelExport.clear();
                tmpExcelExport.StatementType        = ProjExportToExcelWorksheet::CashFlow;
                tmpExcelExport.ActualBudget         = ProjActualBudget::Actual;

                tmpExcelExport.initFromProjTransPosting(actual);
                tmpExcelExport.initFromProjTable(projTableInfo);
                tmpExcelExport.initFromProjCategory(categoryInfo);

                // Set Order Number and Vendor
                if (actual.ProjTransType == ProjTransType::Item)
                {
                    if ((actual.TransactionOrigin == ProjOrigin::SalesOrder)         ||
                    (actual.TransactionOrigin == ProjOrigin::ItemRequirement)    ||
                    (actual.TransactionOrigin == ProjOrigin::PurchaseOrder)      ||
                    (actual.TransactionOrigin == ProjOrigin::VendorInvoice)      ||
                    (actual.TransactionOrigin == ProjOrigin::ProductionFinished) ||
                    (actual.TransactionOrigin == ProjOrigin::ProductionConsumed) ||
                    (actual.TransactionOrigin == ProjOrigin::BeginningBalance))
                    {
                        projItemTrans = ProjItemTrans::find(actual.TransId);

                        orderNumber = ProjInvoiceItem::findTransId(projItemTrans.ProjTransId).SalesId;
                        if (actual.TransactionOrigin == ProjOrigin::PurchaseOrder)
                        {
                            select firstonly purchLine
                            where purchLine.ProjTransId == actual.TransId;
                            vendor = purchLine.purchTable().vendTable_OrderAccount().AccountNum;
                        }
                        else if (actual.TransactionOrigin == ProjOrigin::VendorInvoice)
                        {
                            select firstonly RecId
                            from vendInvoiceInfoLine_Project
                                where vendInvoiceInfoLine_Project.ProjTransId == actual.TransId
                            join RecId from vendInvoiceInfoLine
                                where vendInvoiceInfoLine.RecId == vendInvoiceInfoLine_Project.VendInvoiceInfoLineRefRecId
                            join OrderAccount from vendInvoiceInfoTable
                                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId &&
                                    vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId;
                            vendor = vendInvoiceInfoTable.OrderAccount;
                        }

                        tmpExcelExport.OrderNumber = orderNumber;
                        tmpExcelExport.Vendor = vendor;
                    }
                }

                if (_inflow)
                {
                    tmpExcelExport.CashInFlow += _cashFlowAmount;
                }
                else
                {
                    tmpExcelExport.CashOutFlow += _cashFlowAmount;
                }
                tmpExcelExport.NetCashFlow = tmpExcelExport.CashInFlow - tmpExcelExport.CashOutFlow;
                tmpExcelExport.insert();

                // Calculate Deviation
                if (actualBudgetDeviationSum == ProjActualBudget::Deviation)
                {
                    tmpExcelExport.clear();
                    tmpExcelExport.StatementType        = ProjExportToExcelWorksheet::CashFlow;
                    tmpExcelExport.ActualBudget         = ProjActualBudget::Deviation;

                    tmpExcelExport.initFromProjTransPosting(actual);
                    tmpExcelExport.initFromProjTable(projTableInfo);
                    tmpExcelExport.initFromProjCategory(categoryInfo);

                    tmpExcelExport.OrderNumber = orderNumber;
                    tmpExcelExport.Vendor = vendor;

                    if (_inflow)
                    {
                        tmpExcelExport.CashInFlow += _cashFlowAmount;
                    }
                    else
                    {
                        tmpExcelExport.CashOutFlow += _cashFlowAmount;
                    }
                    tmpExcelExport.NetCashFlow = tmpExcelExport.CashInFlow - tmpExcelExport.CashOutFlow;
                    tmpExcelExport.insert();
                }

                // Calculate Sum
                if (actualBudgetDeviationSum == ProjActualBudget::Sum_)
                {
                    tmpExcelExport.clear();
                    tmpExcelExport.StatementType        = ProjExportToExcelWorksheet::CashFlow;
                    tmpExcelExport.ActualBudget         = ProjActualBudget::Sum_;

                    tmpExcelExport.initFromProjTransPosting(actual);
                    tmpExcelExport.initFromProjTable(projTableInfo);
                    tmpExcelExport.initFromProjCategory(categoryInfo);

                    tmpExcelExport.OrderNumber = orderNumber;
                    tmpExcelExport.Vendor = vendor;

                    if (_inflow)
                    {
                        tmpExcelExport.CashInFlow += _cashFlowAmount;
                    }
                    else
                    {
                        tmpExcelExport.CashOutFlow += _cashFlowAmount;
                    }

                    tmpExcelExport.NetCashFlow = tmpExcelExport.CashInFlow + tmpExcelExport.CashOutFlow;
                    tmpExcelExport.insert();
                }
                break;

            case tableNum(ProjTransBudget):
                budget = _dataSource;

                tmpExcelExport.clear();
                tmpExcelExport.StatementType    = ProjExportToExcelWorksheet::CashFlow;
                tmpExcelExport.ActualBudget     = ProjActualBudget::Budget;

                tmpExcelExport.initFromProjTransBudget(budget);
                tmpExcelExport.initFromProjTable(projTableInfo);
                tmpExcelExport.initFromProjCategory(categoryInfo);

                if (_inflow)
                {
                    tmpExcelExport.CashInFlow += _cashFlowAmount;
                }
                else
                {
                    tmpExcelExport.CashOutFlow += _cashFlowAmount;
                }
                tmpExcelExport.NetCashFlow = tmpExcelExport.CashInFlow - tmpExcelExport.CashOutFlow;
                tmpExcelExport.insert();

                // Calculate Deviation
                if (actualBudgetDeviationSum == ProjActualBudget::Deviation)
                {
                    tmpExcelExport.clear();
                    tmpExcelExport.StatementType    = ProjExportToExcelWorksheet::CashFlow;
                    tmpExcelExport.ActualBudget     = ProjActualBudget::Deviation;

                    tmpExcelExport.initFromProjTransBudget(budget);
                    tmpExcelExport.initFromProjTable(projTableInfo);
                    tmpExcelExport.initFromProjCategory(categoryInfo);

                    if (_inflow)
                    {
                        tmpExcelExport.CashInFlow += -_cashFlowAmount;
                    }
                    else
                    {
                        tmpExcelExport.CashOutFlow += -_cashFlowAmount;
                    }
                    tmpExcelExport.NetCashFlow = tmpExcelExport.CashInFlow - tmpExcelExport.CashOutFlow;
                    tmpExcelExport.insert();
                }

                // Calculate Sum
                if (actualBudgetDeviationSum == ProjActualBudget::Sum_)
                {
                    tmpExcelExport.clear();
                    tmpExcelExport.StatementType    = ProjExportToExcelWorksheet::CashFlow;
                    tmpExcelExport.ActualBudget     = ProjActualBudget::Sum_;

                    tmpExcelExport.initFromProjTransBudget(budget);
                    tmpExcelExport.initFromProjTable(projTableInfo);
                    tmpExcelExport.initFromProjCategory(categoryInfo);

                    if (_inflow)
                    {
                        tmpExcelExport.CashInFlow += _cashFlowAmount;
                    }
                    else
                    {
                        tmpExcelExport.CashOutFlow += _cashFlowAmount;
                    }
                    tmpExcelExport.NetCashFlow = tmpExcelExport.CashInFlow + tmpExcelExport.CashOutFlow;
                    tmpExcelExport.insert();
                }
                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>