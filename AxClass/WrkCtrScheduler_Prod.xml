<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrScheduler_Prod</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WrkCtrScheduler_Prod</c> class is a resource scheduler processor for production orders.
/// </summary>
/// <remarks>
/// This processor loads the production orders information and feeding this to the scheduling engine.
/// It also writes the results provided by the scheduling engine back to the Microsoft Dynamics AX
/// database.
/// </remarks>
class WrkCtrScheduler_Prod extends WrkCtrScheduler
{
    boolean checkForProdLocked;

    Map itemInventUnitOfMeasurePrecision;

    private WrkCtrSchedulingInteropDataProvider dataProvider;
    private readonly boolean scheduleEngineApplicableResourcesPeriodFlightIsEnabled;
    private readonly boolean wrkCtrSchedulerProdValidateResourceRequirementFlightIsEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInfologMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an Infolog entry for an order that failed scheduling.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// An instance of the <c>WrkCtrParmSchedule</c> class that contains the order scheduling parameters.
    /// </param>
    /// <param name="_jobSchedulingError">
    /// A <c>WrkCtrJobSchedulingError</c> value that indicates the error to report; optional.
    /// </param>
    /// <param name="_infologMessage">
    /// A string that should be put in the Infolog as error or information.
    /// </param>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that identifies the record that triggered the failure.
    /// </param>
    /// <param name="_throwError">
    /// true if an error should be thrown; false if the message should be added as information.
    /// </param>
    protected void addInfologMessage(WrkCtrParmSchedule         _wrkCtrParmSchedule,
                                     WrkCtrJobSchedulingError   _jobSchedulingError = WrkCtrJobSchedulingError::None,
                                     str                        _infologMessage     = '',
                                     Common                     _common             = null,
                                     boolean                    _throwError         = true)
    {
        // call the base class to add any additional common error info
        super(_wrkCtrParmSchedule,
              _jobSchedulingError,
              strFmt("@SYS134389", _wrkCtrParmSchedule.schedNumId()),
              _common);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToUpdatedOrdersMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds new order to the map of updated orders.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters that are
    /// needed for scheduling the order.
    /// </param>
    /// <param name="_order">
    /// The order in which to add.
    /// </param>
    /// <param name="_bomCalcData">
    /// The BOM data in which to add.
    /// </param>
    protected void addToUpdatedOrdersMap(WrkCtrParmSchedule  _wrkCtrParmSchedule,
                                         Common              _order,
                                         BOMCalcData         _bomCalcData)
    {
        ProdTable       prodTable = _order as ProdTable;
        ProdJobUpdate   jobUpdate;
        OprNum          schedOprNum;

        if (    !prodTable.RouteJobs
            ||  prodTable.SchedStatus != (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail ? ProdSchedStatus::JobScheduled : ProdSchedStatus::OperationScheduled))
        {
            if (!_wrkCtrParmSchedule.schedSingleJob())
            {
                // Create the records in ProdRouteJob
                if (_wrkCtrParmSchedule.schedOnlyOprNum())
                {
                    schedOprNum = _wrkCtrParmSchedule.schedOprNum();
                    jobUpdate = ProdJobUpdate::newProdIdOprNum(prodTable.ProdId,
                                                               schedOprNum,
                                                               schedOprNum,
                                                               false);
                }
                else
                {
                    jobUpdate = ProdJobUpdate::newProdTable(prodTable,
                                                            _bomCalcData,
                                                            false);
                }

                jobUpdate.parmScheduleAllJobs(_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail);

                jobUpdate.run();
            }

            mapUpdatedOrders.insert(prodTable, _wrkCtrParmSchedule);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>blankRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a blank <c>ProdRoute</c> record.
    /// </summary>
    /// <returns>
    /// A <c>Common</c> table buffer that contains a blank <c>ProdRoute</c> record.
    /// </returns>
    protected Common blankRoute()
    {
        ProdRoute   prodRoute;

        return prodRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a production order can be scheduled.
    /// </summary>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> table buffer that contains the production order record.
    /// </param>
    /// <returns>
    /// true if the order meets all requirements for being scheduled; otherwise, false.
    /// </returns>
    protected boolean canSchedule(Common _prodTable)
    {
        ProdTable prodTable = _prodTable as ProdTable;
        boolean     ret;

        ret = super(_prodTable);

        if (prodTable.ProdLocked && checkForProdLocked)
        {
            return checkFailed("@SYS8998");
        }

        if (masterData.exists(prodTable.ProdId))
        {
            // The production order loaded in the list, we can not schedule it twice
            return checkFailed(strFmt("@SYS134377", prodTable.ProdId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReferenceProdParmScheduling</Name>
				<Source><![CDATA[
    private void createReferenceProdParmScheduling(ProdId                _prodId,
                                                   WrkCtrParmSchedule    _wrkCtrParmSchedule)
    {
        ProdParmScheduling  prodParmSchedulingLocal;
        
        prodParmSchedulingLocal.initValue();
        prodParmSchedulingLocal.LineNum             = 1;
        prodParmSchedulingLocal.ProdId              = _prodId;
        prodParmSchedulingLocal.ParmId              = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        prodParmSchedulingLocal.AutoUpdate          = NoYes::Yes;
        prodParmSchedulingLocal.ExecutedDateTime    = DateTimeUtil::getSystemDateTime();
        prodParmSchedulingLocal.JobStatus           = ParmJobStatus::Executed;

        this.initProdParmSchedulingFromWrkCtrParmSchedule(prodParmSchedulingLocal, _wrkCtrParmSchedule);

        prodParmSchedulingLocal.doInsert();        
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdParmSchedulingFromWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    protected void initProdParmSchedulingFromWrkCtrParmSchedule(ProdParmScheduling _prodParmSchedulingLocal, WrkCtrParmSchedule _wrkCtrParmSchedule)
    {        
        _prodParmSchedulingLocal.CancelOverlap       = _wrkCtrParmSchedule.cancelOverlap();
        _prodParmSchedulingLocal.CancelProcessTime   = _wrkCtrParmSchedule.cancelProcessTime();
        _prodParmSchedulingLocal.CancelQueueTime     = _wrkCtrParmSchedule.cancelQueueTime();
        _prodParmSchedulingLocal.CancelSetupTime     = _wrkCtrParmSchedule.cancelSetupTime();
        _prodParmSchedulingLocal.CancelTransportTime = _wrkCtrParmSchedule.cancelTransportTime();
        _prodParmSchedulingLocal.CapLimited          = _wrkCtrParmSchedule.capacityLimited();
        _prodParmSchedulingLocal.MatLimited          = _wrkCtrParmSchedule.materialLimited();
        _prodParmSchedulingLocal.PropertyLimited     = _wrkCtrParmSchedule.propertyLimited();
        _prodParmSchedulingLocal.SchedDirection      = (_wrkCtrParmSchedule.schedDirection() == SchedDirection::Backward) ?
                                                        ProdSchedDirection::BackwardFromSchedDate : ProdSchedDirection::ForwardFromSchedDate;
        _prodParmSchedulingLocal.SchedMethod         = ( _wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough) ?
                                                        ProdSchedMethod::OperationScheduling : ProdSchedMethod::JobScheduling;
        _prodParmSchedulingLocal.SchedDate           = _wrkCtrParmSchedule.schedDate();
        _prodParmSchedulingLocal.SchedTime           = _wrkCtrParmSchedule.schedTime();
        _prodParmSchedulingLocal.SchedRef            = _wrkCtrParmSchedule.schedReference();
        _prodParmSchedulingLocal.SyncRef             = _wrkCtrParmSchedule.synchronizeReference();        
        _prodParmSchedulingLocal.ApplyIssueMargin    = _wrkCtrParmSchedule.applyIssueMargin();
        _prodParmSchedulingLocal.ApplyReceiptMargin  = _wrkCtrParmSchedule.applyReceiptMargin();
        _prodParmSchedulingLocal.ApplyReorderMargin  = _wrkCtrParmSchedule.applyReorderMargin();
    }

]]></Source>
			</Method>
			<Method>
				<Name>capacityRefType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the capacity reservation type.
    /// </summary>
    /// <returns>
    ///    A <c>WrkCtrCapRefType</c> object that has the capacity reservation type.
    /// </returns>
    public WrkCtrCapRefType capacityRefType()
    {
        return WrkCtrCapRefType::Production;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cleans up the order data when the scheduling fails.
    /// </summary>
    /// <param name="_prodTable">
    ///    A <c>ProdTable</c> record with the production order data.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> value that contains the scheduling parameters.
    /// </param>
    protected void cleanUpOrder(Common              _prodTable,
                                WrkCtrParmSchedule  _wrkCtrParmSchedule)
    {
        ProdTable prodTable = _prodTable as ProdTable;
        ProdRouteJob prodRouteJob;

        super(_prodTable, _wrkCtrParmSchedule);

        if (!mapOrderData.exists(this.keyOrder(prodTable)))
        {
            delete_from prodRouteJob
                where prodRouteJob.ProdId == prodTable.ProdId;

            prodTable.selectForUpdate();
            prodTable.RouteJobs = NoYes::No;
            prodTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBOMCalcData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>BOMCalcData</c> class for a given order.
    /// </summary>
    /// <param name="_order">
    /// The order for which BOM calculation data is needed.
    /// </param>
    /// <returns>
    /// An instance of the <c>BOMCalcData</c> class to use for runtime computation.
    /// </returns>
    protected BOMCalcData createBOMCalcData(Common _order)
    {
        ProdTable prodTable = _order;

        return BOMCalcData::newProdTable(prodTable.QtySched, prodTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRouteTraverser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>WrkCtrSchedulerRouteTraverser</c> class.
    /// </summary>
    /// <param name="_scheduleEngine">
    /// The scheduling engine.
    /// </param>
    /// <param name="_constraintLevel">
    /// The constraint level.
    /// </param>
    /// <returns>
    /// A new instance of the <c>WrkCtrSchedulerRouteTraverser</c> class.
    /// </returns>
    protected WrkCtrSchedulerRouteTraverser createRouteTraverser(
        WrkCtrSchedulerEngineInterface  _scheduleEngine,
        RouteLevel                      _constraintLevel)
    {
        return WrkCtrSchedulerRouteTraverser::newProd(_scheduleEngine, _constraintLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a temporary production route operation record and returns it as a <c>Common</c> table
    ///    buffer.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID to create the temporary operation for.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the temporary production operation data.
    /// </returns>
    protected Common createTmpRoute(InventRefId _refId)
    {
        ProdRoute prodRoute;

        prodRoute.setTmp();
        prodRoute.setTmpData(tmpRoute);
        prodRoute.ProdId = _refId;
        prodRoute.doInsert();

        temporaryOperations.add(prodRoute.RecId);

        routeData.insert(this.keyRoute(prodRoute.ProdId, prodRoute.OprNum,  RouteOprPriority::Primary), prodRoute);

        return prodRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a temporary production job record and returns it as a <c>Common</c> table buffer.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID to create the temporary job record for.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the temporary job information.
    /// </returns>
    protected Common createTmpRouteJob(InventRefId _refId)
    {
        ProdRouteJob prodRouteJob;

        prodRouteJob.ProdId = _refId;
        prodRouteJob.setFields();
        prodRouteJob.doInsert();

        jobData.insert(prodRouteJob.RecId, prodRouteJob);

        temporaryJobs.add(prodRouteJob.RecId);
        prodRouteJob.selectForUpdate();

        return prodRouteJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTemporaryJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a temporary job.
    /// </summary>
    /// <param name="_recId">
    /// The identifier of the job to delete.
    /// </param>
    protected void deleteTemporaryJob(recId _recId)
    {
        ProdRouteJob  prodRouteJob;

        delete_from prodRouteJob where prodRouteJob.RecId == _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJobWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>WrkCtrParmSchedule</c> object for the order that a specific job belongs to.
    /// </summary>
    /// <param name="_jobId">
    ///    A record ID value that identifies the job for which the scheduling parameters are being looked up.
    /// </param>
    /// <returns>
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters for the order of the
    ///    specified job.
    /// </returns>
    protected WrkCtrParmSchedule findJobWrkCtrParmSchedule(recId _jobId)
    {
        ProdRouteJob prodRouteJob;

        prodRouteJob = jobData.lookup(_jobId);

        return masterDataParms.lookup(prodRouteJob.ProdId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a production order in the master data and retrieves the order record.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID.
    /// </param>
    /// <param name="_forUpdate">
    ///    true if the record is to be selected for update; otherwise, false.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <returns>
    ///    A <c>ProdTable</c> table buffer that contains the production order data.
    /// </returns>
    protected Common findRefId(InventRefId           _refId,
                                  boolean               _forUpdate = false,
                                  WrkCtrParmSchedule    _wrkCtrParmSchedule = null
                                  )
    {
        return ProdTable::find(_refId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemInventUnitPrecision</Name>
				<Source><![CDATA[
    protected UnitOfMeasureDecimalPrecision getItemInventUnitPrecision(ItemId _itemId)
    {
        UnitOfMeasureDecimalPrecision precision;

        if (itemInventUnitOfMeasurePrecision == null)
        {
            itemInventUnitOfMeasurePrecision = new Map(Types::String, Types::Integer);
        }

        if (itemInventUnitOfMeasurePrecision.exists(_itemId))
        {
            precision = itemInventUnitOfMeasurePrecision.lookup(_itemId);
        }
        else
        {
            precision = UnitOfMeasure::unitOfMeasureDecimalPrecision(
                            UnitOfMeasure::unitOfMeasureIdBySymbol(
                                InventTable::find(_itemId).inventUnitId()));
            itemInventUnitOfMeasurePrecision.insert(_itemId, precision);
        }

        return precision;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRouteAndOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the route and operation.
    /// </summary>
    /// <param name="_routeJobMap">
    /// The current job.
    /// </param>
    /// <param name="_routeMap">
    /// The current route.
    /// </param>
    /// <param name="_routeOprMap">
    /// The current route operation.
    /// </param>
    /// <returns>
    /// A container that contains the new route and operation.
    /// </returns>
    private container getRouteAndOperation(RouteJobMap _routeJobMap, RouteMap _routeMap, RouteOprMap _routeOprMap)
    {
        RouteMap    routeMap    = _routeMap;
        RouteOprMap routeOprMap = _routeOprMap;

        if (_routeJobMap.OprPriority != RouteOprPriority::Primary || _routeJobMap.NumPrimary != 1)
        {
            // Get route for secondary operation
            routeMap = _routeJobMap.prodRoute();
            routeOprMap = _routeJobMap.prodRoute();
        }

        return [routeMap, routeOprMap];
    }

]]></Source>
			</Method>
			<Method>
				<Name>infologPrefixOprNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the prefix to display in the Infolog specified by the job ID.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that identifies the job for which to compute the message prefix.
    /// </param>
    /// <returns>
    ///    A string value that contains the Infolog prefix.
    /// </returns>
    protected str infologPrefixOprNum(Common _common)
    {
        ProdRouteJob    prodRouteJob = _common as ProdRouteJob;
        str             result = '';

        if (prodRouteJob)
        {
            result = strFmt("@SYS302657",
                            prodRouteJob.OprNum,
                            prodRouteJob.OprPriority);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCapacityReservationData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the capacity reservation record with the appropriate scheduler data.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrCapRes">
    ///    A <c>WrkCtrCapRes</c> record that identifies the capacity reservation.
    /// </param>
    /// <param name="_jobId">
    ///    A record ID that identifies the job that the capacity reservation belongs to.
    /// </param>
    protected void initCapacityReservationData(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                                               WrkCtrCapRes         _wrkCtrCapRes,
                                               recId                _jobId)
    {
        ProdRouteJob prodRouteJob;

        prodRouteJob = jobData.lookup(_jobId);

        // set order ID
        _wrkCtrCapRes.RefId           = prodRouteJob.ProdId;
        _wrkCtrCapRes.OprNum          = prodRouteJob.OprNum;
        _wrkCtrCapRes.PlanVersion     = 0;

        _wrkCtrCapRes.OprPriority     = prodRouteJob.OprPriority;
        _wrkCtrCapRes.JobType         = prodRouteJob.JobType;
        _wrkCtrCapRes.PropertyId      = prodRouteJob.PropertyId;

        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail)
        {
            _wrkCtrCapRes.JobId       = prodRouteJob.JobId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inputWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the input warehouse ID for a specific operation record.
    /// </summary>
    /// <param name="_routeMap">
    /// A record that contains the production route operation data.
    /// </param>
    /// <returns>
    /// The input warehouse ID assigned to the BOM line connected to the operation.
    /// </returns>
    protected InventLocationIdInput inputWarehouse(RouteMap _routeMap)
    {
        ProdBOM                 prodBOM;
        InventLocationIdInput   inputWarehouse = '';
        InventDim               inventDim;
        ProdRoute               prodRoute    = _routeMap;

        // for secondary operations nothing is done regarding input warehouse filtering
        if (prodRoute.OprPriority != RouteOprPriority::Primary)
        {
            return '';
        }

        while select WrkCtrConsumption, InventDimId from prodBOM
        where   prodBOM.ProdId == prodRoute.ProdId
            &&  (prodBOM.OprNum == prodRoute.OprNum
            ||   (prodBOM.OprNum == 0 &&
                  prodRoute.isFirstOpr()))
        {
            if (prodBOM.WrkCtrConsumption)
            {
                inventDim = InventDim::find(prodBOM.InventDimId);

                if (inventDim.InventLocationId)
                {
                    if (inputWarehouse &&
                        inventDim.InventLocationId != inputWarehouse)
                    {
                        info(strFmt("@SYS302190",
                                    prodRoute.ProdId));

                        break;
                    }
                    else
                    {
                        inputWarehouse = inventDim.InventLocationId;
                    }
                }
            }
        }

        return inputWarehouse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts an order into the master data and triggers the loading of the route information into the
    ///    scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling settings.
    /// </param>
    /// <param name="_prodTable">
    ///    A <c>ProdTable</c> table buffer with the production order data.
    /// </param>
    /// <param name="_prodTableNext">
    ///    A <c>ProdTable</c> table buffer with the data of the next referenced production order.
    /// </param>
    /// <param name="_prodNextOprNum">
    ///    The next referenced production order operation number.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    A <c>BOMLevel</c> object that indicates the start reference level for scheduling.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    ///    A <c>BOMLevel</c> object that indicates the maximal reference level for scheduling.
    /// </param>
    protected void insertOrder(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                               ProdTable            _prodTable,
                               ProdTable            _prodTableNext,
                               OprNum               _prodNextOprNum,
                               BOMLevel             _startCollectRefLevel,
                               BOMLevel             _maxCollectRefLevel = 0)
    {
        // Load data for single production order
        masterData.insert(_prodTable.ProdId, _prodTable);
        masterDataParms.insert(_prodTable.ProdId, _wrkCtrParmSchedule);

        this.updateExplosion(_prodTable, _wrkCtrParmSchedule);

        this.loadRoute(_wrkCtrParmSchedule,
                       _prodTable,
                       _prodTable.inventDim().InventSiteId,
                       _prodTableNext,
                       _prodNextOprNum,
                       _startCollectRefLevel,
                       _maxCollectRefLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSchedFromJobConstraints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the bind priority, goal, start and end date constraints
    /// for scheduling an order around a specific job.
    /// </summary>
    /// <param name="_schedFromJobInfo">
    /// A <c>ProdRouteJobInfo</c> instance with data about the starting job.
    /// </param>
    /// <param name="_referenceDateTime">
    /// The date and time from which the starting job is being scheduled.
    /// </param>
    /// <param name="_referenceSchedDirection">
    /// The direction in which the starting job is being scheduled.
    /// </param>
    protected void insertSchedFromJobConstraints(
        ProdRouteJobInfo    _schedFromJobInfo,
        utcDateTime         _referenceDateTime,
        SchedDirection      _referenceSchedDirection)
    {
        ProdRouteJob        paralellJob;

        int                 constraintLevel = 2;

        int                 startingJobPriority = 2;
        int                 startingParalellJobsPriority = startingJobPriority - 1;
        int                 baseJobPriority = -1;
        int                 lowestJobPriorityLeftBranch;

        WrkCtrSchedulerRouteTraverser   routeTraverser;

        void addJobConstraints(RecId _jobRecId, int _bindPriority)
        {
            scheduleEngine.addJobBindPriority(_jobRecId, constraintLevel, _bindPriority);

            // set schedule direction constraints
            if (_referenceSchedDirection == SchedDirection::Backward)
            {
                // set the chosen job to be scheduled backward and add end date constraint
                scheduleEngine.addJobGoal(_jobRecId, constraintLevel, WrkCtrSchedulerGoal::LatestStartTime);
                scheduleEngine.addConstraintJobEndsAt(_jobRecId, constraintLevel, _referenceDateTime);
            }
            else
            {
                // set the chosen job to be scheduled forward and add start date constraint
                scheduleEngine.addJobGoal(_jobRecId, constraintLevel, WrkCtrSchedulerGoal::EarliestEndTime);
                scheduleEngine.addConstraintJobStartsAt(_jobRecId, constraintLevel, _referenceDateTime);
            }
        }

        // raise the priority of the chosen job and jobs parallel to it
        // and add scheduling constraints
        addJobConstraints(_schedFromJobInfo.parmJob().RecId, startingJobPriority);

        paralellJob = _schedFromJobInfo.parallelJobs();
        while (paralellJob)
        {
            addJobConstraints(paralellJob.RecId, startingParalellJobsPriority);
            next paralellJob;
        }

        // traverser adds scheduling constraints and
        // reverses goal and lowers priority with every successor/predecessor direction change
        routeTraverser = this.createRouteTraverser(scheduleEngine, constraintLevel);

        // jobs on left branch get backward/forward goals and lower bind priority
        lowestJobPriorityLeftBranch = routeTraverser.traverseAndAddConstraints(_schedFromJobInfo, SchedDirection::Backward, baseJobPriority);

        // jobs on right branch get forward/backward goals and even lower bind priority
        routeTraverser.traverseAndAddConstraints(_schedFromJobInfo, SchedDirection::Forward, lowestJobPriorityLeftBranch - 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSingleJobStartEndConstraints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the start and end date constraints for singe job scheduling.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// The scheduling parameters.
    /// </param>
    /// <param name="_prodRouteJob">
    /// The job.
    /// </param>
    /// <returns>
    /// A container with two dates: [startDateLowerBound, endDateUpperBound].
    /// </returns>
    protected container insertSingleJobStartEndConstraints(
        WrkCtrParmSchedule              _wrkCtrParmSchedule,
        ProdRouteJob                    _prodRouteJob)
    {
        ProdRouteJobInfo jobInfo;

        Set  currentOrderExclusiveJobList;
        date prevJobsLatestEndDate;
        int  prevJobsLatestEndTime;
        date nextJobsEarliestStartDate;
        int  nextJobsEarliestStartTime;

        date lowerBound = dateNull();
        date upperBound = dateMax();

        if (_wrkCtrParmSchedule.schedSingleJob())
        {
            currentOrderExclusiveJobList = this.getExclusiveJobList(_wrkCtrParmSchedule);
            jobInfo = new ProdRouteJobInfo(_prodRouteJob);

            [prevJobsLatestEndDate, prevJobsLatestEndTime] = jobInfo.prevJobsLatestEndDateTime(jobInfo.prevJobsQueryExcludingJobs(currentOrderExclusiveJobList));
            if (prevJobsLatestEndDate)
            {
                scheduleEngine.addConstraintJobStartsAt(_prodRouteJob.RecId, 0, DateTimeUtil::newDateTime(prevJobsLatestEndDate, prevJobsLatestEndTime));
                lowerBound = prevJobsLatestEndDate;
            }

            [nextJobsEarliestStartDate, nextJobsEarliestStartTime] = jobInfo.nextJobsEarliestStartDateTime(jobInfo.nextJobsQueryExcludingJobs(currentOrderExclusiveJobList));
            if (nextJobsEarliestStartDate)
            {
                scheduleEngine.addConstraintJobEndsAt(_prodRouteJob.RecId, 0, DateTimeUtil::newDateTime(nextJobsEarliestStartDate, nextJobsEarliestStartTime));
                upperBound = nextJobsEarliestStartDate;
                if (nextJobsEarliestStartTime == 0)
                {
                    upperBound = upperBound - 1;
                }
            }
        }

        return [lowerBound, upperBound];
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retreives a value that can be used in maps that have as key the production order ID.
    /// </summary>
    /// <param name="_prodTable">
    ///    A <c>ProdTable</c> table buffer that contains the production order data.
    /// </param>
    /// <returns>
    ///    A string that contains the production order ID that is used as key for the specified production
    ///    order record.
    /// </returns>
    protected str keyOrder(Common _prodTable)
    {
        ProdTable prodTable = _prodTable as ProdTable;
        return prodTable.ProdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the lead time parameters for a given order.
    /// </summary>
    /// <param name="_order">
    /// The order for which to retrieve the lead time parameters.
    /// </param>
    /// <returns>
    /// A container that contains the parameters in the lead time format.
    /// </returns>
    /// <remarks>
    /// The lead time format uses calendar days.
    /// </remarks>
    protected container leadTimeParameters(Common _order)
    {
        ProdTable   prodTable = _order as ProdTable;
        ReqSetupDim setupDim = ReqSetupDim::newInventTable(InventTable::find(prodTable.ItemId), prodTable.InventDimId);

        return [setupDim.leadTime(ReqRefType::Production), setupDim.leadTimeCalendarDays(ReqRefType::Production)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether capacity reservations that are derived from planned orders are included in the
    /// calculation of available capacity when the scheduling is executed.
    /// </summary>
    /// <param name="_inventDimId">
    /// An <c>InventDimId</c> object that identifies the dimension by which to return the option to use the
    /// planned production orders capacity reservations.
    /// </param>
    /// <returns>
    /// true if the capacity reservations derived from planned orders are considered in the calculation;
    /// otherwise, false
    /// </returns>
    public boolean limitCapPO(InventDimId _inventDimId)
    {
        return ProdParametersDim::find(_inventDimId).LimitCapProdPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the capacity reservations that are derived from project hour forecasts will be
    /// included in the calculation of available capacity when executing scheduling.
    /// </summary>
    /// <param name="_inventDimId">
    /// An <c>InventDimId</c> object that identifies the dimension by which to return the option to use the
    /// project hour forecast capacity reservations.
    /// </param>
    /// <returns>
    /// true if the capacity reservations derived from project hour forecasts are considered in the
    /// calculation; otherwise, false.
    /// </returns>
    public boolean limitCapProject(InventDimId _inventDimId)
    {
        return ProdParametersDim::find(_inventDimId).LimitCapProdProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadJobsDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the job information for the jobs of one operation into the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters that are
    /// required for the scheduling of the order.
    /// </param>
    /// <param name="_order">
    /// A record that contains the data for the order that is being scheduled ( <c>ProdTable</c> ,
    /// <c>ReqTrans</c> , etc.).
    /// </param>
    /// <param name="_bomCalcData">
    /// A <c>BomCalcData</c> instance that is used to calculate the runtime of the job.
    /// </param>
    /// <param name="_routeMap">
    /// A <c>RouteMap</c> map that contains the operation data.
    /// </param>
    /// <param name="_siteId">
    /// The ID of the site stamped on the order.
    /// </param>
    /// <param name="_orderNext">
    /// A record with the data for the next (reference) order.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The start BOM level to use when determining the job goals.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// The maximal BOM level to use when determining the job goals.
    /// </param>
    /// <param name="_jobNumNextOprFirst">
    /// The record ID of the first job of the next operation.
    /// </param>
    /// <param name="_jobNumNextOprLast">
    /// The record ID of the last job of the next operation.
    /// </param>
    /// <returns>
    /// A container that contains the Record IDs for the first and last jobs.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The resource specified as the target resource for an operation is already in the scheduling of that
    /// operation.
    /// </exception>
    protected container loadJobsDetail(WrkCtrParmSchedule           _wrkCtrParmSchedule,
                                       Common                       _order,
                                       BOMCalcData                  _bomCalcData,
                                       RouteMap                     _routeMap,
                                       InventSiteId                 _siteId,
                                       Common                       _orderNext,
                                       BOMLevel                     _startCollectRefLevel,
                                       BOMLevel                     _maxCollectRefLevel,
                                       recId                        _jobNumNextOprFirst,
                                       recId                        _jobNumNextOprLast)
    {
        ProdJobType                 prodJobType;
        ProdRouteJob                prodRouteJob;

        SchedJobLink                primaryLink = SchedJobLink::None;
        SchedJobLinkType            primaryLinkType = SchedJobLinkType::None;

        boolean                     isFirstJob = true;
        RouteGroup                  routeGroup;
        MapEnumerator               mapEnumerator;

        recId                       jobNum;
        recId                       jobNumPrev = 0;
        recId                       jobNumFirst;

        Map                         mapJobNumPrevNumPrimSec = new Map(Types::String,Types::Int64); // Key = numPrimary#numSecondary, Value = JobNum

        List                        resourceList;
        RouteJobType                jobTypePrev = RouteJobType::QueueBefore;
        Map                         jobTimes;
        ProdUnitId                  prodUnitId;
        InventLocationIdInput       inputWarehouse;
        recId                       prevProdRouteRecId;
        real                        jobTimeForAllResources;
        Map                         requirementProperties;
        boolean                     useFastSetup;
        real                        primaryJobTime;
        ProdRoute                   prodRoute;
        ProdTable                   prodTable = _order as ProdTable;

        WrkCtrActivityRequirementSet    wrkCtrActivityRequirementSet;
        WrkCtrProdRouteActivity         wrkCtrProdRouteActivity;

        date singleJobSchedLowerBound;
        date singleJobSchedUpperBound;

        BOMCalcData bomCalcData = _bomCalcData;

        RouteJobNumType             prevNumType = -1;
        RecId                       primaryJobRecId;
        Map                         mapPrimaryRouteJobToJobTimes = new Map(Types::Container, Types::Container);
        container                   keyContainer;

        // initialize the parallel job map
        this.initParallelJobsMap();

        masterData.insert(prodTable.ProdId, prodTable);

        // Loop through all jobs in the operation
        while select forupdate prodRouteJob
            order by NumType, NumPrimary, OprPriority, NumSecondary, RecId
            where prodRouteJob.ProdId        == prodTable.ProdId &&
                  prodRouteJob.OprNum        == _routeMap.OprNum
                  && ( prodRouteJob.RecId    == _wrkCtrParmSchedule.schedJobRecId()
                       ||  !_wrkCtrParmSchedule.schedSingleJob())
        join prodRoute
            where   prodRoute.ProdId        == prodRouteJob.ProdId
            &&      prodRoute.OprNum        == prodRouteJob.OprNum
            &&      prodRoute.OprPriority   == prodRouteJob.OprPriority
        join wrkCtrProdRouteActivity
            where   wrkCtrProdRouteActivity.ProdId          == prodTable.ProdId
            &&      wrkCtrProdRouteActivity.OprNum          == prodRoute.OprNum
            &&      wrkCtrProdRouteActivity.OprPriority     == prodRoute.OprPriority
            &&      wrkCtrProdRouteActivity.RouteDataAreaId == prodRoute.DataAreaId
        join wrkCtrActivityRequirementSet
            where wrkCtrActivityRequirementSet.Activity == wrkCtrProdRouteActivity.Activity
        join routeGroup
            where routeGroup.RouteGroupId == prodRoute.RouteGroupId
        {
            jobNum = prodRouteJob.RecId;

            this.addJobToOverlapJobList(prodRouteJob, prodRoute.OprNumNext);

            prodJobType = ProdJobType::construct(prodRouteJob.JobType);

            requirementProperties = this.initRequirementProperties(
                _wrkCtrParmSchedule,
                prodRouteJob,
                wrkCtrActivityRequirementSet,
                _siteId);

            [prevProdRouteRecId, prodUnitId, inputWarehouse] = this.getProductionUnitAndWarehouse(
                prodRoute.RecId,
                prevProdRouteRecId,
                _wrkCtrParmSchedule,
                prodUnitId,
                inputWarehouse,
                prodRoute);

            if (_wrkCtrParmSchedule.schedSingleJob())
            {
                bomCalcData = BomCalcDataProdRouteJob::construct(_bomCalcData, prodRouteJob);
            }

            // Fast setup applies when
            // - only site and resource group requirements exists
            // - the job is not locked
            // - job scheduling is used
            // - runtimes are resource independent (formula0)
            // - not doing property limited scheduling
            // - not keeping resource assignments
            useFastSetup = !_wrkCtrParmSchedule.propertyLimited() &&
                           !this.mustKeepJobResourceAssignment(_wrkCtrParmSchedule, prodRouteJob) &&
                           (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail) &&
                           this.requirementsAllowFastSetup(requirementProperties) &&
                           prodJobType.isWrkCtrHoursResourceIndependent(prodRoute);

            if (useFastSetup)
            {
                if (prodRouteJob.OprPriority == RouteOprPriority::Primary && prodRouteJob.NumPrimary == 1)
                {
                    jobTimeForAllResources = this.computeJobTime(_wrkCtrParmSchedule,
                                                                 prodRouteJob,
                                                                 prodRoute,
                                                                 prodRoute,
                                                                 prodRouteJob.JobType,
                                                                 bomCalcData,
                                                                 prodRouteJob.JobStatus < ProdJobStatus::Completed,
                                                                 prodJobType);
                    primaryJobTime = jobTimeForAllResources;
                }
                else
                {
                    jobTimeForAllResources = primaryJobTime;
                }
            }
            else
            {
                resourceList = this.initResourceList(
                    _wrkCtrParmSchedule,
                    prodRouteJob,
                    wrkCtrActivityRequirementSet,
                    _siteId,
                    requirementProperties);

                if (resourceList.elements() == 0 ||
                    (wrkCtrSchedulerProdValidateResourceRequirementFlightIsEnabled &&
                    !this.mustKeepJobResourceAssignment(_wrkCtrParmSchedule, prodRouteJob) && !this.isSpecifiedResourceValid(resourceList, _wrkCtrParmSchedule)))
                {
                    this.addInfologMessage(
                        _wrkCtrParmSchedule,
                        WrkCtrJobSchedulingError::NoMatchingResources,
                        '',
                        prodRouteJob);
                }

                this.checkForHighNumberOfResourceCombinations(_wrkCtrParmSchedule,
                                                              wrkCtrActivityRequirementSet,
                                                              resourceList);

                if (prodRouteJob.OprPriority == RouteOprPriority::Primary)
                {
                    // Set common values for all parallel jobs
                    prodJobType    = ProdJobType::construct(prodRouteJob.JobType);
                    keyContainer   = [prodRouteJob.NumType, resourceList.pack()];

                    if (!mapPrimaryRouteJobToJobTimes.exists(keyContainer))
                    {
                        jobTimes = this.computeJobTimes(_wrkCtrParmSchedule,
                                                    prodRouteJob,
                                                    prodRoute,
                                                    prodRoute,
                                                    prodRouteJob.JobType,
                                                    resourceList,
                                                    bomCalcData,
                                                    prodRouteJob.JobStatus < ProdJobStatus::Completed,
                                                        prodJobType,
                                                        true,
                                                        '',
                                                        '',
                                                        WrkCtrActivityRequirementSet.Quantity);
                        mapPrimaryRouteJobToJobTimes.insert(keyContainer, jobTimes.pack());
                    }
                    else
                    {
                         jobTimes = Map::create(mapPrimaryRouteJobToJobTimes.lookup(keyContainer));
                    }

                    primaryJobTime = 0;
                    if (jobTimes.elements() > 0)
                    {
                        primaryJobTime = realMax();
                        mapEnumerator = jobTimes.getEnumerator();
                        while (mapEnumerator && mapEnumerator.moveNext())
                        {
                            if (primaryJobTime > mapEnumerator.currentValue())
                            {
                                primaryJobTime = mapEnumerator.currentValue();
                            }
                        }
                    }
                }
                else
                {
                    jobTimes = this.fixedJobTimesForResources(resourceList,
                                                              primaryJobTime);
                }
            }

            if (prodRouteJob.NumType != prevNumType)
            {
                primaryJobRecId = prodRouteJob.RecId;
                prevNumType     = prodRouteJob.NumType;
            }

            [primaryLink, primaryLinkType, jobNumFirst, isFirstJob, jobNumPrev, jobTypePrev] = this.insertJobAndConstraints(
                                                                                                                            prodRouteJob,
                                                                                                                            _wrkCtrParmSchedule,
                                                                                                                            prodUnitId,
                                                                                                                            inputWarehouse,
                                                                                                                            requirementProperties,
                                                                                                                            jobTimes,
                                                                                                                            wrkCtrActivityRequirementSet,
                                                                                                                            prodRoute.OprNumNext,
                                                                                                                            prodJobType,
                                                                                                                            routeGroup,
                                                                                                                            this.computeJobGoal(_wrkCtrParmSchedule, prodTable.CollectRefLevel, _startCollectRefLevel),
                                                                                                                            useFastSetup,
                                                                                                                            jobTimeForAllResources,
                                                                                                                            jobNumPrev,
                                                                                                                            mapJobNumPrevNumPrimSec,
                                                                                                                            resourceList,
                                                                                                                            isFirstJob,
                                                                                                                            jobTypePrev,
                                                                                                                            primaryLink,
                                                                                                                            primaryLinkType,
                                                                                                                            jobNumFirst,
                                                                                                                            primaryJobRecId);

            [singleJobSchedLowerBound, singleJobSchedUpperBound] = this.insertSingleJobStartEndConstraints(_wrkCtrParmSchedule, prodRouteJob);
            this.checkSingleJobSchedApplicableResources(_wrkCtrParmSchedule, wrkCtrActivityRequirementSet, _siteId, singleJobSchedLowerBound, singleJobSchedUpperBound);
        }

        // insert constraints for parallel jobs for a specific job type
        this.insertParallelJobsConstraints(jobTypePrev,
                                           _jobNumNextOprFirst,
                                           SchedJobLink::FS,
                                           primaryLinkType,
                                           _wrkCtrParmSchedule.schedMethod());

        // Return the first job and last job of this operation, which will be used in the next loop
        // for linking the previous operation to this operation
        return [jobNumFirst, jobNum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSpecifiedResourceValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the resource meet resource requirement.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters that are
    /// required for the scheduling of the order.
    /// </param>
    /// <param name = "_resourceList">
    /// A  list that contains all applicable resources.
    /// </param>
    /// <returns>
    /// True if the resource meet resource requirement or empty; otherwise, false.
    /// </returns>
    protected boolean isSpecifiedResourceValid(List _resourceList, WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        ListEnumerator enumerator;

        if (_wrkCtrParmSchedule.schedToWrkCtrId() == '')
        {
            return true;
        }

        enumerator = _resourceList.getEnumerator();

        while (enumerator.moveNext())
        {
            if (enumerator.current() == _wrkCtrParmSchedule.schedToWrkCtrId())
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRequirementProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes requirement properties.
    /// </summary>
    /// <param name = "_wrkCtrParmSchedule">A work schedule.</param>
    /// <param name = "_prodRouteJob">A production route job.</param>
    /// <param name = "_wrkCtrActivityRequirementSet">An activity requirements.</param>
    /// <param name = "_siteId">A site ID.</param>
    /// <returns>Requirement properties.</returns>
    [Replaceable]
    protected Map initRequirementProperties(
        WrkCtrParmSchedule _wrkCtrParmSchedule,
        ProdRouteJob _prodRouteJob,
        WrkCtrActivityRequirementSet _wrkCtrActivityRequirementSet,
        InventSiteId _siteId)
    {
        Map requirementProperties;

        if (this.mustKeepJobResourceAssignment(_wrkCtrParmSchedule, _prodRouteJob))
        {
            requirementProperties = this.getResourceRequirementProperties(_prodRouteJob.WrkCtrId);
        }
        else if (_wrkCtrParmSchedule.schedToWrkCtrId() && _wrkCtrParmSchedule.schedJobRecId() == _prodRouteJob.RecId)
        {
            requirementProperties = this.getResourceRequirementProperties(_wrkCtrParmSchedule.schedToWrkCtrId());
        }
        else
        {
            // Local cache of property information and applicable resources.
            Map mapOprPriorityToRequirementProperties = new Map(Types::Enum, Types::Class);

            this.updateRequirementSetAndPropertiesMaps(mapOprPriorityToRequirementProperties,
                                                        _prodRouteJob,
                                                        _wrkCtrActivityRequirementSet,
                                                        _siteId,
                                                        _wrkCtrParmSchedule.schedMethod());
            requirementProperties = mapOprPriorityToRequirementProperties.lookup(_prodRouteJob.OprPriority);
        }

        return requirementProperties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initResourceList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes resource list.
    /// </summary>
    /// <param name = "_wrkCtrParmSchedule">A work schedule.</param>
    /// <param name = "_prodRouteJob">A production route job.</param>
    /// <param name = "_wrkCtrActivityRequirementSet">An activity requirements.</param>
    /// <param name = "_siteId">A site ID.</param>
    /// <param name = "_requirementProperties">Requirement properties.</param>
    /// <returns>Resource list.</returns>
    [Replaceable]
    protected List initResourceList(
        WrkCtrParmSchedule _wrkCtrParmSchedule,
        ProdRouteJob _prodRouteJob,
        WrkCtrActivityRequirementSet _wrkCtrActivityRequirementSet,
        InventSiteId _siteId,
        Map _requirementProperties)
    {
        List resourceList;

        if (this.mustKeepJobResourceAssignment(_wrkCtrParmSchedule, _prodRouteJob))
        {
            resourceList = new List(Types::String);
            resourceList.addEnd(_prodRouteJob.WrkCtrId);
        }
        else
        {
            // Resources based on the requirements
            resourceList = wrkCtrApplicableResourceListCache.applicableResourceList(_wrkCtrActivityRequirementSet,
            _siteId,
            _wrkCtrParmSchedule.minimumSchedDate(),
            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Detail,
            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough,
            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough);

            boolean scheduleNewResource = WrkCtrSchedulerProdAddSchedToWrkCtrIdFlight::instance().isEnabled()
                && _wrkCtrParmSchedule.schedJobId()
                && _wrkCtrParmSchedule.schedFromWrkCtrId()
                && _wrkCtrParmSchedule.schedToWrkCtrId()
                && _wrkCtrParmSchedule.schedFromWrkCtrId() != _wrkCtrParmSchedule.schedToWrkCtrId();

            // Operations scheduling is done on resource groups, or a new resource is assigned manually
            if (_wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough || scheduleNewResource)
            {
                // operations scheduling with specific resource requirement
                WrkCtrId resourceId = this.getResourceRequirement(_requirementProperties);
                if (resourceId != '')
                {
                    resourceList.addEnd(resourceId);
                }
            }
        }

        return resourceList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for one order that is scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains order scheduling parameters.
    /// </param>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> record that contains the production order data.
    /// </param>
    protected void loadOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _prodTable)
    {
        ProdTable   prodTable = _prodTable as ProdTable;
        ProdTable   prodTableNext;
        ProdTable   prodTableRef;        
        OprNum      oprNum;

        super(_wrkCtrParmSchedule, _prodTable);

        if (scheduleEngineApplicableResourcesPeriodFlightIsEnabled && this.parmDataProvider())
        {
            this.parmDataProvider().parmWrkCtrParmSchedule(_wrkCtrParmSchedule);
        }

        if (!_wrkCtrParmSchedule.schedReference() || _wrkCtrParmSchedule.schedOnlyOprNum())
        {
            if (_wrkCtrParmSchedule.schedSingleJob())
            {
                this.addExclusiveJobToSchedule(_wrkCtrParmSchedule, _wrkCtrParmSchedule.schedJobRecId());
            }

            this.insertOrder(_wrkCtrParmSchedule, prodTable, null, 0, prodTable.CollectRefLevel);
        }
        else
        {
            BOMLevel maxCollectRefLevel;
            
            // Determine the max depth of children and check all productions part of the chain if they are valid.
            // Note that this validity check has to be done before any order is inserted since changes are made during insertion 
            while select prodTableRef
                where prodTableRef.CollectRefProdId == prodTable.CollectRefProdId
            {
                maxCollectRefLevel = max(maxCollectRefLevel, prodTableRef.CollectRefLevel);
                
                setprefix(#PreFixField(prodTableRef, ProdId));
                if (!this.canSchedule(prodTableRef))
                {
                    return;
                }
            }

            maxCollectRefLevel = prodTableRef.CollectRefLevel;

            // Load data for all referenced production orders
            while select forupdate prodTableRef
                order by CollectRefLevel
                where prodTableRef.CollectRefProdId == prodTable.CollectRefProdId
            {
                if (prodTableRef.InventRefType == InventRefType::ProdLine)
                {
                    prodTableNext = ProdTable::find(prodTableRef.InventRefId);
                    oprNum        = ProdBOM::findTransId(prodTableRef.InventRefTransId).OprNum;
                }
                else
                {
                    prodTableNext  = null;
                    oprNum         = 0;
                }

                this.insertOrder(_wrkCtrParmSchedule, prodTableRef, prodTableNext, oprNum, prodTable.CollectRefLevel, maxCollectRefLevel);

                if (prodTableRef.ProdId != prodTable.ProdId)
                {
                    this.createReferenceProdParmScheduling(prodTableRef.ProdId, _wrkCtrParmSchedule);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the information that is needed for scheduling a route for an order into the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters that are
    /// needed for scheduling the order.
    /// </param>
    /// <param name="_order">
    /// A record with the data for the order to begin scheduled.
    /// </param>
    /// <param name="_siteId">
    /// The order site ID.
    /// </param>
    /// <param name="_orderNext">
    /// A record that contains the next order that is linked to the order that is being scheduled; optional.
    /// </param>
    /// <param name="_orderNextOprNum">
    /// The operation number of the next order in which to link; optional.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The initial BOM level that is used to determine the job goals; optional.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// The maximal BOM level that is used to determine the job goals; optional.
    /// </param>
    public void loadRoute(WrkCtrParmSchedule     _wrkCtrParmSchedule,
                          Common                 _order,
                          InventSiteId           _siteId,
                          Common                 _orderNext = null,
                          OprNum                 _orderNextOprNum = 0,
                          BOMLevel               _startCollectRefLevel = 0,
                          BOMLevel               _maxCollectRefLevel = 0)
    {
        ProdTable       prodTable = _order as ProdTable;
        ProdRouteJob    schedFromJobData;

        if (prodTable.CheckRoute)
        {
            prodTable.status().runRouteUpdate();
            prodTable.reread();
        }

        if (_wrkCtrParmSchedule.schedJobRecId() && !_wrkCtrParmSchedule.schedSingleJob())
        {
            select firstonly RecId, ProdId, OprNum, JobType
                from schedFromJobData
                where schedFromJobData.RecId  == _wrkCtrParmSchedule.schedJobRecId()
                   && schedFromJobData.ProdId == prodTable.ProdId;
        }
        else
        {
            schedFromJobData = null;
        }

        super(_wrkCtrParmSchedule,
              _order,
              _siteId,
              _orderNext,
              _orderNextOprNum,
              _startCollectRefLevel,
              _maxCollectRefLevel);

        if (schedFromJobData.RecId != 0)
        {
            schedFromJobData = ProdRouteJob::findJobType(schedFromJobData.ProdId, schedFromJobData.OprNum, RouteOprPriority::Primary, schedFromJobData.JobType);
            if (schedFromJobData.RecId != 0)
            {
                this.insertSchedFromJobConstraints(ProdRouteJobInfo::newFromProdRouteJob(schedFromJobData), DateTimeUtil::newDateTime(_wrkCtrParmSchedule.schedDate(), _wrkCtrParmSchedule.schedTime()), _wrkCtrParmSchedule.schedDirection());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        this.parmRouteRefIdField(fieldNum(ProdRoute, ProdId));
        this.parmRefIdField(fieldNum(ProdTable, ProdId));
        this.parmRouteOprNumField(fieldNum(ProdRouteJob, OprNum));
        this.parmCheckForProdLocked(true);

        scheduleEngineApplicableResourcesPeriodFlightIsEnabled = ScheduleEngineApplicableResourcesPeriodFlight::instance().isEnabled();
        wrkCtrSchedulerProdValidateResourceRequirementFlightIsEnabled = WrkCtrSchedulerProdValidateResourceRequirementFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckForProdLocked</Name>
				<Source><![CDATA[
    public boolean parmCheckForProdLocked(boolean _checkForProdLocked = checkForProdLocked)
    {
        checkForProdLocked = _checkForProdLocked;
        return checkForProdLocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refLineType</Name>
				<Source><![CDATA[
    /// <summary>
    /// The reference line type that is on the <c>ReqTrans</c> records for the current order.
    /// </summary>
    /// <param name="_order">
    /// A record that contains the data for the order that is being scheduled.
    /// </param>
    /// <returns>
    /// A <c>ReqRefType</c> enumeration value.
    /// </returns>
    protected ReqRefType refLineType(Common _order)
    {
        return ReqRefType::ProdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refId</Name>
				<Source><![CDATA[
    protected InventTransRefId refId(WrkCtrParmSchedule	_wrkCtrParmSchedule, Common _order)
    {
        ProdTable prodTable = _order;
        
        return prodTable.ProdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSaveOperationSchedulingResults</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the scheduling results for an operation can be saved.
    /// </summary>
    /// <param name="_prodRoute">
    /// A <c>ProdRoute</c> table buffer that contains the operation record.
    /// </param>
    /// <returns>
    /// True if the scheduling results for the operation can be saved; otherwise, false.
    /// </returns>
    protected boolean canSaveOperationSchedulingResults(ProdRoute _prodRoute)
    {
        return canUpdateCompletedRoute || _prodRoute.OprFinished == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production route.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route to initialize.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_operationData">
    /// A container that contains the start and end dates for the operation.
    /// </param>
    protected void initializeProdRoute(ProdRoute _prodRoute, WrkCtrParmSchedule _wrkCtrParmSchedule, container _operationData)
    {
        SchedFromDate   fromDate;
        SchedFromTime   fromTime;
        SchedToDate     toDate;
        SchedToTime     toTime;
       [fromDate, fromTime, toDate, toTime] = _operationData;

       _prodRoute.FromDate = fromDate;
       _prodRoute.FromTime = (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail ? fromTime : 0);
       _prodRoute.ToDate = toDate;
       _prodRoute.ToTime = (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail ? toTime : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the scheduling results for an operation to the database.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_prodRoute">
    /// A <c>ProdRoute</c> table buffer that contains the operation record.
    /// </param>
    /// <param name="_operationData">
    /// A container that contains the start and end dates for the operation.
    /// </param>
    protected void saveOperation(WrkCtrParmSchedule _wrkCtrParmSchedule,
                                 Common             _prodRoute,
                                 container          _operationData)
    {
        ProdRoute       prodRoute = _prodRoute as ProdRoute;
        SchedFromDate   prodFromDate;
        SchedFromTime   prodFromTime;
        SchedToDate     prodToDate;
        SchedToTime     prodToTime;

        SchedFromDate   fromDate;
        SchedFromTime   fromTime;
        SchedToDate     toDate;
        SchedToTime     toTime;
        ProdId          prodId = prodRoute.ProdId;

        str             keyRoute;

        [fromDate, fromTime, toDate, toTime] = _operationData;

        super(_wrkCtrParmSchedule,
              _prodRoute,
              _operationData);

        _wrkCtrParmSchedule = masterDataParms.lookup(_wrkCtrParmSchedule.schedNumId());

        // Aggregate times on production level
        if (!mapOrderData.exists(prodId))
        {
            prodFromDate = fromDate;
            prodFromTime = fromTime;
            prodToDate = toDate;
            prodToTime = toTime;
        }
        else
        {
            [prodFromDate, prodFromTime, prodToDate, prodToTime] = mapOrderData.lookup(prodId);

            if ((fromDate < prodFromDate) || (fromDate == prodFromDate && fromTime < prodFromTime))
            {
                prodFromDate = fromDate;
                prodFromTime = fromTime;
            }

            if ((toDate > prodToDate) || (toDate == prodToDate && toTime > prodToTime))
            {
                prodToDate = toDate;
                prodToTime = toTime;
            }
        }

        mapOrderData.insert(prodId, [prodFromDate,prodFromTime,prodToDate, prodToTime]);

        if (!temporaryOperations.in(prodRoute.RecId) && this.canSaveOperationSchedulingResults(prodRoute))
        {
            prodRoute.selectForUpdate();

            this.initializeProdRoute(prodRoute, _wrkCtrParmSchedule, [fromDate, fromTime, toDate, toTime]);

            prodRoute.initDimensionWrkCtrTable();
            prodRoute.update();

            if (prodRoute.OprPriority == RouteOprPriority::Primary)
            {
                keyRoute = this.keyRoute(prodRoute.ProdId, prodRoute.OprNum, prodRoute.OprPriority);
                if (    prodRoute.TransferBatch
                    &&  processScheduleResult.exists(keyRoute)
                    &&  overlapScheduleResult.exists(keyRoute))
                {
                    this.updateRouteOverlapQty(
                        prodRoute,
                        processScheduleResult.lookup(keyRoute),
                        overlapScheduleResult.lookup(keyRoute));

                    // a regular update would trigger job re-creation
                    prodRoute.doUpdate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseSameResource</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check whether scheduled job should keep resource, if scheduled job and current job are
    ///     parallel then we should keep the resource, otherwise resource should not be kept
    /// </summary>
    /// <param name="_schedJobRecId">
    ///     <c>recId</c> of the job being scheduled
    /// </param>
    /// <param name="_routeJobMap">
    ///     The job about to be loaded into the scheduling engine.
    /// </param>
    /// <returns>
    ///     <c>true</c> if jobs are parallel, otherwise <c>false</c>
    /// </returns>
    protected boolean mustUseSameResource(RecId _schedJobRecId, RouteJobMap _routeJobMap)
    {
        ProdRouteJob prodRouteJob = ProdRouteJob::findRecId(_schedJobRecId);
        return prodRouteJob.OprNum == _routeJobMap.OprNum
            && prodRouteJob.OprPriority == _routeJobMap.OprPriority
            && prodRouteJob.NumPrimary == _routeJobMap.NumPrimary
            && prodRouteJob.NumSecondary == _routeJobMap.NumSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSaveOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the scheduling results for a production order can be saved.
    /// </summary>
    /// <returns>
    ///     true if the scheduling results for a production order can be saved; otherwise, false.
    /// </returns>
    protected boolean canSaveOrder()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the scheduling results for a production order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_prodTable">
    ///    A <c>ProdTable</c> table buffer that contains the order master data. This can be a <c>ProdTable</c>
    ///    buffer.
    /// </param>
    /// <param name="_prodTableData">
    ///    A container with the start and end dates for the order. The container holds the <c>fromDate</c>,
    ///    <c>fromTime</c>, <c>toDate</c>, and <c>toTime</c> values.
    /// </param>
    protected void saveOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _prodTable,
                             container          _prodTableData)
    {
        ProdTable       prodTable = _prodTable as ProdTable;
        SchedFromDate   fromDate;
        SchedFromTime   fromTime;
        SchedToDate     toDate;
        SchedToTime     toTime;
        ProdRoute       prodRoute;
        boolean         dateInit = false;

        if (!this.canSaveOrder())
        {
            return;
        }

        super(_wrkCtrParmSchedule,
              _prodTable,
              _prodTableData);

        this.checkSchedulingDirectionChange(_wrkCtrParmSchedule,
                                            _prodTable,
                                            "@SYS26421");

        if (!prodTable.status().isBefore(ProdStatus::ReportedFinished))
        {
            // No scheduling changes should be made to the order when it is reported as finished,
            // only the cleanup logic should be run
            this.deleteIncompleteProdRouteJobs(_wrkCtrParmSchedule, prodTable, false);
            return;
        }

        if (_wrkCtrParmSchedule.schedOnlyOprNum() || _wrkCtrParmSchedule.schedSingleJob())
        {
            // Get the min/max dates from all operations and not just the one that was scheduled
            while select FromDate, ToDate, FromTime, ToTime from prodRoute
                where prodRoute.ProdId       == prodTable.ProdId &&
                        prodRoute.OprPriority  == RouteOprPriority::Primary
            {
                if (! dateInit)
                {
                    fromDate    = prodRoute.FromDate;
                    fromTime    = prodRoute.FromTime;
                    toDate      = prodRoute.ToDate;
                    toTime      = prodRoute.ToTime;

                    dateInit    = true;
                }
                else
                {
                    if (fromDate > prodRoute.FromDate || (fromDate == prodRoute.FromDate && fromTime > prodRoute.FromTime))
                    {
                        fromDate    = prodRoute.FromDate;
                        fromTime    = prodRoute.FromTime;
                    }
                    if (toDate < prodRoute.ToDate || (toDate == prodRoute.ToDate && toTime < prodRoute.ToTime))
                    {
                        toDate    = prodRoute.ToDate;
                        toTime    = prodRoute.ToTime;
                    }
                }
            }            
        }
        else
        {
            [fromDate, fromTime, toDate, toTime] = _prodTableData;
        }

        // Modify the status so that it reflects now the order being scheduled
        if (prodTable.status().isBefore(ProdStatus::Scheduled))
        {
            prodTable.ProdStatus = ProdStatus::Scheduled;
        }

        this.initializeProdTableSchedule(prodTable, _wrkCtrParmSchedule, fromDate, fromTime, toDate, toTime);

        this.deleteIncompleteProdRouteJobs(_wrkCtrParmSchedule, prodTable, true);

        prodTable.update();

        this.updateBOMLineInputWarehouse(prodTable);

        using(var context = WrkCtrParmScheduleContext::newStandard(_wrkCtrParmSchedule))
        {
			prodTable.updateRawMaterialDates();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdTableSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the schedule details for a given production order.
    /// </summary>
    /// <param name = "_prodTable">An instance of <c>ProdTable</c> record.</param>
    /// <param name = "_wrkCtrParmSchedule">An instance of the <c>WrkCtrParmSchedule</c> class.</param>
    /// <param name = "_fromDate">From date.</param>
    /// <param name = "_fromTime">From time.</param>
    /// <param name = "_toDate">To date.</param>
    /// <param name = "_toTime">To time.</param>
    [Replaceable]
    protected void initializeProdTableSchedule(        
        ProdTable           _prodTable,
        WrkCtrParmSchedule  _wrkCtrParmSchedule,
        SchedFromDate       _fromDate,
        SchedFromTime       _fromTime,
        SchedToDate         _toDate,
        SchedToTime         _toTime)
    {
        _prodTable.SchedStatus            = this.schedStatus(_wrkCtrParmSchedule);
        _prodTable.SchedDate              = _wrkCtrParmSchedule.todaysdate();
        _prodTable.LatestSchedDate        = _wrkCtrParmSchedule.schedDate();
        _prodTable.LatestSchedTime        = _wrkCtrParmSchedule.schedTime();
        _prodTable.LatestSchedDirection   = _wrkCtrParmSchedule.schedDirection();

        _prodTable.SchedStart             = _fromDate;
        _prodTable.SchedEnd               = _toDate;
        _prodTable.SchedFromTime          = _fromTime;
        _prodTable.SchedToTime            = _toTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteIncompleteProdRouteJobs</Name>
				<Source><![CDATA[
    private void deleteIncompleteProdRouteJobs(WrkCtrParmSchedule _wrkCtrParmSchedule, ProdTable _prodTable, boolean _updateProdTable)
    {
        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough)
        {
            ProdRouteJob prodRouteJob; 

            delete_from prodRouteJob
                    where prodRouteJob.ProdId    == _prodTable.ProdId
                       && prodRouteJob.JobStatus != ProdJobStatus::Completed;
            
            if (_updateProdTable)
            {
                _prodTable.RouteJobs = NoYes::No;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferBatchTimeToProcessTimeRatio</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the ratio between the time that is required to process one transferrable batch and the
    /// total time of the specified operation.
    /// </summary>
    /// <param name="_operationReference">
    /// A record that contains a reference to the operation for which to calculate the ratio.
    /// </param>
    /// <param name="_order">
    /// The order to which the operation belongs.
    /// </param>
    /// <returns>
    /// The ratio between the time that is required to process one transferrable batch and the total time
    /// of the specified operation.
    /// </returns>
    /// <remarks>
    /// If there is no transfer batch quantity on the specified operation, 1 is returned.
    /// </remarks>
    protected real transferBatchTimeToProcessTimeRatio(RouteMap _operationReference, Common _order)
    {
        ProdTable prodTable;
        ProdRoute prodRoute;

        prodTable = _order as ProdTable;

        select firstonly TransferBatch from prodRoute
            where   prodRoute.ProdId        == _operationReference.RefId
                &&  prodRoute.OprNum        == _operationReference.OprNum
                &&  prodRoute.OprPriority   == RouteOprPriority::Primary;

        if (!prodTable || !prodRoute)
        {
            throw error(strFmt("@SYS54195", funcName()));
        }

        if (    prodRoute.TransferBatch <= 0
            ||  prodRoute.TransferBatch >= prodTable.QtySched
            ||  prodTable.QtySched == 0)
        {
            return 1;
        }

        return prodRoute.TransferBatch / prodTable.QtySched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMLineInputWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the picking warehouse on the bills of material (BOM) lines with the input warehouses of the
    ///    selected resources.
    /// </summary>
    /// <param name="_prodTable">
    ///    A <c>ProdTable</c> record that contains the order information.
    /// </param>
    protected void updateBOMLineInputWarehouse(ProdTable _prodTable)
    {
        // Loop through BOM lines to set the picking warehouse
        ProdBOM prodBOM;

        while select forupdate prodBOM
            where   prodBOM.ProdId              == _prodTable.ProdId
                &&  prodBOM.WrkCtrConsumption   == NoYes::Yes
        {
            InventDim inventDim = InventDim::find(prodBOM.InventDimId);
            ProdRoute prodRoute;

            while select prodRoute
                order by OprNum
            where   prodRoute.ProdId            == _prodTable.ProdId
                &&  (prodRoute.OprNum           == prodBOM.OprNum
                ||   prodBOM.OprNum             == 0)
            {
                if (    prodRoute.OprNum        == prodBOM.OprNum
                     || (prodBOM.OprNum         == 0
                     &&  prodRoute.isFirstOpr()))
                {
                    if (mapOperationData.exists(this.keyRoute(prodRoute.ProdId, prodRoute.OprNum, prodRoute.OprPriority)))
                    {
                        TransDate   startDate, endDate;
                        timeOfDay   startTime, endTime;
                        WrkCtrId    resourceId;
                        [startDate, startTime, endDate, endTime, resourceId] = mapOperationData.lookup(this.keyRoute(prodRoute.ProdId, prodRoute.OprNum, prodRoute.OprPriority));

                        WMSLocation resourceWMSLocation = WrkCtrTable::find(resourceId).inputWMSLocation(startDate);
                
                        if (resourceWMSLocation)
                        {
                            if (inventDim.wMSLocationId != resourceWMSLocation.wMSLocationId
                                ||inventDim.InventLocationId != resourceWMSLocation.InventLocationId)
                                            
                            {
                                if (resourceWMSLocation.inventLocation().WHSEnabled
                                    && InventTable::find(prodBOM.ItemId).whsItemIsWHSControlled())
                                {
                                    inventDim.wMSLocationId = '';
                                }
                                else
                                {
                                    inventDim.wMSLocationId = resourceWMSLocation.wMSLocationId;
                                }

                                inventDim.InventLocationId = resourceWMSLocation.InventLocationId;
                                prodBOM.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
                                prodBOM.update();
                            }
                                            
                            break;
                        }

                        WrkCtrResourceGroup wrkCtrResourceGroup = WrkCtrTable::resourceGroup(resourceId, startDate, startDate);

                        if (wrkCtrResourceGroup)
                        {
                            InventLocationIdInput inputWarehouse = wrkCtrResourceGroup.inputInventLocationIdFallback();

                            // Update the picking warehouse

                            if (inputWarehouse != inventDim.InventLocationId)
                            {
                                inventDim.InventLocationId = inputWarehouse;
                                prodBOM.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
                                prodBOM.update();
                            }

                            break;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExplosion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the explosion for a scheduled production order.
    /// </summary>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> table buffer that contains the production order data to be updated.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    protected void updateExplosion(ProdTable _prodTable, WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Req)) && this.canRunExplosion())
        {
            if (_wrkCtrParmSchedule.materialLimited())
            {
                // This check ensures that the selected production order in job scheduling form will be scheduled only once in reference scheduling when 
                // the current scheduled order is for this production order, otherwise, the production order will be scheduled many times 
                // when other production orders are scheduled, and this would cause that it always reserves the capacity and it will not be released, 
                // this will cause the reserved capacity not to be used by itself in later scheduling for all the referenced production orders
                if (needRereadJob && _wrkCtrParmSchedule.schedNumId() != _prodTable.ProdId)
                {
                    _prodTable.reread();
                }
                else if (_wrkCtrParmSchedule.schedNumId() == _prodTable.ProdId)
                {
                    needRereadJob = true;

                    // First we need to schedule with unlimited materials to set correct required date for the materials
                    // Only the specific order will be scheduled, no references
                    var wrkCtrParmScheduleUnlimitedMaterials = _wrkCtrParmSchedule.cloneForUnlimitedMaterialsRun(false);

                    WrkCtrScheduler_Prod prodScheduler = WrkCtrScheduler_Prod::newCheckLockingTTSLevel(false);
                    prodScheduler.reset();
                    prodScheduler.addWrkCtrParmSchedule(wrkCtrParmScheduleUnlimitedMaterials);
                    prodScheduler.run();

                    _prodTable.reread();

                    InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().insertInventSumLogTTS();
                }
            }

            boolean autoReserveCoverage = _prodTable.mustUpdateReservationUsingExplosionBeforeScheduling();

            if (_wrkCtrParmSchedule.canUpdateExplosion() && (autoReserveCoverage || _wrkCtrParmSchedule.materialLimited()))
            {
                boolean deleteCoverage = _wrkCtrParmSchedule.materialLimited();
                var reqCalcExplodeProd  = ReqCalcExplodeProd::newProdTable(_prodTable, autoReserveCoverage, deleteCoverage, false);
                reqCalcExplodeProd.parmMarking(false);
                reqCalcExplodeProd.parmRecalculateBomLevels(_wrkCtrParmSchedule.parmRecalculateBomLevels());
                reqCalcExplodeProd.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunExplosion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if explosion logic can run during scheduling production order.
    /// </summary>
    /// <returns>True if explosion logic can run; otherwise, false.</returns>
    [Wrappable(true)]
    internal boolean canRunExplosion()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRouteOverlapQty</Name>
				<Source><![CDATA[
    protected void updateRouteOverlapQty(ProdRoute _prodRoute, RouteOprTime _processTime, RouteOprTime _overlapTime)
    {
        ProdTable                       prodTable;
        RouteOprQtyOverlap              newOverlapQty;
        UnitOfMeasureDecimalPrecision   roundingPrecision;

        if (_processTime != 0 && _overlapTime != 0)
        {
            select firstonly ItemId, QtySched from prodTable where prodTable.ProdId == _prodRoute.ProdId;

            roundingPrecision = this.getItemInventUnitPrecision(prodTable.ItemId);
            newOverlapQty = roundUpDec(prodTable.QtySched * _overlapTime / _processTime, roundingPrecision);

            if (newOverlapQty > (prodTable.QtySched - _prodRoute.TransferBatch))
            {
                newOverlapQty = 0;
            }

            if (newOverlapQty != _prodRoute.OverlapQty)
            {
                setPrefix(strFmt("@SYS302657", _prodRoute.OprNum, _prodRoute.OprPriority));
                info(strFmt("@SYS88445", _prodRoute.OverlapQty, newOverlapQty));

                _prodRoute.OverlapQty = newOverlapQty;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeJobData</Name>
				<Source><![CDATA[
    public void writeJobData(RecId      _jobId,
                         WrkCtrId   _resourceId,
                         date       _fromDate,
                         TimeOfDay  _fromTime,
                         date       _toDate,
                         TimeOfDay  _toTime,
                         Seconds    _runtime,
                         container  _reservationProperties,
                         container  _capacityReservations,
                         boolean    _physicalUpdateJobs = true)
    {
        if (jobData.exists(_jobId))
        {
            ProdRouteJob prodRouteJob = jobData.lookup(_jobId);
            
            if (!canUpdateCompletedRoute && prodRouteJob.JobStatus == ProdJobStatus::Completed)
            {
                return;
            }
        }

        super(_jobId, _resourceId, _fromDate, _fromTime, _toDate, _toTime, _runtime, _reservationProperties, _capacityReservations, _physicalUpdateJobs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrScheduler_Prod construct()
    {
        return new WrkCtrScheduler_Prod();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEngine</Name>
				<Source><![CDATA[
    protected WrkCtrSchedulerEngineInterface createEngine(Microsoft.Dynamics.AX.Planning.JobScheduling.LoggingOptions _loggingOptions = null)
    {
        if (scheduleEngineApplicableResourcesPeriodFlightIsEnabled)
        {
            dataProvider = WrkCtrSchedulingInteropDataProvider::newWrkCtrCapResHandler(this.parmCapResHandler());
            return WrkCtrSchedulerJobSchedulingEngine::newSchedulingEngine(wrkCtrSchedulerRuntimes, this, _loggingOptions, dataProvider);
        }
        else
        {
            return super(_loggingOptions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckLockingTTSLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>WrkCtrScheduler_Prod</c> class.
    /// </summary>
    /// <param name="_checkLockingTTSLevel">
    /// A Boolean that indicates whether the TTS level check is performed when locking is performed for
    /// capacity reservations saving.
    /// </param>
    /// <returns>
    /// A new instance of the <c>WrkCtrScheduler_Prod</c> class.
    /// </returns>
    public static WrkCtrScheduler_Prod newCheckLockingTTSLevel(boolean _checkLockingTTSLevel = true)
    {
        WrkCtrScheduler_Prod scheduler = new WrkCtrScheduler_Prod();

        scheduler.parmCheckLockingTTSLevel(_checkLockingTTSLevel);

        return scheduler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldIgnoreJobCapacityConstraints</Name>
				<Source><![CDATA[
    protected boolean shouldIgnoreJobCapacityConstraints(RouteJobMap _routeJobMap)
    {
        if (_routeJobMap is ProdRouteJob)
        {
            ProdRouteJob routeJob = _routeJobMap as ProdRouteJob;

            return routeJob.JobFinished == NoYes::Yes;
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDataProvider</Name>
				<Source><![CDATA[
    protected WrkCtrSchedulingInteropDataProvider parmDataProvider(WrkCtrSchedulingInteropDataProvider _dataProvider = dataProvider)
    {
        dataProvider = _dataProvider;
        return dataProvider;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>