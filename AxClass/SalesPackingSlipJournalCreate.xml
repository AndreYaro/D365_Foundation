<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesPackingSlipJournalCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::PackingSlip)]
[DocumentStatusFactoryAttribute(DocumentStatus::ProjectPackingSlip)]
[DocumentStatusFactoryAttribute(DocumentStatus::DeliverySlip_BR)]
class SalesPackingSlipJournalCreate extends FormLetterVersionableJournalCreate
{
    CustPackingSlipVersion      custPackingSlipVersion;
    CustPackingSlipJour         custPackingSlipJour;
    VendInvoiceJour             vendInvoiceJour;
    VendInvoiceTrans            vendInvoiceTrans;
    VendPackingSlipJour         vendPackingSlipJour;
    AddressCountryRegionId      vendCountryRegionId;
    protected AddressStateId    vendStateId;

    SalesTable                  salesTable;
    SalesParmTable              salesParmTable;
    SalesParmUpdate             salesParmUpdate;

    SalesTotals                 salesTotals;
    RecordSortedList            recordListSalesParmLine;
    NoYes                       creditNote;
    NumberOfRecords             numberOfVersions;
    SalesParameters             salesParameters;
    boolean                     isExtensionIntrastatEnabled;

    boolean                     isCountryRegion_PL;
    boolean                     isCountryRegion_LTLV;
    boolean                     isLegalEntityInEEU;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the accounting date of the journal version.
    /// </summary>
    /// <param name="_showMessage">
    /// A Boolean value that indicates whether a message should be shown that states that the next
    /// available date will be used if the original accounting date cannot be used.
    /// </param>
    /// <returns>
    /// The available accounting date.
    /// </returns>
    public AccountingDate adjustAccountingDate(boolean _showMessage)
    {
        Map                 dataAreaIds;
        AccountingDate      prevAccountingDate;
        VendPackingSlipJour localVendPackingSlipJour;

        FormLetterContract formLetterContract = this.parmInterCompanyFormletterContract();

        accountingDate = formLetterContract.parmAccountingDate();
        if (!accountingDate)
        {
            accountingDate = CustPackingSlipVersion::findLatest(custPackingSlipJour.RecId).AccountingDate;

            if (custPackingSlipJour.existsStockedProduct())
            {
                TransDate inventoryClosingDate = InventClosing::closingDate();

                if (accountingDate <= inventoryClosingDate)
                {
                    accountingDate = inventoryClosingDate + 1;

                    if (_showMessage)
                    {
                        info("@SYS328875");
                    }
                }
            }

            //find the corresponding intercompany vendPackingSlipJour and check inventory date for it.
            select crossCompany localVendPackingSlipJour
            where  localVendPackingSlipJour.PackingSlipId         == custPackingSlipJour.PackingSlipId
                && localVendPackingSlipJour.DeliveryDate          == custPackingSlipJour.DeliveryDate
                && localVendPackingSlipJour.InterCompanyCompanyId == custPackingSlipJour.DataAreaId
                && localVendPackingSlipJour.InterCompanySalesId   == custPackingSlipJour.SalesId;

            if (localVendPackingSlipJour.RecId)
            {
                dataAreaIds = new Map(Types::String, Types::Record);
                accountingDate = PurchPackingSlipJournalCreate::findAvailableInventoryDate(localVendPackingSlipJour, accountingDate,
                                                                                           dataAreaIds, _showMessage);
            }

            do
            {
                accountingDate = SalesPackingSlipJournalCreate::findOpenFiscalDate(accountingDate, _showMessage);
                prevAccountingDate = accountingDate;
                if (dataAreaIds && dataAreaIds.elements())
                {
                    accountingDate = PurchPackingSlipJournalCreate::findOpenFiscalDate(accountingDate, dataAreaIds, _showMessage);
                }
            }
            while (prevAccountingDate != accountingDate);

            formLetterContract.parmAccountingDate(accountingDate);
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateCorrectionVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates the correction voucher.
    /// </summary>
    /// <returns>
    /// The correction voucher number sequence object.
    /// </returns>
    protected NumberSeq allocateCorrectionVoucher()
    {
        NumberSequenceDatatype  correctionVoucherDatatype = NumberSequenceDatatype::find(SalesParameters::numRefSalesPackingSlipCorrectionVoucher().NumberSequenceDatatype);
        RefRecId                scopeId = NumberSeqScopeFactory::createDefaultScope().getId();

        NumberSequenceGroupId numberSeqGroupId = this.numberSequenceGroupId();

        if (numberSeqGroupId)
        {
            RefRecId packingSlipCorrectionVoucher = NumberSequenceGroupRef::findNaturalKey(
                correctionVoucherDatatype.RecId,
                scopeId,
                numberSeqGroupId).NumberSequenceId;

            if (!packingSlipCorrectionVoucher)
            {
                packingSlipCorrectionVoucher = SalesParameters::numRefSalesPackingSlipCorrectionVoucher().NumberSequenceId;
            }

            numberSeq = NumberSeq::newGetVoucherFromId(packingSlipCorrectionVoucher);
        }
        else
        {
            numberSeq = NumberSeq::newGetVoucher(SalesParameters::numRefSalesPackingSlipCorrectionVoucher());
        }

        return numberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number sequence group ID from the order header.
    /// </summary>
    /// <returns>
    /// A number sequence group ID.
    /// </returns>
    protected NumberSequenceGroupId numberSequenceGroupId()
    {
        NumberSequenceGroupId numSeqGroupId;
        if (TaxIntegrationUtils::isMultipleTaxIdAllowedWithinOneSalesOrder())
        {
            numSeqGroupId = TaxIntegrationTaxIdUtility::getNumberSequenceGroupIdByTaxId(salesParmTable.TaxId);
        }
        return numSeqGroupId ? numSeqGroupId : salesTable.NumberSequenceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateNumAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates a journal and voucher number from the corresponding number sequences.
    /// </summary>
    /// <returns>
    /// A <c>NumberSeq</c> object.
    /// </returns>
    protected NumberSeq allocateNumAndVoucher()
    {
        NumberSequenceDatatype  numberDatatype = NumberSequenceDatatype::find(SalesParameters::numRefPackingSlipId().NumberSequenceDatatype);
        NumberSequenceDatatype  voucherDatatype = NumberSequenceDatatype::find(SalesParameters::numRefSalesPackingSlipVoucher().NumberSequenceDatatype);
        RefRecId                scopeId = NumberSeqScopeFactory::createDefaultScope().getId();
        RefRecId                packingSlipNumber;
        RefRecId                packingSlipVoucher;

        boolean                 voucherEqualsNumber;
        boolean                 countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean                 countryRegion_LTLVPL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV, #isoPL]);

        if (countryRegion_LTLVPL)
        {
            packingSlipNumber = NumberSequenceTable::findByNaturalKey(this.packingSlipNumber_W(), NumberSeqScopeFactory::createDefaultScope().getId()).RecId;
        }

        NumberSequenceGroupId numberSeqGroupId = this.numberSequenceGroupId();
        if (numberSeqGroupId)
        {
            if (! packingSlipNumber)
            { //
                packingSlipNumber = NumberSequenceGroupRef::findNaturalKey(numberDatatype.RecId, scopeId, numberSeqGroupId).NumberSequenceId;
            } //

            if (!packingSlipNumber)
            {
                packingSlipNumber = SalesParameters::numRefPackingSlipId().NumberSequenceId;
            }

            if (SalesParameters::numRefSalesPackingSlipVoucher().AllowSameAs)
            {
                voucherEqualsNumber = true;
                packingSlipVoucher  = packingSlipNumber;
            }
            else
            {
                packingSlipVoucher = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, numberSeqGroupId).NumberSequenceId;

                if (!packingSlipVoucher)
                {
                    packingSlipVoucher = SalesParameters::numRefSalesPackingSlipVoucher().NumberSequenceId;
                }
            }

            if (countryRegion_RU || countryRegion_LTLVPL)
            {
                return NumberSeq::newGetNumAndVoucherFromId(packingSlipNumber,
                                                            packingSlipVoucher,
                                                            voucherEqualsNumber,
                                                            false,
                                                            false,
                                                            UnknownNoYes::No);
            }
            else
            {
                return NumberSeq::newGetNumAndVoucherFromId(packingSlipNumber, packingSlipVoucher, voucherEqualsNumber);
            } //
        }

        if ((countryRegion_RU || countryRegion_LTLVPL) && packingSlipNumber)
        {
            if (SalesParameters::numRefSalesPackingSlipVoucher().AllowSameAs)
            {
                voucherEqualsNumber = true;
                packingSlipVoucher  = packingSlipNumber;
            }
            else
            {
                packingSlipVoucher = SalesParameters::numRefSalesPackingSlipVoucher().NumberSequenceId;
            }
            return NumberSeq::newGetNumAndVoucherFromId(packingSlipNumber,
                                                        packingSlipVoucher,
                                                        voucherEqualsNumber,
                                                        false,
                                                        false,
                                                        UnknownNoYes::No);
        } //

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDiscardLine</Name>
				<Source><![CDATA[
    protected boolean  checkDiscardLine(Common _salesParmLine)
    {
        SalesParmLine       salesParmLine = _salesParmLine as SalesParmLine;

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            RetailGiftCardTable retailGiftCardTable = salesParmLine.salesLine().mcrRetailGiftCardTable();

            if (retailGiftCardTable && retailGiftCardTable.MCRGiftCardType == MCRGiftCardType::Email)
            {
                return true;
            }

            // A gift card item cannot be invoiced if it does not have a serial number by invoicing.
            if (retailGiftCardTable && retailGiftCardTable.MCRGiftCardType == MCRGiftCardType::Physical)
            {
                if (retailGiftCardTable.EntryId == '')
                {
                    throw error(strfmt("@MCR34074", salesParmLine.ItemId));
                }
            }
        }

        if (SalesPackingSlipDeliverNowQtySignFlightV2::instance().isEnabled()
            && salesParmLine.DeliverNow != 0
            && sign(salesParmLine.DeliverNow) != sign(salesParmLine.salesLine().SalesQty))
        {
            throw error("@SYS331618");
        }

        return super(_salesParmLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDuplicateNum_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to check if a duplicate packing slip number exists.
    /// </summary>
    /// <param name="_num">
    ///     PackingSlipId of the unposted transaction that needs to be checked for duplicity.
    /// </param>
    /// <param name="_salesId">
    ///     SalesId of the unposted transaction.
    /// </param>
    /// <param name="_transDate">
    ///     DeliveryDate of the unposted transaction.
    /// </param>
    /// <returns>
    ///     True, if a a posted transaction exists with the same PackingSlipId.
    /// </returns>
    final public boolean checkDuplicateNum_W(Num _num, SalesIdBase _salesId, TransDate _transDate)
    {
        CustPackingSlipJour custPackingSlipJourLocal;

        boolean ret = super(_num, _salesId, _transDate);

        if (ret && _num)
        {
            select firstonly custPackingSlipJourLocal
                where custPackingSlipJourLocal.PackingSlipId == _num     &&
                      custPackingSlipJourLocal.SalesId       == _salesId &&
                      custPackingSlipJourLocal.DeliveryDate  == _transDate;

            if (custPackingSlipJourLocal)
            {
                ret = checkFailed(strFmt("@GLS110642",
                                         custPackingSlipJourLocal.PackingSlipId,
                                         custPackingSlipJourLocal.SalesId,
                                         custPackingSlipJourLocal.DeliveryDate));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks a journal line.
    /// </summary>
    /// <param name="_journalLine">
    /// The journal line to be checked.
    /// </param>
    /// <param name="_parmLine">
    /// The parameter line to check against.
    /// </param>
    public void checkJournalLine(Common _journalLine, Common _parmLine)
    {
        CustPackingSlipTrans custPackingSlipTrans = _journalLine as CustPackingSlipTrans;
        Qty salesQuantityMatched, inventQuantityMatched;

        [salesQuantityMatched, inventQuantityMatched] = CustInvoicePackingSlipQuantityMatch::salesInventoryQuantityMatched(custPackingSlipTrans.SourceDocumentLine);

        if (salesQuantityMatched)
        {
            if (abs(custPackingSlipTrans.Qty) < abs(salesQuantityMatched)
                || abs(custPackingSlipTrans.InventQty) < abs(inventQuantityMatched))
            {
                // You cannot correct the packing slip below quantity matched by invoice.
                throw error("@SYS324493");
            }
            if (abs(custPackingSlipTrans.Qty) == abs(salesQuantityMatched))
            {
                custPackingSlipTrans.FullyMatched = NoYes::Yes;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoThrow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a journal should be created.
    /// </summary>
    /// <returns>
    /// true if a journal should be created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If a journal is not created, no exception is thrown.A journal is not created if it contains no
    /// lines.
    /// </remarks>
    protected boolean checkNoThrow()
    {
        boolean ret = super();

        if (!this.proforma())
        {
            // Call Center Orders are authorized when completed. All other orders have authorization done when
            // Generating the packing Slip. Here we verify if Call center Orders have all valid payments while other order types
            // tries to authorize the CC payments.
            if (ret
                && this.isAuthorizationRequired())
            {
                if (salesTable.mcrIsCallCenter())
                {
                    ret = salesTable.mcrHasAllValidPayments();
                }
                else
                {
                    ret = salesTable.creditCardDoPreAuthorize(false);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAuthorizationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an authorization is needed to create a journal entry for the packing slip process.
    /// </summary>
    /// <returns>True if an authorization is needed. Otherwise, false.</returns>
    /// <remarks>An authorization is not required when canceling or correcting a packing slip.</remarks>
    protected boolean isAuthorizationRequired()
    {
        return !(this.parmFormLetterJournalCreateVersioning() is FormLetterJournalCreateCorrection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalChain</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a journal chain for chained documents.
    /// </summary>
    public void createJournalChain()
    {
        if (this.parmRelatedJournal().RecId)
        {
            TradePackingSlipJourChain::createRelationship(custPackingSlipJour, this.parmRelatedJournal() as VendPackingSlipJour);
        }
        this.createJournalLineChain();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLine</Name>
				<Source><![CDATA[
    protected void createJournalLine(Common _salesParmLine)
    {
        SalesParmLine salesParmLine = _salesParmLine as SalesParmLine;
        InventQualityManagementBlockHandler::blockSalesPackingSlip(salesParmLine.salesLine());
        super(_salesParmLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLineChain</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates records in the <c>TradePackingSlipTransChain</c> table for each relation between the posted
    ///    sales order packing slip lines and each corresponding purchase order packing line.
    /// </summary>
    protected void createJournalLineChain()
    {
        TradePackingSlipTransChain  packingSlipTransChain;
        VendPackingSlipTrans        vendPackingSlipTrans;
        CustPackingSlipTrans        localCustPackingSlipTrans;

        if (this.parmRelatedJournal().RecId)
        {
            VendPackingSlipJour localVendPackingSlipJour = this.parmRelatedJournal() as VendPackingSlipJour;

            insert_recordset packingSlipTransChain (custPackingSlipTrans, vendPackingSlipTrans)
                select RecId from localCustPackingSlipTrans
                    where   localCustPackingSlipTrans.PackingSlipId   == custPackingSlipJour.PackingSlipId
                        &&  localCustPackingSlipTrans.SalesId         == custPackingSlipJour.SalesId
                        &&  localCustPackingSlipTrans.DeliveryDate    == custPackingSlipJour.DeliveryDate
                join RecId from vendPackingSlipTrans
                    where   vendPackingSlipTrans.VendPackingSlipJour  == localVendPackingSlipJour.RecId
                        &&  vendPackingSlipTrans.InventTransId          == localCustPackingSlipTrans.InventRefTransId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLinesHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates journal line history records for all lines.
    /// </summary>
    public void createJournalLinesHistory()
    {
        CustPackingSlipTransHistory custPackingSlipTransHistory;
        CustPackingSlipTransHistory previousCustPackingSlipTransHistory;
        CustPackingSlipTrans        custPackingSlipTrans;
        SalesShippingStat           salesShippingStat;
        SalesShippingStatHistory    salesShippingStatHistory;
        VersioningTimeStamp         validFrom, validTo;

        validFrom = CustPackingSlipVersion::findLatest(custPackingSlipJour.RecId).VersionDateTime;
        validTo = DateTimeUtil::maxValue();

        if (numberOfVersions > 1)
        {
            insert_recordset custPackingSlipTransHistory(CustPackingSlipTrans,  ValidFrom, ValidTo, Qty,
                InventQty, Remain, RemainInvent, Weight, ValueMST, StatValueMST, PdsCWQty, PdsCWRemain)
            select RecId, validFrom, validTo, Qty,
                InventQty, Remain, RemainInvent, Weight, ValueMST, StatValueMST, PdsCWQty, PdsCWRemain
                from custPackingSlipTrans
                where custPackingSlipTrans.SalesId          == custPackingSlipJour.SalesId
                   && custPackingSlipTrans.PackingSlipId    == custPackingSlipJour.PackingSlipId
                   && custPackingSlipTrans.DeliveryDate     == custPackingSlipJour.DeliveryDate
            notexists join previousCustPackingSlipTransHistory
                where previousCustPackingSlipTransHistory.CustPackingSlipTrans == custPackingSlipTrans.RecId
                   && previousCustPackingSlipTransHistory.Qty == custPackingSlipTrans.Qty;

            insert_recordset salesShippingStatHistory(SalesShippingStat,  ValidFrom, ValidTo, Volume, NetWeight, GrossWeight, FreightZone, CartonsQty, UnitWeight, Quantity, Nolabels)
                select RecId, validFrom, validTo, Volume, NetWeight, GrossWeight, FreightZone, CartonsQty, UnitWeight, Quantity, Nolabels from salesShippingStat
                    where salesShippingStat.PackingSlipId == custPackingSlipJour.PackingSlipId
                       && salesShippingStat.DeliveryDate  == custPackingSlipJour.DeliveryDate
                       && salesShippingStat.SalesId       == custPackingSlipJour.SalesId;
        }
        else
        {
            insert_recordset custPackingSlipTransHistory(CustPackingSlipTrans,  ValidFrom, ValidTo, Qty,
                InventQty, Remain, RemainInvent, Weight, ValueMST, StatValueMST, PdsCWQty, PdsCWRemain)
            select RecId, validFrom, validTo, Qty,
                InventQty, Remain, RemainInvent, Weight, ValueMST, StatValueMST, PdsCWQty, PdsCWRemain
                from custPackingSlipTrans
                where custPackingSlipTrans.SalesId          == custPackingSlipJour.SalesId
                   && custPackingSlipTrans.PackingSlipId    == custPackingSlipJour.PackingSlipId
                   && custPackingSlipTrans.DeliveryDate     == custPackingSlipJour.DeliveryDate;

            insert_recordset salesShippingStatHistory(SalesShippingStat,  ValidFrom, ValidTo, Volume, NetWeight, GrossWeight, FreightZone, CartonsQty, UnitWeight, Quantity, Nolabels)
                select RecId, validFrom, validTo, Volume, NetWeight, GrossWeight, FreightZone, CartonsQty, UnitWeight, Quantity, Nolabels from salesShippingStat
                    where salesShippingStat.ParmId      == salesParmTable.ParmId
                       && salesShippingStat.TableRefId  == salesParmTable.TableRefId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new journal version.
    /// </summary>
    protected void createJournalVersion()
    {
        FormLetterContract salesFormLetterContract = this.parmInterCompanyFormletterContract();

        custPackingSlipVersion.clear();
        custPackingSlipVersion.initFromCustPackingSlipJour(custPackingSlipJour);

        custPackingSlipVersion.ParmId = salesParmUpdate.ParmId;
        custPackingSlipVersion.VersionDateTime  = (salesFormLetterContract && salesFormLetterContract.parmVersionDateTime()) ?
                                                  salesFormLetterContract.parmVersionDateTime() : DateTimeUtil::utcNow();
        salesFormLetterContract.parmVersionDateTime(custPackingSlipVersion.VersionDateTime);
        custPackingSlipVersion.AccountingDate   = this.updateDate();

        if (numberOfVersions)
        {
            custPackingSlipVersion.LedgerVoucher = this.allocateCorrectionVoucher().voucher();
        }
        else
        {
            custPackingSlipVersion.LedgerVoucher = custPackingSlipJour.LedgerVoucher;
        }
        custPackingSlipVersion.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransportationDocuRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the additional information for the transportation document.
    /// </summary>
    private void createTransportationDocuRef()
    {
        #TransportationDocument

        this.setDocuRef(#AdditionalDeclarations, tableNum(CustPackingSlipJour), custPackingSlipJour.RecId, salesParmUpdate.AdditionalDeclarations);
        this.setDocuRef(#AdditionalInstructions, tableNum(CustPackingSlipJour), custPackingSlipJour.RecId, salesParmUpdate.AdditionalInstructions);
        this.setDocuRef(#AdditionalNotes, tableNum(CustPackingSlipJour), custPackingSlipJour.RecId, salesParmUpdate.AdditionalNotes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes when creating the journal ends.
    /// </summary>
    protected void endCreate()
    {
        formLetterJournalCreateVersioning.createJournalChain();
        super();

        this.createJournalLineChain();

        this.mcrCopyNotes();

        // Create additional notes for italian transportation document
        if (this.useTransportationDocument())
        {
            this.createTransportationDocuRef();
        }

        if (isCountryRegion_PL)
        {
            this.postEndCreatePackage();
        }

        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.transitDocument();
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TaxBusinessService::transferTaxDocument(salesParmTable, custPackingSlipJour);
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an existing journal line based on a parameter line.
    /// </summary>
    /// <param name="_parmLine">
    /// The parameter line to use to find the journal line.
    /// </param>
    /// <returns>
    /// The journal line.
    /// </returns>
    public Common findJournalLine(Common _parmLine)
    {
        CustPackingSlipTrans custPackingSlipTrans;
        SalesParmLine salesParmLine = _parmLine as SalesParmLine;

        // Note: The "order by" clause has its effect only in warehouse packing slip scenarios, where there can be more than one
        // CustPackingSlipTrans records with the same InventTransId and each time the query is executed the ParmLine is updated
        // with the latest SalesParmLine.RecId value. Having the order by clause will ensure that the custPackintSlipTrans is picked with the lowest ParmLine value.
        select firstonly forupdate custPackingSlipTrans
            order by ParmLine asc
            where custPackingSlipTrans.SalesId          == custPackingSlipJour.SalesId
               && custPackingSlipTrans.PackingSlipId    == custPackingSlipJour.PackingSlipId
               && custPackingSlipTrans.DeliveryDate     == custPackingSlipJour.DeliveryDate
               && custPackingSlipTrans.InventTransId    == salesParmLine.InventTransId;

        return custPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the form letter type.
    /// </summary>
    /// <returns>
    /// A <c>FormletterType</c> enumeration value.
    /// </returns>
    protected FormletterType formletterType()
    {
        return FormletterType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCatchWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight picked for the specified line.
    /// </summary>
    /// <param name="_localSalesParmLine">
    /// The line being processed.
    /// </param>
    /// <param name="_inventMovement">
    /// The inventory movement related to the line.
    /// </param>
    /// <param name="_custPackingSlipTrans">
    /// The packing slip line being generated.
    /// </param>
    /// <returns>
    /// The weight for the catch weight quantity.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// Insufficient inventory transactions with the picked status.
    /// </exception>
    protected InventQty getCatchWeight(
        SalesParmLine               _localSalesParmLine,
        InventMov_Sales             _inventMovement,
        CustPackingSlipTrans        _custPackingSlipTrans)
    {
        PdsCWInventQty                      cwQtyNotAssigned = _localSalesParmLine.PdsCWDeliverNow;

        PdsCatchWeightMovementQtyAdjustment pdsCatchWeightMovementQtyAdjustment = PdsCatchWeightMovementQtyAdjustment::newSalesPackingSlip(
            _inventMovement,
            _custPackingSlipTrans);

        InventQty qtyAssigned = pdsCatchWeightMovementQtyAdjustment.salesIssueQty(
            DocumentStatus::PackingSlip,
            cwQtyNotAssigned,
            _inventMovement.inventTableInvent().UnitId);

        if (!pdsCatchWeightMovementQtyAdjustment.isFullCatchWeightQuantityAssigned())
        {
            warning("@SCM:ItemFullCatchWeightQuantityNotAssigned");
            Info("@SCM:InventOrderPickingGeneralGuide");
            throw error(strFmt("@SYS54028",StatusIssue::Picked));
        }
        return qtyAssigned;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current journal header.
    /// </summary>
    /// <returns>
    /// A journal header record.
    /// </returns>
    public Common getJournal()
    {
        return custPackingSlipJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a journal and a voucher number.
    /// </summary>
    /// <returns>
    ///   A <c>Container</c> with a journal and voucher number.
    /// </returns>
    protected container getNumAndVoucher()
    {
        super();

        // If CustParameters.InvoiceEditing_W is enabled and SalesParmTable.Num_W has a value,
        // then the packing slip number will be replaced by the Num_W entered by the user.
        if (salesParmTable.Num_W )
        {
            journalNumber = salesParmTable.Num_W;
        }
        else if (salesParmTable.PreallocatedPackingSlipId)
        {
            journalNumber = salesParmTable.PreallocatedPackingSlipId;
        }

        return [journalNumber, voucher];
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class.
    /// </summary>
    protected void init()
    {
        accountingDate = salesParmTable.Transdate;
        super();
        salesParameters             = SalesParameters::find();
        isExtensionIntrastatEnabled = SysExtensionSerializerExtensionMap::isExtensionEnabled(tableNum(CustPackingSlipTrans_Intrastat));
        isCountryRegion_PL   = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);
        isCountryRegion_LTLV = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV]);
        isLegalEntityInEEU   = IntrastatParameters::isLegalEntityInEEU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCatchWeightValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts inventory quantities for catch weight items which have been reserved or picked.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// Insufficient inventory transactions with the picked status.
    /// </exception>
    protected void initCatchWeightValues()
    {
        SalesParmLine               localSalesParmLine;
        InventTransOrigin           inventTransOrigin;
        InventTableModule           inventTableModuleInvent;
        SalesQty                    salesQtyDelta;

        if (!#pdsCatchWeightEnabled)
        { // catch weight not enabled, so no need to try to select
            return;
        }

        while select forupdate localSalesParmLine
            where localSalesParmLine.ParmId     == salesParmTable.ParmId
               && localSalesParmLine.TableRefId == salesParmTable.TableRefId
               && localSalesParmLine.PdsCWDeliverNow             > 0        // only select lines with catch weight being issued
            join RecId from inventTransOrigin
                where inventTransOrigin.InventTransId           == localSalesParmLine.InventTransId
            join UnitId from inventTableModuleInvent
                where inventTableModuleInvent.ItemId            == localSalesParmLine.ItemId
                  &&  inventTableModuleInvent.ModuleType        == ModuleInventPurchSales::Invent
        {
            if (!this.checkDiscardLine(localSalesParmLine))
            {
                setPrefix(localSalesParmLine.FormletterJournalTrans::getLinePrefix());

                SalesLine localSalesLine = localSalesParmLine.salesLine(true);
                InventMov_Sales inventMovement = InventMov_Sales::newFromSalesLine(localSalesLine);
                CustPackingSlipTrans custPackingSlipTrans = this.initJournalLine(localSalesParmLine);

                // Transactions must be picked to get the correct weight
                PdsCatchWeightAutoPickingHelper::newSalesPackingSlip(
                    localSalesParmLine,
                    inventMovement,
                    custPackingSlipTrans).pick();
                salesTable = localSalesParmLine.salesTable(true); // Might be updated by reservation and/or picking code.

                // Find the catch weight from the transactions
                InventQty qtyAssigned = this.getCatchWeight(localSalesParmLine, inventMovement, custPackingSlipTrans);

                // Remain quantities may have been updated on the sales line by picking (less than nominal qty) in a direct delivery scenario - if so, need to update SalesParmLine accordingly
                if (localSalesLine.isDirectDelivery())
                {
                    localSalesLine = localSalesParmLine.salesLine(true);
                    if ( localSalesParmLine.RemainBefore        != localSalesLine.RemainSalesPhysical
                      || localSalesParmLine.RemainBeforeInvent  != localSalesLine.RemainInventPhysical)
                    {
                        SalesQty  diffRemain        = localSalesParmLine.RemainBefore       - localSalesLine.RemainSalesPhysical;
                        InventQty diffRemainInvent  = localSalesParmLine.RemainBeforeInvent - localSalesLine.RemainInventPhysical;

                        localSalesParmLine.RemainBefore         = localSalesLine.RemainSalesPhysical;
                        localSalesParmLine.RemainBeforeInvent   = localSalesLine.RemainInventPhysical;
                        localSalesParmLine.RemainAfter          -= diffRemain;
                        localSalesParmLine.RemainAfterInvent    -= diffRemainInvent;
                        localSalesParmLine.update();
                    }
                }

                // SalesParmLine was initialized from the SalesLine for a default CW quantity based on SalesUpdate setting.
                // If CW quantity to pack was changed in the posting form, then InventQty to post also needs to be updated on SalesParmLine
                // qtyAssigned holds the InventQty corresponding to the updated CW qty; If picked quantity is different from nominal, an average InventQty is calculated and assigned
                if (qtyAssigned > 0
                 && localSalesParmLine.InventNow != qtyAssigned)
                { // Update salesParmLine with new values for weight
                    InventQty inventQtyDelta = qtyAssigned - localSalesParmLine.InventNow;
                    localSalesLine = localSalesParmLine.salesLine();
                    if (localSalesLine.SalesUnit == inventTableModuleInvent.UnitId)
                    { // Same unit so update sales qty related field too
                        salesQtyDelta = inventQtyDelta;
                        localSalesParmLine.DeliverNow += salesQtyDelta;
                        localSalesParmLine.RemainBefore = localSalesLine.RemainSalesPhysical;
                        localSalesParmLine.RemainAfter -= salesQtyDelta;
                    }
                    else if (UnitOfMeasure::findBySymbol(localSalesLine.SalesUnit).UnitOfMeasureClass
                          == UnitOfMeasure::findBySymbol(inventTableModuleInvent.UnitId).UnitOfMeasureClass)
                    { // Same unit class so update sales qty related field too, but convert to proper unit
                        salesQtyDelta = UnitOfMeasureConverter::convert(
                            qtyAssigned,
                            UnitOfMeasure::unitOfMeasureIdBySymbol(inventTableModuleInvent.UnitId),
                            UnitOfMeasure::unitOfMeasureIdBySymbol(localSalesLine.SalesUnit),
                            NoYes::No,
                            localSalesLine.inventTable().Product)
                            - localSalesParmLine.DeliverNow;

                        localSalesParmLine.DeliverNow += salesQtyDelta;
                        localSalesParmLine.RemainBefore = localSalesLine.RemainSalesPhysical;
                        localSalesParmLine.RemainAfter -= salesQtyDelta;
                    }
                    localSalesParmLine.InventNow += inventQtyDelta;
                    localSalesParmLine.RemainBeforeInvent = localSalesLine.RemainInventPhysical;
                    localSalesParmLine.RemainAfterInvent -= inventQtyDelta;
                    localSalesParmLine.update();
                    recordListSalesParmLine = null;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes non-correctable fields on the journal header.
    /// </summary>
    public void initHeader()
    {
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>
        custPackingSlipJour.clear();
        custPackingSlipJour.initValue();

        // <GEEU>
        if (isCountryRegion_LTLV)
        {
            vendPackingSlipJour                  = this.parmRelatedJournal() as VendPackingSlipJour;
            if (vendPackingSlipJour)
            {
                custPackingSlipJour.PackingSlipId   = vendPackingSlipJour.PackingSlipId;
            }
            else
            {
                custPackingSlipJour.PackingSlipId   = this.getJournalNumber();
            }
        }
        else
        {
        // </GEEU>
        custPackingSlipJour.PackingSlipId        = this.getJournalNumber();
        // <GEEU>
        }
        // </GEEU>
        custPackingSlipJour.LedgerVoucher        = this.getVoucher();
        custPackingSlipJour.ReturnPackingSlipId  = salesParmTable.ReturnPackingSlipId;
        custPackingSlipJour.DeliveryDate         = salesParmTable.Transdate;
        custPackingSlipJour.DocumentDate         = salesParmTable.DocumentDate;
        custPackingSlipJour.BankLCExportLine     = salesParmTable.BankLCExportLine;
        custPackingSlipJour.InterCompanyPosted   = this.parmInterCompanyPosted();
        custPackingSlipJour.initFromSalesTable(salesTable);

        this.setDeliveryFields();
        if (this.useTransportationDocumentPopulateFields())
        {
            custPackingSlipJour.Compiler                            = salesParmUpdate.Compiler;
            custPackingSlipJour.TransportationDeliveryLoader        = salesParmUpdate.TransportationDeliveryLoader;
            custPackingSlipJour.TransportationDeliveryContractor    = salesParmUpdate.TransportationDeliveryContractor;
            custPackingSlipJour.TransportationDeliveryOwner         = salesParmUpdate.TransportationDeliveryOwner;
        }

        // <GEEU>
        if (isCountryRegion_LTLV)
        {
            if (salesParmTable.DocAutoNumbering_LT)
            {
                if (!LtInvoiceAutoNumberingTable::checkLastDate(ltDocNumberingCode, this.updateDate(), true))
                {
                    throw error("@SYS18447");
                }

                custPackingSlipJour.PackingSlipNumberingCode_LT = ltDocNumberingCode;
                LtInvoiceAutoNumberingTable::updateLastDate(ltDocNumberingCode, this.updateDate());
            }

            custPackingSlipJour.PrintBlankDate_LT    = salesParmTable.PrintBlankDate_LT;

            if (! this.checkDuplicateNum_W(custPackingSlipJour.PackingSlipId,
                                        custPackingSlipJour.SalesId,
                                        custPackingSlipJour.DeliveryDate))
            {
                throw error("@SYS18447");
            }
        }
        // </GEEU>

        custPackingSlipJour.InvoiceIssueDueDate_W = LedgerInvoiceIssueDueDateSetup_W::findPostalAddressIssueDate(custPackingSlipJour.postalAddress(),
                                                                                                            custPackingSlipJour.DeliveryDate).getInvoiceIssueDueDate(custPackingSlipJour.DeliveryDate);
        if (this.useTransportationDocument())
        {
            TransportationDocument::copy(salesParmTable, custPackingSlipJour);
        }

        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales)
            // Project item requirement skips tax calculation during the posting packing slip process. Thus, no need to save tax id to journal.
            && salesTable.SalesType != SalesType::ItemReq)
        {
            TaxTransactionTaxIDHelper::saveTaxIdToCustVendJour(this.parmTax(), custPackingslipJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTransportationDocumentPopulateFields</Name>
				<Source><![CDATA[
    private boolean useTransportationDocumentPopulateFields()
    {
        if (TaxSalesPackingSlipUseProformaTransportationFlight::instance().isEnabled())
        {
            return salesParameters.TransportationDocumentOnPackingSlip
                && IntrastatCountryRegionParameters::isInEUByIsoCode();
        }
        else
        {
            return this.useTransportationDocument();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalHeader</Name>
				<Source><![CDATA[
    protected void initJournalHeader()
    {
        //Don't want to initialize a new cusPackingSlipJour if one already exists.
        if (!custPackingSlipJour
            && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            custPackingSlipJour.clear();
            custPackingSlipJour.initValue();

            custPackingSlipJour.PackingSlipId        = this.getJournalNumber();
            custPackingSlipJour.LedgerVoucher        = this.getVoucher();
            custPackingSlipJour.ParmId               = salesParmUpdate.ParmId;
            custPackingSlipJour.ReturnPackingSlipId  = salesParmTable.ReturnPackingSlipId;
            custPackingSlipJour.DeliveryDate         = salesParmTable.Transdate;
            custPackingSlipJour.DocumentDate         = salesParmTable.DocumentDate;
            custPackingSlipJour.InterCompanyPosted   = this.parmInterCompanyPosted();
            custPackingSlipJour.initFromSalesTable(salesTable);

            custPackingSlipJour.DeliveryName            = salesParmTable.DeliveryName;
            custPackingSlipJour.DeliveryPostalAddress   = salesParmTable.DeliveryPostalAddress;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalLine</Name>
				<Source><![CDATA[
    public Common initJournalLine(Common _parmLine)
    {
        CustPackingSlipTrans custPackingSlipTrans;
        SalesParmLine  salesParmLine = _parmLine as SalesParmLine;
        SalesLine salesLine = salesParmLine.salesLine();
        SalesTable localSalesTable = salesLine.salesTable();
        Label   label = new Label(custPackingSlipJour.LanguageId);

        // <GIN>
        // </GIN>

        custPackingSlipTrans.clear();
        custPackingSlipTrans.initValue();

        custPackingSlipTrans.initFromSalesLine(salesLine, isExtensionIntrastatEnabled);
        custPackingSlipTrans.initFromCustPckSlpJour(custPackingSlipJour);

        custPackingSlipTrans.Scrap = salesParmLine.Scrap;

        custPackingSlipTrans.LineHeader = label.extractString(literalStr("@SYS9694"))  + ' ' + salesLine.SalesId       + ' '
                                        + label.extractString(literalStr("@SYS24704")) + ' ' + localSalesTable.CustAccount  + ' '
                                        + (localSalesTable.PurchOrderFormNum ? (label.extractString(literalStr("@SYS9452"))  + ' ' + localSalesTable.PurchOrderFormNum + ' ') : '')
                                        + custPackingSlipTrans.LineHeader;

         //If the salesline is from a dropshipment the vendors country or region must be stored to determine Intrastat reporting
        if (salesLine.isDropShipment())
        {
            //if the salesLine is not linked to a different purchase the Vendor country or region need not be found again
            if ( (vendInvoiceJour && vendInvoiceJour.PurchId         == salesLine.InventRefId)
               ||(vendPackingSlipJour && vendPackingSlipJour.PurchId == salesLine.InventRefId))
            {
                // <GEEU>
                if (isCountryRegion_LTLV && vendPackingSlipJour && !vendCountryRegionId)
                {
                    LogisticsPostalAddress postalAddress = VendTable::find(vendPackingSlipJour.OrderAccount).postalAddress();
                    vendCountryRegionId = postalAddress.CountryRegionId;
                    vendStateId = postalAddress.State;
                }
                // </GEEU>
                custPackingSlipTrans.CountryRegionOfShipment = vendCountryRegionId;
                custPackingSlipTrans.StateOfShipment = vendStateId;
            }
            else //Either a vendInvoiceJour or VendPackingSlipJour will exist for a dropshipment salesline being invoiced
            {
                vendInvoiceJour = VendInvoiceJour::findFromPurchId(salesLine.InventRefId);

                if (vendInvoiceJour)
                {
                    LogisticsPostalAddress postalAddress = VendTable::find(vendInvoiceJour.OrderAccount).postalAddress();
                    vendCountryRegionId = postalAddress.CountryRegionId;
                    vendStateId = postalAddress.State;
                    custPackingSlipTrans.CountryRegionOfShipment = vendCountryRegionId;
                    custPackingSlipTrans.StateOfShipment = vendStateId;
                }
                else
                {
                    vendPackingSlipJour = VendPackingSlipJour::findFromPurchId(salesLine.InventRefId);

                    if (vendPackingSlipJour)
                    {
                        LogisticsPostalAddress postalAddress = VendTable::find(vendPackingSlipJour.OrderAccount).postalAddress();
                        vendCountryRegionId = postalAddress.CountryRegionId;
                        vendStateId = postalAddress.State;
                        custPackingSlipTrans.CountryRegionOfShipment = vendCountryRegionId;
                        custPackingSlipTrans.StateOfShipment = vendStateId;
                    }
                }
            }
        }

        if (SalesPackingSlipDisableCreationOfSDFRecordsFlight::instance().isEnabled() || FeatureStateProvider::isFeatureEnabled(SalesPackingSlipDisableCreationOfSDFRecordsFeature::instance()))
        {
            custPackingSlipTrans.SourceDocumentLine = this.createDummySourceDocumentLineRecId();
        }
        else
        {
            SourceDocumentLine sourceDocumentLine;
            this.initializeSourceDocumentLine(custPackingSlipJour.SourceDocumentHeader, sourceDocumentLine);
            custPackingSlipTrans.SourceDocumentLine = SourceDocumentLine::createSourceDocumentLine(tableNum(CustPackingSlipTrans), sourceDocumentLine);
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && salesParmLine.salesParmLine_IN().InventSiteGateEntryLine)
        {
            CustPackingSlipTrans_IN custPackingSlipTransIN = custPackingSlipTrans.custPackingSlipTrans_IN();
            custPackingSlipTransIN.InventSiteGateEntryLine = salesParmLine.salesParmLine_IN().InventSiteGateEntryLine;
            custPackingSlipTrans.packCustPackingSlipTrans_IN(custPackingSlipTransIN);
        }
        // </GIN>

        return custPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new link between the journal and the order.
    /// </summary>
    /// <param name="_salesParmLine">
    /// A parameter line that indicates the journal line and the order line.
    /// </param>
    /// <returns>
    /// The journal link record.
    /// </returns>
    public Common initJournalLink(Common _salesParmLine)
    {
        SalesParmLine salesParmLine = _salesParmLine as SalesParmLine;
        CustPackingSlipSalesLink    custPackingSlipSalesLink;

        custPackingSlipSalesLink.clear();
        custPackingSlipSalesLink.initFromSalesParmLine          (salesParmLine);
        custPackingSlipSalesLink.initFromSalesTable             (SalesTable::find(salesParmLine.OrigSalesId));
        custPackingSlipSalesLink.initFromCustPackingSlipJour    (custPackingSlipJour);

        return custPackingSlipSalesLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the source table record.
    /// </summary>
    protected void initSourceTable()
    {
        salesTable = salesParmTable.salesTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the total calculation.
    /// </summary>
    protected void initTotals()
    {
        this.initCatchWeightValues();
        salesTotals = SalesTotals::construct(salesParmTable, salesParmUpdate.SpecQty, salesParmUpdate.SumBy, salesParmUpdate.ParmId, salesParmUpdate.SumSalesId, documentStatus);
        salesTotals.prepareTotalAmountCalculation();
        salesTotals.prepareQuantitiesCalculation();
        this.parmTax(salesTotals.tax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table ID for the journal line table.
    /// </summary>
    /// <returns>
    /// The table ID for the journal line table.
    /// </returns>
    protected TableId journalLineTableId()
    {
        return tableNum(CustPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>linksTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table ID for the journal link table.
    /// </summary>
    /// <returns>
    /// The table ID for the journal link table.
    /// </returns>
    protected TableId linksTableId()
    {
        return tableNum(CustPackingSlipSalesLink);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCopyNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies notes from <c>SalesLine</c> to packing slip line.
    /// </summary>
    private void mcrCopyNotes()
    {
        custPackingSlipTrans    custPackingSlipTransLocal;
        salesLine               salesLineLocal;
        DocuRef                 docuRef;

        while select custPackingSlipTransLocal
            where custPackingSlipTransLocal.SalesId == custPackingSlipJour.SalesId
                && custPackingSlipTransLocal.PackingSlipId == custPackingSlipJour.PackingSlipId
                && custPackingSlipTransLocal.DeliveryDate == custPackingSlipJour.DeliveryDate
                    join salesLineLocal
                    where salesLineLocal.InventTransId == custPackingSlipTransLocal.InventTransId
                        && salesLineLocal.LineDeliveryType == LineDeliveryType::DeliveryLine
                exists join docuRef
                    where docuRef.RefCompanyId == salesLineLocal.DataAreaId
                        && docuRef.RefTableId  == tableNum(SalesLine)
                        && docuRef.RefRecId    == salesLineLocal.RecId
        {
            Docu::copy(
                SalesDeliverySchedule::findOrderLineForDeliveryLine(salesLineLocal.InventTransId),
                custPackingSlipTransLocal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>noLinesForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs actions when there are no lines selected for posting.
    /// </summary>
    /// <param name="_throwError">
    /// A Boolean value that indicates whether an error message should be thrown as an exception.
    /// </param>
    /// <remarks>
    /// Informs the user that there are no lines selected for posting.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// Posting has been canceled.
    /// </exception>
    protected void noLinesForPosting(boolean _throwError = false)
    {
        if (this.linesExists())
        {
            if (SalesPackingSlipJourCreateAbortPurchProductReceiptFlight::instance().isEnabled()
                && !_throwError && salesTable.existDirectDelivery() && this.parmRelatedJournal())
            {
                _throwError = true;
            }
            // Credit card failed w/error message already, just announce posting failure
            this.showPostingCanceledError(_throwError);
        }
        else
        {
            super(_throwError);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceReferenceNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>NumberSequenceReference</c> object for the journal number.
    /// </summary>
    /// <returns>
    /// A <c>NumberSequenceReference</c> object.
    /// </returns>
    protected NumberSequenceReference numberSequenceReferenceNum()
    {
        return SalesParameters::numRefPackingSlipId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceReferenceVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>NumberSequenceReference</c> object for the voucher number.
    /// </summary>
    /// <returns>
    /// A <c>NumberSequenceReference</c> object.
    /// </returns>
    protected NumberSequenceReference numberSequenceReferenceVoucher()
    {
        return SalesParameters::numRefSalesPackingSlipVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipNumber_W</Name>
				<Source><![CDATA[
    private NumberSequenceCode packingSlipNumber_W()
    {
        NumberSequenceCode newNumber;

        if (salesParmTable.DocAutoNumbering_LT == NoYes::Yes)
        {
            newNumber = LtInvoiceAutoNumberingTable::find(ltDocNumberingCode).NumberSequenceCode;
        }

        if (salesParameters.PackingSlipByInvent_PL)
        {
            NumberSequenceGroupId numberSeqGroupId = this.numberSequenceGroupId();
            if (numberSeqGroupId)
            {
                newNumber = PlNumberSequenceGroupInvent::packingSlip(
                    this.parmInventLocationId_PL(),
                    NumberSequenceDatatype::find(SalesParameters::numRefPackingSlipId().NumberSequenceDatatype).DatatypeId,
                    numberSeqGroupId);
            }
            if (! newNumber)
            {
                newNumber = PlNumberSequenceGroupInvent::packingSlip(
                    this.parmInventLocationId_PL(),
                    NumberSequenceDatatype::find(SalesParameters::numRefPackingSlipId().NumberSequenceDatatype).DatatypeId);
            }
        }

        return newNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = salesParmTable)
    {
        salesParmTable = _parmTable as SalesParmTable;
        return salesParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdate</Name>
				<Source><![CDATA[
    public Common parmParmUpdate(Common _parmUpdate = salesParmUpdate)
    {
        salesParmUpdate = _parmUpdate as SalesParmUpdate;
        return salesParmUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndCreatePackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts event handler for the <c>endCreate</c> method to calculate and create package lines for the
    /// packing slip header
    /// </summary>
    protected void postEndCreatePackage()
    {
        PlInventPackageTrans::createFromSalesTable(salesParmTable, custPackingSlipJour, this.proforma());
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether document posting to the general ledger is enabled.
    /// </summary>
    /// <returns>
    /// true if the document is posted to the general ledger; otherwise, false.
    /// </returns>
    protected boolean postingEnabled()
    {
        return salesParameters.PostPackingSlip == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateJournalLinePackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts event handler for the <c>updateJournalLine</c> method to calculate and create package lines
    /// for the invoice line
    /// </summary>
    /// <param name="_salesParmLine">
    /// Parameter line that is an origin for invoice line.
    /// </param>
    /// <param name="_custPackingSlipTrans">
    /// Packing slip line.
    /// </param>
    protected void postUpdateJournalLinePackage(
        SalesParmLine        _salesParmLine,
        CustPackingSlipTrans _custPackingSlipTrans)
    {
        PlInventPackageTrans::createFromSalesLine(_salesParmLine, _custPackingSlipTrans, this.proforma());
    }

]]></Source>
			</Method>
			<Method>
				<Name>proforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the journal is a pro forma journal.
    /// </summary>
    /// <returns>
    /// true if the journal is a pro forma journal; otherwise, false.
    /// </returns>
    protected boolean proforma()
    {
        return salesParmUpdate.Proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>RecordSortedList</c> object that has every posting parameter line record.
    /// </summary>
    /// <returns>
    /// A <c>RecordSortedList</c> object.
    /// </returns>
    protected RecordSortedList recordListParmLine()
    {
        return salesTotals.recordSortedListLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeliveryFields</Name>
				<Source><![CDATA[
    protected void setDeliveryFields()
    {
        SalesParmLine       salesParmLine;
        ProjInvoiceTable    projInvoiceTable;
        ProjFundingSource   projFundingSource;

        select firstonly salesParmLine
            where salesParmLine.ParmId     == salesParmTable.ParmId
            &&    salesParmLine.TableRefId == salesParmTable.TableRefId;

        SalesLine localSalesLine = salesParmLine.salesLine();

        custPackingSlipJour.DeliveryPostalAddress = salesParmTable.DeliveryPostalAddress ? salesParmTable.DeliveryPostalAddress
                                                                                         : localSalesLine.DeliveryPostalAddress;

        if  (BrazilParameters::isEnabled() && localSalesLine.SalesType == SalesType::ItemReq)
        {
            custPackingSlipJour.DeliveryPostalAddress = localSalesLine.DeliveryPostalAddress;
        }
        custPackingSlipJour.DeliveryName      = salesParmTable.DeliveryName    ? salesParmTable.DeliveryName
                                                                               : localSalesLine.defaultDeliveryName();
        custPackingSlipJour.DlvMode           = salesParmTable.DlvMode         ? salesParmTable.DlvMode
                                                                               : (localSalesLine.DlvMode ? localSalesLine.DlvMode : localSalesLine.salesTable().DlvMode);
        custPackingSlipJour.DlvTerm           = salesParmTable.DlvTerm         ? salesParmTable.DlvTerm
                                                                               : (localSalesLine.DlvTerm ? localSalesLine.DlvTerm : localSalesLine.salesTable().DlvTerm);

        custPackingSlipJour.PrintMgmtSiteId    = salesParmTable.InventSiteId    ? salesParmTable.InventSiteId : '';

        custPackingSlipJour.ShipCarrierAccount = salesParmTable.ShipCarrierAccount ? salesParmTable.ShipCarrierAccount : localSalesLine.ShipCarrierAccount;
        custPackingSlipJour.ShipCarrierId = salesParmTable.ShipCarrierId ? salesParmTable.ShipCarrierId : localSalesLine.ShipCarrierId;

        // Set the invoicing Address of the Packing Slip Journal with the address on the Project Funding source that contains the project
        // associated with the project above
        ProjTable projTable = salesTable.projTable();
        if (projTable)
        {
            projInvoiceTable = projTable.projInvoice();
            if (projInvoiceTable)
            {
                select firstonly InvoiceLocation from projFundingSource
                    where projFundingSource.ContractId == projInvoiceTable.ProjInvoiceProjId &&
                          projFundingSource.FundingType == ProjFundingType::Customer;
            }
        }
        if (projInvoiceTable && (projFundingSource.InvoiceLocation || projInvoiceTable.Description))
        {
            custPackingSlipJour.InvoicingName          = projInvoiceTable.Description;
            custPackingSlipJour.InvoicePostalAddress = LogisticsLocationEntity::location2PostalAddress(projFundingSource.InvoiceLocation, custPackingSlipJour.deliveryDateTime()).RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocuRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the document reference record.
    /// </summary>
    /// <param name="_docuTypeId">
    /// The type of document.
    /// </param>
    /// <param name="_refTableId">
    /// The table ID.
    /// </param>
    /// <param name="_refRecId">
    /// The record ID.
    /// </param>
    /// <param name="_notes">
    /// The content of the document.
    /// </param>
    protected void setDocuRef(DocuTypeId _docuTypeId,
                            RefTableId _refTableId,
                            RefRecId _refRecId,
                            Notes _notes)
    {
        DocuRef docuRef;

        ttsbegin;
        docuRef.clear();
        docuRef.RefTableId   = _refTableId;
        docuRef.RefRecId     = _refRecId;
        docuRef.TypeId       = _docuTypeId;
        docuRef.RefCompanyId = curext();
        docuRef.Notes        = _notes;
        docuRef.insert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the journal to an existing record.
    /// </summary>
    /// <param name="_journal">
    /// An existing journal record.
    /// </param>
    public void setJournal(Common _journal)
    {
        custPackingSlipJour = CustPackingSlipJour::findRecId(_journal.RecId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source table for the journal.
    /// </summary>
    /// <returns>
    /// A record.
    /// </returns>
    protected Common sourceTable()
    {
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total object.
    /// </summary>
    /// <returns>
    /// A total object.
    /// </returns>
    protected Object totals()
    {
        return salesTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>typeParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the type of the posting parameter line table.
    /// </summary>
    /// <returns>
    /// A record.
    /// </returns>
    protected Common typeParmLine()
    {
        SalesParmLine   salesParmLine;
        return salesParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    protected TransDate  updateDate()
    {
        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets correctable fields on the journal header.
    /// </summary>
    protected void updateJournalHeader()
    {
        numberOfVersions = CustPackingSlipVersion::numberOfPackingSlipVersions(custPackingSlipJour.RecId);

        custPackingSlipJour.InternalPackingSlipId = strFmt('%1.%2', custPackingSlipJour.PackingSlipId, numberOfVersions+1);
        custPackingSlipJour.Qty                   = salesTotals.totalQty();
        custPackingSlipJour.Weight                = salesTotals.totalWeight();
        custPackingSlipJour.Volume                = salesTotals.totalVolume();
        custPackingSlipJour.ParmId                = salesParmUpdate.ParmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets correctable fields on journal line.
    /// </summary>
    /// <param name="_journalLine">
    /// The journal line to update.
    /// </param>
    /// <param name="_parmLine">
    /// The parameter line with which to update the journal line.
    /// </param>
    public void updateJournalLine(Common _journalLine, Common _parmLine)
    {
        CustPackingSlipTrans custPackingSlipTrans = _journalLine as CustPackingSlipTrans;
        SalesParmLine   salesParmLine = _parmLine as SalesParmLine;
        SalesLine       salesLine = _parmLine.salesLine();

        custPackingSlipTrans.ParmLine        = salesParmLine.RecId;
        custPackingSlipTrans.Qty             = salesParmLine.DeliverNow;
        custPackingSlipTrans.InventQty       = salesParmLine.InventNow;
        custPackingSlipTrans.PdsCWQty        = salesParmLine.PdsCWDeliverNow;
        custPackingSlipTrans.PdsCWRemain     = salesParmLine.PdsCWRemainAfterInvent;
        custPackingSlipTrans.Remain          = salesParmLine.RemainAfter;
        custPackingSlipTrans.RemainInvent    = salesParmLine.RemainAfterInvent;
        UnitOfMeasureSymbol salesUnit        = custPackingSlipTrans.SalesUnit;
        InventTable         inventTable      = InventTable::find(custPackingSlipTrans.ItemId);
        UnitOfMeasureSymbol inventUnit       = inventTable.inventUnitId();
        ItemNetWeight       netWeight        = inventTable.NetWeight;
        if (salesUnit == inventUnit)
        {
            custPackingSlipTrans.Weight      = netWeight * custPackingSlipTrans.Qty;
        }
        else
        {
            Qty salesQtyDelta = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct
                (custPackingSlipTrans.ItemId, custPackingSlipTrans.InventDimId, custPackingSlipTrans.Qty, salesUnit, inventUnit);
            custPackingSlipTrans.Weight      = netWeight * salesQtyDelta;
        }

        AmountCur lineAmountExcludingTax = salesParmLine.lineAmountExclTax(custPackingSlipJour.DeliveryDate);

        if (salesTable.CurrencyCode)
        {
            custPackingSlipTrans.ValueMST = CurrencyExchangeHelper::mstAmount(lineAmountExcludingTax,
                                                salesTable.CurrencyCode,
                                                custPackingSlipJour.DeliveryDate,
                                                Currency::noYes2UnknownNoYes(salesTable.euroTriangulation(custPackingSlipJour.DeliveryDate)),
                                                salesTable.exchRate(custPackingSlipJour.DeliveryDate),
                                                salesTable.exchRateSecondary(custPackingSlipJour.DeliveryDate));
        }
        else
        {
            custPackingSlipTrans.ValueMST = lineAmountExcludingTax;
        }

        // <GEEU>
        if (isLegalEntityInEEU)
        {
            custPackingSlipTrans.CurrencyCode = salesTable.CurrencyCode;
            custPackingSlipTrans.AmountCur = SalesPackingSlipAmountCurCalculationFlight::instance().isEnabled() ? lineAmountExcludingTax : custPackingSlipTrans.ValueMST;
        }
        // </GEEU>

        if (salesLine.isCategoryBased())
        {
            custPackingSlipTrans.initFromSalesLineForeignTradeCategory(SalesLineForeignTradeCategory::findSalesLine(salesLine));
        }

        // correction or cancellation of created packing slip
        if (formLetterJournalCreateVersioning is FormLetterJournalCreateCorrection
            && !WHSInventTable::exist(CustPackingSlipTrans.ItemId))
        {
            // cancellation
            if (!custPackingSlipTrans.Qty)
            {
                custPackingSlipTrans.FullyMatched = NoYes::Yes;
            }

            this.updateRemainForOverUnderDelivery(custPackingSlipTrans);
        }

        if (custPackingSlipTrans.RecId)
        {
            CustPackingSlipBackorderLine custPackingSlipBackorderLine = this.initializeBackorderLine(custPackingSlipTrans, _parmLine);

            custPackingSlipBackorderLine.write();
        }

        // <GEEPL>
        if (isCountryRegion_PL)
        {
            this.postUpdateJournalLinePackage(_parmLine, _journalLine);
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBackorderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the back order line.
    /// </summary>
    /// <param name = "_custPackingSlipTrans">The posted packing slip line for the sales line.</param>
    /// <param name = "_parmLine">The parameter line used to initialize the <c>CustPackingSlipBackorderLine</c>.</param>
    /// <returns>The initialized back order line.</returns>
    protected CustPackingSlipBackorderLine initializeBackorderLine(CustPackingSlipTrans _custPackingSlipTrans, Common _parmLine)
    {
        SalesParmLine   salesParmLine = _parmLine as SalesParmLine;
        SalesLine       salesLine = _parmLine.salesLine();

        CustPackingSlipBackorderLine    custPackingSlipBackorderLine;
        select forupdate custPackingSlipBackorderLine
                where custPackingSlipBackorderLine.PackingSlipId    == _custPackingSlipTrans.PackingSlipId
                   && custPackingSlipBackorderLine.DeliveryDate     == _custPackingSlipTrans.DeliveryDate
                   && custPackingSlipBackorderLine.SalesId          == _custPackingSlipTrans.SalesId
                   && custPackingSlipBackorderLine.InventTransId    == _custPackingSlipTrans.InventTransId;

        if (!custPackingSlipBackorderLine.RecId)
        {
            custPackingSlipBackorderLine.initFromSalesLine(salesLine);
            custPackingSlipBackorderLine.initFromCustPackingSlipJour(custPackingSlipJour);
            custPackingSlipBackorderLine.QtyBackorderSales = 0; // at the time of the first version the backorder quantity was 0.
            custPackingSlipBackorderLine.QtyBackorderInvent = 0;
            custPackingSlipBackorderLine.PdsCWQtyBackorder = 0;
        }

        custPackingSlipBackorderLine.initFromSalesParmLine(salesParmLine);

        return custPackingSlipBackorderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainForOverUnderDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// In case of over- or underdelivery ensure Remain and RemainInvent are set correctly when packing slip is corrected or canceled.
    /// </summary>
    /// <param name="_custPackingSlipTrans">
    /// The CustPackingSlipTrans
    /// </param>
    /// <remarks>
    /// If packing slip was posted with over- or underdelivery, and the packing slip is canceled, then deliver remainder
    /// should reflect the original deliver remainder, rather than the Delivered quantity from the corrected or canceled packing slip.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// You cannot generate a packing slip for a quantity that has a different sign than the quantity on the order line.
    /// </exception>
    protected void updateRemainForOverUnderDelivery(CustPackingSlipTrans _custPackingSlipTrans)
    {
        if (sign(_custPackingSlipTrans.orig().Qty) != sign(_custPackingSlipTrans.Ordered) && _custPackingSlipTrans.Ordered != 0)
        {
            throw error("@SYS331618");
        }

        CustPackingSlipTrans custPackingSlipTransSum;
        boolean              check;
        boolean              isCWItem = PdsGlobal::pdsIsCWItem(_custPackingSlipTrans.ItemId);

        select sum(Qty), sum(PdsCWQty)  from custPackingSlipTransSum
            group by InventTransId
                where custPackingSlipTransSum.InventTransId == _custPackingSlipTrans.InventTransId;

        SalesQty salesQtyReceiptSum = custPackingSlipTransSum.Qty;
        SalesQty salesQtyOrdered    = _custPackingSlipTrans.salesLine().SalesQty;
        SalesQty salesQtyCorrection = _custPackingSlipTrans.orig().Qty - _custPackingSlipTrans.Qty;

        if (isCWItem)
        {
            SalesQty salesPdsCWQtyReceiptSum = custPackingSlipTransSum.PdsCWQty;
            SalesQty salesPdsCWQtyOrdered    = _custPackingSlipTrans.salesLine().PdsCWQty;
            SalesQty salesPdsCWQtyCorrection = _custPackingSlipTrans.orig().PdsCWQty - _custPackingSlipTrans.PdsCWQty;

            check = (abs(salesPdsCWQtyReceiptSum) > abs(salesPdsCWQtyOrdered)
                    || (abs(salesPdsCWQtyReceiptSum) < abs(salesPdsCWQtyOrdered) && _custPackingSlipTrans.orig().PdsCWRemain == 0));
        }
        else
        {
            check = (abs(salesQtyReceiptSum) > abs(salesQtyOrdered)
                    || (abs(salesQtyReceiptSum) < abs(salesQtyOrdered) && _custPackingSlipTrans.orig().Remain == 0));
        }

        // Determines whether the sales line has been overdelivered or underdelivered.
        if (check)
        {
            SalesQty remain = salesQtyOrdered - (salesQtyReceiptSum - salesQtyCorrection);
            if (salesQtyOrdered > 0)
            {
                _custPackingSlipTrans.Remain = remain > 0 ? remain : 0;
            }
            else
            {
                _custPackingSlipTrans.Remain = remain < 0 ? remain : 0;
            }

            if (PdsGlobal::pdsIsCWItem(_custPackingSlipTrans.ItemId))
            {
                _custPackingSlipTrans.PdsCWRemain = _custPackingSlipTrans.PdsCWRemain -
                (_custPackingSlipTrans.orig().PdsCWQty - (_custPackingSlipTrans.Ordered / PdsCatchWeightItem::find(_custPackingSlipTrans.ItemId).nominalQty()));
            }

            if (_custPackingSlipTrans.salesLine().isStocked())
            {
                if (_custPackingSlipTrans.Remain)
                {
                    real convertedRemainingInvent = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_custPackingSlipTrans.ItemId,
                                                                                                                          _custPackingSlipTrans.InventDimId,
                                                                                                                          _custPackingSlipTrans.Remain,
                                                                                                                          _custPackingSlipTrans.SalesUnit,
                                                                                                                          InventTable::find(_custPackingSlipTrans.ItemId).inventUnitId(),
                                                                                                                          NoYes::Yes);

                    _custPackingSlipTrans.RemainInvent = decRound(convertedRemainingInvent, InventTable::inventDecimals(_custPackingSlipTrans.ItemId));
                }
                else
                {
                    _custPackingSlipTrans.RemainInvent = _custPackingSlipTrans.Remain;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTransportationDocument</Name>
				<Source><![CDATA[
    protected boolean useTransportationDocument()
    {
        return !salesParmUpdate.Proforma
                && salesParameters.TransportationDocumentOnPackingSlip
                && IntrastatCountryRegionParameters::isInEUByIsoCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    protected static SalesPackingSlipJournalCreate construct()
    {
        return new SalesPackingSlipJournalCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenFiscalDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first available sales fiscal date starting from the specified date.
    /// </summary>
    /// <param name="_startFromDate">
    /// The date to start the search from.
    /// </param>
    /// <param name="_showMessage">
    /// A Boolean value that indicates whether a message should be shown that states that the next
    /// available date will be used if the original accounting date cannot be used.
    /// </param>
    /// <returns>
    /// The available date.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// There is no open fiscal period available.
    /// </exception>
    public static AccountingDate findOpenFiscalDate(
                                                    AccountingDate      _startFromDate,
                                                    boolean             _showMessage
                                                   )
    {
        AccountingDate  accountingDate = _startFromDate;

        if (SalesParameters::find().PostPackingSlip)
        {
            RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
            if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(calendarRecId,accountingDate,SysModule::Sales,false))
            {
                accountingDate = LedgerFiscalCalendar::findFirstOpenStartDateModule(calendarRecId, accountingDate, SysModule::Sales);

                if (!accountingDate)
                {
                    throw error("@SYS329190");
                }

                if (_showMessage)
                {
                    info("@SYS329189");
                }
            }
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFormLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>SalesPackingSlipJournalCreate</c> class and initializes a
    /// versioning strategy.
    /// </summary>
    /// <param name="_formLetterContract">
    /// A <c>FormletterContract</c> object to base the initialization on.
    /// </param>
    /// <returns>
    /// A new instance of the <c>SalesPackingSlipJournalCreate</c> class.
    /// </returns>
    public static SalesPackingSlipJournalCreate newFormLetter(FormLetterContract _formLetterContract)
    {
        SalesPackingSlipJournalCreate salesPackingSlipJournalCreate = SalesPackingSlipJournalCreate::construct();

        salesPackingSlipJournalCreate.parmFormLetterJournalCreateVersioning(
            FormLetterJournalCreateVersioning::newFormLetter(_formLetterContract, salesPackingSlipJournalCreate));

        salesPackingSlipJournalCreate.initFromContract(_formLetterContract);

        return salesPackingSlipJournalCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromContract</Name>
				<Source><![CDATA[
    protected void initFromContract(FormLetterContract _formLetterContract)
    {
        SalesFormLetterContract salesFormletterContract = _formLetterContract as SalesFormLetterContract;

        if (salesFormletterContract)
        {
            this.parmWHSLoadId(salesFormletterContract.parmWHSLoadId());

            if (salesFormletterContract.parmLineIdSetPacked())
            {
                container   lineIdSetPacked = SysOperationHelper::base64Decode(salesFormletterContract.parmLineIdSetPacked());
                Set         lineIdSet       = Set::create(lineIdSetPacked);
                if (lineIdSet.elements())
                {
                    this.parmPackedLineIdSet(lineIdSetPacked);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSourceDocumentLine</Name>
				<Source><![CDATA[
    private void initializeSourceDocumentLine(SourceDocumentHeaderRecId sourceDocumentHeaderRecId, SourceDocumentLine _sourceDocumentLine)
    {
        _sourceDocumentLine.SourceDocumentHeader = sourceDocumentHeaderRecId;
        _sourceDocumentLine.TypeEnumName = enumStr(SourceDocument_ProductShipment);
        _sourceDocumentLine.TypeEnumValue = SourceDocument_ProductShipment::ProductShipment;
        _sourceDocumentLine.AccountingStatus = SourceDocumentLineAccountingStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(salesParmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transit documents
    /// </summary>
    private void transitDocument()
    {
        CustPackingSlipTrans        custPackingSlipTransLoc;
        SalesParmLine               salesParmLineLoc;
        TransitDocumentManager_IN transitDocManager = TransitDocumentManager_IN::newManager();

        transitDocManager.transit(salesParmTable, custPackingSlipJour);

        while select custPackingSlipTransLoc
                where custPackingSlipTransLoc.SalesId           == custPackingSlipJour.SalesId
                    && custPackingSlipTransLoc.PackingSlipId    == custPackingSlipJour.PackingSlipId
                    && custPackingSlipTransLoc.DeliveryDate     == custPackingSlipJour.DeliveryDate
                join salesParmLineLoc
                    where salesParmLineLoc.InventTransId        == custPackingSlipTransLoc.InventTransId
                        && salesParmLineLoc.ParmId              == salesParmTable.ParmId
                        && salesParmLineLoc.TableRefId          == salesParmTable.TableRefId
        {
            transitDocManager.transit(salesParmLineLoc, custPackingSlipTransLoc, custPackingSlipJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWHSLoadTableCustPackingSlipJourRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates link between the packing slip journal and the WHS load.
    /// </summary>
    [Hookable(false),
     SysObsolete('Method is obsoleted to support fast print feature. Please file an extensibility request if other access is required.', false, 25\5\2023)]
    protected void createWHSLoadTableCustPackingSlipJourRecords()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the inventory quantity remainder and populates the <c>InventReportDimHistory</c> table.
    /// </summary>
    /// <param name = "_inventTransId">
    /// An <c>InventTransId</c> type.
    /// </param>
    /// <param name = "_inventDimId">
    /// An <c>InventDimId</c> type.
    /// </param>
    /// <param name = "_transRefId">
    /// An <c>InventTransRefId</c> type.
    /// </param>
    /// <param name = "_transactionQty">
    /// An <c>InventQty</c> type.
    /// </param>
    /// <param name = "_qtyRemain">
    ///  An <c>InventQty</c> type.
    /// </param>
    /// <returns>
    /// The inventory quantity remainder.
    ///</returns>
    [SysObsolete('Method is obsoleted to support fast print feature. Please file an extensibility request if other access is required.', false, 25\5\2023)]
    protected InventQty createInventReportDimHistory(
        InventTransId _inventTransId,
        InventDimId _inventDimId,
        InventTransRefId _transRefId,
        InventQty _transactionQty,
        InventQty _qtyRemain)
    {
        InventQty               qtyTrans;
        InventReportDimHistory  inventReportDimHistory;
        Counter                 logCount = infologLine();

        if (abs(_transactionQty) < abs(_qtyRemain))
        {
            qtyTrans   = -_transactionQty;
            _qtyRemain -= qtyTrans;
        }
        else
        {
            qtyTrans  = _qtyRemain;
            _qtyRemain = 0;
        }

        try
        {
            inventReportDimHistory.TransactionLogType = this.inventReportDimHistoryLogType();
            inventReportDimHistory.TransRefId = _transRefId;
            inventReportDimHistory.InventTransId = _inventTransId;
            inventReportDimHistory.InventDimId = _inventDimId;
            inventReportDimHistory.Qty = qtyTrans;
            inventReportDimHistory.insert();
        }
        catch (Exception::DuplicateKeyException)
        {
            if (xSession::lastDuplicateKeyViolatingTable() == inventReportDimHistory.TableId)
            {
                select firstonly forupdate inventReportDimHistory
                    where inventReportDimHistory.TransactionLogType == this.inventReportDimHistoryLogType()
                       && inventReportDimHistory.TransRefId == _transRefId
                       && inventReportDimHistory.InventTransId == _inventTransId
                       && inventReportDimHistory.InventDimId == _inventDimId;

                inventReportDimHistory.Qty += qtyTrans;
                inventReportDimHistory.update();
            }
            else
            {
                throw Exception::DuplicateKeyException;
            }
            infolog.clear(logCount);
        }

        return _qtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReportDimHistoryLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the log type.
    /// </summary>
    /// <returns>
    ///  The Sales order - packing slip type.
    ///</returns>
    [Hookable(false),
     SysObsolete('Method is obsoleted to support fast print feature. Please file an extensibility request if other access is required.', false, 25\5\2023)]
    protected InventReportDimHistoryLogType inventReportDimHistoryLogType()
    {
        return InventReportDimHistoryLogType::SalesPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDummySourceDocumentLineRecId</Name>
				<Source><![CDATA[
    private RecId createDummySourceDocumentLineRecId()
    {
        if (!systemSequence)
        {
            systemSequence  = new SystemSequence();
        }

        RecId sourceDocumentLineRecId;
        try
        {
            systemSequence.suspendRecIds(tableNum(SourceDocumentLine));
            sourceDocumentLineRecId = systemSequence.reserveValues(1, tableNum(SourceDocumentLine));
        }
        finally
        {
            if (systemSequence)
            {
                systemSequence.removeRecIdSuspension(tableNum(SourceDocumentLine));
            }
        }

        if (!sourceDocumentLineRecId)
        {
            throw error('@SCM:ZeroRecIdOfSourceDocumentLine');
        }

        return sourceDocumentLineRecId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>