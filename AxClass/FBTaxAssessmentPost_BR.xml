<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FBTaxAssessmentPost_BR</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxReport</c> class is a parent class that is used by some country/region-specific tax
///    reports, such as the <c>TaxReport_BE</c> class.
/// </summary>
class FBTaxAssessmentPost_BR extends RunBaseBatch implements BatchRetryable
{
    FBTaxAssessment_BR                                   taxAssessment;
    FBTaxAssessmentCalculator_BR                         calculator;

    DataAreaId                                           fiscalEstablishmentDataArea;

    TaxPeriodDate                                        fromDate;
    TaxPeriodDate                                        toDate;
    TransDate                                            transactionDate;

    Counter                                              transactions;
    Counter                                              taxTransactions;

    TaxAmount                                            totalClearingTaxTransAmount;
    TaxAmount                                            totalClearingTaxTransAmountMST;

    InventTransId                                        inventTransId;

    VendAccount                                          vendAccount;
    LedgerDimensionAccount                               settlementAccount;

    FBTaxAssessmentPayment_BR                            taxAssessmentPayment;

    TaxAuthorityAddress                                  taxAuthority;

    Map                                                  clearingAmountByCompanyAndTaxCode;
    Map                                                  taxAmountByFiscalEstablishment;
    Map                                                  numberSeqMap;
    LedgerVoucher                                        ledgerVoucher;
    LedgerVoucherGroup                                   ledgerVoucherGroup;
    FiscalEstablishment_BR                               currentFiscalEstablishment;
    boolean                                              isIntercompany, hasWithholdingTaxes;
    TaxAmount                                            totalClearingWhtAmount;
    TaxAmount                                            totalClearingWhtAmountMST;
    TaxAmount                                            accRoundingDiff;
    TaxAmount                                            currentRoundingDiff;
    RoundingDifferenceThreshold_BR                       roundingDifferenceThreshold;

    #define.CurrentVersion(1)
    #localMacro.CurrentList
        fromDate,
        transactionDate,
        settlementAccount,
        toDate,
        vendAccount,
        totalClearingTaxTransAmount,
        taxAssessment,
        taxAssessmentPayment
    #endMacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateICMSDifAmounts</Name>
				<Source><![CDATA[
    private void calculateICMSDifAmounts(TaxTrans _taxTrans)
    {
        FiscalDocumentTaxTrans_BR fiscalDocumentTaxTrans;
        FiscalDocumentTaxTransSource_BR fiscalDocumentTaxTransSource;
        FiscalDocumentTaxTransOutgoingICMSDif_BR fiscalDocumentTaxTransOutgoingIcmsDif;
        FiscalDocumentTaxTransPovertyFund_BR fiscalDocumentTaxTransPovertyFund;
        TaxAmount taxAmount;
        real signal;

        select firstonly RecId from fiscalDocumentTaxTrans
            join ICMSDifIssuerTaxAmount, ICMSDifRecipientTaxAmount from fiscalDocumentTaxTransOutgoingIcmsDif
                where fiscalDocumentTaxTransOutgoingIcmsDif.FiscalDocumentTaxTrans == fiscalDocumentTaxTrans.RecId
            outer join TaxPovertyFundAmount from fiscalDocumentTaxTransPovertyFund
                where fiscalDocumentTaxTransPovertyFund.FiscalDocumentTaxTrans_BR == fiscalDocumentTaxTrans.RecId
            exists join fiscalDocumentTaxTransSource
                where fiscalDocumentTaxTransSource.FiscalDocumentTaxTrans_BR == fiscalDocumentTaxTrans.RecId
                    && fiscalDocumentTaxTransSource.TaxTrans == _taxTrans.RecId;

        if (!fiscalDocumentTaxTrans)
        {
            select RecId from fiscalDocumentTaxTrans
                where fiscalDocumentTaxTrans.TaxTrans == _taxTrans.RecId
            join ICMSDifIssuerTaxAmount, ICMSDifRecipientTaxAmount from fiscalDocumentTaxTransOutgoingIcmsDif
                where fiscalDocumentTaxTransOutgoingIcmsDif.FiscalDocumentTaxTrans == fiscalDocumentTaxTrans.RecId
            outer join TaxPovertyFundAmount from fiscalDocumentTaxTransPovertyFund
                where fiscalDocumentTaxTransPovertyFund.FiscalDocumentTaxTrans_BR == fiscalDocumentTaxTrans.RecId;
        }

        if (taxAssessment.State == currentFiscalEstablishment.postalAddress().State)
        {
            taxAmount = fiscalDocumentTaxTransOutgoingIcmsDif.ICMSDifIssuerTaxAmount;
        }
        else
        {
            if (taxAssessmentPayment.PaymentType == FBTaxAssessmentPaymentType_BR::ByDocument)
            {
                switch (taxAssessmentPayment.PaymentByDocumentType)
                {
                    case FBTaxAssessmentPaymentByDocumentType_BR::ICMSAndPovertyFund:
                        taxAmount = fiscalDocumentTaxTransOutgoingIcmsDif.ICMSDifRecipientTaxAmount
                                  + fiscalDocumentTaxTransPovertyFund.TaxPovertyFundAmount;
                        break;

                    case FBTaxAssessmentPaymentByDocumentType_BR::ICMSOnly:
                        taxAmount = fiscalDocumentTaxTransOutgoingIcmsDif.ICMSDifRecipientTaxAmount;
                        break;

                    case FBTaxAssessmentPaymentByDocumentType_BR::PovertyFundOnly:
                        taxAmount = fiscalDocumentTaxTransPovertyFund.TaxPovertyFundAmount;
                        break;
                }
            }
            else
            {
                taxAmount = fiscalDocumentTaxTransOutgoingIcmsDif.ICMSDifRecipientTaxAmount
                          + fiscalDocumentTaxTransPovertyFund.TaxPovertyFundAmount;
            }
        }

        signal = _taxTrans.TaxAmount < 0 ? -1 : 1;

        _taxTrans.TaxAmount = signal * taxAmount;
        _taxTrans.TaxAmountCur = _taxTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    This method must be in this class because it is called from the <c>DialogRunBase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsClearingAmount</Name>
				<Source><![CDATA[
    private boolean existsClearingAmount(CompanyId _companyId, TaxCode _taxCode)
    {
        container key = [_companyId, _taxCode];

        if (clearingAmountByCompanyAndTaxCode.exists(key))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>LedgerInterCompany</c> record for the specified parameters.
    /// </summary>
    /// <param name="_companyToFindIn">
    ///    The company where the <c>LedgerInterCompany</c> record exists.
    /// </param>
    /// <param name="_companyRelated">
    ///    The company that has the intercompany relationship.
    /// </param>
    /// <returns>
    ///    The <c>LedgerInterCompany</c> record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The intercompany accounting relationship is missing.
    /// </exception>
    private LedgerInterCompany findLedgerInterCompany(
        CompanyId _companyToFindIn,
        CompanyId _companyRelated)
    {
        return LedgerInterCompany::findCompanyPair(_companyToFindIn, _companyRelated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerVoucherByCompany</Name>
				<Source><![CDATA[
    private LedgerVoucher findLedgerVoucherByCompany(CompanyId _company)
    {
        LedgerVoucher           returnLedgerVoucher;
        NumberSequenceCode      numberSequenceCode;
        TransactionTxt          transactionTxt;
        NumberSeq               numberSeq;

        // Find the number sequence code for the company
        numberSequenceCode = this.findNumberSequenceCodeByCompany(_company);

        // Check if the ledger voucher already exists
        returnLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(_company, numberSequenceCode);

        if (returnLedgerVoucher == null)
        {
            returnLedgerVoucher = LedgerVoucher::newLedgerPost( DetailSummary::Summary,
                                                                SysModule::Tax,
                                                                numberSequenceCode);

            returnLedgerVoucher.parmCompanyId(_company);
            returnLedgerVoucher.parmCheckBlockedDimensions(false);
            ledgerVoucherGroup.addLedgerVoucher(returnLedgerVoucher);

            numberSeq = NumberSeq::newGetVoucher(TaxParameters::numRefTaxReportingVoucher(),false);

            transactionTxt = TransactionTxt::construct();
            transactionTxt.setType(LedgerTransTxt::TaxReporting);
            transactionTxt.setVoucher(returnLedgerVoucher.lastVoucher());
            transactionTxt.setKey1(enum2str(taxAssessment.TaxType));

            returnLedgerVoucher.addVoucher(LedgerVoucherObject::newVoucher( numberSeq.voucher(),
                                                                            transactionDate,
                                                                            SysModule::Tax,
                                                                            LedgerTransType::Tax));

            returnLedgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
        }

        return returnLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNumberSequenceCodeByCompany</Name>
				<Source><![CDATA[
    private NumberSequenceCode findNumberSequenceCodeByCompany(CompanyId _company)
    {
        NumberSeq               numberSeq;

        if (numberSeqMap.exists(_company))
        {
            numberSeq = numberSeqMap.lookup(_company);
        }
        else
        {
            changecompany(_company)
            {
                numberSeq = NumberSeq::newGetVoucher(TaxParameters::numRefTaxReportingVoucher(), false);
            }

            numberSeqMap.insert(_company, numberSeq);
        }

        return numberSeq.parmVoucherSequenceCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxCodeByCompanyId</Name>
				<Source><![CDATA[
    private TaxCode findTaxCodeByCompanyId(CompanyId _companyId)
    {
        MapEnumerator   enumerator;
        CompanyId       companyId;
        TaxCode         taxCode;
        TaxTable        taxTable;

        enumerator = clearingAmountByCompanyAndTaxCode.getEnumerator();

        while (enumerator.moveNext())
        {
            [companyId, taxCode] = enumerator.currentKey();

            if (companyId == _companyId)
            {
                changeCompany (companyId)
                {
                    if (TaxTable::find(taxCode))
                    {
                        return taxCode;
                    }
                }
            }
        }

        select firstOnly TaxCode from taxTable
            where taxTable.TaxType_BR == taxAssessment.TaxType;

        return taxTable.TaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxWithholdCodeByCompanyId</Name>
				<Source><![CDATA[
    private TaxWithholdCode findTaxWithholdCodeByCompanyId(CompanyId _companyId)
    {
        MapEnumerator       enumerator;
        CompanyId           companyId;
        TaxWithholdCode     taxWithholdCode;
        TaxWithholdTable    taxWithholdTable;
        TaxWithholdType_BR  taxWithholdType;

        enumerator = clearingAmountByCompanyAndTaxCode.getEnumerator();

        while (enumerator.moveNext())
        {
            [companyId, taxWithholdCode] = enumerator.currentKey();

            if (companyId == _companyId)
            {
                changeCompany (companyId)
                {
                    if (TaxWithholdTable::find(taxWithholdCode))
                    {
                        return taxWithholdCode;
                    }
                }
            }
        }

        if (taxAssessment.TaxType == TaxType_BR::PIS)
        {
            taxWithholdType = TaxWithholdType_BR::PIS;
        }
        else
        {
            taxWithholdType = TaxWithholdType_BR::COFINS;
        }

        select firstOnly TaxWithholdCode from taxWithholdTable
            where taxWithholdTable.TaxWithholdType_BR == taxWithholdType;

        return taxWithholdTable.TaxWithholdCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountLedgerDimension</Name>
				<Source><![CDATA[
    private LedgerDimensionDefaultAccount getAccountLedgerDimension(TaxCode _taxCode)
    {
        LedgerDimensionDefaultAccount   accountLedgerDimension;

        accountLedgerDimension = TaxLedgerAccountGroup::accountLedgerDimension(_taxCode, TaxDirection::IncomingTax);

        if (!accountLedgerDimension)
        {
            throw error(strFmt("@SYP4881180", taxAssessment.TaxType), "", SysInfoAction_MenuFunction::newMenuItem(menuitemDisplayStr(TaxAccountGroup), MenuItemType::Display));
        }

        return accountLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClearingAmount</Name>
				<Source><![CDATA[
    private TaxAmount getClearingAmount(CompanyId _companyId, TaxCode _taxCode)
    {
        container   key = [_companyId, _taxCode];
        TaxAmount   taxAmount;

        if (clearingAmountByCompanyAndTaxCode.exists(key))
        {
            taxAmount = clearingAmountByCompanyAndTaxCode.lookup(key);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionIntercompanyForAmount</Name>
				<Source><![CDATA[
    private LedgerDimensionDefaultAccount getLedgerDimensionIntercompanyForAmount(
        TaxAmount _taxAmount,
        LedgerInterCompany  _ledgerIntercompany)
    {
        if (_taxAmount > 0)
        {
            return _ledgerIntercompany.OriginatingDebitLedgerDimension;
        }
        else
        {
            return _ledgerIntercompany.OriginatingCreditLedgerDimension;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertClearingAmount</Name>
				<Source><![CDATA[
    private void insertClearingAmount(CompanyId _companyId, TaxCode _taxCode, TaxAmount _taxAmount)
    {
        container   key = [_companyId, _taxCode];

        clearingAmountByCompanyAndTaxCode.insert(key, _taxAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeFiscalEstablishmentDimAttrib</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount mergeFiscalEstablishmentDimAttrib(   LedgerDimensionAccount  _ledgerDimension,
                                                                        FiscalEstablishment_BR  _fiscalEstablishment)
    {
        LedgerDimensionAccount      ledgerDimension;
        DimensionAttributeRecId     fiscalEstablishmentDimensionAttribute;
        List                        dimensionSources;

        fiscalEstablishmentDimensionAttribute = BrazilParameters::find().FiscalEstablishmentDimensionAttribute;

        if (fiscalEstablishmentDimensionAttribute)
        {
            dimensionSources = new List(Types::Class);
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_fiscalEstablishment.getDefaultDimension()));
            ledgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(_ledgerDimension, dimensionSources);
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        clearingAmountByCompanyAndTaxCode    = new Map(Types::Container, Types::Real);
        taxAmountByFiscalEstablishment       = new Map(Types::Record, Types::Real);
        ledgerVoucherGroup                   = LedgerVoucherGroup::construct();
        numberSeqMap                         = new Map(Types::String, Types::Class);
        BrazilParameters brazilParams        = BrazilParameters::find();
        roundingDifferenceThreshold          = brazilParams.RoundingDifferenceThreshold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxAssessment</Name>
				<Source><![CDATA[
    public FBTaxAssessment_BR parmTaxAssessment(FBTaxAssessment_BR _taxAssessment = taxAssessment)
    {
        taxAssessment = _taxAssessment;

        return taxAssessment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxPayment</Name>
				<Source><![CDATA[
    public FBTaxAssessmentPayment_BR parmTaxPayment(FBTaxAssessmentPayment_BR _taxPayment = taxAssessmentPayment)
    {
        taxAssessmentPayment = _taxPayment;

        return taxAssessmentPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    private void post(  TaxCode                   _taxCode,
                        TaxDirection              _taxDirection,
                        LedgerDimensionAccount    _taxledgerDimension,
                        LedgerDimensionAccount    _useTaxPayableLedgerDimension,
                        CurrencyCode              _currencyCode,
                        TaxAmount                 _taxAmount,
                        TaxAmount                 _taxInCostPrice,
                        TaxAmount                 _taxAmountMST,
                        CurrencyExchangeHelper    _currencyHelper,
                        RefRecId                  _taxTransRecId,
                        TaxAmount                 _taxInCostPriceMST = 0,
                        boolean                   _isWithholdingTax = false)
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerPostingController     ledgerPostingController;
        TaxAmount                   taxAmount, taxAmountCurrentFiscalEstablishment;

        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);

        if (_taxAmount)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerPostingController.getReference(),
                                                    LedgerPostingType::Tax,
                                                    _taxledgerDimension,
                                                    _currencyCode,
                                                    _taxAmount - _taxInCostPrice,
                                                    _currencyHelper);

            if (_taxTransRecId)
            {
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTransRecId, TaxTransRelationshipType::Tax);
            }

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);
            ledgerPostingController.addTrans(ledgerVoucherTransObject);

            // Separating withholding tax amount
            if (_isWithholdingTax)
            {
                totalClearingWhtAmount      += (_taxAmount * -1);
                totalClearingWhtAmountMST   += (_taxAmountMST * -1);
            }
            else
            {
                totalClearingTaxTransAmount     += ((_taxAmount - _taxInCostPrice) * -1);
                totalClearingTaxTransAmountMST  += ((_taxAmountMST - _taxInCostPriceMST) * -1);
            }

            if (this.existsClearingAmount(curext(), _taxCode))
            {
                taxAmount = this.getClearingAmount(curext(), _taxCode);
                taxAmount += ((_taxAmount - _taxInCostPrice) * -1);
                this.insertClearingAmount(curext(), _taxCode, taxAmount);
            }
            else
            {
                taxAmount = ((_taxAmount - _taxInCostPrice) * -1);
                this.insertClearingAmount(curext(), _taxCode, taxAmount);
            }

            // PIS/COFINS tax assessment: it is necessary to have a balance by fiscal establishment
            if (taxAmountByFiscalEstablishment.exists(currentFiscalEstablishment))
            {
                taxAmountCurrentFiscalEstablishment = taxAmountByFiscalEstablishment.lookup(currentFiscalEstablishment);
                taxAmountCurrentFiscalEstablishment += _taxAmount;
            }
            else
            {
                taxAmountCurrentFiscalEstablishment = _taxAmount;
            }
            taxAmountByFiscalEstablishment.insert(currentFiscalEstablishment, taxAmountCurrentFiscalEstablishment);
            // End of PIS/COFINS tax assessment

            transactions++;
        }

        if (_taxDirection == TaxDirection::UseTax && _useTaxPayableLedgerDimension
            && _taxAmount == 0 && _taxInCostPrice != 0) // only to process the payable of the ICMS-Diff
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerPostingController.getReference(),
                                                    LedgerPostingType::Tax,
                                                    _useTaxPayableLedgerDimension,
                                                    _currencyCode,
                                                    _taxInCostPrice * -1,
                                                    _currencyHelper);

            ledgerVoucherTransObject.addTaxTransRelationship(_taxTransRecId, TaxTransRelationshipType::UseTaxPayable);
            ledgerPostingController.addTrans(ledgerVoucherTransObject);

            totalClearingTaxTransAmount     += _taxInCostPrice;
            totalClearingTaxTransAmountMST  += _taxInCostPrice;

            transactions++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCreditTaxTrans</Name>
				<Source><![CDATA[
    private void postCreditTaxTrans()
    {
        MapEnumerator               enumerator;
        CurrencyExchangeHelper      currencyExchangeHelper;
        TaxAmount                   taxAmount;
        TaxCode                     taxCode;
        LedgerDimensionAccount      taxClearingLedgerDimension;
        LedgerDimensionAccount      contribSalesTaxExpenseLedgerDimension;
        TaxTrans                    taxTransOffsetTrans;
        TaxTable                    taxTable;
        FBTaxTrans_BR               fbTaxTrans;
        CompanyId                   companyId;
        TaxWithholdTrans            taxWithholdTransOffsetTrans;
        TaxWithholdCode             taxWithholdCode;
        TaxWithholdTable            taxWithholdTable;
        TaxAmount                   totalAmount;
        AmountMST                   salesTaxExpense;
        FBTaxAssessmentPayment_BR   taxPaymentNonCumulative;
        FiscalOrganization_BR       fiscalOrganization;
        FBTaxAssessmentCalculatorPISCOFINS_BR   fbTaxAssessmentCalculatorPisCofins;

        // PIS/COFINS tax assessment: intercompany transactions must be processed
        if (isIntercompany)
        {
            this.postIntercompanyTrans();
        }
        // End of PIS/COFINS tax assessment

        ledgerVoucher           = this.findLedgerVoucherByCompany(curext());
        currencyExchangeHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

        // Verify if it is necessary to exclude the credit that can not be used (because of the proportional appropriation method)
        taxPaymentNonCumulative = FBTaxAssessmentPayment_BR::findByTaxAssessmentContribRegimen(taxAssessment.RecId, FBContribAssessmentRegimen_BR::NonCumulative);

        if (    taxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::NonCumulative
            || (taxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::Both
            && !taxPaymentNonCumulative))
        {
            fbTaxAssessmentCalculatorPisCofins  = calculator as FBTaxAssessmentCalculatorPISCOFINS_BR;
            salesTaxExpense                     = fbTaxAssessmentCalculatorPisCofins.getSalesTaxExpense();
        }

        totalAmount = totalClearingTaxTransAmount + totalClearingWhtAmount - salesTaxExpense;

        if (isIntercompany)
        {
            // Select any tax code from the current company to post the credit transaction.
            // It is necessary to do that once the credit source may be in a different company
            // and its tax code is not valid in the current company.
            taxCode = this.findTaxCodeByCompanyId(curext());

            taxClearingLedgerDimension = this.mergeFiscalEstablishmentDimAttrib(
                LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::accountLedgerDimension(taxCode, TaxDirection::IncomingTax)),
                currentFiscalEstablishment);

            ledgerVoucher.addTrans(
                LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucher.findLedgerVoucherObject(),
                    LedgerPostingType::TaxReport,
                    taxClearingLedgerDimension,
                    Ledger::accountingCurrency(),
                    totalAmount,
                    currencyExchangeHelper));

            if (salesTaxExpense > 0)
            {
                fiscalOrganization = FiscalOrganization_BR::findByFiscalEstablishmentId(currentFiscalEstablishment.FiscalEstablishmentId, currentFiscalEstablishment.dataAreaId);

                contribSalesTaxExpenseLedgerDimension = this.mergeFiscalEstablishmentDimAttrib(
                    LedgerDimensionFacade::serviceCreateLedgerDimension(fiscalOrganization.getSalesTaxExpenseAccountByTaxType(taxAssessment.TaxType)),
                    currentFiscalEstablishment);

                ledgerVoucher.addTrans(
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::TaxReport,
                        contribSalesTaxExpenseLedgerDimension,
                        Ledger::accountingCurrency(),
                        salesTaxExpense,
                        currencyExchangeHelper));
            }
        }
        else
        {
            // In case of there is no intercompany transaction, we can revert the remaining credit by tax code.
            enumerator = clearingAmountByCompanyAndTaxCode.getEnumerator();

            while (enumerator.moveNext())
            {
                [companyId, taxCode] = enumerator.currentKey();
                taxAmount = enumerator.currentValue();

                taxAmount += this.settleOtherAmounts(0, taxAmount);

                taxClearingLedgerDimension = this.mergeFiscalEstablishmentDimAttrib(
                    LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::accountLedgerDimension(taxCode, TaxDirection::IncomingTax)),
                    currentFiscalEstablishment);

                ledgerVoucher.addTrans(
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::TaxReport,
                        taxClearingLedgerDimension,
                        Ledger::accountingCurrency(),
                        taxAmount,
                        currencyExchangeHelper));
            }
        }

        if (totalAmount > 0)
        {
            taxTable = TaxTable::find(taxCode);

            taxTransOffsetTrans.Voucher                 = ledgerVoucher.lastVoucher();
            taxTransOffsetTrans.TransDate               = transactionDate;
            taxTransOffsetTrans.Source                  = TaxModuleType::Tax;
            taxTransOffsetTrans.TaxCode                 = taxCode;
            taxTransOffsetTrans.TaxOrigin               = TaxOrigin::TaxReporting;
            taxTransOffsetTrans.TaxDirection            = TaxDirection::IncomingTax;
            taxTransOffsetTrans.TaxPeriod               = taxTable.TaxPeriod;
            taxTransOffsetTrans.CurrencyCode            = Ledger::accountingCurrency();
            taxTransOffsetTrans.TaxAmountCur            = totalClearingTaxTransAmount - salesTaxExpense;
            taxTransOffsetTrans.TaxAmount               = CurrencyExchangeHelper::amount(totalClearingTaxTransAmount - salesTaxExpense);
            taxTransOffsetTrans.SourceCurrencyCode      = CompanyInfoHelper::standardCurrency();
            taxTransOffsetTrans.SourceTaxAmountCur      = CurrencyExchangeHelper::amount(totalClearingTaxTransAmount - salesTaxExpense);
            taxTransOffsetTrans.SourceRegulateAmountCur = CurrencyExchangeHelper::amount(totalClearingTaxTransAmount - salesTaxExpense);
            taxTransOffsetTrans.PrintCode               = taxTable.PrintCode;

            taxTransOffsetTrans.insertTaxReporting(fromDate);

            if (totalClearingWhtAmount > 0)
            {
                taxWithholdTable = TaxWithholdTable::find(taxWithholdCode);

                taxWithholdTransOffsetTrans.Voucher                 = ledgerVoucher.lastVoucher();
                taxWithholdTransOffsetTrans.TransDate               = transactionDate;
                taxWithholdTransOffsetTrans.Source_BR               = TaxWithholdSource::WithholdTax;
                taxWithholdTransOffsetTrans.TaxWithholdCode         = taxWithholdCode;
                taxWithholdTransOffsetTrans.TaxWithholdPeriod_BR    = taxWithholdTable.TaxWithholdPeriod_BR;
                taxWithholdTransOffsetTrans.TaxWithholdCurrency     = Ledger::accountingCurrency();
                taxWithholdTransOffsetTrans.TaxWithholdAmount       = totalClearingWhtAmount;

                taxWithholdTransOffsetTrans.insert();
            }

            fbTaxTrans.FBTaxAssessment_BR   = taxAssessment.RecId;
            fbTaxTrans.TaxType              = taxAssessment.TaxType;
            fbTaxTrans.Voucher              = ledgerVoucher.lastVoucher();
            fbTaxTrans.VoucherTransDate     = transactionDate;
            fbTaxTrans.VoucherDataArea      = fiscalEstablishmentDataArea;
            fbTaxTrans.TaxAmount            = totalAmount;
            fbTaxTrans.Classification       = FBTaxAssessmentClassification_BR::CreditBalanceToTransport;
            fbTaxTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIntercompanyTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// For each branch fiscal establishment that is out of the company related to the root fiscal establishment
    /// this method posts an intercompany trans to transfer the credit/debit for the root's company.
    /// Moreover, this method posts the opposite intercompany trans in the root's company.
    /// </summary>
    /// <remarks>
    /// The tax amount per fiscal establishment must have been calculated before.
    /// </remarks>
    private void postIntercompanyTrans()
    {
        FBBookingPeriod_BR              fbBookingPeriod;
        FiscalOrganization_BR           fiscalOrganization;
        FiscalEstablishment_BR          branchFiscalEstablishment;
        LedgerInterCompany              ledgerIntercompany;
        LedgerDimensionDefaultAccount   ledgerDimension;
        TaxAmount                       branchTaxAmount;
        CurrencyExchangeHelper          currencyExchangeHelper;
        DimensionAttributeRecId         fiscalEstablishmentDimensionAttribute;
        DimensionDefault                defaultDimension;

        fbBookingPeriod                         = taxAssessment.bookingPeriod();
        fiscalOrganization                      = FiscalOrganization_BR::findByFiscalEstablishmentId(fbBookingPeriod.FiscalEstablishmentId, fbBookingPeriod.FiscalEstablishmentDataArea);

        // Create an intercompany transaction for each branch fiscal establishment of a different company
        while select crossCompany branchFiscalEstablishment
            where   branchFiscalEstablishment.FiscalOrganization_BR == fiscalOrganization.RecId
                &&  branchFiscalEstablishment.dataAreaId            != fiscalOrganization.FiscalEstablishmentDataArea
        {
            if (taxAmountByFiscalEstablishment.exists(branchFiscalEstablishment))
            {
                changeCompany (branchFiscalEstablishment.dataAreaId)
                {
                    fiscalEstablishmentDimensionAttribute   = BrazilParameters::find().FiscalEstablishmentDimensionAttribute;

                    ledgerVoucher           = this.findLedgerVoucherByCompany(branchFiscalEstablishment.dataAreaId);
                    currencyExchangeHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
                    branchTaxAmount         = taxAmountByFiscalEstablishment.lookup(branchFiscalEstablishment);
                    ledgerIntercompany      = this.findLedgerInterCompany(branchFiscalEstablishment.dataAreaId, fiscalEstablishmentDataArea);
                    ledgerDimension         = this.getLedgerDimensionIntercompanyForAmount(branchTaxAmount*-1, ledgerIntercompany);

                    if (fiscalEstablishmentDimensionAttribute)
                    {
                        defaultDimension = this.mergeFiscalEstablishmentDimAttrib(
                                LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension),
                                branchFiscalEstablishment);
                    }
                    else
                    {
                        defaultDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension);
                    }

                    // post intercompany trans for branch fiscal establishment
                    ledgerVoucher.addTrans(
                        LedgerVoucherTransObject::newTransactionAmountDefault(
                            ledgerVoucher.findLedgerVoucherObject(),
                            LedgerPostingType::CrossCompanySettlement,
                            defaultDimension,
                            Ledger::accountingCurrency(),
                            branchTaxAmount * -1,
                            currencyExchangeHelper));
                }

                // post intercompany trans for root fiscal establishment (opposite value from the intercompany for branch)
                ledgerVoucher           = this.findLedgerVoucherByCompany(fiscalEstablishmentDataArea);
                currencyExchangeHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
                ledgerIntercompany      = this.findLedgerInterCompany(fiscalEstablishmentDataArea, branchFiscalEstablishment.dataAreaId);
                ledgerDimension         = this.getLedgerDimensionIntercompanyForAmount(branchTaxAmount, ledgerIntercompany);

                ledgerVoucher.addTrans(
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::CrossCompanySettlement,
                        LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension),
                        Ledger::accountingCurrency(),
                        branchTaxAmount,
                        currencyExchangeHelper));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVendVoucher</Name>
				<Source><![CDATA[
    protected void postVendVoucher()
    {
        DueDate                         dueDate;
        VendVoucher                     vendVoucher;
        VendTable                       vendTable;
        ExchangeRateHelper              exchangeRateHelper;
        CurrencyExchangeHelper          currencyExchangeHelper;
        VendTrans                       vendTrans;
        LedgerDimensionDefaultAccount   interestFineDefaultDimension;
        LedgerDimensionAccount          interestFineledgerDimension;
        LedgerDimensionAccount          creditByDocCannotBeUsedLedgerDimension;
        Amount                          totalAmount;
        Amount                          totalAmountMST;
        DimensionDefault                defaultDimension;
        FiscalEstablishment_BR          fiscalEstablishment;
        DimensionAttributeRecId         fiscalEstablishmentDimensionAttribute;
        AmountMST                               salesTaxExpense;
        FiscalOrganization_BR                   fiscalOrganization;
        FBTaxAssessmentCalculatorPISCOFINS_BR   fbTaxAssessmentCalculatorPisCofins;

        // PIS/COFINS tax assessment: intercompany transactions must be processed
        if (isIntercompany)
        {
            this.postIntercompanyTrans();
        }
        // End of PIS/COFINS tax assessment

        ledgerVoucher           = this.findLedgerVoucherByCompany(curext());
        currencyExchangeHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
        fiscalEstablishment     = taxAssessment.bookingPeriod().fiscalEstablishment();

        vendTable = VendTable::find(taxAuthority.AccountNum);
        dueDate   = FBTaxAssessmentPost_BR::taxReportDate(taxAssessment, taxAssessmentPayment);

        if (taxAssessmentPayment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::NonCumulative)
        {
            fbTaxAssessmentCalculatorPisCofins  = calculator as FBTaxAssessmentCalculatorPISCOFINS_BR;
            salesTaxExpense                     = fbTaxAssessmentCalculatorPisCofins.getSalesTaxExpense();
        }

        totalAmount += totalClearingTaxTransAmount + totalClearingWhtAmount - salesTaxExpense;
        totalAmount += this.settleOtherAmounts(vendTable.DefaultDimension, totalClearingTaxTransAmount + totalClearingWhtAmount - salesTaxExpense);
        totalAmountMST = CurrencyExchangeHelper::amount(totalAmount);

        totalAmount = totalAmount - (taxAssessmentPayment.InterestAmount + taxAssessmentPayment.FineAmount);
        totalAmountMST = totalAmountMST - (taxAssessmentPayment.InterestAmount + taxAssessmentPayment.FineAmount);

        fiscalEstablishmentDimensionAttribute   = BrazilParameters::find().FiscalEstablishmentDimensionAttribute;
        if (fiscalEstablishmentDimensionAttribute)
        {
            defaultDimension = LedgerDimensionDefaultFacade::serviceReplaceAttributeValue(
                vendTable.DefaultDimension,
                fiscalEstablishment.getDefaultDimension(),
                BrazilParameters::find().FiscalEstablishmentDimensionAttribute);
        }
        else
        {
            defaultDimension = vendTable.DefaultDimension;
        }

        vendVoucher  = CustVendVoucher::construct(SysModule::Vend,
                                        vendTable.AccountNum,
                                        CurrencyExchangeHelper::curAmount(totalAmount, vendTable.Currency, transactionDate),
                                        vendTable.Currency,
                                        LedgerTransTxt::TaxReporting,
                                        defaultDimension,
                                        VendParameters::find().PostingProfile,
                                        LedgerPostingType::Tax,
                                        vendTable.PaymTermId,
                                        SettlementType::None,
                                        HcmWorker::userId2Worker(curUserId()),
                                        NoYes::Yes,
                                        '',
                                        dateNull(),
                                        0,
                                        dueDate);

        vendVoucher.parmTransTxt("@SYS23178");
        vendVoucher.parmPaymMode(vendTable.PaymMode);
        vendVoucher.parmPaymSpec(vendTable.PaymSpec);
        vendVoucher.parmPaymId(vendTable.PaymId);
        vendVoucher.parmAmountMST(totalAmountMST);
        vendVoucher.parmFiscalEstablishmentRecId_BR(fiscalEstablishment.recid);

        exchangeRateHelper = ExchangeRateHelper::newExchangeDate(
        Ledger::current(),
            vendTable.Currency,
            transactionDate);

        vendVoucher.parmExchRate(exchangeRateHelper.getExchangeRate1());
        vendVoucher.parmExchRateSecondary(exchangeRateHelper.getExchangeRate2());

        vendVoucher.post(ledgerVoucher, vendTrans);

        if (salesTaxExpense > 0)
        {
            fiscalOrganization = FiscalOrganization_BR::findByFiscalEstablishmentId(fiscalEstablishment.FiscalEstablishmentId, fiscalEstablishment.dataAreaId);

            creditByDocCannotBeUsedLedgerDimension = this.mergeFiscalEstablishmentDimAttrib(
                LedgerDimensionFacade::serviceCreateLedgerDimension(fiscalOrganization.getSalesTaxExpenseAccountByTaxType(taxAssessment.TaxType)),
                fiscalEstablishment);

            ledgerVoucher.addTrans(
                LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucher.findLedgerVoucherObject(),
                    LedgerPostingType::TaxReport,
                    creditByDocCannotBeUsedLedgerDimension,
                    Ledger::accountingCurrency(),
                    salesTaxExpense,
                    currencyExchangeHelper));
        }

        if (taxAssessmentPayment.FineAmount)
        {
            interestFineDefaultDimension = VendLedgerAccounts::findFineAccount_BR(vendTable.AccountNum,
                                                                                  VendParameters::find().PostingProfile);

            interestFineledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(interestFineDefaultDimension, defaultDimension);

            ledgerVoucher.addTrans(
                LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucher.findLedgerVoucherObject(),
                    LedgerPostingType::Tax,
                    interestFineledgerDimension,
                    Ledger::accountingCurrency(),
                    taxAssessmentPayment.FineAmount,
                    currencyExchangeHelper));
        }

        if (taxAssessmentPayment.InterestAmount)
        {
            interestFineDefaultDimension = VendLedgerAccounts::findInterestAccount_BR(vendTable.AccountNum,
                                                                                     VendParameters::find().PostingProfile);

            interestFineledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(interestFineDefaultDimension, defaultDimension);

            ledgerVoucher.addTrans(
                LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucher.findLedgerVoucherObject(),
                    LedgerPostingType::Tax,
                    interestFineledgerDimension,
                    Ledger::accountingCurrency(),
                    taxAssessmentPayment.InterestAmount,
                    currencyExchangeHelper));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxCode</Name>
				<Source><![CDATA[
    private Counter processTaxCode(TaxCode _taxCode)
    {
        TaxTrans taxTrans;
        TaxTrans_BR taxtransBR;
        FBTaxTrans_BR fbTaxTrans;
        CurrencyExchangeHelper currencyExchangeHelper;
        Counter transactionsInTax;
        FBTaxTransTaxAssessmentPayment_BR fbTaxTransTaxAssessmentPayment;
        FiscalDocumentTaxTransSource_BR fiscalDocumentTaxTransSource;
        Set fiscalDocumentTaxTransIdSet;

        void process()
        {
            if (FBTaxAssessmentPost_BR::hasTaxableAmount(taxTrans)
                && (!this.needCalculateICMSDifAmounts(taxTrans)
                    || (this.needCalculateICMSDifAmounts(taxTrans)
                        && (!fiscalDocumentTaxTransSource.FiscalDocumentTaxTrans_BR
                            || !fiscalDocumentTaxTransIdSet.in(fiscalDocumentTaxTransSource.FiscalDocumentTaxTrans_BR)))))
            {
                if (fiscalDocumentTaxTransSource.FiscalDocumentTaxTrans_BR)
                {
                    fiscalDocumentTaxTransIdSet.add(fiscalDocumentTaxTransSource.FiscalDocumentTaxTrans_BR);
                }

                currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                                        Ledger::primaryLedger(taxTrans.companyInfo().RecId),
                                        transactionDate);

                this.saveAndPostRetrieveAccountsAndAmounts(taxTrans, currencyExchangeHelper);
                transactionsInTax++;
            }
        }

        fiscalDocumentTaxTransIdSet = new Set(Types::Int64);

        if (taxAssessmentPayment.RecId != 0)
        {
            // only process transactions linked to the payment when processing payments
            while select    TaxAmount, TaxAmountCur, TaxBaseQty, TaxBaseAmount, TaxBaseAmountCur, TaxInCostPrice,
                            TaxInCostPriceMST, TaxInCostPriceCur, SourceDocumentLine, RecId, TransDate, TaxCode,
                            TaxPeriod, TaxDirection, TaxOrigin, SourceCurrencyCode, CurrencyCode, SourceRegulateAmountCur, Voucher
                from taxTrans
                    where   taxTrans.TransDate  >= taxAssessment.FromDate
                        &&  taxTrans.TransDate  <= taxAssessment.ToDate
                        &&  taxTrans.TaxCode    == _taxCode
                        &&  (   (taxTrans.SourceTableId == tableNum(InventTransferJourLine) || taxTrans.SourceTableId == tableNum(TaxFiscalDocumentLine_BR))
                            ||  taxTrans.Source != TaxModuleType::Tax)
                outer join FiscalDocumentTaxTrans_BR from fiscalDocumentTaxTransSource
                    where fiscalDocumentTaxTransSource.TaxTrans == taxTrans.RecId
                exists join taxtransBR
                    where taxtransBR.TaxTrans == taxTrans.RecId
                        // also process ICMSDiff when taxType is ICMS
                        && ((taxAssessment.TaxType == TaxType_BR::ICMS
                        && (taxtransBR.TaxType_BR == TaxType_BR::ICMS
                                || (taxtransBR.TaxType_BR == TaxType_BR::ICMSDiff && taxTrans.TaxDirection == TaxDirection::UseTax)))
                        // only process taxtrans with taxAssessment.taxType when not processing ICMS
                        || (taxAssessment.TaxType != TaxType_BR::ICMS && taxtransBR.TaxType_BR == taxAssessment.TaxType))
                     && taxtransBR.TaxReceivableLongTerm_BR == NoYes::No
                exists join fbTaxTrans
                    where   fbTaxTrans.TaxType                  == taxAssessment.TaxType
                        &&  fbTaxTrans.FiscalEstablishmentId    == currentFiscalEstablishment.FiscalEstablishmentId
                        &&  fbTaxTrans.FiscalEstablishmentDataArea == currentFiscalEstablishment.dataAreaId
                        &&  fbTaxTrans.Voucher                  == taxTrans.Voucher
                        &&  fbTaxTrans.VoucherDataArea          == taxTrans.dataAreaId
                        &&  fbTaxTrans.FBTaxAssessment_BR       == taxAssessment.RecId
                exists join fbTaxTransTaxAssessmentPayment
                    where fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTrans.RecId
                        && fbTaxTransTaxAssessmentPayment.FBTaxAssessmentPayment_BR == taxAssessmentPayment.RecId
            {
                process();
            }
        }
        else
        {
            // process all transactions not linked to a payment and linked to assessment period when processing tax assessment closing
            while select    TaxAmount, TaxAmountCur, TaxBaseQty, TaxBaseAmount, TaxBaseAmountCur, TaxInCostPrice,
                            TaxInCostPriceMST, TaxInCostPriceCur, SourceDocumentLine, RecId, TransDate, TaxCode,
                            TaxPeriod, TaxDirection, TaxOrigin, SourceCurrencyCode, CurrencyCode, SourceRegulateAmountCur, Voucher
                from taxTrans
                    where   taxTrans.TransDate  >= taxAssessment.FromDate
                        &&  taxTrans.TransDate  <= taxAssessment.ToDate
                        &&  taxTrans.TaxCode    == _taxCode
                        &&  (   (taxTrans.SourceTableId == tableNum(InventTransferJourLine) || taxTrans.SourceTableId == tableNum(TaxFiscalDocumentLine_BR))
                            ||  taxTrans.Source != TaxModuleType::Tax)
                outer join FiscalDocumentTaxTrans_BR from fiscalDocumentTaxTransSource
                    where fiscalDocumentTaxTransSource.TaxTrans == taxTrans.RecId
                        && fiscalDocumentTaxTransSource.FiscalDocumentTaxTrans_BR
                exists join taxtransBR
                    where taxtransBR.TaxTrans == taxTrans.RecId
                        // also process ICMSDiff when taxType is ICMS
                        && ((taxAssessment.TaxType == TaxType_BR::ICMS
                        && (taxtransBR.TaxType_BR == TaxType_BR::ICMS
                                || (taxtransBR.TaxType_BR == TaxType_BR::ICMSDiff && taxTrans.TaxDirection == TaxDirection::UseTax)))
                        // only process taxtrans with taxAssessment.taxType when not processing ICMS
                        || (taxAssessment.TaxType != TaxType_BR::ICMS && taxtransBR.TaxType_BR == taxAssessment.TaxType))
                    &&  taxtransBR.TaxReceivableLongTerm_BR == NoYes::No
                exists join fbTaxTrans
                    where   fbTaxTrans.TaxType                  == taxAssessment.TaxType
                        &&  fbTaxTrans.FiscalEstablishmentId    == currentFiscalEstablishment.FiscalEstablishmentId
                        &&  fbTaxTrans.FiscalEstablishmentDataArea == currentFiscalEstablishment.dataAreaId
                        &&  fbTaxTrans.Voucher                  == taxTrans.Voucher
                        &&  fbTaxTrans.VoucherDataArea          == taxTrans.dataAreaId
                        &&  fbTaxTrans.FBTaxAssessment_BR       == taxAssessment.RecId
                notExists join fbTaxTransTaxAssessmentPayment
                    where fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTrans.RecId
            {
                process();
            }
        }

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxTransByTaxCode</Name>
				<Source><![CDATA[
    private Counter processTaxTransByTaxCode()
    {
        TaxTrans                            taxTransLocal;
        TaxTrans_BR                         taxtransBRLocal;
        Counter                             transactionsInTax;
        FBTaxTrans_BR                       fbTaxTransLocal;
        FBTaxTransTaxAssessmentPayment_BR   fbTaxTransTaxAssessmentPayment;

        void process()
        {
            if (FBTaxAssessmentPost_BR::hasTaxableAmount(taxTransLocal))
            {
                transactionsInTax += this.processTaxCode(taxTransLocal.TaxCode);
            }
        }

        if (taxAssessmentPayment.RecId != 0)
        {
            // only process transactions linked to the payment when processing payments
            while select sum(TaxAmount), sum(TaxAmountCur), sum(TaxBaseQty), sum(TaxBaseAmount), sum(TaxBaseAmountCur), sum(TaxInCostPrice),
                        sum(TaxInCostPriceMST), sum(TaxInCostPriceCur), TaxCode
            from taxTransLocal
            group by TaxCode
            where   taxTransLocal.TransDate      >= taxAssessment.FromDate
                &&  taxTransLocal.TransDate      <= taxAssessment.ToDate
                &&  (   (taxTransLocal.SourceTableId == tableNum(InventTransferJourLine) && taxTransLocal.Source == TaxModuleType::Tax)
                    ||  taxTransLocal.Source         != TaxModuleType::Tax)
                exists join taxtransBRLocal
                    where taxtransBRLocal.TaxTrans == taxTransLocal.RecId
                        // also process ICMSDiff when taxType is ICMS
                        && ((taxAssessment.TaxType == TaxType_BR::ICMS
                        && (taxtransBRLocal.TaxType_BR == TaxType_BR::ICMS
                                || (taxtransBRLocal.TaxType_BR == TaxType_BR::ICMSDiff && taxTransLocal.TaxDirection == TaxDirection::UseTax)))
                        // only process taxtrans with taxAssessment.taxType when not processing ICMS
                        ||  (taxAssessment.TaxType != TaxType_BR::ICMS && taxtransBRLocal.TaxType_BR == taxAssessment.TaxType))
                    &&  taxtransBRLocal.TaxReceivableLongTerm_BR == NoYes::No
                exists join fbTaxTransLocal
                    where   fbTaxTransLocal.TaxType                 == taxAssessment.TaxType
                        &&  fbTaxTransLocal.FiscalEstablishmentId   == currentFiscalEstablishment.FiscalEstablishmentId
                        &&  fbTaxTransLocal.FiscalEstablishmentDataArea == currentFiscalEstablishment.dataAreaId
                        &&  fbTaxTransLocal.Voucher                 == taxTransLocal.Voucher
                        &&  fbTaxTransLocal.VoucherDataArea         == taxTransLocal.dataAreaId
                        &&  fbTaxTransLocal.FBTaxAssessment_BR      == taxAssessment.RecId
                exists join fbTaxTransTaxAssessmentPayment
                    where fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTransLocal.RecId
                        && fbTaxTransTaxAssessmentPayment.FBTaxAssessmentPayment_BR == taxAssessmentPayment.RecId
            {
                process();
            }
        }
        else
        {
            // process all transactions not linked to a payment and linked to assessment period when processing tax assessment closing
            while select sum(TaxAmount), sum(TaxAmountCur), sum(TaxBaseQty), sum(TaxBaseAmount), sum(TaxBaseAmountCur), sum(TaxInCostPrice),
                        sum(TaxInCostPriceMST), sum(TaxInCostPriceCur), TaxCode
            from taxTransLocal
            group by TaxCode
            where   taxTransLocal.TransDate      >= taxAssessment.FromDate
                &&  taxTransLocal.TransDate      <= taxAssessment.ToDate
                &&  (   (taxTransLocal.SourceTableId == tableNum(InventTransferJourLine) && taxTransLocal.Source == TaxModuleType::Tax)
                    ||  taxTransLocal.Source         != TaxModuleType::Tax)
                exists join taxtransBRLocal
                    where taxtransBRLocal.TaxTrans == taxTransLocal.RecId
                        // also process ICMSDiff when taxType is ICMS
                        && ((taxAssessment.TaxType == TaxType_BR::ICMS
                        && (taxtransBRLocal.TaxType_BR == TaxType_BR::ICMS
                                || (taxtransBRLocal.TaxType_BR == TaxType_BR::ICMSDiff && taxTransLocal.TaxDirection == TaxDirection::UseTax)))
                        // only process taxtrans with taxAssessment.taxType when not processing ICMS
                        ||  (taxAssessment.TaxType != TaxType_BR::ICMS && taxtransBRLocal.TaxType_BR == taxAssessment.TaxType))
                    &&  taxtransBRLocal.TaxReceivableLongTerm_BR == NoYes::No
                exists join fbTaxTransLocal
                    where   fbTaxTransLocal.TaxType                 == taxAssessment.TaxType
                        &&  fbTaxTransLocal.FiscalEstablishmentId   == currentFiscalEstablishment.FiscalEstablishmentId
                        &&  fbTaxTransLocal.FiscalEstablishmentDataArea == currentFiscalEstablishment.dataAreaId
                        &&  fbTaxTransLocal.Voucher                 == taxTransLocal.Voucher
                        &&  fbTaxTransLocal.VoucherDataArea         == taxTransLocal.dataAreaId
                        &&  fbTaxTransLocal.FBTaxAssessment_BR      == taxAssessment.RecId
                notExists join fbTaxTransTaxAssessmentPayment
                    where fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTransLocal.RecId
            {
                process();
            }
        }

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxWithholdCode</Name>
				<Source><![CDATA[
    private Counter processTaxWithholdCode( TaxWithholdCode     _taxWithholdCode,
                                            TaxWithholdType_BR  _taxWithholdType,
                                            AmountMST           _totalCreditAmount)
    {
        TaxWithholdTrans                    taxWithholdTrans;
        FBTaxWithholdTrans_BR               fbTaxWithholdTrans;
        Counter                             transactionsInTax;
        FBTaxTrans_BR                       fbTaxTrans;
        CurrencyExchangeHelper              currencyExchangeHelper;
        AmountMST                           taxWithholdAmountMST;
        LedgerDimensionAccount              taxWithholdLedgerDimension;
        TaxTransRefRecId                    offsetTaxWithholdTrans;
        CustTrans                           invoiceCustTrans;
        AmountMST                           creditAmount, remainingCreditAmount;
        FBTaxTransTaxAssessmentPayment_BR   fbTaxTransTaxAssessmentPayment;

        void process()
        {
            if (remainingCreditAmount > taxWithholdTrans.TaxWithholdAmount)
            {
                creditAmount = taxWithholdTrans.TaxWithholdAmount;
            }
            else
            {
                creditAmount = remainingCreditAmount;
            }
            remainingCreditAmount -= creditAmount;

            currencyExchangeHelper  = CurrencyExchangeHelper::newExchangeDate(
                                        Ledger::primaryLedger(CompanyInfo::find(false).RecId),
                                        transactionDate);
            taxWithholdAmountMST    = CurrencyExchangeHelper::amount(creditAmount);

            select DefaultDimension from invoiceCustTrans
                where taxWithholdTrans.CustTransInvoiceId == invoiceCustTrans.RecId;

            if (taxWithholdTrans.LedgerDimension)
            {
                if (invoiceCustTrans.DefaultDimension)
                {
                    taxWithholdLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                                                                taxWithholdTrans.LedgerDimension,
                                                                invoiceCustTrans.DefaultDimension);
                }
                else
                {
                    taxWithholdLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdTrans.LedgerDimension);
                }

                offsetTaxWithholdTrans = this.saveOffsetTaxWithholdTrans(taxWithholdTrans, creditAmount);

                this.post(  taxWithholdTrans.TaxWithholdCode,
                            TaxDirection::IncomingTax,
                            taxWithholdLedgerDimension,
                            0,
                            CompanyInfoHelper::standardCurrency(),
                            creditAmount * -1,
                            0,
                            taxWithholdAmountMST * -1,
                            currencyExchangeHelper,
                            offsetTaxWithholdTrans,
                            0,
                            true);
            }

            transactionsInTax++;
        }

        remainingCreditAmount = _totalCreditAmount;

        if (taxAssessmentPayment.RecId != 0)
        {
            while select taxWithholdTrans
                where   taxWithholdTrans.TaxWithholdCode    == _taxWithholdCode
                    &&  taxWithholdTrans.TaxWithholdAmount
                    &&  taxWithholdTrans.TaxWithholdBaseAmount
                    exists join fbTaxWithholdTrans
                        where   fbTaxWithholdTrans.VoucherId            == taxWithholdTrans.Voucher
                            &&  fbTaxWithholdTrans.TransDate            == taxWithholdTrans.TransDate
                            &&  fbTaxWithholdTrans.FiscalEstablishment  == currentFiscalEstablishment.FiscalEstablishmentId
                    exists join fbTaxTrans
                        where   fbTaxTrans.FBTaxWithholdTrans_BR    == fbTaxWithholdTrans.RecId
                            &&  fbTaxTrans.FBTaxAssessment_BR       == taxAssessment.RecId
                    exists join fbTaxTransTaxAssessmentPayment
                        where   fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTrans.RecId
                            &&  fbTaxTransTaxAssessmentPayment.FBTAxAssessmentPayment_BR == taxAssessmentPayment.RecId
            {
                if (remainingCreditAmount == 0)
                {
                    break;
                }

                process();
            }
        }
        else
        {
            while select taxWithholdTrans
                where   taxWithholdTrans.TaxWithholdCode    == _taxWithholdCode
                    &&  taxWithholdTrans.TaxWithholdAmount
                    &&  taxWithholdTrans.TaxWithholdBaseAmount
                    exists join fbTaxWithholdTrans
                        where   fbTaxWithholdTrans.VoucherId            == taxWithholdTrans.Voucher
                            &&  fbTaxWithholdTrans.TransDate            == taxWithholdTrans.TransDate
                            &&  fbTaxWithholdTrans.FiscalEstablishment  == currentFiscalEstablishment.FiscalEstablishmentId
                    exists join fbTaxTrans
                        where   fbTaxTrans.FBTaxWithholdTrans_BR    == fbTaxWithholdTrans.RecId
                            &&  fbTaxTrans.FBTaxAssessment_BR       == taxAssessment.RecId
                    notExists join fbTaxTransTaxAssessmentPayment
                        where   fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTrans.RecId
            {
                if (remainingCreditAmount == 0)
                {
                    break;
                }

                process();
            }
        }

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxWithholdTransByTaxCode</Name>
				<Source><![CDATA[
    private Counter processTaxWithholdTransByTaxCode()
    {
        TaxWithholdTrans                    taxWithholdTrans;
        TaxWithholdTable                    taxWithholdTable;
        TaxWithholdType_BR                  taxWithholdType;
        FBTaxWithholdTrans_BR               fbTaxWithholdTrans;
        FBTaxTrans_BR                       fbTaxTrans;
        Counter                             transactionsInTax;
        FBTaxTransTaxAssessmentPayment_BR   fbTaxTransTaxAssessmentPayment;

        void process()
        {
            if (fbTaxTrans.TaxAmount)
            {
                transactionsInTax += this.processTaxWithholdCode(taxWithholdTrans.TaxWithholdCode, taxWithholdType, fbTaxTrans.TaxAmount);
            }
        }

        if (taxAssessment.TaxType == TaxType_BR::PIS)
        {
            taxWithholdType = TaxWithholdType_BR::PIS;
        }
        else
        {
            taxWithholdType = TaxWithholdType_BR::COFINS;
        }

        if (taxAssessmentPayment.RecId != 0)
        {
            while select sum(TaxAmount) from fbTaxTrans
                group by taxWithholdTrans.TaxWithholdCode
                where   fbTaxTrans.FBTaxAssessment_BR   == taxAssessment.RecId
                    join RecId from fbTaxWithholdTrans
                        where   fbTaxWithholdTrans.RecId                == fbTaxTrans.FBTaxWithholdTrans_BR
                            &&  fbTaxWithholdTrans.FiscalEstablishment  == currentFiscalEstablishment.FiscalEstablishmentId
                    join TaxWithholdCode from taxWithholdTrans
                        where   taxWithholdTrans.Voucher    == fbTaxWithholdTrans.VoucherId
                            &&  taxWithholdTrans.TransDate  == fbTaxWithholdTrans.TransDate
                    exists join taxWithholdTable
                        where   taxWithholdTable.TaxWithholdCode    == taxWithholdTrans.TaxWithholdCode
                            &&  taxWithholdTable.TaxWithholdType_BR == taxWithholdType
                    exists join fbTaxTransTaxAssessmentPayment
                        where   fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR                == fbTaxTrans.RecId
                            &&  fbTaxTransTaxAssessmentPayment.FBTaxAssessmentPayment_BR    == taxAssessmentPayment.RecId
            {
                process();
            }
        }
        else
        {
            while select sum(TaxAmount) from fbTaxTrans
                group by taxWithholdTrans.TaxWithholdCode
                where   fbTaxTrans.FBTaxAssessment_BR   == taxAssessment.RecId
                    join RecId from fbTaxWithholdTrans
                        where   fbTaxWithholdTrans.RecId                == fbTaxTrans.FBTaxWithholdTrans_BR
                            &&  fbTaxWithholdTrans.FiscalEstablishment  == currentFiscalEstablishment.FiscalEstablishmentId
                    join TaxWithholdCode from taxWithholdTrans
                        where   taxWithholdTrans.Voucher    == fbTaxWithholdTrans.VoucherId
                            &&  taxWithholdTrans.TransDate  == fbTaxWithholdTrans.TransDate
                    exists join taxWithholdTable
                        where   taxWithholdTable.TaxWithholdCode    == taxWithholdTrans.TaxWithholdCode
                            &&  taxWithholdTable.TaxWithholdType_BR == taxWithholdType
                    notExists join fbTaxTransTaxAssessmentPayment
                        where   fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == taxAssessmentPayment.RecId
            {
                process();
            }
        }

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertBalanceFromPreviousPeriod</Name>
				<Source><![CDATA[
    private void revertBalanceFromPreviousPeriod()
    {
        MapEnumerator                       enumerator = clearingAmountByCompanyAndTaxCode.getEnumerator();
        CurrencyExchangeHelper              currencyExchangeHelper;
        FBTaxTrans_BR                       fbTaxTrans;
        TaxTrans                            taxTransOffsetTrans;
        TaxTable                            taxTable;
        TaxCode                             taxCode;
        LedgerDimensionAccount              taxClearingLedgerDimension;
        TaxWithholdTable                    taxWithholdTable;

        // Find any tax code related to the current company
        taxCode     = this.findTaxCodeByCompanyId(curext());
        taxTable    = TaxTable::find(taxCode);

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), transactionDate);

        // If there is a tax code and transactions to be reverted,
        // then the credit from previous period is reverted
        if (taxTable)
        {
            taxClearingLedgerDimension = this.mergeFiscalEstablishmentDimAttrib(
                LedgerDimensionFacade::serviceCreateLedgerDimension(this.getAccountLedgerDimension(taxCode)),
                currentFiscalEstablishment);

            // Revert credit from previous balance
            while select forupdate fbTaxTrans
                where   fbTaxTrans.FBTaxAssessment_BR           == taxAssessment.RecId
                    &&  fbTaxTrans.Classification               == FBTaxAssessmentClassification_BR::CreditBalanceFromPreviousPeriod
                    &&  fbTaxTrans.FiscalEstablishmentId        == currentFiscalEstablishment.FiscalEstablishmentId
                    &&  fbTaxTrans.FiscalEstablishmentDataArea  == currentFiscalEstablishment.dataAreaId
                    &&  fbTaxTrans.Voucher                      == ''
            {
                taxTransOffsetTrans.Voucher                 = ledgerVoucher.lastVoucher();
                taxTransOffsetTrans.TransDate               = transactionDate;
                taxTransOffsetTrans.Source                  = TaxModuleType::Tax;
                taxTransOffsetTrans.TaxCode                 = taxCode;
                taxTransOffsetTrans.TaxOrigin               = TaxOrigin::TaxReporting;
                taxTransOffsetTrans.TaxDirection            = TaxDirection::IncomingTax;
                taxTransOffsetTrans.TaxPeriod               = taxTable.TaxPeriod;
                taxTransOffsetTrans.CurrencyCode            = Ledger::accountingCurrency();
                taxTransOffsetTrans.TaxAmountCur            = fbTaxTrans.TaxAmount;
                taxTransOffsetTrans.TaxAmount               = CurrencyExchangeHelper::amount(fbTaxTrans.TaxAmount);
                taxTransOffsetTrans.SourceCurrencyCode      = CompanyInfoHelper::standardCurrency();
                taxTransOffsetTrans.SourceTaxAmountCur      = CurrencyExchangeHelper::amount(fbTaxTrans.TaxAmount);
                taxTransOffsetTrans.SourceRegulateAmountCur = CurrencyExchangeHelper::amount(fbTaxTrans.TaxAmount);
                taxTransOffsetTrans.PrintCode               = taxTable.PrintCode;

                taxTransOffsetTrans.insertTaxReporting(fromDate);

                this.post(taxCode,
                          TaxDirection::IncomingTax,
                          taxClearingLedgerDimension,
                          0,
                          Ledger::accountingCurrency(),
                          fbTaxTrans.TaxAmount * -1,
                          0,
                          fbTaxTrans.TaxAmount * -1,
                          currencyExchangeHelper,
                          taxTransOffsetTrans.RecID,
                          0);

                fbTaxTrans.Voucher          = ledgerVoucher.lastVoucher();
                fbTaxTrans.VoucherDataArea  = fiscalEstablishmentDataArea;
                fbTaxTrans.VoucherTransDate = transactionDate;
                fbTaxTrans.update();
            }
        }

        // Find any withhold tax code related to the current company
        taxWithholdTable    = TaxWithholdTable::find(this.findTaxWithholdCodeByCompanyId(curext()));

        // Withholding taxes section
        if (hasWithholdingTaxes && taxWithholdTable)
        {
            if (taxAssessment.ContribAssessmentRegimen != FBContribAssessmentRegimen_BR::Both)
            {
                this.revertWhtBalanceFromPreviousPeriod(taxAssessment.ContribAssessmentRegimen, taxWithholdTable, currencyExchangeHelper);
            }
            else
            {
                if (taxAssessmentPayment.RecId)
                {
                    this.revertWhtBalanceFromPreviousPeriod(taxAssessmentPayment.ContribAssessmentRegimen, taxWithholdTable, currencyExchangeHelper);
                }
                else
                {
                    this.revertWhtBalanceFromPreviousPeriod(FBContribAssessmentRegimen_BR::Cumulative, taxWithholdTable, currencyExchangeHelper);
                    this.revertWhtBalanceFromPreviousPeriod(FBContribAssessmentRegimen_BR::NonCumulative, taxWithholdTable, currencyExchangeHelper);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertWhtBalanceFromPreviousPeriod</Name>
				<Source><![CDATA[
    private void revertWhtBalanceFromPreviousPeriod(FBContribAssessmentRegimen_BR   _assessmentRegimen,
                                                    TaxWithholdTable                _taxWithholdTable,
                                                    CurrencyExchangeHelper          _currencyExchangeHelper)
    {
        FBTaxTrans_BR                       fbTaxTrans;
        TaxWithholdTrans                    taxWithholdTransOffsetTrans;
        LedgerDimensionAccount              taxClearingLedgerDimension;
        FBTaxAssessmentClassification_BR    withholdingClassification;

        taxClearingLedgerDimension = this.mergeFiscalEstablishmentDimAttrib(
                LedgerDimensionFacade::serviceCreateLedgerDimension(_taxWithholdTable.TaxIncomingLedgerDimension_BR),
                currentFiscalEstablishment);

        if (_assessmentRegimen == FBContribAssessmentRegimen_BR::Cumulative)
        {
            withholdingClassification = FBTaxAssessmentClassification_BR::CumulativeWhtFromPreviousPeriod;
        }
        else if (_assessmentRegimen == FBContribAssessmentRegimen_BR::NonCumulative)
        {
            withholdingClassification = FBTaxAssessmentClassification_BR::NonCumulativeWhtFromPreviousPeriod;
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Revert manual withholding tax credit
        while select forupdate fbTaxTrans
            where   fbTaxTrans.FBTaxAssessment_BR           == taxAssessment.RecId
                &&  fbTaxTrans.Classification               == withholdingClassification
                &&  fbTaxTrans.FiscalEstablishmentId        == currentFiscalEstablishment.FiscalEstablishmentId
                &&  fbTaxTrans.FiscalEstablishmentDataArea  == currentFiscalEstablishment.dataAreaId
                &&  fbTaxTrans.Voucher                      == ''
        {
            taxWithholdTransOffsetTrans.Voucher                 = ledgerVoucher.lastVoucher();
            taxWithholdTransOffsetTrans.TransDate               = transactionDate;
            taxWithholdTransOffsetTrans.Source_BR               = TaxWithholdSource::WithholdTax;
            taxWithholdTransOffsetTrans.TaxWithholdCode         = _taxWithholdTable.TaxWithholdCode;
            taxWithholdTransOffsetTrans.TaxWithholdPeriod_BR    = _taxWithholdTable.TaxWithholdPeriod_BR;
            taxWithholdTransOffsetTrans.TaxWithholdCurrency     = Ledger::accountingCurrency();
            taxWithholdTransOffsetTrans.TaxWithholdAmount       = fbTaxTrans.TaxAmount;
            taxWithholdTransOffsetTrans.insert();

            this.post(_taxWithholdTable.TaxWithholdCode,
                        TaxDirection::IncomingTax,
                        taxClearingLedgerDimension,
                        0,
                        Ledger::accountingCurrency(),
                        fbTaxTrans.TaxAmount * -1,
                        0,
                        fbTaxTrans.TaxAmount * -1,
                        _currencyExchangeHelper,
                        taxWithholdTransOffsetTrans.RecID,
                        0,
                        true);

            fbTaxTrans.Voucher          = ledgerVoucher.lastVoucher();
            fbTaxTrans.VoucherDataArea  = fiscalEstablishmentDataArea;
            fbTaxTrans.VoucherTransDate = transactionDate;
            fbTaxTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the tax assessment posting to the ledger.
    /// </summary>
    public void  run()
    {
        #OCCRetryCount
        TaxTrans        taxTrans;
        MapEnumerator   enumerator;
        NumberSeq       numberSeq;

        try
        {
            ttsbegin;

            if (taxAssessment)
            {
                // Check if the tax assessment may have intercompany transactions
                isIntercompany      = false;
                hasWithholdingTaxes = false;

                if (taxAssessment.TaxType == TaxType_BR::PIS || taxAssessment.TaxType == TaxType_BR::COFINS)
                {
                    isIntercompany      = true;
                    hasWithholdingTaxes = true;
                }

                fiscalEstablishmentDataArea = taxAssessment.bookingPeriod().FiscalEstablishmentDataArea;

                changeCompany (fiscalEstablishmentDataArea)
                {
                    this.validateBeforePost();

                    fromDate    = taxAssessment.FromDate;
                    toDate      = taxAssessment.ToDate;

                    if (taxAssessmentPayment.RecId)
                    {
                        transactionDate = taxAssessmentPayment.TransDate;
                    }
                    else
                    {
                        transactionDate = taxAssessment.ToDate;
                    }

                    this.updateNow();

                    if (taxTransactions)
                    {
                        if (!transactions)
                        {
                            enumerator = ledgerVoucherGroup.getInternalCollection().getEnumerator();

                            while (enumerator.moveNext())
                            {
                                ledgerVoucher = enumerator.currentValue();

                                update_recordset taxTrans
                                    setting Voucher = ''
                                    where   taxTrans.Voucher   == ledgerVoucher.lastVoucher()
                                        &&  taxTrans.TransDate == transactionDate;

                                numberSeq = numberSeqMap.lookup(ledgerVoucher.parmCompanyId());
                                numberSeq.abort();
                            }
                        }
                    }
                    else
                    {
                        if (taxAssessmentPayment.RecId)
                        {
                            taxAssessmentPayment.Voucher = '';
                            taxAssessmentPayment.update();
                        }

                        enumerator = numberSeqMap.getEnumerator();

                        while (enumerator.moveNext())
                        {
                            numberSeq = enumerator.currentValue();
                            numberSeq.abort();
                        }
                    }
                }
            }
            else
            {
                throw error("@SYS24993");
            }
            ttsCommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostLegacy</Name>
				<Source><![CDATA[
    private void saveAndPostLegacy(TaxTrans   _taxTrans,
                     LedgerDimensionAccount _taxLedgerDimension,
                     LedgerDimensionAccount _useTaxPayableLedgerDimension,
                     CurrencyExchangeHelper _currencyExchangeHelper,
                     TaxAmountCur _taxCodeCurrencyAmount,
                     TaxAmount    _accountingTaxAmount,
                     TaxAmountCur _taxCodeTaxInCostPriceAmount,
                     TaxAmount    _accountingTaxInCostPrice,
                     TaxAmountCur _transactionTaxAmount)
    {
        AmountCur               taxAmountCur;
        AmountCur               taxInCostPriceCur;
        AmountMST               taxAmountMST;
        AmountMST               taxInCostPriceMST;
        CurrencyCode            currencyCode;
        LedgerDimensionAccount  useTaxPayableLedgerDimension;
        RefRecId                taxOffsetRecId;

        if (_taxTrans.CurrencyCode && _taxTrans.CurrencyCode != CompanyInfoHelper::standardCurrency())
        {
            currencyCode      = _taxTrans.CurrencyCode;
            taxAmountCur      = CurrencyExchangeHelper::amount(_taxCodeCurrencyAmount, currencyCode);
            taxInCostPriceCur = CurrencyExchangeHelper::amount(_taxCodeTaxInCostPriceAmount, currencyCode);
        }
        else
        {
            taxAmountCur      = CurrencyExchangeHelper::amount(_accountingTaxAmount);
            taxInCostPriceCur = CurrencyExchangeHelper::amount(_accountingTaxInCostPrice);
            currencyCode      = CompanyInfoHelper::standardCurrency();
        }

        taxAmountMST          =  CurrencyExchangeHelper::amount(_accountingTaxAmount);
        taxInCostPriceMST     =  CurrencyExchangeHelper::amount(_accountingTaxInCostPrice);

        if (_taxTrans.TaxDirection == TaxDirection::UseTax && !_useTaxPayableLedgerDimension)
        {
            useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(_taxTrans.TaxCode));
        }
        else
        {
            useTaxPayableLedgerDimension = _useTaxPayableLedgerDimension;
        }

        taxOffsetRecId = this.saveOffsetTaxTrans(_taxTrans);

        if (FBTaxAssessmentPost_BR::canPostTaxTrans(_taxTrans))
        {
            this.post(_taxTrans.TaxCode,
                      _taxTrans.TaxDirection,
                      _taxLedgerDimension,
                      useTaxPayableLedgerDimension,
                      currencyCode,
                      taxAmountCur * -1,
                      taxInCostPriceCur * -1,
                      taxAmountMST * -1,
                      _currencyExchangeHelper,
                      taxOffsetRecId,
                      taxInCostPriceMST * -1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostRetrieveAccountsAndAmounts</Name>
				<Source><![CDATA[
    private void saveAndPostRetrieveAccountsAndAmounts(TaxTrans   _taxTrans, CurrencyExchangeHelper _currencyExchangeHelper)
    {
        LedgerDimensionAccount taxLedgerDimension;
        LedgerDimensionAccount useTaxPayableLedgerDimension;
        AccountingDistribution accountingDistribution;
        RefRecId               taxTransOffsetRecId;
        TaxAmountCur           taxAmountCur, totalTaxAmountCur;
        TaxAmount              taxAmount, totalTaxAmount;
        TaxAmount              taxInCostPriceMST, totalTaxInCostPriceMST;
        TaxAmountCur           taxInCostPriceCur, totalTaxInCostPriceCur;
        TaxAmountCur           actualTransactionalTaxAmount, totalActualTransactionalTaxAmount;
        AllocationFactor       totalAllocationFactor;
        CurrencyCode           currencyCode;
        AmountMST              taxAmountMST;

        useTaxPayableLedgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(_taxTrans.RecId, TaxTransRelationshipType::UseTaxPayable);

        if (this.needCalculateICMSDifAmounts(_taxTrans))
        {
            this.calculateICMSDifAmounts(_taxTrans);
        }

        if (_taxTrans.SourceDocumentLine &&
            _taxTrans.TaxOrigin != TaxOrigin::Payment &&
            _taxTrans.TaxOrigin != TaxOrigin::TaxReversed &&
            _taxTrans.TaxOrigin != TaxOrigin::CashDisc)
        {
            taxTransOffsetRecId = this.saveOffsetTaxTrans(_taxTrans);

            boolean adjustRoundingDiff = false;
            currentRoundingDiff = 0;

            while select LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, SourceDocumentLine, RecId from accountingDistribution
                where accountingDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine &&
                   accountingDistribution.ReferenceRole  != AccountingDistributionReferenceRole::Reversing &&
                  (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax ||
                   accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance ||
                   // Exclusive to process the debit adjustment of ICMSDiff
                   (_taxTrans.taxTrans_BR().TaxType_BR == TaxType_BR::ICMSDiff
                     && (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable ||
                     accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance ||
                     accountingDistribution.MonetaryAmount == MonetaryAmount::TaxMeasureNonRecoverable)))
            {
                this.saveAndPostWithDistributions(_taxTrans,
                                           accountingDistribution,
                                           useTaxPayableLedgerDimension,
                                           _currencyExchangeHelper,
                                           taxTransOffsetRecId);

                adjustRoundingDiff = adjustRoundingDiff || accountingDistribution.TransactionCurrency != _taxTrans.CurrencyCode;
            }

            if (adjustRoundingDiff)
            {
                accRoundingDiff += currentRoundingDiff - _taxTrans.TaxAmount;
            }
        }
        else
        {
            // Legacy scenario where the original invoice was based on the source doucment framework.
            // we need to recalculate split the amounts from TaxTrans using the allocation factor from
            // the accounting distribution.

            if (_taxTrans.SourceDocumentLine)
            {
                taxTransOffsetRecId = this.saveOffsetTaxTrans(_taxTrans);

                while select LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, SourceDocumentLine, RecId, AllocationFactor from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine &&
                    accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                    (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax ||
                    accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance ||
                    // if US tax rules are on, the use tax expense is non-recoverable VAT.
                    // we need to find that record anyways so that the Use Tax Payable (the offset) can be backed out.
                    ((accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                        || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxMeasureNonRecoverable) &&
                    TaxParameters::find().PurchTaxOnOperations &&
                    _taxTrans.TaxDirection == TaxDirection::UseTax))
                {
                    taxAmountCur = _taxTrans.TaxAmountCur * accountingDistribution.AllocationFactor;
                    taxAmount = _taxTrans.TaxAmount * accountingDistribution.AllocationFactor;
                    taxInCostPriceMST = _taxTrans.TaxInCostPriceMST * accountingDistribution.AllocationFactor;
                    taxInCostPriceCur = _taxTrans.TaxInCostPriceCur * accountingDistribution.AllocationFactor;
                    actualTransactionalTaxAmount = _taxTrans.SourceRegulateAmountCur * accountingDistribution.AllocationFactor;

                    totalTaxAmountCur += taxAmountCur;
                    totalTaxAmount += taxAmount;
                    totalTaxInCostPriceMST += taxInCostPriceMST;
                    totalTaxInCostPriceCur += taxInCostPriceCur;
                    totalActualTransactionalTaxAmount += actualTransactionalTaxAmount;
                    totalAllocationFactor += accountingDistribution.AllocationFactor;

                    if (totalAllocationFactor == 1)  //add the difference caused by division and rounding to the last posting
                    {
                        taxAmountCur += _taxTrans.TaxAmountCur - totalTaxAmountCur;
                        taxAmount += _taxTrans.TaxAmount - totalTaxAmount;
                        taxInCostPriceMST += _taxTrans.TaxInCostPriceMST - totalTaxInCostPriceMST;
                        taxInCostPriceCur += _taxTrans.TaxInCostPriceCur - totalTaxInCostPriceCur;
                        actualTransactionalTaxAmount += _taxTrans.SourceRegulateAmountCur - actualTransactionalTaxAmount;
                    }

                    if (_taxTrans.CurrencyCode && _taxTrans.CurrencyCode != CompanyInfoHelper::standardCurrency())
                    {
                        currencyCode = _taxTrans.CurrencyCode;
                        taxAmountCur = CurrencyExchangeHelper::amount(taxAmountCur, currencyCode);
                        taxInCostPriceCur = CurrencyExchangeHelper::amount(taxInCostPriceCur, currencyCode);
                    }
                    else
                    {
                        taxAmountCur = CurrencyExchangeHelper::amount(taxAmount);
                        taxInCostPriceCur = CurrencyExchangeHelper::amount(totalTaxInCostPriceCur);
                        currencyCode = CompanyInfoHelper::standardCurrency();
                    }

                    taxAmountMST = CurrencyExchangeHelper::amount(taxAmount);

                    if (_taxTrans.TaxDirection == TaxDirection::UseTax && !useTaxPayableLedgerDimension)
                    {
                        useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(_taxTrans.TaxCode));
                    }

                    if (FBTaxAssessmentPost_BR::canPostTaxTrans(_taxTrans))
                    {
                        this.post(_taxTrans.TaxCode,
                                  _taxTrans.TaxDirection,
                                  accountingDistribution.LedgerDimension,
                                  useTaxPayableLedgerDimension,
                                  currencyCode,
                                  taxAmountCur * -1,
                                  taxInCostPriceCur * -1,
                                  taxAmountMST * -1,
                                  _currencyExchangeHelper,
                                  taxTransOffsetRecId);
                    }
                }
            }
            else
            {
                taxLedgerDimension = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(_taxTrans.RecId);

                if (taxLedgerDimension)
                {
                    this.saveAndPostLegacy(_taxTrans,
                                 taxLedgerDimension,
                                 useTaxPayableLedgerDimension,
                                 _currencyExchangeHelper,
                                 _taxTrans.TaxAmountCur,
                                 _taxTrans.TaxAmount,
                                 _taxTrans.TaxInCostPriceCur,
                                 _taxTrans.TaxInCostPriceMST,
                                 _taxTrans.SourceRegulateAmountCur);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostWithDistributions</Name>
				<Source><![CDATA[
    private void saveAndPostWithDistributions(TaxTrans _taxTrans, AccountingDistribution _accountingDistribution, LedgerDimensionAccount _useTaxPayableLedgerDimension, CurrencyExchangeHelper _currencyHelper, RefRecId _taxTransOffsetRecId)
    {
        TaxAmountCur                taxCodeCurrencyAmount;
        TaxAmount                   accountingTaxAmount;
        TaxAmount                   useTaxAccountingTaxAmount;
        LedgerDimensionAccount      useTaxPayableLedgerDimension;
        SourceDocumentLine          sourceDocumentLine;
        SourceDocumentLineItem      sourceDocumentLineItem;

        if (_taxTrans.TaxDirection == TaxDirection::UseTax && !_useTaxPayableLedgerDimension)
        {
            useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(_taxTrans.TaxCode));
        }
        else
        {
            useTaxPayableLedgerDimension = _useTaxPayableLedgerDimension;
        }

        sourceDocumentLine = SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine);
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);

        // transactional to accounting currency
        _currencyHelper.parmExchangeRate1(sourceDocumentLineItem.parmExchangeRate1());
        _currencyHelper.parmExchangeRate2(sourceDocumentLineItem.parmExchangeRate2());
        accountingTaxAmount = _currencyHelper.calculateTransactionToAccounting(_accountingDistribution.TransactionCurrency, _accountingDistribution.TransactionCurrencyAmount, true);

        currentRoundingDiff += accountingTaxAmount;

        if (_taxTrans.taxTrans_BR().TaxType_BR == TaxType_BR::ICMSDiff)
        {
            useTaxAccountingTaxAmount = _currencyHelper.calculateTransactionToAccounting(_accountingDistribution.TransactionCurrency, _taxTrans.TaxInCostPriceCur, true);
        }
        _currencyHelper.parmExchangeRate1(0);

        // accounting to tax code currency
        taxCodeCurrencyAmount = _currencyHelper.calculateAccountingToTransaction(_taxTrans.CurrencyCode, accountingTaxAmount, true);

        if (FBTaxAssessmentPost_BR::canPostTaxTrans(_taxTrans))
        {
            this.post(_taxTrans.TaxCode,
                      _taxTrans.TaxDirection,
                      _accountingDistribution.LedgerDimension,
                      useTaxPayableLedgerDimension,
                      CompanyInfoHelper::standardCurrency(),
                      (taxCodeCurrencyAmount - useTaxAccountingTaxAmount) * -1,
                      useTaxAccountingTaxAmount * -1,
                      accountingTaxAmount * -1,
                      _currencyHelper,
                      _taxTransOffsetRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOffsetTaxTrans</Name>
				<Source><![CDATA[
    private RecId saveOffsetTaxTrans(TaxTrans _taxTrans)
    {
        TaxTrans        taxTransOffsetTrans;

        ledgerVoucher = this.findLedgerVoucherByCompany(curext());

        taxTransOffsetTrans.clear();

        taxTransOffsetTrans.Voucher                 = ledgerVoucher.lastVoucher();
        taxTransOffsetTrans.TransDate               = transactionDate;
        taxTransOffsetTrans.Source                  = TaxModuleType::Tax;
        taxTransOffsetTrans.TaxCode                 = _taxTrans.TaxCode;
        taxTransOffsetTrans.TaxOrigin               = TaxOrigin::TaxReporting;
        taxTransOffsetTrans.TaxDirection            = _taxTrans.TaxDirection;
        taxTransOffsetTrans.TaxPeriod               = _taxTrans.TaxPeriod;
        taxTransOffsetTrans.CurrencyCode            = _taxTrans.CurrencyCode;
        taxTransOffsetTrans.TaxBaseAmountCur        = _taxTrans.TaxBaseAmountCur * -1;
        taxTransOffsetTrans.TaxAmountCur            = _taxTrans.TaxAmountCur * -1;
        taxTransOffsetTrans.TaxBaseAmount           = _taxTrans.TaxBaseAmount* -1;
        taxTransOffsetTrans.TaxBaseQty              = _taxTrans.TaxBaseQty * -1;
        taxTransOffsetTrans.TaxAmount               = CurrencyExchangeHelper::amount(_taxTrans.TaxAmount * -1);
        taxTransOffsetTrans.TaxInCostPrice          = _taxTrans.TaxInCostPrice * -1;
        taxTransOffsetTrans.TaxInCostPriceMST       = _taxTrans.TaxInCostPriceMST * -1;
        taxTransOffsetTrans.TaxInCostPriceCur       = _taxTrans.TaxInCostPriceCur * -1;
        taxTransOffsetTrans.SourceCurrencyCode      = CompanyInfoHelper::standardCurrency();
        taxTransOffsetTrans.SourceBaseAmountCur     = _taxTrans.TaxBaseAmount * -1;
        taxTransOffsetTrans.SourceTaxAmountCur      = CurrencyExchangeHelper::amount(_taxTrans.TaxAmount * -1);
        taxTransOffsetTrans.SourceRegulateAmountCur = CurrencyExchangeHelper::amount(_taxTrans.TaxAmount * -1);
        taxTransOffsetTrans.ExemptTax               = _taxTrans.ExemptTax;
        taxTransOffsetTrans.ExemptCode              = _taxTrans.ExemptCode;
        taxTransOffsetTrans.TaxValue                = _taxTrans.TaxValue;
        taxTransOffsetTrans.VATExemptPct            = _taxTrans.VATExemptPct;
        taxTransOffsetTrans.PrintCode               = _taxTrans.PrintCode;

        taxTransOffsetTrans.insertTaxReporting(fromDate);

        return taxTransOffsetTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOffsetTaxWithholdTrans</Name>
				<Source><![CDATA[
    private RecId saveOffsetTaxWithholdTrans(TaxWithholdTrans _taxWithholdTrans, AmountMST _taxAmount)
    {
        TaxWithholdTrans    offsetTaxWithholdTrans;

        offsetTaxWithholdTrans.clear();

        offsetTaxWithholdTrans.Voucher                  = LedgerVoucher.lastVoucher();
        offsetTaxWithholdTrans.TransDate                = transactionDate;
        offsetTaxWithholdTrans.CompetenceDate           = transactionDate;
        offsetTaxWithholdTrans.Source_BR                = TaxWithholdSource::WithholdTax;
        offsetTaxWithholdTrans.TaxWithholdCode          = _taxWithholdTrans.TaxWithholdCode;
        offsetTaxWithholdTrans.TaxWithholdBaseAmount    = _taxWithholdTrans.TaxWithholdBaseAmount * -1;
        offsetTaxWithholdTrans.TaxWithholdAmount        = _taxAmount * -1;
        offsetTaxWithholdTrans.TaxExemptedAmount        = _taxWithholdTrans.TaxExemptedAmount;
        offsetTaxWithholdTrans.TaxWithholdCurrency      = _taxWithholdTrans.TaxWithholdCurrency;
        offsetTaxWithholdTrans.TaxWithholdPeriod_BR     = _taxWithholdTrans.TaxWithholdPeriod_BR;
        offsetTaxWithholdTrans.TaxWithholdGroup         = _taxWithholdTrans.TaxWithholdGroup;

        offsetTaxWithholdTrans.insert();

        return offsetTaxWithholdTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleOtherAmounts</Name>
				<Source><![CDATA[
    private TaxAmount settleOtherAmounts(DimensionDefault _defaultDimension, TaxAmount _taxAmount)
    {
        LedgerDimensionDefaultAccount   pennyDiffDefaultAccount;
        LedgerDimensionAccount          pennyDiffDimAccount;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        TaxAmount                       taxAmountRoundDiff;
        CurrencyExchangeHelper          currencyExchangeHelper;

        taxAmountRoundDiff = taxAuthority.roundOffTaxAmount(_taxAmount) - _taxAmount;

        if (taxAmountRoundDiff)
        {
            pennyDiffDefaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::VATRoundOff);

            if (!pennyDiffDefaultAccount)
                throw error (strFmt("@SYS66102", LedgerPostingType::VATRoundOff));

            pennyDiffDimAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(pennyDiffDefaultAccount, _defaultDimension);

            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                            ledgerVoucher.findLedgerVoucherObject(),
                                            LedgerPostingType::VATRoundOff,
                                            pennyDiffDimAccount,
                                            Ledger::accountingCurrency(),
                                           -taxAmountRoundDiff,
                                            currencyExchangeHelper);

            ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        return taxAmountRoundDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessTaxTrans</Name>
				<Source><![CDATA[
    private boolean shouldProcessTaxTrans(TaxTrans_BR taxTransBR)
    {
        FiscalDocumentTaxTrans_BR   fiscalDocumentTaxTrans;
        FBTaxTrans_BR               fbTaxTrans;

        if (taxAssessment.TaxType == TaxType_BR::ICMS && taxTransBR.TaxType_BR == TaxType_BR::ICMSDiff)
        {
            select RecId from fiscalDocumentTaxTrans
                where fiscalDocumentTaxTrans.TaxTrans == taxTransBR.TaxTrans
                exists join fbTaxTrans
                    where fbTaxTrans.FiscalDocumentTaxTrans_BR == fiscalDocumentTaxTrans.RecId
                          && fbTaxTrans.FBTaxAssessment_BR == taxAssessment.RecId;

            return fiscalDocumentTaxTrans.RecId != 0;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList] = packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPost</Name>
				<Source><![CDATA[
    private Counter updateAndPost()
    {
        Counter                 transactionsInTax;

        transactionsInTax = this.processTaxTransByTaxCode();

        if (hasWithholdingTaxes)
        {
            transactionsInTax += this.processTaxWithholdTransByTaxCode();
        }

        this.revertBalanceFromPreviousPeriod();

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the ledger or the vendor transactions and inserts a record in the TaxReportVoucher table.
    /// </summary>
    private void updateNow()
    {
        FiscalOrganization_BR           fiscalOrganization;
        FBBookingPeriod_BR              fbBookingPeriod;
        FiscalEstablishment_BR          branchFiscalEstablishment;
        MapEnumerator                   enumerator;

        transactions    = 0;
        taxTransactions = 0;

        if (taxAssessmentPayment)
        {
            taxAuthority = TaxAuthorityAddress::find(taxAssessmentPayment.TaxAuthority);
            vendAccount = taxAuthority.AccountNum;
        }

        // PIS/COFINS tax assessment: root fiscal establishment and branches must be processed
        if (isIntercompany)
        {
            fbBookingPeriod     = taxAssessment.bookingPeriod();
            fiscalOrganization  = FiscalOrganization_BR::findByFiscalEstablishmentId(fbBookingPeriod.FiscalEstablishmentId, fbBookingPeriod.FiscalEstablishmentDataArea);

            while select crossCompany branchFiscalEstablishment
                where   branchFiscalEstablishment.FiscalOrganization_BR == fiscalOrganization.RecId
            {
                changeCompany (branchFiscalEstablishment.dataAreaId)
                {
                    ledgerVoucher               = this.findLedgerVoucherByCompany(curext());
                    currentFiscalEstablishment  = branchFiscalEstablishment;
                    taxTransactions             += this.updateAndPost();
                }
            }
        }
        else
        {
            // Other taxes: only the fiscal establishment related to the tax assessment is processed
            ledgerVoucher               = this.findLedgerVoucherByCompany(curext());
            currentFiscalEstablishment  = taxAssessment.bookingPeriod().fiscalEstablishment();
            taxTransactions             += this.updateAndPost();
        }

        if (transactions > 0)
        {
            ledgerVoucher               = this.findLedgerVoucherByCompany(curext());
            currentFiscalEstablishment  = taxAssessment.bookingPeriod().fiscalEstablishment();

            if (taxAssessmentPayment.RecId == 0)
            {
                // Closing tax assessment scenario
                this.postCreditTaxTrans();
                this.updateTaxAssessment(totalClearingTaxTransAmount + totalClearingWhtAmount);
            }
            else
            {
                // Tax payment scenario
                this.postVendVoucher();
                this.updatePayment(totalClearingTaxTransAmount + totalClearingWhtAmount);
            }
        }
        else
        {
            warning("@SYS62090");
        }

        ledgerVoucherGroup.end();

        if (transactions > 0 )
        {
            enumerator = ledgerVoucherGroup.getInternalCollection().getEnumerator();

            while (enumerator.moveNext())
            {
                ledgerVoucher = enumerator.currentValue();
                info(strFmt("@SYS9799", ledgerVoucher.lastVoucher()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFiscalLedgerAmountsPayment</Name>
				<Source><![CDATA[
    private void validateFiscalLedgerAmountsPayment(
        TaxAmount _taxAmountMST,
        FBTaxAssessmentPayment_BR _taxAssessmentPayment,
        AmountMST _salesTaxExpense,
        AmountMST _accRoundingDiff
    )
    {
        AmountMST calculatedAmount = abs(_taxAmountMST) + _salesTaxExpense + _accRoundingDiff;
        AmountMST difference = abs(_taxAssessmentPayment.TaxAmountToPay - calculatedAmount);
        
        if (difference > roundingDifferenceThreshold && _taxAssessmentPayment.TaxAmountToPay != calculatedAmount)
        {
            throw error(strFmt("@FBK4520006", _taxAssessmentPayment.TaxAmountToPay, abs(_taxAmountMST), difference));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePayment</Name>
				<Source><![CDATA[
    private void updatePayment(TaxAmount _taxAmountMST)
    {
        FBTaxAssessmentPayment_BR               taxAssessmentPaymentLocal;
        AmountMST                               salesTaxExpense;
        FBTaxAssessmentCalculatorPISCOFINS_BR   fbTaxAssessmentCalculatorPisCofins;

        if (!taxAssessmentPayment.RecId)
        {
            return;
        }

        ledgerVoucher = this.findLedgerVoucherByCompany(curext());

        select forUpdate taxAssessmentPaymentLocal
            where taxAssessmentPaymentLocal.RecId == taxAssessmentPayment.RecId;

        taxAssessmentPaymentLocal.selectForUpdate(true);
        taxAssessmentPaymentLocal.Voucher = ledgerVoucher.lastVoucher();
        taxAssessmentPaymentLocal.update() ;

        taxAssessmentPayment.data(taxAssessmentPaymentLocal);

        if (taxAssessmentPayment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::NonCumulative)
        {
            fbTaxAssessmentCalculatorPisCofins  = calculator as FBTaxAssessmentCalculatorPISCOFINS_BR;
            salesTaxExpense = fbTaxAssessmentCalculatorPisCofins.getSalesTaxExpense();
        }

        this.validateFiscalLedgerAmountsPayment(_taxAmountMST, taxAssessmentPayment, salesTaxExpense, accRoundingDiff);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFiscalLedgerAmountsAssessment</Name>
				<Source><![CDATA[
    private void validateFiscalLedgerAmountsAssessment(AmountMST _creditBalanceAmount, AmountMST _taxAmount)
    {
        AmountMST difference = abs(_creditBalanceAmount) - abs(_taxAmount);

        if (abs(difference) > roundingDifferenceThreshold)
        {
            throw error(strFmt("@FBK4520009",
                    abs(_creditBalanceAmount),
                    abs(_taxAmount),
                    difference));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxAssessment</Name>
				<Source><![CDATA[
    private void updateTaxAssessment(TaxAmount _taxAmountMST)
    {
        FBTaxAssessment_BR                      taxAssessmentLocal;
        AmountMST                               creditBalanceAmount;
        FBTaxAssessmentCalculatorPISCOFINS_BR   fbTaxAssessmentCalculatorPisCofins;
        FBTaxAssessmentPayment_BR               taxPaymentNonCumulative;

        if (taxAssessmentPayment.RecId)
        {
            return;
        }

        if (hasWithholdingTaxes)
        {
            fbTaxAssessmentCalculatorPisCofins = calculator as FBTaxAssessmentCalculatorPISCOFINS_BR;

            creditBalanceAmount = calculator.getCreditBalanceExclOtherDebitAdj()
                                + fbTaxAssessmentCalculatorPisCofins.getWhtAvailableForNextPeriodByRegimen(taxAssessment.ContribAssessmentRegimen);

            // Verify if it is necessary to add the credit that can not be used (because of the proportional appropriation method)
            taxPaymentNonCumulative = FBTaxAssessmentPayment_BR::findByTaxAssessmentContribRegimen(taxAssessment.RecId, FBContribAssessmentRegimen_BR::NonCumulative);

            if (    taxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::NonCumulative
                || (taxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::Both
                && !taxPaymentNonCumulative))
            {
                creditBalanceAmount += fbTaxAssessmentCalculatorPisCofins.getSalesTaxExpense();
            }
        }
        else
        {
            creditBalanceAmount = calculator.getCreditBalanceExclOtherDebitAdj();
        }

        this.validateFiscalLedgerAmountsAssessment(creditBalanceAmount, _taxAmountMST);

        ledgerVoucher = this.findLedgerVoucherByCompany(curext());

        select forUpdate taxAssessmentLocal
            where taxAssessmentLocal.RecId == taxAssessment.RecId;

        taxAssessmentLocal.VoucherDataArea  = fiscalEstablishmentDataArea;
        taxAssessmentLocal.VoucherTransDate = transactionDate;
        taxAssessmentLocal.Voucher          = ledgerVoucher.lastVoucher();
        taxAssessmentLocal.update();

        taxAssessment.data(taxAssessmentLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPreventCloseAssessment</Name>
				<Source><![CDATA[
    protected boolean isPreventCloseAssessment()
    {
        boolean debitBalanceDue = calculator.getOpenOtherDebitAmountToPay() > 0 || calculator.getOpenPeriodicAssessmentAmountToPay() > 0;
        
        if (debitBalanceDue && taxAssessment.TaxType == TaxType_BR::ICMS)
        {
            // if an ICMS assessment and we have a balance due on debit, check if we have a credit balance. If no balance, do not prevent closing the assessment
            return calculator.getCreditBalanceAtEndOfThePeriod() > 0;
        }
        else
        {
            return debitBalanceDue;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBeforePost</Name>
				<Source><![CDATA[
    private void validateBeforePost()
    {
        TaxAuthorityAddress                     taxAuthorityAddress;
        boolean                                 ok = true;
        FBTaxAssessmentCalculatorPISCOFINS_BR   calculatorPisCofins;
        FiscalOrganization_BR                   fiscalOrganization;

        calculator = FBTaxAssessmentCalculator_BR::construct(taxAssessment);
        calculator.calculate();

        if (taxAssessmentPayment)
        {
            taxAuthorityAddress = TaxAuthorityAddress::find(taxAssessmentPayment.TaxAuthority);

            if (!taxAuthorityAddress)
            {
                ok = checkFailed(strFmt("@SYS26332", fieldId2name(tableNum(FBTaxAssessmentPayment_BR),fieldNum(FBTaxAssessmentPayment_BR,TaxAuthority))));
            }
            else
            {
                if (!taxAuthorityAddress.AccountNum)
                {
                    ok = checkFailed(strFmt("@FBK4520030", taxAuthorityAddress.TaxAuthority));
                }
            }

            if (taxAssessmentPayment.ContribAssessmentRegimen != FBContribAssessmentRegimen_BR::Cumulative
                && taxAssessmentPayment.PaymentType == FBTaxAssessmentPaymentType_BR::Periodic && calculator.getCreditBalanceAtEndOfThePeriod())
            {
                ok = checkFailed("@FBK303");
            }

            if (strLen(taxAssessmentPayment.RevenueCode) == 0)
            {
                ok = checkFailed(strFmt("@SYS26332", fieldId2name(tableNum(FBTaxAssessmentPayment_BR), fieldNum(FBTaxAssessmentPayment_BR, RevenueCode))));
            }
        }
        else
        {
            if (this.isPreventCloseAssessment())
            {
                ok = checkFailed("@Brazil:FBTaxAssessmentPaymentNotPosted");
            }
        }

        if (taxAssessment.ContribAssessmentRegimen != FBContribAssessmentRegimen_BR::Both
            && calculator.getTotalPeriodicAssessmentAmountPaid() > 0 && calculator.getCreditBalanceAtEndOfThePeriod())
        {
            ok = checkFailed("@FBK4520005");
        }

        if (taxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::Both)
        {
            calculatorPisCofins = calculator as FBTaxAssessmentCalculatorPISCOFINS_BR;

            if (calculatorPisCofins.getSalesTaxExpense() > 0)
            {
                fiscalOrganization = FiscalOrganization_BR::findByFiscalEstablishmentId(taxAssessment.bookingPeriod().FiscalEstablishmentId, taxAssessment.bookingPeriod().FiscalEstablishmentDataArea);

                if (fiscalOrganization && !fiscalOrganization.getSalesTaxExpenseAccountByTaxType(taxAssessment.TaxType))
                {
                    ok = checkFailed(strFmt("@SYS26332", taxAssessment.TaxType == TaxType_BR::PIS ? "@SYP4882729" : "@SYP4882727"));
                }
            }
        }

        if (ok == false)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTaxTrans</Name>
				<Source><![CDATA[
    static private boolean canPostTaxTrans(TaxTrans   _taxTrans)
    {
        boolean canPost = true;

        if (_taxTrans.TaxDirection == TaxDirection::TaxExemptPurchase ||
            _taxTrans.TaxDirection == TaxDirection::TaxExemptSales    ||
            (_taxTrans.TaxDirection == TaxDirection::TaxTransaction
                // handles tax fiscal document that produces TaxDirection::TaxTransaction and TaxModuleType::Sales
                && _taxTrans.Source != TaxModuleType::Sales) )
        {
            canPost = false;
        }
        // handles ISS
        // retained tax from sales are not processed by tax assessment because they are considered expenses
        // recoverable tax from purchase invoices are not processed by tax assessment because the business scenario not exists
        else if (_taxTrans.taxTrans_BR().TaxType_BR == TaxType_BR::ISS
                    && _taxTrans.TaxDirection == TaxDirection::IncomingTax)
        {
            canPost = false;
        }

        return canPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeTaxAssessment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Closes the tax assessment and post the result to the general ledger
    /// </summary>
    /// <param name="_taxAssessment">
    ///     The tax assessment to close
    /// </param>

    public static void closeTaxAssessment(FBTaxAssessment_BR _taxAssessment)
    {
        XppILExecutePermission          xppILExecutePermission;
        FBTaxAssessmentPost_BR          taxPayment;

        taxPayment = new FBTaxAssessmentPost_BR();
        taxPayment.parmTaxAssessment(_taxAssessment);
        taxPayment.runOperation();

        if (FormDataUtil::isFormDataSource(_taxAssessment))
        {
            FormDataUtil::getFormDataSource(_taxAssessment).reread();
            FormDataUtil::getFormDataSource(_taxAssessment).refreshEx();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTaxableAmount</Name>
				<Source><![CDATA[
    private static boolean hasTaxableAmount(TaxTrans _taxTrans)
    {
        return _taxTrans.TaxAmountCur      ||
               _taxTrans.TaxBaseQty        ||
               _taxTrans.TaxBaseAmount     ||
               _taxTrans.TaxBaseAmountCur  ||
               _taxTrans.TaxInCostPrice    ||
               _taxTrans.TaxInCostPriceMST ||
               _taxTrans.TaxInCostPriceCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts a tax assessment payment to the general ledger
    /// </summary>
    /// <param name="_payment">
    ///     The payment post
    /// </param>

    public static void postPayment(FBTaxAssessmentPayment_BR _payment)
    {
        XppILExecutePermission          xppILExecutePermission;
        FBTaxAssessmentPost_BR          taxPayment;

        taxPayment = new FBTaxAssessmentPost_BR();
        taxPayment.parmTaxAssessment(FBTaxAssessment_BR::find(_payment.FBTaxAssessment_BR));
        taxPayment.parmTaxPayment(_payment);

        taxPayment.runOperation();

        if (FormDataUtil::isFormDataSource(_payment))
        {
            FormDataUtil::getFormDataSource(_payment).reread();
            FormDataUtil::getFormDataSource(_payment).refreshEx();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransactionReversalUpdateOriginal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The post event handler of the method ReversalUpdateOriginal for the class <c>TransactionReversal</c>
    /// </summary>
    /// <param name="_args">
    ///     The <c>XppPrePostArgs</c> object
    /// </param>
    [PostHandlerFor(classStr(TransactionReversal), methodStr(TransactionReversal, updateOriginal))]
    public static void postTransactionReversalUpdateOriginal(XppPrePostArgs _args)
    {
        TransactionReversal transactionReversal;
        FBTaxAssessmentPayment_BR taxAssessmentPayment;
        Voucher voucher;
        TransDate transDate;
        boolean revoke;

        transactionReversal = _args.getThis();

        revoke = transactionReversal.parmRevoke();

        voucher = _args.getArg('_voucher');
        transDate = _args.getArg('_transDate');

        while select RecId from taxAssessmentPayment
            where taxAssessmentPayment.TransDate == transDate
                && taxAssessmentPayment.Voucher   == voucher
        {
            TransactionReversalTrans::updateOriginal(tablenum(FBTaxAssessmentPayment_BR), taxAssessmentPayment.RecId, !revoke);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransactionReversalUpdateTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The post event handler of the method ReversalUpdateTaxTrans for the class <c>TransactionReversal</c>
    /// </summary>
    /// <param name="_args">
    ///     The <c>XppPrePostArgs</c> object
    /// </param>
    [PostHandlerFor(classStr(TransactionReversal), methodStr(TransactionReversal, updateTaxTrans))]
    public static void postTransactionReversalUpdateTaxTrans(XppPrePostArgs _args)
    {
        TransactionReversal transactionReversal;
        FBTaxAssessmentPayment_BR taxAssessmentPayment, taxAssessmentPaymentLocal;
        FBTaxAssessment_BR taxAssessment;
        Voucher voucher;
        TransDate transDate;
        TraceNum reversalTraceNum;
        Voucher reversalVoucher;
        TransDate reversalDate;
        FBTaxTrans_BR fbTaxTrans;
        FBTaxTransTaxAssessmentPayment_BR fbTaxTransTaxAssessmentPayment;

        transactionReversal = _args.getThis();

        reversalTraceNum = transactionReversal.parmReversalTraceNum();
        reversalVoucher = transactionReversal.parmReversalVoucher();
        reversalDate = transactionReversal.parmReversalDate();

        voucher = _args.getArg('_voucher');
        transDate = _args.getArg('_transDate');

        while select forupdate taxAssessmentPayment
         where taxAssessmentPayment.TransDate  == transDate
             && taxAssessmentPayment.Voucher   == voucher
             && taxAssessmentPayment.TaxAuthorityDataArea == curext()
        {
            taxAssessmentPayment.Reversed  = true;
            taxAssessmentPayment.TraceNum  = reversalTraceNum;
            taxAssessmentPayment.update();

            update_recordSet fbTaxTrans
                setting Voucher = '', VoucherDataArea = '', VoucherTransDate = dateNull()
                exists join fbTaxTransTaxAssessmentPayment
                where   fbTaxTransTaxAssessmentPayment.FBTaxTrans_BR == fbTaxTrans.RecId
                    &&  fbTaxTransTaxAssessmentPayment.FBTaxAssessmentPayment_BR == taxAssessmentPayment.RecId
                    && (fbTaxTrans.Classification       == FBTaxAssessmentClassification_BR::CreditBalanceFromPreviousPeriod
                    || fbTaxTrans.Classification        == FBTaxAssessmentClassification_BR::CumulativeWhtFromPreviousPeriod
                    || fbTaxTrans.Classification        == FBTaxAssessmentClassification_BR::NonCumulativeWhtFromPreviousPeriod);

            delete_from fbTaxTransTaxAssessmentPayment
                where fbTaxTransTaxAssessmentPayment.FBTaxAssessmentPayment_BR == taxAssessmentPayment.RecId;

            taxAssessmentPaymentLocal           = taxAssessmentPayment.data();
            taxAssessmentPaymentLocal.Voucher   = reversalVoucher;
            taxAssessmentPaymentLocal.TransDate = reversalDate;
            taxAssessmentPaymentLocal.Reversed  = true;
            taxAssessmentPaymentLocal.TraceNum  = reversalTraceNum;
            taxAssessmentPaymentLocal.insert();

            TransactionReversalTrans::createTransaction(tablenum(FBTaxAssessmentPayment_BR),taxAssessmentPayment.RecId, reversalTraceNum);
            TransactionReversalTrans::createTransaction(tablenum(FBTaxAssessmentPayment_BR),taxAssessmentPayment.RecId, reversalTraceNum);
        }

        select forUpdate taxAssessment
            where taxAssessment.Voucher == voucher
                && taxAssessment.VoucherTransDate == transDate
                && taxAssessment.VoucherDataArea == curext();

        taxAssessment.voucher = '';
        taxAssessment.VoucherTransDate = dateNull();
        taxAssessment.VoucherDataArea = '';

        TransactionReversalTrans::createTransaction(tablenum(FBTaxAssessment_BR),taxAssessment.RecId, reversalTraceNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxAssessmentClosing</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reverses the tax assessment ledger posting
    /// </summary>
    /// <param name="_taxAssessment">
    ///     The tax assessment to reverse
    /// </param>
    public static void reverseTaxAssessmentClosing(FBTaxAssessment_BR _taxAssessment)
    {
        TransactionReversal_Ledger  transactionReversal;
        GeneralJournalAccountEntry  generalJournalAccountEntry;
        GeneralJournalEntry         generalJournalEntry;
        LedgerVoucher               ledgerVoucher;
        FBTaxTrans_BR               fbTaxTrans;

        select firstOnly generalJournalAccountEntry
            join SubledgerVoucher, AccountingDate from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.SubledgerVoucher == _taxAssessment.Voucher
                    && generalJournalEntry.AccountingDate == _taxAssessment.VoucherTransDate;

        if (generalJournalAccountEntry)
        {
            ttsbegin;
            transactionReversal = TransactionReversal_Ledger::construct();

            transactionReversal.parmReversalDate(_taxAssessment.ToDate);
            transactionReversal.parmSysModule(SysModule::Ledger);
            ledgerVoucher = transactionReversal.initLedgerVoucher();

            transactionReversal.createGeneralJournal(
                generalJournalEntry.SubledgerVoucher,
                generalJournalEntry.AccountingDate,
                ledgerVoucher);

            ledgerVoucher.end();

            transactionReversal.postReversal();

            TransactionLog::create(TransactionLogType::TransactionReversal, "@SYS88953");

            _taxAssessment.Voucher = '';
            _taxAssessment.VoucherTransDate = dateNull();
            _taxAssessment.VoucherDataArea = '';
            _taxAssessment.update();

            update_recordSet fbTaxTrans
                setting Voucher = '', VoucherDataArea = '', VoucherTransDate = dateNull()
                where   fbTaxTrans.FBTaxAssessment_BR   == _taxAssessment.RecId
                    && (fbTaxTrans.Classification       == FBTaxAssessmentClassification_BR::CreditBalanceFromPreviousPeriod
                        || fbTaxTrans.Classification       == FBTaxAssessmentClassification_BR::CumulativeWhtFromPreviousPeriod
                        || fbTaxTrans.Classification       == FBTaxAssessmentClassification_BR::NonCumulativeWhtFromPreviousPeriod);

            delete_from fbTaxTrans
                where   fbTaxTrans.FBTaxAssessment_BR   == _taxAssessment.RecId
                    &&  fbTaxTrans.Classification       == FBTaxAssessmentClassification_BR::CreditBalanceToTransport;

            ttscommit;
        }

        if (FormDataUtil::isFormDataSource(_taxAssessment))
        {
            FormDataUtil::getFormDataSource(_taxAssessment).reread();
            FormDataUtil::getFormDataSource(_taxAssessment).refreshEx();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxReportDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the due date of the tax payment
    /// </summary>
    /// <param name="_taxAssessment">
    /// The tax assessment record
    /// </param>
    /// <param name="_taxPayment">
    /// The tax payment record
    /// </param>
    /// <returns>
    /// The calculated due date
    /// </returns>

    public static TransDate taxReportDate(FBTaxAssessment_BR _taxAssessment,
                                           FBTaxAssessmentPayment_BR _taxPayment)
    {
        TransDate   taxDate;
        PaymTermId  paymTermId;
        ;
        paymTermid = _taxPayment.PaymentTermId;

        taxDate  = _taxAssessment.toDate;

        if (! taxDate)
            return dateNull();
        taxDate  = PaymTerm::advanceDate(paymTermId, taxDate);

        if (! taxDate)
            taxDate  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        return taxDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onTaxAssessmentUpdateStatus</Name>
				<Source><![CDATA[
    [SubscribesTo(tableStr(FBTaxAssessment_BR), delegateStr(FBTaxAssessment_BR, statusUpdatedDelegate))]
    public static void onTaxAssessmentUpdateStatus(FBTaxAssessment_BR _taxAssessment)
    {
        if (BrazilParameters::isFBLedgerIntegrationActivated() && FBTaxAssessmentPost_BR::paymentLedgerIntegrationEnabled(_taxAssessment))
        {
            if (_taxAssessment.Status == FBTaxAssessmentStatus_BR::Closed)
            {
                FBTaxAssessmentPost_BR::closeTaxAssessment(_taxAssessment);
            }

            if (_taxAssessment.Status == FBTaxAssessmentStatus_BR::Opened)
            {
                FBTaxAssessmentPost_BR::reverseTaxAssessmentClosing(_taxAssessment);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentLedgerIntegrationEnabled</Name>
				<Source><![CDATA[
    private static boolean paymentLedgerIntegrationEnabled(FBTaxAssessment_BR _taxAssessment)
    {
        switch (_taxAssessment.TaxType)
        {
            case TaxType_BR::ICMS :
            case TaxType_BR::ICMSST:
            case TaxType_BR::ICMSDiff:
            case TaxType_BR::IPI :
            case TaxType_BR::ISS :
            case TaxType_BR::PIS:
            case TaxType_BR::COFINS:
                return true;

            default : return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needCalculateICMSDifAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether ICMS-Diff amounts should be calculated.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>True, if ICMS-Diff amounts should be calculated, otherwise - false.</returns>
    private boolean needCalculateICMSDifAmounts(TaxTrans _taxTrans)
    {
        return taxAssessment.TaxType == TaxType_BR::ICMSDiff
                && _taxTrans.TaxOrigin == TaxOrigin::Tax
                && _taxTrans.taxTrans_BR().TaxType_BR == TaxType_BR::ICMSDiff;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>