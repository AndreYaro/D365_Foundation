<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjBudgetManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>ProjBudgetManager</c> class is used to perform budget commitment, amendment and allocation
///    of the project budget.
/// </summary>
class ProjBudgetManager extends RunBase
{
    #Define.RetryNum(3)
    #Define.Star("*")
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canImportRevenueBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// return value that indicates whether or not current project type allow import revenue budget
    /// </summary>
    /// <param name="_projType">
    /// A <c>ProjType</c> value that determines project type
    /// </param>
    /// <returns>
    /// true if current project type allow import revenue budget; otherwise, false.
    /// </returns>
    protected boolean canImportRevenueBudget(ProjType _projType)
    {
        return _projType == ProjType::TimeMaterial || _projType == ProjType::FixedPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canImportRevenueBudgetV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether we can import revenue budget for a project.
    /// </summary>
    /// <param name = "_projTable">The project record.</param>
    /// <returns>
    /// true if revenue budget can be imported; otherwise, false.
    /// </returns>
    protected boolean canImportRevenueBudgetV2(ProjTable _projTable)
    {
        boolean ret = false;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            if (_projTable.ProjInvoiceProjId)
            {
                ret = true;
            }
        }
        else
        {
            ret = this.canImportRevenueBudget(_projTable.Type);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the specified transaction currency has a budget exchange rate.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The company master currency.
    /// </param>
    /// <param name="_projTrans">
    ///    A <c>ProjTrans</c> value that determines which transaction has to be validated.
    /// </param>
    /// <returns>
    ///    true if the specified exchange rate of the currency budget exists; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    An exception is thrown if the budget exchange rate does not exist.
    /// </exception>
    private boolean checkExchangeRate(CurrencyCode _currencyCode,ProjTrans _projTrans)
    {
        boolean                 result;
        ExchRate                validationRate;
        ExchangeRateHelper      rateValidationHelper;

        if (_currencyCode != _projTrans.currencyIdSales())
        {
            rateValidationHelper = ExchangeRateHelper::newExchangeDate(Ledger::current(), _projTrans.currencyIdSales(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            rateValidationHelper.parmExchangeRateTypeRecId(Ledger::budgetExchangeRateType());
            rateValidationHelper.parmErrorType(AifErrorType::None);

            validationRate = rateValidationHelper.getCrossRate();

            if (validationRate == 0)
            {
                throw error(strFmt("@SYS301758",(_projTrans.currencyIdSales())));
            }
            else
            {
                result = true;
            }
        }
        else
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllocationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the allocation lines of specified project budget revision.
    /// </summary>
    /// <param name="_isHourCosts">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on an hour cost
    /// budget line.
    /// </param>
    /// <param name="_isExpenseCosts">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on an expense cost
    /// budget line.
    /// </param>
    /// <param name="_isItemCosts">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on an item cost
    /// budget line.
    /// </param>
    /// <param name="_isFees">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on a fee budget
    /// line.
    /// </param>
    /// <param name="_isHourRevenues">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on an hour revenue
    /// budget line.
    /// </param>
    /// <param name="_isExpenseRevenues">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on an expense
    /// revenue budget line.
    /// </param>
    /// <param name="_isItemRevenues">
    /// A <c>NoYes</c> type value that determines whether allocation should be performed on an item revenue
    /// budget line.
    /// </param>
    /// <param name="_isFromDate">
    /// A <c>TransDate</c> type value that determines the from date of allocation.
    /// </param>
    /// <param name="_isToDate">
    /// A <c>TransDate</c> type value that determines the to date of allocation.
    /// </param>
    /// <param name="_common">
    /// A <c>ProjBudget</c> or <c>ProjBudgetRevision</c> table buffer.
    /// </param>
    /// <param name="_projAllocationMethod">
    /// A <c>ProjAllocationMethod</c> type value that determines that allocation method that is used for
    /// allocation.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The allocation start date did not have lies in any fiscal period.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The allocation end date did not have lies in any fiscal period.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The allocation start date did not have lies in any fiscal year.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The allocation end date did not have lies in any fiscal year.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// A cancel update error message will show if an error occurred when the allocation line was created.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    /// An error throws when updating the record which creates conflict and is not recoverable.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    /// An error throw when update conflict is occurred.
    /// </exception>
    public void createAllocationLine(NoYes _isHourCosts, NoYes _isExpenseCosts,
                                 NoYes _isItemCosts, NoYes _isFees, NoYes _isHourRevenues,
                                 NoYes _isExpenseRevenues, NoYes _isItemRevenues, TransDate _isFromDate,
                                 TransDate _isToDate, Common _common, ProjAllocationMethod _projAllocationMethod)
    {
        TransDate               allocationStartDate;
        TransDate               allocationEndDate;
        TransDate               allocationStartYearDate;
        TransDate               allocationEndYearDate;
        ProjBudget              projBudget;
        ProjBudgetRevision      projBudgetRevision;
        ProjBudgetLine          projBudgetLine;
        ProjBudgetRevisionLine  projBudgetRevisionLine;

        FiscalCalendarYear      fiscalCalendarYear;
        FiscalCalendarPeriod    fiscalCalendarPeriod;

        RecId                   fiscalCalendar;
        ProjAllocationMethod    projAllocationMethod;
        boolean                 previousAllocationExists;
        boolean                 isBudgetAllocation;
        container               previousAllocation;

        switch (_common.TableId)
        {
            case tableNum(ProjBudget) :
                projBudget = _common;
                isBudgetAllocation = true;
                break;
            case tableNum(ProjBudgetRevision) :
                projBudgetRevision = _common;
                break;
        }

        fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());

        //Finding the start date of the period in which contains allocation start date.
        select RecId,FiscalCalendar from fiscalCalendarYear
    where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
        join StartDate from fiscalCalendarPeriod
        where fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId
          && (fiscalCalendarPeriod.StartDate          <= _isFromDate
          &&  fiscalCalendarPeriod.EndDate            >= _isFromDate);

        if (fiscalCalendarPeriod)
        {
            allocationStartDate = fiscalCalendarPeriod.StartDate;
        }
        else
        {
            throw error("@SYS301636");
        }

        // Finding the end date of the period in which contains allocation end date.
        select RecId from fiscalCalendarYear
    where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
        join EndDate from fiscalCalendarPeriod
        where fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId
          && (fiscalCalendarPeriod.StartDate          <= _isToDate
          &&  fiscalCalendarPeriod.EndDate            >= _isToDate);

        if (fiscalCalendarPeriod)
        {
            allocationEndDate = fiscalCalendarPeriod.EndDate;
        }
        else
        {
            throw error("@SYS301636");
        }

        // Finding the start date of the year in which contains allocation start date.
        while select StartDate from fiscalCalendarYear
    where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
      && (fiscalCalendarYear.StartDate      <= _isFromDate
      &&  fiscalCalendarYear.EndDate        >= _isFromDate)
        {
            if (fiscalCalendarYear)
            {
                allocationStartYearDate = fiscalCalendarYear.StartDate;
            }
            else
            {
                throw error("@SYS301636");
            }
        }

        // Finding the end date of the year in which contains allocation end date.
        while select EndDate from fiscalCalendarYear
    where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
      && (fiscalCalendarYear.StartDate      <= _isToDate
      &&  fiscalCalendarYear.EndDate        >= _isToDate)
        {
            if (fiscalCalendarYear)
            {
                allocationEndYearDate = fiscalCalendarYear.EndDate;
            }
            else
            {
                throw error("@SYS301636");
            }
        }

        try
        {
            ttsbegin;
            if (isBudgetAllocation)
            {
                while select forupdate projBudgetLine  where projBudgetLine.ProjBudget == projBudget.RecId
                {
                    // Check whether a transction type is selected on allocation process form or not
                    if (ProjBudgetManager::checkTransType(_isHourCosts, _isExpenseCosts,
                       _isItemCosts, _isFees, _isHourRevenues,
                       _isExpenseRevenues, _isItemRevenues, projBudgetLine))
                    {
                        if (projBudget.BudgetState == ProjBudgetState::Created)
                        {
                            projAllocationMethod =  _projAllocationMethod;
                        }
                        else
                        {
                            if (projBudgetLine.OriginalBudget == 0)
                            {
                                // this is amendment rows.So find If any budget line was created when original budget was created.
                                previousAllocationExists = false;

                                previousAllocation = ProjBudgetManager::projAllocationMethod(projBudgetLine, isBudgetAllocation);
                                previousAllocationExists = conPeek(previousAllocation, 1);
                                projAllocationMethod = conPeek(previousAllocation, 2);

                                if (!previousAllocationExists)
                                {
                                    // since no budget Line is previously created so use the specified allocation method.
                                    projAllocationMethod = _projAllocationMethod;
                                }
                            }
                            else
                            {
                                projAllocationMethod =   projBudgetLine.ProjAllocationMethod;
                            }
                        }

                        switch (projAllocationMethod)
                        {
                            case ProjAllocationMethod::Yearly:
                            this.createAllocationLineByYear(_isHourCosts, _isExpenseCosts,
                                                            _isItemCosts, _isFees, _isHourRevenues,
                                                            _isExpenseRevenues, _isItemRevenues, allocationStartYearDate,
                                                            allocationEndYearDate, projBudget, projBudgetLine);
                                break;

                            case  ProjAllocationMethod::Periods:
                            this.createAllocationLineByPeriod(_isHourCosts, _isExpenseCosts,
                                                              _isItemCosts, _isFees, _isHourRevenues,
                                                              _isExpenseRevenues, _isItemRevenues, allocationStartDate,
                                                              allocationEndDate, projBudget, projBudgetLine);
                                break;

                            case  ProjAllocationMethod::Quarter:
                            this.createAllocationLineByQuarter(_isHourCosts, _isExpenseCosts,
                                                               _isItemCosts, _isFees, _isHourRevenues,
                                                               _isExpenseRevenues, _isItemRevenues, allocationStartDate,
                                                               allocationEndDate, projBudget, projBudgetLine);
                                break;
                        }
                    }
                }
            }
            else
            {
                while select projBudgetRevisionLine where projBudgetRevisionLine.ProjBudgetRevision == projBudgetRevision.RecId
                {
                    projBudgetLine = ProjBudgetLine::find(projBudgetRevisionLine.ProjBudgetLine);

                    // Check whether a transaction type is selected on allocation process form or not
                    if (ProjBudgetManager::checkTransType(_isHourCosts, _isExpenseCosts,
                       _isItemCosts, _isFees, _isHourRevenues,
                       _isExpenseRevenues, _isItemRevenues, projBudgetLine))
                    {
                        previousAllocation = ProjBudgetManager::projAllocationMethod(projBudgetLine, isBudgetAllocation);
                        previousAllocationExists = conPeek(previousAllocation, 1);
                        projAllocationMethod = conPeek(previousAllocation, 2);

                        if (!previousAllocationExists)
                        {
                            // since no budget Line is previously created so use the specified allocation method.
                            projAllocationMethod = _projAllocationMethod;
                        }

                        switch (projAllocationMethod)
                        {
                            case ProjAllocationMethod::Yearly:
                            this.createAllocationLineByYear(_isHourCosts, _isExpenseCosts,
                                                            _isItemCosts, _isFees, _isHourRevenues,
                                                            _isExpenseRevenues, _isItemRevenues, allocationStartYearDate,
                                                            allocationEndYearDate, projBudgetRevision, projBudgetRevisionLine);
                                break;

                            case ProjAllocationMethod::Periods:
                            this.createAllocationLineByPeriod(_isHourCosts, _isExpenseCosts,
                                                              _isItemCosts, _isFees, _isHourRevenues,
                                                              _isExpenseRevenues, _isItemRevenues, allocationStartDate,
                                                              allocationEndDate, projBudgetRevision, projBudgetRevisionLine);
                                break;

                            case ProjAllocationMethod::Quarter:
                            this.createAllocationLineByQuarter(_isHourCosts, _isExpenseCosts,
                                                               _isItemCosts, _isFees, _isHourRevenues,
                                                               _isExpenseRevenues, _isItemRevenues, allocationStartDate,
                                                               allocationEndDate, projBudgetRevision, projBudgetRevisionLine);
                                break;
                        }
                    }
                }
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    ttsabort;
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllocationLineByPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified transaction type is selected for allocation by period.
    /// </summary>
    /// <param name="_isHourCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// cost budget line.
    /// </param>
    /// <param name="_isExpenseCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense cost budget line.
    /// </param>
    /// <param name="_isItemCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an item
    /// cost budget line.
    /// </param>
    /// <param name="_isFees">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on a fee
    /// budget line.
    /// </param>
    /// <param name="_isHourRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// revenue budget line.
    /// </param>
    /// <param name="_isExpenseRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense revenue budget line.
    /// </param>
    /// <param name="_isItemRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed  on an item
    /// revenue budget line.
    /// </param>
    /// <param name="_isFromDate">
    /// A <c>TransDate</c> type value that specifies the from date of allocation.
    /// </param>
    /// <param name="_isToDate">
    /// A <c>TransDate</c> type value that specifies the to date of allocation.
    /// </param>
    /// <param name="_headerRecord">
    /// A <c>ProjBudget</c> or <c>ProjBudgetRevision</c> table buffer.
    /// </param>
    /// <param name="_lineRecord">
    /// A <c>ProjBudgetLine</c> or <c>ProjBudgetRevisionLine</c> table buffer.
    /// </param>
    private void createAllocationLineByPeriod(NoYes _isHourCosts, NoYes _isExpenseCosts,
                                          NoYes _isItemCosts, NoYes _isFees, NoYes _isHourRevenues,
                                          NoYes _isExpenseRevenues, NoYes _isItemRevenues, TransDate _isFromDate,
                                          TransDate _isToDate, Common _headerRecord, Common _lineRecord)
    {
        ProjBudget                  projBudget;
        ProjBudgetRevision          projBudgetRevision;
        ProjBudgetLine              projBudgetLine;
        ProjBudgetRevisionLine      projBudgetRevisionLine;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        FiscalCalendarYear          fiscalCalendarYear;
        RecId                       totalPeriod;
        AmountCur                   allocationAmount;
        RecId                       fiscalCalendar;
        int                         counter;
        boolean                     isBudgetAllocation;

        fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());

        //Get total number of periods within provided date range
        totalPeriod = ProjBudgetManager::getTotalInterval(ProjAllocationMethod::Periods, _isFromDate,_isToDate);

        if (totalPeriod)
        {
            switch (_headerRecord.TableId)
            {
                case tableNum(ProjBudget) :
                    projBudget = _headerRecord;
                    projBudgetLine = _lineRecord;
                    projBudgetLine.selectForUpdate(true);
                    // deleting previously budget allocation lines
                    this.deleteorUpdateAllocationLine(projBudgetLine, projBudget.BudgetState);
                    allocationAmount = CurrencyExchangeHelper::amount((projBudget.BudgetState == ProjBudgetState::Created ? projBudgetLine.OriginalBudget : projBudgetLine.UncommittedRevisions) / totalPeriod);
                    isBudgetAllocation = true;
                    break;

                case tableNum(ProjBudgetRevision) :
                    projBudgetRevision = _headerRecord;
                    projBudgetRevisionLine = _lineRecord;
                    // deleting previously revision allocation lines
                    this.deleteRevisionAllocationLine(projBudgetRevisionLine);

                    // Updating <c>UncommittedRevisions</c> to zero for budget allocation lines of previous period.
                    this.resetUncommittedRevisions(projBudgetRevisionLine.ProjBudgetLine);

                    allocationAmount = CurrencyExchangeHelper::amount(projBudgetRevisionLine.RevisionAmount / totalPeriod);
                    break;
            }

            counter = 0;

            while select RecId from fiscalCalendarYear
        where  fiscalCalendarYear.FiscalCalendar == fiscalCalendar
            join   RecId, FiscalCalendarYear, StartDate, EndDate from fiscalCalendarPeriod
            order by fiscalCalendarPeriod.StartDate asc
            where  fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId
               &&  fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
               && (fiscalCalendarPeriod.StartDate >= _isFromDate
               &&  fiscalCalendarPeriod.EndDate   <= _isToDate)
            {
                //insert allocation on creation and update allocation line on amendment
                counter++;

                if (isBudgetAllocation)
                {
                    if (counter == totalPeriod)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount((projBudget.BudgetState == ProjBudgetState::Created ? projBudgetLine.OriginalBudget : projBudgetLine.UncommittedRevisions) - allocationAmount * (totalPeriod - 1));
                    }
                    this.insertorUpdateProjAllocationLines(allocationAmount, ProjAllocationMethod::Periods, fiscalCalendarPeriod, projBudgetLine.RecId, projBudget.BudgetState);

                    projBudgetLine.ProjAllocationMethod = ProjAllocationMethod::Periods;
                    projBudgetLine.update();
                }
                else
                {
                    if (counter == totalPeriod)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount(projBudgetRevisionLine.RevisionAmount - allocationAmount * (totalPeriod - 1));
                    }
                    ProjBudgetRevisionManager::insertOrUpdateProjAllocationLines(allocationAmount, ProjAllocationMethod::Periods, fiscalCalendarPeriod, projBudgetRevisionLine.RecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllocationLineByQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified transaction type is selected for allocation by quarter.
    /// </summary>
    /// <param name="_isHourCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// cost budget line.
    /// </param>
    /// <param name="_isExpenseCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense cost budget line.
    /// </param>
    /// <param name="_isItemCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an item
    /// cost budget line.
    /// </param>
    /// <param name="_isFees">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on a fee
    /// budget line.
    /// </param>
    /// <param name="_isHourRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// revenue budget line.
    /// </param>
    /// <param name="_isExpenseRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense revenue budget line.
    /// </param>
    /// <param name="_isItemRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an item
    /// revenue budget line.
    /// </param>
    /// <param name="_isFromDate">
    /// A <c>TransDate</c> data type value that specifies the from date of allocation.
    /// </param>
    /// <param name="_isToDate">
    /// A <c>TransDate</c> data type value that specifies the to date of allocation.
    /// </param>
    /// <param name="_headerRecord">
    /// A <c>ProjBudget</c> or <c>ProjBudgetRevision</c> table buffer.
    /// </param>
    /// <param name="_lineRecord">
    /// A <c>ProjBudgetLine</c> or <c>ProjBudgetRevisionLine</c> table buffer.
    /// </param>
    private void createAllocationLineByQuarter(NoYes _isHourCosts, NoYes _isExpenseCosts,
                                           NoYes _isItemCosts, NoYes _isFees, NoYes _isHourRevenues,
                                           NoYes _isExpenseRevenues, NoYes _isItemRevenues, TransDate _isFromDate,
                                           TransDate _isToDate, Common _headerRecord, Common _lineRecord)
    {
        ProjBudget                  projBudget;
        ProjBudgetRevision          projBudgetRevision;
        ProjBudgetLine              projBudgetLine;
        ProjBudgetRevisionLine      projBudgetRevisionLine;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        FiscalCalendarYear          fiscalCalendarYear;
        AmountCur                   allocationAmount;
        RecId                       fiscalCalendar;
        RecId                       totalQuarter;
        int                         counter;
        boolean                     isBudgetAllocation;

        fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());

        //Get total number of periods within provided date range
        totalQuarter = ProjBudgetManager::getTotalInterval(ProjAllocationMethod::Quarter, _isFromDate, _isToDate);

        if (totalQuarter)
        {
            switch (_headerRecord.TableId)
            {
                case tableNum(ProjBudget) :
                    projBudget = _headerRecord;
                    projBudgetLine = _lineRecord;
                    projBudgetLine.selectForUpdate(true);
                    // deleting previously budget allocation lines
                    this.deleteorUpdateAllocationLine(projBudgetLine, projBudget.BudgetState);
                    allocationAmount = CurrencyExchangeHelper::amount((projBudget.BudgetState == ProjBudgetState::Created ? projBudgetLine.OriginalBudget : projBudgetLine.UncommittedRevisions) / totalQuarter);
                    isBudgetAllocation = true;
                    break;

                case tableNum(ProjBudgetRevision) :
                    projBudgetRevision = _headerRecord;
                    projBudgetRevisionLine = _lineRecord;
                    // deleting previously revision allocation lines
                    this.deleteRevisionAllocationLine(projBudgetRevisionLine);

                    // Updating <c>UncommittedRevisions</c> to zero for budget allocation lines of previous period.
                    this.resetUncommittedRevisions(projBudgetRevisionLine.ProjBudgetLine);

                    allocationAmount = CurrencyExchangeHelper::amount(projBudgetRevisionLine.RevisionAmount / totalQuarter);
                    break;
            }

            counter = 0;

            while select RecId, Quarter from  fiscalCalendarPeriod
            join RecId from  fiscalCalendarYear
            group by fiscalCalendarPeriod.FiscalCalendarYear, fiscalCalendarPeriod.Quarter
            where fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId
              &&  fiscalCalendarYear.FiscalCalendar == fiscalCalendar
              && (fiscalCalendarPeriod.StartDate >= _isFromDate
              &&  fiscalCalendarPeriod.EndDate   <= _isToDate)
            {
                counter++;

                if (isBudgetAllocation)
                {
                    if (counter == totalQuarter)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount((projBudget.BudgetState == ProjBudgetState::Created ? projBudgetLine.OriginalBudget : projBudgetLine.UncommittedRevisions) - allocationAmount * (totalQuarter - 1));
                    }
                    //insert allocation on creation and update allocation line on amendment
                    this.insertorUpdateProjAllocationLines(allocationAmount, ProjAllocationMethod::Quarter, fiscalCalendarPeriod, projBudgetLine.RecId, projBudget.BudgetState);

                    projBudgetLine.ProjAllocationMethod = ProjAllocationMethod::Quarter;
                    projBudgetLine.update();
                }
                else
                {
                    if (counter == totalQuarter)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount(projBudgetRevisionLine.RevisionAmount - allocationAmount * (totalQuarter - 1));
                    }
                    ProjBudgetRevisionManager::insertOrUpdateProjAllocationLines(allocationAmount, ProjAllocationMethod::Quarter, fiscalCalendarPeriod, projBudgetRevisionLine.RecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllocationLineByYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified transaction type is selected for allocation by year.
    /// </summary>
    /// <param name="_isHourCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// cost budget line.
    /// </param>
    /// <param name="_isExpenseCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense cost budget line.
    /// </param>
    /// <param name="_isItemCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an item
    /// cost budget line.
    /// </param>
    /// <param name="_isFees">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on a fee
    /// budget line.
    /// </param>
    /// <param name="_isHourRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// revenue budget line.
    /// </param>
    /// <param name="_isExpenseRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense revenue budget line.
    /// </param>
    /// <param name="_isItemRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an item
    /// revenue budget line.
    /// </param>
    /// <param name="_isFromDate">
    /// A <c>TransDate</c> data type value that specifies the from date of allocation.
    /// </param>
    /// <param name="_isToDate">
    /// A <c>TransDate</c> type value that specifies the to date of allocation.
    /// </param>
    /// <param name="_headerRecord">
    /// A <c>ProjBudget</c> or <c>ProjBudgetRevision</c> table buffer.
    /// </param>
    /// <param name="_lineRecord">
    /// A <c>ProjBudgetLine</c> or <c>ProjBudgetRevisionLine</c> table buffer.
    /// </param>

    private void createAllocationLineByYear(NoYes _isHourCosts, NoYes _isExpenseCosts,
                                        NoYes _isItemCosts, NoYes _isFees, NoYes _isHourRevenues,
                                        NoYes _isExpenseRevenues, NoYes _isItemRevenues, TransDate _isFromDate,
                                        TransDate _isToDate, Common _headerRecord, Common _lineRecord)
    {
        ProjBudget                  projBudget;
        ProjBudgetRevision          projBudgetRevision;
        ProjBudgetLine              projBudgetLine;
        ProjBudgetRevisionLine      projBudgetRevisionLine;
        FiscalCalendarYear          fiscalCalendarYear;
        RecId                       totalYear;
        AmountCur                   allocationAmount;
        RecId                       fiscalCalendar;
        int                         counter;
        boolean                     isBudgetAllocation;

        fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());

        //Get total number of periods within provided date range
        totalYear = ProjBudgetManager::getTotalInterval(ProjAllocationMethod::Yearly, _isFromDate, _isToDate);

        if (totalYear)
        {
            switch (_headerRecord.TableId)
            {
                case tableNum(ProjBudget) :
                    projBudget = _headerRecord;
                    projBudgetLine = _lineRecord;
                    projBudgetLine.selectForUpdate(true);
                    // deleting previously allocation lines
                    this.deleteorUpdateAllocationLine(projBudgetLine, projBudget.BudgetState);
                    allocationAmount = CurrencyExchangeHelper::amount((projBudget.BudgetState == ProjBudgetState::Created ? projBudgetLine.OriginalBudget : projBudgetLine.UncommittedRevisions) / totalYear);
                    isBudgetAllocation = true;
                    break;

                case tableNum(ProjBudgetRevision) :
                    projBudgetRevision = _headerRecord;
                    projBudgetRevisionLine = _lineRecord;
                    // deleting previously allocation lines
                    this.deleteRevisionAllocationLine(projBudgetRevisionLine);

                    // Updating <c>UncommittedRevisions</c> to zero for budget allocation lines of previous period.
                    this.resetUncommittedRevisions(projBudgetRevisionLine.ProjBudgetLine);

                    allocationAmount = CurrencyExchangeHelper::amount(projBudgetRevisionLine.RevisionAmount / totalYear);
            }

            counter = 0;

            while select RecId from  fiscalCalendarYear
        where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
          && (fiscalCalendarYear.StartDate      >= _isFromDate
          &&  fiscalCalendarYear.EndDate        <= _isToDate)
            {
                counter++;

                if (isBudgetAllocation)
                {
                    if (counter == totalYear)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount((projBudget.BudgetState == ProjBudgetState::Created ? projBudgetLine.OriginalBudget : projBudgetLine.UncommittedRevisions) - allocationAmount * (totalYear - 1));
                    }
                    //insert allocation on creation and update allocation line on amendment
                    this.insertorUpdateProjAllocationLines(allocationAmount, ProjAllocationMethod::Yearly, fiscalCalendarYear, projBudgetLine.RecId, projBudget.BudgetState);
                    projBudgetLine.ProjAllocationMethod = ProjAllocationMethod::Yearly;
                    projBudgetLine.update();
                }
                else
                {
                    if (counter == totalYear)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount(projBudgetRevisionLine.RevisionAmount - allocationAmount * (totalYear - 1));
                    }
                    ProjBudgetRevisionManager::insertOrUpdateProjAllocationLines(allocationAmount, ProjAllocationMethod::Yearly, fiscalCalendarYear, projBudgetRevisionLine.RecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjForecastCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes project forecast cost record in the <c>ProjForecastCost</c> table.
    /// </summary>
    /// <param name="_projForecastBudgetType">
    ///    Budget forcast type.
    /// </param>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetLine">
    ///    A <c>ProjBudgetLine</c> table buffer that contains the project budget line.
    /// </param>
    /// <returns>
    ///    A <c>ProjForecastCost</c> table buffer that contains the project forecast cost line.
    /// </returns>
    protected ProjForecastCost initializeProjForecastCost(ProjForecastBudgetType _projForecastBudgetType, ProjBudget _projBudget, ProjBudgetLine _projBudgetLine)
    {
        ProjForecastCost projForecastCost;

        projForecastCost.clear();
        projForecastCost.CurrencyId = Ledger::accountingCurrency(CompanyInfo::current());
        projForecastCost.ProjId = _projBudgetLine.ProjId;
        projForecastCost.initValue();
        projForecastCost.CategoryId = _projBudgetLine.CategoryId;
        projForecastCost.Qty = 1;
        projForecastCost.ModelId = (_projForecastBudgetType == ProjForecastBudgetType::RemainingBudget ? _projBudget.RemainingBudgetForecastModel: _projBudget.OriginalBudgetForecastModel);
        projForecastCost.ProjForecastBudgetType = _projForecastBudgetType;
        projForecastCost.ActivityNumber = _projBudgetLine.ActivityNumber;
        projForecastCost.DefaultDimension = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
        projForecastCost.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);
        projForecastCost.CostPrice = 0;
        projForecastCost.SalesPrice = 0;

        return ProjForecastCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetCostForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the budget cost forecast record in the <c>ProjForecastCost</c> table.
    /// </summary>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision record ID.
    /// </param>
    protected void createBudgetCostForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId = 0)
    {
        QueryRun  queryRun = new QueryRun(this.buildQueryToGetCostProjBudgetLine(_projBudget));
        while(queryRun.next())
        {
            ProjBudgetLine  projBudgetLine = queryRun.get(tableNum(ProjBudgetLine));
            this.createOrUpdateBudgetCostForecast(_projBudget, _projBudgetRevisionRecId, projBudgetLine);
        }
        // since every time amendment is committed a new amendment row is created. So we place a marker of Qty = 0 when
        // we insert amendment line. so that when we update any amendment forecast we are sure that this row is created
        // due to current amendment commitment process. Finally, setting the actual value.
        if (_projBudget.BudgetState == ProjBudgetState::Amendment)
        {
            ProjForecastCost projForecastCost;

            update_recordset projForecastCost
            setting Qty = 1
            where projForecastCost.ProjId like _projBudget.RootProjId + #Star
            &&  projForecastCost.ProjForecastBudgetType == ProjForecastBudgetType::Amendment
            &&  projForecastCost.Qty == 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetCostProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Provides the base query to select all project budget line of type cost and project budget to the <c>ProjBudgetLine</c> table.
    /// </summary>
    /// <param name = "_projBudget">
    ///		A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <returns>
    ///		Returns query intance to select all project budget line of type cost and project budget to the <c>ProjBudgetLine</c> table.
    /// </returns>
    protected Query buildQueryToGetCostProjBudgetLine(ProjBudget _projBudget)
    {
        Query query = new Query();
        QueryBuildDataSource projBudgetLineQbds = query.addDataSource(tableNum(ProjBudgetLine));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,CategoryId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,TotalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,RecId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudgetLineType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,UncommittedRevisions));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,OriginalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjTransType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ActivityNumber));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjId));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjBudget)).value(queryValue(_projBudget.Recid));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjTransType)).value(queryValue(ProjTransType::Cost));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBudgetCostForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates or updates the budget cost forecast record in the <c>ProjForecastCost</c> table.
    /// </summary>
    /// <param name = "_projBudget">
    ///     A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///     The project budget revision record ID.
    /// </param>
    /// <param name = "_projBudgetLine">
    ///     The project budget line.
    /// </param>
    protected void createOrUpdateBudgetCostForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId, ProjBudgetLine _projBudgetLine)
    {
        ProjForecastCost projForecastCost;
        ProjBudgetAllocationLine projBudgetAllocationLine;

        void setProjForecastCostPrice()
        {
            AmountCur amountCur = _projBudget.BudgetState == ProjBudgetState::Created
                                 ? _projBudgetLine.OriginalBudget
                                 : ProjBudgetRevisionLine::findByProjBudgetRevisionIdx(_projBudgetRevisionRecId, _projBudgetLine.RecId).RevisionAmount;
            if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
            {
                projForecastCost.CostPrice += amountCur;
            }
            else
            {
                projForecastCost.SalesPrice += amountCur;
            }
        }

        if (!ProjBudgetAllocationLine::existAllocationByLine(_projBudgetLine.RecId, _projBudget.BudgetState))
        {
            this.createDefaultAllocation(_projBudgetLine, _projBudget.BudgetState);
        }

        // For Original budget forecast.
        projForecastCost = ProjForecastCost::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, _projBudgetLine.ActivityNumber, ProjForecastBudgetType::OriginalBudget, true);

        if (_projBudget.BudgetState == ProjBudgetState::Created)
        {
            if (projForecastCost)
            {
                // if record is found the update the price only.
                setProjForecastCostPrice();
                projForecastCost.update();
            }
            else
            {
                // Creating the original forecast record.
                projForecastCost = this.initializeProjForecastCost(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
                setProjForecastCostPrice();
                projForecastCost.insert();
            }
        }
        else if (!projForecastCost)
        {
            // Creating the original forecast record for amendment
            projForecastCost = this.initializeProjForecastCost(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
            projForecastCost.insert();
        }

        if (_projBudget.BudgetState == ProjBudgetState::Amendment && _projBudgetLine.UncommittedRevisions)
        {
            select firstonly forupdate projForecastCost
                where projForecastCost.ProjId == _projBudgetLine.ProjId
                &&  projForecastCost.CategoryId == _projBudgetLine.CategoryId
                &&  projForecastCost.ActivityNumber == _projBudgetLine.ActivityNumber
                &&  projForecastCost.ProjForecastBudgetType == ProjForecastBudgetType::Amendment
                &&  projForecastCost.Qty == 0;

            if (projForecastCost)
            {
                // if record is found the update the price only.
                setProjForecastCostPrice();
                projForecastCost.update();
            }
            else
            {
                // Creating the original forecast record.
                ProjForecastCost = this.initializeProjForecastCost(ProjForecastBudgetType::Amendment, _projBudget, _projBudgetLine);
                projForecastCost.Qty = 0;
                setProjForecastCostPrice();
                projForecastCost.insert();
            }

            //this.updateFromRevision(_projBudgetRevisionRecId);
        }

        // For remaining budget forecast.
        projForecastCost = ProjForecastCost::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, _projBudgetLine.ActivityNumber, ProjForecastBudgetType::RemainingBudget, true);

        if (projForecastCost)
        {
            // if record is found the update the price only.
            setProjForecastCostPrice();
            projForecastCost.update();
        }
        else
        {
            // Creating the remaining forecast record.
            projForecastCost = this.initializeProjForecastCost(ProjForecastBudgetType::RemainingBudget, _projBudget, _projBudgetLine);
            setProjForecastCostPrice();
            projForecastCost.insert();
        }

        if (_projBudgetRevisionRecId == 0)
        {
            update_recordset projBudgetAllocationLine
                    setting CommittedRevisions = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions,
                            TotalAllocationAmount = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions+ projBudgetAllocationLine.OriginalAllocationAmount,
                            UncommittedRevisions = 0
                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjForecastEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes project forecast hour record in the <c>ProjForecastEmpl</c> table.
    /// </summary>
    /// <param name="_projForecastBudgetType">
    ///    Budget forcast type.
    /// </param>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetLine">
    ///    A <c>ProjBudgetLine</c> table buffer that contains the project budget line.
    /// </param>
    /// <returns>
    ///    A <c>ProjForecastEmpl</c> table buffer that contains the project forecast hour line.
    /// </returns>
    protected ProjForecastEmpl initializeProjForecastEmpl(ProjForecastBudgetType _projForecastBudgetType, ProjBudget _projBudget, ProjBudgetLine _projBudgetLine)
    {
        ProjForecastEmpl projForecastEmpl;

        projForecastEmpl.clear();
        projForecastEmpl.CurrencyId = Ledger::accountingCurrency(CompanyInfo::current());
        projForecastEmpl.ProjId = _projBudgetLine.ProjId;
        projForecastEmpl.initValue();
        projForecastEmpl.CategoryId = _projBudgetLine.CategoryId;
        projForecastEmpl.Qty = 1;
        projForecastEmpl.ModelId = (_projForecastBudgetType == ProjForecastBudgetType::RemainingBudget ? _projBudget.RemainingBudgetForecastModel: _projBudget.OriginalBudgetForecastModel);
        projForecastEmpl.ProjForecastBudgetType = _projForecastBudgetType;
        projForecastEmpl.ActivityNumber = _projBudgetLine.ActivityNumber;
        projForecastEmpl.DefaultDimension = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
        projForecastEmpl.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);
        projForecastEmpl.CostPrice = 0;
        projForecastEmpl.SalesPrice = 0;

        return ProjForecastEmpl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBudgetEmplForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates or updates the budget empl forecast record in the <c>ProjForecastEmpl</c> table.
    /// </summary>
    /// <param name = "_projBudget">
    ///     A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///     The project budget revision record ID.
    /// </param>
    /// <param name = "_projBudgetLine">
    ///     The project budget line.
    /// </param>
    protected void createOrUpdateBudgetEmplForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId, ProjBudgetLine _projBudgetLine)
    {
        ProjForecastEmpl projForecastEmpl;
        ProjBudgetAllocationLine projBudgetAllocationLine;

        void setProjForecastEmplPrice()
        {
            if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
            {
                projForecastEmpl.CostPrice += (_projBudget.BudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget
                                               : ProjBudgetRevisionLine::findByProjBudgetRevisionIdx(_projBudgetRevisionRecId ,_projBudgetLine.RecId).RevisionAmount);
            }
            else
            {
                projForecastEmpl.SalesPrice += (_projBudget.BudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget
                                                : ProjBudgetRevisionLine::findByProjBudgetRevisionIdx(_projBudgetRevisionRecId, _projBudgetLine.RecId).RevisionAmount);
            }
        }

        if (!ProjBudgetAllocationLine::existAllocationByLine(_projBudgetLine.RecId, _projBudget.BudgetState))
        {
            this.createDefaultAllocation(_projBudgetLine, _projBudget.BudgetState);
        }

        // For Original budget forecast.
        projForecastEmpl = ProjForecastEmpl::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, _projBudgetLine.ActivityNumber, ProjForecastBudgetType::OriginalBudget, true);

        if (_projBudget.BudgetState == ProjBudgetState::Created)
        {
            if (projForecastEmpl)
            {
                // if record is found the update the price only.
                setProjForecastEmplPrice();
                projForecastEmpl.update();
            }
            else
            {
                // Creating the original forecast record.
                projForecastEmpl = this.initializeProjForecastEmpl(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
                setProjForecastEmplPrice();
                projForecastEmpl.insert();
            }
        }
        else  if (!projForecastEmpl)
        {
            projForecastEmpl = this.initializeProjForecastEmpl(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
            projForecastEmpl.insert();
        }

        if (_projBudget.BudgetState == ProjBudgetState::Amendment && _projBudgetLine.UncommittedRevisions)
        {
            select firstonly forupdate projForecastEmpl
                where projForecastEmpl.ProjId == _projBudgetLine.ProjId
                &&  projForecastEmpl.CategoryId == _projBudgetLine.CategoryId
                &&  projForecastEmpl.ActivityNumber == _projBudgetLine.ActivityNumber
                &&  projForecastEmpl.ProjForecastBudgetType == ProjForecastBudgetType::Amendment
                &&  projForecastEmpl.Qty == 0;

            if (projForecastEmpl)
            {
                // if record is found the update the price only.
                setProjForecastEmplPrice();
                projForecastEmpl.update();
            }
            else
            {
                // Creating the original forecast record.
                projForecastEmpl = this.initializeProjForecastEmpl(ProjForecastBudgetType::Amendment, _projBudget, _projBudgetLine);
                setProjForecastEmplPrice();
                projForecastEmpl.Qty = 0;
                projForecastEmpl.insert();
            }

            //this.updateFromRevision(_projBudgetRevisionRecId);
        }

        // For remaining budget forecast.
        projForecastEmpl = ProjForecastEmpl::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, _projBudgetLine.ActivityNumber, ProjForecastBudgetType::RemainingBudget, true);

        if (projForecastEmpl)
        {
            // if record is found the update the price only.
            setProjForecastEmplPrice();
            projForecastEmpl.update();
        }
        else
        {
            // Creating the remaining forecast record.
            projForecastEmpl = this.initializeProjForecastEmpl(ProjForecastBudgetType::RemainingBudget, _projBudget, _projBudgetLine);
            setprojForecastEmplPrice();
            projForecastEmpl.insert();
        }

        if (_projBudgetRevisionRecId == 0)
        {
            update_recordset projBudgetAllocationLine
                    setting CommittedRevisions = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions,
                            TotalAllocationAmount = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions+ projBudgetAllocationLine.OriginalAllocationAmount,
                            UncommittedRevisions = 0
                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetEmplForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the budget employee forecast record in the <c>ProjForecastEmpl</c> table.
    /// </summary>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision record ID.
    /// </param>
    protected void createBudgetEmplForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId = 0)
    {
        QueryRun  queryRun = new QueryRun(this.buildQueryToGetEmplProjBudgetLine(_projBudget));
        while(queryRun.next())
        {
            ProjBudgetLine  projBudgetLine = queryRun.get(tableNum(ProjBudgetLine));

            this.createOrUpdateBudgetEmplForecast(_projBudget, _projBudgetRevisionRecId, projBudgetLine);
        }
        // since every time amendment is committed a new amendment row is created. So we place a marker of Qty = 0 when
        // we insert amendment line. so that when we update any amendment forecast we are sure that this row is created
        // due to current amendment commitment process. Finally, setting the actual value.
        if (_projBudget.BudgetState == ProjBudgetState::Amendment)
        {
            ProjForecastEmpl projForecastEmpl;

            update_recordset projForecastEmpl
            setting Qty = 1
            where projForecastEmpl.ProjId like _projBudget.RootProjId + #Star
            &&  projForecastEmpl.ProjForecastBudgetType == ProjForecastBudgetType::Amendment
            &&  projForecastEmpl.Qty == 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetEmplProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Provides the base query to select all project budget line of type hour and project budget to the <c>ProjBudgetLine</c> table.
    /// </summary>
    /// <param name = "_projBudget">
    ///		A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <returns>
    ///		Returns query intances to select all project budget line of type hour and project budget to the <c>ProjBudgetLine</c> table.
    /// </returns>
    protected Query buildQueryToGetEmplProjBudgetLine(ProjBudget _projBudget)
    {
        Query query = new Query();
        QueryBuildDataSource projBudgetLineQbds = query.addDataSource(tableNum(ProjBudgetLine));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,CategoryId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,TotalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,RecId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudgetLineType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,UncommittedRevisions));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,OriginalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjTransType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ActivityNumber));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjId));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjBudget)).value(queryValue(_projBudget.Recid));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjTransType)).value(queryValue(ProjTransType::Hour));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetFromEstimates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the category budget rows in the <c>ProjBudgetLine</c> table by transferring estimates to
    /// to selected forecast model then importing budget from the forecasts in the selected model.
    /// </summary>
    /// <param name="_forecastModelId">
    /// A <c>ForecaseModelId</c> value that determines the forecast model.
    /// </param>
    /// <param name="_sourceProjId">
    /// A <c>ProjId</c> value that determines the project ID used to select estimates.
    /// </param>
    /// <param name="_projBudgetId">
    /// A <c>RecId</c> value that specifies the project budget for which to create budget rows.
    /// </param>
    /// <param name="_markUpUnits">
    /// A <c>MarkUpValue</c> value that specifies the mark up percentage.
    /// </param>
    /// <param name="_markUpCosts">
    /// A <c>boolean</c> value that specifies the mark up costs.
    /// </param>
    /// <param name="_markUpRevenue">
    /// A <c>boolean</c> value that specifies the mark up revenue.
    /// </param>
    /// <param name="_summarizeByCategory">
    /// A <c>boolean</c> value that specifies whether to group by based on activity or not.
    /// </param>
    /// <param name="_projBudgetRevision">
    /// A <c>RecId</c> value that specifies the project budget revision for which to create budget revision rows.
    /// </param>
    public  void createBudgetFromEstimates(
    ForecastModelId _forecastModelId,
    ProjId          _sourceProjId,
    RecId           _projBudgetId,
    MarkupValue     _markUpUnits            = 0.0,
    MarkupValue     _markUpCosts            = 0.0,
    MarkupValue     _markUpRevenue          = 0.0,
    boolean         _summarizeByCategory    = false,
    RecId           _projBudgetRevision     = 0)
    {
        PSAActivityEstimates    psaActivityEstimates, tmpPsaActivityEstimates;
        smmActivities           smmActivities;
        HierarchyTreeTable      hierarchyTreeTable;
        HierarchyLinkTable      hierarchyLinkTable;        

        ProjForecastTransferFromWbs projForecastTransferFromWbs;

        tmpPsaActivityEstimates.setTmp();

        List projList = new List(Types::Record);

        ProjTable sourceProject = ProjTable::find(_sourceProjId);

        projList.addStart(sourceProject);

        if (sourceProject.ProjBudgetManagement == ProjBudgetManagement::None && ProjTable::child(_sourceProjId))
        {
            projList = ProjTable::getChildProjectsFromRootProject(_sourceProjId, projList);
        }

        ListEnumerator projEnumerator = projList.getEnumerator();

        while (projEnumerator.moveNext())
        {
            ProjTable projTable = projEnumerator.current();

            while select * from psaActivityEstimates
            join RecId from smmActivities
                where psaActivityEstimates.ActivityNumber == smmActivities.ActivityNumber
            join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RefRecId == smmActivities.RecId
            join RecId from hierarchyLinkTable
                where hierarchyLinkTable.HierarchyId == hierarchyTreeTable.HierarchyId &&
                      hierarchyLinkTable.RefTableId == tableNum(ProjTable) &&
                      hierarchyLinkTable.RefRecId == projTable.RecId
            {
               if (! ProjBudgetCategoryToTransTypeValidation::validate(psaActivityEstimates.ProjCategoryId, psaActivityEstimates.ProjTransType))
                {
                    throw Error(strFmt("@Proj:ProjCategoryMappingError",psaActivityEstimates.ProjCategoryId, psaActivityEstimates.ProjTransType));
                }

                tmpPsaActivityEstimates.data(psaActivityEstimates.data());
                tmpPsaActivityEstimates.insert();
            }

            if (ProjForecastTransferWBSCleanupNonExistActivityFlight::instance().isEnabled())
            {
                this.cleanUpForecastsForNonExistingPSAActivityEstimates(tmpPsaActivityEstimates, projTable.ProjId, _forecastModelId);
            }
            projForecastTransferFromWbs = new ProjForecastTransferFromWbs(tmpPsaActivityEstimates, projTable.ProjId, _forecastModelId);
            projForecastTransferFromWbs.transfer();

            this.createBudgetFromForecastModel(_forecastModelId, projTable.ProjId, _projBudgetId, _markUpUnits, _markUpCosts, _markUpRevenue, _summarizeByCategory, _projBudgetRevision);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetFromForecastModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the category budget rows in the <c>ProjBudgetLine</c> table by using the specified forecast
    /// model.
    /// </summary>
    /// <param name="_forecastModelId">
    /// A <c>ForecaseModelId</c> value that determines the forecast model to use for creating budget rows.
    /// </param>
    /// <param name="_sourceProjId">
    /// A <c>ProjId</c> value that determines the project ID used to select forecast.
    /// </param>
    /// <param name="_projBudgetId">
    /// A <c>RecId</c> value that specifies the project budget for which to create budget rows.
    /// </param>
    /// <param name="_markUpUnits">
    /// A <c>MarkUpValue</c> value that specifies the mark up percentage.
    /// </param>
    /// <param name="_markUpCosts">
    /// A <c>boolean</c> value that specifies the mark up costs.
    /// </param>
    /// <param name="_markUpRevenue">
    /// A <c>boolean</c> value that specifies the mark up revenue.
    /// </param>
    /// <param name="_summarizeByCategory">
    /// A <c>boolean</c> value that specifies whether to group by based on activity or not.
    /// </param>
    /// <param name="_projBudgetRevision">
    /// A <c>RecId</c> value that specifies the project budget revision for which to create budget revision rows.
    /// </param>
    public  void createBudgetFromForecastModel(
        ForecastModelId _forecastModelId,
        ProjId          _sourceProjId,
        RecId           _projBudgetId,
        MarkupValue     _markUpUnits            = 0.0,
        MarkupValue     _markUpCosts            = 0.0,
        MarkupValue     _markUpRevenue          = 0.0,
        boolean         _summarizeByCategory    = false,
        RecId           _projBudgetRevision     = 0)

    {
        #define.WildcardCharacter('*')
        ProjTable               projTable;
        ProjForecastEmpl        projForecastEmplGroup;
        ProjForecastEmpl        projForecastEmpl;
        ProjForecastCost        projForecastCostGroup;
        ProjForecastCost        projForecastCost;
        ForecastSales           forecastSales;
        ForecastSales           forecastSalesGroup;
        ProjForecastRevenue     projForecastRevenue;
        ProjForecastRevenue     projForecastRevenueGroup;
        ProjBudgetLine          projBudgetLine;
        ProjId                  projIdQueryValue;
        AmountCur               transTurnover;
        AmountCur               transCost;
        ProjTrans               projTrans;
        CurrencyCode            currencyCode;
        RefRecId                projBudgetLineCostRecId;
        RefRecId                projBudgetLineRevenueRecId;
        RecId                   projBudgetRevisionRevLineRecId;
        RecId                   projBudgetRevisionCostLineRecId;
        QueryRun                groupQueryRun;
        QueryRun                queryRun;
        TableId                 tableNumProjForecastEmpl;
        FieldId                 fieldNumProjForecastEmplModelId;
        FieldId                 fieldNumProjForecastEmplProjId;
        FieldId                 fieldNumProjForecastEmplCategoryId;
        FieldId                 fieldNumProjForecastEmplActivityNumber;
        TableId                 tableNumProjForecastCost;
        FieldId                 fieldNumProjForecastCostModelId;
        FieldId                 fieldNumProjForecastCostProjId;
        FieldId                 fieldNumProjForecastCostCategoryId;
        FieldId                 fieldNumProjForecastCostActivityNumber;
        TableId                 tableNumForecastSales;
        FieldId                 fieldNumForecastSalesModelId;
        FieldId                 fieldNumForecastSalesProjId;
        FieldId                 fieldNumForecastSalesProjCategoryId;
        FieldId                 fieldNumForecastSalesActivityNumber;
        TableId                 tableNumForecastRevenue;
        FieldId                 fieldNumForecastRevenueModelId;
        FieldId                 fieldNumForecastRevenueProjId;
        FieldId                 fieldNumForecastRevenueProjCategoryId;
        FieldId                 fieldNumForecastRevenueActivityNumber;
        boolean                 isProject3ConfigKeyEnabled;
        boolean                 canImportRevenueBudget;
        Map                     projCanImportRevenueBudgetMap;
        MapEnumerator           projIdEnumerator;

        tableNumProjForecastEmpl               = tableNum(ProjForecastEmpl);
        fieldNumProjForecastEmplModelId        = fieldNum(ProjForecastEmpl, ModelId);
        fieldNumProjForecastEmplProjId         = fieldNum(ProjForecastEmpl, ProjId);
        fieldNumProjForecastEmplCategoryId     = fieldNum(ProjForecastEmpl, CategoryId);
        fieldNumProjForecastEmplActivityNumber = fieldNum(ProjForecastEmpl, ActivityNumber);
        tableNumProjForecastCost               = tableNum(ProjForecastCost);
        fieldNumProjForecastCostModelId        = fieldNum(ProjForecastCost, ModelId);
        fieldNumProjForecastCostProjId         = fieldNum(ProjForecastCost, ProjId);
        fieldNumProjForecastCostCategoryId     = fieldNum(ProjForecastCost, CategoryId);
        fieldNumProjForecastCostActivityNumber = fieldNum(ProjForecastCost, ActivityNumber);
        tableNumForecastSales                  = tableNum(ForecastSales);
        fieldNumForecastSalesModelId           = fieldNum(ForecastSales, ModelId);
        fieldNumForecastSalesProjId            = fieldNum(ForecastSales, ProjId);
        fieldNumForecastSalesProjCategoryId    = fieldNum(ForecastSales, ProjCategoryId);
        fieldNumForecastSalesActivityNumber    = fieldNum(ForecastSales, ActivityNumber);
        tableNumForecastRevenue                = tableNum(ProjForecastRevenue);
        fieldNumForecastRevenueModelId         = fieldNum(ProjForecastRevenue, ModelId);
        fieldNumForecastRevenueProjId          = fieldNum(ProjForecastRevenue, ProjId);
        fieldNumForecastRevenueProjCategoryId  = fieldNum(ProjForecastRevenue, CategoryId);
        fieldNumForecastRevenueActivityNumber  = fieldNum(ProjForecastRevenue, ActivityNumber);
        
        projCanImportRevenueBudgetMap          = new Map(typeOf(_sourceProjId),typeOf(canImportRevenueBudget));
        projTable                              = ProjTable::find(_sourceProjId);
        canImportRevenueBudget                 = this.canImportRevenueBudgetV2(projTable);
        projCanImportRevenueBudgetMap.insert(_sourceProjId,canImportRevenueBudget);

        projIdQueryValue = _sourceProjId;

        if (projTable.ProjBudgetManagement == ProjBudgetManagement::None)
        {
            projIdQueryValue = _sourceProjId + #WildcardCharacter;
        }

        if (_projBudgetRevision == 0)
        {
            delete_from projBudgetLine
                where  projBudgetLine.ProjBudget == _projBudgetId
                    && projBudgetLine.ProjId == _sourceProjId;
        }
        else
        {
            this.deleteBudgetLinesBeforeImportForRevs(_projBudgetRevision, _projBudgetId, _sourceProjId);
        }

        currencyCode = Ledger::accountingCurrency(CompanyInfo::current());

        //Hour
        groupQueryRun = new QueryRun(this.getQueryWithGroupByClause(
                            tableNumProjForecastEmpl,
                            fieldNumProjForecastEmplModelId,
                            fieldNumProjForecastEmplProjId,
                            fieldNumProjForecastEmplCategoryId,
                            fieldNumProjForecastEmplActivityNumber,
                            _forecastModelId,
                            projIdQueryValue,
                            _summarizeByCategory));

        while (groupQueryRun.next())
        {
            projForecastEmplGroup           = groupQueryRun.get(tableNumProjForecastEmpl);
            transCost                       = 0;
            transTurnover                   = 0;
            projBudgetRevisionRevLineRecId  = 0;
            projBudgetRevisionCostLineRecId = 0;

            if (projCanImportRevenueBudgetMap.exists(projForecastEmplGroup.ProjId))
            {
                canImportRevenueBudget = projCanImportRevenueBudgetMap.lookup(projForecastEmplGroup.ProjId);
            }
            else
            {
                canImportRevenueBudget = this.canImportRevenueBudgetV2(ProjTable::find(projForecastEmplGroup.ProjId));
                projCanImportRevenueBudgetMap.insert(projForecastEmplGroup.ProjId, canImportRevenueBudget);
            }

            if (canImportRevenueBudget)
            {
                projBudgetLineRevenueRecId = this.createBudgetLineIfNotExists(
                                                    projForecastEmplGroup.CategoryId,
                                                    ProjTransType::Hour,
                                                    transTurnover,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    projForecastEmplGroup.ProjId,
                                                    !_summarizeByCategory ? projForecastEmplGroup.ActivityNumber : '',
                                                    _projBudgetRevision);
            }

            projBudgetLineCostRecId = this.createBudgetLineIfNotExists(
                                                projForecastEmplGroup.CategoryId,
                                                ProjTransType::Hour,
                                                transCost,
                                                ProjBudgetLineType::Cost,
                                                _projBudgetId,
                                                projForecastEmplGroup.ProjId,
                                                !_summarizeByCategory ? projForecastEmplGroup.ActivityNumber : '',
                                                _projBudgetRevision);

            ProjBudgetManagerParmArgs projBudgetManagerParmArgs = ProjBudgetManagerParmArgs::construct();
            projBudgetManagerParmArgs.parmTableId(tableNumProjForecastEmpl);
            projBudgetManagerParmArgs.parmFieldNumForecastModelId(fieldNumProjForecastEmplModelId);
            projBudgetManagerParmArgs.parmFieldNumProjId(fieldNumProjForecastEmplProjId);
            projBudgetManagerParmArgs.parmFieldNumCategoryId(fieldNumProjForecastEmplCategoryId);
            projBudgetManagerParmArgs.parmFieldNumActivityNumber(fieldNumProjForecastEmplActivityNumber);
            projBudgetManagerParmArgs.parmForecastModelId(_forecastModelId);
            projBudgetManagerParmArgs.parmProjId(projForecastEmplGroup.ProjId);
            projBudgetManagerParmArgs.parmCategoryId(projForecastEmplGroup.CategoryId);
            projBudgetManagerParmArgs.parmProjCategoryId("");
            projBudgetManagerParmArgs.parmProjActivityNumber(projForecastEmplGroup.ActivityNumber);
            projBudgetManagerParmArgs.parmSummarizeByCategory(_summarizeByCategory);

            queryRun = new QueryRun(this.getQuery(projBudgetManagerParmArgs));

            while (queryRun.next())
            {
                projForecastEmpl = queryRun.get(tableNumProjForecastEmpl);
                projTrans        = ProjTrans::newProjForecastEmpl(projForecastEmpl);

                if (this.checkExchangeRate(currencyCode,projTrans))
                {
                    if (canImportRevenueBudget && this.checkProjTypeForForecastV2(projForecastEmpl.ProjId, projForecastEmpl.LinePropertyId, projForecastEmpl.CategoryId, ProjTransType::Hour))
                    {
                        transTurnover += this.markUpAmount(BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                                projForecastEmpl.indirectSalesTotal(),
                                                projTrans.currencyIdSales(),
                                                DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                                                _markUpUnits,
                                                0.0,
                                                _markUpRevenue);

                        // Create budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionRevLineRecId == 0)
                            {
                                projBudgetRevisionRevLineRecId = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecId, _projBudgetRevision);
                            }
                            this.createBudgetLineDetail(projBudgetLineRevenueRecId,
                                    projTrans,
                                    ProjBudgetLineType::Revenue,
                                    _markUpUnits,
                                    _markUpCosts,
                                    _markUpRevenue,
                                    projBudgetRevisionRevLineRecId);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineRevenueRecId, projTrans, ProjBudgetLineType::Revenue, _markUpUnits, _markUpCosts, _markUpRevenue);
                        }
                    }

                    transCost += this.markUpAmount(BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                        projForecastEmpl.indirectCostTotal(),
                                        projTrans.currencyIdCost(),
                                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                                        _markUpUnits,
                                        _markUpCosts,
                                        0.0);

                    // Create budget line detail
                    if (_projBudgetRevision)
                    {
                        if (projBudgetRevisionCostLineRecId == 0)
                        {
                            projBudgetRevisionCostLineRecId = this.createRevisionLineIfNotExists(projBudgetLineCostRecId, _projBudgetRevision);
                        }
                        this.createBudgetLineDetail(projBudgetLineCostRecId,
                                projTrans,
                                ProjBudgetLineType::Cost,
                                _markUpUnits,
                                _markUpCosts,
                                _markUpRevenue,
                                projBudgetRevisionCostLineRecId);
                    }
                    else
                    {
                        this.createBudgetLineDetail(projBudgetLineCostRecId, projTrans, ProjBudgetLineType::Cost, _markUpUnits, _markUpCosts, _markUpRevenue);
                    }
                }
            }

            if (transTurnover != 0)
            {
                this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecId, _projBudgetRevision, transTurnover);
            }
            else if (canImportRevenueBudget)
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecId, _projBudgetRevision);
            }
            if (transCost != 0)
            {
                this.updateProjBudgetLinesWithAmt(projBudgetLineCostRecId, _projBudgetRevision, transCost);
            }
            else
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineCostRecId, _projBudgetRevision);
            }
        }

        //Expense
        groupQueryRun = new QueryRun(this.getQueryWithGroupByClause(
                            tableNumProjForecastCost,
                            fieldNumProjForecastCostModelId,
                            fieldNumProjForecastCostProjId,
                            fieldNumProjForecastCostCategoryId,
                            fieldNumProjForecastCostActivityNumber,
                            _forecastModelId,
                            projIdQueryValue,
                            _summarizeByCategory));

        while (groupQueryRun.next())
        {
            projForecastCostGroup           = groupQueryRun.get(tableNumProjForecastCost);
            transCost                       = 0;
            transTurnover                   = 0;
            projBudgetRevisionRevLineRecId  = 0;
            projBudgetRevisionCostLineRecId = 0;

            if (projCanImportRevenueBudgetMap.exists(projForecastCostGroup.ProjId))
            {
                canImportRevenueBudget = projCanImportRevenueBudgetMap.lookup(projForecastCostGroup.ProjId);
            }
            else
            {
                canImportRevenueBudget = this.canImportRevenueBudgetV2(ProjTable::find(projForecastCostGroup.ProjId));
                projCanImportRevenueBudgetMap.insert(projForecastCostGroup.ProjId, canImportRevenueBudget);
            }

            if (canImportRevenueBudget)
            {
                projBudgetLineRevenueRecId = this.createBudgetLineIfNotExists(
                                                    projForecastCostGroup.CategoryId,
                                                    ProjTransType::Cost,
                                                    transTurnover,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    projForecastCostGroup.ProjId,
                                                    !_summarizeByCategory ? projForecastCostGroup.ActivityNumber : '',
                                                    _projBudgetRevision);
            }

            projBudgetLineCostRecId = this.createBudgetLineIfNotExists(
                                                projForecastCostGroup.CategoryId,
                                                ProjTransType::Cost,
                                                transCost,
                                                ProjBudgetLineType::Cost,
                                                _projBudgetId,
                                                projForecastCostGroup.ProjId,
                                                !_summarizeByCategory ? projForecastCostGroup.ActivityNumber : '',
                                                _projBudgetRevision);

            ProjBudgetManagerParmArgs projBudgetManagerParmArgs = ProjBudgetManagerParmArgs::construct();
            projBudgetManagerParmArgs.parmTableId(tableNumProjForecastCost);
            projBudgetManagerParmArgs.parmFieldNumForecastModelId(fieldNumProjForecastCostModelId);
            projBudgetManagerParmArgs.parmFieldNumProjId(fieldNumProjForecastCostProjId);
            projBudgetManagerParmArgs.parmFieldNumCategoryId(fieldNumProjForecastCostCategoryId);
            projBudgetManagerParmArgs.parmFieldNumActivityNumber(fieldNumProjForecastCostActivityNumber);
            projBudgetManagerParmArgs.parmForecastModelId(_forecastModelId);
            projBudgetManagerParmArgs.parmProjId(projForecastCostGroup.ProjId);
            projBudgetManagerParmArgs.parmCategoryId(projForecastCostGroup.CategoryId);
            projBudgetManagerParmArgs.parmProjCategoryId("");
            projBudgetManagerParmArgs.parmProjActivityNumber(projForecastCostGroup.ActivityNumber);
            projBudgetManagerParmArgs.parmSummarizeByCategory(_summarizeByCategory);

            queryRun = new QueryRun(this.getQuery(projBudgetManagerParmArgs));

            while (queryRun.next())
            {
                projForecastCost = queryRun.get(tableNumProjForecastCost);
                   
                if (ProjForecastCost::canCreateTransBudget(projForecastCost))
                {
                    projTrans = ProjTrans::newProjForecastCost(projForecastCost);

                    if (this.checkExchangeRate(currencyCode,projTrans))
                    {
                        if (canImportRevenueBudget && this.checkProjTypeForForecastV2(projForecastCost.ProjId, projForecastCost.LinePropertyId, projForecastCost.CategoryId, ProjTransType::Cost))
                        {
                            transTurnover  +=
                                this.markUpAmount(BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                    projTrans.transTurnover(),
                                    projTrans.currencyIdSales(),
                                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                                    _markUpUnits,
                                    0.0,
                                    _markUpRevenue);

                            // Create budget line detail
                            if (_projBudgetRevision)
                            {
                                if (projBudgetRevisionRevLineRecId == 0)
                                {
                                    projBudgetRevisionRevLineRecId = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecId, _projBudgetRevision);
                                }
                                this.createBudgetLineDetail(projBudgetLineRevenueRecId,
                                    projTrans,
                                    ProjBudgetLineType::Revenue,
                                    _markUpUnits,
                                    _markUpCosts,
                                    _markUpRevenue,
                                    projBudgetRevisionRevLineRecId);
                            }
                            else
                            {
                                this.createBudgetLineDetail(projBudgetLineRevenueRecId, projTrans, ProjBudgetLineType::Revenue, _markUpUnits, _markUpCosts, _markUpRevenue);
                            }
                        }

                        transCost      +=
                            this.markUpAmount(BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                projTrans.transCost(),
                                projTrans.currencyIdCost(),
                                DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                                _markUpUnits,
                                _markUpCosts,
                                0.0);

                        // Create budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionCostLineRecId == 0)
                            {
                                projBudgetRevisionCostLineRecId = this.createRevisionLineIfNotExists(projBudgetLineCostRecId, _projBudgetRevision);
                            }

                            this.createBudgetLineDetail(projBudgetLineCostRecId,
                                projTrans,
                                ProjBudgetLineType::Cost,
                                _markUpUnits,
                                _markUpCosts,
                                _markUpRevenue,
                                projBudgetRevisionCostLineRecId);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineCostRecId, projTrans, ProjBudgetLineType::Cost, _markUpUnits, _markUpCosts, _markUpRevenue);
                        }
                    }
                }
            }

            if (transTurnover != 0)
            {
                this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecId, _projBudgetRevision, transTurnover);
            }
            else if (canImportRevenueBudget)
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecId, _projBudgetRevision);
            }
            if (transCost != 0)
            {
                this.updateProjBudgetLinesWithAmt(projBudgetLineCostRecId, _projBudgetRevision, transCost);
            }
            else
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineCostRecId, _projBudgetRevision);
            }
        }

        //Item
        groupQueryRun = new QueryRun(this.getQueryWithGroupByClause(
                            tableNumForecastSales,
                            fieldNumForecastSalesModelId,
                            fieldNumForecastSalesProjId,
                            fieldNumForecastSalesProjCategoryId,
                            fieldNumForecastSalesActivityNumber,
                            _forecastModelId,
                            projIdQueryValue,
                            _summarizeByCategory));

        while (groupQueryRun.next())
        {
            forecastSalesGroup              = groupQueryRun.get(tableNumForecastSales);
            transCost                       = 0;
            transTurnover                   = 0;
            projBudgetRevisionRevLineRecId  = 0;
            projBudgetRevisionCostLineRecId = 0;

            if (projCanImportRevenueBudgetMap.exists(forecastSalesGroup.ProjId))
            {
                canImportRevenueBudget = projCanImportRevenueBudgetMap.lookup(forecastSalesGroup.ProjId);
            }
            else
            {
                canImportRevenueBudget = this.canImportRevenueBudgetV2(ProjTable::find(forecastSalesGroup.ProjId));
                projCanImportRevenueBudgetMap.insert(forecastSalesGroup.ProjId,canImportRevenueBudget);
            }

            if (canImportRevenueBudget)
            {
                projBudgetLineRevenueRecId = this.createBudgetLineIfNotExists(
                                                    forecastSalesGroup.ProjCategoryId,
                                                    ProjTransType::Item,
                                                    transTurnover,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    forecastSalesGroup.ProjId,
                                                    !_summarizeByCategory ? forecastSalesGroup.ActivityNumber : '',
                                                    _projBudgetRevision);
            }

            projBudgetLineCostRecId = this.createBudgetLineIfNotExists(
                                                forecastSalesGroup.ProjCategoryId,
                                                ProjTransType::Item,
                                                transCost,
                                                ProjBudgetLineType::Cost,
                                                _projBudgetId,
                                                forecastSalesGroup.ProjId,
                                                !_summarizeByCategory ? forecastSalesGroup.ActivityNumber : '',
                                                _projBudgetRevision);

            ProjBudgetManagerParmArgs projBudgetManagerParmArgs = ProjBudgetManagerParmArgs::construct();
            projBudgetManagerParmArgs.parmTableId(tableNumForecastSales);
            projBudgetManagerParmArgs.parmFieldNumForecastModelId(fieldNumForecastSalesModelId);
            projBudgetManagerParmArgs.parmFieldNumProjId(fieldNumForecastSalesProjId);
            projBudgetManagerParmArgs.parmFieldNumCategoryId(fieldNumForecastSalesProjCategoryId);
            projBudgetManagerParmArgs.parmFieldNumActivityNumber(fieldNumForecastSalesActivityNumber);
            projBudgetManagerParmArgs.parmForecastModelId(_forecastModelId);
            projBudgetManagerParmArgs.parmProjId(forecastSalesGroup.ProjId);
            projBudgetManagerParmArgs.parmCategoryId("");
            projBudgetManagerParmArgs.parmProjCategoryId(forecastSalesGroup.ProjCategoryId);
            projBudgetManagerParmArgs.parmProjActivityNumber(forecastSalesGroup.ActivityNumber);
            projBudgetManagerParmArgs.parmSummarizeByCategory(_summarizeByCategory);

            queryRun = new QueryRun(this.getQuery(projBudgetManagerParmArgs));

            while (queryRun.next())
            {
                forecastSales   = queryRun.get(tableNumForecastSales);

                if (ForecastSales::canCreateTransBudget(forecastSales))
                {
                    projTrans = ProjTrans::newForecastSales(forecastSales);

                    if (this.checkExchangeRate(currencyCode,projTrans))
                    {
                        if (canImportRevenueBudget && this.checkProjTypeForForecastV2(forecastSales.ProjId, forecastSales.ProjLinePropertyId, forecastSales.ProjCategoryId, ProjTransType::Item))
                        {
                            transTurnover  +=
                                this.markUpAmount(BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                    projTrans.transTurnover(),
                                    projTrans.currencyIdSales(),
                                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                                    _markUpUnits,
                                    0.0,
                                    _markUpRevenue);

                            // Create budget line detail
                            if (_projBudgetRevision)
                            {
                                if (projBudgetRevisionRevLineRecId == 0)
                                {
                                    projBudgetRevisionRevLineRecId = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecId, _projBudgetRevision);
                                }

                                this.createBudgetLineDetail(projBudgetLineRevenueRecId,
                                    projTrans,
                                    ProjBudgetLineType::Revenue,
                                    _markUpUnits,
                                    _markUpCosts,
                                    _markUpRevenue,
                                    projBudgetRevisionRevLineRecId);
                            }
                            else
                            {
                                this.createBudgetLineDetail(projBudgetLineRevenueRecId, projTrans, ProjBudgetLineType::Revenue, _markUpUnits, _markUpCosts, _markUpRevenue);
                            }
                        }
                        transCost      +=
                            this.markUpAmount(BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                projTrans.transCost(),
                                projTrans.currencyIdCost(),
                                DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                                _markUpUnits,
                                _markUpCosts,
                                0.0);

                        // Create budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionCostLineRecId == 0)
                            {
                                projBudgetRevisionCostLineRecId = this.createRevisionLineIfNotExists(projBudgetLineCostRecId, _projBudgetRevision);
                            }

                            this.createBudgetLineDetail(projBudgetLineCostRecId,
                                    projTrans,
                                    ProjBudgetLineType::Cost,
                                    _markUpUnits,
                                    _markUpCosts,
                                    _markUpRevenue,
                                    projBudgetRevisionCostLineRecId);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineCostRecId, projTrans, ProjBudgetLineType::Cost, _markUpUnits, _markUpCosts, _markUpRevenue);
                        }
                    }
                }
            }

            if (transTurnover != 0)
            {
                this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecId, _projBudgetRevision, transTurnover);
            }
            else if (canImportRevenueBudget)
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecId, _projBudgetRevision);
            }
            if (transCost != 0)
            {
                this.updateProjBudgetLinesWithAmt(projBudgetLineCostRecId, _projBudgetRevision, transCost);
            }
            else
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineCostRecId, _projBudgetRevision);
            }
        }

        //Fee transactions
        groupQueryRun = new QueryRun(this.getQueryWithGroupByClause(
                                tableNumForecastRevenue,
                                fieldNumForecastRevenueModelId,
                                fieldNumForecastRevenueProjId,
                                fieldNumForecastRevenueProjCategoryId,
                                fieldNumForecastRevenueActivityNumber,
                                _forecastModelId,
                                projIdQueryValue,
                                _summarizeByCategory));
          
        while (groupQueryRun.next())
        {
            projForecastRevenueGroup            = groupQueryRun.get(tableNumForecastRevenue);
            transTurnover                       = this.transTurnoverFeeTransactions(0);
            projBudgetRevisionRevLineRecId      = 0;
            
            if (projCanImportRevenueBudgetMap.exists(projForecastRevenueGroup.ProjId))
            {
                canImportRevenueBudget = projCanImportRevenueBudgetMap.lookup(projForecastRevenueGroup.ProjId);
            }
            else
            {
                canImportRevenueBudget = this.canImportRevenueBudgetV2(ProjTable::find(projForecastRevenueGroup.ProjId));
                projCanImportRevenueBudgetMap.insert(projForecastRevenueGroup.ProjId,canImportRevenueBudget);
            }

            if (canImportRevenueBudget && !this.isTargetProjTypeFixedPriceV2(projTable::find((projForecastRevenueGroup.ProjId))))
            {
                projBudgetLineRevenueRecId = this.createBudgetLineIfNotExists(
                                                    projForecastRevenueGroup.CategoryId,
                                                    ProjTransType::Revenue,
                                                    transTurnover,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    projForecastRevenueGroup.ProjId,
                                                    projForecastRevenueGroup.ActivityNumber,
                                                    _projBudgetRevision);

                ProjBudgetManagerParmArgs projBudgetManagerParmArgs = ProjBudgetManagerParmArgs::construct();
                projBudgetManagerParmArgs.parmTableId(tableNumForecastRevenue);
                projBudgetManagerParmArgs.parmFieldNumForecastModelId(fieldNumForecastRevenueModelId);
                projBudgetManagerParmArgs.parmFieldNumProjId(fieldNumForecastRevenueProjId);
                projBudgetManagerParmArgs.parmFieldNumCategoryId(fieldNumForecastRevenueProjCategoryId);
                projBudgetManagerParmArgs.parmFieldNumActivityNumber(fieldNumForecastRevenueActivityNumber);
                projBudgetManagerParmArgs.parmForecastModelId(_forecastModelId);
                projBudgetManagerParmArgs.parmProjId(projForecastRevenueGroup.ProjId);
                projBudgetManagerParmArgs.parmCategoryId(projForecastRevenueGroup.CategoryId);
                projBudgetManagerParmArgs.parmProjCategoryId("");
                projBudgetManagerParmArgs.parmProjActivityNumber(projForecastRevenueGroup.ActivityNumber);
                projBudgetManagerParmArgs.parmSummarizeByCategory(_summarizeByCategory);

                queryRun = new QueryRun(this.getQuery(projBudgetManagerParmArgs));
                
                while (queryRun.next())
                {
                    projForecastRevenue = queryRun.get(tableNumForecastRevenue);
                                        
                    if (ProjForecastRevenue::canCreateTransBudget(projForecastRevenue))
                    {
                        projTrans = ProjTrans::newProjForecastRevenue(projForecastRevenue);
                   
                        if (this.checkExchangeRate(currencyCode, projTrans) &&
                            ProjLineProperty::find(projForecastRevenue.LinePropertyId).ToBeInvoiced &&
                            ProjInvoiceTable::isBillingRuleInvoiceable(projForecastRevenue.ProjId, projForecastRevenue.CategoryId, '', projTrans.transType()))
                        {
                            transTurnover  += BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transTurnover(),projTrans.currencyIdSales(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                            //Create budget line detail
                            if (_projBudgetRevision)
                            {
                                if (projBudgetRevisionRevLineRecId == 0)
                                {
                                    projBudgetRevisionRevLineRecId = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecId, _projBudgetRevision);
                                }

                                this.createBudgetLineDetail(projBudgetLineRevenueRecId,
                                    projTrans,
                                    ProjBudgetLineType::Revenue,
                                    0.0, //No Markups for Fee
                                    0.0,
                                    0.0,
                                    projBudgetRevisionRevLineRecId);
                            }
                            else
                            {
                                this.createBudgetLineDetail(projBudgetLineRevenueRecId,
                                    projTrans,
                                    ProjBudgetLineType::Revenue);
                            }
                        }
                    }
                }

                if (transTurnover != 0)
                {
                    this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecId, _projBudgetRevision, transTurnover);
                }
                else
                {
                    this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecId, _projBudgetRevision);
                }
            }
        }

        projIdEnumerator = new MapEnumerator(projCanImportRevenueBudgetMap);
        while (projIdEnumerator.moveNext())
        {
            this.updateBudgetSource(projIdEnumerator.currentKey(), _projBudgetId, ProjBaseBudgetOn::Forecast, _projBudgetRevision, _forecastModelId, "");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTypeForForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether budget line detail can be created for forecast.
    /// </summary>
    /// <param name = "_projId">
    ///     Forecast project ID.
    /// </param>
    /// <param name = "_projLinePropertyId">
    ///     Forecast line property ID
    /// </param>
    /// <param name = "_projCategoryId">
    ///     Forecast project category ID.
    /// </param>
    /// <returns>
    ///     true if budget line detail can be created for forecast; otherwise, false.
    /// </returns>
    protected boolean checkProjTypeForForecast(ProjId _projId, ProjLinePropertyId _projLinePropertyId, ProjCategoryId _projCategoryId)
    {
        return ProjTable::find(_projId).Type == ProjType::FixedPrice || (ProjLineProperty::find(_projLinePropertyId).ToBeInvoiced  &&
                            ProjInvoiceTable::isBillingRuleInvoiceable(_projId, _projCategoryId, ''));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTypeForForecastV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether budget line detail can be created for forecast.
    /// </summary>
    /// <param name = "_projId">Forecast project ID.</param>
    /// <param name = "_projLinePropertyId">Forecast line property ID.</param>
    /// <param name = "_projCategoryId">Forecast project category ID.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <returns>
    /// true if budget line detail can be created for forecast; otherwise, false.
    /// </returns>
    protected boolean checkProjTypeForForecastV2(ProjId _projId, ProjLinePropertyId _projLinePropertyId, ProjCategoryId _projCategoryId, ProjTransType _projTransType)
    {
        boolean ret = false;
        
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjTable projTableLocal = ProjTable::find(_projId);

            ret = ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_projId, projTableLocal.ProjInvoiceProjId, _projTransType, ProjContractBillingMethod::FixedPrice) ||
                    (ProjLineProperty::find(_projLinePropertyId).ToBeInvoiced && ProjInvoiceTable::isBillingRuleInvoiceable(_projId, _projCategoryId, ''));
        }
        else
        {
            ret = this.checkProjTypeForForecast(_projId, _projLinePropertyId, _projCategoryId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTurnoverFeeTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns fee transaction turnover amount.
    /// </summary>
    /// <param name = "_transTurnover">Turnover amount.</param>
    /// <returns>
    /// Returns turnover amount.
    /// </returns>
    protected AmountCur transTurnoverFeeTransactions(AmountCur _transTurnover)
    {
        return _transTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetFromTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the category budget rows in the <c>ProjBudgetLine</c> table by using the transaction with
    /// the specified project ID.
    /// </summary>
    /// <param name="_sourceProjId">
    /// A <c>ProjId</c> value that determines the project that has transactions to use for budget rows
    /// creation.
    /// </param>
    /// <param name="_projBudgetId">
    /// A record ID that specifies the project budget for which to create budget rows.
    /// </param>
    /// <param name="_targetProjId">
    /// A <c>ProjId</c> that specifies the project for which transactions needs to be loaded.
    /// </param>
    /// <param name="_markUpUnits">
    /// A <c>MarkUpValue</c> that specifies the markup percentage for units.
    /// </param>
    /// <param name="_markUpCosts">
    /// A <c>MarkUpValue</c> that specifies the markup percentage for costs.
    /// </param>
    /// <param name="_markUpRevenue">
    /// A <c>MarkUpValue</c> that specifies the markup percentage for revenue.
    /// </param>
    /// <param name="_projBudgetRevision">
    /// A <c>RecId</c> value that specifies the project budget revision for which to create budget revision rows.
    /// </param>
    public void createBudgetFromTransaction(
        ProjId         _sourceProjId,
        RecId          _projBudgetId,
        ProjId         _targetProjId        = '',
        MarkupValue    _markUpUnits         = 0.0,
        MarkupValue    _markUpCosts         = 0.0,
        MarkupValue    _markUpRevenue       = 0.0,
        RecId          _projBudgetRevision  = 0)
    {
        ProjBudgetLine      projBudgetLine;
        ProjEmplTrans       projEmplTrans;
        ProjEmplTrans       projEmplTransSum;
        ProjCostTrans       projCostTrans;
        ProjCostTrans       projCostTransSum;
        ProjItemTrans       projItemTrans;
        ProjItemTrans       projItemTransSum;
        ProjRevenueTrans    projRevenueTrans;
        ProjRevenueTrans    projRevenueTransSum;
        ProjTrans           projTrans;
        ProjBudget          projBudget;
        RecId               projBudgetRevisionRevLineRecid;
        RecId               projBudgetRevisionCostLineRecid;
        AmountCur           sumOfSaleCategory;
        AmountCur           sumOfCostCategory;
        CurrencyCode        currencyCode;
        RefRecId            projBudgetLineCostRecid;
        RefRecId            projBudgetLineRevenueRecid;
        boolean             canImportRevenueBudget;

        ProjTable targetProjTable = ProjTable::find(_targetProjId);

        canImportRevenueBudget = this.canImportRevenueBudgetV2(targetProjTable);

        currencyCode = Ledger::accountingCurrency(CompanyInfo::current());

        select RootProjId from projBudget where projBudget.RecId == _projBudgetId;

        if (_projBudgetRevision == 0)
        {
            delete_from projBudgetLine
                where  projBudgetLine.ProjId == _targetProjId;
        }
        else
        {
            this.deleteBudgetLinesBeforeImportForRevs(_projBudgetRevision, _projBudgetId, _targetProjId, false);
        }

        //Hour
        while select CategoryId from projEmplTrans
        group by projEmplTrans.CategoryId
        where projEmplTrans.ProjId == _sourceProjId
        {
            sumOfSaleCategory = 0;
            sumOfCostCategory = 0;
            projBudgetRevisionRevLineRecid  = 0;
            projBudgetRevisionCostLineRecid = 0;

            if (canImportRevenueBudget)
            {
                projBudgetLineRevenueRecid = this.createBudgetLineIfNotExists(
                                                    projEmplTrans.CategoryId,
                                                    ProjTransType::Hour,
                                                    sumOfSaleCategory,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    _targetProjId ? _targetProjId : projBudget.RootProjId,
                                                    '',
                                                    _projBudgetRevision);
            }

            projBudgetLineCostRecid = this.createBudgetLineIfNotExists(
                                                projEmplTrans.CategoryId,
                                                ProjTransType::Hour,
                                                sumOfCostCategory,
                                                ProjBudgetLineType::Cost,
                                                _projBudgetId,
                                                _targetProjId ? _targetProjId : projBudget.RootProjId,
                                                '',
                                                _projBudgetRevision);

            while select projEmplTransSum
                where projEmplTransSum.ProjId == _sourceProjId
                && projEmplTransSum.CategoryId == projEmplTrans.CategoryId
            {
                projTrans = ProjTrans::newProjEmplTrans(projEmplTransSum);

                if (this.checkExchangeRate(currencyCode,projTrans))
                {
                    if (canImportRevenueBudget)
                    {
                        sumOfSaleCategory += BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transTurnover(),projTrans.currencyIdSales(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                        // Create revenue budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionRevLineRecid == 0)
                            {
                                projBudgetRevisionRevLineRecid = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecid, _projBudgetRevision);
                            }

                            this.createBudgetLineDetail(projBudgetLineRevenueRecid,
                                projTrans,
                                ProjBudgetLineType::Revenue,
                                _markUpUnits,
                                _markUpCosts,
                                _markUpRevenue,
                                projBudgetRevisionRevLineRecid);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineRevenueRecid, projTrans, ProjBudgetLineType::Revenue, _markUpUnits, _markUpCosts, _markUpRevenue);
                        }
                    }

                    sumOfCostCategory +=  BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transCost(),projTrans.currencyIdCost(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    if (_projBudgetRevision)
                    {
                        if (projBudgetRevisionCostLineRecid == 0)
                        {
                            projBudgetRevisionCostLineRecid = this.createRevisionLineIfNotExists(projBudgetLineCostRecid, _projBudgetRevision);
                        }

                        this.createBudgetLineDetail(projBudgetLineCostRecid,
                            projTrans,
                            ProjBudgetLineType::Cost,
                            _markUpUnits,
                            _markUpCosts,
                            _markUpRevenue,
                            projBudgetRevisionCostLineRecid);
                    }
                    else
                    {
                        this.createBudgetLineDetail(projBudgetLineCostRecid, projTrans, ProjBudgetLineType::Cost, _markUpUnits, _markUpCosts, _markUpRevenue);
                    }
                }
            }

            if (sumOfSaleCategory != 0)
            {
                sumOfSaleCategory = this.markUpAmount(
                                                    sumOfSaleCategory,
                                                    _markUpUnits,
                                                    0.0,
                                                    _markUpRevenue);

                this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecid, _projBudgetRevision, sumOfSaleCategory);
            }
            else if (canImportRevenueBudget)
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecid, _projBudgetRevision);
            }

            if (sumOfCostCategory != 0)
            {
                sumOfCostCategory = this.markUpAmount(
                                                    sumOfCostCategory,
                                                    _markUpUnits,
                                                    _markUpCosts,
                                                    0.0);

                this.updateProjBudgetLinesWithAmt(projBudgetLineCostRecid, _projBudgetRevision, sumOfCostCategory);
            }
            else
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineCostRecid, _projBudgetRevision);
            }
        }

        //Expense
        while select CategoryId from projCostTrans
        group by projCostTrans.CategoryId
        where projCostTrans.ProjId == _sourceProjId
        {
            sumOfSaleCategory = 0;
            sumOfCostCategory = 0;
            projBudgetRevisionRevLineRecid  = 0;
            projBudgetRevisionCostLineRecid = 0;

            if (canImportRevenueBudget)
            {
                projBudgetLineRevenueRecid = this.createBudgetLineIfNotExists(
                                                    projCostTrans.CategoryId,
                                                    ProjTransType::Cost,
                                                    sumOfSaleCategory,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    _targetProjId ? _targetProjId : projBudget.RootProjId,
                                                    '',
                                                    _projBudgetRevision);
            }

            projBudgetLineCostRecid = this.createBudgetLineIfNotExists(
                                                projCostTrans.CategoryId,
                                                ProjTransType::Cost,
                                                sumOfCostCategory,
                                                ProjBudgetLineType::Cost,
                                                _projBudgetId,_targetProjId ? _targetProjId : projBudget.RootProjId,
                                                '',
                                                _projBudgetRevision);

            while select projCostTransSum
                where projCostTransSum.ProjId  == _sourceProjId
                && projCostTransSum.CategoryId == projCostTrans.CategoryId
            {
                projTrans = ProjTrans::newProjCostTrans(projCostTransSum);

                if (this.checkExchangeRate(currencyCode,projTrans))
                {
                    if (canImportRevenueBudget)
                    {
                        sumOfSaleCategory += BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transTurnover(),projTrans.currencyIdSales(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                        // Create Revenue budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionRevLineRecid == 0)
                            {
                                projBudgetRevisionRevLineRecid = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecid, _projBudgetRevision);
                            }

                            this.createBudgetLineDetail(projBudgetLineRevenueRecid,
                                projTrans,
                                ProjBudgetLineType::Revenue,
                                _markUpUnits,
                                _markUpCosts,
                                _markUpRevenue,
                                projBudgetRevisionRevLineRecid);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineRevenueRecid, projTrans, ProjBudgetLineType::Revenue, _markUpUnits, _markUpCosts, _markUpRevenue);
                        }
                    }

                    sumOfCostCategory +=  BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transCost(),projTrans.currencyIdCost(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    if (_projBudgetRevision)
                    {
                        if (projBudgetRevisionCostLineRecid == 0)
                        {
                            projBudgetRevisionCostLineRecid = this.createRevisionLineIfNotExists(projBudgetLineCostRecid, _projBudgetRevision);
                        }

                        this.createBudgetLineDetail(projBudgetLineCostRecid,
                            projTrans,
                            ProjBudgetLineType::Cost,
                            _markUpUnits,
                            _markUpCosts,
                            _markUpRevenue,
                            projBudgetRevisionCostLineRecid);
                    }
                    else
                    {
                        this.createBudgetLineDetail(projBudgetLineCostRecid, projTrans, ProjBudgetLineType::Cost, _markUpUnits, _markUpCosts, _markUpRevenue);
                    }
                }
            }

            if (sumOfSaleCategory != 0)
            {
                sumOfSaleCategory = this.markUpAmount(
                                                    sumOfSaleCategory,
                                                    _markUpUnits,
                                                    0.0,
                                                    _markUpRevenue);

                this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecid, _projBudgetRevision, sumOfSaleCategory);
            }
            else if (canImportRevenueBudget)
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecid, _projBudgetRevision);
            }

            if (sumOfCostCategory != 0)
            {
                sumOfCostCategory = this.markUpAmount(
                                                    sumOfCostCategory,
                                                    _markUpUnits,
                                                    _markUpCosts,
                                                    0.0);

                this.updateProjBudgetLinesWithAmt(projBudgetLineCostRecid, _projBudgetRevision, sumOfCostCategory);
            }
            else
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineCostRecid, _projBudgetRevision);
            }
        }

        //Item
        while select CategoryId from projItemTrans
        group by projItemTrans.CategoryId
        where projItemTrans.ProjId == _sourceProjId
        {
            sumOfSaleCategory = 0;
            sumOfCostCategory = 0;
            projBudgetRevisionRevLineRecid  = 0;
            projBudgetRevisionCostLineRecid = 0;

            if (canImportRevenueBudget)
            {
                projBudgetLineRevenueRecid = this.createBudgetLineIfNotExists(
                                                    projItemTrans.CategoryId,
                                                    ProjTransType::Item,
                                                    sumOfSaleCategory,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,
                                                    _targetProjId ? _targetProjId : projBudget.RootProjId,
                                                    '',
                                                    _projBudgetRevision);
            }

            projBudgetLineCostRecid = this.createBudgetLineIfNotExists(
                                                projItemTrans.CategoryId,
                                                ProjTransType::Item,
                                                sumOfCostCategory,
                                                ProjBudgetLineType::Cost,
                                                _projBudgetId,_targetProjId ? _targetProjId : projBudget.RootProjId,
                                                '',
                                                _projBudgetRevision);

            while select projItemTransSum
            where projItemTransSum.ProjId == _sourceProjId
            && projItemTransSum.CategoryId == projItemTrans.CategoryId
            {
                projTrans = ProjTrans::newProjItemTrans(projItemTransSum);

                if (this.checkExchangeRate(currencyCode,projTrans))
                {
                    if (canImportRevenueBudget)
                    {
                        sumOfSaleCategory += BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transTurnover(),projTrans.currencyIdSales(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                        // Create budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionRevLineRecid == 0)
                            {
                                projBudgetRevisionRevLineRecid = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecid, _projBudgetRevision);
                            }
                            this.createBudgetLineDetail(projBudgetLineRevenueRecid,
                                    projTrans,
                                    ProjBudgetLineType::Revenue,
                                    _markUpUnits,
                                    _markUpCosts,
                                    _markUpRevenue,
                                    projBudgetRevisionRevLineRecid);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineRevenueRecid, projTrans, ProjBudgetLineType::Revenue, _markUpUnits, _markUpCosts, _markUpRevenue);
                        }
                    }

                    sumOfCostCategory +=  BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transCost(),projTrans.currencyIdCost(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    if (_projBudgetRevision)
                    {
                        if (projBudgetRevisionCostLineRecid == 0)
                        {
                            projBudgetRevisionCostLineRecid = this.createRevisionLineIfNotExists(projBudgetLineCostRecid, _projBudgetRevision);
                        }

                        this.createBudgetLineDetail(projBudgetLineCostRecid,
                                projTrans,
                                ProjBudgetLineType::Cost,
                                _markUpUnits,
                                _markUpCosts,
                                _markUpRevenue,
                                projBudgetRevisionCostLineRecid);
                    }
                    else
                    {
                        this.createBudgetLineDetail(projBudgetLineCostRecid, projTrans, ProjBudgetLineType::Cost, _markUpUnits, _markUpCosts, _markUpRevenue);
                    }
                }
            }

            if (sumOfSaleCategory != 0)
            {
                sumOfSaleCategory = this.markUpAmount(
                                                    sumOfSaleCategory,
                                                    _markUpUnits,
                                                    0.0,
                                                    _markUpRevenue);

                this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecid, _projBudgetRevision, sumOfSaleCategory);
            }
            else if (canImportRevenueBudget)
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecid, _projBudgetRevision);
            }

            if (sumOfCostCategory != 0)
            {
                sumOfCostCategory = this.markUpAmount(
                                                    sumOfCostCategory,
                                                    _markUpUnits,
                                                    _markUpCosts,
                                                    0.0);

                this.updateProjBudgetLinesWithAmt(projBudgetLineCostRecid, _projBudgetRevision, sumOfCostCategory);
            }
            else
            {
                this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineCostRecid, _projBudgetRevision);
            }
        }

        if (canImportRevenueBudget && !this.isTargetProjTypeFixedPriceV2(targetProjTable))
        {
            while select CategoryId from  projRevenueTrans
            group by projRevenueTrans.CategoryId
            where projRevenueTrans.ProjId == _sourceProjId
            {
                sumOfSaleCategory = 0;
                projBudgetRevisionRevLineRecid  = 0;

                projBudgetLineRevenueRecid = this.createBudgetLineIfNotExists(
                                                    projRevenueTrans.CategoryId,
                                                    ProjTransType::Revenue,
                                                    sumOfSaleCategory,
                                                    ProjBudgetLineType::Revenue,
                                                    _projBudgetId,_targetProjId ? _targetProjId : projBudget.RootProjId,
                                                    '',
                                                    _projBudgetRevision);

                while select projRevenueTransSum
                    where projRevenueTransSum.ProjId    == _sourceProjId
                    && projRevenueTransSum.CategoryId   == projRevenueTrans.CategoryId
                {
                    projTrans = ProjTrans::newProjRevenueTrans(projRevenueTransSum);

                    if (this.checkExchangeRate(currencyCode,projTrans))
                    {
                        sumOfSaleCategory += BudgetTransactionManager::calculateTransAmountToAccountingAmount(projTrans.transTurnover(),projTrans.currencyIdSales(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                        //Create budget line detail
                        if (_projBudgetRevision)
                        {
                            if (projBudgetRevisionRevLineRecid == 0)
                            {
                                projBudgetRevisionRevLineRecid = this.createRevisionLineIfNotExists(projBudgetLineRevenueRecid, _projBudgetRevision);
                            }

                            this.createBudgetLineDetail(projBudgetLineRevenueRecid,
                                        projTrans,
                                        ProjBudgetLineType::Revenue,
                                        0.0, //No Markups for Fee
                                        0.0,
                                        0.0,
                                        projBudgetRevisionRevLineRecid);
                        }
                        else
                        {
                            this.createBudgetLineDetail(projBudgetLineRevenueRecid,
                                projTrans,
                                ProjBudgetLineType::Revenue);
                        }
                    }
                }

                if (sumOfSaleCategory != 0)
                {
                    this.updateProjBudgetLinesWithAmt(projBudgetLineRevenueRecid, _projBudgetRevision, sumOfSaleCategory);
                }
                else
                {
                    this.deleteProjBudgetLinesWhenZeroAmount(projBudgetLineRevenueRecid, _projBudgetRevision);
                }
            }
        }

        this.updateBudgetSource(_targetProjId, _projBudgetId, ProjBaseBudgetOn::ProjectTransactions, _projBudgetRevision, "", _sourceProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTargetProjTypeFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the project type to create budget line detail.
    /// </summary>
    /// <param name = "_targetProjType">
    ///     The project type.
    /// </param>
    /// <returns>
    ///     true if the project type is fixed price; otherwise, false.
    /// </returns>
    protected boolean isTargetProjTypeFixedPrice(ProjType _targetProjType)
    {
        return _targetProjType == ProjType::FixedPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTargetProjTypeFixedPriceV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the project to create budget line detail.
    /// </summary>
    /// <param name = "_targetProjTable">The project record.</param>
    /// <returns>
    /// true if the project type is fixed price or has FixedPrice billing method for revenue transaction type; otherwise, false.
    /// </returns>
    protected boolean isTargetProjTypeFixedPriceV2(ProjTable _targetProjTable)
    {
        boolean ret = false;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ret = ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_targetProjTable.ProjId, _targetProjTable.ProjInvoiceProjId, ProjTransType::Revenue, ProjContractBillingMethod::FixedPrice);
        }
        else
        {
            ret = this.isTargetProjTypeFixedPrice(_targetProjTable.Type);
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetLineDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes and inserts project budget line.
    /// </summary>
    /// <param name = "_projBudgetLineRecid">
    ///     A <c>RefRecId</c> value for the project budget line to be inserted.
    /// </param>
    /// <param name = "_projTrans">
    ///     A instance of <c>ProjTrans</c>
    /// </param>
    /// <param name = "_projBudgetLineType">
    ///     Type of the project budget line.
    /// </param>
    /// <param name = "_markUpUnits">
    ///     A <c>MarkUpValue</c> value that specifies the mark up percentage.
    /// </param>
    /// <param name = "_markUpCosts">
    ///     A <c>MarkupValue</c> value that specifies the mark up costs.
    /// </param>
    /// <param name = "_markUpRevenue">
    ///     A <c>MarkupValue</c> value that specifies the mark up revenue.
    /// </param>
    /// <param name = "_projBudgetRevisionLine">
    ///     A <c>RefRecId</c> value that specifies the project budget revision line.
    /// </param>
    /// <param name = "_allowNegativeLine">
    ///     A <c>boolean</c> value that indicates whether to allow negative project trans lines.
    /// </param>
    /// <returns>
    ///     A <c>RefRecId</c> value for the inserted project budget line.
    /// </returns>
    protected RefRecId createBudgetLineDetail(
        RefRecId            _projBudgetLineRecid,
        ProjTrans           _projTrans,
        ProjBudgetLineType  _projBudgetLineType,
        MarkupValue         _markUpUnits            = 0.0,
        MarkupValue         _markUpCosts            = 0.0,
        MarkupValue         _markUpRevenue          = 0.0,
        RefRecId            _projBudgetRevisionLine = 0,
        boolean             _allowNegativeLine      = false
        )
    {
        ProjBudgetLine          projBudgetLine;
        ProjBudgetLineDetail    projBudgetLineDetail;

        if (_projBudgetLineRecid)
        {
            projBudgetLine = ProjBudgetLine::find(_projBudgetLineRecid);
            if (projBudgetLine)
            {
                if ((_projBudgetLineType == ProjBudgetLineType::Cost && (_projTrans.costPrice() > 0 || (_allowNegativeLine && _projTrans.costPrice() < 0)))
                    || (_projBudgetLineType == ProjBudgetLineType::Revenue && (_projTrans.salesPrice() > 0 || (_allowNegativeLine && _projTrans.salesPrice() < 0))))
                {
                    projBudgetLineDetail.ProjBudgetLine = _projBudgetLineRecid;
                    if (_projBudgetRevisionLine)
                    {
                        projBudgetLineDetail.ProjBudgetRevisionLine = _projBudgetRevisionLine;
                    }

                    projBudgetLineDetail.Resource      = _projTrans.resource();
                    projBudgetLineDetail.ResourceCategory = _projTrans.resourceCategory();
                    if (_projBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        projBudgetLineDetail.CostPrice  =
                        BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                            _projTrans.costPrice(),
                            _projTrans.currencyIdCost(),
                            DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())) * (1 + _markUpCosts/100.00);
                    }
                    else
                    {
                        projBudgetLineDetail.SalesPrice =
                        BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                            _projTrans.salesPrice(),
                            _projTrans.currencyIdSales(),
                            DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())) * (1 + _markUpRevenue/100.00);
                    }
                    projBudgetLineDetail.Quantity       = _projTrans.qty() * (1 + _markUpUnits/100.00);
                    projBudgetLineDetail.ItemId         = _projTrans.itemId();
                    projBudgetLineDetail.SalesUnitId    = _projTrans.salesUnit();
                    projBudgetLineDetail.InventDimId    = _projTrans.inventDimId();
                    projBudgetLineDetail.insert();
                }
            }
        }

        return projBudgetLineDetail.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetLineIfNotExists</Name>
				<Source><![CDATA[
    private RecId createBudgetLineIfNotExists(
        CategoryId         _categoryId,
        ProjTransType      _projTransType,
        AmountCur          _originalAmount,
        ProjBudgetLineType _projBudgetLineType,
        RecId              _projBudget,
        ProjId             _projId,
        ProjActivityNumber _activityNumber,
        RecId              _projBudgetRevision = 0)
    {
        RecId projBudgetLineRecId = 0;

        if (_projBudgetRevision)
        {
            projBudgetLineRecId = ProjBudgetLine::findRecord(
                                    _projId,
                                    _projTransType,
                                    _categoryId,
                                    _projBudget,
                                    _projBudgetLineType,
                                    _activityNumber
                                    ).RecId;
        }

        if (projBudgetLineRecId == 0)
        {
            projBudgetLineRecId = this.insertProjBudgetLine(
            _categoryId,
            _projTransType,
            _originalAmount,
            _projBudgetLineType,
            _projBudget,
            _projId,
            _activityNumber);

            if (_projBudgetRevision)
            {
                this.createDefaultAllocation(ProjBudgetLine::find(projBudgetLineRecId), ProjBudgetState::Created);
            }
        }

        return projBudgetLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjForecastRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes project forecast revnue record in the <c>ProjForecastRevenue</c> table.
    /// </summary>
    /// <param name="_projForecastBudgetType">
    ///    Budget forcast type.
    /// </param>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetLine">
    ///    A <c>ProjBudgetLine</c> table buffer that contains the project budget line.
    /// </param>
    /// <returns>
    ///    A <c>ProjForecastRevenue</c> table buffer that contains the project forecast revenue line.
    /// </returns>
    protected ProjForecastRevenue initializeProjForecastRevenue(ProjForecastBudgetType _projForecastBudgetType, ProjBudget _projBudget, ProjBudgetLine _projBudgetLine)
    {
        ProjForecastRevenue projForecastRevenue;

        projForecastRevenue.clear();
        projForecastRevenue.CurrencyId = Ledger::accountingCurrency(CompanyInfo::current());
        projForecastRevenue.ProjId = _projBudgetLine.ProjId;
        projForecastRevenue.initValue();
        projForecastRevenue.CategoryId = _projBudgetLine.CategoryId;
        projForecastRevenue.ActivityNumber = _projBudgetLine.ActivityNumber;
        projForecastRevenue.Qty = 1;
        projForecastRevenue.ModelId = (_projForecastBudgetType == ProjForecastBudgetType::RemainingBudget ? _projBudget.RemainingBudgetForecastModel: _projBudget.OriginalBudgetForecastModel);
        projForecastRevenue.ProjForecastBudgetType = _projForecastBudgetType;
        projForecastRevenue.DefaultDimension = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
        projForecastRevenue.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);
        projForecastRevenue.SalesPrice = 0;

        return ProjForecastRevenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBudgetRevenueForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or updates the budget revenue forecast record in the <c>ProjForecastRevenue</c> table.
    /// </summary>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision record id
    /// </param>
    /// <param name = "_projBudgetLine">
    ///     The project budget line.
    /// </param>
    protected void createOrUpdateBudgetRevenueForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId, ProjBudgetLine _projBudgetLine)
    {
        ProjForecastRevenue  projForecastRevenue;
        ProjBudgetAllocationLine projBudgetAllocationLine;

        void setProjForecastRevenuePrice()
        {
            projForecastRevenue.SalesPrice += _projBudget.BudgetState == ProjBudgetState::Created
                                             ? _projBudgetLine.OriginalBudget
                                             : ProjBudgetRevisionLine::findByProjBudgetRevisionIdx(_projBudgetRevisionRecId, _projBudgetLine.RecId).RevisionAmount;
        }

        if (!ProjBudgetAllocationLine::existAllocationByLine(_projBudgetLine.RecId, _projBudget.BudgetState))
        {
            this.createDefaultAllocation(_projBudgetLine,_projBudget.BudgetState);
        }

        // For Original budget forecast.
        projForecastRevenue = ProjForecastRevenue::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, ProjForecastBudgetType::OriginalBudget, true);

        if (projForecastRevenue)
        {
            if (_projBudget.BudgetState == ProjBudgetState::Created)
            {
                // if record is found the update the price only.
                setProjForecastRevenuePrice();
                projForecastRevenue.update();
            }
        }
        else
        {
            // Creating the original forecast record.
            projForecastRevenue = this.initializeProjForecastRevenue(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
            if (_projBudget.BudgetState == ProjBudgetState::Created)
            {
                setProjForecastRevenuePrice();
            }
            projForecastRevenue.insert();
        }

        if (_projBudget.BudgetState == ProjBudgetState::Amendment && _projBudgetLine.UncommittedRevisions)
        {
            // Creating the amendment forecast record.
            projForecastRevenue = this.initializeProjForecastRevenue(ProjForecastBudgetType::Amendment, _projBudget, _projBudgetLine);
            setProjForecastRevenuePrice();
            projForecastRevenue.insert();

            //this.updateFromRevision(_projBudgetRevisionRecId);
        }

        // For remaining budget forecast.
        projForecastRevenue = ProjForecastRevenue::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, ProjForecastBudgetType::RemainingBudget, true);

        if (projForecastRevenue)
        {
            // if record is found the update the price only.
            setProjForecastRevenuePrice();
            projForecastRevenue.update();
        }
        else
        {
            // Creating the remaining forecast record.
            projForecastRevenue = this.initializeProjForecastRevenue(ProjForecastBudgetType::RemainingBudget, _projBudget, _projBudgetLine);
            setProjForecastRevenuePrice();
            projForecastRevenue.insert();
        }

        if (_projBudgetRevisionRecId == 0)
        {
            update_recordset projBudgetAllocationLine
                    setting CommittedRevisions = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions,
                            TotalAllocationAmount = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions+ projBudgetAllocationLine.OriginalAllocationAmount,
                            UncommittedRevisions = 0
                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetRevenueForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or updates the budget revenue forecast record in the <c>ProjForecastRevenue</c> table.
    /// </summary>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision record ID.
    /// </param>
    protected void createBudgetRevenueForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId = 0)
    {
        QueryRun  queryRun = new QueryRun(this.buildQueryToGetRevenueProjBudgetLine(_projBudget));
        while(queryRun.next())
        {
            ProjBudgetLine  projBudgetLine = queryRun.get(tableNum(ProjBudgetLine));

            this.createOrUpdateBudgetRevenueForecast(_projBudget, _projBudgetRevisionRecId, projBudgetLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetRevenueProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Provides the base query to select all project budget line of type revenue and project budget to the <c>ProjBudgetLine</c> table.
    /// </summary>
    /// <param name = "_projBudget">
    ///		A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <returns>
    ///		Returns query intance to select all project budget line of type revenue and project budget to the <c>ProjBudgetLine</c> table.
    /// </returns>
    protected Query buildQueryToGetRevenueProjBudgetLine(ProjBudget _projBudget)
    {
        Query query = new Query();
        QueryBuildDataSource projBudgetLineQbds = query.addDataSource(tableNum(ProjBudgetLine));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,CategoryId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,TotalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,RecId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudgetLineType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,UncommittedRevisions));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,OriginalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjTransType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjId));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjBudget)).value(queryValue(_projBudget.Recid));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjTransType)).value(queryValue(ProjTransType::Revenue));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForecastSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes forecast sales record in the <c>ForecastSales</c> table.
    /// </summary>
    /// <param name="_projForecastBudgetType">
    ///    Budget forcast type.
    /// </param>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetLine">
    ///    A <c>ProjBudgetLine</c> table buffer that contains the project budget line.
    /// </param>
    /// <returns>
    ///    A <c>ForecastSales</c> table buffer that contains the forecast sales line.
    /// </returns>
    protected ForecastSales initializeForecastSales(ProjForecastBudgetType _projForecastBudgetType, ProjBudget _projBudget, ProjBudgetLine _projBudgetLine)
    {
        ForecastSales forecastSales;

        forecastSales.clear();
        forecastSales.ProjId = _projBudgetLine.ProjId;
        forecastSales.initValue();
        forecastSales.Active = NoYes::Yes;
        forecastSales.ModelId = (_projForecastBudgetType == ProjForecastBudgetType::RemainingBudget ? _projBudget.RemainingBudgetForecastModel: _projBudget.OriginalBudgetForecastModel);
        forecastSales.ProjCategoryId = _projBudgetLine.CategoryId;
        forecastSales.ActivityNumber = _projBudgetLine.ActivityNumber;
        forecastSales.InventQty = 1;
        forecastSales.SalesQty = 1;
        forecastSales.InventDimId = InventDim::findOrCreateBlank().InventDimId;
        forecastSales.DefaultDimension = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
        forecastSales.ProjLinePropertyId = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);
        forecastSales.Currency = Ledger::accountingCurrency(CompanyInfo::current());
        forecastSales.initFromTransDate(true);
        forecastSales.ProjForecastBudgetType = _projForecastBudgetType;
        forecastSales.CostPrice = 0;
        forecastSales.SalesPrice = 0;

        return forecastSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBudgetSalesForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or updates the budget sales forecast record in the <c>ForecastSales</c> table.
    /// </summary>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision record id
    /// </param>
    /// <param name = "_projBudgetLine">
    ///     The project budget line.
    /// </param>
    protected void createOrUpdateBudgetSalesForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId, ProjBudgetLine _projBudgetLine)
    {
        ForecastSales forecastSales;
        ProjBudgetAllocationLine projBudgetAllocationLine;

        void setForecastSalesPrice()
        {
            AmountCur amountCur = _projBudget.BudgetState == ProjBudgetState::Created
                                 ? _projBudgetLine.OriginalBudget
                                 : ProjBudgetRevisionLine::findByProjBudgetRevisionIdx(_projBudgetRevisionRecId, _projBudgetLine.RecId).RevisionAmount;

            if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
            {
                forecastSales.CostPrice += amountCur;
            }
            else
            {
                forecastSales.SalesPrice += amountCur;
                forecastSales.Amount = forecastSales.calcLineAmount();
            }
        }

        if (!ProjBudgetAllocationLine::existAllocationByLine(_projBudgetLine.RecId,_projBudget.BudgetState))
        {
            this.createDefaultAllocation(_projBudgetLine,_projBudget.BudgetState);
        }

        // For Original budget forecast.
        forecastSales = ForecastSales::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, _projBudgetLine.ActivityNumber, ProjForecastBudgetType::OriginalBudget, true);

        if (_projBudget.BudgetState == ProjBudgetState::Created)
        {
            if (forecastSales)
            {
                // if record is found the update the price only.
                setForecastSalesPrice();
                forecastSales.update();
            }
            else
            {
                // Creating the original forecast record.
                forecastSales = this.initializeForecastSales(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
                setForecastSalesPrice();
                forecastSales.insert();
            }
        }
        else if (!forecastSales)
        {
            forecastSales = this.initializeForecastSales(ProjForecastBudgetType::OriginalBudget, _projBudget, _projBudgetLine);
            forecastSales.insert();
        }

        if (_projBudget.BudgetState == ProjBudgetState::Amendment && _projBudgetLine.UncommittedRevisions)
        {
            select firstonly forupdate forecastSales
                where forecastSales.ProjId == _projBudgetLine.ProjId
                &&  forecastSales.ProjCategoryId == _projBudgetLine.CategoryId
                &&  forecastSales.ActivityNumber == _projBudgetLine.ActivityNumber
                &&  forecastSales.ProjForecastBudgetType == ProjForecastBudgetType::Amendment
                &&  forecastSales.SalesQty == 0;

            if (forecastSales)
            {
                // if record is found the update the price only.
                setForecastSalesPrice();
                forecastSales.update();
            }
            else
            {
                // Creating the original forecast record.
                forecastSales = this.initializeForecastSales(ProjForecastBudgetType::Amendment, _projBudget, _projBudgetLine);
                setForecastSalesPrice();
                forecastSales.SalesQty = 0;
                forecastSales.insert();
            }

            //this.updateFromRevision(_projBudgetRevisionRecId);
        }

        // For remaining budget forecast.
        forecastSales = ForecastSales::findProjectBudgetForecast(_projBudgetLine.ProjId, _projBudgetLine.CategoryId, _projBudgetLine.ActivityNumber, ProjForecastBudgetType::RemainingBudget, true);

        if (forecastSales)
        {
            // if record is found the update the price only.
            setForecastSalesPrice();
            forecastSales.update();
        }
        else
        {
            // Creating the remaining forecast record.
            forecastSales = this.initializeForecastSales(ProjForecastBudgetType::RemainingBudget, _projBudget, _projBudgetLine);
            setForecastSalesPrice();
            forecastSales.insert();
        }

        if (_projBudgetRevisionRecId == 0)
        {
            update_recordset projBudgetAllocationLine
                    setting CommittedRevisions = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions,
                            TotalAllocationAmount = projBudgetAllocationLine.UncommittedRevisions + projBudgetAllocationLine.CommittedRevisions+ projBudgetAllocationLine.OriginalAllocationAmount,
                            UncommittedRevisions = 0
                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetSalesForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the budget sales forecast record in the <c>ForecastSales</c> table.
    /// </summary>
    /// <param name="_projBudget">
    ///    A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision record ID.
    /// </param>
    protected void createBudgetSalesForecast(ProjBudget _projBudget, RefRecId _projBudgetRevisionRecId = 0)
    {
        QueryRun  queryRun = new QueryRun(this.buildQueryToGetSalesProjBudgetLine(_projBudget));
        while(queryRun.next())
        {
            ProjBudgetLine  projBudgetLine = queryRun.get(tableNum(ProjBudgetLine));

            this.createOrUpdateBudgetSalesForecast(_projBudget, _projBudgetRevisionRecId, projBudgetLine);
        }
        // since every time amendment is committed a new amendment row is created. So we place a marker of Qty = 0 when
        // we insert amendment line. so that when we update any amendment forecast we are sure that this row is created
        // due to current amendment commitment process. Finally, setting the actual value.
        if (_projBudget.BudgetState == ProjBudgetState::Amendment)
        {
            ForecastSales forecastSales;

            update_recordset forecastSales
            setting SalesQty = 1
            where forecastSales.ProjId like _projBudget.RootProjId + #Star
            &&  forecastSales.ProjForecastBudgetType == ProjForecastBudgetType::Amendment
            &&  forecastSales.SalesQty == 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryToGetSalesProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Provides the base query to select all project budget line of type item and project budget to the <c>ProjBudgetLine</c> table.
    /// </summary>
    /// <param name = "_projBudget">
    ///		A <c>ProjBudget</c> table buffer that contains the project budget.
    /// </param>
    /// <returns>
    ///		Returns query intance to select all project budget line of type item and project budget to the <c>ProjBudgetLine</c> table.
    /// </returns>
    protected Query buildQueryToGetSalesProjBudgetLine(ProjBudget _projBudget)
    {
        Query query = new Query();
        QueryBuildDataSource projBudgetLineQbds = query.addDataSource(tableNum(ProjBudgetLine));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,CategoryId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,TotalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,RecId));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudgetLineType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,UncommittedRevisions));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,OriginalBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjBudget));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjTransType));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ActivityNumber));
        projBudgetLineQbds.addSelectionField(fieldNum(ProjBudgetLine,ProjId));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjBudget)).value(queryValue(_projBudget.Recid));
        projBudgetLineQbds.addRange(fieldNum(ProjBudgetLine,ProjTransType)).value(queryValue(ProjTransType::Item));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefaultAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the default allocation for a project budget line.
    /// </summary>
    /// <param name="_projBudgetLine">
    ///    A <c>ProjBudgetLine</c> table buffer with which allocation must be performed.
    /// </param>
    /// <param name="_projBudgetState">
    ///    A <c>ProjBudgetState</c> value that specifies the project budget state.
    /// </param>
    public void createDefaultAllocation(ProjBudgetLine _projBudgetLine,ProjBudgetState _projBudgetState)
    {
        ProjBudgetAllocationLine  projBudgetAllocationLineNewAllocation;
        ProjBudgetAllocationLine  projBudgetAllocationLine;
        ProjBudgetLine            projBudgetLineLocal;
        ProjBudgetLine            projBudgetLineforUpdate;
        RecId                     allocateProjBudgetRecID;
        AmountCur                 allocationAmount;
        boolean                   previousAllocationExist;
        int                       counter;
        RecId                     totalNumberofAllocationInterval;

        void getAllocationLineCount()
        {
            select count(RecId)
        from projBudgetAllocationLine
        group by projBudgetAllocationLine.ProjBudgetLine
        where projBudgetAllocationLine.ProjBudgetLine == allocateProjBudgetRecID;

            totalNumberofAllocationInterval = projBudgetAllocationLine.RecId;
        }

        void getAllocationByTransactionType()
        {
            // finding the any allocation of current budget record category transaction type.
            select firstonly RecId,ProjAllocationMethod
        from projBudgetLineLocal
        where projBudgetLineLocal.ProjBudget == _projBudgetLine.ProjBudget
        &&    projBudgetLineLocal.ProjTransType == _projBudgetLine.ProjTransType
        &&    projBudgetLineLocal.ProjBudgetLineType == _projBudgetLine.ProjBudgetLineType
        join  projBudgetAllocationLine
        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLineLocal.RecId;
        }

        if (_projBudgetState == ProjBudgetState::Created)
        {
            getAllocationByTransactionType();
            allocateProjBudgetRecID = projBudgetLineLocal.RecId;
        }
        else if (_projBudgetState == ProjBudgetState::Amendment)
        {
            // finding whether any previous allocation of this budget line exist.
            select ProjBudgetLine from projBudgetAllocationLine
        where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;

            if (projBudgetAllocationLine.ProjBudgetLine)
            {
                // if the allocation has been done to this projbudget line when previous committed then
                // we used the same method allocation procedure for this amendment amount allocation.
                allocateProjBudgetRecID = projBudgetAllocationLine.ProjBudgetLine;
                previousAllocationExist = true;
            }
            else
            {
                // this mean this line is created in current amendment hence we will find what procedure used to allocation
                // the amount of this type of transaction if any
                getAllocationByTransactionType();
                allocateProjBudgetRecID = projBudgetLineLocal.RecId;
                previousAllocationExist = false;
            }
        }

        if (allocateProjBudgetRecID)
        {
            if (_projBudgetState == ProjBudgetState::Created)
            {
                //update the allocation method of given projbudgetline
                projBudgetLineforUpdate = ProjBudgetLine::find(_projBudgetLine.RecId,true);
                projBudgetLineforUpdate.ProjAllocationMethod = projBudgetLineLocal.ProjAllocationMethod;
                projBudgetLineforUpdate.update();
            }

            // finding how many lines are created for previous projbudget line

            getAllocationLineCount();

            if (totalNumberofAllocationInterval > 0)
            {
                allocationAmount =CurrencyExchangeHelper::amount((_projBudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget : _projBudgetLine.UncommittedRevisions) / totalNumberofAllocationInterval);
            }

            counter = 0;

            projBudgetLineLocal.clear();

            projBudgetAllocationLine.clear();

            if (previousAllocationExist)
            {
                while select forupdate projBudgetAllocationLine
                    where projBudgetAllocationLine.ProjBudgetLine == allocateProjBudgetRecID
                {
                    counter++;

                    if (counter == totalNumberofAllocationInterval)
                    {
                        allocationAmount = CurrencyExchangeHelper::amount((_projBudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget : _projBudgetLine.UncommittedRevisions) - allocationAmount * (totalNumberofAllocationInterval - 1));
                    }
               
                    if (totalNumberofAllocationInterval > 1)
                    {
                        ProjBudgetRevLineAllocation projRevAllocationLine;                        

                        // Finding same allocations from previous revisions.
                        select sum(RevisionAllocationAmount) from projRevAllocationLine
                            where projRevAllocationLine.ProjBudgetAllocationLine == projBudgetAllocationLine.RecId;

                        allocationAmount = projRevAllocationLine.RevisionAllocationAmount;
                    }

                    // since later on in the code createBudgetXXXForecast, UncommittedRevisions is added to CommittedRevisions.
                    if (allocationAmount)
                    {
                        projBudgetAllocationLine.UncommittedRevisions = allocationAmount - projBudgetAllocationLine.CommittedRevisions;
                        projBudgetAllocationLine.update();
                    }
                }
            }
            else
            {
                // finding the allocation line of current projbudgetLine
                select RecId from projBudgetAllocationLine
            where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
                if (projBudgetAllocationLine.RecId)
                {
                    // mean that allocation have been done but the allocation total and projbudgetline total not match
                    while select forupdate OriginalAllocationAmount,UncommittedRevisions
                from projBudgetAllocationLine
                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId
                    {
                        counter++;

                        if (counter == totalNumberofAllocationInterval)
                        {
                            allocationAmount = CurrencyExchangeHelper::amount((_projBudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget : _projBudgetLine.UncommittedRevisions) - allocationAmount * (totalNumberofAllocationInterval - 1));
                        }

                        projBudgetAllocationLine.OriginalAllocationAmount = (_projBudgetState == ProjBudgetState::Created ? allocationAmount : 0);
                        projBudgetAllocationLine.UncommittedRevisions = (_projBudgetState == ProjBudgetState::Created ? 0 :allocationAmount);
                        projBudgetAllocationLine.update();
                    }
                }
                else
                {
                    while select projBudgetAllocationLine
                where projBudgetAllocationLine.ProjBudgetLine == allocateProjBudgetRecID
                    {
                        counter++;

                        if (counter == totalNumberofAllocationInterval)
                        {
                            allocationAmount = CurrencyExchangeHelper::amount((_projBudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget : _projBudgetLine.UncommittedRevisions) - allocationAmount * (totalNumberofAllocationInterval - 1));
                        }

                        projBudgetAllocationLineNewAllocation.ProjBudgetLine = _projBudgetLine.RecId;
                        projBudgetAllocationLineNewAllocation.FiscalCalendarPeriod = projBudgetAllocationLine.FiscalCalendarPeriod;
                        projBudgetAllocationLineNewAllocation.FiscalCalendarYear = projBudgetAllocationLine.FiscalCalendarYear;
                        projBudgetAllocationLineNewAllocation.Quarter = projBudgetAllocationLine.Quarter;
                        projBudgetAllocationLineNewAllocation.OriginalAllocationAmount = (_projBudgetState == ProjBudgetState::Created ? allocationAmount : 0);
                        projBudgetAllocationLineNewAllocation.UncommittedRevisions = (_projBudgetState == ProjBudgetState::Created ? 0 :allocationAmount);
                        projBudgetAllocationLineNewAllocation.insert();
                    }
                }
            }
        }
        else
        {
            // Since no category of specified transaction type exist so create default row.
            projBudgetAllocationLine.UncommittedRevisions = (_projBudgetState == ProjBudgetState::Created ? 0 :_projBudgetLine.UncommittedRevisions);
            projBudgetAllocationLine.FiscalCalendarPeriod = 0;
            projBudgetAllocationLine.FiscalCalendarYear = this.getProjBudgetFiscalYear(_projBudgetLine.RecId).RecId;
            projBudgetAllocationLine.OriginalAllocationAmount = (_projBudgetState == ProjBudgetState::Created ? _projBudgetLine.OriginalBudget :0);
            projBudgetAllocationLine.ProjBudgetLine = _projBudgetLine.RecId;
            projBudgetAllocationLine.ReductionAmount = 0;
            projBudgetAllocationLine.TotalAllocationAmount = projBudgetAllocationLine.OriginalAllocationAmount + projBudgetAllocationLine.UncommittedRevisions;
            projBudgetAllocationLine.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRevisionAllocation</Name>
				<Source><![CDATA[
    private void createRevisionAllocation(ProjBudgetRevisionLine revlines)
    {
        ProjBudgetRevisionLine      revisionLine;
        ProjBudgetAllocationLine    allocationLine;
        ProjBudgetRevLineAllocation revAllocationLine;

        insert_recordset revAllocationLine (ProjBudgetRevisionLine, ProjBudgetAllocationLine)
        select RecId from revisionLine
            where revisionLine.ProjBudgetRevision == revlines.ProjBudgetRevision
            &&    revisionLine.ProjBudgetLine     == revlines.ProjBudgetLine
        join RecId from allocationLine
            where allocationLine.ProjBudgetLine   == revisionLine.ProjBudgetLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRevisionLineIfNotExists</Name>
				<Source><![CDATA[
    private RecId createRevisionLineIfNotExists(RecId _projBudgetLine, RecId _projBudgetRevision)
    {
        ProjBudgetRevisionLine  projBudgetRevisionLine;
        ProjBudgetRevisionLine  projBudgetRevisionLineNew;
        RecId                   projBudgetRevisionLineRecId;

        select firstonly RecId from projBudgetRevisionLine
        where projBudgetRevisionLine.ProjBudgetLine  == _projBudgetLine
        && projBudgetRevisionLine.ProjBudgetRevision == _projBudgetRevision;

        if (projBudgetRevisionLine.RecId)
        {
            projBudgetRevisionLineRecId = projBudgetRevisionLine.RecId;
        }
        else
        {
            projBudgetRevisionLineNew.clear();
            projBudgetRevisionLineNew.initValue();
            projBudgetRevisionLineNew.ProjBudgetLine     = _projBudgetLine;
            projBudgetRevisionLineNew.ProjBudgetRevision = _projBudgetRevision;
            projBudgetRevisionLineNew.insert();
            projBudgetRevisionLineRecId = projBudgetRevisionLineNew.RecId;
            this.createRevisionAllocation(projBudgetRevisionLineNew);
        }

        return projBudgetRevisionLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjBudgetRevisionLinefields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>ProjBudgetRevisionLine</c> table fields.
    /// </summary>
    /// <param name = "_projBudgetRevisionLine">
    /// An instance of <c>ProjBudgetRevisionLine</c> table buffer.
    /// </param>
    /// <param name = "_projBudgetLine">
    /// An instance of <c>ProjBudgetLine</c> table buffer.
    /// </param>
    protected void updateProjBudgetRevisionLinefields(ProjBudgetRevisionLine _projBudgetRevisionLine, ProjBudgetLine _projBudgetLine)
    {
        _projBudgetRevisionLine.RevisionAmount = -(_projBudgetLine.OriginalBudget + _projBudgetLine.CommittedRevisions);
        _projBudgetLine.UncommittedRevisions += _projBudgetRevisionLine.RevisionAmount;
        _projBudgetRevisionLine.NewTotalBudget = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBudgetLinesBeforeImportForRevs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deleting the budget lines before importing for reversal.
    /// </summary>
    /// <param name = "_projBudgetRevision">
    /// Record ID of <c>ProjBudgetRevision</c> table buffer.
    /// </param>
    /// <param name = "_projBudget">
    /// Record ID of <c>ProjBudget</c> table buffer.
    /// </param>
    /// <param name = "_projectId">
    /// Project ID.
    /// </param>
    /// <param name = "_isWildCardProject">
    /// An optional value for wildcard projects.
    /// </param>
    private void deleteBudgetLinesBeforeImportForRevs(
    RecId   _projBudgetRevision,
    RecId   _projBudget,
    ProjId  _projectId,
    boolean _isWildCardProject = true)
    {
        ProjBudgetRevisionLine projBudgetRevisionLine;
        ProjBudgetLine projBudgetLine;
        ProjBudgetLineDetail projBudgetLineDetail;
        ProjId tempProjId;

        while select RecId from projBudgetLine
            where projBudgetLine.ProjBudget     == _projBudget
            &&    (projBudgetLine.OriginalBudget != 0.00 || projBudgetLine.CommittedRevisions != 0.00)
        {
            this.createRevisionLineIfNotExists(projBudgetLine.RecId, _projBudgetRevision);
        }

        if (_isWildCardProject)
        {
            tempProjId = _projectId + #Star;
        }
        else
        {
            tempProjId = _projectId;
        }

        while select forupdate projBudgetRevisionLine
            join forupdate projBudgetLine
            where projBudgetRevisionLine.ProjBudgetRevision  == _projBudgetRevision
            && projBudgetLine.RecId == projBudgetRevisionLine.ProjBudgetLine
            && (projBudgetLine.OriginalBudget + projBudgetLine.CommittedRevisions + projBudgetRevisionLine.RevisionAmount) != 0
            && projBudgetLine.ProjId like tempProjId
        {
            projBudgetLine.UncommittedRevisions  -= projBudgetRevisionLine.RevisionAmount;
            projBudgetRevisionLine.RevisionAmount = 0;

            delete_from projBudgetLineDetail
                    where projBudgetLineDetail.ProjBudgetRevisionLine == projBudgetRevisionLine.RecId
                    &&    projBudgetLineDetail.ProjBudgetLine         == projBudgetLine.RecId;

            this.updateProjBudgetRevisionLinefields(projBudgetRevisionLine, projBudgetLine);
            projBudgetLine.update();
            projBudgetRevisionLine.update();
        }

        if (ProjBudgetRevision::find(_projBudgetRevision).RevisionWorkflowStatus != ProjBudgetRevisionWFStatus::Approved)
        {
            delete_from projBudgetRevisionLine
            where projBudgetRevisionLine.PreviousApprovedBudget == 0
            && projBudgetRevisionLine.RevisionAmount            == 0
            && projBudgetRevisionLine.NewTotalBudget            == 0
            && projBudgetRevisionLine.ProjBudgetRevision        == _projBudgetRevision;
        }

        if (ProjBudget::find(_projBudget).BudgetWorkflowStatus != ProjBudgetWorkflowStatus::Approved)
        {
            delete_from projBudgetLine
            where projBudgetLine.UncommittedRevisions == 0
            && projBudgetLine.CommittedRevisions      == 0
            && projBudgetLine.OriginalBudget          == 0
            && projBudgetLine.ProjId                  like tempProjId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDDinsertProjBudgetLineDetail</Name>
				<Source><![CDATA[
    private RefRecId deleteDDinsertProjBudgetLineDetail(
        RefRecId            _projBudgetLineRecid,
        RefRecId            _resourceRecId,
        RefRecId            _resourceCategoryRecId,
        Qty                 _qty,
        AmountCur           _costPrice,
        AmountCur           _salesPrice
        )
    {
        ProjBudgetLine          projBudgetLine;
        ProjBudgetLineDetail    projBudgetLineDetail;

        if (_projBudgetLineRecid)
        {
            projBudgetLine = ProjBudgetLine::find(_projBudgetLineRecid);
            if (projBudgetLine)
            {
                projBudgetLineDetail.ProjBudgetLine = _projBudgetLineRecid;
                projBudgetLineDetail.Resource       = _resourceRecId;
                projBudgetLineDetail.ResourceCategory = _resourceCategoryRecId;
                projBudgetLineDetail.Quantity       = _qty;
                projBudgetLineDetail.CostPrice      = _costPrice;
                projBudgetLineDetail.SalesPrice     = _salesPrice;
                projBudgetLineDetail.insert();
            }
        }

        return projBudgetLineDetail.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteorUpdateAllocationLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes or updates the allocation lines base on the specified project budget state.
    /// </summary>
    /// <param name="_projBudgetLine">
    ///    A <c>ProjBudgetLine</c> table buffer that contains the information about the project budget line.
    /// </param>
    /// <param name="_projBudgetState">
    ///    A <c>ProjBudgetState</c> type value that specifies the state of the budget.
    /// </param>
    private void deleteorUpdateAllocationLine(ProjBudgetLine _projBudgetLine, ProjBudgetState _projBudgetState)
    {
        ProjBudgetAllocationLine    projBudgetAllocationLine;

        switch (_projBudgetState)
        {
            case ProjBudgetState::Created :
                                    delete_from projBudgetAllocationLine
                                    where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
                break;
            case ProjBudgetState::Amendment :
                                    update_recordset projBudgetAllocationLine
                                    setting TotalAllocationAmount = projBudgetAllocationLine.OriginalAllocationAmount + projBudgetAllocationLine.CommittedRevisions,
                                            UncommittedRevisions  = 0
                                    where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDeleteProjBudgetLinesWhenZeroAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check whether budget lines with zero amount should be deleted.
    /// </summary>
    /// <returns>
    ///     false, as project budget lines should not get deleted.
    /// </returns>
    protected boolean shouldDeleteProjBudgetLinesWhenZeroAmount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteProjBudgetLinesWhenZeroAmount</Name>
				<Source><![CDATA[
    private void deleteProjBudgetLinesWhenZeroAmount(
    RefRecId _projBudgetLineRecid,
    RecId _projBudgetRevision
    )
    {
        ProjBudgetLine projBudgetLine;
        ProjBudgetRevisionLine projBudgetRevisionLine;

        if(this.shouldDeleteProjBudgetLinesWhenZeroAmount())
        {
            if (_projBudgetRevision)
            {
                delete_from projBudgetRevisionLine
                where projBudgetRevisionLine.ProjBudgetRevision  == _projBudgetRevision
                && projBudgetRevisionLine.ProjBudgetLine         == _projBudgetLineRecid
                && projBudgetRevisionLine.PreviousApprovedBudget == 0
                && projBudgetRevisionLine.RevisionAmount         == 0;

                delete_from projBudgetLine
                where projBudgetLine.RecId              == _projBudgetLineRecid
                && projBudgetLine.OriginalBudget        == 0
                && projBudgetLine.CommittedRevisions    == 0
                && projBudgetLine.UncommittedRevisions  == 0;
            }
            else
            {
                delete_from projBudgetLine where projBudgetLine.RecId == _projBudgetLineRecid;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRevisionAllocationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the budget revision allocation lines that corresponds to the specified revision line.
    /// </summary>
    /// <param name="_projBudgetRevisionLine">
    /// A <c>ProjBudgetRevisionLine</c> table buffer that contains the information about the project budget
    /// revision line.
    /// </param>
    private void deleteRevisionAllocationLine(ProjBudgetRevisionLine _projBudgetRevisionLine)
    {
        ProjBudgetRevLineAllocation projBudgetRevLineAllocation;

        delete_from projBudgetRevLineAllocation
        where projBudgetRevLineAllocation.ProjBudgetRevisionLine == _projBudgetRevisionLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectFiscalYear</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the allocation fiscal year of the record with the specified project ID for budget allocation.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID of the record to find.
    /// </param>
    /// <returns>
    ///    A record in the <c>FiscalCalendarYear</c> table; otherwise, an empty buffer.
    /// </returns>
    private FiscalCalendarYear getProjectFiscalYear(ProjId  _projId)
    {
        ProjTable           projTable;
        FiscalCalendarYear  fiscalCalendarYear;
        RecId               fiscalCalendar;

        fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());

        projTable = ProjTable::find(_projId);

        if (projTable.StartDate != dateNull())
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendar ,projTable.StartDate);
        }
        else if (projTable.ProjectedStartDate != dateNull())
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendar ,projTable.ProjectedStartDate);
        }
        else
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendar ,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }

        if (!fiscalCalendarYear.RecId)
        {
            throw error("@SYS301636");
        }

        return fiscalCalendarYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the query object for the specified project forecast tabled buffer.
    /// </summary>
    /// <param name = "_projBudgetManagerParmArgs">
    /// An instance of <c>ProjBudgetManagerParmArgs</c>
    /// </param>
    /// <returns>
    /// A query object.
    /// </returns>
    protected Query getQuery(ProjBudgetManagerParmArgs _projBudgetManagerParmArgs)
    {
        Query query = new Query();

        QueryBuildDataSource queryBuildDataSource = query.addDataSource(_projBudgetManagerParmArgs.parmTableId());
        queryBuildDataSource.addRange(_projBudgetManagerParmArgs.parmFieldNumForecastModelId()).value(_projBudgetManagerParmArgs.parmForecastModelId());
        queryBuildDataSource.addRange(_projBudgetManagerParmArgs.parmFieldNumProjId()).value(_projBudgetManagerParmArgs.parmProjId());

        if (_projBudgetManagerParmArgs.parmCategoryId() != "")
        {
            queryBuildDataSource.addRange(_projBudgetManagerParmArgs.parmFieldNumCategoryId()).value(queryValue(_projBudgetManagerParmArgs.parmCategoryId()));
        }

        if (_projBudgetManagerParmArgs.parmProjCategoryId() != "")
        {
            queryBuildDataSource.addRange(_projBudgetManagerParmArgs.parmFieldNumCategoryId()).value(queryValue(_projBudgetManagerParmArgs.parmProjCategoryId()));
        }

        if (!_projBudgetManagerParmArgs.parmSummarizeByCategory())
        {
            queryBuildDataSource.addRange(_projBudgetManagerParmArgs.parmFieldNumActivityNumber()).value(queryValue(_projBudgetManagerParmArgs.parmProjActivityNumber()));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryGroup</Name>
				<Source><![CDATA[
    private Query getQueryGroup()
    {
        //Method is renamed to getQueryGroupByClause
        //This is left here to satisy validateXPOFiles
        Query query;
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryWithGroupByClause</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Provides the base query for specified table.
    /// </summary>
    /// <param name = "_tableId">
    ///		The table Id.
    /// </param>
    /// <param name = "_fieldNumForecastModelId">
    ///		The field Id of forecase model Id.
    /// </param>
    /// <param name = "_fieldNumProjId">
    ///		The field Id of proj Id.
    /// </param>
    /// <param name = "_fieldNumCategoryId">
    ///		The field Id of category Id.
    /// </param>
    /// <param name = "_fieldNumActivityNumber">
    ///		The field Id of activity number.
    /// </param>
    /// <param name = "_forecastModelId">
    ///		The field Id of forecase model Id.
    /// </param>
    /// <param name = "_projId">
    ///		The field Id of proj Id.
    /// </param>
    /// <param name = "_summarizeByCategory">
    ///		true, if summarize by category; otherwise, false.
    /// </param>
    /// <returns>
    /// Returns the query instance.
    /// </returns>
    protected Query getQueryWithGroupByClause(
    TableId         _tableId,
    FieldId         _fieldNumForecastModelId,
    FieldId         _fieldNumProjId,
    FieldId         _fieldNumCategoryId,
    FieldId         _fieldNumActivityNumber,
    ForecastModelId _forecastModelId,
    ProjId          _projId,
    boolean         _summarizeByCategory)
    {
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSource;

        queryBuildDataSource = query.addDataSource(_tableId);
        queryBuildDataSource.addRange(_fieldNumForecastModelId).value(_forecastModelId);
        queryBuildDataSource.addRange(_fieldNumProjId).value(_projId);
        queryBuildDataSource.addGroupByField(_fieldNumProjId);
        queryBuildDataSource.addGroupByField(_fieldNumCategoryId);

        if (!_summarizeByCategory)
        {
            queryBuildDataSource.addGroupByField(_fieldNumActivityNumber);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertorUpdateProjAllocationLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts or updates the records of the <c>ProjectBudgetLine</c> table.
    /// </summary>
    /// <param name="_allocationAmount">
    ///    A <c>AmountCur</c> data type value that indicates the amount of the allocation.
    /// </param>
    /// <param name="_projAllocationMethod">
    ///    A <c>ProjAllocationMethod</c> data type value that indicates the allocation method.
    /// </param>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that specifies the allocation period or year record ID.
    /// </param>
    /// <param name="_projBudgetLineId">
    ///    The record ID of the project budget line.
    /// </param>
    /// <param name="_projBudgetState">
    ///    A <c>ProjBudgetState</c> data type value that specifies the state of the budget.
    /// </param>
    void insertorUpdateProjAllocationLines(AmountCur _allocationAmount,
                                       ProjAllocationMethod _projAllocationMethod,
                                       Common _common ,
                                       RecId _projBudgetLineId,
                                       ProjBudgetState _projBudgetState)
    {
        ProjBudgetAllocationLine        projBudgetAllocationLine;
        FiscalCalendarYear              fiscalCalendarYear;
        FiscalCalendarPeriod            fiscalCalendarPeriod;

        void setAllocationAmount()
        {
            if (_projBudgetState == ProjBudgetState::Created)
            {
                projBudgetAllocationLine.OriginalAllocationAmount = _allocationAmount;
            }
            else if (_projBudgetState == ProjBudgetState::Amendment)
            {
                projBudgetAllocationLine.UncommittedRevisions = _allocationAmount;
            }
        }

        void initProjBudgetAllocation()
        {
            projBudgetAllocationLine.clear();
            projBudgetAllocationLine.ProjBudgetLine = _projBudgetLineId;
        }

        switch (_projAllocationMethod)
        {
            case ProjAllocationMethod::Yearly :

                fiscalCalendarYear = _common;

                projBudgetAllocationLine = ProjBudgetAllocationLine::findbyFiscalYear(fiscalCalendarYear.RecId, _projBudgetLineId,true);

                if (projBudgetAllocationLine)
                {
                    setAllocationAmount();
                    projBudgetAllocationLine.update();
                }
                else
                {
                    initProjBudgetAllocation();
                    projBudgetAllocationLine.FiscalCalendarYear = fiscalCalendarYear.RecId;
                    setAllocationAmount();
                    projBudgetAllocationLine.insert();
                }
                break;

            case ProjAllocationMethod::Quarter :
                fiscalCalendarPeriod  = _common;

                projBudgetAllocationLine = ProjBudgetAllocationLine::findbyFiscalQuarter(fiscalCalendarPeriod.FiscalCalendarYear, fiscalCalendarPeriod.Quarter, _projBudgetLineId, true);

                if (projBudgetAllocationLine)
                {
                    setAllocationAmount();
                    projBudgetAllocationLine.update();
                }
                else
                {
                    initProjBudgetAllocation();
                    projBudgetAllocationLine.FiscalCalendarYear = fiscalCalendarPeriod.FiscalCalendarYear;
                    projBudgetAllocationLine.Quarter = fiscalCalendarPeriod.Quarter;
                    setAllocationAmount();
                    projBudgetAllocationLine.insert();
                }
                break;

            case ProjAllocationMethod::Periods :
                fiscalCalendarPeriod = _common;

                projBudgetAllocationLine = ProjBudgetAllocationLine::findbyFiscalPeriod(fiscalCalendarPeriod.RecId, _projBudgetLineId,true);

                if (projBudgetAllocationLine)
                {
                    setAllocationAmount();
                    projBudgetAllocationLine.update();
                }
                else
                {
                    initProjBudgetAllocation();
                    projBudgetAllocationLine.FiscalCalendarPeriod = fiscalCalendarPeriod.RecId;
                    setAllocationAmount();
                    projBudgetAllocationLine.insert();
                }
                break;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record into the <c>ProjBudgetLine</c> table.
    /// </summary>
    /// <param name="_categoryId">
    /// A <c>CategoryId</c> value that determines the category ID of the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_projTransType">
    /// A <c>ProjTransType</c> value that determines the transaction type of the new <c>ProjBudgetLine</c>
    /// record.
    /// </param>
    /// <param name="_originalAmount">
    /// A <c>AmountCur</c> value that determines the original amount of the new <c>ProjBudgetLine</c>
    /// record.
    /// </param>
    /// <param name="_projBudgetLineType">
    /// A <c>ProjBudgetLineType</c> value that determines the line type of the new <c>ProjBudgetLine</c>
    /// record.
    /// </param>
    /// <param name="_projBudget">
    /// A <c>RecID</c> value that determines the project budget ID of the new <c>ProjBudgetLine</c> record..
    /// </param>
    /// <param name="_projId">
    /// A <c>ProjId</c> value that determines the project ID.
    /// </param>
    /// <param name="_activityNumber">
    /// A <c>activityNumber</c> value that determines the activity.
    /// </param>
    /// <returns>
    /// The record ID of the inserted <c>ProjBudgetLine</c> record.
    /// </returns>
    protected RefRecId insertProjBudgetLine(
        CategoryId         _categoryId,
        ProjTransType      _projTransType,
        AmountCur          _originalAmount,
        ProjBudgetLineType _projBudgetLineType,
        RecId              _projBudget,
        ProjId             _projId,
        ProjActivityNumber _activityNumber
)
    {
        ProjBudgetLine projBudgetLine;

        if (!ProjValProjCategorySetUp::checkProjCategory(_projId,_categoryId))
        {
            checkFailed(strFmt("@SYS300484",_projId,_categoryId));
        }
        else
        {
            projBudgetLine = this.initializeProjBudgetLine(_categoryId, _projTransType, _originalAmount, _projBudgetLineType, _projBudget, _projId, _activityNumber);
            projBudgetLine.insert();
        }
        return projBudgetLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUpAmount</Name>
				<Source><![CDATA[
    private AmountCur markUpAmount(
    AmountCur   _transAmount,
    MarkupValue _markUpUnits    = 0.0,
    MarkupValue _markUpCosts    = 0.0,
    MarkupValue _markUpRevenue  = 0.0
    )
    {
        AmountCur tmpTransAmt = _transAmount;

        if (_markUpUnits != 0.0)
        {
            tmpTransAmt = _transAmount * (1 + _markUpUnits/100.00);
        }
        else
    if (_markUpCosts != 0.0)
        {
            tmpTransAmt = _transAmount * (1 + _markUpCosts/100.00);
        }
        else
    if (_markUpRevenue != 0.0)
        {
            tmpTransAmt = _transAmount * (1 + _markUpRevenue/100.00);
        }

        return tmpTransAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetSource</Name>
				<Source><![CDATA[
    private void updateBudgetSource(
    ProjId              _projId,
    RecId               _projBudget,
    ProjBaseBudgetOn    _baseBudget,
    RecId               _projBudgetRevision   =   0,
    ForecastModelId     _modelId                 =   "",
    ProjId              _sourceProjId            =   "")
    {
        ProjBudgetSource projBudgetSource;

        projBudgetSource = ProjBudgetSource::find(_projId, _projBudget, _projBudgetRevision, true);
        projBudgetSource.BudgetSource = _baseBudget;
        projBudgetSource.ForecastModelId = _modelId;
        projBudgetSource.SourceProjId = _sourceProjId;

        if (projBudgetSource)
        {
            projBudgetSource.update();
        }
        else
        {
            projBudgetSource.ProjId = _projId;
            projBudgetSource.ProjBudget = _projBudget;
            projBudgetSource.ProjBudgetRevision = _projBudgetRevision;
            projBudgetSource.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFromRevision</Name>
				<Source><![CDATA[
    public void updateFromRevision(RefRecId _projBudgetRevisionRecId)
    {
        ProjBudgetAllocationLine projBudgetAllocationLine;
        ProjBudgetRevisionLine   projBudgetRevisionLine;
        ProjBudgetLine           projBudgetLine;
        ProjBudgetRevision       projBudgetRevision;
        ProjBudgetRevLineAllocation projRevAllocationLine;

        if (_projBudgetRevisionRecId == 0)
        {
            return;
        }

        projBudgetRevision = ProjBudgetRevision::find(_projBudgetRevisionRecId);

        while select TotalBudget from projBudgetLine
        join forupdate projBudgetRevisionLine
            where projBudgetRevisionLine.ProjBudgetLine == projBudgetLine.RecId &&
                  projBudgetRevisionLine.ProjBudgetRevision == _projBudgetRevisionRecId
        {
            while select RevisionAllocationAmount,ProjBudgetAllocationLine,ProjBudgetRevisionLine
            from projRevAllocationLine
            where projRevAllocationLine.ProjBudgetRevisionLine == projBudgetRevisionLine.RecId
            {
                select forupdate projBudgetAllocationLine where projBudgetAllocationLine.RecId == projRevAllocationLine.ProjBudgetAllocationLine;

                projBudgetAllocationLine.CommittedRevisions    += projRevAllocationLine.RevisionAllocationAmount;
                projBudgetAllocationLine.TotalAllocationAmount += projRevAllocationLine.RevisionAllocationAmount;
                projBudgetAllocationLine.UncommittedRevisions  -= projRevAllocationLine.RevisionAllocationAmount;
                projBudgetAllocationLine.doUpdate();
            }

            projBudgetRevisionLine.PreviousApprovedBudget = projBudgetLine.TotalBudget;
            projBudgetRevisionLine.NewTotalBudget         = projBudgetRevisionLine.RevisionAmount +
                                                        projBudgetRevisionLine.PreviousApprovedBudget;
            projBudgetRevisionLine.doUpdate();
        }

        while select forupdate projBudgetLine
        join projBudgetRevisionLine
            where projBudgetRevisionLine.ProjBudgetLine == projBudgetLine.RecId &&
                  projBudgetRevisionLine.ProjBudgetRevision == _projBudgetRevisionRecId
        {
            projBudgetLine.CommittedRevisions   += projBudgetRevisionLine.RevisionAmount;
            projBudgetLine.TotalBudget          = projBudgetRevisionLine.NewTotalBudget;
            projBudgetLine.UncommittedRevisions -= projBudgetRevisionLine.RevisionAmount;
            projBudgetLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToUpdateForProjBudgetRevisionLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates specific fields for <c>ProjBudgetRevisionLine</c> table.
    /// </summary>
    /// <param name = "_projBudgetRevisionLine">
    ///     A <c>ProjBudgetRevisionLine</c> table buffer.
    /// </param>
    /// <returns>
    ///     A <c>ProjBudgetRevisionLine</c> table buffer.
    /// </returns>
    protected ProjBudgetRevisionLine specificFieldsToUpdateForProjBudgetRevisionLine(ProjBudgetRevisionLine _projBudgetRevisionLine)
    {
        return _projBudgetRevisionLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToInsertForProjBudgetRevisionLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///      Inserts specific fields into the <c>ProjBudgetRevisionLine</c> table.
    /// </summary>
    /// <param name = "_projBudgetRevisionLine">
    ///      A <c>ProjBudgetRevisionLine</c> table buffer.
    /// </param>
    /// <returns>
    ///     A <c>ProjBudgetRevisionLine</c> table buffer.
    /// </returns>
    protected ProjBudgetRevisionLine specificFieldsToInsertForProjBudgetRevisionLine(ProjBudgetRevisionLine _projBudgetRevisionLine)
    {
        return _projBudgetRevisionLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjBudgetLinesWithAmt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the <c>ProjBudgetLine</c> with summarized amount.
    /// </summary>
    /// <param name = "_projBudgetLineRecId">
    ///     The project budget line record Id.
    /// </param>
    /// <param name = "_projBudgetRevision">
    ///     The project budget revision Id.
    /// </param>
    /// <param name = "_summarizedAmount">
    ///     The amount in the accounting currency of the ledger.
    /// </param>
    protected void updateProjBudgetLinesWithAmt(
    RecId       _projBudgetLineRecId,
    RecId       _projBudgetRevision,
    AmountCur   _summarizedAmount
    )
    {
        ProjBudgetLine          projBudgetLine;
    
        select forupdate projBudgetLine where projBudgetLine.RecId == _projBudgetLineRecId;

        if (_projBudgetRevision == 0)
        {
            projBudgetLine.OriginalBudget = _summarizedAmount;
        }
        else
        {
            ProjBudgetRevisionLine  projBudgetRevisionLine;

            select firstonly forupdate projBudgetRevisionLine
            where projBudgetRevisionLine.ProjBudgetLine   == _projBudgetLineRecId
            &&  projBudgetRevisionLine.ProjBudgetRevision == _projBudgetRevision;

            if (projBudgetRevisionLine)
            {
                projBudgetRevisionLine.RevisionAmount = (_summarizedAmount - projBudgetLine.CommittedRevisions - projBudgetLine.OriginalBudget);
                projBudgetRevisionLine.NewTotalBudget = _summarizedAmount;
            
                if (!projBudgetRevisionLine.PreviousApprovedBudget)
                {
                    projBudgetRevisionLine.PreviousApprovedBudget = projBudgetLine.OriginalBudget;
                }

                projBudgetRevisionLine = this.specificFieldsToUpdateForProjBudgetRevisionLine(projBudgetRevisionLine);
                projBudgetRevisionLine.update();
            }
            else
            {
                projBudgetRevisionLine.clear();
                projBudgetRevisionLine.initValue();
                projBudgetRevisionLine.ProjBudgetLine     = _projBudgetLineRecId;
                projBudgetRevisionLine.ProjBudgetRevision = _projBudgetRevision;
                projBudgetRevisionLine.RevisionAmount     = _summarizedAmount;
                projBudgetRevisionLine.NewTotalBudget     = _summarizedAmount;

                projBudgetRevisionLine = this.specificFieldsToInsertForProjBudgetRevisionLine(projBudgetRevisionLine);
                projBudgetRevisionLine.insert();
            }
            projBudgetLine.UncommittedRevisions += projBudgetRevisionLine.RevisionAmount;
        }
        projBudgetLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelAmendment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cancels the amendment changes in the specified project budget.
    /// </summary>
    /// <param name="_projBudgetRecID">
    ///    The project budget record ID.
    /// </param>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    ///    A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    ///    An update conflict occurred.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    A cancel update error message show if some error occurred when allocation line were created.
    /// </exception>
    public static void cancelAmendment(RecId _projBudgetRecID)
    {
        ProjBudget               projBudget;
        ProjBudgetLine           projBudgetLine;
        ProjBudgetAllocationLine projBudgetAllocationLine;
        ProjBudgetLine           projBudgetLineDelete;

        try
        {
            ttsbegin;
            // reset the budget state
            projBudget = ProjBudget::find(_projBudgetRecID,true);
            projBudget.setProjBudgetState(ProjBudgetState::Committed);

            // Deleting the record which was created in current amendment.
            delete_from projBudgetLineDelete
        where projBudgetLineDelete.ProjBudget == _projBudgetRecID
        &&  projBudgetLineDelete.OriginalBudget == 0
        &&  projBudgetLineDelete.CommittedRevisions == 0;

            // removing the allocation which is done in the current amendment.
            update_recordset projBudgetAllocationLine
        setting UncommittedRevisions =0,
                TotalAllocationAmount = projBudgetAllocationLine.CommittedRevisions + projBudgetAllocationLine.OriginalAllocationAmount
        join projBudgetLine
        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
        &&    projBudgetLine.ProjBudget == _projBudgetRecID;

            // clearing the amendment amount which is entered in amendment state.
            update_recordset projBudgetLine
        setting TotalBudget = projBudgetLine.OriginalBudget + projBudgetLine.CommittedRevisions,
                UncommittedRevisions = 0
        where projBudgetLine.ProjBudget == _projBudgetRecID;

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    ttsabort;
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified transaction type is selected for allocation.
    /// </summary>
    /// <param name="_isHourCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on the hour
    /// cost budget line.
    /// </param>
    /// <param name="_isExpenseCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on the
    /// expense cost budget line.
    /// </param>
    /// <param name="_isItemCosts">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on the item
    /// cost budget line.
    /// </param>
    /// <param name="_isFees">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on the fee
    /// budget line.
    /// </param>
    /// <param name="_isHourRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an hour
    /// revenue budget line.
    /// </param>
    /// <param name="_isExpenseRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an
    /// expense revenue budget line.
    /// </param>
    /// <param name="_isItemRevenues">
    /// A <c>NoYes</c> enumeration value that indicates whether allocation should be performed on an item
    /// revenue budget line.
    /// </param>
    /// <param name="_projBudgetLine">
    /// A <c>ProjBudgetLine</c> table that contains the budget line to allocate.
    /// </param>
    /// <returns>
    /// true if the specified transaction type is selected for allocation; otherwise, false.
    /// </returns>
    public static boolean checkTransType(NoYes _isHourCosts, NoYes _isExpenseCosts,
                                NoYes _isItemCosts, NoYes _isFees, NoYes _isHourRevenues,
                                NoYes _isExpenseRevenues, NoYes _isItemRevenues, ProjBudgetLine _projBudgetLine)
    {
        boolean ret;

        switch ( _projBudgetLine.ProjTransType)
        {
            case ProjTransType::Cost :
            if ((_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Revenue && _isExpenseRevenues)
                ||
               (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost && _isExpenseCosts))
                {
                    ret = true;
                }
                break;

            case ProjTransType::Hour :
            if ((_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Revenue && _isHourRevenues)
                ||
               (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost && _isHourCosts))
                {
                    ret = true;
                }
                break;

            case ProjTransType::Item :
            if ((_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Revenue && _isItemRevenues)
                ||
               (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost && _isItemCosts))
                {
                    ret = true;
                }
                break;

            case ProjTransType::Revenue :
            if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Revenue && _isFees)
                {
                    ret = true;
                }
                break;
        }
        return ret;

    }

]]></Source>
			</Method>
			<Method>
				<Name>commitBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Commits the project budget.
    /// </summary>
    /// <param name="_projBudgetRecID">
    ///    The project budget record ID.
    /// </param>
    /// <param name="_projBudgetRevisionRecId">
    ///    The project budget revision Id
    /// </param>
    public static void commitBudget(RecId _projBudgetRecID, RecId _projBudgetRevisionRecId = 0)
    {
        ProjTable               projTable;
        ProjBudget              projBudget;
        ProjBudgetLine          projBudgetLine;
        ProjBudgetManager       projBudgetManager = new ProjBudgetManager();
        boolean isProjBudgetLineExists;

        projBudget = ProjBudget::find(_projBudgetRecID,true);
        projTable = ProjTable::find(projBudget.RootProjId);

        isProjBudgetLineExists = ProjBudgetManager::validateProjBudgetLine(projTable, _projBudgetRecID);

        if (isProjBudgetLineExists)
        {
            return;
        }
    
        if (!projBudget.OriginalBudgetForecastModel || !projBudget.RemainingBudgetForecastModel)
        {
            checkFailed("@SYS300483");
            return;
        }

        select firstonly RecId from projBudgetLine
    where projBudgetLine.ProjBudget == _projBudgetRecID;

        if (!projBudgetLine.RecId)
        {
            checkFailed("@SYS300482");
            return;
        }

        try
        {
            if (projBudget.BudgetState !=ProjBudgetState::Committed)
            {
                ttsbegin;
                projBudgetManager.createBudgetCostForecast(projBudget, _projBudgetRevisionRecId);
                projBudgetManager.createBudgetEmplForecast(projBudget, _projBudgetRevisionRecId);
                projBudgetManager.createBudgetRevenueForecast(projBudget, _projBudgetRevisionRecId);
                projBudgetManager.createBudgetSalesForecast(projBudget, _projBudgetRevisionRecId);

                // do this on Commit Budget Only
                // the revision is being taking care of on updateFromRevisionCode
                if (_projBudgetRevisionRecId == 0)
                {
                    projBudget.setProjBudgetState(ProjBudgetState::Committed);
                    update_recordset projBudgetLine
                    setting CommittedRevisions = projBudgetLine.CommittedRevisions + projBudgetLine.UncommittedRevisions,
                            TotalBudget = projBudgetLine.OriginalBudget,
                            UncommittedRevisions = 0
                where projBudgetLine.ProjBudget == projBudget.RecId;
                }
                else
                {
                    projBudgetManager.updateFromRevision(_projBudgetRevisionRecId);
                }

                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    ttsabort;
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the project budget line based on the project type.
    /// </summary>
    /// <param name = "_projTable">
    ///     An instance of <c>ProjTable</c> table buffer.
    /// </param>
    /// <param name = "_projBudgetRecID">
    ///     The project budget record ID of the <c>ProjBudgetLine</c> table.
    /// </param>
    /// <returns>
    ///     true if <c>ProjBudgetLine</c> table record exists, otherwise false.
    /// </returns>
    protected static boolean validateProjBudgetLine(ProjTable _projTable, RecId _projBudgetRecID)
    {
        ProjBudgetLine projBudgetLine;

        switch (_projTable.Type)
        {
            case ProjType::Time:
                select firstonly RecId from projBudgetLine
                    where projBudgetLine.ProjBudget == _projBudgetRecID &&
                        projBudgetLine.ProjTransType != ProjTransType::Hour;

                if (projBudgetLine)
                {
                    checkFailed(strFmt("@SYS310807",projBudgetLine.ProjTransType,_projTable.Type));
                }
                break;

            case ProjType::Investment :
            case ProjType::Cost :
            case ProjType::Internal :
                select firstonly RecId from projBudgetLine
                    where projBudgetLine.ProjBudget == _projBudgetRecID &&
                        projBudgetLine.ProjTransType != ProjTransType::Hour &&
                        projBudgetLine.ProjTransType != ProjTransType::Cost &&
                        projBudgetLine.ProjTransType != ProjTransType::Item;

                if (projBudgetLine)
                {
                    checkFailed(strFmt("@SYS310807", projBudgetLine.ProjTransType,_projTable.Type));
                }
                break;

            case ProjType::None:
                if (!_projTable.ProjInvoiceProjId) // internal
                {
                    select firstonly RecId from projBudgetLine
                        where projBudgetLine.ProjBudget == _projBudgetRecID &&
                            projBudgetLine.ProjTransType != ProjTransType::Hour &&
                            projBudgetLine.ProjTransType != ProjTransType::Cost &&
                            projBudgetLine.ProjTransType != ProjTransType::Item;

                    if (projBudgetLine.RecId)
                    {
                        checkFailed(strFmt("@SYS310807", projBudgetLine.ProjTransType,_projTable.Type));
                    }
                }
                break;
        }

        return projBudgetLine ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRevenueBudgetLinesFromCostLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Revenue budget lines from Cost budget lines
    /// </summary>
    /// <param name="_projId">
    /// Project id
    /// </param>
    public static void createRevenueBudgetLinesFromCostLines(
        ProjId _projId)

    {
        ProjBudgetLine          projCostBudgetLine;
        ProjBudgetLine          projRevBudgetLine;
        ProjBudgetLine          projRevBudgetLineForInsertion;
        ProjBudgetLine          projRevBudgetLineForUpdation;
        ProjBudgetLineDetail    projCostBudgetLineDetail;
        ProjBudgetLineDetail    projRevBudgetLineDetailForInsertion;
        ProjTable               projectTable;
        AmountCur               origRevBudgetForLine;

        while select ProjId, ActivityNumber, ProjTransType, CategoryId, RecId, ProjBudget from projCostBudgetLine
            where projCostBudgetLine.ProjId like _projId + '*' &&
            projCostBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
            exists join projectTable
            where projectTable.ProjId  == projCostBudgetLine.ProjId &&
                  (projectTable.Type   == ProjType::TimeMaterial ||
                   projectTable.Type   == ProjType::FixedPrice ||
                   (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() && projectTable.ProjInvoiceProjId))
            notexists join projRevBudgetLine
            where projRevBudgetLine.CategoryId          == projCostBudgetLine.CategoryId &&
                  projRevBudgetLine.ProjTransType       == projCostBudgetLine.ProjTransType &&
                  projRevBudgetLine.ProjBudget          == projCostBudgetLine.ProjBudget &&
                  projRevBudgetLine.ProjId              == projCostBudgetLine.ProjId &&
                  projRevBudgetLine.ActivityNumber      == projCostBudgetLine.ActivityNumber &&
                  projRevBudgetLine.ProjBudgetLineType  == ProjBudgetLineType::Revenue
        {
            ttsbegin;
            projRevBudgetLineForInsertion.clear();
            projRevBudgetLineForInsertion.initValue();
            projRevBudgetLineForInsertion.CategoryId            = projCostBudgetLine.CategoryId;
            projRevBudgetLineForInsertion.ProjTransType         = projCostBudgetLine.ProjTransType;
            projRevBudgetLineForInsertion.ProjBudgetLineType    = ProjBudgetLineType::Revenue;
            projRevBudgetLineForInsertion.ProjBudget            = projCostBudgetLine.ProjBudget;
            projRevBudgetLineForInsertion.ProjId                = projCostBudgetLine.ProjId;
            projRevBudgetLineForInsertion.ActivityNumber        = projCostBudgetLine.ActivityNumber;
            projRevBudgetLineForInsertion.validateWrite();
            projRevBudgetLineForInsertion.insert();

            if (projRevBudgetLineForInsertion.RecId)
            {
                origRevBudgetForLine = 0;

                while select Resource, ResourceCategory, Quantity, ItemId, SalesUnitId, InventDimId
                    from projCostBudgetLineDetail
                    where projCostBudgetLineDetail.ProjBudgetLine == projCostBudgetLine.RecId
                {
                    projRevBudgetLineDetailForInsertion.clear();
                    projRevBudgetLineDetailForInsertion.initValue();
                    if (projCostBudgetLine.ProjTransType == ProjTransType::Cost ||
                        projCostBudgetLine.ProjTransType == ProjTransType::Hour)
                    {
                        projRevBudgetLineDetailForInsertion.Resource = projCostBudgetLineDetail.Resource;
                        projRevBudgetLineDetailForInsertion.ResourceCategory = projCostBudgetLineDetail.ResourceCategory;
                    }
                    else
                    if (projCostBudgetLine.ProjTransType == ProjTransType::Item)
                    {
                        projRevBudgetLineDetailForInsertion.ItemId      = projCostBudgetLineDetail.ItemId;
                        projRevBudgetLineDetailForInsertion.SalesUnitId = projCostBudgetLineDetail.SalesUnitId;
                        projRevBudgetLineDetailForInsertion.InventDimId = projCostBudgetLineDetail.InventDimId;
                    }
                    projRevBudgetLineDetailForInsertion.Quantity        = projCostBudgetLineDetail.Quantity;
                    projRevBudgetLineDetailForInsertion.ProjBudgetLine  = projRevBudgetLineForInsertion.RecId;
                    projRevBudgetLineDetailForInsertion.setPrice();
                    origRevBudgetForLine +=
                        projCostBudgetLineDetail.Quantity * projRevBudgetLineDetailForInsertion.SalesPrice;
                    projRevBudgetLineDetailForInsertion.validateWrite();
                    projRevBudgetLineDetailForInsertion.insert();
                }
            }

            if (origRevBudgetForLine)
            {
                update_recordset projRevBudgetLineForUpdation
                    setting OriginalBudget = origRevBudgetForLine
                    where projRevBudgetLineForUpdation.RecId == projRevBudgetLineForInsertion.RecId;

                origRevBudgetForLine = 0;
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the budget period details affected by the transaction.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID.
    /// </param>
    /// <param name="_projCategoryId">
    ///    The category ID.
    /// </param>
    /// <param name="_budgetLineType">
    ///    The budget type.
    /// </param>
    /// <param name="_transactionDate">
    ///    The transaction date.
    /// </param>
    /// <returns>
    ///    The container that holds the budget period details.
    /// </returns>
    public static container getBudgetPeriod(
    ProjId              _projId,
    ProjCategoryId      _projCategoryId,
    ProjBudgetLineType  _budgetLineType,
    ProjTransDate       _transactionDate)
    {
        ProjTable                   projTable;
        FiscalCalendarYear          fiscalCalendarYear;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        ProjBudgetLine              projBudgetLine;
        ProjBudgetAllocationLine    projBudgetAllocationLine;
        boolean                     isBudgetDefined;
        PeriodName                  periodName;
        LedgerFiscalCalendarPeriod  ledgerFiscalCalendarPeriod;

        void setPeriodName(ProjBudgetInterval _projBudgetInterval, ProjAllocationMethod _projAllocationMethod)
        {
            switch (_projBudgetInterval)
            {
                case ProjBudgetInterval::CurrentPeriod:
                case ProjBudgetInterval::ProjectToDate:
                case ProjBudgetInterval::TotalBudget:

                switch (_projAllocationMethod)
                    {
                        case ProjAllocationMethod::Periods:
                            periodName = fiscalCalendarPeriod.periodName();
                            break;
                        case ProjAllocationMethod::Quarter:
                            periodName = enum2str(projBudgetAllocationLine.Quarter);
                            break;
                        case ProjAllocationMethod::Yearly:
                            periodName = fiscalCalendarYear.yearName();
                            break;
                    }

                    break;
                case ProjBudgetInterval::TotalYear:
                case ProjBudgetInterval::YearToDate:
                    periodName = fiscalCalendarYear.yearName();
                    break;
            }
        }

        projTable = ProjTable::find(_projId);
        if (projTable.UseAlternateProject)
        {
            projTable = ProjTable::find(projTable.AlternateBudgetProject);
        }

        fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(CompanyInfo::current()), _transactionDate);
        if (fiscalCalendarYear)
        {
            select firstonly fiscalCalendarPeriod
            where fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId &&
                fiscalCalendarPeriod.StartDate <= _transactionDate &&
                fiscalCalendarPeriod.EndDate >= _transactionDate
            join RecId from ledgerFiscalCalendarPeriod
                where ledgerFiscalCalendarPeriod.Status == FiscalPeriodStatus::Open
                   && ledgerFiscalCalendarPeriod.Ledger == Ledger::current()
                   && ledgerFiscalCalendarPeriod.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId;

            if (fiscalCalendarPeriod)
            {
                if (projTable.ProjBudgetInterval == ProjBudgetInterval::TotalBudget)
                {
                    select firstonly RecId, ProjAllocationMethod from projBudgetLine
                    where projBudgetLine.ProjId == projTable.ProjId &&
                        projBudgetLine.CategoryId == _projCategoryId &&
                        projBudgetLine.ProjBudgetLineType == _budgetLineType;
                }
                else
                {
                    select firstonly RecId, ProjAllocationMethod from projBudgetLine
                    where projBudgetLine.ProjId == projTable.ProjId &&
                        projBudgetLine.CategoryId == _projCategoryId &&
                        projBudgetLine.ProjBudgetLineType == _budgetLineType
                    join RecId, Quarter from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId &&
                            ((projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId) ||
                            (projBudgetAllocationLine.FiscalCalendarYear == fiscalCalendarYear.RecId &&
                                (projBudgetAllocationLine.Quarter == fiscalCalendarPeriod.Quarter || !projBudgetAllocationLine.Quarter)));
                }

                if (projBudgetLine)
                {
                    isBudgetDefined = true;
                    setPeriodName(projTable.ProjBudgetInterval, projBudgetLine.ProjAllocationMethod);
                }
                else
                {
                    isBudgetDefined = false;
                    periodName = '';
                }
            }
        }

        return [isBudgetDefined, periodName];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultModelForProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns default Forecast model id for project (e.g., For forecast import)
    /// </summary>
    /// <param name="_projectId">
    /// Project for forecast import
    /// </param>
    /// <returns>
    /// Default Forecast model id
    /// </returns>
    public static ForecastModelId getDefaultModelForProject(ProjId _projectId)
    {
        ProjParameters      projParameters;
        ProjForecastUnion   projForecastUnion;

        select firstonly ModelId from projParameters
        exists join projForecastUnion
        where projForecastUnion.ModelId == projParameters.ModelId
        &&    projForecastUnion.ProjId like _projectId + '*'
        &&    projForecastUnion.ProjForecastBudgetType == ProjForecastBudgetType::None;

        return projParameters.ModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjBudgetBalancesDetailed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the detailed project balances and budget assigned to the specifies project.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID of the project.
    /// </param>
    /// <param name="_projBudgetBalanceInterval">
    ///    A <c>ProjBudgetBalanceInterval</c> data type value that specifies the interval that will be used to
    ///    filter the project balances.
    /// </param>
    /// <param name="_projBudgetLineType">
    ///    A <c>ProjBudgetLineType</c> value that indicates line type of the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_fromDate">
    ///    A <c>TransDate</c> data type value that indicates the from date for project balances; Optional.
    /// </param>
    /// <param name="_toDate">
    ///    A <c>TransDate</c> type value that indicates the to date for project balances; Optional.
    /// </param>
    /// <param name="_projControlId">
    ///    Specifies the cost template, used to retrieve information about cost lines.
    /// </param>
    /// <returns>
    ///    A temporary table instance with detailed budget ballances by project category.
    /// </returns>
    public static tmpProjBudgetBalances getProjBudgetBalancesDetailed(
                                                                ProjId _projId,
                                                                boolean _includeSubProjects,
                                                                ProjBudgetBalanceInterval _projBudgetBalanceInterval,
                                                                ProjBudgetLineType _projBudgetLineType,
                                                                TransDate _fromDate = dateNull(),
                                                                TransDate _toDate = maxdate(),
                                                                ProjControlId _projControlId = '')
    {
        ProjBudgetBalancesCalculator projBudgetBalancesCalculator;
        projBudgetBalancesCalculator = ProjBudgetBalancesCalculator::construct(
                                                                 _projId,
                                                                 _includeSubProjects,
                                                                 _projBudgetBalanceInterval,
                                                                 _projBudgetLineType,
                                                                 _fromDate,
                                                                 _toDate,
                                                                 _projControlId);

        return projBudgetBalancesCalculator.getProjBudgetBalancesDetailed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjBudgetBalances</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the project balances and budget assigned to the specifies project.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID of the project.
    /// </param>
    /// <param name="_projBudgetBalanceInterval">
    ///    A <c>ProjBudgetBalanceInterval</c> data type value that specifies the interval that will be used to
    ///    filter the project balances.
    /// </param>
    /// <param name="_projBudgetLineType">
    ///    A <c>ProjBudgetLineType</c> value that indicates line type of the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_fromDate">
    ///    A <c>TransDate</c> data type value that indicates the from date for project balances.
    /// </param>
    /// <param name="_toDate">
    ///    A <c>TransDate</c> type value that indicates the to date for project balances.
    /// </param>
    /// <param name="_projBudgetBalancesGroupByMethod">
    ///    A <c>ProjBudgetBalancesGroupByMethod</c> that species what field to group the balance summaries by.
    /// </param>
    /// <param name="_projControlId">
    ///    Specifies the cost template, applicable if _projBudgetBalancesGroupByMethod is
    /// ProjBudgetBalancesGroupByMethod::CostTemplate or ProjBudgetBalancesGroupByMethod::CostTemplateCategoryId
    /// </param>
    /// <returns>
    ///    A record in the <c>TmpProjBudgetBalances</c> table; otherwise, an empty buffer.
    /// </returns>
    public static tmpProjBudgetBalances getProjBudgetBalances(
                                                                ProjId _projId,
                                                                ProjBudgetBalanceInterval _projBudgetBalanceInterval,
                                                                ProjBudgetLineType _projBudgetLineType,
                                                                TransDate _fromDate = mkDate(01,01,1900),
                                                                TransDate _toDate = mkDate(01,01,1900),
                                                                ProjBudgetBalancesGroupByMethod _projBudgetBalancesGroupByMethod = ProjBudgetBalancesGroupByMethod::ProjTransType,
                                                                ProjControlId _projControlId = '')
    {
        ProjBudgetLine              projBudgetLine;
        ProjBudget                  projBudget;
        ProjBudgetAllocationLine    projBudgetAllocationLine;
        tmpProjBudgetBalances       tmpProjBudgetBalances;
        FiscalCalendarYear          fiscalCalendarYear;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        tmpProjBudgetBalances       tmpProjBudgetBalancesSum;

        void initTmpProjBudgetBalancesBuffer()
        {
            tmpProjBudgetBalances.clear();
            tmpProjBudgetBalances.ProjTable = _projId;
            tmpProjBudgetBalances.TransName = '';
            tmpProjBudgetBalances.CategoryId = '';
            tmpProjBudgetBalances.CategoryGroupId = '';
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::None;
            tmpProjBudgetBalances.CostGroupId = '';
        }

        //Below functions initializes the budget balances lines

        void initRevenue_Total()
        {
            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS79268";
            tmpProjBudgetBalances.insert();
        }

        void initCost_Total()
        {
            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS74805";
            tmpProjBudgetBalances.insert();
        }

        void initRevenue_ProjTransType()
        {
            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS9154";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Revenue;
            tmpProjBudgetBalances.insert();

            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS180590";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Hour;
            tmpProjBudgetBalances.insert();

            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS78349";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Cost;
            tmpProjBudgetBalances.insert();

            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS14428";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Item;
            tmpProjBudgetBalances.insert();

            initRevenue_Total();
        }

        void initCost_ProjTransType()
        {
            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS180544";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Hour;
            tmpProjBudgetBalances.insert();

            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS78349";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Cost;
            tmpProjBudgetBalances.insert();

            initTmpProjBudgetBalancesBuffer();
            tmpProjBudgetBalances.TransName = "@SYS14428";
            tmpProjBudgetBalances.ProjTranstype = ProjTransType::Item;
            tmpProjBudgetBalances.insert();

            initCost_Total();
        }

        void initCategory()
        {
            ProjCategory projCategory;
            ProjBudgetLine projBudgetLineLocal;
            while select CategoryId from projCategory
            group by projCategory.CategoryId
            exists join projBudgetLineLocal
            where
                projBudgetLineLocal.CategoryId == projCategory.CategoryId
                && projBudgetLineLocal.ProjBudgetLineType == _projBudgetLineType
                && projBudgetLineLocal.ProjId like _projId + #Star
            {
                initTmpProjBudgetBalancesBuffer();
                tmpProjBudgetBalances.TransName = projCategory.CategoryId;
                tmpProjBudgetBalances.CategoryId = projCategory.CategoryId;
                tmpProjBudgetBalances.insert();
            }
        }

        void initRevenue_Category()
        {
            initCategory();
            initRevenue_Total();
        }

        void initCost_Category()
        {
            initCategory();
            initCost_Total();
        }

        void initCategoryGroup()
        {
            ProjCategory projCategory;
            ProjBudgetLine projBudgetLineLocal;
            while select CategoryGroupId from projCategory
        group by projCategory.CategoryGroupId
        exists join projBudgetLineLocal
        where
            projBudgetLineLocal.CategoryId == projCategory.CategoryId
            && projBudgetLineLocal.ProjBudgetLineType == _projBudgetLineType
            && projBudgetLineLocal.ProjId like _projId + #Star
            {
                initTmpProjBudgetBalancesBuffer();
                tmpProjBudgetBalances.TransName = projCategory.CategoryGroupId;
                tmpProjBudgetBalances.CategoryGroupId = projCategory.CategoryGroupId;
                tmpProjBudgetBalances.insert();
            }
        }

        void initRevenue_CategoryGroup()
        {
            initCategoryGroup();
            initRevenue_Total();
        }

        void initCost_CategoryGroup()
        {
            initCategoryGroup();
            initCost_Total();
        }

        void initCostTemplate()
        {
            ProjControlCostGroup projControlCostGroup;
            ProjBudgetLine projBudgetLineLocal;

            while select CostGroupId from projControlCostGroup
            group by projControlCostGroup.CostGroupId
            where projControlCostGroup.ControlId == _projControlId
            {
                initTmpProjBudgetBalancesBuffer();
                tmpProjBudgetBalances.TransName = projControlCostGroup.CostGroupId;
                tmpProjBudgetBalances.CostGroupId = projControlCostGroup.CostGroupId;
                tmpProjBudgetBalances.insert();
            }
        }

        void initRevenue_CostTemplate()
        {
            initCostTemplate();
            initRevenue_Total();
        }

        void initCost_CostTemplate()
        {
            initCostTemplate();
            initCost_Total();
        }

        void initCategoryGroup_Category()
        {
            ProjCategory projCategory;
            ProjBudgetLine projBudgetLineLocal;
            while select CategoryGroupId, CategoryId from projCategory
        group by projCategory.CategoryGroupId, projCategory.CategoryId
        exists join projBudgetLineLocal
        where
            projBudgetLineLocal.CategoryId == projCategory.CategoryId
            && projBudgetLineLocal.ProjBudgetLineType == _projBudgetLineType
            && projBudgetLineLocal.ProjId like _projId + #Star
            {
                initTmpProjBudgetBalancesBuffer();
                tmpProjBudgetBalances.TransName = projCategory.CategoryId;
                tmpProjBudgetBalances.CategoryGroupId = projCategory.CategoryGroupId;
                tmpProjBudgetBalances.CategoryId = projCategory.CategoryId;
                tmpProjBudgetBalances.insert();
            }
        }

        void initRevenue_CategoryGroup_Category()
        {
            initCategoryGroup_Category();
        }

        void initCost_CategoryGroup_Category()
        {
            initCategoryGroup_Category();
        }

        void initTransType_Category()
        {
            ProjBudgetLine projBudgetLineLocal;
            while select CategoryId, ProjTransType from projBudgetLineLocal
        group by projBudgetLineLocal.CategoryId, projBudgetLineLocal.ProjTransType
        where
            projBudgetLineLocal.ProjBudgetLineType == _projBudgetLineType
            && projBudgetLineLocal.ProjId like _projId + #Star
            {
                initTmpProjBudgetBalancesBuffer();
                tmpProjBudgetBalances.TransName = projBudgetLineLocal.CategoryId;
                tmpProjBudgetBalances.ProjTranstype = projBudgetLineLocal.ProjTransType;
                tmpProjBudgetBalances.CategoryId = projBudgetLineLocal.CategoryId;
                tmpProjBudgetBalances.insert();
            }
        }

        void initRevenue_TransType_Category()
        {
            initTransType_Category();
        }

        void initCost_TransType_Category()
        {
            initTransType_Category();
        }

        void initCostTemplate_Category()
        {
            ProjControlCategory     projControlCategory;
            ProjBudgetLine          projBudgetLineLocal;
            while select CategoryId, CostGroupId from projControlCategory
            where projControlCategory.ControlId == _projControlId
        exists join projBudgetLineLocal
            where projBudgetLineLocal.CategoryId == projControlCategory.CategoryId
                && projBudgetLineLocal.ProjBudgetLineType == _projBudgetLineType
                && projBudgetLineLocal.ProjId like _projId + #Star
            {
                initTmpProjBudgetBalancesBuffer();
                tmpProjBudgetBalances.TransName = projControlCategory.CategoryId;
                tmpProjBudgetBalances.CostGroupId = projControlCategory.CostGroupId;
                tmpProjBudgetBalances.CategoryId = projControlCategory.CategoryId;
                tmpProjBudgetBalances.insert();
            }
        }

        void initRevenue_CostTemplate_Category()
        {
            initCostTemplate_Category();
        }

        void initCost_CostTemplate_Category()
        {
            initCostTemplate_Category();
        }

        // Below functions calculates and updates project balance lines

        void calcSubTotals()
        {
            real origbudget = 0.0, amendbudget = 0.0, carryforward = 0.0, unapprovedrevisions = 0.0, revisedbudget = 0.0, actualbudget = 0.0, committedbudget = 0.0, remainingbudget = 0.0;

            tmpProjBudgetBalancesSum = tmpProjBudgetBalances;

            if (!tmpProjBudgetBalancesSum)
            {
                select sum(OrigBudget), sum(AmendBudget), sum(UnapprovedRevisions), sum(RevisedBudget),
                sum(ActualRevAndCosts),sum(CommittedCosts),sum(RemainingBudget), sum(CarryForwardBudget)
            from tmpProjBudgetBalancesSum;
            }

            origbudget          = tmpProjBudgetBalancesSum.OrigBudget;
            amendbudget         = tmpProjBudgetBalances.AmendBudget;
            unapprovedrevisions = tmpProjBudgetBalances.UnapprovedRevisions;
            revisedbudget       = tmpProjBudgetBalancesSum.RevisedBudget;
            actualbudget        = tmpProjBudgetBalancesSum.ActualRevAndCosts;
            committedbudget     = tmpProjBudgetBalancesSum.CommittedCosts;
            remainingbudget     = tmpProjBudgetBalancesSum.RemainingBudget;
            carryforward        = tmpProjBudgetBalancesSum.CarryForwardBudget;

            select forupdate tmpProjBudgetBalances
            where tmpProjBudgetBalances.ProjTranstype   == ProjTransType::None
            && tmpProjBudgetBalances.CategoryId         == ''
            && tmpProjBudgetBalances.CategoryGroupId    == ''
            && tmpProjBudgetBalances.CostGroupId        == '';

            tmpProjBudgetBalances.OrigBudget            = origbudget;
            tmpProjBudgetBalances.AmendBudget           = amendbudget;
            tmpProjBudgetBalances.UnapprovedRevisions   = unapprovedrevisions;
            tmpProjBudgetBalances.RevisedBudget         = revisedbudget;
            tmpProjBudgetBalances.ActualRevAndCosts     = actualbudget;
            tmpProjBudgetBalances.CommittedCosts        = committedbudget;
            tmpProjBudgetBalances.RemainingBudget       = remainingbudget;
            tmpProjBudgetBalances.CarryForwardBudget    = carryforward;
            tmpProjBudgetBalances.update();
        }

        void updateTmpProjBudgetBalances()
        {
            //updates current budget balance line
            ProjBudgetReductionHistory      projBudgetReductionHistory;
            CostControlTransCommittedCost   costControlTransCommittedCost;
            ProjPostTransView               projPostTransView;
            AmountCur                       committedRevisions;
            ProjItemTrans                   projItemTrans;

            committedRevisions = (projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Approved ? projBudgetAllocationLine.OriginalAllocationAmount : 0);
            tmpProjBudgetBalances.OrigBudget += projBudgetAllocationLine.OriginalAllocationAmount;
            tmpProjBudgetBalances.AmendBudget += projBudgetAllocationLine.CommittedRevisions;
            tmpProjBudgetBalances.UnapprovedRevisions += projBudgetAllocationLine.UncommittedRevisions;
            tmpProjBudgetBalances.RevisedBudget += (committedRevisions + projBudgetAllocationLine.CommittedRevisions);
            tmpProjBudgetBalances.CarryForwardBudget += (projBudgetAllocationLine.TotalAllocationAmount - committedRevisions - projBudgetAllocationLine.CommittedRevisions);
            tmpProjBudgetBalances.RemainingBudget += projBudgetAllocationLine.TotalAllocationAmount;
            switch (_projBudgetLineType)
            {
                case ProjBudgetLineType::Revenue:
                select sum(SalesAmountReduced) from projBudgetReductionHistory
                    where projBudgetReductionHistory.ProjBudgetAllocationLineIdSales == projBudgetAllocationLine.RecId
                        exists join costControlTransCommittedCost
                            where costControlTransCommittedCost.ProjTransId == projBudgetReductionHistory.ProjTransId &&
                                costControlTransCommittedCost.Open == NoYes::Yes;
                    tmpProjBudgetBalances.CommittedCosts += projBudgetReductionHistory.SalesAmountReduced;
                    tmpProjBudgetBalances.RemainingBudget -= projBudgetReductionHistory.SalesAmountReduced;

                    select sum(SalesAmountReduced) from projBudgetReductionHistory
                    where projBudgetReductionHistory.ProjBudgetAllocationLineIdSales == projBudgetAllocationLine.RecId
                        exists join projPostTransView
                            where projPostTransView.TransId == projBudgetReductionHistory.ProjTransId;
                    tmpProjBudgetBalances.ActualRevAndCosts += projBudgetReductionHistory.SalesAmountReduced;
                    tmpProjBudgetBalances.RemainingBudget -= projBudgetReductionHistory.SalesAmountReduced;
                    break;

                case ProjBudgetLineType::Cost:
                select sum(CostAmountReduced) from projBudgetReductionHistory
                    where projBudgetReductionHistory.ProjBudgetAllocationLineIdCost == projBudgetAllocationLine.RecId
                        exists join costControlTransCommittedCost
                            where costControlTransCommittedCost.ProjTransId == projBudgetReductionHistory.ProjTransId &&
                                costControlTransCommittedCost.Open == NoYes::Yes;
                    tmpProjBudgetBalances.CommittedCosts += projBudgetReductionHistory.CostAmountReduced;
                    tmpProjBudgetBalances.RemainingBudget -= projBudgetReductionHistory.CostAmountReduced;

                    // For item based transactions, get the budget reduction history based off TransIdRef (instead of TransId)
                    // related to changes in DAXSE_918627
                    if (tmpProjBudgetBalances.ProjTranstype == ProjTransType::Item)
                    {
                        select sum(TotalCostAmountCur) from projItemTrans
                        join projBudgetReductionHistory
                        where projItemTrans.ProjTransIdRef == projBudgetReductionHistory.ProjTransId
                           && projBudgetReductionHistory.ProjBudgetAllocationLineIdCost == projBudgetAllocationLine.RecId;

                        tmpProjBudgetBalances.ActualRevAndCosts += projItemTrans.TotalCostAmountCur;
                        tmpProjBudgetBalances.RemainingBudget -= projItemTrans.TotalCostAmountCur;
                    }
                    else
                    {
                        select sum(CostAmountReduced) from projBudgetReductionHistory
                        where projBudgetReductionHistory.ProjBudgetAllocationLineIdCost == projBudgetAllocationLine.RecId
                            exists join projPostTransView
                                where projPostTransView.TransId == projBudgetReductionHistory.ProjTransId;

                        tmpProjBudgetBalances.ActualRevAndCosts += projBudgetReductionHistory.CostAmountReduced;
                        tmpProjBudgetBalances.RemainingBudget -= projBudgetReductionHistory.CostAmountReduced;
                    }

                    break;

                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
        }

        // Below functions select project budget line, allocation lines and etc, then calls calculation functions

        void processNoFilter()
        {
            //Select all allocation lines associated with the current budget line.
            //Calculate and update current balance line using selected allocation lines
            while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
            from projBudgetAllocationLine
            where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
            {
                updateTmpProjBudgetBalances();
            }
        }

        void processProjectToDate()
        {
            //Select allocation lines with:
            // 1) a fiscal calendar that intersects with _fromDate to _toDate
            // 2) and is associated with the current budget line.
            //Calculate and update current balance line using selected allocation lines
            switch (projBudgetLine.ProjAllocationMethod)
            {
                case ProjAllocationMethod::Quarter:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.FiscalCalendarYear == projBudgetAllocationLine.FiscalCalendarYear &&
                            fiscalCalendarPeriod.Quarter == projBudgetAllocationLine.Quarter &&
                            fiscalCalendarPeriod.StartDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;

                case ProjAllocationMethod::Periods:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == projBudgetAllocationLine.FiscalCalendarPeriod &&
                            fiscalCalendarPeriod.StartDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;
                case ProjAllocationMethod::Yearly:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarYear
                        where fiscalCalendarYear.RecId == projBudgetAllocationLine.FiscalCalendarYear &&
                            fiscalCalendarYear.StartDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;
            }
        }

        void processCurrentYear()
        {
            //Select allocation lines with :
            // 1) a fiscal calendar year that includes today
            // 2) and is associated with the current budget line
            //Calculate and update current balance line using selected allocation lines
            switch (projBudgetLine.ProjAllocationMethod)
            {
                case ProjAllocationMethod::Quarter:

                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.FiscalCalendarYear == projBudgetAllocationLine.FiscalCalendarYear &&
                            fiscalCalendarPeriod.Quarter == projBudgetAllocationLine.Quarter
                        join RecId from fiscalCalendarYear
                            where fiscalCalendarYear.RecId == fiscalCalendarPeriod.FiscalCalendarYear &&
                                fiscalCalendarYear.StartDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) &&
                                fiscalCalendarYear.EndDate >= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;

                case ProjAllocationMethod::Periods:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == projBudgetAllocationLine.FiscalCalendarPeriod
                        join RecId from fiscalCalendarYear
                            where fiscalCalendarYear.RecId == fiscalCalendarPeriod.FiscalCalendarYear &&
                                fiscalCalendarYear.StartDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) &&
                                fiscalCalendarYear.EndDate >= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;

                case ProjAllocationMethod::Yearly:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    join RecId from fiscalCalendarYear
                        where fiscalCalendarYear.RecId == projBudgetAllocationLine.FiscalCalendarYear &&
                            fiscalCalendarYear.StartDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) &&
                            fiscalCalendarYear.EndDate >= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;
            }
        }

        void processCustomRange()
        {
            //Select allocation lines with :
            // 1) a fiscal calendar that intersects with _fromDate to _toDate
            // 2) and is associated with the current budget line
            //Calculate and update current balance line using selected allocation lines
            switch (projBudgetLine.ProjAllocationMethod)
            {
                case ProjAllocationMethod::Quarter:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.FiscalCalendarYear == projBudgetAllocationLine.FiscalCalendarYear &&
                            fiscalCalendarPeriod.Quarter == projBudgetAllocationLine.Quarter &&
                            fiscalCalendarPeriod.StartDate <= _toDate &&
                            fiscalCalendarPeriod.EndDate >= _fromDate
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;
                case ProjAllocationMethod::Periods:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == projBudgetAllocationLine.FiscalCalendarPeriod &&
                            fiscalCalendarPeriod.StartDate <= _toDate &&
                            fiscalCalendarPeriod.EndDate >= _fromDate
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;

                case ProjAllocationMethod::Yearly:
                while select OriginalAllocationAmount, CommittedRevisions,  UncommittedRevisions, TotalAllocationAmount, CarryForwardAmount, RecId
                    from projBudgetAllocationLine
                        where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                    exists join RecId from fiscalCalendarYear
                        where fiscalCalendarYear.RecId == projBudgetAllocationLine.FiscalCalendarYear &&
                            fiscalCalendarYear.StartDate <= _toDate &&
                            fiscalCalendarYear.EndDate >= _fromDate
                    {
                        updateTmpProjBudgetBalances();
                    }
                    break;
            }
        }

        void processBudgetLine()
        {
            //Update the current balance line by using the current budget line.
            //Select actual calculation function.
            switch (_projBudgetBalanceInterval)
            {
                case ProjBudgetBalanceInterval::None:
                    processNoFilter();
                    break;

                case ProjBudgetBalanceInterval::ProjectToDate:
                    processProjectToDate();
                    break;

                case ProjBudgetBalanceInterval::CurrentYear:
                    processCurrentYear();
                    break;

                case ProjBudgetBalanceInterval::CustomRange:
                    processCustomRange();
                    break;
            }
            tmpProjBudgetBalances.update();
        }

        void groupbyTransType()
        {
            //Assumption: each balance line contains a unique transtype
            while select forupdate tmpProjBudgetBalances
            {
                //All budgetline with matching transaction type and associated with
                //_projId
                while select RecId, ProjAllocationMethod from projBudgetLine
                    where projBudgetLine.ProjBudgetLineType == _projBudgetLineType
                          && projBudgetLine.ProjId like _projId + #Star
                          && projBudgetLine.ProjTransType == tmpProjBudgetBalances.ProjTranstype
                    join BudgetWorkflowStatus from projBudget
                        where projBudget.RecId == projBudgetLine.ProjBudget
                {
                    processBudgetLine();
                }
            }
        }

        void groupbyCategory()
        {
            //Assumption: each balance line contains a unique category
            while select forupdate tmpProjBudgetBalances
            {
                //All budgetline with matching category and associated with
                //_projId
                while select RecId, ProjAllocationMethod from projBudgetLine
                    where projBudgetLine.ProjBudgetLineType == _projBudgetLineType
                        && projBudgetLine.ProjId like _projId + #Star
                        && projBudgetLine.CategoryId == tmpProjBudgetBalances.CategoryId
                    join BudgetWorkflowStatus from projBudget
                        where projBudget.RecId == projBudgetLine.ProjBudget
                {
                    processBudgetLine();
                }
            }
        }

        void groupbyCategoryGroup()
        {
            ProjCategory projCategory;

            //Assumption: each balance line contains a unique category group
            while select forupdate tmpProjBudgetBalances
            {
                //All budgetline with matching category group and associated with
                //_projId
                while select RecId, ProjAllocationMethod from projBudgetLine
                    where projBudgetLine.ProjBudgetLineType == _projBudgetLineType
                          && projBudgetLine.ProjId like _projId + #Star
                    join BudgetWorkflowStatus from projBudget
                        where projBudget.RecId == projBudgetLine.ProjBudget
                    exists join projCategory
                        where projCategory.CategoryId == projBudgetLine.CategoryId
                        && projCategory.CategoryGroupId == tmpProjBudgetBalances.CategoryGroupId
                {
                    processBudgetLine();
                }
            }
        }

        void groupbyCostTemplate()
        {
            ProjControlCategory projControlCategory;
            while select forupdate tmpProjBudgetBalances
            {
                while select RecId, ProjAllocationMethod from projBudgetLine
                    where projBudgetLine.ProjBudgetLineType == _projBudgetLineType
                          && projBudgetLine.ProjId like _projId + #Star
                    join BudgetWorkflowStatus from projBudget
                        where projBudget.RecId == projBudgetLine.ProjBudget
                    exists join projControlCategory
                        where projControlCategory.CategoryId == projBudgetLine.CategoryId
                            && projControlCategory.ControlId == _projControlId
                            && projControlCategory.CostGroupId == tmpProjBudgetBalances.CostGroupId
                {
                    processBudgetLine();
                }
            }
        }

        void groupbyTransType_Category()
        {
            //This works because each category belongs to only one category type
            //which correspond to transaction type in a one to one fashion.
            //and since we are grouping by transaction type group AND category
            //the categories are unique.
            groupbyCategory();
        }

        void groupbyCategoryGroup_Category()
        {
            //This works because each category belongs to only one category group
            //and since we are grouping by category group AND category
            //the categories are unique.
            groupbyCategory();
        }

        void groupbyCostTemplate_Category()
        {
            //This works because each category belongs to only one cost line for a cost template
            //and since we are grouping by cost line AND category
            //the categories are unique.
            groupbyCategory();
        }

        ttsbegin;

        // Calculates project balances, options are
        // ProjBudgetLineType x ProjBudgetBalancesGroupByMethod
        // e.g. (Cost, CategoryId)

        tmpProjBudgetBalances.clear();

        //In each option do:
        // 1) initialize the project balance lines
        // 2) select budget line, allocation line and etc
        // 3) calcuate and update each line
        switch (_projBudgetLineType)
        {
            case ProjBudgetLineType::Revenue:
            switch (_projBudgetBalancesGroupByMethod)
                {
                    case ProjBudgetBalancesGroupByMethod::ProjTransType:
                        initRevenue_ProjTransType();
                        groupbyTransType();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CategoryGroupId:
                        initRevenue_CategoryGroup();
                        groupbyCategoryGroup();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CostTemplate:
                        initRevenue_CostTemplate();
                        groupByCostTemplate();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CategoryId:
                        initRevenue_Category();
                        groupByCategory();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::ProjTransTypeCategoryId:
                        initRevenue_TransType_Category();
                        groupbyTransType_Category();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CategoryGroupCategoryId:
                        initRevenue_CategoryGroup_Category();
                        groupbyCategoryGroup_Category();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CostTemplateCategoryId:
                        initRevenue_CostTemplate_Category();
                        groupbyCostTemplate_Category();
                        break;
                }
                break;

            case ProjBudgetLineType::Cost:
            switch (_projBudgetBalancesGroupByMethod)
                {
                    case ProjBudgetBalancesGroupByMethod::ProjTransType:
                        initCost_ProjTransType();
                        groupbyTransType();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CategoryGroupId:
                        initCost_CategoryGroup();
                        groupbyCategoryGroup();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CostTemplate:
                        initCost_CostTemplate();
                        groupByCostTemplate();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CategoryId:
                        initCost_Category();
                        groupByCategory();
                        calcSubTotals();
                        break;
                    case ProjBudgetBalancesGroupByMethod::ProjTransTypeCategoryId:
                        initCost_TransType_Category();
                        groupbyTransType_Category();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CategoryGroupCategoryId:
                        initCost_CategoryGroup_Category();
                        groupbyCategoryGroup_Category();
                        break;
                    case ProjBudgetBalancesGroupByMethod::CostTemplateCategoryId:
                        initCost_CostTemplate_Category();
                        groupbyCostTemplate_Category();
                        break;
                }
                break;
        }

        ttscommit;

        return tmpProjBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInterval</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the number of intervals between two dates.
    /// </summary>
    /// <param name="_projAllocationMethod">
    ///    A <c>ProjAllocationMethod</c> enumeration value that specifies the allocation method.
    /// </param>
    /// <param name="_allocationStartDate">
    ///    The start date of the allocation.
    /// </param>
    /// <param name="_allocationEndDate">
    ///    The end date of the allocation.
    /// </param>
    /// <returns>
    ///    An integer value that indicates the number of intervals.
    /// </returns>
    public static RecId getTotalInterval(ProjAllocationMethod _projAllocationMethod, TransDate _allocationStartDate, TransDate _allocationEndDate)
    {
        FiscalCalendarYear          fiscalCalendarYear;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        RecId                       fiscalCalendar;
        RecId                       totalInterval;
        RecId                       totalQuarter;

        fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());

        switch (_projAllocationMethod)
        {
            case ProjAllocationMethod::Yearly:
                select count(RecId) from fiscalCalendarYear
                where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
                &&
                (
                    fiscalCalendarYear.StartDate >= _allocationStartDate && fiscalCalendarYear.EndDate <= _allocationEndDate
                );
                totalInterval = fiscalCalendarYear.RecId;
                break;

            case  ProjAllocationMethod::Periods:
                select count(RecId) from fiscalCalendarPeriod
                join    fiscalCalendarYear
                where fiscalCalendarYear.FiscalCalendar == fiscalCalendar
                &&    fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId
                &&    fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                &&
                (
                    fiscalCalendarPeriod.StartDate >= _allocationStartDate && fiscalCalendarPeriod.EndDate <= _allocationEndDate
                );
                totalInterval = fiscalCalendarPeriod.RecId;
                break;

            case  ProjAllocationMethod::Quarter:
                while select count(RecId) from fiscalCalendarPeriod
                join fiscalCalendarYear
                group by fiscalCalendarPeriod.Quarter, fiscalCalendarPeriod.FiscalCalendarYear
                where fiscalCalendarPeriod.FiscalCalendarYear == fiscalCalendarYear.RecId
                && fiscalCalendarYear.FiscalCalendar == fiscalCalendar
                &&
                (
                    fiscalCalendarPeriod.StartDate >= _allocationStartDate && fiscalCalendarPeriod.EndDate <= _allocationEndDate
                )
                {
                    totalQuarter++;
                }
                totalInterval = totalQuarter;
                break;
        }
        return  totalInterval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        ProjBudget                  projBudget;
        ProjBudgetManagerActionType projBudgetManagerActionType;

        projBudget = args.record();

        projBudgetManagerActionType = args.parmEnum();

        if (!projBudget.RecId)
        {
            throw error(Error::missingRecord("@SYS15292"));
        }
        try
        {
            ttsbegin;
            switch (projBudgetManagerActionType)
            {
                case ProjBudgetManagerActionType::Commit:
                    ProjBudgetManager::commitBudget(projBudget.RecId);
                    break;

                case ProjBudgetManagerActionType::NewAmendment:

                    projBudget = ProjBudget::find(projBudget.RecId,true);
                    projBudget.setProjBudgetState(ProjBudgetState::Amendment);

                    break;

                case ProjBudgetManagerActionType::CancelAmendment:
                    ProjBudgetManager::cancelAmendment(projBudget.RecId);
                    break;
                default:
                    throw error(strFmt("@SYS68912",funcName()));
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    ttsabort;
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            throw error("@SYS18447");
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>projAllocationMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Looks for the existing allocation method for the project budget line.
    /// </summary>
    /// <param name="_projBudgetLine">
    /// A record from the <c>ProjBudgetLine</c> table to use to find the existing allocation.
    /// </param>
    /// <param name="_isBudgetAllocation">
    /// true for budget allocation; false for revision allocation.
    /// </param>
    /// <returns>
    /// true if allocation exists; otherwise, false. The project allocation method.
    /// </returns>
    private static container projAllocationMethod(ProjBudgetLine _projBudgetLine, boolean _isBudgetAllocation)
    {
        ProjForecastCost        projForecastCost;
        ProjForecastEmpl        projForecastEmpl;
        ForecastSales           forecastSales;
        ProjForecastRevenue     projForecastRevenue;

        ProjAllocationMethod    projAllocationMethod;
        boolean                 previousAllocationExists;

        ProjAllocationMethod findPreviousAllocationMethodofTransaction()
        {
            ProjBudgetLine projBudgetLineFindAllocationMethod;

            select ProjAllocationMethod,RecId
        from projBudgetLineFindAllocationMethod
        where projBudgetLineFindAllocationMethod.ProjTransType == _projBudgetLine.ProjTransType
        &&    projBudgetLineFindAllocationMethod.ProjBudgetLineType == _projBudgetLine.ProjBudgetLineType
        &&    projBudgetLineFindAllocationMethod.ProjBudget == _projBudgetLine.ProjBudget
        &&    !projBudgetLineFindAllocationMethod.OriginalBudget;

            if (projBudgetLineFindAllocationMethod.RecId)
            {
                previousAllocationExists = true;
            }

            return projBudgetLineFindAllocationMethod.ProjAllocationMethod;
        }

        switch (_projBudgetLine.ProjTransType)
        {
            case ProjTransType::Cost:
                // finding whether any budget forecast exists for current project.
                select firstonly RecId from projForecastCost
            where projForecastCost.ProjId == _projBudgetLine.ProjId
            && projForecastCost.ProjForecastBudgetType != ProjForecastBudgetType::None;

                if (projForecastCost.RecId)
                {
                    projAllocationMethod = findPreviousAllocationMethodofTransaction();
                }
                break;

            case ProjTransType::Hour:
            select firstonly RecId from projForecastEmpl
            where projForecastEmpl.ProjId == _projBudgetLine.ProjId
            && projForecastEmpl.ProjForecastBudgetType != ProjForecastBudgetType::None;

                if (projForecastEmpl.RecId)
                {
                    projAllocationMethod = findPreviousAllocationMethodofTransaction();
                }
                break;

            case ProjTransType::Item:
            select firstonly RecId from  forecastSales
            where forecastSales.ProjId == _projBudgetLine.ProjId
            && forecastSales.ProjForecastBudgetType != ProjForecastBudgetType::None;

                if (forecastSales.RecId)
                {
                    projAllocationMethod = findPreviousAllocationMethodofTransaction();
                }

                break;

            case ProjTransType::Revenue:
            select firstonly RecId from projForecastRevenue
            where projForecastRevenue.ProjId == _projBudgetLine.ProjId
            && projForecastRevenue.ProjForecastBudgetType != ProjForecastBudgetType::None;

                if (projForecastRevenue.RecId)
                {
                    projAllocationMethod = findPreviousAllocationMethodofTransaction();
                }

                break;
        }

        return [previousAllocationExists, projAllocationMethod];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProfitablityForFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check profitablity for Fixed price project based on Revenue budget lines and project contract value (on-account milestones).
    /// </summary>
    /// <param name="_projectId">
    /// Project id
    /// </param>
    /// <returns>
    /// False if the project is unprofitable and the user cancels the current operation when shown a warning, true otherwise.
    /// </returns>
    public static boolean checkProfitablityForFixedPrice(ProjId _projectId)
    {
        ProjBudgetLine          projBudgetLine;
        DialogButton            dialogButton;
        boolean                 warnAccepted = true;
        ProjOnAccTrans          projOnAccTrans;
        ProjOnAccTransSale      projOnAccTransSale;
        ProjTable               projTable;
        String15                includeSubProjects;
        AmountMST               mstAmount;
        CurrencyCode            companyCurrencyCode = Ledger::accountingCurrencyByLedger(Ledger::current());
        CurrencyExchangeHelper  currencyExchangeHelper;

        projTable = ProjTable::find(_projectId);
        if (projTable.Type == ProjType::FixedPrice ||
            (projTable.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            if (projTable.ProjBudgetManagement == ProjBudgetManagement::Independent)
            {
                includeSubProjects = "";
            }
            else
            {
                includeSubProjects = "*";
            }

            select sum(OriginalBudget), sum(CommittedRevisions), sum(UnCommittedRevisions) from projBudgetLine
                where  projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Revenue
                &&  projBudgetLine.ProjId like _projectId + includeSubProjects;

            while select Amount from projOnAccTransSale
                join TransId, ProjId, TransDate, CurrencyId from projOnAccTrans
                where projOnAccTransSale.TransId == projOnAccTrans.TransId
                && projOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                && projOnAccTrans.ProjId like _projectId + includeSubProjects
            {
                if (companyCurrencyCode != projOnAccTrans.CurrencyId)
                {
                    currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::current(),
                        projOnAccTrans.TransDate);

                    currencyExchangeHelper.parmExchangeRate1(0);
                    currencyExchangeHelper.parmExchangeRate2(0);

                    mstAmount += currencyExchangeHelper.calculateTransactionToAccounting(projOnAccTrans.CurrencyId, projOnAccTransSale.Amount, true);
                }
                else
                {
                    mstAmount += projOnAccTransSale.Amount;
                }
            }

            if ((projBudgetLine.OriginalBudget + projBudgetLine.CommittedRevisions + projBudgetLine.UncommittedRevisions) > mstAmount)
            {
                dialogButton = Box::okCancel("@SYP4881399",
                        DialogButton::Ok,
                        "@SYP4881398",
                        "");

                if (dialogButton == DialogButton::Cancel)
                {
                    warnAccepted = false;
                }
            }
        }

        return warnAccepted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjBudgetFiscalYear</Name>
				<Source><![CDATA[
    private FiscalCalendarYear getProjBudgetFiscalYear(RecId _projBudgetLineRecId)
    {
        RecId               fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());
        ProjBudgetLine      projBudgetLine = ProjBudgetLine::find(_projBudgetLineRecId);
        FiscalCalendarYear  fiscalCalendarYear;

        if (projBudgetLine)
        {
            //CreatedDateTime field is used for the look up to fetch the project budget creation date.
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendar , DateTimeUtil::date(projBudgetLine.CreatedDateTime));
        }

        if (!fiscalCalendarYear.RecId)
        {
            fiscalCalendarYear = this.getProjectFiscalYear(projBudgetLine.ProjId);
        }

        return fiscalCalendarYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>ProjBudgetLine</c> table buffer.
    /// </summary>
    /// <param name="_categoryId">
    /// The category ID to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_projTransType">
    /// The project transaction type to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_originalAmount">
    /// The original amount to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_projBudgetLineType">
    /// The project budget line type to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_projBudget">
    /// The project budget ID to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_projId">
    /// The project ID to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <param name="_activityNumber">
    /// The activity number to set on the new <c>ProjBudgetLine</c> record.
    /// </param>
    /// <returns>
    /// A <c>ProjBudgetLine</c> table buffer.
    /// </returns>
    protected ProjBudgetLine initializeProjBudgetLine(CategoryId        _categoryId,
                                                    ProjTransType      _projTransType,
                                                    AmountCur          _originalAmount,
                                                    ProjBudgetLineType _projBudgetLineType,
                                                    RecId              _projBudget,
                                                    ProjId             _projId,
                                                    ProjActivityNumber _activityNumber)
    {
        ProjBudgetLine projBudgetLine;

        projBudgetLine.CategoryId           = _categoryId;
        projBudgetLine.ProjTransType        = _projTransType;
        projBudgetLine.OriginalBudget       = _originalAmount;
        projBudgetLine.CommittedRevisions   = 0 ;
        projBudgetLine.UncommittedRevisions = 0 ;
        projBudgetLine.TotalBudget          = 0;
        projBudgetLine.ProjBudgetLineType   = _projBudgetLineType;
        projBudgetLine.ProjBudget           = _projBudget;
        projBudgetLine.ProjId               = _projId;
        projBudgetLine.ActivityNumber       = _activityNumber;

        return projBudgetLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetUncommittedRevisions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the allocation lines based on budget line.
    /// </summary>
    /// <param name="_projBudgetLine">
    /// A <c>ProjBudgetLine</c> table <c>RecId</c> that contains the information about the project budget line.
    /// </param>
    private void resetUncommittedRevisions(RecId _projBudgetLine)
    {
        ProjBudgetAllocationLine projBudgetAllocationLine;

        update_recordset projBudgetAllocationLine
            setting UncommittedRevisions = 0
            where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpForecastsForNonExistingPSAActivityEstimates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove forecast entries which are referenced by this project ID and model ID for
    /// which the referenced WBS task <c>ActivityNumber</c> are not referenced by <c>AcitivityEstimates</c> table.
    /// </summary>
    private void cleanUpForecastsForNonExistingPSAActivityEstimates(PSAActivityEstimates _psaActivityEstimates,  ProjId _projId, ProjForecastModelId _modelId)
    {
        ProjForecastEmpl     hourForecastTable;
        ProjForecastCost     costForecastTable;
        ProjForecastRevenue  revForecastTable;
        ForecastSales        forecastSales;

        ttsbegin;

        delete_from hourForecastTable
        where hourForecastTable.ProjId == _projId
            && hourForecastTable.ModelId == _modelId
            && hourForecastTable.ActivityNumber != ''
        notExists join _psaActivityEstimates
        where hourForecastTable.ActivityNumber == _psaActivityEstimates.ActivityNumber
            && _psaActivityEstimates.ProjTransType == QuotationProjTransType::Hour;

        delete_from costForecastTable
        where costForecastTable.ProjId == _projId
            && costForecastTable.ModelId == _modelId
            && costForecastTable.ActivityNumber != ''
        notExists join _psaActivityEstimates
        where costForecastTable.ActivityNumber == _psaActivityEstimates.ActivityNumber
            && _psaActivityEstimates.ProjTransType == QuotationProjTransType::Expense;

        delete_from revForecastTable
        where revForecastTable.ProjId == _projId
            && revForecastTable.ModelId == _modelId
            && revForecastTable.ActivityNumber != ''
        notExists join _psaActivityEstimates
        where revForecastTable.ActivityNumber == _psaActivityEstimates.ActivityNumber
            && _psaActivityEstimates.ProjTransType == QuotationProjTransType::Fee;

        delete_from forecastSales
        where forecastSales.ProjId == _projId
            && forecastSales.ModelId == _modelId
            && forecastSales.ActivityNumber != ''
        notExists join _psaActivityEstimates
        where forecastSales.ActivityNumber == _psaActivityEstimates.ActivityNumber
            && _psaActivityEstimates.ProjTransType == QuotationProjTransType::Item;

        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>