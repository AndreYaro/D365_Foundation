<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustOverPaym</Name>
	<SourceCode>
		<Declaration><![CDATA[
public final class CustOverPaym extends RunBaseBatch implements BatchRetryable
{
    LedgerVoucher ledgerVoucher;
    CustTable custTable;
    VendTable vendTable;
    LedgerTransTxt transTxt;
    TransDate runDate;
    QueryRun queryRun;
    RecId vendTransRecId;
    private SpecTransExecutionContext specTransExecutionContext;

    boolean isReimbursementGenerated;
    CustTrans custTransOriginal;

    str custBillingClassificationIds;
    NoYes inclTransWithNoBillingClassification;
    NoYes separateReimbursementforBillingClassification;
    NoYes includeCustomerWithDebitTransactions;
    boolean summarizeCustomer;
    container custBillingClassificationIdsContainer;

    #define.semicolon(";")
    #define.comma(",")
    #define.zero('0')

    #DEFINE.CurrentVersion(3)

    #LOCALMACRO.CurrentList
        runDate,
        inclTransWithNoBillingClassification,
        separateReimbursementforBillingClassification,
        includeCustomerWithDebitTransactions,
        custBillingClassificationIds,
        summarizeCustomer
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMapEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the dimension and transaction amount in dimension map.
    /// </summary>
    /// <param name="_ledgerDimensionAccount">
    /// The ledger dimensions value to use.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use.
    /// </param>
    /// <param name="_transactionAmount">
    /// The transaction amount to use.
    /// </param>
    /// <param name="_dimensionsMap">
    /// The map in which dimensions and amount are added.
    /// </param>
    /// <param name="_billingClassificationId">
    /// The record ID of <c>CustBillingClassification</c> table to use.
    /// </param>
    protected void addMapEntry(
        LedgerDimensionAccount  _ledgerDimensionAccount,
        CurrencyCode            _currencyCode,
        AmountMST               _transactionAmount,
        Map                     _dimensionsMap,
        RefRecId                _billingClassificationId = 0)
    {
        if (_dimensionsMap.exists([_ledgerDimensionAccount, _currencyCode, _billingClassificationId]))
        {
            _transactionAmount += _dimensionsMap.lookup([_ledgerDimensionAccount, _currencyCode, _billingClassificationId]);
        }

        _dimensionsMap.insert([_ledgerDimensionAccount, _currencyCode, _billingClassificationId], _transactionAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMapTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a Map of transactions that are to be reimbursed and settled
    /// </summary>
    /// <param name = "_custTrans"><c>CustTrans</c> to be added to the map</param>
    /// <param name = "_dimensionAmountMapPerCustomer">The map that _custTrans will be added to</param>
    /// <param name = "_transactionsToMark">List of transactions to mark for settlement</param>
    /// <param name = "_total">The current total amount to reimburse</param>
    /// <param name = "_currencyExchangeHelper"><c>CurrencyExchangeHelper</c></param>
    /// <param name = "_crosscompany">If _custTrans was retrieved from cross company query</param>
    /// <param name = "_useBillingClassification"></param>
    /// <returns>_total + _custTrans remaining amount</returns>
    private AmountMST addMapTrans(CustTrans _custTrans,
        Map _dimensionAmountMapPerCustomer,
        List _transactionsToMark,
        CurrencyExchangeHelper _currencyExchangeHelper,
        boolean _crosscompany,
        boolean _useBillingClassification)
    {
        Map dimensionAmountMapPerTransaction = this.getDimensionsFromCustomerTransaction(_custTrans.Voucher,
            _custTrans.TransDate,
            _custTrans.DataAreaId,
            _custTrans.Invoice,
            _custTrans.remainAmountCur() / _custTrans.AmountCur,
            _custTrans.CurrencyCode,
            _custTrans.remainAmountCur());

        MapEnumerator dimensionAmountMapPerTransactionEnumerator = dimensionAmountMapPerTransaction.getEnumerator();

        LedgerDimensionAccount  currentTransactionLedgerDimensionAccount;

        AmountMST currentTransactionAmount;

        RefRecId billingClassificationRecId;

        while (dimensionAmountMapPerTransactionEnumerator.moveNext())
        {
            currentTransactionLedgerDimensionAccount = dimensionAmountMapPerTransactionEnumerator.currentKey();
            currentTransactionAmount = dimensionAmountMapPerTransactionEnumerator.currentValue();

            if (_crosscompany)
            {
                currentTransactionAmount = _currencyExchangeHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(CompanyInfo::findDataArea(_custTrans.company()).RecId), currentTransactionAmount, true);
            }

            billingClassificationRecId = (_useBillingClassification ? _custTrans.CustBillingClassification : 0);

            this.addMapEntry(currentTransactionLedgerDimensionAccount, _custTrans.CurrencyCode, currentTransactionAmount, _dimensionAmountMapPerCustomer, billingClassificationRecId);
        }

        _transactionsToMark.addEnd(_custTrans);

        return _custTrans.remainAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransactionsForReimbursementSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the customers transactions that are elegable for reimbursement when summarizing.
    /// </summary>
    /// <param name = "_findTransArgs">Contains arguments used to reimburse the customer.</param>
    /// <param name = "_transactionsToMark">The list of transactions to mark for settlement.</param>
    /// <returns>Total amount of transactions found.</returns>
    private AmountMST findTransactionsForReimbursementSummarized(CustOverPaymFindTransactionsForReimburseArgs _findTransArgs, List _transactionsToMark)
    {
        CustTrans custTrans;
        AmountMST total;

        boolean useBillingClassification = _findTransArgs.parmUseBillingClassification();

        QueryRun qr = new QueryRun(this.buildFindTransactionsForReimbursementQuery(_findTransArgs));

        while (qr.next())
        {
            if (qr.changed(tableNum(CustTrans)))
            {
                custTrans = qr.get(tableNum(CustTrans));

                if (custTrans.remainAmountCur() < 0 
                    && ((useBillingClassification && strContains(custBillingClassificationIds, int642str(custTrans.CustBillingClassification)))
                    || !useBillingClassification))
                {
                    total += custTrans.remainAmountMST();
                    _transactionsToMark.addEnd(custTrans);
                }
            }
        }

        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransactionsForReimbursementNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the customers transactions that are elegable for reimbursement when not summarizing.
    /// </summary>
    /// <param name = "_findTransArgs">Contains arguments used to reimburse the customer.</param>
    /// <param name = "_transactionsToMark">The list of transactions to mark for settlement.</param>
    /// <param name = "_dimensionAmountMapPerCustomer">The map of dimension to amount.</param>
    /// <returns>Total amount of transactions found.</returns>
    private AmountMST findTransactionsForReimbursementNonSummarized(CustOverPaymFindTransactionsForReimburseArgs _findTransArgs, List _transactionsToMark, Map _dimensionAmountMapPerCustomer)
    {
        CustTrans custTrans;
        AmountMST total;

        boolean useBillingClassification = _findTransArgs.parmUseBillingClassification();
        CurrencyExchangeHelper currencyExchangeHelper = _findTransArgs.parmCurrencyExchangeHelper();

        QueryRun qr = new QueryRun(this.buildFindTransactionsForReimbursementQuery(_findTransArgs));

        while (qr.next())
        {
            if (qr.changed(tableNum(CustTrans)))
            {
                custTrans = qr.get(tableNum(CustTrans));

                if (custTrans.remainAmountCur() < 0)
                {
                    if (useBillingClassification && strContains(custBillingClassificationIds, int642str(custTrans.CustBillingClassification)))
                    {
                        total += this.addMapTrans(custTrans, _dimensionAmountMapPerCustomer, _transactionsToMark, currencyExchangeHelper, false, separateReimbursementforBillingClassification);
                    }
                    else if (!useBillingClassification)
                    {
                        total += this.addMapTrans(custTrans, _dimensionAmountMapPerCustomer, _transactionsToMark, currencyExchangeHelper, false, false);
                    }
                }
            }
        }

        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFindTransactionsForReimbursementQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query used in methods <c>findTransactionsForReimbursementNonSummarized</c> and <c>findTransactionsForReimbursementSummarized</c>.
    /// </summary>
    /// <param name = "_findTransArgs">Contains arguments used to build the query.</param>
    /// <returns>The generated query.</returns>
    protected Query buildFindTransactionsForReimbursementQuery(CustOverPaymFindTransactionsForReimburseArgs _findTransArgs)
    {
        boolean useBillingClassification = _findTransArgs.parmUseBillingClassification();

        Query q = new Query();

        QueryBuildDataSource qbds = q.addDataSource(tableNum(CustTrans));
        qbds.addRange(fieldNum(CustTrans, AccountNum)).value(queryValue(custTable.AccountNum));
        qbds.addRange(fieldNum(CustTrans, AmountMST)).value('< 0');
        qbds.addRange(fieldNum(CustTrans, SettleAmountCur)).value(strFmt('(%1.%2 != %1.%3)', qbds.name(), fieldStr(CustTrans, SettleAmountCur), fieldStr(CustTrans, AmountCur)));

        if (!useBillingClassification)
        {
            qbds.addRange(fieldNum(CustTrans, CustBillingClassification)).value(SysQuery::value(0));
        }

        qbds.fields().clearFieldList();

        qbds.addSelectionField(fieldNum(CustTrans, Voucher));
        qbds.addSelectionField(fieldNum(CustTrans, TransDate));
        qbds.addSelectionField(fieldNum(CustTrans, AmountMST));
        qbds.addSelectionField(fieldNum(CustTrans, Invoice));
        qbds.addSelectionField(fieldNum(CustTrans, AmountCur));
        qbds.addSelectionField(fieldNum(CustTrans, SettleAmountCur));
        qbds.addSelectionField(fieldNum(CustTrans, CurrencyCode));
        qbds.addSelectionField(fieldNum(CustTrans, SettleAmountMST));
        qbds.addSelectionField(fieldNum(CustTrans, ExchAdjustment));

        if (useBillingClassification)
        {
            qbds.addSelectionField(fieldNum(CustTrans, CustBillingClassification));
        }
        else 
        {
            qbds.addSelectionField(fieldNum(CustTrans, TransType));
        }

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCrossCompanyQueryForCalcTotalNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the cross company query used to calculate not summarized totals.
    /// </summary>
    /// <param name = "_calcArgs">Contains arguments used to construct the query</param>
    /// <returns>The generated query.</returns>
    protected Query buildCrossCompanyQueryForCalcTotalNonSummarized(CustOverPaymCalcTotalArgs _calcArgs)
    {
        Query q = new Query();
        q.allowCrossCompany(true);

        this.addCompanyRangeToQuery(q, _calcArgs.parmCompanies());

        QueryBuildDataSource qbdsCustTrans = q.addDataSource(tableNum(CustTrans));
        qbdsCustTrans.addRange(fieldNum(CustTrans, AmountMST)).value(queryValue('< 0'));
        qbdsCustTrans.addRange(fieldNum(CustTrans, SettleAmountCur)).value(strFmt('(%1.%2 != %1.%3)', qbdsCustTrans.name(), fieldStr(CustTrans, SettleAmountCur), fieldStr(CustTrans, AmountCur)));

        qbdsCustTrans.fields().clearFieldList();

        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, Voucher));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, TransDate));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, AmountMST));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, Invoice));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, AmountCur));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, SettleAmountCur));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, CurrencyCode));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, SettleAmountMST));
        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, ExchAdjustment));

        QueryBuildDataSource qbdsCustTable = qbdsCustTrans.addDataSource(tableNum(CustTable));
        qbdsCustTable.addLink(fieldNum(CustTrans, AccountNum), fieldNum(CustTable, AccountNum));
        qbdsCustTable.addRange(fieldNum(CustTable, Party)).value(queryValue(custTable.Party));
        qbdsCustTable.joinMode(JoinMode::ExistsJoin);

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the unsummarized total for the customer.
    /// </summary>
    /// <param name = "_calcArgs">Contains arguments used to calculate totals</param>
    /// <returns>The total by dimension.</returns>
    protected Map calcTotalNonSummarized(CustOverPaymCalcTotalArgs _calcArgs)
    {
        CustTrans custTrans;
        AmountMST total;

        Map dimensionAmountMapPerCustomer = new Map(Types::Container, Types::Real);

        List transactionsToMark = new List(Types::Record);

        boolean isCrossCompany = _calcArgs.parmIsCrossCompany();

        if (isCrossCompany)
        {
            CurrencyExchangeHelper currencyExchangeHelper = _calcArgs.parmCurrencyExchangeHelper();

            QueryRun qr = new QueryRun(this.buildCrossCompanyQueryForCalcTotalNonSummarized(_calcArgs));

            while (qr.next())
            {
                if (qr.changed(tableNum(CustTrans)))
                {
                    custTrans = qr.get(tableNum(CustTrans));

                    if (custTrans.remainAmountCur() < 0)
                    {
                        total += this.addMapTrans(custTrans, dimensionAmountMapPerCustomer, transactionsToMark, currencyExchangeHelper, isCrossCompany, isConfigurationkeyEnabled(configurationKeyNum(PublicSector)));
                    }
                }
            }
        }
        else
        {
            boolean useBillingClassification = (separateReimbursementforBillingClassification 
                || !(custBillingClassificationIds == ',0' || !CustParameters::isBillingClassificationEnabled()));

            useBillingClassification = useBillingClassification && isConfigurationkeyEnabled(configurationKeyNum(PublicSector));

            CustOverPaymFindTransactionsForReimburseArgs findTransArgs = CustOverPaymFindTransactionsForReimburseArgs::construct();
            findTransArgs.parmCurrencyExchangeHelper(_calcArgs.parmCurrencyExchangeHelper());
            findTransArgs.parmUseBillingClassification(useBillingClassification);

            total += this.findTransactionsForReimbursementNonSummarized(findTransArgs, transactionsToMark, dimensionAmountMapPerCustomer);
        }


        if (-total < CustParameters::find().MinRefund)
        {
            dimensionAmountMapPerCustomer = new Map(Types::Int64, Types::Real);
            warning(strFmt("@SYS133157", custTable.AccountNum, custTable.name()));
        }
        else
        {
            ListEnumerator transactionsToMarkListEnumerator = transactionsToMark.getEnumerator();
            while (transactionsToMarkListEnumerator.moveNext())
            {
                custTrans = transactionsToMarkListEnumerator.current();
                this.markTransaction(custTrans);
            }
        }

        return dimensionAmountMapPerCustomer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCrossCompanyQueryForCalcTotalSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the cross company query used to calculate summarized totals.
    /// </summary>
    /// <param name = "_calcArgs">Contains arguments used to construct the query</param>
    /// <returns>The generated query.</returns>
    protected Query buildCrossCompanyQueryForCalcTotalSummarized(CustOverPaymCalcTotalArgs _calcArgs)
    {
        Query q = new Query();
        q.allowCrossCompany(true);

        this.addCompanyRangeToQuery(q, _calcArgs.parmCompanies());

        QueryBuildDataSource qbdsCustTrans = q.addDataSource(tableNum(CustTrans));
            
        qbdsCustTrans.fields().clearFieldList();

        qbdsCustTrans.addGroupByField(fieldNum(CustTrans, DataAreaId));
        qbdsCustTrans.addGroupByField(fieldNum(CustTrans, AccountNum));

        qbdsCustTrans.addSelectionField(fieldNum(CustTrans, AmountMST), SelectionField::Sum);

        QueryBuildDataSource qbdsCustTable = qbdsCustTrans.addDataSource(tableNum(CustTable));
        qbdsCustTable.addLink(fieldNum(CustTrans, AccountNum), fieldNum(CustTable, AccountNum));
        qbdsCustTable.addRange(fieldNum(CustTable, Party)).value(queryValue(custTable.Party));
        qbdsCustTable.joinMode(JoinMode::ExistsJoin);

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCompanyRangeToQuery</Name>
				<Source><![CDATA[
    private void addCompanyRangeToQuery(Query _q, container _companies)
    {
        for (int i = 1; i <= conLen(_companies); i++)
        {
            _q.addCompanyRange(conPeek(_companies, i));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the smmarized total for the customer.
    /// </summary>
    /// <param name = "_calcArgs">Contains arguments used to calculate totals</param>
    /// <returns>The total amount.</returns>
    protected AmountMST calcTotalSummarized(CustOverPaymCalcTotalArgs _calcArgs)
    {
        CustTrans custTrans;
        AmountMST total;

        List transactionsToMark = new List(Types::Record);

        if (_calcArgs.parmIsCrossCompany())
        {
            CurrencyExchangeHelper currencyExchangeHelper = _calcArgs.parmCurrencyExchangeHelper();

            QueryRun qr = new QueryRun(this.buildCrossCompanyQueryForCalcTotalSummarized(_calcArgs));

            while (qr.next())
            {
                if (qr.changed(tableNum(CustTrans)))
                {
                    custTrans = qr.get(tableNum(CustTrans));

                    total += currencyExchangeHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(CompanyInfo::findDataArea(custTrans.company()).RecId),custTrans.AmountMST, true);
                }
            }
        }
        else
        {
            boolean isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();
            boolean useBillingClassification = separateReimbursementforBillingClassification || !(custBillingClassificationIds == ',0' || !isBillingClassificationEnabled);
            useBillingClassification = useBillingClassification || isBillingClassificationEnabled;
            useBillingClassification = useBillingClassification && isConfigurationkeyEnabled(configurationKeyNum(PublicSector));

            CustOverPaymFindTransactionsForReimburseArgs findTransArgs = CustOverPaymFindTransactionsForReimburseArgs::construct();
            findTransArgs.parmCurrencyExchangeHelper(_calcArgs.parmCurrencyExchangeHelper());
            findTransArgs.parmUseBillingClassification(useBillingClassification);

            total += this.findTransactionsForReimbursementSummarized(findTransArgs, transactionsToMark);
        }

        if (total)
        {
            ListEnumerator transactionsToMarkListEnumerator = transactionsToMark.getEnumerator();
            while (transactionsToMarkListEnumerator.moveNext())
            {
                custTrans = transactionsToMarkListEnumerator.current();
                this.markTransaction(custTrans);
            }
        }

        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total for a customer.
    /// </summary>
    /// <param name = "_currencyExchangeHelper">The <c>CurrencyExchangeHelper</c> instance.</param>
    /// <param name = "_crosscompany">Flag for running cross company.</param>
    /// <param name = "_companies">The companies to calculate tottals by.</param>
    /// <param name = "billingClassificationIds">The billing classificationids.</param>
    /// <returns>The total by dimension or by sumarized totatl.</returns>
    [SysObsolete('Use the method calcTotalSummarized when summarizeCustomer is true. Use the method calcTotalNonSummarized when summarizeCustomer is false', true, 20\9\2022)]
    protected anytype calcTotal(CurrencyExchangeHelper _currencyExchangeHelper, boolean _crosscompany = false, container _companies = conNull(), str billingClassificationIds = '')
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class two times with the
    ///    same parameters is not always possible. If the <see cref="M:RunBaseBatch.canGoBatch" /> method is
    ///    false, this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllTransactionsUnmarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether there are no tranctions marked for settlement so reimbursement for those transactions can be processed.
    /// </summary>
    /// <returns>
    /// true if the transactions can be processed; otherwise, false.
    /// </returns>
    protected boolean checkAllTransactionsUnmarked()
    {
        boolean hasSpecTrans;
        boolean canBeProcessed = true;
        CustTransOpen custTransOpen;

        while select RecId from custTransOpen
            where custTransOpen.AccountNum == custTable.AccountNum
        {
            hasSpecTrans = SpecTrans::existByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId);

            if (hasSpecTrans)
            {
                canBeProcessed = checkFailed("@SPS2456");
                break;
            }
        }

        return canBeProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustVoucherSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes <c>CustVendVoucher</c> class used to post the <c>CustTrans</c> table record when summarizing.
    /// </summary>
    /// <param name = "_createTransArgs">Contains arguments used to initialize the <c>CustVendVoucher</c> instance.</param>
    /// <returns>An instance of <c>CustVenVoucher</c></returns>
    protected CustVendVoucher initializeCustVoucherSummarized(CustOverPaymCreateCustTransArgs _createTransArgs)
    {
        CustVendVoucher custVendVoucher = CustVendVoucher::construct(SysModule::Cust,
            custTable.AccountNum,
            _createTransArgs.parmTransAmount(),
            _createTransArgs.parmCurrencyCode(),
            transTxt,
            custTable.DefaultDimension,
            '',
            LedgerPostingType::CustBalance);

        if (!CustPaymModeTable::find(custTable.PaymMode).IsSEPA)
        {
            custVendVoucher.parmPaymMode(custTable.PaymMode);
        }

        custVendVoucher.parmPaymSpec(custTable.PaymSpec);
        custVendVoucher.parmExchRate(100);

        this.initializeCustVoucherFields(custVendVoucher as CustVoucher);
        
        return custVendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustVoucherNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes <c>CustVendVoucher</c> class used to post the <c>CustTrans</c> table record when not summarizing.
    /// </summary>
    /// <param name = "_createTransArgs">Contains arguments used to initialize the <c>CustVendVoucher</c> instance.</param>
    /// <returns>An instance of <c>CustVenVoucher</c></returns>
    protected CustVendVoucher initializeCustVoucherNonSummarized(CustOverPaymCreateCustTransArgs _createTransArgs)
    {
        LedgerDimensionAccount ledgerDimensionaccount = _createTransArgs.parmLedgerDimensionAccount();
        CurrencyCode currencyCode = _createTransArgs.parmCurrencyCode();

        CustVendVoucher custVendVoucher = CustVendVoucher::construct(SysModule::Cust,
            custTable.AccountNum,
            _createTransArgs.parmTransAmount(),
            currencyCode,
            transTxt,
            LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerDimensionaccount),
            '',
            LedgerPostingType::CustBalance);

        //Mandates do not apply to reimbursements.
        if (!CustPaymModeTable::find(custTable.PaymMode).IsSEPA)
        {
            custVendVoucher.parmPaymMode(custTable.PaymMode);
        }

        custVendVoucher.parmPaymSpec(custTable.PaymSpec);
        
        CustVoucher custVoucher = custVendVoucher as CustVoucher;

        this.initializeCustVoucherFields(custVoucher);

        custVoucher.parmSummaryledgerDimensionAccount(ledgerDimensionaccount);

        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrencyToCurrency(currencyCode, Ledger::accountingCurrency());
        exchangeRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

        custVoucher.parmExchRate(exchangeRateHelper.getExchangeRate1());

        return custVendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustVoucherFields</Name>
				<Source><![CDATA[
    private void initializeCustVoucherFields(CustVoucher _custVoucher)
    {
        _custVoucher.parmTransRefId(ledgerVoucher.findLedgerVoucherObject().parmReferenceNumber());
        _custVoucher.parmTransRefType(CustTransRefType::Other);
        _custVoucher.parmIsReimbursement(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTrans</Name>
				<Source><![CDATA[
    private void createCustTrans(CustOverPaymCreateCustTransArgs _createTransArgs)
    {
        CustVendVoucher custVendVoucher = (summarizeCustomer ?
            this.initializeCustVoucherSummarized(_createTransArgs) :
            this.initializeCustVoucherNonSummarized(_createTransArgs));

        CustTrans custTrans;

        custVendVoucher.post(ledgerVoucher, custTrans);

        this.postCreateCustTrans(custTrans, _createTransArgs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCreateCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs post processing on the created <c>CustTrans</c> table record.
    /// </summary>
    /// <param name = "_custTrans">The <c>CustTrans</c> table record created from posting.</param>
    /// <param name = "_createTransArgs">Contains args used to post the voucher.</param>
    protected void postCreateCustTrans(CustTrans _custTrans, CustOverPaymCreateCustTransArgs _createTransArgs)
    {
        if (_custTrans.RecId != 0)
        {
            isReimbursementGenerated = true;
            this.markTransaction(_custTrans);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && _createTransArgs.parmBillingClassification())
        {
            ttsbegin;

            _custTrans.selectForUpdate(true);
            _custTrans.CustBillingClassification = _createTransArgs.parmBillingClassification();
            _custTrans.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOneTimeVendor</Name>
				<Source><![CDATA[
    private VendTable createOneTimeVendor(CustOverPaymUpdateVendTableForReimbursementArgs _args)
    {  
        NumberSeq numberSeq = NumberSeq::newGetNum(VendParameters::numRefOneTimeSupplierAccount());
        ttsbegin;

        VendTable vendTableLocal = VendTable::find(VendParameters::find().DefaultVend);

        if (vendTableLocal.RecId == 0)
        {
            throw error ("@SYS26764");
        }

        VendAccount newAccountNum = numberSeq.num();

        if (!newAccountNum)
        {
            throw error(strFmt("@SYS28626", "@SYS22531"));
        }

        if (!VendTable::find(newAccountNum))
        {
            vendTableLocal.AccountNum = newAccountNum;
            vendTableLocal.Party = custTable.Party;
            vendTableLocal.Currency = custTable.Currency;
            vendTableLocal.OneTimeVendor = NoYes::Yes;

            vendTableLocal.PaymTermId = custTable.PaymTermId;
            vendTableLocal.PaymSched = custTable.PaymSched;
            vendTableLocal.PaymDayId = custTable.PaymDayId;
            vendTableLocal.CashDisc = custTable.CashDisc;

            vendTableLocal.BankAccount = custTable.BankAccount;
            vendTableLocal.BankCentralBankPurposeCode = custTable.BankCentralBankPurposeCode;
            vendTableLocal.BankCentralBankPurposeText = custTable.BankCentralBankPurposeText;

            vendTableLocal.insert();

            vendTableLocal = VendTable::find(newAccountNum);

            if (!vendTableLocal.AccountNum)
            {
                throw error("@SYS26764");
            }

            _args.parmVendAccount(newAccountNum);

            this.createOneTimeVendBankAccount(_args);
        }
        else
        {
            NumberSeq numberSeq1 = NumberSeq::newGetNum(VendParameters::numRefVendAccount());
            throw error(strFmt("@SYS67731", numberSeq.parmNumberSequenceCode(), numberSeq1.parmNumberSequenceCode()));
        }
        ttscommit;

        return vendTableLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOneTimeVendBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a one time bank account for the one time vendor.
    /// </summary>
    /// <param name = "_args">The args used to create the one time vendor bank account.</param>
    private void createOneTimeVendBankAccount(CustOverPaymUpdateVendTableForReimbursementArgs _args)
    {
        CustBankAccount custBankAccount = CustBankAccount::find(custTable.AccountNum, _args.parmBankAccount());

        if (custBankAccount.RecId != 0)
        {
            VendBankAccount vendBankAccount;

            vendBankAccount.VendAccount         = _args.parmVendAccount();
            vendBankAccount.AccountID           = custBankAccount.AccountID;
            vendBankAccount.Name                = custBankAccount.Name;
            vendBankAccount.BankGroupID         = custBankAccount.BankGroupId;
            vendBankAccount.RegistrationNum     = custBankAccount.RegistrationNum;
            vendBankAccount.BankCIN             = custBankAccount.BankCIN;
            vendBankAccount.BankContractAccount = custBankAccount.BankContractAccount;
            vendBankAccount.CurrencyCode        = custBankAccount.CurrencyCode;
            vendBankAccount.BankCodeType        = custBankAccount.BankCodeType;
            vendBankAccount.swiftNo             = custBankAccount.swiftNo;
            vendBankAccount.BankAccountType     = custBankAccount.BankAccountType;
            vendBankAccount.VendPaymentTextCode = custBankAccount.CustPaymentTextCode;
            vendBankAccount.MsgToBank           = custBankAccount.MsgToBank;
            vendBankAccount.ExchRateRef         = custBankAccount.ExchRateRef;
            vendBankAccount.ContactPerson       = custBankAccount.ContactPerson;
            vendBankAccount.Phone               = custBankAccount.Phone;
            vendBankAccount.PhoneLocal          = custBankAccount.PhoneLocal;
            vendBankAccount.Pager               = custBankAccount.Pager;
            vendBankAccount.CellularPhone       = custBankAccount.CellularPhone;
            vendBankAccount.TeleFax             = custBankAccount.TeleFax;
            vendBankAccount.Email               = custBankAccount.Email;
            vendBankAccount.sms                 = custBankAccount.sms;
            vendBankAccount.url                 = custBankAccount.url;
            vendBankAccount.Telex               = custBankAccount.Telex;
            vendBankAccount.Location            = custBankAccount.Location;

            unchecked (Uncheck::TableSecurityPermission)
            {
                vendBankAccount.AccountNum      = custBankAccount.AccountNum;
                vendBankAccount.BankIBAN        = custBankAccount.BankIBAN;
            }

            vendBankAccount.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeVendVoucherSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes <c>CustVendVoucher</c> class used to post the <c>VendTrans</c> table record when summarizing.
    /// </summary>
    /// <param name = "_createTransArgs">Contains arguments used to initialize the <c>CustVendVoucher</c> instance.</param>
    /// <returns>An instance of <c>CustVenVoucher</c></returns>
    protected CustVendVoucher initializeVendVoucherSummarized(CustOverPaymCreateVendTransArgs _createTransArgs)
    {
        CustVendVoucher vendVoucher = CustVendVoucher::construct(SysModule::Vend,
            vendTable.AccountNum,
            _createTransArgs.parmTransAmount(),
            _createTransArgs.parmCurrencyCode(),
            transTxt,
            vendTable.DefaultDimension,
            '',
            LedgerPostingType::CustReimbursement);

        this.initVendVoucherFromVendTable(vendVoucher);

        vendVoucher.parmExchRate(100);
        
        return vendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeVendVoucherNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes <c>CustVendVoucher</c> class used to post the <c>VendTrans</c> table record when not summarizing.
    /// </summary>
    /// <param name = "_createTransArgs">Contains arguments used to initialize the <c>CustVendVoucher</c> instance.</param>
    /// <returns>An instance of <c>CustVenVoucher</c></returns>
    protected CustVendVoucher initializeVendVoucherNonSummarized(CustOverPaymCreateVendTransArgs _createTransArgs)
    {
        CurrencyCode currencyCode = _createTransArgs.parmCurrencyCode();

        CustVendVoucher vendVoucher = CustVendVoucher::construct(SysModule::Vend,
            vendTable.AccountNum,
            _createTransArgs.parmTransAmount(),
            currencyCode,
            transTxt,
            _createTransArgs.parmDimensionDefault(),
            '',
            LedgerPostingType::CustReimbursement);

        this.initVendVoucherFromVendTable(vendVoucher);

        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrencyToCurrency(currencyCode, Ledger::accountingCurrency());
        exchangeRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

        vendVoucher.parmExchRate(exchangeRateHelper.getExchangeRate1());

        return vendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendVoucherFromVendTable</Name>
				<Source><![CDATA[
    private void initVendVoucherFromVendTable(CustVendVoucher _vendVoucher)
    {
        _vendVoucher.parmPaymMode(vendTable.PaymMode);
        _vendVoucher.parmPaymSpec(vendTable.PaymSpec);
        _vendVoucher.parmIsReimbursement(true);
        _vendVoucher.parmThirdPartyBankAccountId(vendTable.BankAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVendTrans</Name>
				<Source><![CDATA[
    private void createVendTrans(CustOverPaymCreateVendTransArgs _createVendTransArgs)
    {
        CustVendVoucher vendVoucher = (summarizeCustomer ?
            this.initializeVendVoucherSummarized(_createVendTransArgs) :
            this.initializeVendVoucherNonSummarized(_createVendTransArgs));

        VendTrans vendTrans;

        vendVoucher.post(ledgerVoucher, vendTrans);

        this.setVendTransRemitToAddress(vendTrans);

        vendTransRecId = vendTrans.RecId;

        if (isReimbursementGenerated && !vendTransRecId)
        {
            isReimbursementGenerated = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the dialog form that is called by the class.
    /// </summary>
    /// <returns>
    /// The dialog form object that is constructed by this method.
    /// </returns>
    public Object dialog()
    {
        DialogRunbase dialog = Dialog::newFormnameRunbase(formStr(CustOverPaym),this);

        dialog.caption("@SYS24632");
        dialog = this.dialogInternal(dialog);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionsFromCustomerTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the dimension from a Customer Transaction.
    /// </summary>
    /// <param name="_custTransVoucher">
    /// A voucher from the <c>CustTrans</c> table.
    /// </param>
    /// <param name="_transDate">
    /// A transaction date of Customer.
    /// </param>
    /// <param name="_dataAreaId">
    /// The company of the transaction.
    /// </param>
    /// <param name="_custInvoiceId">
    /// The invoice ID of the transaction.
    /// </param>
    /// <param name="_remainingAmountPercent">
    /// A percentage of the remaining amount.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code of the transaction.
    /// </param>
    /// <param name="_remainingTransactionAmount">
    /// The remaining amount of the transaction.
    /// </param>
    /// <returns>
    /// A Map that contains the dimensions from a customer transaction.
    /// </returns>
    protected Map getDimensionsFromCustomerTransaction(
        Voucher         _custTransVoucher,
        TransDate       _transDate,
        DataAreaId      _dataAreaId,
        CustInvoiceId   _custInvoiceId,
        Percent         _remainingAmountPercent,
        CurrencyCode    _currencyCode,
        AmountCur       _remainingTransactionAmount)
    {
        SubledgerVoucherGeneralJournalEntry localSubledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry          localGeneralJournalAccountEntry;
        Map                                 dimensionPerTransactionMap;
        boolean                             entriesFound;
        Counter                             counter;
        RefRecId                            totalTransCount;
        AmountCur                           totalCustomerBalanceAmount, currentCustomerBalanceAmount;

        dimensionPerTransactionMap = new Map(Types::Container, Types::Real);

        select crossCompany count(RecId)
            from  localGeneralJournalAccountEntry
            where localGeneralJournalAccountEntry.PostingType == LedgerPostingType::CustBalance
                exists join  localSubledgerVoucherGeneralJournalEntry
                where localSubledgerVoucherGeneralJournalEntry.GeneralJournalEntry  == localGeneralJournalAccountEntry.GeneralJournalEntry  &&
                      localSubledgerVoucherGeneralJournalEntry.Voucher              == _custTransVoucher                                    &&
                      localSubledgerVoucherGeneralJournalEntry.VoucherDataAreaId    == _dataAreaId                                          &&
                      localSubledgerVoucherGeneralJournalEntry.AccountingDate       == _transDate;

        totalTransCount = localGeneralJournalAccountEntry.RecId;

        while select crossCompany LedgerDimension, TransactionCurrencyAmount
            from  localGeneralJournalAccountEntry
            where localGeneralJournalAccountEntry.PostingType == LedgerPostingType::CustBalance
                exists join  localSubledgerVoucherGeneralJournalEntry
                where localSubledgerVoucherGeneralJournalEntry.GeneralJournalEntry  == localGeneralJournalAccountEntry.GeneralJournalEntry  &&
                      localSubledgerVoucherGeneralJournalEntry.Voucher              == _custTransVoucher                                    &&
                      localSubledgerVoucherGeneralJournalEntry.VoucherDataAreaId    == _dataAreaId                                          &&
                      localSubledgerVoucherGeneralJournalEntry.AccountingDate       == _transDate
        {
            counter++;
            currentCustomerBalanceAmount = CurrencyExchange::round(localGeneralJournalAccountEntry.TransactionCurrencyAmount * _remainingAmountPercent, _currencyCode);
            totalCustomerBalanceAmount += currentCustomerBalanceAmount;

            if (counter == totalTransCount && totalCustomerBalanceAmount != _remainingTransactionAmount)
            {
                currentCustomerBalanceAmount += _remainingTransactionAmount - totalCustomerBalanceAmount;
            }

            this.addMapEntry(localGeneralJournalAccountEntry.LedgerDimension, _currencyCode, currentCustomerBalanceAmount, dimensionPerTransactionMap);
            entriesFound = true;
        }

        if (!entriesFound)
        {
            error(strFmt("@SPS2410", _custInvoiceId));
        }

        return dimensionPerTransactionMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the parameter values from the dialog form.
    /// </summary>
    /// <returns>
    /// true if the super method call returns true; otherwise, false.
    /// </returns>
    public boolean getFromDialog()
    {
        #Characters

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            this.queryBuild();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSeparateReimbursementforBillingClassification</Name>
				<Source><![CDATA[
    public NoYes parmSeparateReimbursementforBillingClassification(NoYes _separateReimbursementforBillingClassification = separateReimbursementforBillingClassification)
    {
        separateReimbursementforBillingClassification = _separateReimbursementforBillingClassification;

        return separateReimbursementforBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInclTransWithNoBillingClassification</Name>
				<Source><![CDATA[
    public NoYes parmInclTransWithNoBillingClassification(NoYes _inclTransWithNoBillingClassification = inclTransWithNoBillingClassification)
    {
        inclTransWithNoBillingClassification = _inclTransWithNoBillingClassification;

        return inclTransWithNoBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeCustomerWithDebitTransactions</Name>
				<Source><![CDATA[
    public NoYes parmIncludeCustomerWithDebitTransactions(NoYes _includeCustomerWithDebitTransactions = includeCustomerWithDebitTransactions)
    {
        includeCustomerWithDebitTransactions = _includeCustomerWithDebitTransactions;

        return includeCustomerWithDebitTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSummarizeCustomer</Name>
				<Source><![CDATA[
    public boolean parmSummarizeCustomer(boolean _summarizeCustomer = summarizeCustomer)
    {
        summarizeCustomer = _summarizeCustomer;

        return summarizeCustomer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustBillingClassificationIdsContainer</Name>
				<Source><![CDATA[
    public container parmCustBillingClassificationIdsContainer(container _custBillingClassificationIdsContainer = custBillingClassificationIdsContainer)
    {
        custBillingClassificationIdsContainer = _custBillingClassificationIdsContainer;

        return custBillingClassificationIdsContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> table record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        queryRun = new QueryRun(queryStr(CustOverPayment));
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherInit</Name>
				<Source><![CDATA[
    private void ledgerVoucherInit(NumberSeq _numberSequence, Voucher _voucher = _numberSequence.voucher())
    {
        if (ledgerVoucher == null)
        {
            ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                         SysModule::Cust,
                                                         _numberSequence.parmVoucherSequenceCode());
        }

        ledgerVoucher.addVoucher(
            LedgerVoucherObject::newVoucher(
                 _voucher,
                 DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                 SysModule::Cust,
                 LedgerTransType::Cust));
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the specified transaction for settlement.
    /// </summary>
    /// <param name="_custTrans">
    ///    The customer transaction.
    /// </param>
    protected void markTransaction(CustTrans _custTrans)
    {
        SpecTransManager specTransManager;
        CustTransOpen custTransOpen;
      
        Debug::assert(specTransExecutionContext != null);
        specTransManager = SpecTransManager::newFromSpec(specTransExecutionContext.parmSpecContext());
        custTransOpen = CustTransOpen::findRefId(_custTrans.RecId);

        if (!specTransManager.exist(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId))
        {
            specTransManager.insert(
                custTransOpen.company(),
                tableNum(CustTransOpen),
                custTransOpen.RecId,
                custTransOpen.AmountCur,
                _custTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequence</Name>
				<Source><![CDATA[
    private NumberSequenceReference numberSequence()
    {
        return CustParameters::numRefCustOverPaymId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> to use for the <c>CustTrans</c> table.
    /// </summary>
    public void queryBuild()
    {
        Query                           query;
        QueryBuildDataSource            qbds;
        QueryBuildDataSource            custBillingClassificationDatasource;
        QueryBuildRange                 custBillingClassificationDataSourceRange;
        QueryBuildRange                 custTransAmountRange;

        custBillingClassificationIds = con2StrUnlimited(custBillingClassificationIdsContainer,#comma);

        query = queryRun.query();

        qbds = query.dataSourceTable(tableNum(CustTable));

        query.clearGroupBy();

        /**************************************************************************************/
        // Filter the customer payment proposal data according to the Billing Classification field

        custBillingClassificationDatasource = SysQuery::findOrCreateDataSource(query, tableNum(CustTrans), tableNum(CustTable));
        custBillingClassificationDatasource.joinMode(JoinMode::ExistsJoin);
        custBillingClassificationDatasource.relations(true);

        custTransAmountRange = SysQuery::findOrCreateRange(custBillingClassificationDatasource,fieldNum(CustTrans, AmountMST));
        custTransAmountRange.status(RangeStatus::Hidden);
        custTransAmountRange.value(strFmt('(%1.%2 < 0) && (%1.%2 != %1.%3)', custBillingClassificationDatasource.name(), fieldStr(CustTrans, AmountMST), fieldStr(CustTrans, SettleAmountMST)));

        if (CustParameters::isBillingClassificationEnabled())
        {
            if (custBillingClassificationDataSourceRange != null)
            {
                custBillingClassificationDatasource.clearRange(fieldNum(CustTrans, CustBillingClassification));
            }
            else
            {
                custBillingClassificationDataSourceRange = SysQuery::findOrCreateRange(custBillingClassificationDatasource,fieldNum(CustTrans, CustBillingClassification));
                custBillingClassificationDataSourceRange.status(RangeStatus::Hidden);
            }

            if (custBillingClassificationIds)
            {
                custBillingClassificationIds = Global::strReplace(custBillingClassificationIds, #semicolon, #comma);

                if (inclTransWithNoBillingClassification == NoYes::Yes)
                {
                    custBillingClassificationIds = custBillingClassificationIds + #comma + #zero;
                }
                custBillingClassificationDataSourceRange.value(custBillingClassificationIds);
            }
            else
            {
                if (inclTransWithNoBillingClassification == NoYes::No)
                {
                    custBillingClassificationDataSourceRange.value(SysQuery::valueNot(queryValue(0)));
                }
                else
                {
                    custBillingClassificationIds = custBillingClassificationIds + #comma + #zero;
                    custBillingClassificationDataSourceRange.value(custBillingClassificationIds);
                }
            }
        }
        /**************************************************************************************/
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendTableForReimbursement</Name>
				<Source><![CDATA[
    private void updateVendTableForReimbursement(CustOverPaymUpdateVendTableForReimbursementArgs _args)
    {
        if (_args.parmVendAccount() == '')
        {
            vendTable = (DirPartyTableHelper::isvendor(custTable.Party) ?
                VendTable::findByPartyRecId(custTable.Party) :
                this.createOneTimeVendor(_args));
        }
        else
        {
            vendTable = VendTable::find(_args.parmVendAccount());
        }

        if (!vendTable)
        {
            throw error(strFmt("@SYS84404", custTable.AccountNum));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdateVendTableForReimbursementArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instanse of <c>CustOverPaymUpdateVendTableForReimbursementArgs</c>.
    /// </summary>
    /// <param name = "_reimburseArgs">The <c>CustOverPaymReimburseArgs</c> instance used for population.</param>
    /// <returns>An instance of <c>CustOverPaymUpdateVendTableForReimbursementArgs</c>.</returns>
    protected CustOverPaymUpdateVendTableForReimbursementArgs createUpdateVendTableForReimbursementArgs(CustOverPaymReimburseArgs _reimburseArgs)
    {
        CustOverPaymUpdateVendTableForReimbursementArgs updateVendTableArgs = CustOverPaymUpdateVendTableForReimbursementArgs::construct();
        updateVendTableArgs.parmVendAccount(custTable.VendAccount);
        updateVendTableArgs.parmBankAccount(custTable.BankAccount);

        return updateVendTableArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reimburseSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reimburses customer based by summarized amount.
    /// </summary>
    /// <param name = "_reimburseArgs">The argument object.</param>
    protected void reimburseSummarized(CustOverPaymReimburseArgs _reimburseArgs)
    {
        this.createReimbursement(_reimburseArgs, this.createCustTransArgs(_reimburseArgs), this.createVendTransArgs(_reimburseArgs));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reimburseNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reimburses customer by the unsummarized amounts.
    /// </summary>
    /// <param name = "_reimburseArgs">The argument object.</param>
    protected void reimburseNonSummarized(CustOverPaymReimburseArgs _reimburseArgs)
    {
        CustOverPaymCreateVendTransArgs createVendTransArgs = this.createVendTransArgs(_reimburseArgs);
        createVendTransArgs.parmDimensionDefault(LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_reimburseArgs.parmLedgerDimensionAccount()));

        this.createReimbursement(_reimburseArgs, this.createCustTransArgs(_reimburseArgs), createVendTransArgs);;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVendTransArgs</Name>
				<Source><![CDATA[
    private CustOverPaymCreateVendTransArgs createVendTransArgs(CustOverPaymReimburseArgs _reimburseArgs)
    {
        CustOverPaymCreateVendTransArgs createVendTransArgs = CustOverPaymCreateVendTransArgs::construct();
        createVendTransArgs.parmTransAmount(_reimburseArgs.parmAmountMST());
        createVendTransArgs.parmCurrencyCode(_reimburseArgs.parmCurrencyCode());

        return createVendTransArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTransArgs</Name>
				<Source><![CDATA[
    private CustOverPaymCreateCustTransArgs createCustTransArgs(CustOverPaymReimburseArgs _reimburseArgs)
    {
        CustOverPaymCreateCustTransArgs createCustTransArgs = CustOverPaymCreateCustTransArgs::construct();
        createCustTransArgs.parmTransAmount(-_reimburseArgs.parmAmountMST());
        createCustTransArgs.parmBillingClassification(_reimburseArgs.parmBillingClassification());
        createCustTransArgs.parmLedgerDimensionAccount(_reimburseArgs.parmLedgerDimensionAccount());
        createCustTransArgs.parmCurrencyCode(_reimburseArgs.parmCurrencyCode());

        return createCustTransArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCalcTotalArgs</Name>
				<Source><![CDATA[
    private CustOverPaymCalcTotalArgs createCalcTotalArgs(CustOverPaymRunArgs _runArgs)
    {
        CustOverPaymCalcTotalArgs calcArgs = CustOverPaymCalcTotalArgs::construct();
        calcArgs.parmCompanies(_runArgs.parmCompanies());
        calcArgs.parmCurrencyExchangeHelper(_runArgs.parmCurrencyExchangeHelper());
        calcArgs.parmIsCrossCompany(_runArgs.parmIsCrossCompany());

        return calcArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReimburseArgs</Name>
				<Source><![CDATA[
    private CustOverPaymReimburseArgs createReimburseArgs(AmountMST _amountMST,
        NumberSeq _numberSequence = null,
        RefRecId _billingClassification =  0,
        LedgerDimensionAccount _ledgerDimensionAccount = 0,
        CurrencyCode _currencyCode = Ledger::accountingCurrency())
    {
        CustOverPaymReimburseArgs reimburseArgs = CustOverPaymReimburseArgs::construct();

        reimburseArgs.parmAmountMST(_amountMST);
        reimburseArgs.parmNumberSequence(_numberSequence);
        reimburseArgs.parmBillingClassification(_billingClassification);
        reimburseArgs.parmLedgerDimensionAccount(_ledgerDimensionAccount);
        reimburseArgs.parmCurrencyCode(_currencyCode);

        return reimburseArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReimbursement</Name>
				<Source><![CDATA[
    private void createReimbursement(CustOverPaymReimburseArgs _reimburseArgs, CustOverPaymCreateCustTransArgs _createCustTransArgs, CustOverPaymCreateVendTransArgs _createVendTransArgs)
    {
        this.updateVendTableForReimbursement(this.createUpdateVendTableForReimbursementArgs(_reimburseArgs));

        this.createCustTrans(_createCustTransArgs);

        this.createVendTrans(_createVendTransArgs);

        _reimburseArgs.parmNumberSequence().used();
        this.updateCustomer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reimburse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reimburses the customer for the given amount.
    /// </summary>
    /// <param name = "_amountMST">The amount to reimburse the customer.</param>
    /// <param name = "_numberSequence">The number sequence used to create the transactions.</param>
    /// <param name = "_billingClassification">The billing classification record.</param>
    /// <param name = "_ledgerDimensionAccount">The account to reimburse.</param>
    /// <param name = "_currencyCode">The currency of the transaction.</param>
    [SysObsolete('Use the method reimburseSummarized when summarizeCustomer is true. Use the method reimburseNonSummarized when summarizeCustomer is false', true, 20\9\2022)]
    protected void reimburse(
        AmountMST _amountMST,
        NumberSeq _numberSequence = null,
        RefRecId _billingClassification =  0,
        LedgerDimensionAccount _ledgerDimensionAccount = 0,
        CurrencyCode _currencyCode = Ledger::accountingCurrency())
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustTableChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the <c>CustTable</c> table record in the <c>QueryRun</c> object it changed.
    /// </summary>
    /// <returns>true if the current <c>CustTable</c> table record is valid; otherwise, false.</returns>
    protected boolean validateCustTableChange()
    {
        boolean isValid = true;

        if (queryRun.changed(tableNum(CustTable)))
        {
            isValid = includeCustomerWithDebitTransactions || this.validateForDebitTransactions(custTable.AccountNum);
            isValid = isValid && this.checkAllTransactionsUnmarked();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles <c>CustTrans</c> table records for customer.
    /// </summary>
    protected void settleCustTrans()
    {
        if (ledgerVoucher)
        {
            ledgerVoucher.end();
        }

        Debug::assert(specTransExecutionContext != null);
        CustTrans::settleTransaction(specTransExecutionContext, CustTransSettleTransactionParameters::construct());
    }

]]></Source>
			</Method>
			<Method>
				<Name>runSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the summarized reimbursement for a customer.
    /// </summary>
    /// <param name = "_runArgs">The args object.</param>
    protected void runSummarized(CustOverPaymRunArgs _runArgs)
    {        
        setPrefix(strFmt("@SYS70279", custTable.AccountNum));

        boolean isValid = this.validateCustTableChange();

        if (!isValid)
        {
            warning("@AccountsReceivable:CustOverPaymCustHasNoValidTransactions");
        }

        if (isValid)
        {
            specTransExecutionContext = SpecTransExecutionContext::newFromSource(custTable);

            CustOverPaymCalcTotalArgs calcArgs = this.createCalcTotalArgs(_runArgs);
            AmountMST amountMST = this.calcTotalSummarized(calcArgs);

            if (-amountMST >= _runArgs.parmMinimumAmount())
            {
                NumberSeq numberSequence = _runArgs.parmNumberSequence();

                Voucher voucher = numberSequence.voucher();
                this.ledgerVoucherInit(numberSequence, voucher);

                if (!voucher)
                {
                    throw error(strFmt("@SYS28626", numberSequence));
                }

                
                CustOverPaymReimburseArgs reimburseArgs = this.createReimburseArgs(
                    amountMST,
                    numberSequence);
                this.reimburseSummarized(reimburseArgs);

                this.settleCustTrans();

                info(strFmt("@SPS2409", voucher));
            }
            else if (_runArgs.parmShouldThrowException())
            {
                throw error(strFmt("@SYS133157", custTable.AccountNum, custTable.name()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runNonSummarized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the non-summarized reimbursement for a customer.
    /// </summary>
    /// <param name = "_runArgs">The args object.</param>
    protected void runNonSummarized(CustOverPaymRunArgs _runArgs)
    {
        Map dimensionMap;
        ledgerVoucher = null;

        setPrefix(strFmt("@SYS70279", custTable.AccountNum));

        boolean isValid = this.validateCustTableChange();
        
        if (isValid)
        {
            specTransExecutionContext = SpecTransExecutionContext::newFromSource(custTable);

            CustOverPaymCalcTotalArgs calcArgs = this.createCalcTotalArgs(_runArgs);
            dimensionMap = this.calcTotalNonSummarized(calcArgs);

            AmountMST amountMST;
            LedgerDimensionAccount currentTransactionLedgerDimensionAccount;
            CurrencyCode currencyCode;
            RefRecId billingClassificationId;
            Voucher voucher;

            NumberSeq numberSequence = _runArgs.parmNumberSequence();
            MapEnumerator dimensionMapEnumerator = dimensionMap.getEnumerator();

            while (dimensionMapEnumerator.moveNext())
            {
                voucher = numberSequence.voucher();

                this.ledgerVoucherInit(numberSequence, voucher);

                if (!voucher)
                {
                    throw error(strFmt("@SYS28626", numberSequence));
                }

                [currentTransactionLedgerDimensionAccount, currencyCode, billingClassificationId] = dimensionMapEnumerator.currentKey();

                amountMST = dimensionMapEnumerator.currentValue();

                CustOverPaymReimburseArgs reimburseArgs = this.createReimburseArgs(
                    amountMST,
                    numberSequence,
                    billingClassificationId,
                    currentTransactionLedgerDimensionAccount,
                    currencyCode);
                this.reimburseNonSummarized(reimburseArgs);

                info(strFmt("@SPS2409", voucher));
            }
        }

        if (dimensionMap && dimensionMap.elements() > 0)
        {
            this.settleCustTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run(boolean _throwException = false, boolean _crosscompany = false, container _companies = conNull())
    {
        CustOverPaymRunArgs runArgs = CustOverPaymRunArgs::construct();
        runArgs.parmShouldThrowException(_throwException);
        runArgs.parmIsCrossCompany(_crosscompany);
        runArgs.parmCompanies(_companies);
        runArgs.parmMinimumAmount(CustParameters::find().MinRefund);
        runArgs.parmCurrencyExchangeHelper(
            CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId)));

        NumberSeq numberSequence = NumberSeq::newGetVoucher(this.numberSequence());

        runArgs.parmNumberSequence(numberSequence);

        queryRun.setRecord(custTable);

        setPrefix("@AccountsReceivable:ReimbursementProcessIsComplete");

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && inclTransWithNoBillingClassification == NoYes::Yes)
        {
            custBillingClassificationIds = custBillingClassificationIds + #comma + #zero;
        }

        while (queryRun.next())
        {
            ledgerVoucher = null;
            custTable = queryRun.get(tableNum(CustTable));

            try 
            {
                ttsbegin;
                if (summarizeCustomer)
                {
                    this.runSummarized(runArgs);
                }
                else
                {
                    this.runNonSummarized(runArgs);
                }
                ttscommit;
            }
            catch (Exception::Error)
            {
                numberSequence.abort();
                continue;
            }
        }

        TransactionLog::create(TransactionLogType::CustReimbursement, "@SYS24632");

        if (!summarizeCustomer)
        {
            if (isReimbursementGenerated)
            {
                info("@SYS27120");
            }
            else
            {
                warning("@SPS2454");
            }
        }

        if (!(isReimbursementGenerated || !summarizeCustomer))
        {
            warning("@SPS2454");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend <c>RunBaseBatch</c> must override the <c>runsImpersonated</c> method and
    ///    return false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendTransRemitToAddress</Name>
				<Source><![CDATA[
    private void setVendTransRemitToAddress(VendTrans   _vendTrans)
    {
        LogisticsLocationDefault vendDefaultRemitToLocation;
        LogisticsLocation logisticsLocation;
        LogisticsLocationRole logisticsLocationRole;
        boolean isDefaultRemitTo;

        DirPartyLocationRole dirPartyLocationRole;
        DirPartyLocation dirPartyLocation;
        boolean          isOnlyOneRemitToAddress;

        logisticsLocationRole = LogisticsLocationRole::findBytype(LogisticsLocationRoleType::RemitTo);

        ttsbegin;
        vendDefaultRemitToLocation = LogisticsLocationDefault::construct(vendTable);
        isDefaultRemitTo = vendDefaultRemitToLocation.defaultExistsByType(LogisticsLocationRoleType::RemitTo);
        isOnlyOneRemitToAddress =  (select count(RecId) from dirPartyLocationRole  where
         dirPartyLocationRole.LocationRole == logisticsLocationRole.RecId).RecId == 1;

        _vendTrans.selectForUpdate(true);

        if (isDefaultRemitTo)
        {
            // determines the vendor's logistics remit-to address location.
            logisticsLocationRole = LogisticsLocationRole::findBytype(LogisticsLocationRoleType::RemitTo);

            // gets the customer default remit-to address location.
            logisticsLocation = vendDefaultRemitToLocation.getDefaultLocationByType(LogisticsLocationRoleType::RemitTo);

            _vendTrans.RemittanceLocation = logisticsLocation.RecId;
            _vendTrans.update();
        }
        else if (isOnlyOneRemitToAddress)
        {
            select Party, RecId from dirPartyLocation
            where dirPartyLocation.Party == custTable.Party
            join dirPartyLocationRole
            where dirPartyLocationRole.LocationRole == logisticsLocationRole.RecId &&
            dirPartyLocationRole.PartyLocation == dirPartyLocation.RecId;

            _vendTrans.RemittanceLocation = dirPartyLocationRole.PartyLocation;
            _vendTrans.update();
        }
        else
        {
            _vendTrans.RemittanceLocation = vendDefaultRemitToLocation.getPrimaryPostalLocation().RecId;
            _vendTrans.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a select button to the dialog.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> object.If you change the return value to false the button will no
    ///    longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version     version = RunBase::getVersion(_packedClass);
        container   packedQuery;

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomer</Name>
				<Source><![CDATA[
    private void updateCustomer()
    {
        if (custTable.VendAccount != vendTable.AccountNum)
        {
            if (summarizeCustomer)
            {
                custTable.selectForUpdate(true);
            }
            else
            {
                custTable = CustTable::find(custTable.AccountNum, true);
            }

            custTable.VendAccount = vendTable.AccountNum;
            custTable.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the field selection for reimbursement.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called; optional.
    /// </param>
    /// <returns>
    /// true if the reimbursement is valid for running; otherwise, false.
    /// </returns>
    public boolean validate(Object _calledFrom = null)
    {
        boolean isValid = true;

        if (CustParameters::isBillingClassificationEnabled())
        {
            custBillingClassificationIds = con2StrUnlimited(custBillingClassificationIdsContainer,#comma);
            if (inclTransWithNoBillingClassification == NoYes::No && custBillingClassificationIds == "")
            {
                isValid = checkFailed("@SPS758");
            }
        }
        else
        {
            isValid = super(_calledFrom);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForDebitTransactions</Name>
				<Source><![CDATA[
    private boolean validateForDebitTransactions(AccountNum _accountNum)
    {
        CustTrans   localCustTrans;

        select RecId from localCustTrans
            where localCustTrans.AccountNum == _accountNum                      &&
                  localCustTrans.AmountCur  !=  localCustTrans.SettleAmountCur  &&
                  localCustTrans.AmountCur  >   0;

        return localCustTrans.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS24632";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReimbursementSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the settlement is for reimbursement.
    /// </summary>
    /// <param name="_custVendSettlement">
    /// The <c>CustVendSettlement</c> record.
    /// </param>
    /// <returns>
    /// true if the reimbursement is for settlement; otherwise, false.
    /// </returns>
    public static boolean isReimbursementSettlement(CustVendSettlement _custVendSettlement)
    {
        boolean     isReimbursementSettlement;
        CustTrans   custDebitTrans;
        CustTrans   custCreditTrans;

        if (_custVendSettlement.TableId == tableNum(CustSettlement))
        {
            custDebitTrans = CustTrans::find(_custVendSettlement.TransRecId);
            custCreditTrans = CustTrans::find(_custVendSettlement.OffsetRecId);

            isReimbursementSettlement = custDebitTrans.isReimbursement() || custCreditTrans.isReimbursement();
        }
        return isReimbursementSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        CustOverPaym custOverPaym = new CustOverPaym();
        CustTable custTable;

        if (args.caller() && args.record() && args.record().TableId == tableNum(CustTable))
        {
            custOverPaym.initFromArgs(args);

            if (custOverPaym.prompt())
            {
                if (formHasMethod(args.caller(), 'parmSelectedCompanies'))
                {
                    custOverPaym.runOperation();
                }
                else
                {
                    custOverPaym.runOperation();
                }
            }
        }
        else
        {
            if (custOverPaym.prompt())
            {
                custOverPaym.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the query range.
    /// </summary>
    /// <param name="_args">
    /// The <c>Args</c> object.
    /// </param>
    protected void initFromArgs(Args _args)
    {
        this.getLast();
        custTable = _args.record() as CustTable;
        SysQuery::findOrCreateRange(this.queryRun().query().dataSourceTable(tableNum(CustTable)), fieldNum(CustTable, AccountNum))
            .value(queryValue(custTable.AccountNum));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>