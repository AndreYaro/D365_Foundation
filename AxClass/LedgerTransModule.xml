<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerTransModule</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerTransModule</c> class generates the records for transaction origin.
/// </summary>
public class LedgerTransModule 
{
    private static const LedgerDimensionDefaultAccount DefaultDimensionDefaultValue = 0;
    private static const LedgerDimensionAccount LedgerDimensionDefaultValue = 0;
    private static const GeneralJournalEntryRecId GeneralJournalEntryRecIdDefaultValue = 0;
    private static const AmountCur TransactionAmountDefaultValue = 0;
    private static const Name TaxCodeStringDefaultValue = '';
    private static const NoYes IsCorrectionDefaultValue = NoYes::No;
    private static const TransTxt TextDefaultValue = '';

    private boolean delayMainAccountTranslation = false;

    UserConnection userConnection;
    Amount reportingCurrencyAmount;
    ExchRate fixedExchRate;

    // <GEERU>
    #isoCountryRegionCodes
    // </GEERU>

    LedgerTransModuleTmp transModuleTmp;
    RecordInsertList transModuleTmpList;

    boolean         showMainAccountOnly;

    // reset by createTransModule
    Integer         numTrans;
    int64           rowCount;

    boolean excludeAsset;
    boolean excludeBank;
    boolean excludeCustomer;
    boolean excludeGeneralLedger;
    boolean excludeInventory;
    boolean excludeProduction;
    boolean excludeProject;
    boolean excludeTax;
    boolean excludeVendor;

    boolean excludeEmployee;
    boolean excludeRCash;
    boolean excludeRDeferrals;
    boolean accumulateTrans;

    TmpRecIdFilter tmpRecIdFilter;

    GeneralJournalEntryRecId currentGJE;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>asset</Name>
				<Source><![CDATA[
    protected void asset(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        AssetTrans assetTrans;

        while select AmountCur, AmountMST, ReportingCurrencyAmount, AssetId, CurrencyCode, DefaultDimension, Txt from assetTrans
            where assetTrans.Voucher ==  _subledgerVoucher &&
                assetTrans.TransDate == _accountingDate
        {
            this.parmReportingCurrencyAmount(assetTrans.ReportingCurrencyAmount);
            this.insertTransactionList(
                tableNum(AssetTrans),
                assetTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::FixedAssets,
                assetTrans.AssetId,
                assetTrans.AmountMST,
                assetTrans.DefaultDimension,
                AssetTable::find(assetTrans.AssetId).Name,
                assetTrans.Txt,
                assetTrans.AmountCur,
                assetTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>asset_RU</Name>
				<Source><![CDATA[
    protected void asset_RU(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        RAssetTrans rAssetTrans;
        RAssetTransUnionView rAssetTransUnionView;

        while select AccountNum, AmountCur, AmountMST, CurrencyCode, DefaultDimension, LedgerDimension, Txt from rAssetTrans
            exists join rAssetTransUnionView
                where rAssetTransUnionView.RefRecId == rAssetTrans.RecId
                   && rAssetTransUnionView.Voucher == _subledgerVoucher
                   && rAssetTransUnionView.TransDate == _accountingDate
        {
            this.insertTransactionList(
                tableNum(RAssetTrans),
                rAssetTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::FixedAssets_RU,
                rAssetTrans.AccountNum,
                rAssetTrans.AmountMST,
                rAssetTrans.DefaultDimension,
                RAssetTable::find(rAssetTrans.AccountNum).Name,
                rAssetTrans.Txt,
                rAssetTrans.AmountCur,
                rAssetTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bank</Name>
				<Source><![CDATA[
    void bank(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        BankAccountTrans bankAccountTrans;

        while select AccountId, AmountCur, AmountMST, CurrencyCode, DefaultDimension, PaymReference, AmountReportingCurrency from bankAccountTrans
            where bankAccountTrans.Voucher == _subledgerVoucher
                && bankAccountTrans.TransDate == _accountingDate
        {
            this.parmReportingCurrencyAmount(bankAccountTrans.AmountReportingCurrency);
            this.insertTransactionList(
                tableNum(BankAccountTrans),
                bankAccountTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Bank,
                bankAccountTrans.AccountId,
                bankAccountTrans.AmountMST,
                bankAccountTrans.DefaultDimension,
                BankAccountTable::name(bankAccountTrans.AccountId),
                bankAccountTrans.PaymReference,
                bankAccountTrans.AmountCur,
                bankAccountTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransModule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Set the internal values used to find all the other vouchers related to a selected voucher.
    /// </summary>
    /// <param name="_seedGeneralJournalEntryRecId">
    ///    The general journal entry seed value used to populate the form.
    /// </param>
    /// <param name="_singleVoucherOnly">
    ///    Boolean value that indicates if the selection should be restricted to the selected voucher only;
    ///    optional.
    /// </param>
    public void createTransModule(GeneralJournalEntryRecId _seedGeneralJournalEntryRecId, boolean _singleVoucherOnly = true)
    {
        GeneralJournalEntry generalJournalEntry;
        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        Voucher subledgerVoucher;
        AccountingDate accountingDate;
        Set processedGeneralJournalEntries = new Set(Types::Int64);
        boolean processLedger;

        if (userConnection)
        {
            transModuleTmp.setConnection(userConnection);
        }

        if (!accumulateTrans)
        {
            delete_from transModuleTmp;
        }

        // <GEERU>
        if (! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            // </GEERU>
            numTrans = 0;
            rowCount = 0;
            // <GEERU>
        }
        // </GEERU>

        // cycle all vouchers related to GeneralJournalEntry
        while select RecId from generalJournalEntry
            where generalJournalEntry.RecId == _seedGeneralJournalEntryRecId
        join AccountingDate, Voucher from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
        {
            rowCount++;
            processLedger = false;

            if (!processedGeneralJournalEntries.in(generalJournalEntry.RecId))
            {
                // Process general journal entries only once since the join between subledger voucher table
                // will result in processing general journal account entry records multiple times
                // which in turn causes amounts to be shown multiple times.
                processLedger = true;
                processedGeneralJournalEntries.add(generalJournalEntry.RecId);
            }

            this.processAllModules(generalJournalEntry.RecId,
                subledgerVoucherGeneralJournalEntry.Voucher,
                subledgerVoucherGeneralJournalEntry.AccountingDate,
                processLedger);

            if (!_singleVoucherOnly)
            {
                // Find all the related vouchers.
                while select FromDate, FromVoucher, ToDate, ToVoucher from ledgerJournalVoucherChanged
                    where (ledgerJournalVoucherChanged.FromDate != ledgerJournalVoucherChanged.ToDate ||
                        ledgerJournalVoucherChanged.FromVoucher != ledgerJournalVoucherChanged.ToVoucher) &&
                        ((ledgerJournalVoucherChanged.FromDate == subledgerVoucherGeneralJournalEntry.AccountingDate &&
                        ledgerJournalVoucherChanged.FromVoucher == subledgerVoucherGeneralJournalEntry.Voucher) ||
                        (ledgerJournalVoucherChanged.ToDate == subledgerVoucherGeneralJournalEntry.AccountingDate &&
                        ledgerJournalVoucherChanged.ToVoucher == subledgerVoucherGeneralJournalEntry.Voucher))
                {
                    if (ledgerJournalVoucherChanged.FromDate == subledgerVoucherGeneralJournalEntry.AccountingDate &&
                        ledgerJournalVoucherChanged.FromVoucher == subledgerVoucherGeneralJournalEntry.Voucher)
                    {
                        accountingDate = ledgerJournalVoucherChanged.ToDate;
                        subledgerVoucher = ledgerJournalVoucherChanged.ToVoucher;
                    }
                    else
                    {
                        accountingDate = ledgerJournalVoucherChanged.FromDate;
                        subledgerVoucher = ledgerJournalVoucherChanged.FromVoucher;
                    }

                    // have to process
                    while select AccountingDate, GeneralJournalEntry, Voucher from subledgerVoucherLink
                        where subledgerVoucherLink.AccountingDate == accountingDate
                            && subledgerVoucherLink.Voucher == subledgerVoucher
                            && subledgerVoucherLink.VoucherDataAreaId == curExt()
                    {
                        processLedger = false;

                        if (!processedGeneralJournalEntries.in(subledgerVoucherLink.GeneralJournalEntry))
                        {
                            // Process general journal entries only once since the join between subledger voucher table
                            // will result in processing general journal account entry records multiple times
                            // which in turn causes amounts to be shown multiple times.
                            processLedger = true;
                            processedGeneralJournalEntries.add(subledgerVoucherLink.GeneralJournalEntry);
                        }

                        this.processAllModules(
                            subledgerVoucherLink.GeneralJournalEntry,
                            subledgerVoucherLink.Voucher,
                            subledgerVoucherLink.AccountingDate,
                            processLedger);
                    }
                }
            }
        }

        if (transModuleTmpList)
        {
            transModuleTmpList.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate customer transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void cust(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        CustTrans custTrans;

        while select AmountCur, AmountMST, AccountNum, Correct, CurrencyCode, DefaultDimension, Txt, ReportingCurrencyAmount from custTrans
            where custTrans.Voucher == _subledgerVoucher
                && custTrans.TransDate == _accountingDate
        {
            this.parmReportingCurrencyAmount(custTrans.ReportingCurrencyAmount);
            this.insertTransactionList(
                tableNum(CustTrans),
                custTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Cust,
                custTrans.AccountNum,
                custTrans.AmountMST,
                custTrans.DefaultDimension,
                CustTable::Find(custTrans.AccountNum).name(),
                custTrans.Txt,
                custTrans.AmountCur,
                custTrans.CurrencyCode,
                TaxCodeStringDefaultValue,
                custTrans.Correct);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deferrals_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for deferrals transactions for the specified voucher and accounting date.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The voucher number.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    protected void deferrals_RU(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        RDeferralsTrans rDeferralsTrans;
        RDeferralsTransUnionView rDeferralsTransUnionView;

        while select Amount, DeferralsId, LedgerDimension, Txt from rDeferralsTrans
            exists join rDeferralsTransUnionView
                where rDeferralsTransUnionView.RefRecId == rDeferralsTrans.RecId
                   && rDeferralsTransUnionView.Voucher == _subledgerVoucher
                   && rDeferralsTransUnionView.TransDate == _accountingDate
        {
            this.insertTransactionList(
                tableNum(RDeferralsTrans),
                rDeferralsTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::RDeferrals,
                rDeferralsTrans.DeferralsId,
                rDeferralsTrans.Amount,
                LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(rDeferralsTrans.LedgerDimension),
                RDeferralsTable::find(rDeferralsTrans.DeferralsId).Name,
                rDeferralsTrans.Txt,
                rDeferralsTrans.Amount,
                Ledger::accountingCurrency());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>empl_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate <c>EmplTrans_RU</c> transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void empl_RU(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        EmplTrans_RU emplTrans;

        while select AmountCur, AmountMST, CurrencyCode, EmplAccount, LedgerDimension, Txt from emplTrans
           where emplTrans.Voucher == _subledgerVoucher &&
                 emplTrans.TransDate == _accountingDate
        {
            this.insertTransactionList(
                tableNum(EmplTrans_RU),
                emplTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Employee_RU,
                emplTrans.EmplAccount,
                emplTrans.AmountMST,
                LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(emplTrans.LedgerDimension),
                EmployeeTable_RU::findByEmployeeId(emplTrans.EmplAccount).employeeName(),
                emplTrans.Txt,
                emplTrans.AmountCur,
                emplTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeAllModules</Name>
				<Source><![CDATA[
    /// <summary>
    /// Excludes all modules from processing.
    /// </summary>
    /// <remarks>
    /// The normal pattern is to call this method and then manually include a
    /// small number of modules.
    /// </remarks>
    public void excludeAllModules()
    {
        excludeAsset = true;
        excludeBank = true;
        excludeCustomer = true;
        excludeGeneralLedger = true;
        excludeInventory = true;
        excludeProduction = true;
        excludeProject = true;
        excludeTax = true;
        excludeVendor = true;

        // <GEERU>
        excludeEmployee = true;
        excludeRCash = true;
        excludeRDeferrals = true;
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransactionList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a new record in the table.
    /// </summary>
    /// <param name="_recordTableId">
    /// The reference table ID.
    /// </param>
    /// <param name="_recordRecId">
    /// The reference record ID.
    /// </param>
    /// <param name="_subledgerVoucher">
    /// The voucher number.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_module">
    /// The <c>SysModule</c> type for this record.
    /// </param>
    /// <param name="_id">
    /// The record description.
    /// </param>
    /// <param name="_amount">
    /// The transaction amount.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimension for this transaction.
    /// </param>
    /// <param name="_idName">
    /// The table name.
    /// </param>
    /// <param name="_transText">
    /// The transaction text.
    /// </param>
    /// <param name="_amountCur">
    /// The transaction currency amount.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <param name="_taxCodeString">
    /// The tax code.
    /// </param>
    /// <param name="_correct">
    /// A boolean value indicating whether the transaction is a correction.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The <c>DimensionAttributeValueCombination</c> record ID.
    /// </param>
    /// <param name="_generalJournalEntry">
    /// The <c>GeneralJournalEntry</c> record ID.
    /// </param>
    /// <param name="_isCredit">
    /// A boolean value indicating whether the transaction is a credit.
    /// </param>
    public void insertTransactionList(
        tableId                 _recordTableId,
        recId                   _recordRecId,
        Voucher                 _subledgerVoucher,
        AccountingDate          _accountingDate,
        SysModule               _module,
        DimensionDisplayValue   _id,
        Amount                  _amount,
        DimensionDefault        _defaultDimension,
        DirPartyName            _idName,
        TransTxt                _transText,
        AmountCur               _amountCur,
        CurrencyCode            _currencyCode,        
        Name                    _taxCodeString      = '',
        NoYes                   _correct            = NoYes::No,
        LedgerDimensionAccount  _ledgerDimension    = 0,
        GeneralJournalEntryRecId _generalJournalEntry = currentGJE,
        NoYes                   _isCredit = _amount < 0.0,
        MainAccountRecId        _mainAccount = 0)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            select count(RecId) from tmpRecIdFilter;
            if (tmpRecIdFilter.RecId)
            {
                select firstOnly RecId from tmpRecIdFilter
                    where tmpRecIdFilter.RefRecId   == _recordRecId
                       && tmpRecIdFilter.RefTableId == _recordTableId;

                if (! tmpRecIdFilter.RecId)
                {
                    return;
                }
            }
        }

        numTrans++;

        transModuleTmp.clear();

        LedgerTransModulePopulateLedgerTransModuleTmpParameters parameters = this.populateLedgerTransModuleTmpParameters(
            _recordTableId,
            _recordRecId,
            _subledgerVoucher,
            _accountingDate,
            _module,
            _id,
            _amount,
            _defaultDimension,
            _idName,
            _transText,
            _amountCur,
            _currencyCode,
            _taxCodeString,
            _correct,
            _ledgerDimension,
            _generalJournalEntry,
            _isCredit,
            _mainAccount);

        this.populateLedgerTransModuleTmp(parameters);

        transModuleTmpList.add(transModuleTmp);

        // Reset reportingCurrencyAmount value to 0 after processing.
        reportingCurrencyAmount = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerTransModuleTmpParameters</Name>
				<Source><![CDATA[
    private LedgerTransModulePopulateLedgerTransModuleTmpParameters populateLedgerTransModuleTmpParameters(
        TableId  _recordTableId,
        RecId _recordRecId,
        Voucher _subledgerVoucher,
        AccountingDate _accountingDate,
        SysModule _module,
        DimensionDisplayValue _id,
        Amount _amount,
        DimensionDefault _defaultDimension,
        DirPartyName _idName,
        TransTxt _transText,
        AmountCur _amountCur,
        CurrencyCode _currencyCode,
        Name  _taxCodeString,
        NoYes _correct,
        LedgerDimensionAccount _ledgerDimension,
        GeneralJournalEntryRecId _generalJournalEntry,
        NoYes _isCredit,
        MainAccountRecId _mainAccount)
    {
        LedgerTransModulePopulateLedgerTransModuleTmpParameters parameters = LedgerTransModulePopulateLedgerTransModuleTmpParameters::construct();

        parameters.recordTableId = _recordTableId;
        parameters.recordRecId = _recordRecId;
        parameters.subledgerVoucher = _subledgerVoucher;
        parameters.accountingDate = _accountingDate;
        parameters.module = _module;
        parameters.id = _id;
        parameters.amount = _amount;
        parameters.defaultDimension = _defaultDimension;
        parameters.idName = _idName;
        parameters.transText = _transText;
        parameters.amountCur = _amountCur;
        parameters.currencyCode = _currencyCode;
        parameters.taxCodeString = _taxCodeString;
        parameters.correct = _correct;
        parameters.ledgerDimension = _ledgerDimension;
        parameters.generalJournalEntry = _generalJournalEntry;
        parameters.isCredit = _isCredit;
        parameters.mainAccount = _mainAccount;

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerTransModuleTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>LedgerTransModuleTmp</c> buffer.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>LedgerTransModulePopulateLedgerTransModuleTmpParameters</c> instance which contains the parameters used to populate <c>LedgerTransModuleTmp</c> buffer.
    /// </param>
    [Wrappable(true)]
    protected final void populateLedgerTransModuleTmp(LedgerTransModulePopulateLedgerTransModuleTmpParameters _parameters)
    {
        transModuleTmp.Counter = numTrans;
        transModuleTmp.RecordTableId = _parameters.recordTableId;
        transModuleTmp.RecordRecId = _parameters.recordRecId;
        transModuleTmp.Module = _parameters.module;
        transModuleTmp.Amount = _parameters.amount;
        transModuleTmp.DefaultDimension = _parameters.defaultDimension;
        transModuleTmp.IdName = _parameters.idName;
        transModuleTmp.TransText = _parameters.transText;
        transModuleTmp.Id = _parameters.id;
        transModuleTmp.AmountCur = _parameters.amountCur;
        transModuleTmp.CurrencyCode = _parameters.currencyCode;
        transModuleTmp.TaxCodeString = _parameters.taxCodeString;
        transModuleTmp.MainAccount = _parameters.mainAccount;

        // For ledger transactions, keep the voucher number blank if multiple vouchers exist for the GeneralJournalEntry
        if (_parameters.module == SysModule::Ledger && rowCount > 1)
        {
            transModuleTmp.Voucher = "";
        }
        else
        {
            transModuleTmp.Voucher = _parameters.subledgerVoucher;
        }

        transModuleTmp.TransDate = _parameters.accountingDate;
        transModuleTmp.Correct = _parameters.correct;
        transModuleTmp.IsCredit = _parameters.isCredit;
        transModuleTmp.LedgerDimension = _parameters.ledgerDimension;
        transModuleTmp.GeneralJournalEntry = _parameters.generalJournalEntry;
        transModuleTmp.ReportingCurrencyAmount = this.parmReportingCurrencyAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>invent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate inventory transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void invent(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        InventTransPosting inventTransPosting;

        while select * from inventTransPosting
            index hint DateVoucherTransIdx
            where  inventTransPosting.Voucher == _subledgerVoucher
                && inventTransPosting.TransDate == _accountingDate
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _accountingDate);
            this.parmReportingCurrencyAmount(currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(Ledger::accountingCurrency(), inventTransPosting.PostedValue()));
            this.insertTransactionList(
                tableNum(InventTransPosting),
                inventTransPosting.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Invent,
                inventTransPosting.ItemId,
                inventTransPosting.PostedValue(),
                inventTransPosting.DefaultDimension,
                InventTable::Name(inventTransPosting.ItemId),
                Enum2Str(inventTransPosting.InventTransPostingType),
                inventTransPosting.postedValue(),
                Ledger::accountingCurrency());
        }

        InventSettlement inventSettlement;

        while select CostAmountAdjustment, DefaultDimension, ItemId, InventTransCurrency_RU from inventSettlement
            where inventSettlement.TransDate == _accountingDate
                && inventSettlement.Voucher == _subledgerVoucher
        {
            this.insertTransactionList(
                tableNum(InventSettlement),
                inventSettlement.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Invent,
                inventSettlement.ItemId,
                inventSettlement.CostAmountAdjustment,
                inventSettlement.DefaultDimension,
                InventTable::Find(inventSettlement.ItemId).defaultProductName(),
                TextDefaultValue,
                inventSettlement.CostAmountAdjustment,
                inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur ? Ledger::accountingCurrency() : Ledger::reportingCurrency());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Default constructor for the class.
    /// </summary>
    /// <returns>A new instance of the <c>LedgerTransModule</c> class.</returns>
    public static LedgerTransModule construct()
    {
        return new LedgerTransModule();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForSpecificTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>LedgerTransModule</c> class tied to a specific temporary table.
    /// </summary>
    /// <param name = "_tempTable">A temporary table to use when generating the data.</param>
    /// <returns>A new instance of the <c>LedgerTransModule</c> class.</returns>
    public static LedgerTransModule constructForSpecificTable(LedgerTransModuleTmp _tempTable)
    {
        LedgerTransModule newTransModule = new LedgerTransModule();
        newTransModule.setTempTableInstance(_tempTable);

        return newTransModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTempTableInstance</Name>
				<Source><![CDATA[
    protected void setTempTableInstance(LedgerTransModuleTmp _tempTable)
    {
        transModuleTmp.linkPhysicalTableInstance(_tempTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccumulateTrans</Name>
				<Source><![CDATA[
    public boolean parmAccumulateTrans(boolean _accumulateTrans = accumulateTrans)
    {
        accumulateTrans = _accumulateTrans;
        return accumulateTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeAsset</Name>
				<Source><![CDATA[
    public boolean parmExcludeAsset(boolean _excludeAsset = excludeAsset)
    {
        excludeAsset = _excludeAsset;
        return excludeAsset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeBank</Name>
				<Source><![CDATA[
    public boolean parmExcludeBank(boolean _excludeBank = excludeBank)
    {
        excludeBank = _excludeBank;
        return excludeBank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeCustomer</Name>
				<Source><![CDATA[
    public boolean parmExcludeCustomer(boolean _excludeCustomer = excludeCustomer)
    {
        excludeCustomer = _excludeCustomer;
        return excludeCustomer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeEmployee_RU</Name>
				<Source><![CDATA[
    public boolean parmExcludeEmployee_RU(boolean _excludeEmployee = excludeEmployee)
    {
        excludeEmployee = _excludeEmployee;
        return excludeEmployee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeGeneralLedger</Name>
				<Source><![CDATA[
    public boolean parmExcludeGeneralLedger(boolean _excludeGeneralLedger = excludeGeneralLedger)
    {
        excludeGeneralLedger = _excludeGeneralLedger;
        return excludeGeneralLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeInventory</Name>
				<Source><![CDATA[
    public boolean parmExcludeInventory(boolean _excludeInventory = excludeInventory)
    {
        excludeInventory = _excludeInventory;
        return excludeInventory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeProduction</Name>
				<Source><![CDATA[
    public boolean parmExcludeProduction(boolean _excludeProduction = excludeProduction)
    {
        excludeProduction = _excludeProduction;
        return excludeProduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeProject</Name>
				<Source><![CDATA[
    public boolean parmExcludeProject(boolean _excludeProject = excludeProject)
    {
        excludeProject = _excludeProject;
        return excludeProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeRCash_RU</Name>
				<Source><![CDATA[
    public boolean parmExcludeRCash_RU(boolean _excludeRCash = excludeRCash)
    {
        excludeRCash = _excludeRCash;
        return excludeRCash;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeRDeferrals_RU</Name>
				<Source><![CDATA[
    public boolean parmExcludeRDeferrals_RU(boolean _excludeRDeferrals = excludeRDeferrals)
    {
        excludeRDeferrals = _excludeRDeferrals;
        return excludeRDeferrals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeTax</Name>
				<Source><![CDATA[
    public boolean parmExcludeTax(boolean _excludeTax = excludeTax)
    {
        excludeTax = _excludeTax;
        return excludeTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeVendor</Name>
				<Source><![CDATA[
    public boolean parmExcludeVendor(boolean _excludeVendor = excludeVendor)
    {
        excludeVendor = _excludeVendor;
        return excludeVendor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowMainAccountOnly</Name>
				<Source><![CDATA[
    public boolean parmShowMainAccountOnly(boolean _showMainAccountOnly = showMainAccountOnly)
    {
        showMainAccountOnly = _showMainAccountOnly;

        return showMainAccountOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDelayMainAccountTranslation</Name>
				<Source><![CDATA[
    public boolean parmDelayMainAccountTranslation(boolean _delayMainAccountTranslation = delayMainAccountTranslation)
    {
        delayMainAccountTranslation = _delayMainAccountTranslation;
        return delayMainAccountTranslation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpRecIdFilter_RU</Name>
				<Source><![CDATA[
    public TmpRecIdFilter parmTmpRecIdFilter_RU(TmpRecIdFilter _tmpRecIdFilter = tmpRecIdFilter)
    {
        tmpRecIdFilter = _tmpRecIdFilter;
        return tmpRecIdFilter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUserConnection</Name>
				<Source><![CDATA[
    public UserConnection parmUserConnection(UserConnection _userConnection = userConnection)
    {
        userConnection = _userConnection;
        return userConnection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyAmount</Name>
				<Source><![CDATA[
    public Amount parmReportingCurrencyAmount(Amount _reportingCurrencyAmount = reportingCurrencyAmount)
    {
        reportingCurrencyAmount = _reportingCurrencyAmount;
        return reportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAllModules</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Generates transactions for all modules.
    /// </summary>
    /// <param name="_generalJournalEntryRecId">
    ///  The record ID of the <c>GeneralJournalEntry</c> buffer.
    /// </param>
    /// <param name="_subledgerVoucher">
    ///  The <c>Voucher</c> value for which the transactions need to be generated.
    /// </param>
    /// <param name="_accountingDate">
    ///  The <c>AccountingDate</c> value for which the transactions need to be generated.
    /// </param>
    /// <param name="_processLedger">
    ///  A boolean value which determines whether the ledger module has to be processed or not; Optional.
    /// </param>
    public void processAllModules(GeneralJournalEntryRecId _generalJournalEntryRecId, Voucher _subledgerVoucher, AccountingDate _accountingDate, boolean _processLedger = true)
    {
        if (userConnection)
        {
            transModuleTmp.setConnection(userConnection);
        }

        if (!transModuleTmpList)
        {
            transModuleTmpList = new RecordInsertList(tableNum(LedgerTransModuleTmp), true, true, true, true, true, transModuleTmp);
        }

        currentGJE = _generalJournalEntryRecId;

        if (!excludeGeneralLedger && _processLedger)
        {
            this.processLedger(_generalJournalEntryRecId, _accountingDate);
        }

        if (!excludeCustomer)
        {
            this.cust(_subledgerVoucher, _accountingDate);
        }

        if (!excludeVendor)
        {
            this.vend(_subledgerVoucher, _accountingDate);
        }

        if (!excludeInventory)
        {
            this.invent(_subledgerVoucher, _accountingDate);
        }

        if (!excludeProduction)
        {
            this.prod(_subledgerVoucher, _accountingDate);
        }

        if (!excludeBank)
        {
            this.bank(_subledgerVoucher, _accountingDate);
        }

        if (!excludeTax)
        {
            this.tax(_subledgerVoucher, _accountingDate);
        }

        if (!excludeProject)
        {
            this.proj(_subledgerVoucher, _accountingDate);
        }

        if (!excludeAsset)
        {
            this.asset(_subledgerVoucher, _accountingDate);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (!excludeAsset)
            {
                this.asset_RU(_subledgerVoucher, _accountingDate);
            }

            if (!excludeEmployee)
            {
                this.empl_RU(_subledgerVoucher, _accountingDate);
            }

            if (!excludeRCash)
            {
                this.rcash_RU(_subledgerVoucher, _accountingDate);
            }

            if (!excludeRDeferrals)
            {
                this.deferrals_RU(_subledgerVoucher, _accountingDate);
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Generates transactions for ledger module.
    /// </summary>
    /// <param name="_generalJournalEntryRecId">
    ///  The record ID of the <c>GeneralJournalEntry</c> buffer.
    /// </param>
    /// <param name="_accountingDate">
    ///  The <c>AccountingDate</c> value for which the transactions need to be generated.
    /// </param>
    protected void processLedger(GeneralJournalEntryRecId _generalJournalEntryRecId, AccountingDate _accountingDate)
    {
        DimensionAttributeValueCombination dimAttrValueCombo;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        MainAccount mainAccount;
        TaxTrans taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        Name taxCodeString;
        DimensionDefault defaultDimension;
        Set taxCodes;        
        LedgerEntryJournal  ledgerEntryJournal;

        while select SubledgerVoucher from generalJournalEntry
            where generalJournalEntry.RecId == _generalJournalEntryRecId
        join AccountingCurrencyAmount, IsCorrection, IsCredit, ReportingCurrencyAmount,
            TransactionCurrencyAmount, TransactionCurrencyCode, Text, RecId, LedgerAccount, LedgerDimension from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
        join RecId, MainAccountId, Name from mainAccount
            where mainAccount.RecId == generalJournalAccountEntry.MainAccount
        outer join JournalNumber from ledgerEntryJournal
            where ledgerEntryJournal.RecId == generalJournalEntry.LedgerEntryJournal        
        {
            taxCodeString = '';
            taxCodes = new Set(Types::String);

            LedgerJournalType journalType;
            if (ledgerEntryJournal.JournalNumber)
            {
                journalType = LedgerJournalTable::find(ledgerEntryJournal.JournalNumber).JournalType;                
            }  
            
            boolean isReportingCurrencyPrimary = (journalType == LedgerJournalType::ReportingCurrencyAdjustment);

            while select RecId from taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
            join TaxCode from taxTrans
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
            {
                if (!taxCodes.in(taxTrans.TaxCode))
                {
                    // Append the tax codes only once.
                    taxCodeString += taxTrans.TaxCode + ',';
                    taxCodes.add(taxTrans.TaxCode);
                }
            }

            // Remove the dangling comma at the end.
            if (strScan(taxCodeString, ',', strLen(taxCodeString), 1))
            {
                taxCodeString = subStr(taxCodeString, 1, strLen(taxCodeString) -1);
            }

            this.parmReportingCurrencyAmount(generalJournalAccountEntry.ReportingCurrencyAmount);

            this.insertTransactionList(
                tablenum(GeneralJournalAccountEntry),
                generalJournalAccountEntry.RecId,
                generalJournalEntry.SubledgerVoucher,
                _accountingDate,
                SysModule::Ledger,
                showMainAccountOnly ? mainAccount.MainAccountId : generalJournalAccountEntry.LedgerAccount,
                isReportingCurrencyPrimary ? generalJournalAccountEntry.ReportingCurrencyAmount : generalJournalAccountEntry.AccountingCurrencyAmount,
                defaultDimension,
                delayMainAccountTranslation ? mainAccount.Name : MainAccount::getLocalizedName(mainAccount.RecId),
                generalJournalAccountEntry.Text,
                generalJournalAccountEntry.TransactionCurrencyAmount,
                generalJournalAccountEntry.TransactionCurrencyCode,
                taxCodeString,
                generalJournalAccountEntry.IsCorrection,
                generalJournalAccountEntry.LedgerDimension,
                _generalJournalEntryRecId,
                generalJournalAccountEntry.IsCredit,
                generalJournalAccountEntry.MainAccount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate production transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void prod(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        ProdTableJour prodTableJour;

        while select AmountFinancial, JournalType, ProdId from prodTableJour
            where prodTableJour.TransDate == _accountingDate
                && prodTableJour.Voucher == _subledgerVoucher
        {
            DimensionDefault defaultDimension = ProdTable::find(prodTableJour.ProdId).DefaultDimension;

            this.insertTransactionList(
                tableNum(ProdTableJour),
                prodTableJour.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Prod,
                prodTableJour.ProdId,
                prodTableJour.AmountFinancial,
                defaultDimension,
                ProdTable::Find(prodTableJour.ProdId).Name,
                Enum2Str(prodTableJour.JournalType),
                prodTableJour.AmountFinancial,
                ''); // empty currency code because that is the legacy behavior
        }

        ProdRouteTrans prodRouteTrans;

        while select * from prodRouteTrans
            where prodRouteTrans.DateWIP == _accountingDate
                && prodRouteTrans.VoucherWIP == _subledgerVoucher
        {
            this.insertTransactionList(
                tableNum(ProdRouteTrans),
                prodRouteTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Prod,
                prodRouteTrans.TransRefId,
                prodRouteTrans.Amount,
                prodRouteTrans.DefaultDimension,
                prodRouteTrans.transRefName(),
                prodRouteTrans.OprId,
                prodRouteTrans.Amount,
                ''); // empty currency code because that is the legacy behavior
        }

        while select prodRouteTrans
            where prodRouteTrans.DateCalc == _accountingDate
                && prodRouteTrans.VoucherCalc == _subledgerVoucher
        {
            this.insertTransactionList(
                tableNum(ProdRouteTrans),
                prodRouteTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Prod,
                prodRouteTrans.TransRefId,
                prodRouteTrans.Amount,
                prodRouteTrans.DefaultDimension,
                prodRouteTrans.transRefName(),
                prodRouteTrans.OprId,
                prodRouteTrans.Amount,
                ''); // empty currency code because that is the legacy behavior
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>proj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate project transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void proj(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        ProjTransPosting projTransPosting;

        Set recIdSet = new Set(Types::Int64);

        while select ProjTransType, TransId, InventTransId, ProjAdjustRefId, CostSales, AmountMst from projTransPosting
            index hint VoucherDateIdx
            where projTransPosting.Voucher          == _subledgerVoucher &&
                  projTransPosting.LedgerTransDate  == _accountingDate &&
                 (projTransPosting.ProjTransType    == ProjTransType::Revenue    ||
                  projTransPosting.ProjTransType    == ProjTransType::Hour       ||
                  projTransPosting.ProjTransType    == ProjTransType::Cost       ||
                  projTransPosting.ProjTransType    == ProjTransType::Item       ||
                  projTransPosting.ProjTransType    == ProjTransType::OnAccount)
        {
            ProjTrans projTrans;

            switch (projTransPosting.ProjTransType)
            {
                case ProjTransType::Revenue :
                    ProjRevenueTrans projRevenueTrans;

                    select * from projRevenueTrans
                        where projRevenueTrans.TransId == projTransPosting.TransId;

                    projTrans = ProjTrans::newProjRevenueTrans(projRevenueTrans);

                    break;

                case ProjTransType::Hour:
                    ProjEmplTrans projEmplTrans;

                    select * from projEmplTrans
                        where projEmplTrans.TransId == projTransPosting.TransId;

                    projTrans = ProjTrans::newProjEmplTrans(projEmplTrans);
                    break;

                case ProjTransType::Cost:
                    ProjCostTrans projCostTrans;

                    select * from projCostTrans
                        where projCostTrans.TransId == projTransPosting.TransId;

                    if (!recIdSet.in(projCostTrans.RecId))
                    {
                        recIdSet.add(projCostTrans.RecId);
                        projTrans = ProjTrans::newProjCostTrans(projCostTrans);
                    }

                    break;

                case ProjTransType::Item:
                    if (projTransPosting.CostSales  == ProjCostSales::Cost)
                    {
                        ProjItemTransCost projItemTransCost;
                        
                        select firstonly projItemTransCost
                                where projItemTransCost.InventTransId   == projTransPosting.InventTransId &&
                                      projItemTransCost.ProjAdjustRefId == projTransPosting.ProjAdjustRefId &&
                                      projItemTransCost.Voucher == _subledgerVoucher;
                        
                        projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    }
                    else
                    {
                        ProjItemTrans projItemTrans;

                        select * from projItemTrans
                                where projItemTrans.InventTransId   == projTransPosting.InventTransId   &&
                                      projItemTrans.ProjAdjustRefId == projTransPosting.ProjAdjustRefId;

                        projTrans = ProjTrans::newProjItemTrans(projItemTrans);
                    }
                    break;

                case ProjTransType::OnAccount:
                    ProjOnAccTrans projOnAccTrans;

                    select * from projOnAccTrans
                        where projOnAccTrans.TransId == projTransPosting.TransId;

                    projTrans = ProjTrans::newProjOnAccTrans(projOnAccTrans);
                    break;
            }

            if (projTrans && projTrans.recId())
            {
                
                if (projTransPosting.CostSales  == ProjCostSales::Cost)
                {
                   
                    GeneralJournalAccountEntry generalJournalAccountEntry;
                    GeneralJournalEntry generalJournalEntry;

                    select firstonly generalJournalAccountEntry
                            join RecId from generalJournalEntry
                            where generalJournalAccountEntry.generalJournalEntry == generalJournalEntry.RecId
                                && generalJournalEntry.SubledgerVoucher == _subledgerVoucher
                                && generalJournalEntry.SubledgerVoucherDataAreaId == projTransPosting.DataAreaId;

                    AmountMSTSecondary reportingAmountInReportingCurrency = this.getReportingCurrencyForAccountingCurrency(projTransPosting.AmountMst, generalJournalAccountEntry, _accountingDate);
                    this.parmReportingCurrencyAmount(reportingAmountInReportingCurrency);
                    
                    // Added code to insert correct amount against <c>AccountType</c> - Project when user clicks <c>TransactionOrigin</c>
                    // in case of purchase order with either procurement category or non-stocked item.
                    PurchLine purchLine = PurchLine::findInventTransId(projTransPosting.InventTransId);

                    if (purchLine
                        && !purchLine.isStocked())
                    {
                        
                        ExchRate exchRate = ExchangeRateCalculation::calculateReciprocalExchangeRate(generalJournalAccountEntry.getAccountingExchangeRate());

                        this.insertTransactionList(projTrans.tableId(),
                                         projTrans.recId(),
                                         _subledgerVoucher,
                                         _accountingDate,
                                         SysModule::Project,
                                         projTrans.projId(),
                                         projTransPosting.AmountMst,
                                         projTrans.defaultDimension(),
                                         ProjTable::name(projTrans.projId()),
                                         projTrans.txt(),
                                         CurrencyExchangeHelper::amountCur2MST(projTransPosting.AmountMst, generalJournalAccountEntry.TransactionCurrencyCode, exchRate),
                                         generalJournalAccountEntry.TransactionCurrencyCode);
                    }
                    else
                    {
                        this.insertTransactionList(projTrans.tableId(),
                                         projTrans.recId(),
                                         _subledgerVoucher,
                                         _accountingDate,
                                         SysModule::Project,
                                         projTrans.projId(),
                                         projTransPosting.AmountMst,
                                         projTrans.defaultDimension(),
                                         ProjTable::name(projTrans.projId()),
                                         projTrans.txt(),
                                         projTrans.transCost(),
                                         projTrans.currencyIdCost());
                    }
                }

                if (projTransPosting.CostSales  == ProjCostSales::Sales)
                {
                    this.insertTransactionList(projTrans.tableId(),
                                         projTrans.recId(),
                                         _subledgerVoucher,
                                         _accountingDate,
                                         SysModule::Project,
                                         projTrans.projId(),
                                         projTransPosting.AmountMst,
                                         projTrans.defaultDimension(),
                                         ProjTable::name(projTrans.projId()),
                                         projTrans.txt(),
                                         projTrans.transTurnover(),
                                         projTrans.currencyIdSales());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyForAccountingCurrency</Name>
				<Source><![CDATA[
    private AmountMstSecondary getReportingCurrencyForAccountingCurrency(AmountMst _amount, GeneralJournalAccountEntry _generalJournalAccount, AccountingDate _accountingDate)
    {
        AmountMstSecondary reportingAmount = _amount;
        if(reportingAmount && _generalJournalAccount) 
        {
            CurrencyCode accountingCurrencyCode = Ledger::accountingCurrency();
            CurrencyCode reportingCurrencyCode = Ledger::reportingCurrency();

            if(accountingCurrencyCode != reportingCurrencyCode)
            {
                CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _accountingDate);
                exchangeRateHelper.parmExchangeRate1(_generalJournalAccount.getReportingExchangeRate());
                reportingAmount = exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(accountingCurrencyCode, _amount);
            }
        }
        return reportingAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rcash_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate <c>RCashTrans</c> transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void rcash_RU(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        RCashTrans cashTrans;

        while select AmountCur, AccountNum, AmountMST, CurrencyCode, LedgerDimension, Txt from cashTrans
            where cashTrans.Voucher == _subledgerVoucher &&
                cashTrans.TransDate == _accountingDate
        {
            this.insertTransactionList(
                tableNum(RCashTrans),
                cashTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::RCash,
                cashTrans.AccountNum,
                cashTrans.AmountMST,
                LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(cashTrans.LedgerDimension),
                RCashTable::find(cashTrans.AccountNum).Name,
                cashTrans.Txt,
                cashTrans.AmountCur,
                cashTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate tax transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void tax(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        MainAccount mainAccount;
        TaxTrans taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;

        RecId lastTaxTransRecId;

        //For the posted tax transactions where the tax link records to GeneralJournalAccountEntry have been created.
        while select RecId, HeadingTableId, SourceDocumentLine, SourceCurrencyCode, SourceTaxAmountCur,
                TaxAmount, TaxCode, TaxGroup, TaxOrigin, TaxAutogenerated, SourceRegulateAmountCur,
                TaxInCostPriceRegulated, TaxInCostPrice, TaxInCostPriceMST, TaxAmountRep, TaxInCostPriceRep, TransDate, SourceRecId, SourceTableId, Voucher
			from taxTrans
            order by taxTrans.RecId
            where taxTrans.Voucher == _subledgerVoucher
                && taxTrans.TransDate == _accountingDate
        outer join RecId from taxTransGeneralJournalAccountEntry
            where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax ||
                    taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice ||
                    taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount)
        join RecId, GeneralJournalEntry from generalJournalAccountEntry
            where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
        join RecId, DisplayValue, MainAccount from dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        {
            // For source documents, lines may have been distributed between different dimensions
            // or multiple records that go to the same account could've been merged together,
            // so grab the original transaction values from accounting distributions
            mainAccount = MainAccount::find(dimensionAttributeValueCombination.MainAccount);

            this.insertTransModuleTmp(
                taxTrans,
                lastTaxTransRecId,
                dimensionAttributeValueCombination,
                _subledgerVoucher,
                _accountingDate,
                generalJournalAccountEntry,
                mainAccount);

            lastTaxTransRecId = taxTrans.RecId;
        }

        //For the posted tax transactions not associated with tax link record to GeneralJournalAccountEntry.
        while select RecId, HeadingTableId, SourceDocumentLine, SourceCurrencyCode, SourceTaxAmountCur,
                TaxAmount, TaxCode, TaxGroup, TaxOrigin, TaxAutogenerated, SourceRegulateAmountCur,
                TaxInCostPriceRegulated, TaxInCostPrice, TaxInCostPriceMST, TaxAmountRep, TaxInCostPriceRep, TransDate, SourceRecId, SourceTableId, Voucher
			from taxTrans
            order by taxTrans.RecId
            where taxTrans.Voucher == _subledgerVoucher
                && taxTrans.TransDate == _accountingDate
        outer join RecId from taxTransGeneralJournalAccountEntry
            where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax ||
                    taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice ||
                    taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount)
                && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == 0
        join RecId, DisplayValue, MainAccount from dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == taxTransGeneralJournalAccountEntry.LedgerDimension
        {
            // For source documents, lines may have been distributed between different dimensions
            // or multiple records that go to the same account could've been merged together,
            // so grab the original transaction values from accounting distributions
            mainAccount = MainAccount::find(dimensionAttributeValueCombination.MainAccount);

            this.insertTransModuleTmp(
                taxTrans,
                lastTaxTransRecId,
                dimensionAttributeValueCombination,
                _subledgerVoucher,
                _accountingDate,
                generalJournalAccountEntry,
                mainAccount);

            lastTaxTransRecId = taxTrans.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransModuleTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts data into <c>TransModuleTmp</c> table.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <param name = "_lastTaxTransRecId">
    /// The Record id of last <c>TaxTrans</c> record.
    /// </param>
    /// <param name = "_dimensionAttributeValueCombination">
    /// The <c>DimensionAttributeValueCombination</c> record.
    /// </param>
    /// <param name = "_subledgerVoucher">
    /// The voucher value.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date value.
    /// </param>
    /// <param name = "_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <param name = "_mainAccount">
    /// The <c>MainAccount</c> record.
    /// </param>
    protected void insertTransModuleTmp(
        TaxTrans                            _taxTrans,
        RecId                               _lastTaxTransRecId,
        DimensionAttributeValueCombination  _dimensionAttributeValueCombination,
        Voucher                             _subledgerVoucher,
        AccountingDate                      _accountingDate,
        GeneralJournalAccountEntry          _generalJournalAccountEntry,
        MainAccount                         _mainAccount)
    {
        AmountMST       taxAmountMST;
        AmountCur       taxAmountCur;
        TaxAmountCur    taxAmountRep;
        CurrencyCode    taxSourceCurrencyCode;

        boolean isRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (_taxTrans.SourceDocumentLine)
        {
            if (_taxTrans.RecId == _lastTaxTransRecId)
            {
                return;
            }

            AccountingDistribution accountingDistribution;

            select firstOnly count(RecId), sum(TransactionCurrencyAmount), TransactionCurrency from accountingDistribution
                    group by accountingDistribution.SourceDocumentLine, accountingDistribution.LedgerDimension, accountingDistribution.TransactionCurrency
                        where accountingDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine &&
                              accountingDistribution.LedgerDimension == _dimensionAttributeValueCombination.RecId;

            if (accountingDistribution.RecId)
            {
                taxAmountCur = accountingDistribution.TransactionCurrencyAmount;
                taxSourceCurrencyCode = accountingDistribution.TransactionCurrency;
                taxAmountRep = _taxTrans.netTaxAmountRep();
            }
            else
            {
                taxAmountCur = _taxTrans.netSourceTaxAmountCur();
                taxSourceCurrencyCode = _taxTrans.SourceCurrencyCode;
                taxAmountRep = _taxTrans.netTaxAmountRep();
            }

            TransDate exchangeDate = this.exchRateDate_W(_generalJournalAccountEntry, _taxTrans, _accountingDate);

            if (TaxApplyFixedExchangRateInVendorTransactionOriginFlight::instance().isEnabled())
            {
                taxAmountMST = this.getTaxAmountMST(accountingDistribution, _taxTrans, exchangeDate, this.parmFixedExchRate());
            }
            else
            {
                taxAmountMST = this.getTaxAmountMST(accountingDistribution, _taxTrans, exchangeDate, 0);
            }
        }
        else
        {
            taxAmountCur = TaxParameters::find().PurchTaxOnOperations ? _taxTrans. SourceTaxAmountCur : _taxTrans.netSourceTaxAmountCur();
            taxSourceCurrencyCode = _taxTrans.SourceCurrencyCode;
            taxAmountMST = TaxParameters::find().PurchTaxOnOperations ? _taxTrans.TaxAmount : _taxTrans.netTaxAmountMST();
            taxAmountRep = TaxParameters::find().PurchTaxOnOperations ? _taxTrans.TaxAmountRep : _taxTrans.netTaxAmountRep();
        }

        if (_taxTrans)
        {
            this.parmReportingCurrencyAmount(taxAmountRep);
        }

        this.insertTransactionList(
                    isRU ? tableNum(GeneralJournalAccountEntry) : tableNum(TaxTrans),
                    isRU ? _generalJournalAccountEntry.RecId : _taxTrans.RecId,
                    _subledgerVoucher,
                    _accountingDate,
                    SysModule::Tax,
                    showMainAccountOnly ? _mainAccount.MainAccountId : _dimensionAttributeValueCombination.DisplayValue,
                    taxAmountMST,
                    LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_dimensionAttributeValueCombination.RecId),
                    TaxTable::Find(_taxTrans.TaxCode).TaxName,
                    enum2str(_taxTrans.TaxOrigin),
                    taxAmountCur,
                    taxSourceCurrencyCode,
                    _taxTrans.TaxCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateDate_W</Name>
				<Source><![CDATA[
    private TransDate exchRateDate_W(GeneralJournalAccountEntry _generalJournalAccountEntry, TaxTrans _taxTrans, TransDate _accountingDate)
    {
        TransDate exchangeDate = _accountingDate;

        if (//Only free text invoice will be impact
            _taxTrans.HeadingTableId == tableNum(CustInvoiceJour))
        {
            GeneralJournalEntry generalJournalEntryLocal = GeneralJournalEntry::find(_generalJournalAccountEntry.GeneralJournalEntry);
            switch (SalesParameters::find().DateOfExchRate_W)
            {
                case DateOfExchRate_W::DateOfVATRegister:
                    CustInvoiceJour custInvoiceJour = CustInvoiceJour::findFromTaxTrans(_taxTrans.Voucher, _taxTrans.TransDate);
                    if (custInvoiceJour)
                    {
                        exchangeDate = custInvoiceJour.vatDueDate_W();
                    }
                    break;
                case DateOfExchRate_W::DocumentDate:
                    if (generalJournalEntryLocal)
                    {
                        exchangeDate = generalJournalEntryLocal.DocumentDate;
                    }
                    break;
                case DateOfExchRate_W::DocumentDateEU:
                    if (TaxGroupHeading::find(_taxTrans.TaxGroup).EUTrade_W)
                    {         
                        if (generalJournalEntryLocal)
                        {
                            exchangeDate = generalJournalEntryLocal.DocumentDate;
                        }
                    }
                    break;
            }
        }

        return exchangeDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transModule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>RecordInsertList</c> instance and inserts the records to the database.
    /// </summary>
    /// <returns>
    /// The <c>RecordInsertList</c> instance.
    /// </returns>
    LedgerTransModuleTmp transModule()
    {
        if (transModuleTmpList)
        {
            transModuleTmpList.insertDatabase();
        }

        return transModuleTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate vendor transactions.
    /// </summary>
    /// <param name = "_subledgerVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date.
    /// </param>
    protected void vend(Voucher _subledgerVoucher, AccountingDate _accountingDate)
    {
        VendTrans vendTrans;

        while select AmountCur, AmountMST, AccountNum, Correct, CurrencyCode, DefaultDimension, Txt, ReportingCurrencyAmount, FixedExchRate, ExchRate from vendTrans
            where vendTrans.Voucher == _subledgerVoucher
                && vendTrans.TransDate == _accountingDate
        {
            if (TaxApplyFixedExchangRateInVendorTransactionOriginFlight::instance().isEnabled() && vendTrans.FixedExchRate)
            {
                this.parmFixedExchRate(vendTrans.ExchRate);
            }

            this.parmReportingCurrencyAmount(vendTrans.ReportingCurrencyAmount);
            this.insertTransactionList(
                tableNum(VendTrans),
                vendTrans.RecId,
                _subledgerVoucher,
                _accountingDate,
                SysModule::Vend,
                vendTrans.AccountNum,
                vendTrans.AmountMST,
                vendTrans.DefaultDimension,
                VendTable::Find(vendTrans.AccountNum).Name(),
                vendTrans.Txt,
                vendTrans.AmountCur,
                vendTrans.CurrencyCode,
                TaxCodeStringDefaultValue,
                vendTrans.Correct);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Caclcuates the tax amount in accounting currency based on accounting distribution and tax transaction.
    /// </summary>
    /// <param name = "_accountingDistribution">Accounting distribution record</param>
    /// <param name = "_taxTrans">Tax transaction record.</param>
    /// <param name = "_accountingDate">Accounting date.</param>
    /// <param name = "_exchangeRate">Exchange rate used to calculate accounting currency amount.</param>
    /// <returns>Tax amount in accounting currency.</returns>
    protected AmountMST getTaxAmountMST(AccountingDistribution _accountingDistribution,
										TaxTrans _taxTrans,
										AccountingDate _accountingDate,
										CurrencyExchangeRate _exchangeRate)
    {
        AmountMST amountMST;
		
		if (_accountingDistribution.RecId)
        {
			amountMST = CurrencyExchangeHelper::amountCur2MST(
														_accountingDistribution.TransactionCurrencyAmount, 
														_accountingDistribution.TransactionCurrency, 
														_exchangeRate, 
														_accountingDate);
        }
		else
        {
            amountMST = _taxTrans.netTaxAmountMST();
        }

		return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFixedExchRate</Name>
				<Source><![CDATA[
    internal protected ExchRate parmFixedExchRate(ExchRate _fixedExchRate = fixedExchRate)
    {
        fixedExchRate = _fixedExchRate;

        return fixedExchRate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>