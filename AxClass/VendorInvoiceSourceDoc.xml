<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VendorInvoiceSourceDoc</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>VendorInvoiceSourceDoc</c> class provides the information to handle the distributions and
/// subledger journal lines of a <c>VendInvoiceInfoTable</c> record that is generated from a vendor
/// invoice.
/// </summary>
[SourceDocumentEnumClassExtAttribute(enumStr(SourceDocument_VendorInvoice),
    SourceDocument_VendorInvoice::VendorInvoice, tableStr(VendInvoiceInfoTable)),
    SourceDocumentEnumClassExtAttribute(enumStr(SourceDocument_VendorInvoice),
    SourceDocument_VendorInvoice::VendorInvoice, tableStr(VendInvoiceJour))]
public class VendorInvoiceSourceDoc extends SourceDocument
    implements SourceDocumentIParty,
               SourceDocumentIChargeSource,
               SourceDocumentIDataProvider,
               SourceDocumentIAccountingRule,
               SourceDocumentIPostingJournalSeqProv,
               SourceDocumentIDiscount,
               SourceDocumentIEmpl_RU,
               SourceDocumentIReportingExchRate
{
    VendInvoiceMap vendInvoiceMap;
    VendInvoiceInfoTable vendInvoiceInfoTable;
    VendInvoiceJour vendInvoiceJour;
    boolean invoiceAccountFound;
    boolean calcTotals;
    VendTable invoiceAccount;
    MarkupTrans markupTrans;
    SourceDocumentLineTmpRelation sourceDocumentLineTmpRelation;
    // <GEERU>
    EmployeeId_RU emplId;
    boolean emplIdIsSet;
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createRelievingInvoiceLinesEarlyMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates relieving source document lines for a vendor invoice journal using product receipt quantity.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// The vendor invoice journal.
    /// </param>
    /// <returns>
    /// A <c>SourceDocumentLineTmpRelation</c> table filled with matching product receipt line relationships.
    /// </returns>
    /// <remarks>
    /// The updateRelievingInvoiceLinesFactor method must be called after this method to update the AllocationFactor field correctly.
    /// The createSourceDocumentLineRelievingAmount method must be called once after all relieving lines have been created to create the relieving amount records.
    /// This method does not relieve taxes.
    /// </remarks>
    private SourceDocumentLineTmpRelation createRelievingInvoiceLinesEarlyMatch(VendInvoiceJour _vendInvoiceJour)
    {
        VendPackingSlipTrans vendPackingSlipTrans;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        SourceDocumentLine vendInvoiceInfoLineSourceDocumentLine;
        // <GIN>
        CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink_IN;
        // </GIN>

        // <GIN>
        // When the default quantity for lines on invoice posting is set to Bill of entry quantity during Invoice.
        if (TaxParameters::isCustomsEnable_IN() 
            && CustomsVendBOEJour_IN::findFromPurchId(vendInvoiceMap.PurchId).RecId != 0 
            && vendInvoiceInfoTable.purchParmUpdate().SpecQty == PurchUpdate::BillOfEntryQuantity_IN)
        {
            insert_recordset sourceDocumentLineTmpRelation
            (
                DependentSourceDocumentLine,
                TermQuantity,
                IndependentSourceDocumentLine
            )
            select vendInvoiceInfoLineSourceDocumentLine
                where vendInvoiceInfoLineSourceDocumentLine.SourceDocumentHeader == _vendInvoiceJour.SourceDocumentHeader
            join SourceDocumentLine from vendInvoiceInfoLine
                where vendInvoiceInfoLine.SourceDocumentLine == vendInvoiceInfoLineSourceDocumentLine.RecId
            join ReceiveNow from vendInvoiceInfoSubLine
                where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
            join customsVendPackingSlipBOETransLink_IN
                where customsVendPackingSlipBOETransLink_IN.CustomsVendBOETrans_IN == vendInvoiceInfoSubLine.JournalRefRecId
            join SourceDocumentLine from vendPackingSlipTrans
                where vendPackingSlipTrans.RecId == customsVendPackingSlipBOETransLink_IN.VendPackingSlipTrans &&
                    vendInvoiceInfoSubLine.JournalRefTableId == tableNum(CustomsVendBOETrans_IN);
        }
        // </GIN>
        else
        {
            insert_recordset sourceDocumentLineTmpRelation
            (
                DependentSourceDocumentLine,
                TermQuantity,
                IndependentSourceDocumentLine
            )
            select vendInvoiceInfoLineSourceDocumentLine
                where vendInvoiceInfoLineSourceDocumentLine.SourceDocumentHeader == _vendInvoiceJour.SourceDocumentHeader
            join SourceDocumentLine from vendInvoiceInfoLine
                where vendInvoiceInfoLine.SourceDocumentLine == vendInvoiceInfoLineSourceDocumentLine.RecId
            join ReceiveNow from vendInvoiceInfoSubLine
                where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
            join SourceDocumentLine from vendPackingSlipTrans
                where vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId &&
                    vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans);
        }

        return sourceDocumentLineTmpRelation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRelievingInvoiceLinesLateMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates relieving source document lines for a vendor invoice journal using the ordered quantity.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// The vendor invoice journal.
    /// </param>
    /// <returns>
    /// A <c>SourceDocumentLineTmpRelation</c> table filled with matching product receipt line relationships.
    /// </returns>
    /// <remarks>
    /// The updateRelievingInvoiceLinesFactor method must be called after this method to update the AllocationFactor field correctly.
    /// This method does not relieve taxes.
    /// The createSourceDocumentLineRelievingAmount method must be called once after all relieving lines have been created to create the relieving amount records.
    /// </remarks>
    private SourceDocumentLineTmpRelation createRelievingInvoiceLinesLateMatch(VendInvoiceJour _vendInvoiceJour)
    {
        VendInvoicePackingSlipQuantityMatch vendInvoicePackingSlipQuantityMatch;
        VendInvoiceTrans vendInvoiceTrans;
        SourceDocumentLine vendInvoiceTransSourceDocumentLine;
        VendPackingSlipTrans vendPackingSlipTrans;
        SourceDocumentLineRelieving sourceDocumentLineRelieving;

        insert_recordset sourceDocumentLineTmpRelation 
        (
            DependentSourceDocumentLine,
            TermQuantity,                
            IndependentSourceDocumentLine
        )
        select vendInvoiceTransSourceDocumentLine
            where vendInvoiceTransSourceDocumentLine.SourceDocumentHeader == _vendInvoiceJour.SourceDocumentHeader
        join SourceDocumentLine from vendInvoiceTrans
            where vendInvoiceTrans.SourceDocumentLine == vendInvoiceTransSourceDocumentLine.RecId
        join Quantity from vendInvoicePackingSlipQuantityMatch
            where vendInvoicePackingSlipQuantityMatch.InvoiceSourceDocumentLIne == vendInvoiceTrans.SourceDocumentLine
        join SourceDocumentLine from vendPackingSlipTrans
            where vendPackingSlipTrans.SourceDocumentLine == vendInvoicePackingSlipQuantityMatch.PackingSlipSourceDocumentLine;
        
        return sourceDocumentLineTmpRelation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceDocumentLineMatchingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides matching product receipt line relationships.
    /// </summary>
    /// <param name = "_matchingInvoiceJour">
    /// The vendor invoice journal.
    /// </param>
    /// <returns>
    /// A <c>SourceDocumentLineTmpRelation</c> table filled with matching product receipt line relationships.
    /// </returns>
    public SourceDocumentLineTmpRelation createSourceDocumentLineMatchingList(VendInvoiceJour _matchingInvoiceJour)
    {
        // Early Match (vendInvoiceInfoSubLine) is created when the default quantity for lines on invoice posting is set to
        // Product receipt quantity or Receive Now quantity during invoice editing, prior to posting.
        // Late Match (VendInvoicePackingSlipQuantityMatch) is created during invoice posting.

        if (!vendInvoiceInfoTable)
        {
            vendInvoiceInfoTable = VendInvoiceInfoTable::findSourceDocumentHeader(_matchingInvoiceJour.SourceDocumentHeader);
        }

        if (vendInvoiceInfoTable.ProcessingAdvanced == NoYes::Yes)
        {
            // Product receipt relieving should not happen if posting a prepayment application
            sourceDocumentLineTmpRelation = null;
        }
        else
        {
            boolean hasMatchingQuantity = this.hasMatchingQuantity(_matchingInvoiceJour);

            if (hasMatchingQuantity)
            {
                sourceDocumentLineTmpRelation = this.createRelievingInvoiceLinesLateMatch(_matchingInvoiceJour);
            }
            else
            {
                // Create relieving information based on early matching information when late match info is not available (ex: before invoice posting)
                sourceDocumentLineTmpRelation = this.createRelievingInvoiceLinesEarlyMatch(_matchingInvoiceJour);
            }
        }

        return sourceDocumentLineTmpRelation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMatchingQuantity</Name>
				<Source><![CDATA[
    private boolean hasMatchingQuantity(VendInvoiceJour _matchingInvoiceJour)
    {
        VendInvoicePackingSlipQuantityMatch vendInvoicePackingSlipQuantityMatch;
        VendPackingSlipTrans vendPackingSlipTrans;
        VendInvoiceTrans vendInvoiceTrans;
        SourceDocumentLine vendInvoiceTransSourceDocumentLine;

        boolean hasMatchingQuantity;

        select firstonly RecId from vendInvoiceTransSourceDocumentLine
            where vendInvoiceTransSourceDocumentLine.SourceDocumentHeader == _matchingInvoiceJour.SourceDocumentHeader
        exists join vendInvoiceTrans
            where vendInvoiceTrans.SourceDocumentLine == vendInvoiceTransSourceDocumentLine.RecId
        exists join vendInvoicePackingSlipQuantityMatch
            where vendInvoicePackingSlipQuantityMatch.InvoiceSourceDocumentLIne == vendInvoiceTrans.SourceDocumentLine
        exists join vendPackingSlipTrans
            where vendPackingSlipTrans.SourceDocumentLine == vendInvoicePackingSlipQuantityMatch.PackingSlipSourceDocumentLine;

        if (vendInvoiceTransSourceDocumentLine.RecId)
        {
            hasMatchingQuantity = true;
        }

        return hasMatchingQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchingVendorInvoiceJournal</Name>
				<Source><![CDATA[
    private VendInvoiceJour getMatchingVendorInvoiceJournal()
    {
        VendInvoiceJour matchingInvoiceJour;

        if (vendInvoiceMap.TableId == tableNum(VendInvoiceJour))
        {
            matchingInvoiceJour = vendInvoiceJour;
        }
        else
        {
            matchingInvoiceJour = VendInvoiceJour::findSourceDocumentHeader(vendInvoiceInfoTable.SourceDocumentHeader);
        }

        return matchingInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentRelationMatchingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides matching product receipt line relationships.
    /// </summary>
    /// <returns>
    /// A <c>SourceDocumentLineTmpRelation</c> table filled with matching product receipt line relationships.
    /// </returns>
    public SourceDocumentLineTmpRelation getSourceDocumentRelationMatchingList()
    {
        VendInvoiceJour matchingInvoiceJour;

        matchingInvoiceJour = this.getMatchingVendorInvoiceJournal();

        // Non-posted logic takes a different path for preview purposes
        if (matchingInvoiceJour)
        {
            this.createSourceDocumentLineMatchingList(matchingInvoiceJour);
        }

        return sourceDocumentLineTmpRelation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentsBusinessEvent</Name>
				<Source><![CDATA[
    public BusinessEvent documentsBusinessEvent()
    {
        return new BusinessEvent(enumNum(BusinessEvent_VendorInvoice),BusinessEvent_VendorInvoice::VendorPaymentRequestForExpensedProducts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceAccount</Name>
				<Source><![CDATA[
    protected VendTable getInvoiceAccount()
    {
        if (!invoiceAccountFound)
        {
            invoiceAccount = vendInvoiceMap.vendTable_InvoiceAccount();
            invoiceAccountFound = true;
        }

        return invoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucherSeriesNumberSequence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides posting journal number sequence code, currently used for Belgian
    /// </summary>
    /// <param name="company">
    /// The company ID needed to get the country code.
    /// </param>
    /// <returns>
    /// The number sequence code either for credit or debit depending on the total of line amount of this
    /// doc.
    /// </returns>
    public NumberSequenceCode getVoucherSeriesNumberSequence(CompanyId company)
    {
        #ISOCountryRegionCodes
        NumberSequenceCode voucherSeries;
        NumberSequenceReference numberSequenceRefInvoice;
        NumberSequenceReference numberSequenceRefVoucher;
        NumberSequenceTable numberSequenceTableInvoice;
        NumberSequenceTable numberSequenceTableVoucher;
        NumberSequenceDatatype invoiceDatatype;
        NumberSequenceDatatype voucherDatatype;
        SourceDocumentAmountList sdlist;
        SourceDocumentAmount sdtotal;
        SourceDocumentAmountListEnumerator sdListEnumerator;
        SourceDocumentLineItemITax sdLineTaxItem;
        Amount totalAmount, lineAmount;
        RefRecId invoiceNumberId;
        RefRecId invoiceVoucherId;
        RefRecId scopeId = NumberSeqScopeFactory::createDefaultScope().getId();
        NumberSequenceGroupId numberSequenceGroupId;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE], company))
        {
            return voucherSeries;
        }

        // generic sd way to get total.
        sdlist = this.parmSourceDocumentAmountList();
        sdListEnumerator = this.parmSourceDocumentAmountList().getEnumerator();

        while (sdListEnumerator.moveNext())
        {
            sdtotal = sdListEnumerator.current();
            lineAmount = sdtotal.parmAmount();
            if (sdtotal.parmIsTaxAmount())
            {
                sdLineTaxItem = SourceDocumentLineItem::newFromSourceDocumentLine(sdtotal.parmSourceDocumentLine()) as SourceDocumentLineItemITax;
                Debug::assert(sdLineTaxItem != null); // because it is tax Amount
                if (sdLineTaxItem.parmTaxDirection() == TaxDirection::OutgoingTax)
                {
                    lineAmount = lineAmount * -1;
                }
            }

            totalAmount += lineAmount;
        }

        if (totalAmount > 0)
        {
            // not a credit note.
            numberSequenceRefInvoice = NumberSeqReference::findReference(extendedTypeNum(PurchInternalInvoiceId)); // Internal Invoice
            numberSequenceRefVoucher = NumberSeqReference::findReference(extendedTypeNum(PurchInvoiceVoucher)); // invoice voucher
        }
        else
        {
            // a credit note
            numberSequenceRefInvoice = NumberSeqReference::findReference(extendedTypeNum(PurchInternalCreditNoteId)); // internal credcit note
            numberSequenceRefVoucher = NumberSeqReference::findReference(extendedTypeNum(PurchCreditNoteVoucher)); // credit note voucher
        }

        numberSequenceTableInvoice = NumberSequenceTable::find(numberSequenceRefInvoice.NumberSequenceId);
        numberSequenceTableVoucher = NumberSequenceTable::find(numberSequenceRefVoucher.NumberSequenceId);
        invoiceDatatype = NumberSequenceDatatype::find(numberSequenceRefInvoice.NumberSequenceDatatype);
        voucherDatatype = NumberSequenceDatatype::find(numberSequenceRefVoucher.NumberSequenceDatatype);

        VendInvoiceJour vendInvoiceJourLocal = this.getMatchingVendorInvoiceJournal();
        numberSequenceGroupId = (vendInvoiceJourLocal.NumberSequenceGroup) ?
            vendInvoiceJourLocal.NumberSequenceGroup :
            this.getInvoiceAccount().NumberSequenceGroup;

        if (numberSequenceGroupId)
        {
            invoiceNumberId = NumberSequenceGroupRef::findNaturalKey(invoiceDatatype.RecId, scopeId, numberSequenceGroupId).NumberSequenceId;

            if (!invoiceNumberId)
            {
               invoiceNumberId = numberSequenceRefInvoice.NumberSequenceId;
            }

            if (numberSequenceRefVoucher.AllowSameAs)
            {
                invoiceVoucherId = invoiceNumberId;
            }
            else
            {
                invoiceVoucherId = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, numberSequenceGroupId).NumberSequenceId;

                if (!invoiceVoucherId)
                {
                    invoiceVoucherId = numberSequenceRefVoucher.NumberSequenceId;
                }
            }
            voucherSeries = NumberSequenceTable::find(invoiceVoucherId).NumberSequence;
        }
        else
        {
            if (numberSequenceRefVoucher.AllowSameAs && voucherDatatype.DataTypeSameAsId == invoiceDatatype.DatatypeId)
            {
                numberSequenceTableVoucher = numberSequenceTableInvoice;
            }
             voucherSeries = numberSequenceTableVoucher.NumberSequence;
        }

        return voucherSeries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>VendorInvoiceSource</c> class.
    /// </summary>
    /// <param name="_sourceDocumentImplementation">
    /// A source document implementation table.
    /// </param>
    protected void initializeImplementation(SourceDocumentHeaderImplementation _sourceDocumentImplementation)
    {
        if (_sourceDocumentImplementation.TableId == tableNum(VendInvoiceInfoTable))
        {
            vendInvoiceInfoTable = _sourceDocumentImplementation;
            vendInvoiceMap = vendInvoiceInfoTable;
        }
        else if (_sourceDocumentImplementation.TableId == tableNum(VendInvoiceJour))
        {
            vendInvoiceJour = _sourceDocumentImplementation;
            vendInvoiceMap = vendInvoiceJour;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate()
    {
        TransDate settlementDate;

        if (vendInvoiceMap.TableId == tableNum(VendInvoiceJour))
        {
            settlementDate = this.getAccountingDateFromVendAdvanceApplicationTrans();
        }

        if (settlementDate == dateNull())
        {
            settlementDate = vendInvoiceMap.VendInvoiceMap::documentDate();
        }

        return settlementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDateFromVendAdvanceApplicationTrans</Name>
				<Source><![CDATA[
    private TransDate getAccountingDateFromVendAdvanceApplicationTrans()
    {
        TransDate settlementDate;
        
        VendAdvanceApplicationTransQueryBuilder qb = VendAdvanceApplicationTransQueryBuilder::construct();
        qb.parmInvoiceRecId(vendInvoiceMap.RecId);
        qb.parmIsPosted(true);

        Query q = qb.buildQuery();

        QueryBuildDataSource qbds = q.dataSourceTable(tableNum(VendAdvanceApplicationTrans));
        qbds.fields().clearFieldList();
        qbds.addSelectionField(fieldNum(VendAdvanceApplicationTrans, SettlementPostingDate));
        qbds.addRange(fieldNum(VendAdvanceApplicationTrans, SettlementPostingDate)).value(SysQuery::valueNot(dateNull()));

        QueryRun qr = new QueryRun(q);
        qr.next();

        VendAdvanceApplicationTrans vendAdvanceApplicationTrans = qr.get(tableNum(VendAdvanceApplicationTrans));

        if (vendAdvanceApplicationTrans)
        {
            settlementDate = vendAdvanceApplicationTrans.SettlementPostingDate;
        }

        return settlementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalcTotals</Name>
				<Source><![CDATA[
    public boolean parmCalcTotals(boolean _calcTotals = calcTotals)
    {
        calcTotals = _calcTotals;
        return calcTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeInputAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the document input amount for the charges and other totals
    /// </summary>
    /// <returns>Input amount for the charge calculation as that determine whether the transaction is a credit note or invoice ledger</returns>
    public Amount parmChargeInputAmount()
    {
        PurchTotals purchTotals;
        Amount chargeInputAmount;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;

        if (markupTrans == null && !calcTotals)
        {
            chargeInputAmount = 0;
        }
        else if (vendInvoiceMap.TableId == tableNum(VendInvoiceInfoTable))
        {
            VendInvoiceInfoTable localVendInvoiceInfoTable = vendInvoiceMap;

            //Check whether we can get PurchTotals from the <c>VendInvoiceTotalAccountingDistributionSum</c> view
            VendInvoiceTotalAccountingDistributionSum vendInvoiceTotalAccountingDistributionSum;

            select firstonly InvoiceTotal from vendInvoiceTotalAccountingDistributionSum
                where vendInvoiceTotalAccountingDistributionSum.ParmId == localVendInvoiceInfoTable.ParmId &&
                    vendInvoiceTotalAccountingDistributionSum.TableRefId == localVendInvoiceInfoTable.TableRefId &&
                    vendInvoiceTotalAccountingDistributionSum.VendInvoiceInfoTableDataAreaId == localVendInvoiceInfoTable.DataAreaId;

            if (vendInvoiceTotalAccountingDistributionSum)
            {
                return vendInvoiceTotalAccountingDistributionSum.InvoiceTotal;
            }

            purchTotals = PurchTotals::newParmTable(localVendInvoiceInfoTable,
                                                    PurchUpdate::All,
                                                    localVendInvoiceInfoTable.ParmId,
                                                    '',
                                                    localVendInvoiceInfoTable.Ordering);
            purchTotals.calc(true);

            if (markupTrans.TransTableId == vendInvoiceInfoSubTable.TableId)
            {
                vendInvoiceInfoSubTable = VendInvoiceInfoSubTable::findRecId(markupTrans.TransRecId);

                return purchTotals.purchOrderBalance(vendInvoiceInfoSubTable.TableId, vendInvoiceInfoSubTable.RecId);
            }

            chargeInputAmount = purchTotals.purchBalance();
        }
        else
        {
            chargeInputAmount = vendInvoiceJour.SalesBalance;
        }

        return chargeInputAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeQuantity</Name>
				<Source><![CDATA[
    public Qty parmChargeQuantity()
    {
        return 0; // a Piece charge MarkupTrans on the header must be allocated down to the lines prior to distributing.
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeSource</Name>
				<Source><![CDATA[
    public Common parmChargeSource(Common _markupTrans = markupTrans)
    {
        markupTrans = _markupTrans;
        return markupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompletedSourceRelationType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the table Id which owns the source document after completion/posting.
    /// </summary>
    /// <returns>
    /// The table Id which owns the source document after completion/posting.
    /// </returns>
    public TableId parmCompletedSourceRelationType()
    {
        return tableNum(VendInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrentVoucher</Name>
				<Source><![CDATA[
    public Voucher parmCurrentVoucher(DataAreaId _dataAreaId)
    {
        Voucher localVoucher;

        SourceDocumentLineRecId sourceDocumentLineRecId = this.findSourceDocumentLineRecIdForCurrentVoucher();
        if (sourceDocumentLineRecId)
        {
            localVoucher =  this.findCurrentVoucherFromSourceDocumentLineRecId(sourceDocumentLineRecId);
        }
        else
        {
            localVoucher = vendInvoiceMap.ledgerVoucher();
        }

        return localVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSourceDocumentLineRecIdForCurrentVoucher</Name>
				<Source><![CDATA[
    private SourceDocumentLineRecId findSourceDocumentLineRecIdForCurrentVoucher()
    {
        SourceDocumentLineRecId sourceDocumentLineRecId;

        if (sourceDocumentLinesForCurrentVoucher && !sourceDocumentLinesForCurrentVoucher.empty())
        {
            MapEnumerator lineEnumerator = sourceDocumentLinesForCurrentVoucher.getEnumerator();

            while (lineEnumerator.moveNext())
            {
                if (lineEnumerator.currentValue() is VendorInvoiceLineSourceDocLineItem)
                {
                    sourceDocumentLineRecId = lineEnumerator.currentKey();
                    break;
                }
            }
        }

        return sourceDocumentLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCurrentVoucherFromSourceDocumentLineRecId</Name>
				<Source><![CDATA[
    private Voucher findCurrentVoucherFromSourceDocumentLineRecId(SourceDocumentLineRecId _sourceDocumentLineRecId)
    {
        Voucher localVoucher;
        VendInvoiceTrans vendInvoiceTrans;
        SourceDocumentLine sourceDocumentLine;

        select firstonly AdvanceApplicationId, InternalInvoiceId from vendInvoiceTrans
            where vendInvoiceTrans.SourceDocumentLine == _sourceDocumentLineRecId
            join sourceDocumentLine
                where sourceDocumentLine.RecId == vendInvoiceTrans.SourceDocumentLine
                    && sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed;

        if (vendInvoiceTrans.AdvanceApplicationId)
        {
            localVoucher = vendInvoiceTrans.InternalInvoiceId;
        }
        else
        {
            localVoucher = this.getMatchingVendorInvoiceJournal().ledgerVoucher;
        }

        return localVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault parmDefaultDimension()
    {
        return vendInvoiceMap.VendInvoiceMap::defaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscCode</Name>
				<Source><![CDATA[
    public DiscCode parmDiscCode()
    {
        return vendInvoiceMap.VendInvoiceMap::cashDiscCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmDiscDataAreaId()
    {
        DataAreaId dataAreaId;

        if (vendInvoiceMap.VendInvoiceMap::cashDiscCode())
        {
            dataAreaId = vendInvoiceMap.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscDirection</Name>
				<Source><![CDATA[
    public int parmDiscDirection()
    {
        return DiscountDirection::Received;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributionTemplateRecId</Name>
				<Source><![CDATA[
    public AccountingDistributionTemplateRecId parmDistributionTemplateRecId()
    {
        return vendInvoiceMap.accDistributionTemplateRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentDate</Name>
				<Source><![CDATA[
    public DocumentDate parmDocumentDate()
    {
        return vendInvoiceMap.DocumentDate ? vendInvoiceMap.DocumentDate : vendInvoiceMap.InvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentNumber</Name>
				<Source><![CDATA[
    public DocumentNum parmDocumentNumber()
    {
        return vendInvoiceMap.InvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmplId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the Employee Id for the source document.
    /// </summary>
    /// <returns>
    /// The Employee Id for the source document.
    /// </returns>
    public EmployeeId_RU parmEmplId()
    {
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        #EECountryRegionCodes

        if (!emplIdIsSet)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
            {
                if (vendInvoiceMap.TableId == tableNum(VendInvoiceInfoTable))
                {
                    localVendInvoiceInfoTable = vendInvoiceMap;

                    emplId = localVendInvoiceInfoTable.vendInvoiceInfoTable_W().EmplAccount_RU;
                }

                if (!emplId && vendInvoiceMap.PurchId)
                {
                    emplId = PurchTable::find(vendInvoiceMap.PurchId).purchTable_W().EmplAccount_RU;
                }
            }

            emplIdIsSet = true;
        }

        return emplId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmplPostingProfile</Name>
				<Source><![CDATA[
    public EmplPostingProfile_RU parmEmplPostingProfile()
    {
        return EmplParameters_RU::find().PostingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate1</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate1()
    {
        return vendInvoiceMap.ExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate2</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate2()
    {
        return vendInvoiceMap.ExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchangeRate1</Name>
				<Source><![CDATA[
    public ReportingCurrencyExchRate parmReportingCurrencyExchangeRate1()
    {
        return vendInvoiceMap.VendInvoiceMap::parmReportingCurrencyExchangeRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCorrection</Name>
				<Source><![CDATA[
    public boolean parmIsCorrection()
    {
        if (vendInvoiceMap.TableId != tableNum(VendInvoiceInfoTable))
        {
            return false;
        }

        if (!LedgerParameters::findByCompany(curext()).TransactionReversalCorrection)
        {
            return false;
        }

        NoYes isCorrection;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            isCorrection = PurchParmUpdate::find(vendInvoiceInfoTable.ParmId).Storno;
        }
        else
        {
            isCorrection = vendInvoiceInfoTable.creditCorrection();
        }

        return isCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDocumentEditable</Name>
				<Source><![CDATA[
    public boolean parmIsDocumentEditable()
    {
        if (vendInvoiceMap.isAdvance())
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsStornoForReversal_RU</Name>
				<Source><![CDATA[
    public boolean parmIsStornoForReversal_RU()
    {
        if (vendInvoiceMap.TableId != tableNum(VendInvoiceInfoTable))
        {
            return false;
        }

        return LedgerParameters::findByCompany(curext()).TransactionReversalCorrection
            && PurchParmUpdate::find(vendInvoiceInfoTable.ParmId).StornoPhysical_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxInChargeInputAmountIncluded</Name>
				<Source><![CDATA[
    public boolean parmIsTaxInChargeInputAmountIncluded()
    {
        return vendInvoiceMap.isInclTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPartyAccount</Name>
				<Source><![CDATA[
    public Common parmPartyAccount()
    {
        return this.getInvoiceAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermId</Name>
				<Source><![CDATA[
    public PaymTermId parmPaymTermId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingProfile</Name>
				<Source><![CDATA[
    public PostingProfile parmPostingProfile()
    {
        return vendInvoiceMap.VendInvoiceMap::postingProfile();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantity</Name>
				<Source><![CDATA[
    public Qty parmQuantity()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>TransactionTxt</c> and populates it with the appropriate
    /// data.
    /// </summary>
    /// <returns>
    /// A string value representing the transaction text for the document.
    /// </returns>
    /// <remarks>
    /// If there is no user-defined default text, the text defaults from the parent
    /// class <c>SourceDocument</c>.
    /// </remarks>
    public str parmTransactionText()
    {
        TransactionTxt transactionTxt = TransactionTxt::construct();
        str ret;
        VendInvoiceJour vendInvoiceJourLocal;
        VendInvoiceInfoTable vendInvoiceInfoTableLocal;
        LedgerTransTxt ledgerTransTxt;
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;
        Num docNum;

        this.parmCalcTotals(true);

        // Determine the transaction text type
        if (this.parmChargeInputAmount() < 0)
        {
            transactionTxt.setType(LedgerTransTxt::PurchCreditNoteLedger);
            ledgerTransTxt = LedgerTransTxt::PurchCreditNoteLedger;
        }
        else
        {
            transactionTxt.setType(LedgerTransTxt::PurchInvoiceLedger);
            ledgerTransTxt = LedgerTransTxt::PurchInvoiceLedger;
        }

        transactionTxt.setDate(this.parmAccountingDate());
        transactionTxt.setFormLetter(vendInvoiceMap.InvoiceId);
        transactionTxt.setVoucher(this.parmCurrentVoucher(vendInvoiceMap.DataAreaId));
        transactionTxt.setKey1(vendInvoiceMap.PurchId);
        transactionTxt.setKey2(vendInvoiceMap.InvoiceAccount);
        transactionTxt.setKey3(VendTable::groupId(vendInvoiceMap.InvoiceAccount));
        transactionTxt.setLanguage(currentUserLanguage());

        if (TransactionTextContext::isTypeSupported(ledgerTransTxt))
        {
            switch (vendInvoiceMap.TableId)
            {
                case tableNum(VendInvoiceInfoTable):
                vendInvoiceInfoTableLocal = vendInvoiceMap;
                vendInvoiceJourLocal = VendInvoiceJour::findSourceDocumentHeader(vendInvoiceInfoTableLocal.SourceDocumentHeader);
                break;

                case tableNum(VendInvoiceJour):
                vendInvoiceJourLocal = vendInvoiceMap;
                break;
            }

            // Only consider buffers that are VendInvoiceJour
            if (vendInvoiceJourLocal is VendInvoiceJour)
            {
                TransactionTextContext transactionTextContext = this.constructContextForTransactionText(ledgerTransTxt, vendInvoiceJourLocal);
                transactionTxt.setTransactionTextContext(transactionTextContext);
            }
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            transactionTxt.setCustVendName(VendTable::find(vendInvoiceMap.InvoiceAccount).customerAccountName());

            docNum = vendInvoiceJourLocal.InvoiceId;

            if (vendInvoiceInfoTableLocal && vendInvoiceInfoTableLocal.hasToIssueFiscalDocument_BR())
            {
                vendInvoiceInfoTable_W = vendInvoiceInfoTableLocal.vendInvoiceInfoTable_W();
                docNum = FiscalDocument_BR::getInvoiceIdWithoutSeriesPrefix(vendInvoiceJourLocal.InvoiceId, vendInvoiceInfoTable_W.FiscalDocumentSeries_BR);
            }

            transactionTxt.setFormLetter(docNum);
        }
        // </GBR>

        ret = transactionTxt.txt();
        this.parmCalcTotals(false);

        // If no default text is defined, use default from SourceDocument
        if (!ret)
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendInvoiceMap</Name>
				<Source><![CDATA[
    public VendInvoiceMap parmVendInvoiceMap()
    {
        return vendInvoiceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrievedSourceDocTypeInfoEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handler for the <c>retrievedSourceDocTypeInfo</c> event.
    /// </summary>
    /// <param name="_sourceDocumentTmpTypeInformation">
    /// A <c>SourceDocumentTmpTypeInformation</c> table buffer.
    /// </param>
    /// <param name="_caller">
    /// The name of the caller.
    /// </param>
    [SubscribesTo(classstr(SourceDocumentTypeInformation),
                  delegatestr(SourceDocumentTypeInformation, retrievedSourceDocTypeInfoEventHandler))]
    public static void retrievedSourceDocTypeInfoEventHandler(SourceDocumentTmpTypeInformation _sourceDocumentTmpTypeInformation, str _caller)
    {
        if (SourceDocumentTypeInformation::isCallerSubledgerJournalTransferRelated(_caller))
        {
            // remove unposted vendor invoices
            delete_from _sourceDocumentTmpTypeInformation
                where _sourceDocumentTmpTypeInformation.ClassId == classNum(VendorInvoiceSourceDoc) &&
                    _sourceDocumentTmpTypeInformation.SourceRelationType == tableNum(VendInvoiceInfoTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceDocumentLinesForTermQuantityChange</Name>
				<Source><![CDATA[
    public void updateSourceDocumentLinesForTermQuantityChange()
    {
        SourceDocumentLine localSourceDocumentline;
        VendInvoiceTrans localVendInvoiceTrans;

        update_recordset localSourceDocumentline
            setting TermQuantity = localVendInvoiceTrans.Qty
            join localVendInvoiceTrans
            where localVendInvoiceTrans.SourceDocumentLine == localSourceDocumentline.RecId
                && localSourceDocumentLine.SourceDocumentHeader == vendInvoiceJour.SourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesCurrentExecutionContextSupportParallelProcessing</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean doesCurrentExecutionContextSupportParallelProcessing()
    {
        VendorInvoiceProcessContext invoiceProcessContext = VendorInvoiceProcessContext::instance();

        return !invoiceProcessContext.parmIsWorkflowEventInProcess() && invoiceProcessContext.parmDoesContextSupportsParallelLineProcessing();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructContextForTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>TransactionTextContext</c> class instance given a <c>LedgerTransTxt</c> class instance and a <c>VendInvoiceJour</c> table buffer.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    /// The <c>LedgerTransTxt</c> enumeration type representing the specified transaction type that will be used to create the <c>TransactionTextContext</c> instance.
    /// </param>
    /// <param name="_vendInvoiceJour">
    /// A <c>VendInvoiceJour</c> table buffer.
    /// </param>
    /// <returns>
    /// <c>TransactionTextContext</c> class instance.
    /// </returns>
    protected TransactionTextContext constructContextForTransactionText(LedgerTransTxt _ledgerTransTxt, VendInvoiceJour _vendInvoiceJour)
    {
        TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_ledgerTransTxt);
        transactionTextContext.setTableBuffer(_vendInvoiceJour);
        transactionTextContext.setTableBuffer(_vendInvoiceJour.purchTable());

        return transactionTextContext;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>