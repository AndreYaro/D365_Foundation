<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PaymCalendarProcessor</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>PaymCalendarProcessor</c> class manages due date adjustments for payment calendars.
/// </summary>
public class PaymCalendarProcessor
{
    private const int CalendarBitmapSize = 12; // Count of Int's in the bitmap
    private const int BitsInInt = 32; // Number of bits in an Int

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date so that it falls on a business day per specified calendar source.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_paymCalendarDerivationSource">
    /// An interface that provides the information that is required to retrieve the payment calendar.
    /// </param>
    /// <returns>
    /// The adjusted due date.
    /// </returns>
    /// <remarks>
    /// If no adjustment is needed, the original date is returned.
    /// </remarks>
    public DueDate adjustDate(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, PaymCalendarIDerivationSource _paymCalendarDerivationSource)
    {
        DueDate adjustedDate;
        PaymCalendarFindCalendarResults calendar;

        // Validate input parameters
        if (!_paymCalendarDerivationSource)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        Debug::assert(_updatePolicy != PaymentDueDateUpdatePolicy::NoUpdate);

        calendar = this.findPaymCalendar(_paymCalendarDerivationSource);

        adjustedDate = this.calculateAdjustedDate(_dueDate, _updatePolicy, calendar);

        return adjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDateForCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date so that it falls on a business day per specified calendar.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_calendar">
    /// A class that specifies the payment calendar.
    /// </param>
    /// <returns>
    /// The adjusted due date.
    /// </returns>
    /// <remarks>
    /// If no adjustment is needed, the original date is returned.
    /// </remarks>
    public DueDate adjustDateForCalendar(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, PaymCalendarFindCalendarResults _calendar)
    {
        DueDate adjustedDate;

        // Validate input parameters
        if (!_calendar)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        adjustedDate = this.calculateAdjustedDate(_dueDate, _updatePolicy, _calendar);

        return adjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAdjustedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date based on the found calendar with the result saved in a class variable.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_calendar">
    /// A class that specifies the payment calendar.
    /// </param>
    /// <returns>
    /// The adjusted due date.
    /// </returns>
    /// <remarks>
    /// The <c>findPaymCalendar</c> method must be called before invoking this method.
    /// </remarks>
    private DueDate calculateAdjustedDate(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, PaymCalendarFindCalendarResults _calendar)
    {
        PaymCalendarBitmap paymCalendarBitmap;
        boolean isAdjustedDateFound;
        DueDate adjustedDate;

        adjustedDate = _dueDate;

        if (_calendar.parmPaymCalendar().RecId)
        {
            isAdjustedDateFound = false;

            while (!isAdjustedDateFound)
            {
                // Setup calendar bitmap for seeking in the year
                paymCalendarBitmap = this.getCalendarBitmap(adjustedDate, _updatePolicy, _calendar.parmPaymCalendar(), _calendar.parmPostalAddress(), _calendar.parmIncludeStateHoliday());

                isAdjustedDateFound = paymCalendarBitmap.seekNearestBusinessDay();
                adjustedDate = paymCalendarBitmap.parmAdjustedDate();
            }
        }

        return adjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHolidayCalendarBitmap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a bitmap representing the holidays for the specified calendar, year, state and city.
    /// </summary>
    /// <param name="_paymCalendarId">
    /// The record ID of the <c>PaymCalendar</c> record of the payment calendar associated to the state and
    /// city holidays.
    /// </param>
    /// <param name="_year">
    /// The specific year for the calendar.
    /// </param>
    /// <param name="_state">
    /// The record ID of the <c>LogisticsAddressState</c> record that specifies the state holidays.
    /// </param>
    /// <param name="_city">
    /// The record ID of the <c>LogisticsAddresssCity</c> record that specifies the city holidays.
    /// </param>
    /// <returns>
    /// A container that contains a bitmap wherein the bits that correspond to holidays are set to false.
    /// </returns>
    private container createHolidayCalendarBitmap(PaymCalendarRecId _paymCalendarId, int _year, LogisticsAddressStateRecId _state, LogisticsAddressCityRecId _city)
    {
        CityHoliday cityHoliday;
        StateHoliday stateHoliday;
        LogisticsAddressCity logisticsAddressCity;
        LogisticsAddressState logisticsAddressState;
        LogisticsAddressCountryRegion logisticsAddressCountryRegion;
        PaymCalendarCountryRegion paymCalendarCountryRegion;
        container bitmapContainer;
        int i;
        int holidays[CalendarBitmapSize];
        date firstDayInYear;
        date lastDayInYear;
        int holiday;
        int dayMaskLocal;
        int holidaysIndex;

        PreferredLocale locale = new xSession().preferredLocale();

        // Init holidays (all days are intially business days)
        for (i = 1; i <= CalendarBitmapSize; i++)
        {
            holidays[i] = -1;
        }

        // Remove state holidays from map
        paymCalendarCountryRegion = PaymCalendarCountryRegion::findByPaymCalendar(_paymCalendarId);
        if (PaymCalendarCountryRegion.RecId)
        {
            // Init {firstDayInYear, lastDayInYear}
            firstDayInYear = mkDate(1, 1, _year);
            lastDayInYear = DateTimeUtil::getEndOfYearDate(locale, firstDayInYear);

            while select HolidayDate from stateHoliday
                where stateHoliday.State == _state
                exists join logisticsAddressState
                    where logisticsAddressState.RecId == stateHoliday.State
                exists join logisticsAddressCountryRegion
                    where logisticsAddressCountryRegion.RecId == paymCalendarCountryRegion.CountryRegion
                        && logisticsAddressCountryRegion.CountryRegionId == logisticsAddressState.CountryRegionId
            {
                // Init mask
                holiday = dayOfYr(stateHoliday.HolidayDate);
                holidaysIndex = PaymCalendarProcessor::getBitmapIndex(holiday);
                dayMaskLocal = 0x00000001 << (PaymCalendarProcessor::getBitPosition(holiday) - 1);

                // Clear day in bitmap
                dayMaskLocal = ~dayMaskLocal;
                holidays[holidaysIndex] = holidays[holidaysIndex] & dayMaskLocal;
            }

            while select HolidayDate from cityHoliday
                where cityHoliday.City == _city
                exists join logisticsAddressCity
                    where logisticsAddressCity.RecId == cityHoliday.City
                exists join logisticsAddressCountryRegion
                    where logisticsAddressCountryRegion.RecId == paymCalendarCountryRegion.CountryRegion
                        && logisticsAddressCountryRegion.CountryRegionId == logisticsAddressCity.CountryRegionId
            {
                // Init mask
                holiday = dayOfYr(cityHoliday.HolidayDate);
                holidaysIndex = PaymCalendarProcessor::getBitmapIndex(holiday);
                dayMaskLocal = 0x00000001 << (PaymCalendarProcessor::getBitPosition(holiday) - 1);

                // Clear day in bitmap
                dayMaskLocal = ~dayMaskLocal;
                holidays[holidaysIndex] = holidays[holidaysIndex] & dayMaskLocal;
            }
        }

        bitmapContainer = [holidays];

        return bitmapContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRuleList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an ordered list of rules for the specified values.
    /// </summary>
    /// <param name="_legalEntity">
    /// The record ID that specifies the legal entity.
    /// </param>
    /// <param name="_moduleType">
    /// The module type of the rules to be retrieved.
    /// </param>
    /// <returns>
    /// A list that contains the rules ordered by how they must be applied.
    /// </returns>
    /// <remarks>
    /// The list contains objects of type <c>PaymCalendarSpecificRule</c> ,
    /// <c>PaymCalendarThirdPartyLocationRule</c> , or <c>PaymCalendarLegalEntityLocationRule</c> .
    /// </remarks>
    private List createRuleList(DataAreaId _dataAreaId, PaymCalendarModuleType _moduleType)
    {
        PaymCalendarRule paymCalendarRule;
        PaymCalendarCriteriaRule paymCalendarCriteriaRule;
        PaymCalendarEvaluationPriority paymCalendarEvaluationPriority;
        LogisticsPostalAddress logisticsPostalAddressLocal;
        CompanyInfo companyInfo;
        PaymCalendarRecId paymCalendarRecId;
        PaymTermId paymTerm;
        PaymMode paymMode;
        List ruleList;
        boolean includeStateHolidayLocal;

        ruleList = new List(Types::Class);

        changecompany(_dataAreaId)
        {
            while select paymCalendarRule
                order by paymCalendarRule.Priority
                where paymCalendarRule.ModuleType == _moduleType
                    && paymCalendarRule.IsActive == NoYes::Yes
            {
                switch (paymCalendarRule.RuleType)
                {
                    case PaymCalendarRuleType::Specific:
                        paymCalendarCriteriaRule = paymCalendarRule as PaymCalendarCriteriaRule;
                        paymCalendarRecId = paymCalendarCriteriaRule.PaymCalendar;
                        paymTerm = paymCalendarCriteriaRule.PaymTerm;

                        if (_moduleType == PaymCalendarModuleType::Customer)
                        {
                            paymMode = paymCalendarCriteriaRule.CustomerPaymMode;
                        }
                        else
                        {
                            paymMode = paymCalendarCriteriaRule.VendorPaymMode;
                        }

                        ruleList.addEnd(PaymCalendarSpecificRule::construct(paymCalendarRecId, paymTerm, paymMode, paymCalendarRule.RecId));
                        break;

                    case PaymCalendarRuleType::ThirdPartyLocation:
                        while select AddressProcess from paymCalendarEvaluationPriority
                            order by paymCalendarEvaluationPriority.Priority
                            where paymCalendarEvaluationPriority.PaymCalendarRule == paymCalendarRule.RecId
                        {
                            ruleList.addEnd(PaymCalendarThirdPartyLocationRule::construct(paymCalendarEvaluationPriority.AddressProcess, paymCalendarRule.RecId));
                        }
                        break;

                    case PaymCalendarRuleType::LegalEntityLocation:
                        paymCalendarRecId = 0;
                        includeStateHolidayLocal = false;
                        companyInfo = CompanyInfo::findDataArea(_dataAreaId);
                        logisticsPostalAddressLocal = companyInfo.postalAddress();

                        if (logisticsPostalAddressLocal.CountryRegionId)
                        {
                            [paymCalendarRecId, includeStateHolidayLocal] = PaymCalendarProcessor::getCalendarForLocation(_dataAreaId, _moduleType, logisticsPostalAddressLocal.CountryRegionId);
                        }

                        ruleList.addEnd(PaymCalendarLegalEntityLocationRule::construct(logisticsPostalAddressLocal.CountryRegionId, paymCalendarRecId, includeStateHolidayLocal, paymCalendarRule.RecId));
                        break;
                }

                // Early out if company location (additional rules are ignored after this rule)
                if (paymCalendarRule.RuleType == PaymCalendarRuleType::LegalEntityLocation)
                {
                    break;
                }
            }
        }

        return ruleList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dueDateIncludingGraceDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the due date for the specified grace period, accounting for business and holiday days.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_paymCalendar">
    /// The payment calendar that specifies the business/holiday days.
    /// </param>
    /// <param name="_daysGrace">
    /// The number of days in the grace period.
    /// </param>
    /// <param name="_logisticsPostalAddress">
    /// The <c>LogisticsPostalAddress</c> record that is used to specify additional state holidays;
    /// optional.
    /// </param>
    /// <param name="_dueDatePolicy">
    /// The update policy to use when adjusting the due date; optional.
    /// </param>
    /// <returns>
    /// The adjusted due date.
    /// </returns>
    public DueDate dueDateIncludingGraceDays (DueDate _dueDate, PaymCalendar _paymCalendar, int _daysGrace, LogisticsPostalAddress _logisticsPostalAddress = null, PaymentDueDateUpdatePolicy _dueDatePolicy = PaymentDueDateUpdatePolicy::Next)
    {
        PaymCalendarBitmap paymCalendarBitmap;
        boolean isAdjustedDateFound;
        boolean isInitialBusinessDayFound;
        int graceDaysRemaining;
        DueDate adjustedDate;

        // Validate input parameters
        if (!_paymCalendar.RecId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        adjustedDate = _dueDate;
        isAdjustedDateFound = false;
        isInitialBusinessDayFound = false;
        graceDaysRemaining = _daysGrace;

        while (!isAdjustedDateFound)
        {
            // Setup calendar bitmap for seeking in the year
            paymCalendarBitmap = this.getCalendarBitmap(adjustedDate, _dueDatePolicy, _paymCalendar, _logisticsPostalAddress, true);

            // Seek initial business day
            if (!isInitialBusinessDayFound)
            {
                isInitialBusinessDayFound = paymCalendarBitmap.seekNearestBusinessDay();
            }

            // Skip the grace days
            if (isInitialBusinessDayFound)
            {
                graceDaysRemaining = paymCalendarBitmap.advanceBusinessDays(graceDaysRemaining);
            }

            // Seek first business day after grace period
            if (graceDaysRemaining == 0)
            {
                isAdjustedDateFound = paymCalendarBitmap.seekNearestBusinessDay();
            }

            adjustedDate = paymCalendarBitmap.parmAdjustedDate();
        }

        return adjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the payment calendar for the specified derivation source.
    /// </summary>
    /// <param name="_paymCalendarDerivationSource">
    /// An interface that provides the information that is required to retrieve the payment calendar.
    /// </param>
    /// <returns>
    /// An instance of <c>PaymCalendarFindCalendarResults</c> which contains the retrieved payment calendar
    /// values.
    /// </returns>
    public PaymCalendarFindCalendarResults findPaymCalendar(PaymCalendarIDerivationSource _paymCalendarDerivationSource)
    {
        CompanyInfo companyInfo;
        DataAreaId dataAreaId;
        PaymCalendarModuleType moduleType;
        List ruleList;
        ListEnumerator enumerator;
        Object rule;
        PaymCalendarSpecificRule specificRule;
        PaymCalendarThirdPartyLocationRule thirdPartyLocationRule;
        PaymCalendarLegalEntityLocationRule legalEntityLocationRule;
        PaymMode paymMode, paymModeSource;
        PaymTermId paymTerm, paymTermSource;
        PaymCalendarRecId paymCalendarRecId;
        PaymCalendarIBankAddress bankAddressSource;
        PaymCalendarIDocumentAddress documentAddressSource;
        PaymCalendar paymCalendar;
        LogisticsPostalAddress logisticsPostalAddress;
        boolean includeStateHoliday;
        PaymCalendarRuleId paymCalendarRuleId;
        PaymCalendarFindCalendarResults results;

        // Get list of rules
        dataAreaId = _paymCalendarDerivationSource.parmPaymTermDataAreaId();
        moduleType = _paymCalendarDerivationSource.parmModuleType();
        ruleList = this.getRuleList(dataAreaId, moduleType);

        // Retrieve common values that are inexpensive to fetch
        paymModeSource = _paymCalendarDerivationSource.parmPaymMode();
        paymTermSource = _paymCalendarDerivationSource.parmPaymTermId();

        // Init for seek
        paymCalendarRecId = 0;

        // Seek first matching rule
        enumerator = ruleList.getEnumerator();

        while (enumerator.moveNext())
        {
            rule = enumerator.current();

            // Check specific rule
            specificRule = rule as PaymCalendarSpecificRule;

            if (specificRule != null)
            {
                // Check paymMode
                paymMode = specificRule.parmPaymMode();

                if ((paymMode == '') || (paymMode == paymModeSource))
                {
                    // Check paymTerm
                    paymTerm = specificRule.parmPaymTerm();

                    if ((paymTerm == '') || (paymTerm == paymTermSource))
                    {
                        paymCalendarRecId = specificRule.parmPaymCalendar();
                        logisticsPostalAddress.clear();
                        includeStateHoliday = false;
                        paymCalendarRuleId = specificRule.parmPaymCalendarRuleId();
                        break;
                    }
                }
            }
            else
            {
                // Check third party location rule (i.e. cust/vend location)
                thirdPartyLocationRule = rule as PaymCalendarThirdPartyLocationRule;
                if (thirdPartyLocationRule != null)
                {
                    switch (thirdPartyLocationRule.parmAddressProcess())
                    {
                        case PaymCalendarLocationType::Bank:
                            bankAddressSource = _paymCalendarDerivationSource as PaymCalendarIBankAddress;

                            if (bankAddressSource != null)
                            {
                                logisticsPostalAddress = bankAddressSource.getBankPostalAddress();

                                if (logisticsPostalAddress.CountryRegionId)
                                {
                                    [paymCalendarRecId, includeStateHoliday] = PaymCalendarProcessor::getCalendarForLocation(dataAreaId, moduleType, logisticsPostalAddress.CountryRegionId);
                                }
                            }
                            break;

                        case PaymCalendarLocationType::ThirdParty: // (a.k.a. primary address)
                            logisticsPostalAddress = _paymCalendarDerivationSource.getPrimaryPostalAddress();

                            if (logisticsPostalAddress.CountryRegionId)
                            {
                                [paymCalendarRecId, includeStateHoliday] = PaymCalendarProcessor::getCalendarForLocation(dataAreaId, moduleType, logisticsPostalAddress.CountryRegionId);
                            }
                            break;

                        case PaymCalendarLocationType::LegalEntity: // (a.k.a. document address)
                            documentAddressSource = _paymCalendarDerivationSource as PaymCalendarIDocumentAddress;

                            if (documentAddressSource != null)
                            {
                                logisticsPostalAddress = documentAddressSource.getDocumentPostalAddress();

                                if (logisticsPostalAddress.CountryRegionId)
                                {
                                    [paymCalendarRecId, includeStateHoliday] = PaymCalendarProcessor::getCalendarForLocation(dataAreaId, moduleType, logisticsPostalAddress.CountryRegionId);
                                }
                            }
                            break;
                    }

                    if (paymCalendarRecId)
                    {
                        paymCalendarRuleId = thirdPartyLocationRule.parmPaymCalendarRuleId();
                    }
                }
                else
                {
                    // Check legal entity location rule (i.e. company location)
                    legalEntityLocationRule = rule as PaymCalendarLegalEntityLocationRule;

                    if (legalEntityLocationRule != null)
                    {
                        companyInfo = CompanyInfo::findDataArea(dataAreaId);
                        logisticsPostalAddress = companyInfo.postalAddress();

                        if (logisticsPostalAddress.CountryRegionId == legalEntityLocationRule.parmCountryRegionId())
                        {
                            // The cached values are valid
                            paymCalendarRecId = legalEntityLocationRule.parmPaymCalendarRecId();
                            includeStateHoliday = legalEntityLocationRule.parmIncludeStateHoliday();
                        }
                        else if (logisticsPostalAddress.CountryRegionId)
                        {
                            [paymCalendarRecId, includeStateHoliday] = PaymCalendarProcessor::getCalendarForLocation(dataAreaId, moduleType, logisticsPostalAddress.CountryRegionId);
                        }

                        if (paymCalendarRecId)
                        {
                            paymCalendarRuleId = legalEntityLocationRule.parmPaymCalendarRuleId();
                        }
                    }
                }
            }

            // Exit while if calendar was found
            if (paymCalendarRecId)
            {
                break;
            }
        }

        // Init return values (logisticsPostalAddress and includeStateHoliday are already set if found)
        if (paymCalendarRecId)
        {
            paymCalendar = PaymCalendar::find(paymCalendarRecId);
        }
        else
        {
            paymCalendar.clear();
            logisticsPostalAddress.clear();
            includeStateHoliday = false;
            paymCalendarRuleId = 0;
        }

        results = PaymCalendarFindCalendarResults::construct(paymCalendar, logisticsPostalAddress, includeStateHoliday, paymCalendarRuleId);

        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date so that it falls on a business day per specified calendar source.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_paymCalendarDerivationSource">
    /// An interface that provides the information that is required to retrieve the payment calendar.
    /// </param>
    /// <returns>
    /// An instance of the <c>PaymCalendarAdjustedDate</c> table which contains the adjusted due date
    /// together with the calendar and rule that was applied when adjusting the date.
    /// </returns>
    /// <remarks>
    /// An empty record ID is returned for the payment calendar and calendar rule whenever a calendar is
    /// not found.
    /// </remarks>
    public PaymCalendarAdjustedDate getAdjustedDate(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, PaymCalendarIDerivationSource _paymCalendarDerivationSource)
    {
        DueDate adjustedDate;
        PaymCalendarFindCalendarResults calendar;

        // Validate input parameters
        if (!_paymCalendarDerivationSource)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        Debug::assert(_updatePolicy != PaymentDueDateUpdatePolicy::NoUpdate);

        calendar = this.findPaymCalendar(_paymCalendarDerivationSource);
        adjustedDate = this.calculateAdjustedDate(_dueDate, _updatePolicy, calendar);

        return PaymCalendarAdjustedDate::construct(adjustedDate, calendar.parmPaymCalendar().RecId, calendar.parmPaymCalendarRuleId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendarBitmap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a calendar bitmap for the specified values.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_updatePolicy">
    /// A value that specifies the search direction when seeking the next valid business day.
    /// </param>
    /// <param name="_paymCalendar">
    /// The payment calendar that specifies the business and holiday days.
    /// </param>
    /// <param name="_address">
    /// The <c>LogisticsPostalAddress</c> record.
    /// </param>
    /// <param name="_includeStateCityHoliday">
    /// true if state and city holidays should be considered; otherwise, false.
    /// </param>
    /// <returns>
    /// An instance of the calendar bitmap.
    /// </returns>
    private PaymCalendarBitmap getCalendarBitmap(DueDate _dueDate, PaymentDueDateUpdatePolicy _updatePolicy, PaymCalendar _paymCalendar, LogisticsPostalAddress _address, boolean _includeStateCityHoliday)
    {
        PaymCalendarBitmap paymCalendarBitmap;
        container calendarBitmap;

        calendarBitmap = this.retrieveCalendarBitmap(_paymCalendar, year(_dueDate), _address, _includeStateCityHoliday);
        paymCalendarBitmap = PaymCalendarBitmap::construct(_dueDate, _updatePolicy, calendarBitmap);

        return paymCalendarBitmap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRuleList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an ordered list of rules for the specified values.
    /// </summary>
    /// <param name="_legalEntity">
    /// The record ID that specifies the legal entity.
    /// </param>
    /// <param name="_moduleType">
    /// The module type of the rules to be retrieved.
    /// </param>
    /// <returns>
    /// A list containing the rules ordered by how they must be applied.
    /// </returns>
    /// <remarks>
    /// The list contains objects of type <c>PaymCalendarSpecificRule</c>,
    /// <c>PaymCalendarThirdPartyLocationRule</c>, or <c>PaymCalendarLegalEntityLocationRule</c>.
    /// </remarks>
    private List getRuleList(DataAreaId _dataAreaId, PaymCalendarModuleType _moduleType)
    {
        container cachedResult;
        List ruleList;

        cachedResult = PaymCalendarProcessor::getCacheValue(
                PaymCalendarCacheScope::RuleList,
                [_dataAreaId, _moduleType]);

        if (cachedResult == conNull())
        {
            ruleList = this.createRuleList(_dataAreaId, _moduleType);

            // Add to cache
            cachedResult = ruleList.pack();
            PaymCalendarProcessor::insertIntoCache(
                PaymCalendarCacheScope::RuleList,
                [_dataAreaId, _moduleType],
                cachedResult);
        }
        else
        {
            ruleList = List::create(cachedResult);
        }

        return ruleList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCalendarBitmap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a bitmap representing the business days for the specified calendar, year and state.
    /// </summary>
    /// <param name="_paymCalendar">
    /// The payment calendar that specifies the business and holiday days.
    /// </param>
    /// <param name="_year">
    /// The specific year for the calendar.
    /// </param>
    /// <param name="_address">
    /// The <c>LogisticsPostalAddress</c> record.
    /// </param>
    /// <param name="_includeStateCityHoliday">
    /// true if state and city holidays should be considered; otherwise, false.
    /// </param>
    /// <returns>
    /// A container that contains a bitmap.
    /// </returns>
    private container retrieveCalendarBitmap(PaymCalendar _paymCalendar, int _year, LogisticsPostalAddress _address, boolean _includeStateCityHoliday)
    {
        LogisticsAddressState state;
        int businessDaysLocal[CalendarBitmapSize];
        int holidays[CalendarBitmapSize];
        int i;

        state = LogisticsAddressState::find(_address.CountryRegionId, _address.State);

        if (!state || !_includeStateCityHoliday)
        {
            return this.retrievePaymentCalendarBitmap(_paymCalendar, _year);
        }
        else
        {
            // Lookup bitmaps
            [businessDaysLocal] = this.retrievePaymentCalendarBitmap(_paymCalendar, _year);

            [holidays] = this.retrieveHolidayCalendarBitmap(_paymCalendar.RecId, _year, _address);

            // Remove holidays from businessDaysLocal
            for (i = 1; i <= CalendarBitmapSize; i++)
            {
                businessDaysLocal[i] = businessDaysLocal[i] & holidays[i];
            }

            return [businessDaysLocal];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveHolidayCalendarBitmap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a bitmap representing the holidays for the specified calendar, year, state and city.
    /// </summary>
    /// <param name="_paymCalendarId">
    /// The record ID of the <c>PaymCalendar</c> record of the payment calendar associated to the state and city holidays.
    /// </param>
    /// <param name="_year">
    /// The specific year for the calendar.
    /// </param>
    /// <param name="_address">
    /// The <c>LogisticsPostalAddress</c> record.
    /// </param>
    /// <returns>
    /// A container holding a bitmap wherein the bits that correspond to holidays are set to false.
    /// The bitmap contains a bit for each day of the year in ascending order.
    /// </returns>
    /// <remarks>
    /// The bitmap is cached to minimize retrivial time.
    /// </remarks>
    private container retrieveHolidayCalendarBitmap(PaymCalendarRecId _paymCalendarId, int _year, LogisticsPostalAddress _address)
    {
        container cachedResult;
        LogisticsAddressStateRecId state;
        LogisticsAddressCityRecId city;

        state = LogisticsAddressState::find(_address.CountryRegionId, _address.State).RecId;

        // <GBR>
        city = BrazilParameters::isEnabled() ? _address.CityRecId : 0;
        // </GBR>

        cachedResult = PaymCalendarProcessor::getCacheValue(
            PaymCalendarCacheScope::HolidayCalendar,
            [_paymCalendarId, _year, state, city]);

        if (cachedResult == conNull())
        {
            cachedResult = this.createHolidayCalendarBitmap(_paymCalendarId, _year, state, city);

            PaymCalendarProcessor::insertIntoCache(
                PaymCalendarCacheScope::HolidayCalendar,
                [_paymCalendarId, _year, state, city],
                cachedResult);
        }

        return cachedResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrievePaymentCalendarBitmap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a bitmap representing the business days for the specified calendar and year.
    /// </summary>
    /// <param name="_paymCalendar">
    /// The payment calendar that specifies the business/holiday days.
    /// </param>
    /// <param name="_year">
    /// The specific year for the calendar.
    /// </param>
    /// <returns>
    /// A container holding a bitmap wherein the bits that correspond to business days are set to true.
    /// The bitmap contains a bit for each day of the year in ascending order.
    /// </returns>
    /// <remarks>
    /// The bitmap is cached to minimize retrivial time.
    /// </remarks>
    private container retrievePaymentCalendarBitmap(PaymCalendar _paymCalendar, int _year)
    {
        container cachedResult;

        cachedResult = PaymCalendarProcessor::getCacheValue(
            PaymCalendarCacheScope::PaymentCalendar,
            [_paymCalendar.RecId, _year]);

        if (cachedResult == conNull())
        {
            cachedResult = PaymCalendarProcessor::createPaymentCalendarBitmap(_paymCalendar, _year);

            PaymCalendarProcessor::insertIntoCache(
                PaymCalendarCacheScope::PaymentCalendar,
                [_paymCalendar.RecId, _year],
                cachedResult);
        }

        return cachedResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calendarForLocationChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the calendar for location cache after
    /// a <c>PaymCalendarCountryRegionLegalEntity</c> record is modified.
    /// </summary>
    /// <remarks>
    /// Modifying a calendar for location comprises deleting a location calendar or
    /// selecting/unselecting a location calendar or changing the include state holidays checkbox.
    /// </remarks>
    public static void calendarForLocationChanged()
    {
        PaymCalendarProcessor::clearScope(PaymCalendarCacheScope::CalendarForLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearScope</Name>
				<Source><![CDATA[
    private static void clearScope(PaymCalendarCacheScope _scope)
    {
        SysGlobalObjectCache c = classfactory.globalObjectCache();
        c.clear(PaymCalendarProcessor::getCacheScopeStr(_scope));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an instance of the <c>PaymCalendarProcessor</c> class.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>PaymCalendarProcessor</c> class.
    /// </returns>
    public static PaymCalendarProcessor construct()
    {
        return new PaymCalendarProcessor();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentCalendarBitmap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a bitmap representing the business days for the specified calendar and year.
    /// </summary>
    /// <param name="_paymCalendar">
    /// The payment calendar that specifies the businesss and holiday days.
    /// </param>
    /// <param name="_year">
    /// The specific year for the calendar.
    /// </param>
    /// <returns>
    /// A container holding a bitmap wherein the bits that correspond to business days are set to true.
    /// </returns>
    private static container createPaymentCalendarBitmap(PaymCalendar _paymCalendar, int _year)
    {
        PaymCalendarException paymCalendarException;
        container bitmapContainer;
        int i;
        int businessDaysLocal[CalendarBitmapSize];
        boolean isBusinessDay[7];
        int daysInYear;
        int dayOfWeek;
        int dayMaskLocal;
        int daysRemainingInMaskLocal;
        int businessDaysIndexLocal;
        int exceptionDay;
        date firstDayInYear;
        date lastDayInYear;

        PreferredLocale locale = new xSession().preferredLocale();

        // Init { firstDayInYear, lastDayInYear, daysInYear }
        firstDayInYear = mkDate(1, 1, _year);
        lastDayInYear = DateTimeUtil::getEndOfYearDate(locale, firstDayInYear);
        daysInYear = dayOfYr(lastDayInYear);

        // Init isBusinessDay
        isBusinessDay[1] = _paymCalendar.IsMondayBusinessDay;
        isBusinessDay[2] = _paymCalendar.IsTuesdayBusinessDay;
        isBusinessDay[3] = _paymCalendar.IsWednesdayBusinessDay;
        isBusinessDay[4] = _paymCalendar.IsThursdayBusinessDay;
        isBusinessDay[5] = _paymCalendar.IsFridayBusinessDay;
        isBusinessDay[6] = _paymCalendar.IsSaturdayBusinessDay;
        isBusinessDay[7] = _paymCalendar.IsSundayBusinessDay;

        // Init businessDaysLocal for standard business week
        businessDaysLocal[0] = 0; // Clear array: all days are intially holidays
        dayMaskLocal = 0x00000001;
        daysRemainingInMaskLocal = BitsInInt;
        businessDaysIndexLocal = 1;
        dayOfWeek = dayOfWk(firstDayInYear);

        for (i = 1; i <= daysInYear; i++)
        {
            if (isBusinessDay[dayOfWeek])
            {
                businessDaysLocal[businessDaysIndexLocal] = businessDaysLocal[businessDaysIndexLocal] | dayMaskLocal;
            }

            // Advance dayOfWeek
            dayOfWeek++;
            if (dayOfWeek == 8)
            {
                dayOfWeek = 1;
            }

            // Advance dayMask (and currentIntIndex)
            daysRemainingInMaskLocal--;
            if (daysRemainingInMaskLocal == 0)
            {
                dayMaskLocal = 0x00000001;
                daysRemainingInMaskLocal = BitsInInt;
                businessDaysIndexLocal++;
            }
            else
            {
                dayMaskLocal = dayMaskLocal << 1;
            }
        }

        // Process exception days
        while select ExceptionDate, ExceptionType from paymCalendarException
            where paymCalendarException.PaymCalendar == _paymCalendar.RecId
                && paymCalendarException.ExceptionDate >= firstDayInYear
                && paymCalendarException.ExceptionDate <= lastDayInYear
        {
            // Init mask
            exceptionDay = dayOfYr(paymCalendarException.ExceptionDate);
            businessDaysIndexLocal = PaymCalendarProcessor::getBitmapIndex(exceptionDay);
            dayMaskLocal = 0x00000001 << (PaymCalendarProcessor::getBitPosition(exceptionDay) - 1);

            // Update day
            if (paymCalendarException.ExceptionType == PaymDayExceptionType::Add)
            {
                businessDaysLocal[businessDaysIndexLocal] = businessDaysLocal[businessDaysIndexLocal] | dayMaskLocal;
            }
            else
            {
                dayMaskLocal = ~dayMaskLocal;
                businessDaysLocal[businessDaysIndexLocal] = businessDaysLocal[businessDaysIndexLocal] & dayMaskLocal;
            }
        }

        bitmapContainer = [businessDaysLocal];

        return bitmapContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts user to accept adjusted due date based on Payment calendar configuration if it has changed
    /// from the prior due date.
    /// </summary>
    /// <param name="_dueDate">
    /// The current due date to adjust from the table buffer.
    /// </param>
    /// <param name="_priorDueDate">
    /// The due date prior to adjustment.
    /// </param>
    /// <param name="_paymCalendarAdjustedDate">
    /// An instance of the <c>PaymCalendarAdjustedDate</c> class that contains the adjusted due date
    /// together with the calendar and rule that was applied when adjusting the date.
    /// </param>
    /// <returns>
    /// If the adjusted due date is accepted, the adjusted due date is returned, otherwise the
    /// original due date is returned.
    /// </returns>
    public static TransDate getAdjustedDueDate(TransDate _dueDate, TransDate _priorDueDate, PaymCalendarAdjustedDate _paymCalendarAdjustedDate)
    {
        TransDate dueDate = _dueDate;

        if (dueDate != _paymCalendarAdjustedDate.parmAdjustedDueDate())
        {
            dueDate = _paymCalendarAdjustedDate.parmAdjustedDueDate();
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBitmapIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the index into the array of integers representing the bitmap for the specified day in the year.
    /// </summary>
    /// <param name="_targetDay">
    /// The day in the year.
    /// </param>
    /// <returns>
    /// The bitmap index.
    /// </returns>
    /// <remarks>
    /// The index will be enclosed in range of 1 through 12.
    /// </remarks>
    private static int getBitmapIndex(int _targetDay)
    {
        real bitmapIndex;

        bitmapIndex = ((_targetDay - 1) / BitsInInt) + 1;

        return real2int(bitmapIndex);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBitPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bit position for the bitmask for the specified day in the year.
    /// </summary>
    /// <param name="_targetDay">
    /// The day in the year.
    /// </param>
    /// <returns>
    /// The bit position.
    /// </returns>
    /// <remarks>
    /// The bit position will be enclosed in range of 1 through 32.
    /// </remarks>
    private static int getBitPosition(int _targetDay)
    {
        int bitPosition;

        bitPosition = _targetDay mod BitsInInt;

        if (bitPosition == 0)
        {
            bitPosition = 32;
        }

        return bitPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheScopeStr</Name>
				<Source><![CDATA[
    private static str getCacheScopeStr(PaymCalendarCacheScope _scope)
    {
        #define.PaymCalendarCachePrefix('PaymentCalendarCache_')

        // Int2Str is used instead of Enum2Str to get the int
        // value like '2' instead of the string value for
        // the scope to ensure uniqueness. The _scope enum
        // is implicitly cast to an int by this call. This
        // avoids calling strfmt() which causes a kernel
        // callback running under IL and is therefore significantly
        // slower.
        return #PaymCalendarCachePrefix + int2str(_scope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheValue</Name>
				<Source><![CDATA[
    private static container getCacheValue(PaymCalendarCacheScope _scope, container _key)
    {
        SysGlobalObjectCache c;

        if (classfactory)
        {
            c = classfactory.globalObjectCache();
        }
        else
        {
            c = new SysGlobalObjectCache();
        }

        return c.find(PaymCalendarProcessor::getCacheScopeStr(_scope), _key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendarForLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the payment calendar for the specified values.
    /// </summary>
    /// <param name="_legalEntity">
    /// The record ID that specifies the legal entity.
    /// </param>
    /// <param name="_moduleType">
    /// The associated module type.
    /// </param>
    /// <param name="_countryRegionId">
    /// The natural key that specifies the country or region.
    /// </param>
    /// <returns>
    /// A container that contains the record ID of the payment calendar and a flag denoting whether state
    /// holidays should be included.
    /// </returns>
    /// <remarks>
    /// An empty record ID is returned if a calendar is not defined for the specified country, or if that
    /// calendar was not selected for the specified legal entity and module type.
    /// </remarks>
    private static container getCalendarForLocation(DataAreaId _dataAreaId, PaymCalendarModuleType _moduleType, LogisticsAddressCountryRegionId _countryRegionId)
    {
        LogisticsAddressCountryRegion logisticsAddressCountryRegion;
        PaymCalendarCountryRegion paymCalendarCountryRegion;
        PaymCalendarCountryRegionLegalEntity paymCalendarCountryRegionLegalEntity;
        PaymCalendarRecId paymCalendarRecId = 0;
        boolean includeStateHolidayLocal = false;
        container cachedResult;

        cachedResult = PaymCalendarProcessor::getCacheValue(
            PaymCalendarCacheScope::CalendarForLocation,
            [_dataAreaId, _moduleType, _countryRegionId]);

        if (cachedResult == conNull())
        {
            logisticsAddressCountryRegion = LogisticsAddressCountryRegion::find(_countryRegionId);
            paymCalendarCountryRegion = PaymCalendarCountryRegion::findByCountryRegion(logisticsAddressCountryRegion.RecId);

            if (paymCalendarCountryRegion)
            {
                paymCalendarCountryRegionLegalEntity = PaymCalendarCountryRegionLegalEntity::findByLegalEntityTypePaymentCalendar(_dataAreaId, _moduleType, paymCalendarCountryRegion.RecId);

                if (paymCalendarCountryRegionLegalEntity)
                {
                    paymCalendarRecId = paymCalendarCountryRegion.PaymCalendar;
                    includeStateHolidayLocal = paymCalendarCountryRegionLegalEntity.IncludeStateHoliday;
                }
            }

            // Add to cache
            cachedResult = [paymCalendarRecId, includeStateHolidayLocal];

            PaymCalendarProcessor::insertIntoCache(
                PaymCalendarCacheScope::CalendarForLocation,
                [_dataAreaId, _moduleType, _countryRegionId],
                cachedResult);
        }

        return cachedResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoCache</Name>
				<Source><![CDATA[
    private static void insertIntoCache(PaymCalendarCacheScope _scope, container _key, container _value)
    {
        SysGlobalObjectCache c;

        if (classfactory)
        {
            c = classfactory.globalObjectCache();
        }
        else
        {
            c = new SysGlobalObjectCache();
        }

        c.insert(PaymCalendarProcessor::getCacheScopeStr(_scope), _key, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymCalendarChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment calendar cache after a calendar is modified.
    /// </summary>
    /// <remarks>
    /// Modifying a calendar includes adding/deleting a calendar or modifying
    /// one of the IsBusinessDays fields. It also includes adding/deleting an
    /// exception day.
    /// </remarks>
    public static void paymCalendarChanged()
    {
        PaymCalendarProcessor::clearScope(PaymCalendarCacheScope::PaymentCalendar);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymCalendarRuleChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment calendar rules cache after a rule is modified.
    /// </summary>
    /// <remarks>
    /// Modifying a calendar rule includes adding/deleting an active rule or
    /// modifying an existing rule (except for name and description). It also
    /// includes changing the location rule evaludation priority.
    /// </remarks>
    public static void paymCalendarRuleChanged()
    {
        PaymCalendarProcessor::clearScope(PaymCalendarCacheScope::RuleList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>stateHolidayChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the state holiday calendar cache after a state holiday is modified.
    /// </summary>
    /// <remarks>
    /// Modifying a state holiday calendar comprises adding/deleting a state holiday.
    /// </remarks>
    public static void stateHolidayChanged()
    {
        PaymCalendarProcessor::clearScope(PaymCalendarCacheScope::HolidayCalendar);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>