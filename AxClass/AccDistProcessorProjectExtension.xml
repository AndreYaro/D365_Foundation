<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AccDistProcessorProjectExtension</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>AccDistProcessorProjectExtension</c> class is the extension of the project to the accounting
///    distribution processor.
/// </summary>
[SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProductRequisition), SourceDocument_ProductRequisition::PurchaseRequisition),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProductOrder), SourceDocument_ProductOrder::PurchaseOrder),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_VendorInvoice), SourceDocument_VendorInvoice::VendorInvoice),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_CustomerInvoice), SourceDocument_CustomerInvoice::CustomerFreeTextInvoice),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ExpenseReport), SourceDocument_ExpenseReport::ExpenseReport),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_TravelRequisition), SourceDocument_TravelRequisition::TravelRequisition),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProjectTimesheets), SourceDocument_ProjectTimesheets::Timesheets),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_EarningStatement), SourceDocument_EarningStatement::EarningStatement),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_PayrollPayStatement), SourceDocument_PayrollPayStatement::PayStatement),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProjectRevenue), SourceDocument_ProjectRevenue::ProjectRevenue),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_AdvancedLedgerEntry), SourceDocument_AdvancedLedgerEntry::AdvancedLedgerEntry),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProjAdvancedJournal), SourceDocument_ProjAdvancedJournal::ProjAdvancedJournal),
SourceDocumentEnumLiteralClassExtensionAttribute(enumStr(BudgetReservation_SourceDocument_PSN), enumLiteralStr(BudgetReservation_SourceDocument_PSN, BudgetReservation))]
class AccDistProcessorProjectExtension extends AccDistProcessorExtension
{
    Map reversedAccountingDistributionMap;
    Map reversalMap;

    Map originAccountingDistributionMap;
    Map originMap;

    Map accountingDistributionMap;
    Map ledgerDimensionAllocationMap;

    Map distributeEqually;

    boolean                         isSourceDocumentAccountingPolicyInitialized;
    SourceDocumentAccountingPolicy  sourceDocumentAccountingPolicy;

    Map topSourceDocumentLineMap;
    Map topSourceDocLineHasProjectMap;

    AmountCur   remainingAmount;
    RefRecId    previousFundingSource;

    Map         referenceAccountingDistributionMap;
    AmountCur   currentDistributionTotalAmount;
    AmountCur   referenceDistributionTotalAmount;

    Map         newFundingLimitList;
    Map         newTaxDistributionsMap;
    Map         reversedCurrentFundingLimitMap;
    Map         taxReferenceFundingLimitMap;
    List        newReversedFundingLimitList;
    List        newTaxReversedFundingLimitList;
    List        listNewDistributions;
    List        listNewTaxDistributions;
    List        listPOSpecialCaseTaxTracking;
    boolean     skipActiveVendorInvoiceCheck;
    private boolean vendorInvoiceRetentionCalcFeature = ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled();

    private Map  canCreateProjectDistributionMap;

    private ProjOpsFinancialsLogger logger;

    #define.TaxScopeCache('ProjTaxScopeCache')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocateDeletedTaxTracking</Name>
				<Source><![CDATA[
    private void allocateDeletedTaxTracking(RefRecId _accountingDistributionRecId, List _listOfRecords)
    {
        ListEnumerator              listEnum;
        ProjFundingLimitTracking    fundingLimitTracking;

        listEnum = _listOfRecords.getEnumerator();

        while (listEnum.moveNext())
        {
            fundingLimitTracking.data(listEnum.current());
            fundingLimitTracking.SourceAccountingDistribution = _accountingDistributionRecId;
            fundingLimitTracking.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>areTaxFieldsChanged</Name>
				<Source><![CDATA[
    private boolean areTaxFieldsChanged(SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        PurchLine purchLine;
        PurchReqLine purchReqLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        AccountingDistribution accountingDistributions;
        AccountingDistribution taxDistributions;

        // check if top source document line is either PO or Vendor Invoice
        if (!(_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem ||
             _topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem))
        {
            return false;
        }

        //Conditions for Purchase Order
        if (_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            select firstonly TaxItemGroup,TaxGroup,RecId from purchLine where purchLine.SourceDocumentLine == _topSourceDocumentLineItem.parmSourceDocumentLine().RecId
                join TaxItemGroup,TaxGroup from purchReqLine where purchReqLine.LineRefId == purchLine.PurchReqLineRefId;

            if (purchLine.RecId != 0 &&
               ((purchLine.TaxItemGroup != purchReqLine.TaxItemGroup) ||
                (purchLine.TaxGroup != purchReqLine.TaxGroup)))
            {
                return true;
            }

            // At the time when PO was created, tax distributions are not created yet
            // We need to delete PR tax distributions to get correct allocation
            if (purchLine.RecId != 0 && purchLine.TaxItemGroup != "" && purchLine.TaxGroup != "")
            {
                select firstonly RecId from accountingDistributions where accountingDistributions.SourceDocumentLine == _topSourceDocumentLineItem.parmSourceDocumentLine().RecId
                    join RecId from taxDistributions where taxDistributions.ParentDistribution == accountingDistributions.RecId &&
                                                           taxDistributions.MonetaryAmount == MonetaryAmount::TaxNonRecoverable;
                                            
                if (taxDistributions.RecId == 0)
                {
                    return true;
                }
            }
        }

        if (_topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            select firstonly TaxItemGroup,TaxGroup,RecId,InventTransId from vendInvoiceInfoLine
                        where vendInvoiceInfoLine.SourceDocumentLine == _topSourceDocumentLineItem.parmSourceDocumentLine().RecId
                    join TaxItemGroup,TaxGroup,RecId,InventTransId from purchLine
                        where purchLine.InventTransId == vendInvoiceInfoLine.InventTransId;

            if (vendInvoiceInfoLine.RecId != 0 &&
               ((vendInvoiceInfoLine.TaxItemGroup != purchLine.TaxItemGroup) ||
                (vendInvoiceInfoLine.TaxGroup != purchLine.TaxGroup)))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransactionCurrencyPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate transaction currency price for the currenct distribution line item.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// The source document line item.
    /// </param>
    /// <returns>
    /// Project sales price of the source document line item.
    /// </returns>
    private PriceCur calculateTransactionCurrencyPrice(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        PriceCur projectSalesPrice;
        SourceDocumentLineItemIProjectRevenue sourceDocumentLineItemIProjectRevenue;

        if (_sourceDocumentLineItem is TrvExpTransSourceDocLineItem)
        {
            sourceDocumentLineItemIProjectRevenue = _sourceDocumentLineItem as TrvExpTransSourceDocLineItem;
        }
        else if (_sourceDocumentLineItem.parmParentSourceDocumentLineItem())
        {
            sourceDocumentLineItemIProjectRevenue = _sourceDocumentLineItem.parmParentSourceDocumentLineItem() as SourceDocumentLineItemIProjectRevenue;
        }

        if (sourceDocumentLineItemIProjectRevenue)
        {
            projectSalesPrice = sourceDocumentLineItemIProjectRevenue.parmProjectSalesPrice();
        }
        else if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            PurchOrderLineSourceDocumentLineItem purchOrderLineSourceDocumentLineItem = _sourceDocumentLineItem as PurchOrderLineSourceDocumentLineItem;
            projectSalesPrice = purchOrderLineSourceDocumentLineItem.parmProjectSalesPrice();
        }
        else
        {
            projectSalesPrice = 0;
        }

        return projectSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateChildProjectDistribution</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canCreateChildProjectDistribution(
        AccountingDistribution          _accountingDistribution,
        SourceDocumentLineItem          _accDistSourceDocumentLineItem,
        SourceDocumentLineItem          _topSourceDocumentLineItem,
        ProjectAccountingDistribution   _projectAccountingDistribution)
    {
        boolean canCreateProjectDistribution;

        if (ProjectSourceDocumentLineItemHelper::canProcessProject(_topSourceDocumentLineItem))
        {
            if (this.canCreateProjectDistribution(_accountingDistribution, _accDistSourceDocumentLineItem, _topSourceDocumentLineItem))
            {
                canCreateProjectDistribution = true;
            }
            else
            {
                // Allow creation of project distribtuion if this has posting type PSAProjPurchRetain
                AccountingPolicy accountingPolicy = this.getAccountingPolicy(_accDistSourceDocumentLineItem);
                AccountingDistributionRule accountingDistributionRule = accountingPolicy.parmDistributionRule(_accountingDistribution.MonetaryAmount);
                if (ProjectSourceDocumentLineItemHelper::projCategory(_topSourceDocumentLineItem).CategoryType != ProjCategoryType::None
                    && accountingDistributionRule.parmLedgerPostingType() == LedgerPostingType::PSAProjPurchRetain)
                {
                    canCreateProjectDistribution = true;
                }
            }
        }
        else
        {
            if (this.canMonetaryAmountCreateProjectDistribution(_accountingDistribution) ||
                _accountingDistribution.LedgerDimension == this.getExtendedPriceLedgerDimension(_topSourceDocumentLineItem))
            {
                canCreateProjectDistribution = true;
            }
        }
        
        return canCreateProjectDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateFromOriginSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to create project accounting distribution records that are based on the
    /// accounting distributions of an existing source document line.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// The source document line of the accounting distribution.
    /// </param>
    /// <param name="_monetaryAmount">
    /// The monetary amount of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    /// <returns>
    /// true if the project accounting distribution records will be created based on origin accounting
    /// distributions; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canCreateFromOriginSourceDocumentLine(SourceDocumentLineRecId _sourceDocumentLine, MonetaryAmount _monetaryAmount, SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        MonetaryAmountList                      monetaryAmountList;
        AccountingDistributionList              accountingDistributionList;
        AccountingDistributionListEnumerator    accountingDistributionListEnumerator;
        AccountingDistribution                  accountingDistribution;
        AccountingDistribution                  reversingAccountingDistribution;
        AccountingDistribution                  originAccountingDistribution;
        List                                    originAccountingDistributionList;
        List                                    newOriginAccountingDistributionList;
        ListEnumerator                          originAccountingDistributionListEnumerator;
        boolean                                 originAccountingDistributionFound;
        boolean                                 canCreateFromOriginDistribution;
        boolean                                 originAccountingDistributionNotOnList;
        str                                     key;

        key = int642str(_sourceDocumentLine) + '#' + int2str(enum2int(_monetaryAmount));
        if (!originMap.exists(key))
        {
            monetaryAmountList = MonetaryAmountList::construct();
            monetaryAmountList.addEnd(_monetaryAmount);

            if (_topSourceDocumentLineItem.parmOriginSourceDocumentLineItem() &&
                _topSourceDocumentLineItem.parmOriginSourceDocumentLineItem().getAccDistListForMonetaryAmount(monetaryAmountList).elements())
            {
                originAccountingDistributionList = new List(Types::Record);
                accountingDistributionList = _topSourceDocumentLineItem.parmOriginSourceDocumentLineItem().getAccDistListForMonetaryAmount(monetaryAmountList);
                accountingDistributionListEnumerator = accountingDistributionList.getEnumerator();
                while (accountingDistributionListEnumerator.moveNext())
                {
                    originAccountingDistribution = accountingDistributionListEnumerator.current();
                    originAccountingDistributionList.addEnd(originAccountingDistribution);
                }
                originAccountingDistributionMap.insert(key, originAccountingDistributionList);

                originAccountingDistributionNotOnList = false;

                while select AllocationFactor, LedgerDimension from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLine &&
                        accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                        accountingDistribution.MonetaryAmount == _monetaryAmount
                    notexists join reversingAccountingDistribution
                    where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                        reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                {
                    newOriginAccountingDistributionList = new List(Types::Record);
                    originAccountingDistributionFound = false;

                    originAccountingDistributionListEnumerator = originAccountingDistributionList.getEnumerator();
                    while (originAccountingDistributionListEnumerator.moveNext())
                    {
                        originAccountingDistribution = originAccountingDistributionListEnumerator.current();
                        if (!originAccountingDistributionFound &&
                            originAccountingDistribution.LedgerDimension == accountingDistribution.LedgerDimension &&
                            originAccountingDistribution.AllocationFactor == accountingDistribution.AllocationFactor)
                        {
                            originAccountingDistributionFound = true;
                        }
                        else
                        {
                            newOriginAccountingDistributionList.addEnd(originAccountingDistribution);
                        }
                    }

                    originAccountingDistributionList = List::create(newOriginAccountingDistributionList.pack());

                    if (!originAccountingDistributionFound)
                    {
                        originAccountingDistributionNotOnList = true;
                        break;
                    }
                }

                if (originAccountingDistributionNotOnList || originAccountingDistributionList.elements())
                {
                    originMap.insert(key, NoYes::No);
                }
                else
                {
                    originMap.insert(key, NoYes::Yes);
                }
            }
            else
            {
                originMap.insert(key, NoYes::No);
            }
        }

        canCreateFromOriginDistribution = (originMap.lookup(key) == NoYes::Yes ? true : false);

        return canCreateFromOriginDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateFromReversedDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether project accounting distribution records will be created based on reversed
    /// accounting distributions.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// The source document line of the accounting distribution.
    /// </param>
    /// <param name="_monetaryAmount">
    /// The monetary amount of the accounting distribution.
    /// </param>
    /// <returns>
    /// true if project accounting distribution records will be created based on reversed accounting
    /// distributions; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canCreateFromReversedDistribution(SourceDocumentLineRecId _sourceDocumentLine, MonetaryAmount _monetaryAmount)
    {
        AccountingDistribution  accountingDistribution;
        AccountingDistribution  reversingAccountingDistribution;
        AccountingDistribution  reversedAccountingDistribution;
        List                    reversedAccountingDistributionList;
        List                    newReversedAccountingDistributionList;
        ListEnumerator          reversedAccountingDistributionListEnumerator;
        boolean                 reversedAccountingDistributionFound;
        boolean                 canCreateFromReversedDistribution;
        boolean                 reversedAccountingDistributionNotOnList;
        str                     key;

        key = int642str(_sourceDocumentLine) + '#' + int2str(enum2int(_monetaryAmount));
        if (reversedAccountingDistributionMap.exists(key))
        {
            if (!reversalMap.exists(key))
            {
                reversedAccountingDistributionList = reversedAccountingDistributionMap.lookup(key);
                reversedAccountingDistributionNotOnList = false;

                while select AllocationFactor from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLine &&
                        accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                        accountingDistribution.MonetaryAmount == _monetaryAmount
                    notexists join reversingAccountingDistribution
                    where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                        reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                {
                    newReversedAccountingDistributionList = new List(Types::Record);
                    reversedAccountingDistributionFound = false;

                    reversedAccountingDistributionListEnumerator = reversedAccountingDistributionList.getEnumerator();
                    while (reversedAccountingDistributionListEnumerator.moveNext())
                    {
                        reversedAccountingDistribution = reversedAccountingDistributionListEnumerator.current();
                        if (!reversedAccountingDistributionFound &&
                            reversedAccountingDistribution.AllocationFactor == accountingDistribution.AllocationFactor)
                        {
                            reversedAccountingDistributionFound = true;
                        }
                        else
                        {
                            newReversedAccountingDistributionList.addEnd(reversedAccountingDistribution);
                        }
                    }

                    reversedAccountingDistributionList = List::create(newReversedAccountingDistributionList.pack());

                    if (!reversedAccountingDistributionFound)
                    {
                        reversedAccountingDistributionNotOnList = true;
                        break;
                    }
                }

                if (reversedAccountingDistributionNotOnList || reversedAccountingDistributionList.elements())
                {
                    reversalMap.insert(key, NoYes::No);
                }
                else
                {
                    reversalMap.insert(key, NoYes::Yes);
                }
            }

            canCreateFromReversedDistribution = (reversalMap.lookup(key) == NoYes::Yes ? true : false);
        }

        return canCreateFromReversedDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateProjectDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a project accounting distribution record must be created for the accounting distribution.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    /// <returns>
    /// true if a project accounting distribution record must be created; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canCreateProjectDistribution(
        AccountingDistribution _accountingDistribution,
        SourceDocumentLineItem _accDistSourceDocumentLineItem,
        SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        boolean canCreateProjectDistribution;

        if (!canCreateProjectDistributionMap.exists(_accountingDistribution.RecId))
        {
            AccountingPolicy            accountingPolicy;
            AccountingDistributionRule  accountingDistributionRule;

            if (_accDistSourceDocumentLineItem is PayrollPayStatementEarningSourceDocLine)
            {
                // Project distributions for payroll pay statement earning lines are created through a different path.
                return false;
            }
            
            if (this.canMonetaryAmountCreateProjectDistribution(_accountingDistribution))
            {
                if (_accountingDistribution.LedgerDimension == this.getTopDistributionLedgerDimension(_accountingDistribution))
                {
                    canCreateProjectDistribution = true;
                }
                else
                {
                    canCreateProjectDistribution = this.canCreateProjDistributionForTaxRecoverable(
                        _accountingDistribution, _accDistSourceDocumentLineItem, _topSourceDocumentLineItem);
                }
            }
            else
            {
                accountingPolicy = this.getAccountingPolicy(_accDistSourceDocumentLineItem);

                accountingDistributionRule = accountingPolicy.parmDistributionRule(_accountingDistribution.MonetaryAmount);
                canCreateProjectDistribution = ProjectSourceDocumentLineItemHelper::isLedgerPostingTypeProject(accountingDistributionRule.parmLedgerPostingType());

                if (isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                    && _accDistSourceDocumentLineItem is PayrollPayStatementSourceDocumentLine
                    && _accDistSourceDocumentLineItem.parmOriginSourceDocumentLineItem())
                {
                    canCreateProjectDistribution = true;
                }
            }

            if (canCreateProjectDistribution)
            {
                canCreateProjectDistributionMap.insert(_accountingDistribution.RecId, NoYes::Yes);
            }
            else
            {
                canCreateProjectDistributionMap.insert(_accountingDistribution.RecId, NoYes::No);
            }
        }
        else
        {
            if (canCreateProjectDistributionMap.lookup(_accountingDistribution.RecId) == NoYes::Yes)
            {
                canCreateProjectDistribution = true;
            }
        }

        return canCreateProjectDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createChildDistributions</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void createChildDistributions(AccountingDistribution _parentAccountingDistribution, ProjectAccountingDistribution _parentProjectAccountingDistribution)
    {
        AccountingDistribution          childAccountingDistribution;
        ProjectAccountingDistribution   childProjectAccountingDistribution;
        SourceDocumentLineItem          accDistSourceDocumentLineItem;
        SourceDocumentLineItem          topSourceDocumentLineItem;

        boolean skipUpdateFundingSource;

        if (_parentProjectAccountingDistribution)
        {
            topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(_parentAccountingDistribution.SourceDocumentLine);
            skipUpdateFundingSource = ProjFundingLimitTrackingManager::isUsingDocumentMatching(topSourceDocumentLineItem);

            while select childAccountingDistribution
                where childAccountingDistribution.ParentDistribution == _parentAccountingDistribution.RecId
            {
                accDistSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(childAccountingDistribution.SourceDocumentLine));

                if (this.canCreateProjectDistribution(childAccountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem))
                {
                    childProjectAccountingDistribution.clear();
                    childProjectAccountingDistribution.data(_parentProjectAccountingDistribution);
                    if (childAccountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice
                        && childAccountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess
                        && !ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(childAccountingDistribution.MonetaryAmount))
                    {
                        childProjectAccountingDistribution.TransactionCurrencyPrice = 0;
                    }
                    ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(childAccountingDistribution, childProjectAccountingDistribution, accDistSourceDocumentLineItem);
                    childProjectAccountingDistribution.initFromAccountingDistribution(childAccountingDistribution);
                    childProjectAccountingDistribution.insert(skipUpdateFundingSource);
                    this.createChildDistributions(childAccountingDistribution, childProjectAccountingDistribution);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createForProjectRevenueLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the corresponding project accounting distribution record for the accounting distribution
    /// of the source document line item that is used to accrue project revenues.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution of the source document line item that is used to accrue project revenues.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createForProjectRevenueLine(AccountingDistribution _accountingDistribution)
    {
        ProjectAccountingDistribution   projectAccountingDistribution;
        AccountingDistribution          referenceAccountingDistribution;
        ProjectAccountingDistribution   referenceProjectAccountingDistribution;

        projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.RecId, true);
        if (!projectAccountingDistribution)
        {
            if (!_accountingDistribution.ReferenceDistribution)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            referenceAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ReferenceDistribution);
            if (!referenceAccountingDistribution)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            referenceProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referenceAccountingDistribution.RecId);
            if (!referenceProjectAccountingDistribution)
            {
                // When projects are in another legal entity, we don't have project accounting extension.
                return;
            }

            projectAccountingDistribution.clear();
            projectAccountingDistribution.ProjTable = referenceProjectAccountingDistribution.ProjTable;
            projectAccountingDistribution.ProjCategory = referenceProjectAccountingDistribution.ProjCategory;
            projectAccountingDistribution.SmmActivities = referenceProjectAccountingDistribution.SmmActivities;
            projectAccountingDistribution.ProjFundingSource = referenceProjectAccountingDistribution.ProjFundingSource;
            projectAccountingDistribution.ProjLineProperty = referenceProjectAccountingDistribution.ProjLineProperty;
            projectAccountingDistribution.Currency = 0;
            projectAccountingDistribution.TransactionCurrencyPrice = 0;
            projectAccountingDistribution.TaxGroupHeading = 0;
            projectAccountingDistribution.TaxItemGroupHeading = 0;
            projectAccountingDistribution.initFromAccountingDistribution(_accountingDistribution);
            projectAccountingDistribution.insert();
        }
        else
        {
            ProjectAccountingDistribution::fieldModifiedTransCurrencyAmountPost(_accountingDistribution, projectAccountingDistribution);
            projectAccountingDistribution.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromOriginSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the corresponding project accounting distribution record for an accounting distribution
    /// that is based on an accounting distribution record of an existing source document line.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createFromOriginSourceDocumentLine(
        AccountingDistribution  _accountingDistribution,
        SourceDocumentLineItem  _accDistSourceDocumentLineItem,
        SourceDocumentLineItem  _topSourceDocumentLineItem)
    {
        AccountingDistribution          originAccountingDistribution;
        ProjectAccountingDistribution   originProjectAccountingDistribution;
        List                            originAccountingDistributionList;
        List                            newOriginAccountingDistributionList;
        ListEnumerator                  originAccountingDistributionListEnumerator;
        boolean                         originAccountingDistributionFound;
        str                             key;

        key = int642str(_accountingDistribution.SourceDocumentLine) + '#' + int2str(enum2int(_accountingDistribution.MonetaryAmount));
        if (originAccountingDistributionMap.exists(key))
        {
            newOriginAccountingDistributionList = new List(Types::Record);
            originAccountingDistributionFound = false;

            originAccountingDistributionList = originAccountingDistributionMap.lookup(key);
            originAccountingDistributionListEnumerator = originAccountingDistributionList.getEnumerator();
            while (originAccountingDistributionListEnumerator.moveNext())
            {
                originAccountingDistribution = originAccountingDistributionListEnumerator.current();
                if (!originAccountingDistributionFound &&
                    originAccountingDistribution.LedgerDimension == _accountingDistribution.LedgerDimension &&
                    originAccountingDistribution.AllocationFactor == _accountingDistribution.AllocationFactor)
                {
                    originAccountingDistributionFound = true;

                    originProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(originAccountingDistribution.RecId);
                    if (originProjectAccountingDistribution)
                    {
                        this.createFromProjectAccountingDistribution(_accountingDistribution, _accDistSourceDocumentLineItem, _topSourceDocumentLineItem, originProjectAccountingDistribution);
                    }
                }
                else
                {
                    newOriginAccountingDistributionList.addEnd(originAccountingDistribution);
                }
            }

            originAccountingDistributionMap.remove(key);
            originAccountingDistributionMap.insert(key, newOriginAccountingDistributionList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccDistCostAmountWithPriceVariance</Name>
				<Source><![CDATA[
    private Amount getAccDistCostAmountWithPriceVariance(AccountingDistribution _accountDistribution)
    {
        AccountingDistribution accountingDistribution;

        if (_accountDistribution)
        {
            select sum(TransactionCurrencyAmount) from accountingDistribution
                where accountingDistribution.RecId == _accountDistribution.RecId
                   || (accountingDistribution.ParentDistribution == _accountDistribution.RecId
                        && accountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance);
        }

        return accountingDistribution.TransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromProjectAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the corresponding project accounting distribution record for an accounting distribution
    /// based on an existing project accounting distribution record.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    /// <param name="_projectAccountingDistribution">
    /// The existing project accounting distribution that the new project accounting distribution will be based on.
    /// </param>
    /// <param name="_doSpecialFundingSourceAllocation">
    /// true if special funding source allocation is needed.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createFromProjectAccountingDistribution(
        AccountingDistribution          _accountingDistribution,
        SourceDocumentLineItem          _accDistSourceDocumentLineItem,
        SourceDocumentLineItem          _topSourceDocumentLineItem,
        ProjectAccountingDistribution   _projectAccountingDistribution,
        boolean                         _doSpecialFundingSourceAllocation = false)
    {
        ProjectAccountingDistribution   projectAccountingDistribution, referenceProjectAccountingDistribution;
        AccountingDistribution          originAccountingDistribution, parentAccountingDistribution, referenceAccountingDistribution;
        SourceDocumentLineItem          originAccDistSourceDocumentLineItem;
        PurchLine                       purchLine;
        boolean                         canUpdateTransCurrencyAmount = true;
        boolean                         projAccDistributionSkipUpdateFundingSource = false;

        boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());

        if (_projectAccountingDistribution)
        {
            if (this.canCreateChildProjectDistribution(
                _accountingDistribution,
                _accDistSourceDocumentLineItem,
                _topSourceDocumentLineItem,
                _projectAccountingDistribution))
            {
                projectAccountingDistribution.clear();
                projectAccountingDistribution.data(_projectAccountingDistribution);

                if (_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                {
                    purchLine = PurchLine::findBySourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

                    if (projectAccountingDistribution.smmActivities == 0 && purchLine.ActivityNumber != '')
                    {
                        projectAccountingDistribution.smmActivities = smmActivities::find(purchLine.ActivityNumber).RecId;
                    }

                    if (purchLine.ProjId != '')
                    {
                        ProjTable projTable = ProjTable::find(purchLine.ProjId);
                        if (projTable)
                        {
                            // In reversal scenario, we should create the reversal entry using original project accounting distribution's projId.
                            // When flight is enabled and it's reversal scenario, ProjectAccountingDistribution's projId will be used for reversal 
                            // else existing logic of overriding the projId with purchLine projId will execute.

                            if (ProjFixCommittedCostWhenChangePurchLineProjIdFlight::instance().isEnabled()) 
                            {
                                if (_accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing)
                                {
                                    projectAccountingDistribution.ProjTable = projTable.RecId;
                                }
                            }
                            else
                            {
                                projectAccountingDistribution.ProjTable = projTable.RecId;
                            }
                        }
                    }
                    
                    if (purchLine.ProjCategoryId != '')
                    {
                        ProjCategory projCategory = ProjCategory::find(purchLine.ProjCategoryId);
                        if (projCategory)
                        {
                            projectAccountingDistribution.ProjCategory = projCategory.RecId;
                        }
                    }
                                
                    // Setting sales currency for project accounting distribution.
                    Currency currency = Currency::find(purchLine.ProjSalesCurrencyId);
                    if (currency)
                    {
                        projectAccountingDistribution.Currency = currency.RecId;
                    }
                    
                    if ((purchLine.ProcurementCategory || !purchLine.StockedProduct) &&
                        purchLine.InventRefId &&
                        purchLine.InventRefTransId &&
                        purchLine.LineAmount < 0)
                    {
                        projectAccountingDistribution.ProjItemTransCost = 0;
                        projectAccountingDistribution.ProjItemTransSale = 0;
                    }

                    if (purchLine.isCanceled())
                    {
                        canUpdateTransCurrencyAmount = false;
                    }
                }
                
                if (_accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice
                    && _accountingDistribution.MonetaryAmount != MonetaryAmount::PayrollCost
                    && _accountingDistribution.MonetaryAmount != MonetaryAmount::PayrollLiability
                    && _accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess)
                {
                    projectAccountingDistribution.TransactionCurrencyPrice = 0;
                }

                boolean calculateTotalSalesPriceWithoutRetention = ProjSalesPriceWithoutRetentionFeatureHelper::isFeatureEnabled();
                boolean transitionFlightIsEnable = ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled();
                if (ProjectSourceDocumentLineItemHelper::canUpdateTransactionCurrencyPrice(_accDistSourceDocumentLineItem))
                {
                    projectAccountingDistribution.TransactionCurrencyPrice = this.calculateTransactionCurrencyPrice(_accDistSourceDocumentLineItem);
                    if ((_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable ||
                        _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance) &&
                        (_topSourceDocumentLineItem is SourceDocumentLineItemIProduct ||
                            _topSourceDocumentLineItem is TrvExpTransSourceDocLineItem))
                    {
                        SourceDocumentLineItemIProduct sourceDocumentLineItemIProduct;
                        if (_topSourceDocumentLineItem is SourceDocumentLineItemIProduct)
                        {
                            sourceDocumentLineItemIProduct = _topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
                        }

                        boolean skipSettingTransactionCurrency;
                        if (transitionFlightIsEnable && _topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                        {
                            // For vendor retention scenario, when the feature is enabled, then either when it is non recoverable tax variance
                            // or non recoverable tax and is project retention release, then the transaction amount should be 0.
                            // Reason is that we won't post the amount to project transacitons in these scenarios.
                            VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = _topSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                            boolean processFeatureAsEnable = ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                                vendorInvoiceRetentionCalcFeature,
                                vendorInvoiceLineSourceDocLineItem.parmLotId());

                            if ((processFeatureAsEnable
                                    || calculateTotalSalesPriceWithoutRetention)
                                && (_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance
                                    || (_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                                        && vendorInvoiceLineSourceDocLineItem.isProjRetentionRelease())))
                            {
                                projectAccountingDistribution.TransactionCurrencyPrice = 0;
                                projectAccountingDistribution.TransactionCurrencyAmount = 0;
                                skipSettingTransactionCurrency = true;
                            }
                        }

                        if (transitionFlightIsEnable
                            &&_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
                            && (_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                                || (streamLinePricesFeature
                                    && _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)))
                        {
                            if (_accountingDistribution.ReferenceDistribution)
                            {
                                AccountingDistribution refAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ReferenceDistribution);
                                if (refAccountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                                    && refAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::None
                                    && _accountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                                    && (_accountingDistribution.AllocationFactor + refAccountingDistribution.AllocationFactor == 0))
                                {
                                    ProjectAccountingDistribution refTaxProjAccountingDistribution =
                                        ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.ReferenceDistribution);
                                    if (refTaxProjAccountingDistribution)
                                    {
                                        // This is NonRecoverable tax reversal, which the amount should be the
                                        // same negative of the referenced accounting distribution amount.
                                        projectAccountingDistribution.TransactionCurrencyPrice = refTaxProjAccountingDistribution.TransactionCurrencyPrice;
                                        projectAccountingDistribution.TransactionCurrencyAmount = -refTaxProjAccountingDistribution.TransactionCurrencyAmount;
                                        skipSettingTransactionCurrency = true;
                                    }
                                }
                            }
                        }

                        if (!skipSettingTransactionCurrency)
                        {
                            if (sourceDocumentLineItemIProduct
                                && ProjectSourceDocumentLineItemHelper::verifyCostPriceEqualsSalesPrice(sourceDocumentLineItemIProduct))
                            {
                                if (streamLinePricesFeature)
                                {
                                    projectAccountingDistribution.TransactionCurrencyPrice = 0;
                                    projectAccountingDistribution.TransactionCurrencyAmount = 0;
                                    AmountCur taxCostPrice = CurrencyExchangeHelper::price(_accountingDistribution.TransactionCurrencyAmount, _accountingDistribution.TransactionCurrency);
                                    if (taxCostPrice)
                                    {
                                        Amount taxSalesPrice =  AccDistProcessorProjectExtension::transTurnover(_topSourceDocumentLineItem, taxCostPrice);
                                        projectAccountingDistribution.TransactionCurrencyPrice = taxSalesPrice;
                                        projectAccountingDistribution.TransactionCurrencyAmount = taxSalesPrice;
                                    }
                                }
                                else
                                {
                                    projectAccountingDistribution.TransactionCurrencyPrice = CurrencyExchangeHelper::price(_accountingDistribution.TransactionCurrencyAmount, _accountingDistribution.TransactionCurrency);
                                    projectAccountingDistribution.TransactionCurrencyAmount = _accountingDistribution.TransactionCurrencyAmount;
                                }
                            }
                            else
                            {
                                // For the case of cost price is not the same as sales price, add markup to the tax amount.
                                AmountCur taxCostPrice = CurrencyExchangeHelper::price(_accountingDistribution.TransactionCurrencyAmount, _accountingDistribution.TransactionCurrency);
                                AmountCur taxSalesPrice = 0;
                                VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            
                                boolean noVendorRetentionCalculation = calculateTotalSalesPriceWithoutRetention
                                    || (transitionFlightIsEnable
                                        && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                                            vendorInvoiceRetentionCalcFeature,
                                            vendInvInfoLine.InventTransId));

                                if (((transitionFlightIsEnable && taxCostPrice != 0)
                                        || (!transitionFlightIsEnable && taxCostPrice > 0))
                                    || !noVendorRetentionCalculation)
                                {
                                    taxSalesPrice =  AccDistProcessorProjectExtension::transTurnover(_topSourceDocumentLineItem, taxCostPrice);
                                }
                                else if (vendInvInfoLine && (vendInvInfoLine.PSAReleasePercent || vendInvInfoLine.PSAReleaseAmount))
                                {
                                    taxSalesPrice -= projectAccountingDistribution.TransactionCurrencyAmount;
                                }

                                projectAccountingDistribution.TransactionCurrencyPrice = taxSalesPrice;
                                projectAccountingDistribution.TransactionCurrencyAmount = taxSalesPrice;
                            }
                        }
                        canUpdateTransCurrencyAmount = false;
                    }
                }

                originAccountingDistribution = AccountingDistribution::find(_projectAccountingDistribution.AccountingDistribution);
                originAccDistSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(originAccountingDistribution.SourceDocumentLine));

                Qty origQty = ProjectAccountingDistribution::quantity(originAccountingDistribution, originAccDistSourceDocumentLineItem);
                Qty qty = ProjectAccountingDistribution::quantity(_accountingDistribution, _accDistSourceDocumentLineItem);

                if (qty == origQty
                    && projectAccountingDistribution.TransactionCurrencyPrice == _projectAccountingDistribution.TransactionCurrencyPrice
                    && (!streamLinePricesFeature
                        || originAccountingDistribution.TransactionCurrencyAmount == _accountingDistribution.TransactionCurrencyAmount)
                    && (!transitionFlightIsEnable
                    || !(originAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::None
                        && _accountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing)))
                {
                    // For reversing case, it should not be set to the same amount from the referenced accounting distribution amount.
                    // However, this will only be checked when transitionFlightIsEnable is enabled in case for regression.
                    projectAccountingDistribution.TransactionCurrencyAmount = _projectAccountingDistribution.TransactionCurrencyAmount;
                }
                else if (canUpdateTransCurrencyAmount)
                {
                    boolean useOriginAccDist = _accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                        && _accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice;

                    useOriginAccDist = useOriginAccDist && qty != origQty && this.existQuantityVarianceDistribution(_accountingDistribution);
                    
                    if (useOriginAccDist)
                    {
                        ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(_accountingDistribution, projectAccountingDistribution, originAccDistSourceDocumentLineItem);
                    }
                    else
                    {
                        ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(_accountingDistribution, projectAccountingDistribution, _accDistSourceDocumentLineItem);
                    }
                }

                // Discount and project adjustment is factor into the parent transaction
                if (_accountingDistribution.MonetaryAmount == MonetaryAmount::Discount ||
                    _accountingDistribution.MonetaryAmount == MonetaryAmount::PriceAdjustment)
                {
                    projectAccountingDistribution.TransactionCurrencyPrice = 0;
                    projectAccountingDistribution.TransactionCurrencyAmount = 0;
                    canUpdateTransCurrencyAmount = false;
                }
                else if (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem && purchLine &&
                    purchLine.ProjSalesPrice != _projectAccountingDistribution.TransactionCurrencyPrice)
                {
                    if (ProjFundingLimitMultiFundingSourcesFixFlight::instance().isEnabled())
                    {
                        projectAccountingDistribution.TransactionCurrencyPrice = purchLine.ProjSalesPrice;
                        projectAccountingDistribution.TransactionCurrencyAmount = purchLine.ProjSalesPrice * purchLine.PurchQty * _accountingDistribution.AllocationFactor;
                    }
                    else
                    {
                        projectAccountingDistribution.TransactionCurrencyAmount = purchLine.ProjSalesPrice * purchLine.PurchQty;
                    }
                }
                else if(_accDistSourceDocumentLineItem is ChargeSourceDocLineItem && purchLine)
                {
                    projectAccountingDistribution.TransactionCurrencyAmount = _accountingDistribution.TransactionCurrencyAmount;
                }

                VendInvoiceInfoLine vendInvInfoLine;
                VendInvoiceInfoLine_Project vendInvInfoLine_Project;
                VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem;
                boolean updateProjAccDistTransactionCurrencyPrice = true;

                if (canUpdateTransCurrencyAmount && _accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    vendorInvoiceLineSourceDocLineItem = _accDistSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;

                    vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendorInvoiceLineSourceDocLineItem.parmSourceDocumentLine().RecId);
                    vendInvInfoLine_Project = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvInfoLine.RecId);
                    
                    if (vendInvInfoLine_Project)
                    {
                        SalesQty receiveNowQty;

                        // In the case of partial or overdelivery, original quantity has to be used for ExtendedPrice distribution
                        // as transaction amount is split between ExtendedPrice and QuantityVariance distribuitions.
                        if (_accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                            && qty != origQty
                            && this.existQuantityVarianceDistribution(_accountingDistribution))
                        {
                            receiveNowQty = origQty;
                        }
                        else
                        {
                            receiveNowQty = vendInvInfoLine.ReceiveNow;
                        }

                        if (vendInvInfoLine.purchLine().PurchUnit != UnitOfMeasure::find(vendInvInfoLine_Project.ProjSalesUnitId).Symbol
                                && vendInvInfoLine.ItemId)
                        {
                            receiveNowQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                                vendInvInfoLine.ItemId,
                                vendInvInfoLine.InventDimId,
                                receiveNowQty,
                                vendInvInfoLine.purchLine().PurchUnit,
                                UnitOfMeasure::find(vendInvInfoLine_Project.ProjSalesUnitId).Symbol,
                                NoYes::Yes);
                        }

                        Amount expectedSalesAmount = vendInvInfoLine_Project.ProjSalesPrice * receiveNowQty;
                        if (streamLinePricesFeature)
                        {
                            expectedSalesAmount = expectedSalesAmount * _accountingDistribution.AllocationFactor;
                        }

                        if (expectedSalesAmount != _projectAccountingDistribution.TransactionCurrencyAmount)
                        {
                            if (streamLinePricesFeature)
                            {
                                this.setSalesAmountForVendorInvoice(_accountingDistribution, projectAccountingDistribution, vendInvInfoLine, vendInvInfoLine_Project);
                            }
                            else
                            {
                                projectAccountingDistribution.TransactionCurrencyAmount = (vendInvInfoLine_Project.ProjSalesPrice * _accountingDistribution.AllocationFactor) * receiveNowQty;
                            }
                        }
                    }

                    if (updateProjAccDistTransactionCurrencyPrice)
                    {
                        if (streamLinePricesFeature)
                        {
                            projectAccountingDistribution.TransactionCurrencyPrice = vendInvInfoLine_Project.ProjSalesPrice;
                        }
                        else
                        {
                            projectAccountingDistribution.TransactionCurrencyPrice = vendorInvoiceLineSourceDocLineItem.parmProjectSalesPrice();
                        }
                    }

                    if (_accountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance)
                    {
                        // Price variance only refers to a change in cost price, so the sales amount for this distribution is 0
                        projectAccountingDistribution.TransactionCurrencyAmount = 0;
                    }
                    else if (_accountingDistribution.MonetaryAmount == MonetaryAmount::QuantityVariance)
                    {
                        projectAccountingDistribution.calcQtyVarianceTransactionAmount(_accountingDistribution, vendorInvoiceLineSourceDocLineItem);
                    }
                }

                projectAccountingDistribution.initFromAccountingDistribution(_accountingDistribution);

                if (_accDistSourceDocumentLineItem is PayrollPayStatementBenefitSourceDocLine
                    || _accDistSourceDocumentLineItem is PayrollPayStatementTaxSourceDocLine)
                {
                    if (PayrollPayStatementLine::findBySourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId).ReversedPayStatementLine)
                    {
                        // Set the sign on the transaction amount accordingly for the reversing distribution
                        projectAccountingDistribution.TransactionCurrencyAmount = -projectAccountingDistribution.TransactionCurrencyAmount;

                        // Clear out the ProjCostTransCost FK value from the originally posted buffer so that this distribution can be posted
                        projectAccountingDistribution.ProjCostTransCost = 0;
                    }
                }

                ProjLineProperty projLineProperty = ProjectSourceDocumentLineItemHelper::projLineProperty(_accDistSourceDocumentLineItem);

                if (projLineProperty)
                {
                    projectAccountingDistribution.ProjLineProperty = projLineProperty.RecId;
                }

                SalesPrice modifiedTransactionCurrencyAmount;

                if (canUpdateTransCurrencyAmount &&
                    (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem  && purchLine.ProjSalesPrice != _projectAccountingDistribution.TransactionCurrencyAmount) ||
                    (_accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem && (vendInvInfoLine_Project.ProjSalesPrice != _projectAccountingDistribution.TransactionCurrencyAmount)))
                {
                    modifiedTransactionCurrencyAmount = vendInvInfoLine_Project.ProjSalesPrice ?
                        vendInvInfoLine_Project.ProjSalesPrice * vendInvInfoLine.ReceiveNow * _accountingDistribution.AllocationFactor:
                        purchLine.ProjSalesPrice * purchLine.PurchQty * _accountingDistribution.AllocationFactor;
                }
                
                // If SDL uses amount matching, allocate funding sources differently
                if (_doSpecialFundingSourceAllocation)
                {
                    ProjSalesCurrencyCode projSalesCurrencyCode = Currency::findRecId(projectAccountingDistribution.Currency).CurrencyCode;
                   
                    if (projSalesCurrencyCode == _accountingDistribution.TransactionCurrency)
                    {
                        if (modifiedTransactionCurrencyAmount)
                        {
                            projectAccountingDistribution.TransactionCurrencyAmount = modifiedTransactionCurrencyAmount;
                        }
                        else
                        {
                            projectAccountingDistribution.TransactionCurrencyAmount = _projectAccountingDistribution.TransactionCurrencyAmount;
                        }
                    }
                    else
                    {
                        if (modifiedTransactionCurrencyAmount)
                        {
                            projectAccountingDistribution.TransactionCurrencyAmount = modifiedTransactionCurrencyAmount;
                        }
                        else
                        {
                            projectAccountingDistribution.TransactionCurrencyAmount = CurrencyExchangeHelper::curAmount2CurAmount(
                                _projectAccountingDistribution.TransactionCurrencyAmount,
                                _accountingDistribution.TransactionCurrency,
                                projSalesCurrencyCode,
                                _accountingDistribution.AccountingDate,
                                false);
                        }
                    }

                    // Calculate the amount if vendor retention cost amount calculation feature is disabled.
                    if (vendorInvoiceLineSourceDocLineItem
                        && !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                            vendorInvoiceRetentionCalcFeature,
                            vendorInvoiceLineSourceDocLineItem))
                    {
                        // Calculate the amount if this invoice has vendor payment retention terms.
                        projectAccountingDistribution.TransactionCurrencyAmount =
                            vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                                _accountingDistribution, projectAccountingDistribution.TransactionCurrencyAmount);
                    }
                    else if (streamLinePricesFeature && vendInvInfoLine_Project)
                    {
                        this.setSalesAmountForVendorInvoice(_accountingDistribution, projectAccountingDistribution, vendInvInfoLine, vendInvInfoLine_Project);
                    }
                    
                    this.insertProjectAccDistributon(projectAccountingDistribution, _accountingDistribution, true);
                    this.doSpecialFundingSourceAllocation(_accountingDistribution, projectAccountingDistribution);
                }
                else
                {
                    if (canUpdateTransCurrencyAmount && vendorInvoiceLineSourceDocLineItem)
                    {
                        vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(
                            vendorInvoiceLineSourceDocLineItem.parmSourceDocumentLine().RecId);

                        // Calculate the amount if this invoice has vendor payment retention terms.
                        if(_accountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance)
                        {
                            projectAccountingDistribution.TransactionCurrencyAmount = 0;
                            if (streamLinePricesFeature)
                            {
                                projectAccountingDistribution.TransactionCurrencyPrice = 0;
                            }
                        }
                        else if (vendInvInfoLine.PSARetainagePercent || vendInvInfoLine.PSAReleaseAmount)
                        {
                            boolean noVendorRetentionCalculation = calculateTotalSalesPriceWithoutRetention
                                || (transitionFlightIsEnable &&
                                    ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                                        vendorInvoiceRetentionCalcFeature,
                                        vendInvInfoLine.InventTransId));

                            if (noVendorRetentionCalculation)
                            {
                                if (!streamLinePricesFeature)
                                {
                                    // If streamLinePricesFeature is enabled, the amount has been calculated and recalculation is not needed.
                                    projectAccountingDistribution.TransactionCurrencyAmount = vendInvInfoLine_Project.ProjSalesPrice 
                                        * vendInvInfoLine.ReceiveNow * _accountingDistribution.AllocationFactor;
                                }
                            }
                            else
                            {
                                projectAccountingDistribution.TransactionCurrencyAmount = AccDistProcessorProjectExtension::calcTransCurrencyAmountWithRetention(vendorInvoiceLineSourceDocLineItem, vendInvInfoLine, _accountingDistribution, _accDistSourceDocumentLineItem);
                            }

                            if (streamLinePricesFeature && vendInvInfoLine.ReceiveNow)
                            {
                                projectAccountingDistribution.TransactionCurrencyPrice = vendInvInfoLine_Project.ProjSalesPrice;
                            }

                        }
                        else if (streamLinePricesFeature && vendInvInfoLine_Project)
                        {
                            this.setSalesAmountForVendorInvoice(_accountingDistribution, projectAccountingDistribution, vendInvInfoLine, vendInvInfoLine_Project);
                        }
                    }
                    this.insertProjectAccDistributon(projectAccountingDistribution, _accountingDistribution, false);
                }
            }
        }
        else // no parent project accounting distribution YET so get the PAD from Parent's Reference
        {
            if (_accountingDistribution.ParentDistribution)
            {
                parentAccountingDistribution = this.getTopParentAccountingDistribution(_accountingDistribution);
                referenceAccountingDistribution = AccountingDistribution::find(parentAccountingDistribution.ReferenceDistribution);
                if (referenceAccountingDistribution)
                {
                    referenceProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referenceAccountingDistribution.RecId);
                    projectAccountingDistribution.data(referenceProjectAccountingDistribution);

                    projectAccountingDistribution.initFromAccountingDistribution(_accountingDistribution);

                    // If SDL uses amount matching, allocate funding sources differently
                    if (_doSpecialFundingSourceAllocation)
                    {
                        projectAccountingDistribution.TransactionCurrencyAmount = 0;
                        this.insertProjectAccDistributon(projectAccountingDistribution, _accountingDistribution, true);
                        this.doSpecialFundingSourceAllocation(_accountingDistribution, projectAccountingDistribution);
                    }
                }
            }
        } 
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjectAccDistributon</Name>
				<Source><![CDATA[
    private void insertProjectAccDistributon(ProjectAccountingDistribution projectAccountingDistribution, 
                AccountingDistribution _accountingDistribution, boolean projAccDistributionSkipUpdateFundingSource)
    {
        if (ProjFundingLimitCheckforChargesFlight_ProjectPurch::instance().isEnabled()
                && _accountingDistribution.MonetaryAmount == MonetaryAmount::Charge
                && !ProjFundingLimitTrackingManager::isWithinFundingLimitProjAcctDist(projectAccountingDistribution, _accountingDistribution))
        {
            throw error("@SYS136009");
        }
        else
        {
            projectAccountingDistribution.insert(projAccDistributionSkipUpdateFundingSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTransCurrencyAmountWithRetention</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the project accounting distribution transaction currency amount with retetnion.
    /// </summary>
    /// <param name="_vendorInvoiceLineSourceDocLineItem">
    /// The vendor invoice line source doc line item.
    /// </param>
    /// <param name="_vendInvInfoLine">
    /// The vendor invoice info line.
    /// </param>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <returns>
    /// The transaction currency amount for the project accounting distribution.
    /// </returns>
    public static AmountCur calcTransCurrencyAmountWithRetention(VendorInvoiceLineSourceDocLineItem _vendorInvoiceLineSourceDocLineItem, VendInvoiceInfoLine _vendInvInfoLine, AccountingDistribution _accountingDistribution, SourceDocumentLineItem  _accDistSourceDocumentLineItem)
    {
        AmountCur transactionCurrencyAmount = 0;
        if (_vendorInvoiceLineSourceDocLineItem)
        {
            AmountCur transAmountForRetention = _vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                                     _accountingDistribution, _vendInvInfoLine.LineAmount * _accountingDistribution.AllocationFactor, false);
            // Calculate the sales amount.
            if (transAmountForRetention == 0)
            {
                transactionCurrencyAmount = AccDistProcessorProjectExtension::calculateSalesAmountFromProjSalesPrice(_accountingDistribution, _accDistSourceDocumentLineItem);
            }
            else
            {
                transactionCurrencyAmount = AccDistProcessorProjectExtension::transTurnover(_accDistSourceDocumentLineItem, transAmountForRetention);
            }
        }
        return transactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromProjectAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the corresponding project accounting distribution record for an accounting distribution
    /// based on the project allocation setup.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createFromProjectAllocation(
        AccountingDistribution  _accountingDistribution,
        SourceDocumentLineItem  _accDistSourceDocumentLineItem,
        SourceDocumentLineItem  _topSourceDocumentLineItem)
    {
        SourceDocumentLineItemIProject  sourceDocumentLineItemIProject;
        List                            newLedgerDimensionAllocationList;
        ListEnumerator                  ledgerDimensionAllocationListEnumerator;
        LedgerDimensionAccount          ledgerDimension;
        AllocationFactor                allocationFactor;
        ProjFundingSourceRefId          projFundingSourceRefId;
        boolean                         ledgerDimensionAllocationFound;
        AccountingDistribution          accountingDistributionCompare;
        str                             key;
        List                            ledgerDimensionAllocationList;
        ProjectAccountingDistribution   projectAccountingDistribution;
        boolean                         canCreateFromProjectAllocations;
        List                            accountingDistributionList;
        List                            newAccountingDistributionList;
        ListEnumerator                  accountingDistributionListEnumerator;
        SourceDocumentLineRecId         sourceDocumentLineRecId;
        RecVersion                      sourceDocumentLineRecVersion;
        List                            projectDistributionList;
        ListEnumerator                  projectDistributionListEnumerator;
        List                            newProjectDistributionList;
        AllocationFactor                projectAllocationFactor;
        AmountCur                       projectTransactionCurrencyAmount;
        boolean                         projectAllocationFactorFound;
        SourceDocumentLine              sourceDocumentLine;
        boolean                         sysCondition;
        boolean                         psCondition;
        CustInvoiceLine                 custInvoiceLine;
        boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());

        sourceDocumentLineItemIProject = _topSourceDocumentLineItem as SourceDocumentLineItemIProject;

        key = int642str(_accountingDistribution.SourceDocumentLine) + '#' + int2str(enum2int(_accountingDistribution.MonetaryAmount));

        if (!accountingDistributionMap.exists(key))
        {
            canCreateFromProjectAllocations = true;
        }
        else
        {
            newAccountingDistributionList = new List(Types::Int64);

            accountingDistributionList = accountingDistributionMap.lookup(key);
            accountingDistributionListEnumerator = accountingDistributionList.getEnumerator();
            while (accountingDistributionListEnumerator.moveNext())
            {
                if (AccountingDistribution::exist(accountingDistributionListEnumerator.current()))
                {
                    newAccountingDistributionList.addEnd(accountingDistributionListEnumerator.current());
                }
            }

            if (!newAccountingDistributionList.elements())
            {
                canCreateFromProjectAllocations = true;
            }
        }

        if (canCreateFromProjectAllocations)
        {
            sourceDocumentLine            = _topSourceDocumentLineItem.parmSourceDocumentLine();
            sourceDocumentLineRecId       = sourceDocumentLine.RecId;
            sourceDocumentLineRecVersion  = sourceDocumentLine.RecVersion;
            ledgerDimensionAllocationList = SysTransactionScopeCache::get(classStr(AccDistProcessorProjectExtension), [sourceDocumentLineRecId, sourceDocumentLineRecVersion], null);
        }
        else
        {
            ledgerDimensionAllocationList = null;
        }

        if (ledgerDimensionAllocationList)
        {
            newLedgerDimensionAllocationList = new List(Types::Container);
            ledgerDimensionAllocationFound = false;

            ledgerDimensionAllocationListEnumerator = ledgerDimensionAllocationList.getEnumerator();
            while (ledgerDimensionAllocationListEnumerator.moveNext())
            {
                [ledgerDimension, allocationFactor, projFundingSourceRefId] = ledgerDimensionAllocationListEnumerator.current();
                accountingDistributionCompare.LedgerDimension = ledgerDimension;
                accountingDistributionCompare.AllocationFactor = allocationFactor;

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    || isConfigurationkeyEnabled(configurationKeyNum(Project))
                )
                {
                    custInvoiceLine = CustInvoiceLine::findBySourceDocumentLine(_accountingDistribution.SourceDocumentLine);

                    psCondition = !ledgerDimensionAllocationFound
                        && (_accountingDistribution.LedgerDimension == accountingDistributionCompare.LedgerDimension
                            || custInvoiceLine.ProjId && custInvoiceLine.ProjCategoryId)
                        && _accountingDistribution.AllocationFactor == accountingDistributionCompare.AllocationFactor;
                }

                sysCondition = !ledgerDimensionAllocationFound
                    && _accountingDistribution.LedgerDimension == accountingDistributionCompare.LedgerDimension
                    && _accountingDistribution.AllocationFactor == accountingDistributionCompare.AllocationFactor;

                if (sysCondition || psCondition)
                {
                    ledgerDimensionAllocationFound = true;

                    projectAccountingDistribution.clear();
                    projectAccountingDistribution.initFromSourceDocumentLineItem(_topSourceDocumentLineItem);
                    projectAccountingDistribution.ProjFundingSource = projFundingSourceRefId;

                    if (_accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice
                        && _accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess
                        && !ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(_accountingDistribution.MonetaryAmount))
                    {
                        projectAccountingDistribution.TransactionCurrencyPrice = 0;
                    }

                    if (projectAccountingDistribution.TransactionCurrencyPrice)
                    {
                        boolean getProjfundingEngineRevenueList = SysTransactionScopeCache::get(identifierStr(ProjFundingEngineRevenueList), [_accountingDistribution.SourceDocumentLine, _accountingDistribution.MonetaryAmount]);

                        if (getProjfundingEngineRevenueList)
                        {
                            newProjectDistributionList = new List(Types::Container);
                            projectAllocationFactorFound = false;
                            projectDistributionList = SysTransactionScopeCache::get(identifierStr(ProjFundingEngineRevenueList), [_accountingDistribution.SourceDocumentLine, _accountingDistribution.MonetaryAmount]);
                            projectDistributionListEnumerator = projectDistributionList.getEnumerator();
                            while (projectDistributionListEnumerator.moveNext())
                            {
                                [projectAllocationFactor, projectTransactionCurrencyAmount] = projectDistributionListEnumerator.current();
                                if (!projectAllocationFactorFound && allocationFactor == projectAllocationFactor)
                                {
                                    PurchLine purchLine = PurchLine::findBySourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                                    
                                    if (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
                                        && purchLine.PurchUnit != purchLine.ProjSalesUnitId
                                        && purchLine.ItemId)
                                    {
                                        SalesQty salesQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                                            purchLine.ItemId,
                                            purchLine.InventDimId,
                                            purchLine.PurchQty,
                                            purchLine.PurchUnit,
                                            purchLine.ProjSalesUnitId,
                                            NoYes::Yes);
                                      
                                        if (_accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                                            && _accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
                                            && streamLinePricesFeature)
                                        {
                                            this.setSalesAmountForPurchLine(_accountingDistribution, projectAccountingDistribution, purchLine, true, salesQty);
                                            projectAllocationFactorFound = true;
                                        }
                                        else
                                        {
                                            projectAccountingDistribution.TransactionCurrencyAmount = CurrencyExchangeHelper::amount(
                                                salesQty * purchLine.ProjSalesPrice * allocationFactor, purchLine.CurrencyCode);
                                            projectAllocationFactorFound = true;
                                        }
                                    }
                                    else if (_accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                                        && _accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
                                        && purchLine
                                        && purchLine.ProjId
                                        && streamLinePricesFeature)
                                    {
                                        this.setSalesAmountForPurchLine(_accountingDistribution, projectAccountingDistribution, purchLine);
                                        projectAllocationFactorFound = true;
                                    }
                                    else if (_accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                                        && _accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                                        && streamLinePricesFeature)
                                    {
                                        VendInvoiceInfoLine_Project vendInvInfoLine_Project;
                                        VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = _accDistSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                                        VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendorInvoiceLineSourceDocLineItem.parmSourceDocumentLine().RecId);
                                        vendInvInfoLine_Project = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvInfoLine.RecId);
                                        this.setSalesAmountForVendorInvoice(_accountingDistribution, projectAccountingDistribution, vendInvInfoLine, vendInvInfoLine_Project);
                                        projectAllocationFactorFound = true;
                                    }
                                    else
                                    {
                                        projectAccountingDistribution.TransactionCurrencyAmount = projectTransactionCurrencyAmount;
                                        projectAllocationFactorFound = true;
                                    }
                                }
                                else
                                {
                                    newProjectDistributionList.addEnd([projectAllocationFactor, projectTransactionCurrencyAmount]);
                                }
                            }
                            SysTransactionScopeCache::remove(identifierStr(ProjFundingEngineRevenueList), [_accountingDistribution.SourceDocumentLine, _accountingDistribution.MonetaryAmount]);
                            if (newProjectDistributionList.elements())
                            {
                                SysTransactionScopeCache::set(identifierStr(ProjFundingEngineRevenueList), [_accountingDistribution.SourceDocumentLine, _accountingDistribution.MonetaryAmount], newProjectDistributionList);
                            }
                        }
                        else
                        {
                            ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(_accountingDistribution, projectAccountingDistribution, _accDistSourceDocumentLineItem);
                            if (_accountingDistribution.MonetaryAmount == MonetaryAmount::Discount ||
                                _accountingDistribution.MonetaryAmount == MonetaryAmount::PriceAdjustment)
                            {
                                projectAccountingDistribution.TransactionCurrencyAmount = 0;
                                projectAccountingDistribution.TransactionCurrencyPrice = 0;
                            }
                            else if (streamLinePricesFeature && _accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                            {
                                VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                                VendInvoiceInfoLine_Project projVendInvInfoLine = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvInfoLine.RecId);

                                this.setSalesAmountForVendorInvoice(_accountingDistribution, projectAccountingDistribution, vendInvInfoLine, projVendInvInfoLine);
                            }
                        }
                    }

                    projectAccountingDistribution.initFromAccountingDistribution(_accountingDistribution);
                    projectAccountingDistribution.insert();
                }
                else
                {
                    newLedgerDimensionAllocationList.addEnd([ledgerDimension, allocationFactor, projFundingSourceRefId]);
                }
            }

            SysTransactionScopeCache::remove(classStr(AccDistProcessorProjectExtension), [sourceDocumentLineRecId, sourceDocumentLineRecVersion]);
            if (newLedgerDimensionAllocationList.elements())
            {
                SysTransactionScopeCache::set(classStr(AccDistProcessorProjectExtension), [sourceDocumentLineRecId, sourceDocumentLineRecVersion], newLedgerDimensionAllocationList);
            }
        }
        else if (ProjectSourceDocumentLineItemHelper::useTemplate(_topSourceDocumentLineItem, _accountingDistribution.MonetaryAmount))
        {
            projectAccountingDistribution.clear();
            projectAccountingDistribution.initFromSourceDocumentLineItem(_topSourceDocumentLineItem);

            changecompany(CompanyInfo::findRecId(_accountingDistribution.AccountingLegalEntity).DataArea)
            {
                projectAccountingDistribution.ProjFundingSource = ProjTable::findRecId(projectAccountingDistribution.ProjTable).defaultFundingSource();
            }

            if (_accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice
                && _accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess
                && !ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(_accountingDistribution.MonetaryAmount))
            {
                projectAccountingDistribution.TransactionCurrencyPrice = 0;
            }

            if (projectAccountingDistribution.TransactionCurrencyPrice)
            {
                ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(_accountingDistribution, projectAccountingDistribution, _accDistSourceDocumentLineItem);
            }
            projectAccountingDistribution.initFromAccountingDistribution(_accountingDistribution);
            if (!ProjFundingLimitTrackingManager::isWithinFundingLimitProjAcctDist(projectAccountingDistribution, _accountingDistribution))
            {
                throw error("@SYS136009");
            }
            ProjectAccountingDistribution::writeProjectAccountingDistribution(_accountingDistribution, projectAccountingDistribution);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromReversedDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the corresponding project accounting distribution record for an accounting distribution
    /// based on a reversed accounting distribution record.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createFromReversedDistribution(
        AccountingDistribution  _accountingDistribution,
        SourceDocumentLineItem  _accDistSourceDocumentLineItem,
        SourceDocumentLineItem  _topSourceDocumentLineItem)
    {
        AccountingDistribution          reversedAccountingDistribution;
        ProjectAccountingDistribution   reversedProjectAccountingDistribution;
        List                            reversedAccountingDistributionList;
        List                            newReversedAccountingDistributionList;
        ListEnumerator                  reversedAccountingDistributionListEnumerator;
        boolean                         reversedAccountingDistributionFound;
        str                             key;

        key = int642str(_accountingDistribution.SourceDocumentLine) + '#' + int2str(enum2int(_accountingDistribution.MonetaryAmount));
        if (reversedAccountingDistributionMap.exists(key))
        {
            newReversedAccountingDistributionList = new List(Types::Record);
            reversedAccountingDistributionFound = false;

            reversedAccountingDistributionList = reversedAccountingDistributionMap.lookup(key);
            reversedAccountingDistributionListEnumerator = reversedAccountingDistributionList.getEnumerator();
            while (reversedAccountingDistributionListEnumerator.moveNext())
            {
                reversedAccountingDistribution = reversedAccountingDistributionListEnumerator.current();
                if (!reversedAccountingDistributionFound &&
                    reversedAccountingDistribution.SourceDocumentLine == _accountingDistribution.SourceDocumentLine &&
                    reversedAccountingDistribution.MonetaryAmount == _accountingDistribution.MonetaryAmount &&
                    reversedAccountingDistribution.AllocationFactor == _accountingDistribution.AllocationFactor)
                {
                    reversedAccountingDistributionFound = true;

                    reversedProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(reversedAccountingDistribution.RecId);
                    if (reversedProjectAccountingDistribution)
                    {
                        this.createFromProjectAccountingDistribution(_accountingDistribution, _accDistSourceDocumentLineItem, _topSourceDocumentLineItem, reversedProjectAccountingDistribution);
                    }
                }
                else
                {
                    newReversedAccountingDistributionList.addEnd(reversedAccountingDistribution);
                }
            }

            reversedAccountingDistributionMap.remove(key);
            reversedAccountingDistributionMap.insert(key, newReversedAccountingDistributionList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromSourceDocumentLineItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the corresponding project accounting distribution record for an accounting distribution
    /// based on the source document line item.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createFromSourceDocumentLineItem(
        AccountingDistribution          _accountingDistribution,
        SourceDocumentLineItem          _accDistSourceDocumentLineItem,
        SourceDocumentLineItem          _topSourceDocumentLineItem)
    {
        ProjectAccountingDistribution   projectAccountingDistribution;
        ProjTable                       projTable;
        ProjInvoiceTable                projInvoiceTable;
        ProjFundingSource               projFundingSourceLocal;
        ProjTrans                       projTrans;
        ProjFundingEngine               projFundingEngine;
        MapEnumerator                   enumerateMap;
        Map                             saleDistributions = new Map(Types::Int64, Types::Real);

        projectAccountingDistribution.clear();
        projectAccountingDistribution.initFromSourceDocumentLineItem(_topSourceDocumentLineItem);
        projectAccountingDistribution.ProjFundingSource = 0;

        if (_accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice
            && _accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess
            && !ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(_accountingDistribution.MonetaryAmount))
        {
            projectAccountingDistribution.TransactionCurrencyPrice = 0;
        }

        if (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            PurchLine purchLine = PurchLine::findBySourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
            
            if (purchLine.PurchUnit != purchLine.ProjSalesUnitId && purchLine.ItemId)
            {
                SalesQty salesQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                    purchLine.ItemId,
                    purchLine.InventDimId,
                    purchLine.PurchQty,
                    purchLine.PurchUnit,
                    purchLine.ProjSalesUnitId,
                    NoYes::Yes);

                if (FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance()))
                {
                    this.setSalesAmountForPurchLine(_accountingDistribution, projectAccountingDistribution, purchLine, true, salesQty);
                }
                else
                {
                    projectAccountingDistribution.TransactionCurrencyAmount = CurrencyExchangeHelper::amount(salesQty * purchLine.ProjSalesPrice, purchLine.CurrencyCode);
                }
            }
            else
            {
                projectAccountingDistribution.TransactionCurrencyAmount = CurrencyExchangeHelper::amount(
                    purchLine.PurchQty * purchLine.ProjSalesPrice, purchLine.CurrencyCode);
            }

            if (ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled())
            {
                PurchOrderLineSourceDocumentLineItem purchOrderLineSourceDocumentLineItem = _accDistSourceDocumentLineItem as PurchOrderLineSourceDocumentLineItem;
                projectAccountingDistribution.ProjFundingSource = purchOrderLineSourceDocumentLineItem.parmProjectFundingSourceRecId();
            }
        }
        else
        {
            ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(_accountingDistribution, projectAccountingDistribution, _accDistSourceDocumentLineItem);
        }

        projectAccountingDistribution.initFromAccountingDistribution(_accountingDistribution);

        // Inventory requires a singele distribution.  Attempt to create based on rules
        projTrans = ProjFundingLimitTrackingManager::createProjTransFromProjDist(projectAccountingDistribution, _accountingDistribution);
        if (projTrans && projectAccountingDistribution.ProjFundingSource == 0)
        {
            projFundingEngine = ProjFundingEngine::construct(projTrans, 0.0, projTrans.transTurnover(), false);
            projFundingEngine.parmSingleFundingSourceRequired(true);
            if (projFundingEngine.allocate())
            {
                saleDistributions = projFundingEngine.parmSaleDistributions();
                enumerateMap = new MapEnumerator(saleDistributions);
                while (enumerateMap.moveNext())
                {
                    projectAccountingDistribution.ProjFundingSource = enumerateMap.currentKey();
                }
            }
        }

        if (projectAccountingDistribution.ProjFundingSource == 0)
        {
            // Find a valid funding source so record can be created. --
            projTable = ProjectSourceDocumentLineItemHelper::projTable(_topSourceDocumentLineItem);
            changecompany (projTable.DataAreaId)
            {
                projInvoiceTable = projTable.projInvoice();

                select firstonly RecId from projFundingSourceLocal
                    where projFundingSourceLocal.ContractId == projInvoiceTable.ProjInvoiceProjId &&
                          (projFundingSourceLocal.FundingType == ProjFundingType::Customer ||
                          projFundingSourceLocal.FundingType == ProjFundingType::Grant);
            }

            projectAccountingDistribution.ProjFundingSource = projFundingSourceLocal.RecId;
        }

        if (!ProjFundingLimitTrackingManager::isWithinFundingLimitProjAcctDist(projectAccountingDistribution, _accountingDistribution))
        {
            throw error("@SYS136009");
        }

        projectAccountingDistribution.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteChildDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes child project accounting distributions for the parent accounting distribution.
    /// </summary>
    /// <param name="_parentAccountingDistribution">
    /// The parent accounting distribution.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void deleteChildDistributions(RefRecId _parentAccountingDistribution)
    {
        AccountingDistribution          childAccountingDistribution;
        ProjectAccountingDistribution   childProjectAccountingDistribution;

        while select RecId from childAccountingDistribution
                where childAccountingDistribution.ParentDistribution == _parentAccountingDistribution
            join forupdate childProjectAccountingDistribution
                where childProjectAccountingDistribution.AccountingDistribution == childAccountingDistribution.RecId
        {
            childProjectAccountingDistribution.delete();
            this.deleteChildDistributions(childAccountingDistribution.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCurrentTrackingInfo</Name>
				<Source><![CDATA[
    private Map deleteCurrentTrackingInfo(AccountingDistribution accountingDistribution, boolean isTaxDeleted)
    {
        ProjFundingLimitTracking        projFundingLimitTracking;
        Map                             mapDeletedTaxTracking = new Map(Types::Int64, Types::Class);
        List                            listTaxTracking = new List(Types::Record);

        delete_from projFundingLimitTracking where projFundingLimitTracking.AccountingDistribution == accountingDistribution.RecId;

        if (isTaxDeleted)
        {
            if (mapDeletedTaxTracking.exists(accountingDistribution.RecId))
            {
                mapDeletedTaxTracking.remove(accountingDistribution.RecId);
            }

            while select projFundingLimitTracking where projFundingLimitTracking.SourceAccountingDistribution == accountingDistribution.RecId &&
                                                        projFundingLimitTracking.Reversing == NoYes::Yes
            {
                listTaxTracking.addEnd(projFundingLimitTracking);
            }

            if (listTaxTracking.elements() > 0)
            {
                mapDeletedTaxTracking.insert(accountingDistribution.RecId, listTaxTracking);
            }
        }

        delete_from projFundingLimitTracking where projFundingLimitTracking.SourceAccountingDistribution == accountingDistribution.RecId &&
                                                   projFundingLimitTracking.Reversing == NoYes::Yes;

        return mapDeletedTaxTracking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSpecialFundingSourceAllocation</Name>
				<Source><![CDATA[
    private void doSpecialFundingSourceAllocation(AccountingDistribution            _accountingDistribution,
                                                  ProjectAccountingDistribution     projectAccountingDistribution)
    {
        ProjTrans                       projTrans;
        AmountCur                       amountToCheckAgainstLimit;
        List                            listFundingLimitTracking = new List(Types::Record);
        List                            listNewFundingLimit;
        List                            listReversedFundingLimit = new List(Types::Record);
        str                             mapKey;
        int                             addTaxReferenceRevert; // 0 - empty cache, 1 - recently added, 2 - updated

        void insertZeroFundingLimitTracking()
        {
            ProjFundingLimitTracking        projFundingLimitTracking;

            projFundingLimitTracking.clear();
            projFundingLimitTracking.ProjFundingLimit               = 0;
            projFundingLimitTracking.SourceDocumentHeader           = _accountingDistribution.SourceDocumentHeader;
            projFundingLimitTracking.SourceDocumentLine             = _accountingDistribution.SourceDocumentLine;
            projFundingLimitTracking.AccountingDistribution         = _accountingDistribution.RecId;
            projFundingLimitTracking.ProjectAccountingDistribution  = projectAccountingDistribution.RecId;
            projFundingLimitTracking.sdCreditLine                   = NoYes::No;
            projFundingLimitTracking.Reversing                      = NoYes::No;
            projFundingLimitTracking.Amount                         = 0;
            projFundingLimitTracking.insert();

            listNewFundingLimit.addEnd(projFundingLimitTracking);
        }

        listNewFundingLimit = new List(Types::Record);

        projTrans = ProjFundingLimitTrackingManager::createProjTransFromProjDist(projectAccountingDistribution, _accountingDistribution);

        if (projTrans)
        {
            if (projTrans.transTurnover() != 0.0)
            {
                amountToCheckAgainstLimit = remainingAmount + projTrans.transTurnover();

                if (amountToCheckAgainstLimit <= 0)
                {
                    remainingAmount = amountToCheckAgainstLimit;
                    insertZeroFundingLimitTracking();
                    newFundingLimitList.insert(_accountingDistribution.RecId, listNewFundingLimit);
                }
                else
                {
                    remainingAmount = 0;

                    changecompany (CompanyInfo::findRecId(_accountingDistribution.AccountingLegalEntity).DataArea)
                    {
                        listNewFundingLimit = ProjFundingEngine::setFundTrackingForDistribution(_accountingDistribution, projectAccountingDistribution, amountToCheckAgainstLimit);
                        newFundingLimitList.insert(_accountingDistribution.RecId, listNewFundingLimit);
                    }
                }

                if (_accountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance ||
                   _accountingDistribution.MonetaryAmount == MonetaryAmount::QuantityVariance ||
                   _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
                {
                    return;
                }

                mapKey = strFmt("%1#%2",_accountingDistribution.RecId,_accountingDistribution.ReferenceDistribution);

                if (_accountingDistribution.ReferenceDistribution && referenceAccountingDistributionMap.exists(mapKey))
                {
                    listFundingLimitTracking = referenceAccountingDistributionMap.lookup(mapKey);

                    if (listFundingLimitTracking.elements() > 0)
                    {
                        ProjFundingLimitTrackingManager::allocateFundingLimitTrackingFromList(listFundingLimitTracking);
                        referenceAccountingDistributionMap.remove(mapKey);

                        listReversedFundingLimit = ProjFundingLimitTrackingManager::reverseFundingLimitForNewDistribution(listFundingLimitTracking, _accountingDistribution);

                        newReversedFundingLimitList.appendList(listReversedFundingLimit);
                    }
                }
                else if (_accountingDistribution.ParentDistribution && _accountingDistribution.ReferenceDistribution ==0)
                {
                    newFundingLimitList.remove(_accountingDistribution.RecId);
                    newTaxDistributionsMap.insert(_accountingDistribution.RecId, listNewFundingLimit);
                    mapKey = strFmt("%1#%2",_accountingDistribution.RecId,_accountingDistribution.ParentDistribution);

                    addTaxReferenceRevert = SysTransactionScopeCache::get(#TaxScopeCache, _accountingDistribution.ParentDistribution, 0);

                    if (addTaxReferenceRevert == 1)
                    {
                        SysTransactionScopeCache::set(#TaxScopeCache, _accountingDistribution.ParentDistribution, 2);
                    }

                    if (referenceAccountingDistributionMap.exists(mapKey))
                    {
                        listFundingLimitTracking = referenceAccountingDistributionMap.lookup(mapKey);

                        // 0 - empty cache, 1 - recently added, 2 - updated
                        if (addTaxReferenceRevert < 2 && listFundingLimitTracking.elements() > 0)
                        {
                            listReversedFundingLimit = this.updateTaxReversingFundingLimit(_accountingDistribution, listFundingLimitTracking);
                            referenceAccountingDistributionMap.remove(mapKey);

                            newTaxReversedFundingLimitList.appendList(listReversedFundingLimit);

                            if (taxReferenceFundingLimitMap.exists(_accountingDistribution.RecId))
                            {
                                taxReferenceFundingLimitMap.remove(_accountingDistribution.RecId);
                            }

                            taxReferenceFundingLimitMap.insert(_accountingDistribution.RecId, newTaxReversedFundingLimitList);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingPolicy</Name>
				<Source><![CDATA[
    private AccountingPolicy getAccountingPolicy(SourceDocumentLineItem _accDistSourceDocumentLineItem)
    {
        AccountingPolicy    accountingPolicy;
        AccountingPolicy    sourceDocumentLineAccountingPolicy;

        if (!isSourceDocumentAccountingPolicyInitialized)
        {
            if (accountingDistributionProcessor)
            {
                sourceDocumentLineAccountingPolicy = accountingDistributionProcessor.parmSourceDocumentLineAccountingPolicy();

                if (sourceDocumentLineAccountingPolicy)
                {
                    sourceDocumentAccountingPolicy = sourceDocumentLineAccountingPolicy.parmSourceDocumentAccountingPolicy();
                }
            }

            isSourceDocumentAccountingPolicyInitialized = true;
        }

        if (sourceDocumentAccountingPolicy)
        {
            accountingPolicy = sourceDocumentAccountingPolicy.getAccountingPolicyForLineItem(_accDistSourceDocumentLineItem);
        }
        else
        {
            accountingPolicy = AccountingPolicy::newPolicy(_accDistSourceDocumentLineItem);
        }

        return accountingPolicy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtendedPriceLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the extended price ledger dimension of the top source document line.
    /// </summary>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    /// <returns>
    /// The extended price ledger dimension of the top source document line.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected LedgerDimensionAccount getExtendedPriceLedgerDimension(SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        LedgerDimensionAccount  ledgerDimension;
        AccountingDistribution  accountingDistribution;

        select firstonly LedgerDimension from accountingDistribution
            where accountingDistribution.SourceDocumentLine == _topSourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                    (accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollCost
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollLiability
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess);

        ledgerDimension = accountingDistribution.LedgerDimension;

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the parent accounting distribution and project accounting distribution.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution for which the parent accounting distribution and project accounting
    /// distribution would be retrieved.
    /// </param>
    /// <returns>
    /// A container that contains the parent accounting distribution and project accounting distribution.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container getParentAccountingDistribution(AccountingDistribution _accountingDistribution)
    {
        AccountingDistribution          parentAccountingDistribution;
        ProjectAccountingDistribution   parentProjectAccountingDistribution;

        if (_accountingDistribution.ParentDistribution)
        {
            parentAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ParentDistribution);
            if (parentAccountingDistribution)
            {
                parentProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(parentAccountingDistribution.RecId);
            }
        }

        return [parentAccountingDistribution, parentProjectAccountingDistribution];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record in the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the ledger dimension is for an intercompany transaction.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The <c>AccountingPolicy</c> for the source document line item.
    /// This variable is not used in the default logic, but is provided for extensibility reasons.
    /// </param>
    /// <returns>
    /// The project ledger dimension.
    /// </returns>
    protected static LedgerDimensionDefaultAccount getProjectLedgerDimension(
        ProjTable               _projTable,
        ProjCategory            _projCategory,
        ProjFundingSource       _projFundingSource,
        ProjLineProperty        _projLineProperty,
        boolean                 _isIntercompany,
        SourceDocumentLineItem  _topSourceDocumentLineItem)
    {
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            defaultLedgerDimension = ProjectPosting::getProjectLedgerDimensionWhenProjOpsIntegrationEnabled(_projTable,
                                                                                                    _projCategory,
                                                                                                    _projFundingSource,
                                                                                                    _projLineProperty,
                                                                                                    _topSourceDocumentLineItem,
                                                                                                    _isIntercompany);
        }
        else
        {
            defaultLedgerDimension = ProjectPosting::getProjectLedgerDimension(_projTable, _projCategory, _projFundingSource, _projLineProperty, _isIntercompany);
        }
        return defaultLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReferenceAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the reference accounting distribution and project accounting distribution.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution for which the reference accounting distribution and project accounting
    /// distribution would be retrieved.
    /// </param>
    /// <returns>
    /// A container of the reference accounting distribution and project accounting distribution.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container getReferenceAccountingDistribution(AccountingDistribution _accountingDistribution)
    {
        AccountingDistribution          referenceAccountingDistribution;
        ProjectAccountingDistribution   referenceProjectAccountingDistribution;
        RecId                           referenceDistribution;

        if (_accountingDistribution.ReferenceDistribution)
        {
            referenceDistribution = _accountingDistribution.ReferenceDistribution;
            while (referenceDistribution && !referenceProjectAccountingDistribution)
            {
                referenceAccountingDistribution = AccountingDistribution::find(referenceDistribution);
                referenceProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referenceAccountingDistribution.RecId);
                referenceDistribution = referenceAccountingDistribution.ReferenceDistribution;
            }
        }

        return [referenceAccountingDistribution, referenceProjectAccountingDistribution];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTopDistributionLedgerDimension</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected LedgerDimensionAccount getTopDistributionLedgerDimension(AccountingDistribution _childAccountingDistribution)
    {
        AccountingDistribution  parentAccountingDistribution;
        LedgerDimensionAccount  ledgerDimension;

        if (_childAccountingDistribution.ParentDistribution)
        {
            parentAccountingDistribution = AccountingDistribution::find(_childAccountingDistribution.ParentDistribution);
            if (parentAccountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                || parentAccountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess
                || ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(parentAccountingDistribution.MonetaryAmount))
            {
                ledgerDimension = parentAccountingDistribution.LedgerDimension;
            }
            else
            {
                ledgerDimension = this.getTopDistributionLedgerDimension(parentAccountingDistribution);
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTopParentAccountingDistribution</Name>
				<Source><![CDATA[
    private AccountingDistribution getTopParentAccountingDistribution(AccountingDistribution _accountingDistribution)
    {
        AccountingDistribution parentAccountingDistribution;

        select firstonly parentAccountingDistribution where parentAccountingDistribution.RecId == _accountingDistribution.ParentDistribution;

        if (parentAccountingDistribution.ParentDistribution != 0)
        {
            parentAccountingDistribution = this.getTopParentAccountingDistribution(parentAccountingDistribution);
        }

        return parentAccountingDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPOTaxSpecialCase</Name>
				<Source><![CDATA[
    // A specical case for PO when a PR was created and the tax distributions are not carried over to PO
    // In this case, there won't be any tracking limit for the tax distributions for PO
    // We would need to do a check for this situation and make sure to allocate the funding tracking correctly by
    // temporarily removing reference doc tracking (parent and tax)
    private boolean isPOTaxSpecialCase(AccountingDistribution _accountingDistribution, SourceDocumentLineItem _topSourceDocumentLineItem, boolean _recalculateTaxFundingLimit)
    {
        ProjFundingLimitTracking currentLimitTracking;
        ProjFundingLimitTracking reversedLimitTracking;
        ProjFundingLimitTracking referenceLimitTracking;
        AccountingDistribution parentDistribution;
        AccountingDistribution childDistribution;
        boolean retval = false;

        if (_recalculateTaxFundingLimit ||
           _accountingDistribution.MonetaryAmount != MonetaryAmount::TaxNonRecoverable)
        {
            return false;
        }

        if (_accountingDistribution.ReferenceDistribution && _accountingDistribution.ParentDistribution && _topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            select firstonly RecId from currentLimitTracking where currentLimitTracking.AccountingDistribution ==  _accountingDistribution.RecId
                join RecId from reversedLimitTracking where reversedLimitTracking.SourceAccountingDistribution == currentLimitTracking.AccountingDistribution;

            if (currentLimitTracking.RecId == 0)
            {
                // parent of the current tax distribution
                // reference of the parent is the parent of the current tax distribution's reference
                parentDistribution = AccountingDistribution::find(_accountingDistribution.ParentDistribution);

                this.releaseFundingLimitTrackingRecords(_accountingDistribution);

                while select referenceLimitTracking where referenceLimitTracking.AccountingDistribution == parentDistribution.ReferenceDistribution
                {
                    listPOSpecialCaseTaxTracking.addEnd(referenceLimitTracking);
                }

                referenceLimitTracking.clear();

                while select RecId from childDistribution where childDistribution.ParentDistribution == parentDistribution.ReferenceDistribution
                    join forupdate referenceLimitTracking where referenceLimitTracking.AccountingDistribution == childDistribution.RecId
                {
                    listPOSpecialCaseTaxTracking.addEnd(referenceLimitTracking);
                    referenceLimitTracking.doDelete();
                }

                if (listPOSpecialCaseTaxTracking.elements() > 0)
                {
                    delete_from referenceLimitTracking where referenceLimitTracking.AccountingDistribution == parentDistribution.ReferenceDistribution;

                    retval = true;
                }
                else
                {
                    retval = false;
                }
            }
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProcessFundingRuleAllocation</Name>
				<Source><![CDATA[
    private void postProcessFundingRuleAllocation(List listTaxReference, boolean isCurrentAmountLessReference)
    {
        AccountingDistribution accountingDistribution;
        SourceDocumentLineItem topSourceDocumentLineItem;
        SourceDocumentLineItem accDistSourceDocumentLineItem;
        MapEnumerator          mapEnumerator, taxMapEnumerator;
        List                   listFundingLimits = new List(Types::Record);
        List                   listFundingLimitTracking = new List(Types::Record);

        // Reallocate parent reference funding sources that were deleted prior to allocating current source document
        if (reversedCurrentFundingLimitMap.elements() > 0)
        {
            mapEnumerator = reversedCurrentFundingLimitMap.getEnumerator();

            while (mapEnumerator.moveNext())
            {
                accDistSourceDocumentLineItem = mapEnumerator.currentValue();

                if (!accDistSourceDocumentLineItem.parmSourceDocumentLine().ParentSourceDocumentLine)
                {
                    topSourceDocumentLineItem = accDistSourceDocumentLineItem;
                }
                else
                {
                    topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                }

                if (!topSourceDocumentLineMap.exists(accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId))
                {
                    topSourceDocumentLineMap.insert(accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId, topSourceDocumentLineItem);
                }

                this.processSpecialFundingDistributions(accDistSourceDocumentLineItem, topSourceDocumentLineItem);
            }
        }

        // If the current document total amount is less than the reference document
        // We need to reverse the amount used in the current document to prevent overcommitting when the current document is canceled
        if (newFundingLimitList.elements() > 0 && newReversedFundingLimitList.elements() > 0 && isCurrentAmountLessReference)
        {
            ProjFundingLimitTrackingManager::deleteFundingLimitTrackingFromList(newReversedFundingLimitList);
            mapEnumerator = newFundingLimitList.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                accountingDistribution = AccountingDistribution::find(mapEnumerator.currentKey());
                listFundingLimits = mapEnumerator.currentValue();
                ProjFundingLimitTrackingManager::reverseFundingLimitForNewDistribution(listFundingLimits, accountingDistribution);
            }
        }

        if (taxReferenceFundingLimitMap.elements() > 0 && isCurrentAmountLessReference)
        {
            taxMapEnumerator = taxReferenceFundingLimitMap.getEnumerator();
            while (taxMapEnumerator.moveNext())
            {
                accountingDistribution = AccountingDistribution::find(taxMapEnumerator.currentKey());
                listFundingLimitTracking = taxMapEnumerator.currentValue();
                ProjFundingLimitTrackingManager::deleteFundingLimitTrackingFromList(listFundingLimitTracking);
                listFundingLimits = newTaxDistributionsMap.lookup(taxMapEnumerator.currentKey());

                ProjFundingLimitTrackingManager::reverseTaxFundingLimitForNewDistribution(listFundingLimits, accountingDistribution);
            }
        }

        if (listTaxReference.elements() > 0)
        {
            ProjFundingLimitTrackingManager::allocateFundingLimitTrackingFromList(listTaxReference);
        }

        if (listPOSpecialCaseTaxTracking.elements() > 0)
        {
            ProjFundingLimitTrackingManager::allocateFundingLimitTrackingFromList(listPOSpecialCaseTaxTracking);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDistributeFundingSources</Name>
				<Source><![CDATA[
    private void processDistributeFundingSources(SourceDocumentLineItem accDistSourceDocumentLineItem, AccountingDistribution accountingDistribution)
    {
        AccountingDistribution          referenceAccountingDistribution, parentAccountingDistribution;
        ProjectAccountingDistribution   projectAccountingDistribution, referenceProjectAccountingDistribution, parentProjectAccountingDistribution;
        SourceDocumentLine              accDistSourceDocumentLine;
        SourceDocumentLineItem          topSourceDocumentLineItem;

        List                            listFundingSources = new List(Types::Int64);
        Map                             mapFundingSource = new Map(Types::Int64, Types::Int64);
        RefRecId                        sourceDocumentLineRecId;
        boolean                         useSpecialFundingSourceAllocation;
        ProjParameters                  projParameters = ProjParameters::find();

        if (accDistSourceDocumentLineItem is SourceDocumentLineItemIProduct)
        {
            SourceDocumentLineItemIProduct sourceDocLineItemProduct = accDistSourceDocumentLineItem as SourceDocumentLineItemIProduct;
            if (ProjectSourceDocumentLineItemHelper::isProjCategoryTypeItem(accDistSourceDocumentLineItem) &&
                !sourceDocLineItemProduct.parmItemId())
            {
                useSpecialFundingSourceAllocation = true;
            }

        }

        accDistSourceDocumentLine     = accDistSourceDocumentLineItem.parmSourceDocumentLine();
        topSourceDocumentLineItem     = topSourceDocumentLineMap.lookup(accDistSourceDocumentLine.RecId);
        Debug::assert(topSourceDocumentLineItem != null);

        if (accDistSourceDocumentLineItem is ProjectRevenueSourceDocLineItem)
        {
            //Create project accounting record for the project revenue source document line item
            this.createForProjectRevenueLine(accountingDistribution);
        }
        else
        {
            //Create project accounting record for a source document line item
            projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(accountingDistribution.RecId, true);

            //In the case of AccountingDistribution transaction currency amount is not matching between ProjectAccountingDistribution transaction currency amount,
            //remove ProjectAccountingDistribution record so that data can be regenerated.
            if (accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem && projectAccountingDistribution)
            {
                AmountCur accountingDistributionTransactionCurrencyAmount = accountingDistribution.TransactionCurrencyAmount;
                VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = accDistSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                accountingDistributionTransactionCurrencyAmount = ProjectSourceDocumentLineItemHelper::getAmountWithDiscount(vendorInvoiceLineSourceDocLineItem, accountingDistributionTransactionCurrencyAmount);

                // Calculate the amount if vendor retention cost amount calculation feature is disabled.
                if (!ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                    vendorInvoiceRetentionCalcFeature,
                    vendorInvoiceLineSourceDocLineItem))
                {
                    accountingDistributionTransactionCurrencyAmount = vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                        accountingDistribution, accountingDistributionTransactionCurrencyAmount);
                }
                
                if (accountingDistributionTransactionCurrencyAmount != projectAccountingDistribution.TransactionCurrencyAmount)
                {
                    ttsbegin;
                    projectAccountingDistribution.TransactionCurrencyAmount = accountingDistributionTransactionCurrencyAmount;
                    projectAccountingDistribution.update();
                    ttscommit;
                }
            }

            if (!projectAccountingDistribution)
            {
                [referenceAccountingDistribution, referenceProjectAccountingDistribution] =
                    this.getReferenceAccountingDistribution(accountingDistribution);

                [parentAccountingDistribution, parentProjectAccountingDistribution] =
                    this.getParentAccountingDistribution(accountingDistribution);

                if (referenceAccountingDistribution || parentAccountingDistribution)
                {
                    if (parentAccountingDistribution.RecId != 0)
                    {
                        sourceDocumentLineRecId = AccountingDistribution::find(parentAccountingDistribution.ReferenceDistribution).SourceDocumentLine;
                    }
                    else
                    {
                        sourceDocumentLineRecId = referenceAccountingDistribution.SourceDocumentLine;
                    }
                }

                if (referenceAccountingDistribution)
                {
                    //Create project accounting record from a reference project accounting record.
                    this.createFromProjectAccountingDistribution(accountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem, referenceProjectAccountingDistribution, useSpecialFundingSourceAllocation);
                }
                else if (parentAccountingDistribution)
                {
                    //Create project accounting record from a parent project accounting record.
                    this.createFromProjectAccountingDistribution(accountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem, parentProjectAccountingDistribution, useSpecialFundingSourceAllocation);
                }
                else
                {
                    if (this.canCreateFromOriginSourceDocumentLine(accountingDistribution.SourceDocumentLine, accountingDistribution.MonetaryAmount, topSourceDocumentLineItem))
                    {
                        //Create project accounting record from a project accounting record of an existing source document line.
                        this.createFromOriginSourceDocumentLine(
                            accountingDistribution,
                            accDistSourceDocumentLineItem,
                            topSourceDocumentLineItem);
                    }
                    else if (this.canCreateFromReversedDistribution(accountingDistribution.SourceDocumentLine, accountingDistribution.MonetaryAmount))
                    {
                        //Create project accounting record from a reversed project accounting record.
                        this.createFromReversedDistribution(
                            accountingDistribution,
                            accDistSourceDocumentLineItem,
                            topSourceDocumentLineItem);
                    }
                    else if (ProjectSourceDocumentLineItemHelper::canProcessProject(topSourceDocumentLineItem))
                    {
                        //Create project accounting record based on project allocation setup
                        if (this.canCreateProjectDistribution(accountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem))
                        {
                            this.createFromProjectAllocation(
                                accountingDistribution,
                                accDistSourceDocumentLineItem,
                                topSourceDocumentLineItem);
                        }
                    }
                    else
                    {
                        //For stocked scenario, create project accounting record using default values from source document line item
                        if ((accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice) || (accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess) ||
                            (accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice && accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess &&
                                accountingDistribution.LedgerDimension == this.getExtendedPriceLedgerDimension(topSourceDocumentLineItem)))
                        {
                            this.createFromSourceDocumentLineItem(accountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem);
                        }
                    }
                }
            }
            else
            {
                // Delete existing Project Distributions and recreate it to re-run the funding rule allocation

                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);

                this.doSpecialFundingSourceAllocation(accountingDistribution, projectAccountingDistribution);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processed</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void processed(SourceDocumentLineItemList _sourceDocumentLineItemList)
    {
        SourceDocumentLineItemListEnumerator    sourceDocumentLineItemListEnumerator;
        SourceDocumentLineItem                  accDistSourceDocumentLineItem;
        SourceDocumentLine                      accDistSourceDocumentLine;
        SourceDocumentLineItem                  topSourceDocumentLineItem;

        AccountingDistribution                  accountingDistribution, taxPRAccountingDistribution;
        AccountingDistribution                  refAccountingDistribution;
        boolean                                 hasProject;
        boolean                                 isUsingSourceDocumentMatching = false;
        List                                    listFundingLimits = new List(Types::Record);
        List                                    listTaxReference  = new List(Types::Record);

        SourceDocumentLineItem                  taxSourceDocumentLineItem;
        List                                    listPRTaxFundingLimits = new List(Types::String);

        ListEnumerator                          listEnumerator;
        boolean                                 recalculateTaxFundingLimit, isTaxDeleted,isCurrentAmountLessReference = false;
        RefRecId                                accountingDistributionRecId, refAccountingDistributionRecId;
        Map                                     mapDeletedTaxTracking;

        SourceDocumentLineItem                  refSourceDocumentLineItem;
        SourceDocumentLineItemListEnumerator    refSourceDocumentLineItemEnum;
        SourceDocumentLineItemListEnumerator    currentSourceDocumentLineItemEnum;

        referenceAccountingDistributionMap = new Map(Types::String, Types::Class);

        newFundingLimitList = new Map(Types::Int64, Types::Class);
        newTaxDistributionsMap  = new Map(Types::Int64, Types::Class);
        newReversedFundingLimitList = new List(Types::Record);
        newTaxReversedFundingLimitList = new List(Types::Record);
        reversedCurrentFundingLimitMap = new Map(Types::Int64, Types::Class);
        taxReferenceFundingLimitMap = new Map(Types::Int64, Types::Class);
        listNewDistributions = new List(Types::Container);
        listNewTaxDistributions = new List(Types::Container);
        listPOSpecialCaseTaxTracking = new List(Types::Record);
        
        using (SysInstrumentationActivityContext activityContext = logger.projOpsFinActivity()
            .activityContext(ProjOpsFinancialsInstrumentationActivites::DistributionProcessorPostProcessing))
        {

            if (_sourceDocumentLineItemList)
            {
                sourceDocumentLineItemListEnumerator = _sourceDocumentLineItemList.getEnumerator();

                //Clear all funding limit tracking first for all the reference distributions
                // This way, you'll have FULL amount of all available funding sources
                while (sourceDocumentLineItemListEnumerator.moveNext())
                {
                    accDistSourceDocumentLineItem = sourceDocumentLineItemListEnumerator.current();
                    accDistSourceDocumentLine     = accDistSourceDocumentLineItem.parmSourceDocumentLine();

                    topSourceDocumentLineItem = topSourceDocumentLineMap.lookup(accDistSourceDocumentLine.RecId);
                    Debug::assert(topSourceDocumentLineItem != null);
                    hasProject = topSourceDocLineHasProjectMap.lookup(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

                    //early exit when SDL don't have Project
                    if (!hasProject)
                    {
                        continue;
                    }

                    isUsingSourceDocumentMatching = ProjFundingLimitTrackingManager::isUsingDocumentMatching(topSourceDocumentLineItem, skipActiveVendorInvoiceCheck);

                    if (isUsingSourceDocumentMatching && referenceDistributionTotalAmount == 0)
                    {
                        // Get the current total amount and the reference distributions total amount for the whole source line

                        select firstonly ReferenceDistribution from accountingDistribution
                                where accountingDistribution.SourceDocumentLine == topSourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                                    accountingDistribution.ReferenceDistribution > 0 ;

                        if (accountingDistribution.ReferenceDistribution)
                        {
                            refAccountingDistribution = AccountingDistribution::find(accountingDistribution.ReferenceDistribution);

                            select sum(TransactionCurrencyAmount) from accountingDistribution
                                    where accountingDistribution.SourceDocumentLine == refAccountingDistribution.SourceDocumentLine;

                            referenceDistributionTotalAmount = accountingDistribution.TransactionCurrencyAmount;

                            refSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(refAccountingDistribution.SourceDocumentLine));
                            refSourceDocumentLineItemEnum = refSourceDocumentLineItem.parmChildSourceDocumentLineItemList().getEnumerator();

                            while (refSourceDocumentLineItemEnum.moveNext())
                            {
                                select sum(TransactionCurrencyAmount) from accountingDistribution
                                        where accountingDistribution.SourceDocumentLine == refSourceDocumentLineItemEnum.current().parmSourceDocumentLine().RecId;

                                referenceDistributionTotalAmount += accountingDistribution.TransactionCurrencyAmount;
                            }

                            accountingDistribution.clear();
                            select sum(TransactionCurrencyAmount) from accountingDistribution
                                where accountingDistribution.SourceDocumentLine == topSourceDocumentLineItem.parmSourceDocumentLine().RecId;

                            currentDistributionTotalAmount = accountingDistribution.TransactionCurrencyAmount;

                            currentSourceDocumentLineItemEnum = topSourceDocumentLineItem.parmChildSourceDocumentLineItemList().getEnumerator();
                            while (currentSourceDocumentLineItemEnum.moveNext())
                            {
                                select sum(TransactionCurrencyAmount) from accountingDistribution
                                        where accountingDistribution.SourceDocumentLine == currentSourceDocumentLineItemEnum.current().parmSourceDocumentLine().RecId;

                                currentDistributionTotalAmount += accountingDistribution.TransactionCurrencyAmount;
                            }

                            isCurrentAmountLessReference = currentDistributionTotalAmount < referenceDistributionTotalAmount;
                        }

                        isTaxDeleted = ProjFundingLimitTrackingManager::areTaxFieldsDeleted(topSourceDocumentLineItem);

                        if (!isTaxDeleted)
                        {
                            recalculateTaxFundingLimit = this.areTaxFieldsChanged(topSourceDocumentLineItem);
                        }
                        else
                        {
                            recalculateTaxFundingLimit = true;
                        }

                        while select accountingDistribution
                            where accountingDistribution.SourceDocumentLine == accDistSourceDocumentLine.RecId
                        {
                            if (!this.canCreateProjectDistribution(accountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem))
                            {
                                continue;
                            }

                            mapDeletedTaxTracking = this.deleteCurrentTrackingInfo(accountingDistribution, isTaxDeleted);

                            if (!this.isPOTaxSpecialCase(accountingDistribution, topSourceDocumentLineItem, recalculateTaxFundingLimit))
                            {
                                if (accountingDistribution.ReferenceDistribution)
                                {
                                    this.releaseFundingLimitTrackingRecords(accountingDistribution);
                                }
                                else
                                {
                                    if (accountingDistribution.ParentDistribution &&
                                        accDistSourceDocumentLineItem is TaxSourceDocSublineItem &&
                                        accountingDistribution.TransactionCurrencyAmount > 0 &&
                                        (topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem || topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem))
                                    {
                                        // If the distributions don't have reference distributions, it's most likely a recalculated sales tax distributions
                                        // In this case, the reversed funding limit tracking records for the reference sales tax records are now also deleted
                                        // Bring those back to get the TRUE remaining funding amounts
                                        this.revertReferenceTaxFundingLimit(accountingDistribution);
                                    }
                                }
                            }
                        }
                    }
                }

                if (hasProject && isUsingSourceDocumentMatching)
                {
                    if (listNewDistributions.elements() > 0)
                    {
                        listEnumerator = listNewDistributions.getEnumerator();
                        while (listEnumerator.moveNext())
                        {
                            [accountingDistributionRecId, refAccountingDistributionRecId] = listEnumerator.current();
                            refAccountingDistribution = AccountingDistribution::find(refAccountingDistributionRecId); //tax parent
                            this.releaseFundingLimitTrackingRecords(refAccountingDistribution, true);
                        }
                    }

                    if (recalculateTaxFundingLimit && listNewTaxDistributions.elements() > 0)
                    {
                        listEnumerator = listNewTaxDistributions.getEnumerator();
                        while (listEnumerator.moveNext())
                        {
                            [accountingDistributionRecId, refAccountingDistributionRecId] = listEnumerator.current();

                            while select taxPRAccountingDistribution where taxPRAccountingDistribution.ParentDistribution == refAccountingDistributionRecId
                            {
                                taxSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(taxPRAccountingDistribution.SourceDocumentLine));

                                if (taxSourceDocumentLineItem is TaxSourceDocSublineItem)
                                {
                                    listTaxReference.appendList(ProjFundingLimitTrackingManager::releaseTaxFundingLimitTracking(taxPRAccountingDistribution.RecId));
                                }
                            }
                        }
                    }
                }

                sourceDocumentLineItemListEnumerator.reset();

                while (sourceDocumentLineItemListEnumerator.moveNext())
                {
                    accDistSourceDocumentLineItem = sourceDocumentLineItemListEnumerator.current();
                    accDistSourceDocumentLine = accDistSourceDocumentLineItem.parmSourceDocumentLine();
                    topSourceDocumentLineItem = topSourceDocumentLineMap.lookup(accDistSourceDocumentLine.RecId);
                    
                    Debug::assert(topSourceDocumentLineItem != null);
                    SourceDocumentLine topSourceDocumentLine = topSourceDocumentLineItem.parmSourceDocumentLine();
                    hasProject = topSourceDocLineHasProjectMap.lookup(topSourceDocumentLine.RecId);

                    if (hasProject || accDistSourceDocumentLineItem is ProjectRevenueSourceDocLineItem)
                    {
                        if (!isUsingSourceDocumentMatching)
                        {
                            this.processRegularDistributions(accDistSourceDocumentLineItem);
                        }
                        else
                        {
                            logger.logInformation(strFmt('Using source document matching for SourceDocumentLine: %1, call stack: %2',
                                topSourceDocumentLine.RecId, ProjOpsInstrumentationLogger::getCallStack(xSession::xppCallStack())));
                            this.processSpecialFundingDistributions(accDistSourceDocumentLineItem, topSourceDocumentLineItem);
                        }
                    }
                }

                // This will reallocate funding sources that were deleted prior to allocating the current source document
                // hasProject and isUsingSourceDocumentMatching should have been set to TRUE from the previous SDL iteration if the top SDL has project
                if (hasProject && isUsingSourceDocumentMatching)
                {
                    this.postProcessFundingRuleAllocation(listTaxReference, isCurrentAmountLessReference);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processing</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void processing(SourceDocumentLineItemList _sourceDocumentLineItemList)
    {
        SourceDocumentLineItemListEnumerator    sourceDocumentLineItemListEnumerator;
        SourceDocumentLineItem                  accDistSourceDocumentLineItem;
        SourceDocumentLine                      accDistSourceDocumentLine;
        SourceDocumentLineItem                  topSourceDocumentLineItem;
        AccountingDistribution                  accountingDistribution;
        AccountingDistribution                  reversingAccountingDistribution;
        str                                     key;
        List                                    reversedAccountingDistributionList;
        List                                    accountingDistributionList;
        boolean                                 hasMainAccDerivationInputChanged;

        SourceDocumentLineItemIProjectRevenue   sourceDocumentLineItemIProjectRevenue;
        SourceDocumentLineItemIProduct          sourceDocumentLineItemIProduct;
        SourceDocumentLineItemIProductQuantity  sourceDocumentLineItemIProductQuantity;
        RefRecId                                newCurrency;
        ProjSalesCurrencyCode                   newCurrencyCode;
        PriceCur                                newTransactionCurrencyPrice;
        AmountCur                               newTransactionCurrencyAmount;
        AmountCur                               evenTransactionCurrencyAmount;
        AmountCur                               remainingTransactionCurrencyAmount;
        AmountCur                               eventPlusRemainingTransactionCurrencyAmount;
        AmountCur                               evenAllocation;
        AmountCur                               remainingAllocation;
        AmountCur                               evenPlusRemainingAllocation;
        container                               con;

        using (SysInstrumentationActivityContext activityContext = logger.projOpsFinActivity()
            .activityContext(ProjOpsFinancialsInstrumentationActivites::DistributionProcessorPreProcessing))
        {
            if (_sourceDocumentLineItemList)
            {
                topSourceDocumentLineMap = new Map(Types::Int64, Types::Class);
                topSourceDocLineHasProjectMap = new Map(Types::Int64, Types::Enum);

                reversedAccountingDistributionMap = new Map(Types::String, Types::Class);
                reversalMap = new Map(Types::String, Types::Enum);

                originAccountingDistributionMap = new Map(Types::String, Types::Class);
                originMap = new Map(Types::String, Types::Enum);

                accountingDistributionMap = new Map(Types::String, Types::Class);
                ledgerDimensionAllocationMap = new Map(Types::String, Types::Class);

                distributeEqually = new Map(Types::Int64, Types::Container);

                sourceDocumentLineItemListEnumerator = _sourceDocumentLineItemList.getEnumerator();
                while (sourceDocumentLineItemListEnumerator.moveNext())
                {
                    accDistSourceDocumentLineItem = sourceDocumentLineItemListEnumerator.current();
                    accDistSourceDocumentLine     = accDistSourceDocumentLineItem.parmSourceDocumentLine();

                    if (!accDistSourceDocumentLine.ParentSourceDocumentLine)
                    {
                        topSourceDocumentLineItem = accDistSourceDocumentLineItem;
                    }
                    else
                    {
                        topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accDistSourceDocumentLine.RecId);
                    }

                    topSourceDocumentLineMap.insert(accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId, topSourceDocumentLineItem);

                    if (ProjectSourceDocumentLineItemHelper::hasProject(topSourceDocumentLineItem))
                    {
                        if (topSourceDocLineHasProjectMap.exists(topSourceDocumentLineItem.parmSourceDocumentLine().RecId))
                        {
                            topSourceDocLineHasProjectMap.remove(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                        }

                        topSourceDocLineHasProjectMap.insert(topSourceDocumentLineItem.parmSourceDocumentLine().RecId, true);

                        if (accountingDistributionProcessor &&
                            accDistSourceDocumentLine.RecId && topSourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                            accountingDistributionProcessor.parmDistributionProcessorAction()  == AccountingDistributionProcessorAction::Distribute &&
                            accountingDistributionProcessor.parmDistributionMethod() == AccountingDistributionMethod::Equally &&
                            accountingDistributionProcessor.parmTargetAccountingStatus() == SourceDocumentLineAccountingStatus::FullyDistributed)
                        {
                            newCurrency = 0;
                            newCurrencyCode = '';
                            newTransactionCurrencyPrice = 0;
                            newTransactionCurrencyAmount = 0;

                            switch (ProjectSourceDocumentLineItemHelper::projTransType(topSourceDocumentLineItem))
                            {
                                case ProjTransType::Hour:
                                case ProjTransType::Cost:
                                case ProjTransType::Item:

                                    if (!ProjectSourceDocumentLineItemHelper::implementsProjectRevenue(topSourceDocumentLineItem))
                                    {
                                        throw error(Error::wrongUseOfFunction(funcName()));
                                    }

                                    sourceDocumentLineItemIProjectRevenue = topSourceDocumentLineItem as SourceDocumentLineItemIProjectRevenue;
                                    newCurrency = ProjectSourceDocumentLineItemHelper::salesCurrency(topSourceDocumentLineItem).RecId;
                                    newCurrencyCode = sourceDocumentLineItemIProjectRevenue.parmProjectSalesCurrencyCode();
                                    newTransactionCurrencyPrice = sourceDocumentLineItemIProjectRevenue.parmProjectSalesPrice();
                                    if (!newCurrency && topSourceDocumentLineItem is SourceDocumentLineItemIProduct &&
                                        ProjParameters::find().DefaultCostPriceAsSalesPrice &&
                                        ProjectSourceDocumentLineItemHelper::isProjCategoryTypeItem(topSourceDocumentLineItem))
                                    {
                                        sourceDocumentLineItemIProduct = topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
                                        if (!sourceDocumentLineItemIProduct.parmItemId())
                                        {
                                            newCurrency = Currency::find(topSourceDocumentLineItem.parmTransactionCurrencyCode()).RecId;
                                            newCurrencyCode = topSourceDocumentLineItem.parmTransactionCurrencyCode();
                                            newTransactionCurrencyPrice = 0;
                                        }
                                    }
                                    break;

                                case ProjTransType::Revenue:
                                    newCurrency = 0;
                                    newCurrencyCode = '';
                                    newTransactionCurrencyPrice = 0;
                                    break;
                                default:
                                    throw error(Error::wrongUseOfFunction(funcName()));
                            }
                            if (topSourceDocumentLineItem is SourceDocumentLineItemIProductQuantity)
                            {
                                sourceDocumentLineItemIProductQuantity = topSourceDocumentLineItem as SourceDocumentLineItemIProductQuantity;
                            }
                            newTransactionCurrencyAmount = CurrencyExchangeHelper::amount((sourceDocumentLineItemIProductQuantity && sourceDocumentLineItemIProductQuantity.parmQuantity() ? sourceDocumentLineItemIProductQuantity.parmQuantity() : 1) * newTransactionCurrencyPrice, newCurrencyCode);

                            select count(RecId), sum(TransactionCurrencyAmount) from accountingDistribution
                                where accountingDistribution.SourceDocumentLine == accDistSourceDocumentLine.RecId &&
                                    accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                                    (accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                                    || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollCost
                                    || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollLiability
                                    || accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess)
                                notexists join reversingAccountingDistribution
                                where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                                    reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing;

                            evenTransactionCurrencyAmount = newTransactionCurrencyAmount;
                            remainingTransactionCurrencyAmount = 0;
                            eventPlusRemainingTransactionCurrencyAmount = 0;

                            evenAllocation = accountingDistribution.TransactionCurrencyAmount;
                            remainingAllocation = 0;
                            evenPlusRemainingAllocation = 0;

                            if (accountingDistribution.RecId > 1)
                            {
                                evenTransactionCurrencyAmount = CurrencyExchangeHelper::amount(evenTransactionCurrencyAmount / accountingDistribution.RecId, newCurrencyCode);
                                remainingTransactionCurrencyAmount = newTransactionCurrencyAmount - evenTransactionCurrencyAmount * accountingDistribution.RecId;
                                eventPlusRemainingTransactionCurrencyAmount = evenTransactionCurrencyAmount + remainingTransactionCurrencyAmount;

                                evenAllocation = CurrencyExchangeHelper::amount(evenAllocation / accountingDistribution.RecId, accountingDistribution.TransactionCurrency);
                                remainingAllocation = accountingDistribution.TransactionCurrencyAmount - evenAllocation * accountingDistribution.RecId;
                                evenPlusRemainingAllocation = evenAllocation + remainingAllocation;
                            }

                            con = [newCurrency, newTransactionCurrencyPrice, evenTransactionCurrencyAmount, eventPlusRemainingTransactionCurrencyAmount, evenAllocation, evenPlusRemainingAllocation];
                            distributeEqually.insert(accDistSourceDocumentLine.RecId, con);
                        }

                        hasMainAccDerivationInputChanged = topSourceDocumentLineItem.hasMainAccDerivationInputChanged();

                        while select accountingDistribution
                            order by accountingDistribution.MonetaryAmount
                            where accountingDistribution.SourceDocumentLine == accDistSourceDocumentLine.RecId &&
                                accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                            notexists join reversingAccountingDistribution
                            where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                                reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                        {
                            key = int642str(accDistSourceDocumentLine.RecId) + '#' + int2str(enum2int(accountingDistribution.MonetaryAmount));

                            if (accDistSourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed)
                            {
                                if (!hasMainAccDerivationInputChanged)
                                {
                                    if (reversedAccountingDistributionMap.exists(key))
                                    {
                                        reversedAccountingDistributionList = reversedAccountingDistributionMap.lookup(key);
                                        reversedAccountingDistributionMap.remove(key);
                                    }
                                    else
                                    {
                                        reversedAccountingDistributionList = new List(Types::Record);
                                    }
                                    reversedAccountingDistributionList.addEnd(accountingDistribution);
                                    reversedAccountingDistributionMap.insert(key, reversedAccountingDistributionList);
                                }
                            }
                            else
                            {
                                if (accountingDistributionMap.exists(key))
                                {
                                    accountingDistributionList = accountingDistributionMap.lookup(key);
                                    accountingDistributionMap.remove(key);
                                }
                                else
                                {
                                    accountingDistributionList = new List(Types::Int64);
                                }
                                accountingDistributionList.addEnd(accountingDistribution.RecId);
                                accountingDistributionMap.insert(key, accountingDistributionList);
                            }
                        }
                    }
                    else
                    {
                        if (topSourceDocLineHasProjectMap.exists(topSourceDocumentLineItem.parmSourceDocumentLine().RecId))
                        {
                            topSourceDocLineHasProjectMap.remove(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                        }

                        topSourceDocLineHasProjectMap.insert(topSourceDocumentLineItem.parmSourceDocumentLine().RecId, false);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateExistingProjAccDistByAccDist</Name>
				<Source><![CDATA[
    private boolean shouldUpdateExistingProjAccDistByAccDist(
        SourceDocumentLineItem _accDistSourceDocumentLineItem,
        AccountingDistribution _accountingDistribution)
    {
        // For PO item scenario, if user updates the PO price or amount, the project accounting
        // distribution of the previouse records should not be update again. Else it can cause
        // project funding limit tracking corruption.
        
        boolean shouldUpdateExistingDistribution = true;

        if (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
            && _accountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::None)
        {
            AccountingDistribution accountingDistribution;

            select firstonly RecId from accountingDistribution
                where accountingDistribution.ReferenceDistribution == _accountingDistribution.RecId;

            shouldUpdateExistingDistribution = accountingDistribution.RecId ? false : true;
        }

        return shouldUpdateExistingDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRegularDistributions</Name>
				<Source><![CDATA[
    private void processRegularDistributions(SourceDocumentLineItem _accDistSourceDocumentLineItem)
    {
        AccountingDistribution          accountingDistribution, referenceAccountingDistribution, parentAccountingDistribution;
        ProjectAccountingDistribution   projectAccountingDistribution, referenceProjectAccountingDistribution, parentProjectAccountingDistribution;
        SourceDocumentLine              accDistSourceDocumentLine;
        SourceDocumentLineItem          topSourceDocumentLineItem;
        RefRecId                                newCurrency;
        PriceCur                                newTransactionCurrencyPrice;
        AmountCur                               evenTransactionCurrencyAmount;
        AmountCur                               eventPlusRemainingTransactionCurrencyAmount;
        AmountCur                               evenAllocation;
        AmountCur                               evenPlusRemainingAllocation;

        boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());

        using (SysInstrumentationActivityContext activityContext = logger.projOpsFinActivity()
            .activityContext(ProjOpsFinancialsInstrumentationActivites::DistributionProcessorProcessRegularDistributions))
        {
            accDistSourceDocumentLine     = _accDistSourceDocumentLineItem.parmSourceDocumentLine();
            topSourceDocumentLineItem     = topSourceDocumentLineMap.lookup(accDistSourceDocumentLine.RecId);
            Debug::assert(topSourceDocumentLineItem != null);

            while select accountingDistribution
                where accountingDistribution.SourceDocumentLine == accDistSourceDocumentLine.RecId
            {
                if (streamLinePricesFeature
                    && !this.shouldUpdateExistingProjAccDistByAccDist(_accDistSourceDocumentLineItem, accountingDistribution))
                {
                    continue;
                }

                if (_accDistSourceDocumentLineItem is ProjectRevenueSourceDocLineItem)
                {
                    //Create project accounting record for the project revenue source document line item
                    this.createForProjectRevenueLine(accountingDistribution);

                    logger.logInformation(
                        strFmt('Created project accounting record for a project revenue source document line item. AccountingDistribution: %1',
                        accountingDistribution.RecId));
                }
                else
                {
                    //Create project accounting record for a source document line item
                    projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(accountingDistribution.RecId, true);
                    if (!projectAccountingDistribution)
                    {
                        System.Text.StringBuilder loggerMessage = new System.Text.StringBuilder('Created project accounting record for a source document line item, ');

                        [referenceAccountingDistribution, referenceProjectAccountingDistribution] =
                            this.getReferenceAccountingDistribution(accountingDistribution);

                        [parentAccountingDistribution, parentProjectAccountingDistribution] =
                            this.getParentAccountingDistribution(accountingDistribution);

                        if (referenceAccountingDistribution)
                        {
                            loggerMessage.Append('from a reference project accounting record.');

                            //Create project accounting record from a reference project accounting record.
                            this.createFromProjectAccountingDistribution(accountingDistribution, _accDistSourceDocumentLineItem, topSourceDocumentLineItem, referenceProjectAccountingDistribution);
                        }
                        else if (parentAccountingDistribution)
                        {
                            loggerMessage.Append('from a parent project accounting record.');

                            //Create project accounting record from a parent project accounting record.
                            this.createFromProjectAccountingDistribution(accountingDistribution, _accDistSourceDocumentLineItem, topSourceDocumentLineItem, parentProjectAccountingDistribution);
                        }
                        else
                        {
                            if (this.canCreateFromOriginSourceDocumentLine(accountingDistribution.SourceDocumentLine, accountingDistribution.MonetaryAmount, topSourceDocumentLineItem))
                            {
                                loggerMessage.Append('from a project accounting record of an existing source document line.');

                                //Create project accounting record from a project accounting record of an existing source document line.
                                this.createFromOriginSourceDocumentLine(
                                    accountingDistribution,
                                    _accDistSourceDocumentLineItem,
                                    topSourceDocumentLineItem);
                            }
                            else if (this.canCreateFromReversedDistribution(accountingDistribution.SourceDocumentLine, accountingDistribution.MonetaryAmount))
                            {
                                loggerMessage.Append('from a reversed project accounting record.');

                                //Create project accounting record from a reversed project accounting record.
                                this.createFromReversedDistribution(
                                    accountingDistribution,
                                    _accDistSourceDocumentLineItem,
                                    topSourceDocumentLineItem);
                            }
                            else if (ProjectSourceDocumentLineItemHelper::canProcessProject(topSourceDocumentLineItem))
                            {
                                loggerMessage.Append('based on project allocation setup.');

                                //Create project accounting record based on project allocation setup
                                if (this.canCreateProjectDistribution(accountingDistribution, _accDistSourceDocumentLineItem, topSourceDocumentLineItem))
                                {
                                    this.createFromProjectAllocation(
                                        accountingDistribution,
                                        _accDistSourceDocumentLineItem,
                                        topSourceDocumentLineItem);
                                }

                                loggerMessage.Clear().Append('Project accounting record not created since canCreateProjectDistribution returned false.');

                            }
                            else
                            {
                                //For stocked scenario, create project accounting record using default values from source document line item
                                if ((accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice) || (accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess) ||
                                    (accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice && accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess &&
                                        accountingDistribution.LedgerDimension == this.getExtendedPriceLedgerDimension(topSourceDocumentLineItem)))
                                {
                                    loggerMessage.Append('using default values from source document line item.');

                                    this.createFromSourceDocumentLineItem(accountingDistribution, _accDistSourceDocumentLineItem, topSourceDocumentLineItem);
                                }
                                else
                                {
                                    loggerMessage.Clear().Append('Project accounting record not created based on MonetaryAmount value.');
                                }
                            }
                        }

                        loggerMessage.Append(strFmt(' AccountingDistribution: %1', accountingDistribution.RecId));
                        logger.logInformation(loggerMessage.ToString());
                    }
                    else
                    {
                        //Update existing project accounting distribution
                        if ((accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                            || accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess
                            || ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(accountingDistribution.MonetaryAmount))
                            && distributeEqually.exists(accountingDistribution.SourceDocumentLine))
                        {
                            SourceDocumentLineItemIProject sourceDocumentLineItemIProject;
                            boolean amountCalculated = false;

                            if (topSourceDocumentLineItem is SourceDocumentLineItemIProject && topSourceDocumentLineItem is TrvExpTransSourceDocLineItem)
                            {
                                sourceDocumentLineItemIProject = topSourceDocumentLineItem as SourceDocumentLineItemIProject;

                                ProjId projId = ProjTable::findRecId(projectAccountingDistribution.ProjTable).ProjId;
                            
                                if (projId != sourceDocumentLineItemIProject.parmProjectId())
                                {
                                    ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                                        projId, sourceDocumentLineItemIProject.parmProjectResourceRecId(), ProjCategory::findRecId(projectAccountingDistribution.ProjCategory).CategoryId,
                                        accountingDistribution.TransactionCurrencyAmount, accountingDistribution.TransactionCurrency, Currency::findRecId(projectAccountingDistribution.Currency).CurrencyCode,
                                        topSourceDocumentLineItem.parmAccountingDate(), '', '', '', topSourceDocumentLineItem.parmExchangeRate1());

                                    [projectAccountingDistribution.TransactionCurrencyAmount] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams);
                                                    
                                    amountCalculated = true;
                                }
                            }

                            [newCurrency,
                                newTransactionCurrencyPrice,
                                evenTransactionCurrencyAmount,
                                eventPlusRemainingTransactionCurrencyAmount,
                                evenAllocation,
                                evenPlusRemainingAllocation] = distributeEqually.lookup(accountingDistribution.SourceDocumentLine);

                            projectAccountingDistribution.Currency = newCurrency;
                            projectAccountingDistribution.TransactionCurrencyPrice = newTransactionCurrencyPrice;
                            if (!amountCalculated)
                            {
                                if (accountingDistribution.TransactionCurrencyAmount == evenAllocation)
                                {
                                    projectAccountingDistribution.TransactionCurrencyAmount = evenTransactionCurrencyAmount;
                                }
                                else if (accountingDistribution.TransactionCurrencyAmount == evenPlusRemainingAllocation)
                                {
                                    projectAccountingDistribution.TransactionCurrencyAmount = eventPlusRemainingTransactionCurrencyAmount;
                                }
                            }
                            projectAccountingDistribution.update();
                        }
                        else if (_accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                        {
                            VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = _accDistSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                            VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendorInvoiceLineSourceDocLineItem.parmSourceDocumentLine().RecId);
                            VendInvoiceInfoLine_Project projVendInvInfoLine = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvInfoLine.RecId);

                            projectAccountingDistribution.TransactionCurrencyPrice = projVendInvInfoLine.ProjSalesPrice;

                            if (accountingDistribution.MonetaryAmount == MonetaryAmount::QuantityVariance)
                            {
                                projectAccountingDistribution.calcQtyVarianceTransactionAmount(accountingDistribution, vendorInvoiceLineSourceDocLineItem);
                            }
                            else if(accountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance ||
                                accountingDistribution.MonetaryAmount == MonetaryAmount::PriceAdjustment ||
                                accountingDistribution.MonetaryAmount == MonetaryAmount::Discount)
                            {
                                projectAccountingDistribution.TransactionCurrencyAmount = 0;
                                projectAccountingDistribution.TransactionCurrencyPrice = 0;
                            }
                            else if (vendInvInfoLine.PSARetainagePercent || vendInvInfoLine.PSAReleaseAmount)
                            {
                                boolean calculateTotalSalesPriceWithoutRetention = ProjSalesPriceWithoutRetentionFeatureHelper::isFeatureEnabled();

                                if (calculateTotalSalesPriceWithoutRetention
                                    || (ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled()
                                        && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                                            vendorInvoiceRetentionCalcFeature,
                                            vendInvInfoLine.InventTransId)))
                                {
                                    if (streamLinePricesFeature)
                                    {
                                        this.setSalesAmountForVendorInvoice(accountingDistribution, projectAccountingDistribution, vendInvInfoLine, projVendInvInfoLine);
                                    }
                                    else
                                    {
                                        projectAccountingDistribution.TransactionCurrencyAmount = projVendInvInfoLine.ProjSalesPrice
                                            * vendInvInfoLine.ReceiveNow * accountingDistribution.AllocationFactor;
                                    }
                                }
                                else
                                {
                                    projectAccountingDistribution.TransactionCurrencyAmount =   
                                        AccDistProcessorProjectExtension::calcTransCurrencyAmountWithRetention(
                                            vendorInvoiceLineSourceDocLineItem, vendInvInfoLine, accountingDistribution,        
                                            _accDistSourceDocumentLineItem);
                                }
                            }
                            else
                            {
                                if (streamLinePricesFeature)
                                {
                                    this.setSalesAmountForVendorInvoice(accountingDistribution, projectAccountingDistribution, vendInvInfoLine, projVendInvInfoLine);
                                }
                                else
                                {
                                    projectAccountingDistribution.TransactionCurrencyAmount = projVendInvInfoLine.ProjSalesPrice
                                            * vendInvInfoLine.ReceiveNow * accountingDistribution.AllocationFactor;
                                }
                            }

                            projectAccountingDistribution.update();
                        }
                        else if (this.useOrigTransactionCurrencyAmount(_accDistSourceDocumentLineItem))
                        {
                            boolean isTaxScenario = _accDistSourceDocumentLineItem is TaxSourceDocSublineItem
                                && (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                                    || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance);

                            PurchLine purchLine;

                            if (streamLinePricesFeature && topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                            {
                                purchLine = PurchLine::findBySourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }

                            if (streamLinePricesFeature
                                && purchLine
                                && isTaxScenario)
                            {
                                AmountCur taxCostPrice = CurrencyExchangeHelper::price(accountingDistribution.TransactionCurrencyAmount, accountingDistribution.TransactionCurrency);
                                
                                if (taxCostPrice != 0)
                                {
                                    projectAccountingDistribution.TransactionCurrencyAmount =  AccDistProcessorProjectExtension::transTurnover(topSourceDocumentLineItem, taxCostPrice);
                                    projectAccountingDistribution.TransactionCurrencyPrice = projectAccountingDistribution.TransactionCurrencyAmount;
                                }
                                else
                                {
                                    projectAccountingDistribution.TransactionCurrencyPrice = projectAccountingDistribution.TransactionCurrencyAmount;
                                }
                            }
                            else if (!isTaxScenario)
                            {
                                // Update transaction currency price and amount if this is not non-deductible tax transaction.
                                boolean calcTransactionPriceForPO;
                                if (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                                {
                                    PurchOrderLineSourceDocumentLineItem purchOrderLineSourceDocumentLineItem = _accDistSourceDocumentLineItem as PurchOrderLineSourceDocumentLineItem;
                                    if (purchOrderLineSourceDocumentLineItem.parmQuantity() != ProjectAccountingDistribution::quantity(accountingDistribution, _accDistSourceDocumentLineItem) ||
                                        purchOrderLineSourceDocumentLineItem.parmProjectSalesPrice() != projectAccountingDistribution.TransactionCurrencyPrice)
                                    {
                                        calcTransactionPriceForPO = true;
                                    }
                                }

                                if (calcTransactionPriceForPO || ProjectSourceDocumentLineItemHelper::canUpdateTransactionCurrencyPrice(_accDistSourceDocumentLineItem))
                                {
                                    projectAccountingDistribution.TransactionCurrencyPrice = this.calculateTransactionCurrencyPrice(_accDistSourceDocumentLineItem);
                                }

                                if (purchLine
                                    && accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                                    && streamLinePricesFeature)
                                {
                                    this.setSalesAmountForPurchLine(accountingDistribution, projectAccountingDistribution, purchLine);
                                    
                                    if (purchLine.PurchQty != 0)
                                    {
                                        boolean foundTransactionCurrencyPrice;
                                        if (accountingDistribution.ReferenceDistribution != 0
                                            && accountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing)
                                        {
                                            ProjectAccountingDistribution origProjAccDist =
                                                ProjectAccountingDistribution::findByAccountingDistribution (accountingDistribution.ReferenceDistribution);
                                            if (origProjAccDist)
                                            {
                                                projectAccountingDistribution.TransactionCurrencyPrice = origProjAccDist.TransactionCurrencyPrice;
                                                foundTransactionCurrencyPrice = true;
                                            }
                                        }

                                        if (!foundTransactionCurrencyPrice)
                                        {
                                            projectAccountingDistribution.TransactionCurrencyPrice = purchLine.ProjSalesPrice;
                                        }
                                    }
                                }
                                else
                                {
                                    ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(
                                        accountingDistribution, projectAccountingDistribution);
                                }
                            }
                        
                            if (_accDistSourceDocumentLineItem && _accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                            {
                                if (!streamLinePricesFeature)
                                {
                                    select firstonly ProjId, ProjCategoryId, ProjLinePropertyId from purchLine
                                        where purchLine.SourceDocumentLine == _accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId;
                                }

                                if (purchLine)
                                {
                                    if (purchLine.ProjId != '')
                                    {
                                        ProjTable projTable = ProjTable::find(purchLine.ProjId);
                                        if (projTable)
                                        {
                                            // When flight is enabled and it's reversal scenario, we should not override the ProjectAccountingDistribution's projId with purchLine projId
                                            // else existing logic will execute.

                                            if (ProjFixCommittedCostWhenChangePurchLineProjIdFlight::instance().isEnabled())
                                            {
                                                if (accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing)
                                                {
                                                    projectAccountingDistribution.ProjTable = projTable.RecId;
                                                }
                                            }
                                            else
                                            {
                                                projectAccountingDistribution.ProjTable = projTable.RecId;
                                            }
                                        }
                                    }
                    
                                    if (purchLine.ProjCategoryId != '')
                                    {
                                        ProjCategory projCategory = ProjCategory::find(purchLine.ProjCategoryId);
                                        if (projCategory)
                                        {
                                            projectAccountingDistribution.ProjCategory = projCategory.RecId;
                                        }
                                    }
                                
                                    if (purchLine.ProjLinePropertyId != '')
                                    {
                                        ProjLineProperty projLineProperty = ProjLineProperty::find(purchLine.ProjLinePropertyId);
                                        if (projLineProperty)
                                        {
                                            projectAccountingDistribution.ProjLineProperty = projLineProperty.RecId;
                                        }
                                    }

                                    // Setting sales currency for project accounting distribution.
                                    Currency currency = Currency::find(purchLine.ProjSalesCurrencyId);
                                    if (currency)
                                    {
                                        projectAccountingDistribution.Currency = currency.RecId;
                                    }

                                    if (purchLine.ActivityNumber != '')
                                    {
                                        smmActivities smmAct = smmActivities::find(purchLine.ActivityNumber);
                                        if (smmAct)
                                        {
                                            projectAccountingDistribution.smmActivities = smmAct.RecId;
                                        }
                                    }
                                }
                            }
                            projectAccountingDistribution.update();
                        }
                    }
                }
                // Update the ledger dimension of non recoverable tax record in accounting distribution when vendor invoice have the retention and tax
                if (accountingDistribution.ParentDistribution
                    && _accDistSourceDocumentLineItem is TaxSourceDocSublineItem
                    && topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                    && (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                       || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance))
                {
                    VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

                    if (vendInvInfoLine.PSARetainagePercent || vendInvInfoLine.PSAReleaseAmount)
                    {
                        AccountingDistribution mainAccountingDistribution = AccountingDistribution::find(this.getTopParentAccountingDistribution(accountingDistribution).ReferenceDistribution);

                        if (mainAccountingDistribution && mainAccountingDistribution.LedgerDimension != accountingDistribution.LedgerDimension)
                        {
                            accountingDistribution.selectForupdate(true);
                            accountingDistribution.LedgerDimension = mainAccountingDistribution.LedgerDimension;
                            ttsbegin;
                            accountingDistribution.update();
                            ttscommit;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSpecialFundingDistributions</Name>
				<Source><![CDATA[
    private void processSpecialFundingDistributions(SourceDocumentLineItem accDistSourceDocumentLineItem,
                                                    SourceDocumentLineItem topSourceDocumentLineItem)
    {
        List childAccountingDistributionRecIdList = new List(Types::Int64);

        SourceDocumentLine accDistSourceDocumentLine = accDistSourceDocumentLineItem.parmSourceDocumentLine();
        
        AccountingDistribution rootParentAccountingDistribution;
        AccountingDistribution childAccountingDistribution;

        // Always process parent transaction first.
        // The order by TransactionCurrency means that negative Transactions will be process first before the positive transaction.
        while select rootParentAccountingDistribution
            order by rootParentAccountingDistribution.TransactionCurrency
            where rootParentAccountingDistribution.SourceDocumentLine == accDistSourceDocumentLine.RecId
        notexists join childAccountingDistribution
            where childAccountingDistribution.RecId == rootParentAccountingDistribution.ParentDistribution
                && childAccountingDistribution.SourceDocumentLine == accDistSourceDocumentLine.RecId
        {
            this.getChildAccountingDistributionList(childAccountingDistributionRecIdList, rootParentAccountingDistribution.RecId);
            
            if (this.canCreateProjectDistribution(rootParentAccountingDistribution, accDistSourceDocumentLineItem, topSourceDocumentLineItem))
            {
                this.processDistributeFundingSources(accDistSourceDocumentLineItem, rootParentAccountingDistribution);
            }
        }

        if (childAccountingDistributionRecIdList.elements() != 0)
        {
            List nextLevelAccountingDistributionList = childAccountingDistributionRecIdList;
            do
            {
                nextLevelAccountingDistributionList = this.processNextLevelAccountingDistributionList(
                    nextLevelAccountingDistributionList, accDistSourceDocumentLineItem, topSourceDocumentLineItem);
            }
            while (nextLevelAccountingDistributionList.elements() != 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildAccountingDistributionList</Name>
				<Source><![CDATA[
    private void getChildAccountingDistributionList(List _childAccountingDistributionRecIdList, RecId _parentAccountingDistributionRecId)
    {
        AccountingDistribution childAcountingDistribution;

        while select childAcountingDistribution
            where childAcountingDistribution.ParentDistribution == _parentAccountingDistributionRecId
        {
            if (childAcountingDistribution.TransactionCurrencyAmount < 0)
            {
                _childAccountingDistributionRecIdList.addStart(childAcountingDistribution.RecId);
            }
            else
            {
                _childAccountingDistributionRecIdList.addEnd(childAcountingDistribution.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNextLevelAccountingDistributionList</Name>
				<Source><![CDATA[
    private List processNextLevelAccountingDistributionList(List _childAccountingDistributionRecIdList,
        SourceDocumentLineItem _accDistSourceDocumentLineItem, SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        List nextLevelChildAccountingDistributionRecIdList = new List(Types::Int64);
        
        ListEnumerator listEnumerator = _childAccountingDistributionRecIdList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            this.getChildAccountingDistributionList(nextLevelChildAccountingDistributionRecIdList, listEnumerator.current());
            AccountingDistribution childAccountingDistribution = AccountingDistribution::find(listEnumerator.current());

            if (this.canCreateProjectDistribution(childAccountingDistribution, _accDistSourceDocumentLineItem, _topSourceDocumentLineItem))
            {
                this.processDistributeFundingSources(_accDistSourceDocumentLineItem, childAccountingDistribution);
            }
        }
       
        return nextLevelChildAccountingDistributionRecIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseFundingLimitTrackingRecords</Name>
				<Source><![CDATA[
    private void releaseFundingLimitTrackingRecords(AccountingDistribution _accountingDistribution, boolean _removeCurrentFundingLimitTracking = false)
    {
        List                            listFundingLimits = new List(Types::Record);
        str                             mapKey;
        ProjFundingLimitTracking        projFundingLimitTracking;
        ProjectAccountingDistribution   projectAccountingDistribution;
        SourceDocumentLineItem          sourceDocumentLineItem;

        if (_removeCurrentFundingLimitTracking)
        {
            projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.RecId);

            select firstonly RecId from projFundingLimitTracking
                where projFundingLimitTracking.AccountingDistribution == _accountingDistribution.RecId &&
                      projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId &&
                      projFundingLimitTracking.Reversing == NoYes::No;

            if (projFundingLimitTracking.RecId == 0)
            {
                return;
            }

            if (!reversedCurrentFundingLimitMap.exists(_accountingDistribution.SourceDocumentLine))
            {
                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine));
                reversedCurrentFundingLimitMap.insert(_accountingDistribution.SourceDocumentLine, sourceDocumentLineItem);
            }

            delete_from projFundingLimitTracking
                where projFundingLimitTracking.AccountingDistribution == _accountingDistribution.RecId &&
                      projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId &&
                      projFundingLimitTracking.Reversing == NoYes::No;

            delete_from projFundingLimitTracking
                where projFundingLimitTracking.SourceAccountingDistribution == _accountingDistribution.RecId &&
                      projFundingLimitTracking.Reversing == NoYes::Yes;
        }
        else
        {
            listNewTaxDistributions.addEnd([_accountingDistribution.RecId,_accountingDistribution.ReferenceDistribution]);
        }

        mapKey = strFmt("%1#%2",_accountingDistribution.RecId,_accountingDistribution.ReferenceDistribution);

        if (!referenceAccountingDistributionMap.exists(mapKey))
        {
            if (!(ProjFundingLimitTrackingManager::isPurchaseOrderAccDistribution(_accountingDistribution)  &&
                    ProjFundingLimitTrackingManager::hasPurchaseOrderBeenConfirmed(_accountingDistribution)))
            {
                listFundingLimits = ProjFundingLimitTrackingManager::releaseFundingLimitTracking(_accountingDistribution);

                if (listFundingLimits.elements() > 0)
                {
                    referenceAccountingDistributionMap.insert(mapKey, listFundingLimits);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseTaxReferenceFundingLimit</Name>
				<Source><![CDATA[
    private void releaseTaxReferenceFundingLimit(AccountingDistribution _accountingDistribution, RefRecId _referenceParentRecId)
    {
        List                            listFundingLimits = new List(Types::Record);
        str                             mapKey;
        ProjFundingLimitTracking        projFundingLimitTracking;
        ProjectAccountingDistribution   projectAccountingDistribution;

        projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.RecId);

        select firstonly RecId from projFundingLimitTracking
            where projFundingLimitTracking.AccountingDistribution == _accountingDistribution.RecId &&
                    projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId &&
                    projFundingLimitTracking.Reversing == NoYes::No;

        if (projFundingLimitTracking.RecId == 0)
        {
            return;
        }

        delete_from projFundingLimitTracking
            where projFundingLimitTracking.AccountingDistribution == _accountingDistribution.RecId &&
                    projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId &&
                    projFundingLimitTracking.Reversing == NoYes::No;

        delete_from projFundingLimitTracking
            where projFundingLimitTracking.SourceAccountingDistribution == _accountingDistribution.RecId &&
                    projFundingLimitTracking.Reversing == NoYes::Yes;

        mapKey = strFmt("%1#%2",_accountingDistribution.RecId,_accountingDistribution.ParentDistribution);

        if (!referenceAccountingDistributionMap.exists(mapKey))
        {
            listFundingLimits = ProjFundingLimitTrackingManager::releaseTaxFundingLimitTracking(_referenceParentRecId);

            if (listFundingLimits.elements() > 0)
            {
                referenceAccountingDistributionMap.insert(mapKey, listFundingLimits);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertReferenceTaxFundingLimit</Name>
				<Source><![CDATA[
    private void revertReferenceTaxFundingLimit(AccountingDistribution _accountingDistribution)
    {
        SourceDocumentLineItem      sourceDocumentLineItem;
        AccountingDistribution      parentAccountingDistribution, refParentAccountingDistribution, childAccountingDistribution;
        ProjFundingLimitTracking    projFundingLimitTracking, revertProjFundingLimitTracking;
        List                        listReversedTaxLimit = new List(Types::Record);
        ListEnumerator              listEnumerator;
        str                         mapKey;

        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine));

        if (sourceDocumentLineItem is TaxSourceDocSublineItem)
        {
            parentAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ParentDistribution);

            Debug::assert(parentAccountingDistribution.RecId != 0);

            refParentAccountingDistribution = AccountingDistribution::find(parentAccountingDistribution.ReferenceDistribution);

            // If the tax changed and it generates multiple tax distributions
            // We only to need to reverse the reference tax distributions once
            // Cache values, 0 - no cache, 1 - cache is set, 2 - cache has been updated
            if (SysTransactionScopeCache::get(#TaxScopeCache, _accountingDistribution.ParentDistribution, 0) == 0)
            {
                SysTransactionScopeCache::set(#TaxScopeCache, _accountingDistribution.ParentDistribution, 1);

                while select childAccountingDistribution where childAccountingDistribution.ParentDistribution == refParentAccountingDistribution.RecId
                           join projFundingLimitTracking where projFundingLimitTracking.AccountingDistribution == childAccountingDistribution.RecId &&
                                                               projFundingLimitTracking.Reversing == NoYes::No
                {
                    listReversedTaxLimit.addEnd(projFundingLimitTracking);
                }

                mapKey = strFmt("%1#%2",_accountingDistribution.RecId,_accountingDistribution.ParentDistribution);
                referenceAccountingDistributionMap.insert(mapKey, listReversedTaxLimit);
                listNewDistributions.addEnd([_accountingDistribution.RecId,_accountingDistribution.ParentDistribution]);

                listEnumerator = listReversedTaxLimit.getEnumerator();
                while (listEnumerator.moveNext())
                {
                    revertProjFundingLimitTracking.data(listEnumerator.current());
                    delete_from projFundingLimitTracking where projFundingLimitTracking.RecId == revertProjFundingLimitTracking.RecId;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSkipActiveVendorInvoiceCheck</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setSkipActiveVendorInvoiceCheck(boolean _skipActiveVendorInvoiceCheck = skipActiveVendorInvoiceCheck)
    {
        skipActiveVendorInvoiceCheck = _skipActiveVendorInvoiceCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subscribe</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Subscribes to the accounting distribution processor events.
    /// </summary>
    protected void subscribe()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            accountingDistributionProcessor.processingEventHandler += eventhandler(this.processing);
            accountingDistributionProcessor.processedEventHandler += eventhandler(this.processed);
            accountingDistributionProcessor.creatingAdjustingDistributionForReversal += eventhandler(this.processed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChildDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates child project accounting distributions for the parent project accounting distribution.
    /// </summary>
    /// <param name="_parentAccountingDistribution">
    /// The parent accounting distribution.
    /// </param>
    /// <param name="_parentProjectAccountingDistribution">
    /// The parent project accounting distribution that the new project accounting distributions will be based on.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void updateChildDistributions(AccountingDistribution _parentAccountingDistribution, ProjectAccountingDistribution _parentProjectAccountingDistribution)
    {
        AccountingDistribution          childAccountingDistribution;
        ProjectAccountingDistribution   childProjectAccountingDistribution;
        SourceDocumentLineItem          accDistSourceDocumentLineItem;

        while select childAccountingDistribution
                where childAccountingDistribution.ParentDistribution == _parentAccountingDistribution.RecId
            join forupdate childProjectAccountingDistribution
                where childProjectAccountingDistribution.AccountingDistribution == childAccountingDistribution.RecId
        {
            childProjectAccountingDistribution.ProjTable = _parentProjectAccountingDistribution.ProjTable;
            childProjectAccountingDistribution.ProjCategory = _parentProjectAccountingDistribution.ProjCategory;
            childProjectAccountingDistribution.SmmActivities = _parentProjectAccountingDistribution.SmmActivities;
            childProjectAccountingDistribution.ProjLineProperty = _parentProjectAccountingDistribution.ProjLineProperty;
            childProjectAccountingDistribution.Currency = _parentProjectAccountingDistribution.Currency;
            childProjectAccountingDistribution.TransactionCurrencyPrice = _parentProjectAccountingDistribution.TransactionCurrencyPrice;
            childProjectAccountingDistribution.TaxGroupHeading = _parentProjectAccountingDistribution.TaxGroupHeading;
            childProjectAccountingDistribution.TaxItemGroupHeading = _parentProjectAccountingDistribution.TaxItemGroupHeading;
            childProjectAccountingDistribution.ProjFundingSource = _parentProjectAccountingDistribution.ProjFundingSource;
            if (childAccountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice
                && childAccountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess
                && !ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(childAccountingDistribution.MonetaryAmount))
            {
                childProjectAccountingDistribution.TransactionCurrencyPrice = 0;
            }
            accDistSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(childAccountingDistribution.SourceDocumentLine));
            ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(childAccountingDistribution, childProjectAccountingDistribution, accDistSourceDocumentLineItem);
            childProjectAccountingDistribution.update();

            this.updateChildDistributions(childAccountingDistribution, childProjectAccountingDistribution);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxReversingFundingLimit</Name>
				<Source><![CDATA[
    private List updateTaxReversingFundingLimit(AccountingDistribution accountingDistribution, List taxReferenceList)
    {
        ProjFundingLimitTracking    taxProjFundingLimitTracking;
        ProjFundingLimitTracking    reversingTaxProjFundingLimitTracking;
        ListEnumerator              listEnumerator;
        List                        reversedTrackingList = new List(Types::Record);

        listEnumerator = taxReferenceList.getEnumerator();

        ProjFundingLimitTrackingManager::allocateFundingLimitTrackingFromList(taxReferenceList);

        while (listEnumerator.moveNext())
        {
            reversingTaxProjFundingLimitTracking.data(listEnumerator.current());

            taxProjFundingLimitTracking.AccountingDistribution = reversingTaxProjFundingLimitTracking.AccountingDistribution;
            taxProjFundingLimitTracking.ProjectAccountingDistribution = reversingTaxProjFundingLimitTracking.ProjectAccountingDistribution;
            taxProjFundingLimitTracking.ProjFundingLimit = reversingTaxProjFundingLimitTracking.ProjFundingLimit;
            taxProjFundingLimitTracking.Reversing = NoYes::Yes;
            taxProjFundingLimitTracking.sdCreditLine = NoYes::No;
            taxProjFundingLimitTracking.SourceDocumentHeader = reversingTaxProjFundingLimitTracking.SourceDocumentHeader;
            taxProjFundingLimitTracking.SourceDocumentLine = reversingTaxProjFundingLimitTracking.SourceDocumentLine;
            taxProjFundingLimitTracking.SourceAccountingDistribution = accountingDistribution.RecId;
            taxProjFundingLimitTracking.Amount = reversingTaxProjFundingLimitTracking.Amount * -1;

            taxProjFundingLimitTracking.doInsert();

            reversedTrackingList.addEnd(taxProjFundingLimitTracking);
        }

        return reversedTrackingList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateExistingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new distributions to replace the existing distribution.
    /// </summary>
    /// <param name="_originalAccountingDistribution">
    /// The original accounting distribution that would be allocated based on the project allocation setup.
    /// </param>
    /// <param name="_originalProjectAccountingDistribution">
    /// The original project accounting distribution that would be allocated based on the project allocation setup.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void allocateExistingDistribution(
        AccountingDistribution          _originalAccountingDistribution,
        ProjectAccountingDistribution   _originalProjectAccountingDistribution)
    {
        SourceDocumentLineItem                  accDistSourceDocumentLineItem;
        SourceDocumentLineItem                  topSourceDocumentLineItem;
        SourceDocumentLineItemIProject          sourceDocumentLineItemIProject;
        ProjTable                               projTable;
        ProjInvoiceTable                        projInvoiceTable;
        ProjCategory                            projCategory;
        smmActivities                           smmActivities;
        ProjLineProperty                        projLineProperty;
        SourceDocumentLineItemIProduct          sourceDocumentLineItemIProduct;
        ProjTrans_Virtual                       projTrans;
        ProjFundingEngine                       projFundingEngine;
        List                                    allocations;
        List                                    costList;
        List                                    revenueList;
        ListEnumerator                          allocationsEnumerator;
        ProjSplitAllocation                     allocation;
        Percent                                 allocationPercentage;
        AllocationFactor                        allocationFactor;
        ProjFundingSourceRefId                  allocationFundingSource;
        ProjFundingSource                       allocationProjFundingSource;
        LedgerDimensionDefaultAccount           ledgerDimensionDefaultAccount;
        LedgerDimensionAccount                  ledgerDimension;
        AccountingDistribution                  accountingDistribution;
        ProjectAccountingDistribution           projectAccountingDistribution;
        int                                     counter;
        AmountCur                               currentTransactionCurrencyAmount;
        AllocationFactor                        currentAllocationFactor;
        AmountCur                               remainingTransactionCurrencyAmount;
        AllocationFactor                        remainingAllocationFactor;
        AccDistProcessorProjectExtension        accDistProcessorProjectExtension;
        boolean                                 isIntercompany = false;

        if (_originalProjectAccountingDistribution)
        {
            changecompany (CompanyInfo::findRecId(_originalAccountingDistribution.AccountingLegalEntity).DataArea)
            {
                projTable = ProjTable::findRecId(_originalProjectAccountingDistribution.ProjTable);
                projCategory = ProjCategory::findRecId(_originalProjectAccountingDistribution.ProjCategory);
                smmActivities = smmActivities::findWithRecId(_originalProjectAccountingDistribution.SmmActivities);
                projLineProperty = ProjLineProperty::findRecId(_originalProjectAccountingDistribution.ProjLineProperty);
                projInvoiceTable = projTable.projInvoice();

                if (projInvoiceTable &&
                   ((ProjFundingSource::numberOfFundingSources(projInvoiceTable.ProjInvoiceProjId) != 1) ||
                    ProjFundingLimit::existForContract(projInvoiceTable.ProjInvoiceProjId)))
                {
                    accDistSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(_originalAccountingDistribution.SourceDocumentLine));
                    topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(_originalAccountingDistribution.SourceDocumentLine);
                    sourceDocumentLineItemIProject = topSourceDocumentLineItem as SourceDocumentLineItemIProject;

                    projTrans = ProjTrans_Virtual::construct();
                    projTrans.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(topSourceDocumentLineItem));
                    projTrans.setTransDate(_originalAccountingDistribution.AccountingDate);
                    projTrans.setProjId(projTable.ProjId);
                    projTrans.setActivityNumber(smmActivities.ActivityNumber);
                    projTrans.setCategoryId(projCategory.CategoryId);
                    projTrans.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
                    projTrans.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());
                    if (topSourceDocumentLineItem is SourceDocumentLineItemIProduct)
                    {
                        sourceDocumentLineItemIProduct = topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
                        projTrans.setItemId(sourceDocumentLineItemIProduct.parmItemId());
                    }
                    projTrans.setCurrencyIdCost(ProjectAccountingDistribution::transactionCostCurrency(_originalAccountingDistribution, _originalProjectAccountingDistribution));
                    projTrans.setCurrencyIdSales(ProjectAccountingDistribution::transactionSalesCurrency(_originalAccountingDistribution, _originalProjectAccountingDistribution));
                    projTrans.setLinePropertyId(projLineProperty.LinePropertyId);

                    costList = new List(Types::Class);
                    revenueList = new List(Types::Class);
                    AccDistProcessorProjectExtension::createListsBasedOnAccDist(_originalAccountingDistribution, costList, revenueList);

                    projFundingEngine = ProjFundingEngine::construct_ex(projTrans,
                                                                     costList,
                                                                     revenueList,
                                                                     false);
                    if (projFundingEngine.allocate())
                    {
                        allocations = projFundingEngine.parmfundingSourceAllocation();
                        if (allocations.elements())
                        {
                            remainingTransactionCurrencyAmount = _originalAccountingDistribution.TransactionCurrencyAmount;
                            remainingAllocationFactor = _originalAccountingDistribution.AllocationFactor;
                            isIntercompany = ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(topSourceDocumentLineItem);
                            allocationsEnumerator = allocations.getEnumerator();
                            while (allocationsEnumerator.moveNext())
                            {
                                allocation = allocationsEnumerator.current();
                                allocationPercentage = allocation.parmPercent();
                                allocationFundingSource = allocation.parmFundingSourceRefRecId();

                                if (allocationPercentage)
                                {
                                    allocationFactor = allocationPercentage / 100.0;
                                }
                                else
                                {
                                    allocationFactor = 0;
                                }

                                allocationProjFundingSource = ProjFundingSource::find(allocationFundingSource);
                                ledgerDimensionDefaultAccount = AccDistProcessorProjectExtension::getProjectLedgerDimension(projTable, projCategory, allocationProjFundingSource, projLineProperty, isIntercompany, topSourceDocumentLineItem);
                                ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, topSourceDocumentLineItem.parmDefaultDimension(), allocationProjFundingSource.DefaultDimension);

                                counter += 1;
                                if (counter == allocations.elements())
                                {
                                    currentAllocationFactor = remainingAllocationFactor;
                                    currentTransactionCurrencyAmount = remainingTransactionCurrencyAmount;
                                }
                                else
                                {
                                    currentAllocationFactor = allocationFactor * _originalAccountingDistribution.AllocationFactor;
                                    currentTransactionCurrencyAmount = allocationFactor * _originalAccountingDistribution.TransactionCurrencyAmount;
                                    remainingAllocationFactor = remainingAllocationFactor - currentAllocationFactor;
                                    remainingTransactionCurrencyAmount = remainingTransactionCurrencyAmount - currentTransactionCurrencyAmount;
                                }

                                accountingDistribution.clear();
                                accountingDistribution.data(_originalAccountingDistribution);
                                accountingDistribution.LedgerDimension = _originalAccountingDistribution.LedgerDimension ?
                                                                         _originalAccountingDistribution.LedgerDimension :
                                                                         ledgerDimension;
                                accountingDistribution.AllocationFactor = currentAllocationFactor;
                                accountingDistribution.TransactionCurrencyAmount = currentTransactionCurrencyAmount;
                                accountingDistribution.insertAccountingDistribution();

                                projectAccountingDistribution.clear();
                                projectAccountingDistribution.data(_originalProjectAccountingDistribution);
                                projectAccountingDistribution.ProjFundingSource = allocationFundingSource;
                                ProjectAccountingDistribution::fieldModifiedTransCurrencyPricePost(accountingDistribution, projectAccountingDistribution, accDistSourceDocumentLineItem);
                                projectAccountingDistribution.initFromAccountingDistribution(accountingDistribution);
                                projectAccountingDistribution.insert();

                                AccountingDistributionProcessor::createChildDistribution(accDistSourceDocumentLineItem, accountingDistribution);

                                accDistProcessorProjectExtension = AccDistProcessorProjectExtension::construct();
                                accDistProcessorProjectExtension.createChildDistributions(accountingDistribution, projectAccountingDistribution);
                            }

                            if (!_originalAccountingDistribution.selectForUpdate())
                            {
                                _originalAccountingDistribution.selectForUpdate(true);
                            }
                            _originalAccountingDistribution.delete();

                            info("@SYS344300");
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static AccDistProcessorProjectExtension construct()
    {
        return new AccDistProcessorProjectExtension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDistributionLists</Name>
				<Source><![CDATA[
    private static void createDistributionLists(
        SourceDocumentLineItem  _topSourceDocumentLineItem,
        List                    _listCost,
        List                    _listSales,
        AccountingPolicy        _topSourceDocumentLineItemAccountingPolicy = null)
    {
        AccountingPolicy                        activeAccountingPolicy;
        LedgerDimensionAccount                  extendedPriceLedgerDimension;
        SourceDocumentAmountMap                 activeSourceDocumentAmountMap;
        SourceDocumentLineItem                  activeSourceDocumentLineItem;
        SourceDocumentLine                      activeSourceDocumentLine;
        SourceDocumentLineItem                  childSourceDocumentLineItem;
        SourceDocumentLineItemList              childSourceDocumentLineItemList;
        SourceDocumentLineItemListEnumerator    childSourceDocumentLineItemListEnumerator;
        SourceDocumentAccountingPolicy          localSourceDocumentAccountingPolicy;
        boolean                                 isIntercompany = false;

        void processSourceDocumentAmount(SourceDocumentAmount _sourceDocumentAmount)
        {
            AccountingRule                          accountingRule;
            LedgerDimensionAllocationList           ledgerDimensionAllocationList;
            LedgerDimensionAllocationListEnumerator ledgerDimensionAllocationListEnumerator;
            LedgerDimensionAllocation               ledgerDimensionAllocation;
            LedgerDimensionAccount                  ledgerDimension;
            projAccDistribution                     projAccDistribution;
            SourceDocumentLineItemIProduct          sourceDocumentLineItemIProduct;
            SourceDocumentLineRecId                 sourceDocumentLineRecId;
            ProjTable                               projTable;
            ProjCategory                            projCategory;
            ProjFundingSource                       projFundingSource;
            ProjLineProperty                        projLineProperty;
            LedgerDimensionDefaultAccount           ledgerDimensionDefaultAccount;

            sourceDocumentLineRecId = _topSourceDocumentLineItem.parmSourceDocumentLine().RecId;
            if (activeSourceDocumentLine.RecId == sourceDocumentLineRecId &&
                (_sourceDocumentAmount.parmMonetaryAmount() == MonetaryAmount::ExtendedPrice
                    || _sourceDocumentAmount.parmMonetaryAmount() == MonetaryAmount::WorkInProcess
                    || ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(_sourceDocumentAmount.parmMonetaryAmount())))
            {
                projTable = ProjectSourceDocumentLineItemHelper::projTable(_topSourceDocumentLineItem);
                projCategory = ProjectSourceDocumentLineItemHelper::projCategory(_topSourceDocumentLineItem);
                projFundingSource = ProjectSourceDocumentLineItemHelper::projFundingSource(_topSourceDocumentLineItem);
                projLineProperty = ProjectSourceDocumentLineItemHelper::projLineProperty(_topSourceDocumentLineItem);
                ledgerDimensionDefaultAccount = AccDistProcessorProjectExtension::getProjectLedgerDimension(projTable, projCategory, projFundingSource, projLineProperty, isIntercompany, _topSourceDocumentLineItem);
                
                if (ledgerDimensionDefaultAccount)
                {
                    //Retrieve the account with financial dimension.
                    ledgerDimensionAllocation = DimensionDerivationDistributionRule::deriveDistributionDimension(_topSourceDocumentLineItem,
                        _sourceDocumentAmount.parmMonetaryAmount(),
                        ledgerDimensionDefaultAccount,
                        1,
                        0,
                        AccountingDistributionReferenceRole::None,
                        0);
                    extendedPriceLedgerDimension = ledgerDimensionAllocation.parmLedgerDimension();
                }
            }
            else
            {
                SysTransactionScopeCache::set(classStr(ProjectPosting), [activeSourceDocumentLine.RecId, activeSourceDocumentLine.RecVersion], true);
                if (extendedPriceLedgerDimension)
                {
                    ledgerDimensionAllocation = DimensionDerivationDistributionRule::deriveDistributionDimension(activeSourceDocumentLineItem,
                        _sourceDocumentAmount.parmMonetaryAmount(),
                        extendedPriceLedgerDimension,
                        1,
                        0,
                        AccountingDistributionReferenceRole::None,
                        0);
                    SysTransactionScopeCache::remove(classStr(ProjectPosting), [activeSourceDocumentLine.RecId, activeSourceDocumentLine.RecVersion]);
                    ledgerDimension = ledgerDimensionAllocation.parmLedgerDimension();
                }
            }

            if (activeSourceDocumentLine.RecId == sourceDocumentLineRecId
                && (_sourceDocumentAmount.parmMonetaryAmount() == MonetaryAmount::ExtendedPrice
                    || _sourceDocumentAmount.parmMonetaryAmount() == MonetaryAmount::WorkInProcess
                    || ProjectSourceDocumentLineItemHelper::isPayrollMonetaryAmount(_sourceDocumentAmount.parmMonetaryAmount())))
            {
                AmountCur costAmount = ProjectSourceDocumentLineItemHelper::transCostAmount(activeSourceDocumentLineItem, _sourceDocumentAmount);

                projAccDistribution = projAccDistribution::construct(activeSourceDocumentLine.RecId,
                    _sourceDocumentAmount.parmMonetaryAmount(),
                    costAmount,
                    0);
                _listCost.addEnd(projAccDistribution);

                projAccDistribution = projAccDistribution::construct(activeSourceDocumentLine.RecId,
                    _sourceDocumentAmount.parmMonetaryAmount(),
                    ProjectSourceDocumentLineItemHelper::transTurnover(activeSourceDocumentLineItem),
                    0);

                _listSales.addEnd(projAccDistribution);
            }
            else if (extendedPriceLedgerDimension &&
                ledgerDimension &&
                ledgerDimension == extendedPriceLedgerDimension)
            {
                if (ProjectSourceDocumentLineItemHelper::verifyCostPriceEqualsSalesPrice(_topSourceDocumentLineItem))
                {
                    if (_topSourceDocumentLineItem is SourceDocumentLineItemIProduct)
                    {
                        sourceDocumentLineItemIProduct = _topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
                    }

                    if ((sourceDocumentLineItemIProduct && !sourceDocumentLineItemIProduct.parmItemId()) ||
                        (_topSourceDocumentLineItem is TrvExpTransSourceDocLineItem))
                    {
                        projAccDistribution = projAccDistribution::construct(activeSourceDocumentLine.RecId,
                                                                            _sourceDocumentAmount.parmMonetaryAmount(),
                                                                            _sourceDocumentAmount.parmAmount(),
                                                                            0);
                        _listCost.addEnd(projAccDistribution);

                        projAccDistribution = projAccDistribution::construct(activeSourceDocumentLine.RecId,
                                                                            _sourceDocumentAmount.parmMonetaryAmount(),
                                                                            _sourceDocumentAmount.parmAmount(),
                                                                            0);
                        _listSales.addEnd(projAccDistribution);
                    }
                }
                else if (_sourceDocumentAmount.parmMonetaryAmount() == MonetaryAmount::TaxNonRecoverable )
                {
                    // In the case of Tax non recoverable, it should be added to the cost and revenue list for Project accounting distribution.
                    if (_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem ||
                        _topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem ||
                        _topSourceDocumentLineItem is TrvExpTransSourceDocLineItem ||
                        (_topSourceDocumentLineItem is PurchReqSourceDocLineItem &&
                        ProjPurchRequisitionCommitmentWithTaxMFSFlight::instance().isEnabled()))
                    {
                        projAccDistribution = projAccDistribution::construct(activeSourceDocumentLine.RecId,
                                                                            _sourceDocumentAmount.parmMonetaryAmount(),
                                                                            _sourceDocumentAmount.parmAmount(),
                                                                            0);
                        _listCost.addEnd(projAccDistribution);

                        projAccDistribution = projAccDistribution::construct(activeSourceDocumentLine.RecId,
                                                    _sourceDocumentAmount.parmMonetaryAmount(),
                                                    AccDistProcessorProjectExtension::transTurnover(_topSourceDocumentLineItem, _sourceDocumentAmount.parmAmount()),
                                                    0);
                        _listSales.addEnd(projAccDistribution);
                    }
                }
            }
        }

        void processMonetaryAmountMap(Map _monetaryAmountMap)
        {
            Map             currentMonetaryAmountMap;
            Map             monetaryAmountMap;
            MapEnumerator   monetaryAmountModelEnumerator;
            MonetaryAmount  monetaryAmount;
            Stack           stack;

            if (_monetaryAmountMap)
            {
                stack = new Stack();
                stack.push(_monetaryAmountMap.pack());

                while (stack.qty())
                {
                    currentMonetaryAmountMap = Map::create(stack.pop());

                    monetaryAmountModelEnumerator = currentMonetaryAmountMap.getEnumerator();
                    while (monetaryAmountModelEnumerator.moveNext())
                    {
                        monetaryAmount = monetaryAmountModelEnumerator.currentKey();
                        monetaryAmountMap = monetaryAmountModelEnumerator.currentValue();

                        if (activeSourceDocumentAmountMap.exists(monetaryAmount))
                        {
                            processSourceDocumentAmount(activeSourceDocumentAmountMap.getSourceDocumentAmount(monetaryAmount));
                        }

                        stack.push(monetaryAmountMap.pack());
                    }
                }
            }
        }

        void initActiveAccountingPolicy(SourceDocumentLineItem _sourceDocumentLineItem)
        {
            if (localSourceDocumentAccountingPolicy)
            {
                activeAccountingPolicy = localSourceDocumentAccountingPolicy.getAccountingPolicyForLineItem(_sourceDocumentLineItem);
            }
            else
            {
                activeAccountingPolicy = AccountingPolicy::newPolicy(activeSourceDocumentLineItem);
            }
        }

        void processSourceDocumentLineItem(SourceDocumentLineItem _sourceDocumentLineItem)
        {
            SourceDocumentMonetaryAmountModel   monetaryAmountModel;

            activeSourceDocumentLineItem    = _sourceDocumentLineItem;
            activeSourceDocumentLine        = activeSourceDocumentLineItem.parmSourceDocumentLine();
            activeSourceDocumentAmountMap   = activeSourceDocumentLineItem.parmSourceDocumentAmountMap();

            initActiveAccountingPolicy(activeSourceDocumentLineItem);

            monetaryAmountModel = SourceDocumentMonetaryAmountModel::construct();
            processMonetaryAmountMap(monetaryAmountModel.parmMonetaryAmountChildMap());
        }

        isIntercompany = ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_topSourceDocumentLineItem);

        if (_topSourceDocumentLineItemAccountingPolicy)
        {
            localSourceDocumentAccountingPolicy = _topSourceDocumentLineItemAccountingPolicy.parmSourceDocumentAccountingPolicy();
        }

        processSourceDocumentLineItem(_topSourceDocumentLineItem);

        childSourceDocumentLineItemList = _topSourceDocumentLineItem.parmChildSourceDocumentLineItemList();
        if (childSourceDocumentLineItemList)
        {
            childSourceDocumentLineItemListEnumerator = childSourceDocumentLineItemList.getEnumerator();
            while (childSourceDocumentLineItemListEnumerator.moveNext())
            {
                childSourceDocumentLineItem = childSourceDocumentLineItemListEnumerator.current();
                processSourceDocumentLineItem(childSourceDocumentLineItem);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createListsBasedOnAccDist</Name>
				<Source><![CDATA[
    private static void createListsBasedOnAccDist(AccountingDistribution _accountingDistribution, List costList, List revenueLIst)
    {
        AccountingDistribution          childAccountingDistribution;
        projAccDistribution             projAccDistribution;
        ProjectAccountingDistribution   projectAccountingDistribution;

        // Add parent to lists
        projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.RecId);
        projAccDistribution = projAccDistribution::construct(_accountingDistribution.SourceDocumentLine,
                                                             _accountingDistribution.MonetaryAmount,
                                                             _accountingDistribution.TransactionCurrencyAmount,
                                                             projectAccountingDistribution.ProjFundingSource);
        costList.addEnd(projAccDistribution);

        projAccDistribution = projAccDistribution::construct(_accountingDistribution.SourceDocumentLine,
                                                             _accountingDistribution.MonetaryAmount,
                                                             ProjectAccountingDistribution::transactionCurrencySalesAmt(_accountingDistribution, projectAccountingDistribution),
                                                             projectAccountingDistribution.ProjFundingSource);
        revenueLIst.addEnd(projAccDistribution);

        // Add the children to the list
        while select childAccountingDistribution
                where childAccountingDistribution.ParentDistribution == _accountingDistribution.RecId
        {
            projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(childAccountingDistribution.RecId);
            projAccDistribution = projAccDistribution::construct(childAccountingDistribution.SourceDocumentLine,
                                                                 childAccountingDistribution.MonetaryAmount,
                                                                 childAccountingDistribution.TransactionCurrencyAmount,
                                                                 projectAccountingDistribution.ProjFundingSource);
            costList.addEnd(projAccDistribution);

            projAccDistribution = projAccDistribution::construct(childAccountingDistribution.SourceDocumentLine,
                                                                 childAccountingDistribution.MonetaryAmount,
                                                                 ProjectAccountingDistribution::transactionCurrencySalesAmt(childAccountingDistribution, projectAccountingDistribution),
                                                                 projectAccountingDistribution.ProjFundingSource);
            revenueLIst.addEnd(projAccDistribution);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimensionAllocationList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a list of ledger dimension allocations based on the project setup for a source document
    /// line item.
    /// </summary>
    /// <param name="_topSourceDocumentLineItem">
    /// The source document line item.
    /// </param>
    /// <param name="_topSourceDocumentLineItemAccountingPolicy">
    /// The <c>AccountingPolicy</c> for the source document line item.
    /// </param>
    /// <returns>
    /// A list of ledger dimension allocations based on the project setup.
    /// </returns>
    public static List ledgerDimensionAllocationList(SourceDocumentLineItem  _topSourceDocumentLineItem, AccountingPolicy _topSourceDocumentLineItemAccountingPolicy = null)
    {
        #SubledgerJournal
        
        if (_topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            //
            // Delete any allocation on 'saved' vendor invoice source docuemnt line before running funding engine
            //
            // This happens when submitted to workflow without creating distributions on the active document and then
            // pulling the information back to active to make changes.
            //
            ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId,
                                                                           ProjFundingLimitTrackingAction::Delete);
        }
        
        List ledgerDimensionAllocationList;
        ProjTable projTable = ProjectSourceDocumentLineItemHelper::projTable(_topSourceDocumentLineItem);
        changecompany (projTable.company())
        {
            SourceDocumentLineItemIProject sourceDocumentLineItemIProject = _topSourceDocumentLineItem as SourceDocumentLineItemIProject;
            if (sourceDocumentLineItemIProject.parmProjectFundingSourceRecId() != 0)
            {
                ledgerDimensionAllocationList = AccDistProcessorProjectExtension::documentSuppliedFundingSourceList(_topSourceDocumentLineItem);
            }
            else
            {
                ledgerDimensionAllocationList =  AccDistProcessorProjectExtension::ruleBasedAllocationList(_topSourceDocumentLineItem, _topSourceDocumentLineItemAccountingPolicy);
            }
        }

        return ledgerDimensionAllocationList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentSuppliedFundingSourceList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves ledger dimension allocation list based on funding source list.
    /// </summary>
    /// <param name = "_topSourceDocumentLineItem">
    /// The source document line.
    /// </param>
    /// <returns>
    /// A list of ledger dimension allocations.
    /// </returns>
    protected static List documentSuppliedFundingSourceList(SourceDocumentLineItem  _topSourceDocumentLineItem)
    {
        SourceDocumentLineItemIProject sourceDocumentLineItemIProject = _topSourceDocumentLineItem as SourceDocumentLineItemIProject;
        if (!sourceDocumentLineItemIProject)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ProjFundingSource allocationProjFundingSource = ProjFundingSource::find(sourceDocumentLineItemIProject.parmProjectFundingSourceRecId());
        ProjTable projTable = ProjectSourceDocumentLineItemHelper::projTable(_topSourceDocumentLineItem);
        ProjCategory projCategory = ProjectSourceDocumentLineItemHelper::projCategory(_topSourceDocumentLineItem);
        ProjLineProperty projLineProperty = ProjectSourceDocumentLineItemHelper::projLineProperty(_topSourceDocumentLineItem);
        boolean isIntercompany = ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_topSourceDocumentLineItem);

        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        if (ProjectSourceDocumentLineItemHelper::implementsProjectCustFreeInvoice(_topSourceDocumentLineItem))
        {
            ledgerDimensionDefaultAccount = _topSourceDocumentLineItem.parmLedgerDimensionDefaultAccount();
        }
        else
        {
            ledgerDimensionDefaultAccount = AccDistProcessorProjectExtension::getProjectLedgerDimension(projTable, projCategory, allocationProjFundingSource, projLineProperty, isIntercompany, _topSourceDocumentLineItem);
        }
        LedgerDimensionAccount ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, _topSourceDocumentLineItem.parmDefaultDimension(), allocationProjFundingSource.DefaultDimension);
        AmountCur allocationSalesAmount = ProjectSourceDocumentLineItemHelper::transTurnover(_topSourceDocumentLineItem);

        // Validate funding source against funding limits
        if (allocationProjFundingSource)
        {
            ProjTrans_Virtual projTrans = ProjTrans_Virtual::construct();
            projTrans.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(_topSourceDocumentLineItem));
            projTrans.setTransDate(_topSourceDocumentLineItem.parmAccountingDate());
            projTrans.setProjId(projTable.ProjId);

            smmActivities smmActivities = ProjectSourceDocumentLineItemHelper::smmActivities(_topSourceDocumentLineItem);
            projTrans.setActivityNumber(smmActivities.ActivityNumber);

            projTrans.setCategoryId(projCategory.CategoryId);
            projTrans.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
            projTrans.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());

            SourceDocumentLineItemIProduct sourceDocumentLineItemIProduct = _topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
            if (sourceDocumentLineItemIProduct)
            {
                projTrans.setItemId(sourceDocumentLineItemIProduct.parmItemId());
            }
            
            projTrans.setCurrencyIdCost(ProjectSourceDocumentLineItemHelper::currencyIdCost(_topSourceDocumentLineItem));

            if (ProjectSourceDocumentLineItemHelper::implementsProjectRevenue(_topSourceDocumentLineItem))
            {
                SourceDocumentLineItemIProjectRevenue sourceDocumentLineItemIProjectRevenue = _topSourceDocumentLineItem as SourceDocumentLineItemIProjectRevenue;
                projTrans.setCurrencyIdSales(sourceDocumentLineItemIProjectRevenue.parmProjectSalesCurrencyCode());
            }
            
            projTrans.setLinePropertyId(projLineProperty.LinePropertyId);

            if (!ProjFundingEngine::isAmountWithinFundingLimits(projTrans, allocationProjFundingSource.RecId, allocationSalesAmount))
            {
                throw error("@SYS344241");
            }
        }

        container con = [ledgerDimension, 1, allocationProjFundingSource.RecId];
        List ledgerDimensionAllocationList = new List(Types::Container);
        ledgerDimensionAllocationList.addEnd(con);

        return ledgerDimensionAllocationList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ruleBasedAllocationList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves ledger dimension allocation list based on allocation rule.
    /// </summary>
    /// <param name = "_topSourceDocumentLineItem">
    /// The source document line.
    /// </param>
    /// <param name = "_topSourceDocumentLineItemAccountingPolicy">
    /// The document line item accounting policy.
    /// </param>
    /// <returns>
    /// A list of ledger dimension allocations.
    /// </returns>
    protected static List ruleBasedAllocationList(SourceDocumentLineItem  _topSourceDocumentLineItem, AccountingPolicy _topSourceDocumentLineItemAccountingPolicy)
    {
        ProjTable projTable = ProjectSourceDocumentLineItemHelper::projTable(_topSourceDocumentLineItem);
        ProjCategory projCategory = ProjectSourceDocumentLineItemHelper::projCategory(_topSourceDocumentLineItem);
        smmActivities smmActivities = ProjectSourceDocumentLineItemHelper::smmActivities(_topSourceDocumentLineItem);
        SourceDocumentLineItemIProject sourceDocumentLineItemIProject = _topSourceDocumentLineItem as SourceDocumentLineItemIProject;
        
        ProjTrans_Virtual projTrans = ProjTrans_Virtual::construct();
        projTrans.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(_topSourceDocumentLineItem));
        projTrans.setTransDate(_topSourceDocumentLineItem.parmAccountingDate());
        projTrans.setProjId(projTable.ProjId);
        projTrans.setActivityNumber(smmActivities.ActivityNumber);
        projTrans.setCategoryId(projCategory.CategoryId);
        projTrans.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
        projTrans.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());

        SourceDocumentLineItemIProduct sourceDocumentLineItemIProduct = _topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
        if (sourceDocumentLineItemIProduct)
        {
            projTrans.setItemId(sourceDocumentLineItemIProduct.parmItemId());
        }

        projTrans.setCurrencyIdCost(ProjectSourceDocumentLineItemHelper::currencyIdCost(_topSourceDocumentLineItem));

        if (ProjectSourceDocumentLineItemHelper::implementsProjectRevenue(_topSourceDocumentLineItem))
        {
            SourceDocumentLineItemIProjectRevenue sourceDocumentLineItemIProjectRevenue = _topSourceDocumentLineItem as SourceDocumentLineItemIProjectRevenue;
            projTrans.setCurrencyIdSales(sourceDocumentLineItemIProjectRevenue.parmProjectSalesCurrencyCode());
        }

        ProjLineProperty projLineProperty = ProjectSourceDocumentLineItemHelper::projLineProperty(_topSourceDocumentLineItem);
        projTrans.setLinePropertyId(projLineProperty.LinePropertyId);

        // Add the lending entity dataareaid to the cache so that it can be used while resetting distributions.
        // A combination of project and category is used as key, since the consumer of the cache (ProjectPosting class > costLedgerDimensiondoes()) is a static method and do not have a way to get the value apart from these 2.
        SysGlobalCache  globalCache = appl.globalCache();
        str cacheKey = projtable.ProjId + ':' + projCategory.CategoryId + ':' + projtable.DataAreaId;
        boolean isIntercompany = ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_topSourceDocumentLineItem);

        if (isIntercompany && _topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            VendorInvoiceSourceDoc vendorInvoiceSourceDoc = _topSourceDocumentLineItem.parmSourceDocument();

            globalCache.set(classStr(AccDistProcessorProjectExtension), cacheKey, vendorInvoiceSourceDoc.parmPartyAccount().interCompanyTradingPartnerCompanyID());
        }

        List costList = new List(Types::Class);
        List revenueList = new List(Types::Class);
        AccDistProcessorProjectExtension::createDistributionLists(_topSourceDocumentLineItem, costList, revenueList, _topSourceDocumentLineItemAccountingPolicy);
        ProjFundingEngine projFundingEngine = ProjFundingEngine::construct_ex(projTrans, costList, revenueList, false);

        if (AccDistProcessorProjectExtension::allocateToFundingSources(projFundingEngine))
        {
            List ledgerDimensionAllocationList = AccDistProcessorProjectExtension::getLedgerDimensionAllocationListAndProcessCache(projFundingEngine, _topSourceDocumentLineItem, projTable, projCategory, projLineProperty);
            
            return ledgerDimensionAllocationList;
        }
        else
        {
            throw error("@SYS136009");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateToFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes funding rules to allocate the amount to one or more funding sources.
    /// </summary>
    /// <param name = "_projFundingEngine">
    /// The <c>ProjFundingEngine</c> instance.
    /// </param>
    /// <returns>
    /// Returns true if the amount was distributed to funding sources, otherwise false.
    /// </returns>
    protected static boolean allocateToFundingSources(ProjFundingEngine _projFundingEngine)
    {
        return _projFundingEngine.allocate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionAllocationListAndProcessCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves ledger dimension allocation list and process allocation factor amount cache.
    /// </summary>
    /// <param name = "_projFundingEngine">
    /// The <c>ProjFundingEngine</c> instance.
    /// </param>
    /// <param name = "_topSourceDocumentLineItem">
    /// The source document line.
    /// </param>
    /// <param name = "_projTable">
    /// The <c>ProjTable</c> buffer.
    /// </param>
    /// <param name = "_projCategory">
    /// The <c>ProjCategory</c> buffer.
    /// </param>
    /// <param name = "_projLineProperty">
    /// The <c>ProjLineProperty</c> buffer.
    /// </param>
    /// <returns>
    /// The list of ledger dimension allocation list.
    /// </returns>
    protected static List getLedgerDimensionAllocationListAndProcessCache(
        ProjFundingEngine _projFundingEngine,
        SourceDocumentLineItem  _topSourceDocumentLineItem,
        ProjTable _projTable,
        ProjCategory _projCategory,
        ProjLineProperty _projLineProperty)
    {
        List allocations = _projFundingEngine.parmfundingSourceAllocation();
        List ledgerDimensionAllocationList = new List(Types::Container);

        if (allocations.elements())
        {
            Map mapFundingSourceAllocationFactor = new Map(Types::Int64, Types::Real);
            ProjFundingSourceRefId roundingAllocationFundingSource;
            ProjFundingSourceRefId allocationFundingSource;
            AllocationFactor allocationFactor;
            AllocationFactor totalAllocationFactor;
            LedgerDimensionAccount ledgerDimension;
            
            ListEnumerator allocationsEnumerator = allocations.getEnumerator();
            while (allocationsEnumerator.moveNext())
            {
                ProjSplitAllocation allocation = allocationsEnumerator.current();
                Percent allocationPercentage = allocation.parmPercent();
                allocationFundingSource = allocation.parmFundingSourceRefRecId();
                if (allocation.parmIsAllocateRounding())
                {
                    roundingAllocationFundingSource = allocationFundingSource;
                }

                if (allocationPercentage)
                {
                    allocationFactor = round(allocationPercentage / 100.0, AccountingDistributionConstants::AllocationFactorRoundingPrecision);
                }
                else
                {
                    allocationFactor = 0;
                }
                totalAllocationFactor += allocationFactor;

                mapFundingSourceAllocationFactor.insert(allocationFundingSource, allocationFactor);

                ProjFundingSource allocationProjFundingSource = ProjFundingSource::find(allocationFundingSource);
                boolean isIntercompany = ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_topSourceDocumentLineItem);

                LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount = AccDistProcessorProjectExtension::getProjectLedgerDimension(_projTable, _projCategory, allocationProjFundingSource, _projLineProperty, isIntercompany, _topSourceDocumentLineItem);

                // Clear the cache.
                str cacheKey = _projtable.ProjId + ':' + _projCategory.CategoryId + ':' + _projtable.DataAreaId;
                appl.globalCache().remove(classStr(ProjIntercompanyVendorInvoiceCreator), cacheKey);

                ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSDLI = _topSourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                    
                // Fee type project advanced journal lines should use accrued revenue main account
                if (projAdvancedJournalSDLI && projAdvancedJournalSDLI.parmTransType() == ProjTransType::Revenue)
                {
                    PSAContractLineNum contractLineNum = projAdvancedJournalSDLI.parmProjAdvancedJournalLine().ContractLineId;

                    using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(contractLineNum))
                    {
                        if (ProjectPosting::canAccrueRevenue(ProjTable::find(projAdvancedJournalSDLI.parmProjectId()),
                                                ProjCategory::find(projAdvancedJournalSDLI.parmProjectCategoryId()),
                                                ProjLineProperty::find(projAdvancedJournalSDLI.parmProjectLineProperty()),
                                                projAdvancedJournalSDLI.parmProjectSalesPrice(),
                                                allocationFundingSource))
                        {
                            ledgerDimensionDefaultAccount = ProjPosting::getLedgerDimension(ProjAccountType::SalesValue,
                                                                        projAdvancedJournalSDLI.parmProjectId(),
                                                                        projAdvancedJournalSDLI.parmProjectCategoryId(),
                                                                        allocationFundingSource);
                        }

                    }
                }

                ledgerDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(
                                                 LedgerDimensionFacade::serviceCreateLedgerDimension(
                                                 ledgerDimensionDefaultAccount, _topSourceDocumentLineItem.parmDefaultDimension(),
                                                 allocationProjFundingSource.DefaultDimension));
                          
                container con = [ledgerDimension, allocationFactor, allocationFundingSource];
                ledgerDimensionAllocationList.addEnd(con);
            }

            if (totalAllocationFactor != 1)
            {
                List tmpLedgerDimensionAllocationList = new List(Types::Container);
                ListEnumerator tmpLedgerDimensionAllocationListEnumerator = ledgerDimensionAllocationList.getEnumerator();
                while (tmpLedgerDimensionAllocationListEnumerator.moveNext())
                {
                    [ledgerDimension, allocationFactor, allocationFundingSource] = tmpLedgerDimensionAllocationListEnumerator.current();
                    if (allocationFundingSource == roundingAllocationFundingSource)
                    {
                        allocationFactor = allocationFactor + 1 - totalAllocationFactor;
                        mapFundingSourceAllocationFactor.remove(allocationFundingSource);
                        mapFundingSourceAllocationFactor.insert(allocationFundingSource, allocationFactor);
                    }
                    container con = [ledgerDimension, allocationFactor, allocationFundingSource];
                    tmpLedgerDimensionAllocationList.addEnd(con);
                }
                ledgerDimensionAllocationList = List::create(tmpLedgerDimensionAllocationList.pack());
            }

            List costList = _projFundingEngine.getDistributions(ProjDistributionListType::Cost);
            List revenueList = _projFundingEngine.getDistributions(ProjDistributionListType::Sale);

            AccDistProcessorProjectExtension::processCache(_topSourceDocumentLineItem, ProjDistributionListType::Cost, costList, mapFundingSourceAllocationFactor);
            AccDistProcessorProjectExtension::processCache(_topSourceDocumentLineItem, ProjDistributionListType::Sale, revenueList, mapFundingSourceAllocationFactor);
        }

        return ledgerDimensionAllocationList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes allocation factor amount cache.
    /// </summary>
    /// <param name = "_topSourceDocumentLineItem">
    /// The source document line.
    /// </param>
    /// <param name = "_projDistributionListType">
    /// Project distribution list type: Cost or Sale.
    /// </param>
    /// <param name = "_projAccDistributionList">
    /// The project accounting distribution list.
    /// </param>
    /// <param name = "_mapFundingSourceAllocationFactor">
    /// The funding source allocation factor map.
    /// </param>
    private static void processCache(
        SourceDocumentLineItem  _topSourceDocumentLineItem,
        ProjDistributionListType _projDistributionListType,
        List _projAccDistributionList,
        Map _mapFundingSourceAllocationFactor)
    {
        Map mapSDLMonetaryAmount = new Map(Types::Container, Types::Class);
        ListEnumerator listEnumerator = _projAccDistributionList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            ProjAccDistribution projAccDistribution = listEnumerator.current();

            container cacheKey = [projAccDistribution.parmSourceDocumentLine(), projAccDistribution.parmMonetaryAmount()];
            List listAllocationFactorAmount;
            if (mapSDLMonetaryAmount.exists(cacheKey))
            {
                listAllocationFactorAmount = mapSDLMonetaryAmount.lookup(cacheKey);
                mapSDLMonetaryAmount.remove(cacheKey);
            }
            else
            {
                listAllocationFactorAmount = new List(Types::Container);
            }
            listAllocationFactorAmount.addEnd([_mapFundingSourceAllocationFactor.lookup(projAccDistribution.parmFundingSource()), projAccDistribution.parmAmount()]);
            mapSDLMonetaryAmount.insert(cacheKey, listAllocationFactorAmount);
        }

        MapEnumerator mapEnumeratorSDLMonetaryAmount = mapSDLMonetaryAmount.getEnumerator();
        while (mapEnumeratorSDLMonetaryAmount.moveNext())
        {
            AccDistProcessorProjectExtension::setCache(_topSourceDocumentLineItem, _projDistributionListType, mapEnumeratorSDLMonetaryAmount.currentKey(), mapEnumeratorSDLMonetaryAmount.currentValue());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets allocation factor amount cache.
    /// </summary>
    /// <param name = "_topSourceDocumentLineItem">
    /// The source document line.
    /// </param>
    /// <param name = "_projDistributionListType">
    /// Project distribution list type: Cost or Sale.
    /// </param>
    /// <param name = "_cacheKeyCon">
    /// The cache key container with source document line and monetary amount.
    /// </param>
    /// <param name = "_allocationFactorAmountList">
    /// The allocation factor amount list.
    /// </param>
    private static void setCache(
        SourceDocumentLineItem  _topSourceDocumentLineItem,
        ProjDistributionListType _projDistributionListType,
        container _cacheKeyCon,
        List _allocationFactorAmountList)
    {
        if (_projDistributionListType == ProjDistributionListType::Cost)
        {
            switch (ProjectSourceDocumentLineItemHelper::projTransType(_topSourceDocumentLineItem))
            {
                case ProjTransType::Hour:
                case ProjTransType::Cost:
                case ProjTransType::Item:
                    SysTransactionScopeCache::set(identifierStr(ProjFundingEngineDistList), _cacheKeyCon, _allocationFactorAmountList);
                    break;
            }
        }
        else if (_projDistributionListType == ProjDistributionListType::Sale)
        {
            switch (ProjectSourceDocumentLineItemHelper::projTransType(_topSourceDocumentLineItem))
            {
                case ProjTransType::Hour:
                case ProjTransType::Cost:
                case ProjTransType::Item:
                    SysTransactionScopeCache::set(identifierStr(ProjFundingEngineRevenueList), _cacheKeyCon, _allocationFactorAmountList);
                    if (_topSourceDocumentLineItem is SourceDocumentLineItemIProduct &&
                            ProjParameters::find().DefaultCostPriceAsSalesPrice &&
                            ProjectSourceDocumentLineItemHelper::isProjCategoryTypeItem(_topSourceDocumentLineItem))
                    {
                        SourceDocumentLineItemIProduct sourceDocumentLineItemIProduct = _topSourceDocumentLineItem as SourceDocumentLineItemIProduct;
                        if (!sourceDocumentLineItemIProduct.parmItemId())
                        {
                            boolean isPurchTaxInclude;
                            if (_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
                                && FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance()))
                            {
                                PurchOrderLineSourceDocumentLineItem purchOrderLineSourceDocumentLineItem =
                                    _topSourceDocumentLineItem as PurchOrderLineSourceDocumentLineItem;

                                isPurchTaxInclude = purchOrderLineSourceDocumentLineItem.parmIsTaxInChargeInputAmountIncluded();
                            }

                            if (!isPurchTaxInclude)
                            {
                                SysTransactionScopeCache::remove(identifierStr(ProjFundingEngineRevenueList), _cacheKeyCon);
                            }
                        }
                    }
                    break;
                case ProjTransType::Revenue:
                    SysTransactionScopeCache::set(identifierStr(ProjFundingEngineDistList), _cacheKeyCon, _allocationFactorAmountList);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useOrigTransactionCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether to use the origin transaction currency amount.
    /// </summary>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The <c>SourceDocumentLineItem</c> buffer that holds the current transaction source document reference.
    /// </param>
    /// <returns>
    /// True if current transaction use the origin transaction currency amount; otherwise false.
    /// </returns>
    private boolean useOrigTransactionCurrencyAmount(SourceDocumentLineItem _accDistSourceDocumentLineItem)
    {
        boolean useOrigAmount = true;

        if (_accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem &&
            PurchLine::findBySourceDocumentLine(_accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId).isCanceled())
        {
            useOrigAmount = false;
        }
        else if (_accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = _accDistSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
            if (!vendorInvoiceLineSourceDocLineItem.parmItemId())
            {
                useOrigAmount = false;
            }
        }

        return useOrigAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTurnover</Name>
				<Source><![CDATA[
    private static AmountCur transTurnover(SourceDocumentLineItem _topSourceDocumentLineItem, AmountCur _costAmount)
    {
        // Calculate the project revenue amount by the specified cost amount.
        AmountCur revenueAmount = _costAmount;

        if (_topSourceDocumentLineItem && _topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            PurchLine purchLine;

            select firstonly PurchPrice, ProjSalesPrice, LineDisc, LinePercent, CurrencyCode from purchLine
                where purchLine.SourceDocumentLine == _topSourceDocumentLineItem.parmSourceDocumentLine().RecId;

            if (purchLine.PurchPrice)
            {
                Price purchaseCostPrice = ProjectSourceDocumentLineItemHelper::getCostPriceWithDiscountApplied(purchLine.PurchPrice, purchLine.LineDisc, purchLine.LinePercent);
                if (purchaseCostPrice)
                {
                    revenueAmount = CurrencyExchangeHelper::amount(_costAmount / purchaseCostPrice * purchLine.ProjSalesprice, purchLine.CurrencyCode);
                }
            }
        }
        else if (_topSourceDocumentLineItem && _topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            VendInvoiceInfoLine vendInvoiceLine;
            VendInvoiceInfoLine_Project projVendInvoiceLine;

            select firstonly PurchPrice, LineDisc, LinePercent from vendInvoiceLine
                where vendInvoiceLine.SourceDocumentLine == _topSourceDocumentLineItem.parmSourceDocumentLine().RecId
            join RecId, ProjSalesCurrencyId, ProjSalesPrice from projVendInvoiceLine
                where projVendInvoiceLine.VendInvoiceInfoLineRefRecId == vendInvoiceLine.RecId;

            if (vendInvoiceLine.PurchPrice && projVendInvoiceLine)
            {
                Price purchaseCostPrice = ProjectSourceDocumentLineItemHelper::getCostPriceWithDiscountApplied(vendInvoiceLine.PurchPrice, vendInvoiceLine.LineDisc, vendInvoiceLine.LinePercent);
                if (purchaseCostPrice)
                {
                    revenueAmount = CurrencyExchangeHelper::amount(_costAmount / purchaseCostPrice * projVendInvoiceLine.ProjSalesprice, projVendInvoiceLine.ProjSalesCurrencyId);
                }
            }
        }
        else if (_topSourceDocumentLineItem && _topSourceDocumentLineItem is TrvExpTransSourceDocLineItem)
        {
            TrvExpTransSourceDocLineItem trvExpTransSourceLineItem = _topSourceDocumentLineItem as TrvExpTransSourceDocLineItem;
            AmountCur expSalesPrcie = trvExpTransSourceLineItem.parmProjectSalesPrice();
            TrvExpTrans trvExpTrans = trvExpTransSourceLineItem.parmExpenseLine() as TrvExpTrans;
            AmountCur expCostPrice = trvExpTrans.NetTransactionAmount;

            if (expCostPrice && trvExpTrans.ExpType != TrvExpType::Transport)
            {
                revenueAmount = CurrencyExchangeHelper::amount(_costAmount * expSalesPrcie / expCostPrice, trvExpTransSourceLineItem.parmTransactionCurrencyCode());
            }
        }

        return revenueAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesAmountFromProjSalesPrice</Name>
				<Source><![CDATA[
    private static AmountCur calculateSalesAmountFromProjSalesPrice(AccountingDistribution _accountingDistribution, SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        // In the case of user has set the cost price in purchase line table or vendor invoice line table as 0, then calculate the sales amount by
        // multiplying the sales unit price with the quantity in the invoice.

        AmountCur salesAmount;
        Amount documentCostPrice;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        if (_topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
            documentCostPrice = vendInvoiceInfoLine.PurchPrice;
        }
        else if (_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            PurchLine purchLine = PurchLine::findBySourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
            vendInvoiceInfoLine = VendInvoiceInfoLine::findByPurchLineRefRecId(purchLine.RecId);
            documentCostPrice = PurchLine.PurchPrice;
        }

        if (documentCostPrice == 0)
        {
            VendInvoiceInfoLine_Project projVendInvoiceLine = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvoiceInfoLine.RecId);
            Amount salesUnitPrice = projVendInvoiceLine.ProjSalesPrice;

            if (salesUnitPrice)
            {
                salesAmount = CurrencyExchangeHelper::amount(salesUnitPrice * vendInvoiceInfoLine.ReceiveNow * _accountingDistribution.AllocationFactor, projVendInvoiceLine.ProjSalesCurrencyId);
            }
        }
        
        return salesAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canMonetaryAmountCreateProjectDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether the accounting distribution associated monetary amount type is allowed to create project distribution.
    /// </summary>
    /// <param name = "_accountingDistribution"><c>AccountingDistribution</c> table buffer which has the monetary amount field.</param>
    /// <returns>true if the assoicated monetary amount type can create project distribution; otherwise, false.</returns>
    private boolean canMonetaryAmountCreateProjectDistribution(AccountingDistribution _accountingDistribution)
    {
        boolean canMonetaryAmountCreateProjectDistribution;

        boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());

        if ((!streamLinePricesFeature && _accountingDistribution.MonetaryAmount == MonetaryAmount::Tax) ||
            _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable ||
            _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance ||
            _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance ||
            _accountingDistribution.MonetaryAmount == MonetaryAmount::ChargeVariance ||
            _accountingDistribution.MonetaryAmount == MonetaryAmount::Charge)
        {
            canMonetaryAmountCreateProjectDistribution = true;
        }

        return canMonetaryAmountCreateProjectDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateProjDistributionForTaxRecoverable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a tax non-recoverable and variance monetary amount type project accounting
    /// distribution record should be created for the accounting distribution.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// The accounting distribution.
    /// </param>
    /// <param name="_accDistSourceDocumentLineItem">
    /// The source document line item of the accounting distribution.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    /// The top source document line item.
    /// </param>
    /// <returns>
    /// true if a project accounting distribution record should be created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// For tax non-recoverable and variance type monetary amount, if the ledger dimension between the accounting distribution ledger
    /// dimension and the top accounting distribution ledger dimension are not matching, then this method can be used by comparing the
    /// accounting distribution ledger with the posting account with financial dimension and merge it with funding source financial dimension.
    /// </remarks>
    private boolean canCreateProjDistributionForTaxRecoverable(
        AccountingDistribution _accountingDistribution,
        SourceDocumentLineItem _accDistSourceDocumentLineItem,
        SourceDocumentLineItem _topSourceDocumentLineItem)
    {
        boolean canCreateProjectDistribution;

        SourceDocumentLine parentSourceDocumentLine = _accDistSourceDocumentLineItem.parmParentSourceDocumentLine();

        if (parentSourceDocumentLine &&
            (_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable ||
                _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance))
        {
            SourceDocumentLineItem taxNonRecoverableLineItem = _accDistSourceDocumentLineItem;

            // For the case of TaxNonRecoverableVariance, set it to the parent tax non recoverable line item.
            if (_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
            {
                taxNonRecoverableLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(
                    SourceDocumentLine::find(parentSourceDocumentLine.RecId));
            }

            ProjTable projTable = ProjectSourceDocumentLineItemHelper::projTable(_topSourceDocumentLineItem);
            ProjCategory projCategory = ProjectSourceDocumentLineItemHelper::projCategory(_topSourceDocumentLineItem);
            ProjectAccountingDistribution parentProjAccDist = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.ParentDistribution);
            ProjFundingSource projFundingSource = ProjFundingSource::find(parentProjAccDist.ProjFundingSource);
            ProjLineProperty projLineProperty = ProjectSourceDocumentLineItemHelper::projLineProperty(_topSourceDocumentLineItem);
            LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount = AccDistProcessorProjectExtension::getProjectLedgerDimension(projTable, projCategory, projFundingSource, projLineProperty, false, _topSourceDocumentLineItem);

            //Retrieve the posting account ledger dimension.
            LedgerDimensionAccount extendedPriceLedgerDimension;
            if (ledgerDimensionDefaultAccount)
            {
                LedgerDimensionAllocation ledgerDimensionAllocation = DimensionDerivationDistributionRule::deriveDistributionDimension(
                    taxNonRecoverableLineItem,
                    _accountingDistribution.MonetaryAmount,
                    ledgerDimensionDefaultAccount,
                    1,
                    0,
                    AccountingDistributionReferenceRole::None,
                    0);
                extendedPriceLedgerDimension = ledgerDimensionAllocation.parmLedgerDimension();

                //Merge the funding source dimension
                extendedPriceLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                    extendedPriceLedgerDimension, projFundingSource.DefaultDimension);
            }

            if (_accountingDistribution.LedgerDimension == extendedPriceLedgerDimension)
            {
                canCreateProjectDistribution = true;
            }
        }

        return canCreateProjectDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create an <c>AccDistProcessorProjectExtension</c> instance.
    /// </summary>
    protected void new()
    {
        canCreateProjectDistributionMap = new Map(Types::Int64, Types::Enum);
        logger = ProjOpsFinancialsLogger::createLogger(classStr(AccDistProcessorProjectExtension));
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>existQuantityVarianceDistribution</Name>
				<Source><![CDATA[
    private boolean existQuantityVarianceDistribution(AccountingDistribution _accountingDistribution)
    {
        AccountingDistribution accountingDistributionQtyVariance;

        select firstonly RecId
            from accountingDistributionQtyVariance
                where accountingDistributionQtyVariance.SourceDocumentLine == _accountingDistribution.SourceDocumentLine
                    && accountingDistributionQtyVariance.ParentDistribution == _accountingDistribution.RecId
                    && accountingDistributionQtyVariance.MonetaryAmount == MonetaryAmount::QuantityVariance;

        return accountingDistributionQtyVariance.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesAmountForVendorInvoice</Name>
				<Source><![CDATA[
    private void setSalesAmountForVendorInvoice(AccountingDistribution _accountingDistribution
        , ProjectAccountingDistribution _projectAccountingDistribution
        , VendInvoiceInfoLine _vendInvoiceLine
        , VendInvoiceInfoLine_Project _vendInfoLineProj)
    {
        if (!_vendInfoLineProj.ProjSalesPrice || !_vendInvoiceLine.ReceiveNow)
        {
            _projectAccountingDistribution.TransactionCurrencyAmount = 0;
        }
        else
        {
            Amount accDistTransactionCurrencyAmount = this.getAccDistCostAmountWithPriceVariance(_accountingDistribution);

            if (!accDistTransactionCurrencyAmount)
            {
                _projectAccountingDistribution.TransactionCurrencyAmount = 
                    _vendInfoLineProj.ProjSalesPrice * _vendInvoiceLine.ReceiveNow * _accountingDistribution.AllocationFactor;
                _projectAccountingDistribution.TransactionCurrencyPrice = _vendInfoLineProj.ProjSalesPrice;
            }
            else
            {
                Amount costPriceInAccDistCurrency = _vendInvoiceLine.PurchPrice;
                if (_accountingDistribution.TransactionCurrency != _vendInvoiceLine.currencyCode)
                {
                    costPriceInAccDistCurrency = CurrencyExchangeHelper::curAmount2CurAmount(
                        _vendInvoiceLine.PurchPrice,
                        _vendInvoiceLine.currencyCode,
                        _accountingDistribution.TransactionCurrency,
                        _accountingDistribution.AccountingDate,
                        false);
                }

                if (costPriceInAccDistCurrency)
                {
                    real salesCostRatio = _vendInfoLineProj.ProjSalesPrice / costPriceInAccDistCurrency;
                    _projectAccountingDistribution.TransactionCurrencyAmount = salesCostRatio * accDistTransactionCurrencyAmount;
                }
                else
                {
                    _projectAccountingDistribution.TransactionCurrencyAmount =
                        _vendInfoLineProj.ProjSalesPrice * _vendInvoiceLine.ReceiveNow * _accountingDistribution.AllocationFactor;
                }

                _projectAccountingDistribution.TransactionCurrencyPrice = _vendInfoLineProj.ProjSalesPrice;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesAmountForPurchLine</Name>
				<Source><![CDATA[
    private void setSalesAmountForPurchLine(AccountingDistribution _accountingDistribution
        , ProjectAccountingDistribution _projectAccountingDistribution
        , PurchLine _purchLine
        , boolean _unitConverstionScenario = false
        , UnitQty _unitConverstionsSalesQty = 0)
    {
        UnitQty salesQuantity = _unitConverstionScenario ? _unitConverstionsSalesQty : _purchLine.PurchQty;
        
        if (!_purchLine.ProjSalesPrice || !salesQuantity)
        {
            _projectAccountingDistribution.TransactionCurrencyAmount = 0;
        }
        else
        {
            Amount costPriceInAccDistCurrency = _purchLine.PurchPrice;
            if (_accountingDistribution.TransactionCurrency != _purchLine.CurrencyCode)
            {
                costPriceInAccDistCurrency = CurrencyExchangeHelper::curAmount2CurAmount(
                    _purchLine.PurchPrice,
                    _purchLine.CurrencyCode,
                    _accountingDistribution.TransactionCurrency,
                    _accountingDistribution.AccountingDate,
                    false);
            }

            if (costPriceInAccDistCurrency)
            {
                real salesCostRatio;
                if (_unitConverstionScenario && salesQuantity && _purchLine.PurchQty)
                {
                    salesCostRatio = (_purchLine.ProjSalesPrice * salesQuantity) / (costPriceInAccDistCurrency * _purchLine.PurchQty);
                }
                else
                {
                    salesCostRatio = _purchLine.ProjSalesPrice / costPriceInAccDistCurrency;
                }

                Amount accDistTransactionCurrencyAmount = this.getAccDistCostAmountWithPriceVariance(_accountingDistribution);
                _projectAccountingDistribution.TransactionCurrencyAmount = salesCostRatio * accDistTransactionCurrencyAmount;
            }  
            else
            {
                _projectAccountingDistribution.TransactionCurrencyAmount =
                    _purchLine.ProjSalesPrice * salesQuantity * _accountingDistribution.AllocationFactor;
            }
            _projectAccountingDistribution.TransactionCurrencyPrice = _purchLine.ProjSalesPrice;
            
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>