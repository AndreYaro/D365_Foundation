<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransUpdateBank</Name>
	<SourceCode>
		<Declaration><![CDATA[
public final class LedgerJournalTransUpdateBank extends LedgerJournalTransUpdate
{
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cancelCheque</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes all necessary bank changes in order to cancel a check.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that contains information about a check reversal.
    /// </param>
    private void cancelCheque(LedgerJournalTrans _ledgerJournalTrans)
    {
        BankAccountTrans bankAccountTrans;
        BankChequeTable bankChequeTable;

        bankChequeTable = BankChequeTable::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.BankChequeNum, true);

        if (bankChequeTable)
        {
            // Update the check status to Cancelled and set the reason why.
            bankChequeTable.updateChequeStatusToCancelled(_ledgerJournalTrans.ReasonRefRecID, bankChequeTable.DataAreaId);

            // Remove LedgerTransFurtherPosting records
            LedgerTransFurtherPosting::deleteFurtherPostingChequeCancel(bankChequeTable.Voucher, bankChequeTable.ChequeNum, _ledgerJournalTrans.JournalNum);
        }

        NoYes isAdvancedBankReconciliationEnabled = BankAccountTable::isAdvancedBankReconciliationEnabled(_ledgerJournalTrans.parmAccount());
        NoYes reconciled = isAdvancedBankReconciliationEnabled ? _ledgerJournalTrans.BankReconcileAccountAtPost : NoYes::No;

        // Find the original BankAccountTrans
        select firstonly forupdate bankAccountTrans
            where bankAccountTrans.AccountId == _ledgerJournalTrans.parmAccount()
                && bankAccountTrans.ChequeNum == _ledgerJournalTrans.BankChequeNum
                && bankAccountTrans.CancelPending == NoYes::Yes
                && bankAccountTrans.Reconciled == reconciled
                && bankAccountTrans.Cancel == NoYes::No;

        if (bankAccountTrans)
        {
            bankAccountTrans.BankTransType = BankParameters::find().nsfTransactionType;
            bankAccountTrans.Included = _ledgerJournalTrans.BankReconcileAccountAtPost;
            bankAccountTrans.Reconciled = _ledgerJournalTrans.BankReconcileAccountAtPost;
            bankAccountTrans.Cancel = NoYes::Yes;
            bankAccountTrans.ReasonRefRecID = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, bankAccountTrans.DataAreaId);
            bankAccountTrans.CancelPending = NoYes::No;
            bankAccountTrans.AccountStatementDate = bankAccountTrans.Reconciled ? _ledgerJournalTrans.TransDate : dateNull();

            if (isAdvancedBankReconciliationEnabled && FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
            {
                bankAccountTrans.ClearedDate = _ledgerJournalTrans.TransDate;
            }

            bankAccountTrans.update();

            this.removeBankChequePaymentTrans(_ledgerJournalTrans);
        }

        TransactionLog::create(TransactionLogType::PaymReversal, strfmt("@SYS82243", _ledgerJournalTrans.BankChequeNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelDepositSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes all necessary bank changes in order to cancel a deposit slip.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that contains information about a deposit slip cancellation.
    /// </param>
    private void cancelDepositSlip(LedgerJournalTrans _ledgerJournalTrans)
    {
        BankDeposit bankDeposit;
        BankAccountTrans bankAccountTrans;
        CustTrans localCustTrans;
        BankChequeTable bankChequeTable;
        CompanyId custCompany;

        // If there is a value for the offset company, use that company to find the customer transaction. Otherwise use the primary company.
        custCompany = (_ledgerJournalTrans.OffsetCompany != '') ? _ledgerJournalTrans.OffsetCompany : _ledgerJournalTrans.Company;

        ttsbegin;

        bankDeposit = BankDeposit::find(_ledgerJournalTrans.BankChequeDepositTransRefRecID, true);
        bankDeposit.Canceled = NoYes::Yes;
        bankDeposit.CancelPending = NoYes::No;
        bankDeposit.ReasonRefRecID = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, bankDeposit.DataAreaId);
        bankDeposit.update();

        bankAccountTrans = BankAccountTrans::findByDepositNum(bankDeposit.DepositNum, true);

        if (bankAccountTrans)
        {
            bankAccountTrans.ReasonRefRecID = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, bankAccountTrans.DataAreaId);
            bankAccountTrans.CancelPending = NoYes::No;
            bankAccountTrans.update();
        }

        changecompany(custCompany)
        {
            select firstonly AmountCur, PaymReference, TransDate, Voucher from localCustTrans
                where localCustTrans.RecId == bankDeposit.RefRecId;
        }

        if (localCustTrans)
        {
            select forupdate firstonly bankChequeTable
            where bankChequeTable.Voucher == localCustTrans.Voucher
               && bankChequeTable.TransDate == localCustTrans.TransDate
               && bankChequeTable.ChequeNum == localCustTrans.PaymReference
               && bankChequeTable.RecipientType == BankChequeRecipientType::Cust
               && bankChequeTable.AmountCur == localCustTrans.AmountCur;

            if (bankChequeTable)
            {
                bankChequeTable.updateChequeStatusToCancelled(_ledgerJournalTrans.ReasonRefRecID, bankChequeTable.DataAreaId);
            }
        }

        TransactionLog::create(TransactionLogType::PaymReversal, "@SYS82247");

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    boolean check(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _checkNoSettlement = true,
        LedgerVoucher _ledgerVoucher = null,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        BankAccountTable bankAccountTable;

        ok = super(_ledgerJournalTrans, _checkNoSettlement, _ledgerVoucher, _ledgerPostingMessageCollection);

        bankAccountTable = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());

        if (!bankAccountTable)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS27061", _ledgerJournalTrans.parmAccount())) && ok;
            }
            else
            {
                ok = checkFailed(strFmt("@SYS27061", _ledgerJournalTrans.parmAccount())) && ok;
            }
        }

        ok = MainAccount::checkCurrency(LedgerDimensionFacade::getMainAccountFromLedgerDimension(bankAccountTable.LedgerDimension).RecId, _ledgerJournalTrans.CurrencyCode) && ok;

        if (bankAccountTable)
        {
            ok = bankAccountTable.checkCurrency(_ledgerJournalTrans.CurrencyCode) && ok;
        }

        if (_ledgerJournalTrans.BankDepositVoucher)
        {
            ok = this.checkDepositSlip(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ok = this.checkPaymentJournalFee_RU(_ledgerJournalTrans, ok, _ledgerPostingMessageCollection);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDepositSlip</Name>
				<Source><![CDATA[
    boolean checkDepositSlip(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ret = true;

        if (_ledgerJournalTrans.BankDepositVoucher)
        {
            if (!_ledgerJournalTrans.PaymReference)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ret = _ledgerPostingMessageCollection.logCheckFailed(strfmt('%1 %2: %3', "@SYS23659", _ledgerJournalTrans.Voucher, "@SYS24523"));
                }
                else
                {
                    ret = checkFailed(strfmt('%1 %2: %3', "@SYS23659", _ledgerJournalTrans.Voucher, "@SYS24523"));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentJournalFee_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks payment journal fee.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_ok">
    /// A <c>Boolean</c> determining the default value for the check performed.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection; optional.
    /// </param>
    /// <returns>
    /// true if the check suceeded; false otherwise.
    /// </returns>
    protected boolean checkPaymentJournalFee_RU(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _ok,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        CustVendPaymJournalFee journalFee;
        LedgerJournalTrans ledgerJournalTransMain;
        boolean ret = _ok;

        if (LedgerParameters::find().Correspondence_RU)
        {
            select firstonly ledgerJournalTransMain
                exists join journalFee
                    where journalFee.RefRecId == ledgerJournalTransMain.RecId
                        && journalFee.FeeTransRecId == _ledgerJournalTrans.RecId;

            if (ledgerJournalTransMain
                && ledgerJournalTransMain.correct() != _ledgerJournalTrans.correct())
            {
                if (_ledgerPostingMessageCollection)
                {
                    ret = _ledgerPostingMessageCollection.logCheckFailed("@GLS110476");
                }
                else
                {
                    ret = checkFailed("@GLS110476");
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWhenPost</Name>
				<Source><![CDATA[
    boolean checkWhenPost(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _originalLedgerJournalTrans,
        boolean _checkNoSettlement = true,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        BankAccountTable bankAccountTable;

        ok = super(_ledgerJournalTrans, _originalLedgerJournalTrans, _checkNoSettlement, _ledgerPostingMessageCollection);

        bankAccountTable = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
        if (!bankAccountTable)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strfmt("@SYS27061", _ledgerJournalTrans.parmAccount())) && ok;
            }
            else
            {
                ok = checkFailed(strfmt("@SYS27061", _ledgerJournalTrans.parmAccount())) && ok;
            }
        }

        ok = MainAccount::checkCurrency(LedgerDimensionFacade::getMainAccountFromLedgerDimension(bankAccountTable.LedgerDimension).RecId, _ledgerJournalTrans.CurrencyCode) && ok;

        if (bankAccountTable)
        {
            ok = bankAccountTable.checkCurrency(_ledgerJournalTrans.CurrencyCode) && ok;
        }

        ok = this.checkDepositSlip(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWithholdAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the TaxWithholdAmount for bank transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// TaxWithholdAmount calculated on the bank transaction journal.
    /// </returns>
    public TaxWithholdAmountCur getWithholdAmount_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        CustVendTrans custVendTransToCancel;
        BankChequeTable bankChequeTable;
        BankAccountTrans bankAccountTrans;
        BankDeposit bankDeposit;
        TaxWithholdAmountCur taxWithholdAmount;
        LedgerJournalTrans ledgerJournalTransLoc;
        TaxWithholdTrans_IN taxWithholdTransCP;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        Voucher reversedVoucher;
        TransDate reversedDate;
        AccountNum reversedAccount;
        BankChequeNum bankChequeNum;
        BankDepositNum bankDepositNum;

        if (_ledgerJournalTrans.BankChequeNum)
        {
            bankChequeTable = BankChequeTable::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.BankChequeNum);
            custVendTransToCancel = BankChequeCancel::findCustVendTransForCheque_IN(bankChequeTable);
            bankAccountTrans = BankAccountTrans::findByAccountIDAndChequeNum(bankChequeTable.AccountID,bankChequeTable.ChequeNum);

            reversedVoucher = bankChequeTable.Voucher;
            reversedDate = bankChequeTable.TransDate;
            bankChequeNum = bankChequeTable.ChequeNum;
            reversedAccount = custVendTransToCancel.AccountNum;
        }
        else if (_ledgerJournalTrans.BankDepositNum)
        {
            select firstOnly Voucher, TransDate, DepositNum, CustAccount from bankDeposit
                where bankDeposit.AccountId == _ledgerJournalTrans.parmAccount()
                    && bankDeposit.DepositNum == _ledgerJournalTrans.BankDepositNum;

            bankAccountTrans = BankAccountTrans::findByDepositNum(_ledgerJournalTrans.BankDepositNum);

            reversedVoucher = bankDeposit.Voucher;
            reversedDate = bankDeposit.TransDate;
            bankDepositNum = bankDeposit.DepositNum;
            reversedAccount = bankDeposit.CustAccount;
        }

        select firstOnly ledgerJournalTransLoc
            where ledgerJournalTransLoc.Voucher == reversedVoucher
                && ledgerJournalTransLoc.TransDate == reversedDate
                && ((ledgerJournalTransLoc.PaymReference == bankChequeNum
                        && bankChequeNum)
                    || (ledgerJournalTransLoc.BankDepositNum == bankDepositNum
                        && bankDepositNum))
            join TCSGroup, TDSGroup from ledgerJOurnalTransTaxExt
                where ledgerJournalTransTaxExt.LedgerJournalTrans == ledgerJournalTransLoc.RecId
                    && ledgerJournalTransTaxExt.TDSGroup != '';

        if (ledgerJournalTransTaxExt.TDSGroup
            || ledgerJournalTransTaxExt.TCSGroup)
        {
            taxWithholdAmount = TaxWithholdTrans_IN::getWithholdTaxAmount(
                reversedVoucher,
                reversedDate,
                reversedAccount);

            if (TaxWithholdParameters_IN::find().CrossCompanyPayment)
            {
                while select crossCompany AdjustedTaxWithholdAmount, TaxWithholdAmountCur from taxWithholdTransCP
                    where taxWithholdTransCP.SettlementVoucher == reversedVoucher
                        && taxWithholdTransCP.TransDate == bankAccountTrans.TransDate
                        && taxWithholdTransCP.dataAreaId != curext()
                {
                    taxWithholdTransCP.TaxWithholdAmountCur = taxWithholdTransCP.AdjustedTaxWithholdAmount ?
                        taxWithholdTransCP.AdjustedTaxWithholdAmount : taxWithholdTransCP.TaxWithholdAmountCur;
                    taxWithholdAmount += taxWithholdTransCP.TaxWithholdAmountCur;
                }
            }
        }

        return taxWithholdAmount * -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankVoucher_LV</Name>
				<Source><![CDATA[
    void initBankVoucher_LV(BankVoucher _voucher, LedgerJournalTrans _ledgerJournalTrans)
    {
        VendTable vendTable_LV;
        CustTable custTable_LV;
        BankAccountTable bankAccountTable_LV;
        VendBankAccount vendBankAccount_LV;
        CustBankAccount custBankAccount_LV;
        LedgerJournalTrans ledgerJournalTrans_orig;
        CompanyId company;
        Voucher voucher;

        if (_ledgerJournalTrans.ForeignCompany)
        {
            company = _ledgerJournalTrans.ForeignCompany;
            voucher = _ledgerJournalTrans.ForeignVoucher;
        }
        else
        {
            company = _ledgerJournalTrans.company();
            voucher = _ledgerJournalTrans.Voucher;
        }

        changecompany(company)
        {
            select firstonly ledgerJournalTrans_orig
                where ledgerJournalTrans_orig.Voucher == voucher;
        }

        _voucher.parmBankCentralBankPurposeCode_LV(ledgerJournalTrans_orig.BankCentralBankPurposeCode);
        _voucher.parmBankCentralBankPurposeText_LV(ledgerJournalTrans_orig.BankCentralBankPurposeText);
        _voucher.parmBankPaymentRegistrationNum_LV(ledgerJournalTrans_orig.BankPaymentRegistrationNum_LV);

        if (ledgerJournalTrans_orig.AccountType == LedgerJournalACType::Vend)
        {
            if (ledgerJournalTrans_orig.CustVendBankAccountId)
            {
                vendBankAccount_LV = VendBankAccount::findByCompany(
                    ledgerJournalTrans_orig.Company,
                    ledgerJournalTrans_orig.parmAccount(),
                    ledgerJournalTrans_orig.CustVendBankAccountId);

                _voucher.parmAddressCountryRegionId_LV(vendBankAccount_LV.countryRegionId());
            }
            else
            {
                vendTable_LV = VendTable::findByCompany(ledgerJournalTrans_orig.Company, ledgerJournalTrans_orig.parmAccount());
                _voucher.parmAddressCountryRegionId_LV(vendTable_LV.countryRegionId());
            }
        }

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            if (ledgerJournalTrans_orig.CustVendBankAccountId)
            {
                vendBankAccount_LV = VendBankAccount::findByCompany(
                    _ledgerJournalTrans.OffsetCompany,
                    _ledgerJournalTrans.parmOffsetAccount(),
                    ledgerJournalTrans_orig.CustVendBankAccountId);

                _voucher.parmAddressCountryRegionId_LV(vendBankAccount_LV.countryRegionId());
            }
            else
            {
                vendTable_LV = VendTable::findByCompany(_ledgerJournalTrans.OffsetCompany, _ledgerJournalTrans.parmOffsetAccount());
                _voucher.parmAddressCountryRegionId_LV(vendTable_LV.countryRegionId());
            }
        }

        if (ledgerJournalTrans_orig.AccountType == LedgerJournalACType::Cust)
        {
            if (ledgerJournalTrans_orig.CustVendBankAccountId)
            {
                custBankAccount_LV = CustBankAccount::findByCompany(
                    ledgerJournalTrans_orig.Company,
                    ledgerJournalTrans_orig.parmAccount(),
                    ledgerJournalTrans_orig.CustVendBankAccountId);

                _voucher.parmAddressCountryRegionId_LV(custBankAccount_LV.countryRegionId());
            }
            else
            {
                custTable_LV = CustTable::findByCompany(ledgerJournalTrans_orig.Company, ledgerJournalTrans_orig.parmAccount());
                _voucher.parmAddressCountryRegionId_LV(custTable_LV.countryRegionId());
            }
        }

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
        {
            if (ledgerJournalTrans_orig.CustVendBankAccountId)
            {
                custBankAccount_LV = CustBankAccount::findByCompany(
                    _ledgerJournalTrans.OffsetCompany,
                    _ledgerJournalTrans.parmOffsetAccount(),
                    ledgerJournalTrans_orig.CustVendBankAccountId);

                _voucher.parmAddressCountryRegionId_LV(custBankAccount_LV.countryRegionId());
            }
            else
            {
                custTable_LV = CustTable::findByCompany(_ledgerJournalTrans.OffsetCompany, _ledgerJournalTrans.parmOffsetAccount());
                _voucher.parmAddressCountryRegionId_LV(custTable_LV.countryRegionId());
            }
        }

        //For Bank-Bank transaction.
        if (ledgerJournalTrans_orig.AccountType == LedgerJournalACType::Bank
            && ledgerJournalTrans_orig.OffsetAccountType == LedgerJournalACType::Bank)
        {
            bankAccountTable_LV = BankAccountTable::findByCompany(ledgerJournalTrans_orig.OffsetCompany, ledgerJournalTrans_orig.parmOffsetAccount());

            if (!_ledgerJournalTrans.parmOffsetAccount())
            {
                if (_ledgerJournalTrans.parmAccount() == ledgerJournalTrans_orig.parmAccount())
                {
                    bankAccountTable_LV = BankAccountTable::findByCompany(ledgerJournalTrans_orig.OffsetCompany, ledgerJournalTrans_orig.parmOffsetAccount());
                }
                else
                {
                    bankAccountTable_LV = BankAccountTable::findByCompany(ledgerJournalTrans_orig.Company, ledgerJournalTrans_orig.parmAccount());
                }
            }

            _voucher.parmAddressCountryRegionId_LV(bankAccountTable_LV.countryRegionId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount ledgerDimension(LedgerJournalTrans _journalTrans)
    {
        return BankAccountTable::findLedgerDimension(_journalTrans.parmAccount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeBankChequePaymentTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes invoices that were paid by a check that is being cancelled.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that contains information about a check cancellation.
    /// </param>
    private void removeBankChequePaymentTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        VendTrans vendTrans;
        CustTrans custTrans;
        CustVendTrans custVendTrans;
        BankChequePaymTrans bankChequePaymTrans;
        CompanyId custVendCompany;

        // If there is a value for the offset company, use that company to find the customer or vendor transaction. Otherwise use the primary company.
        custVendCompany = (_ledgerJournalTrans.OffsetCompany != '') ? _ledgerJournalTrans.OffsetCompany : _ledgerJournalTrans.Company;

        if (_ledgerJournalTrans.TransactionType == LedgerTransType::Vend
            || _ledgerJournalTrans.TransactionType == LedgerTransType::Cust)
        {
            changecompany(custVendCompany)
            {
                if (_ledgerJournalTrans.TransactionType == LedgerTransType::Vend)
                {
                    select firstonly vendTrans
                        where vendTrans.RecId == _ledgerJournalTrans.BankChequeDepositTransRefRecID;

                    custVendTrans = vendTrans.data();
                }
                else if (_ledgerJournalTrans.TransactionType == LedgerTransType::Cust)
                {
                    select firstonly custTrans
                        where custTrans.RecId == _ledgerJournalTrans.BankChequeDepositTransRefRecID;

                    custVendTrans = custTrans.data();
                }
            }

            Debug::assert(custVendTrans.RecId != 0);

            delete_from bankChequePaymTrans
                where bankChequePaymTrans.TransDate == custVendTrans.TransDate
                    && bankChequePaymTrans.Voucher == custVendTrans.Voucher
                    && bankChequePaymTrans.ChequeNum == _ledgerJournalTrans.BankChequeNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBankVoucherSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the source of bank voucher.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The journal line record.
    /// </param>
    /// <param name="_bankVoucher">
    /// The bank voucher.
    /// </param>
    protected void setBankVoucherSource(
        LedgerJournalTrans _ledgerJournalTrans,
        BankVoucher _bankVoucher)
    {
        BankDocumentTableMap bankDocumentTableMap;
        BankBridgingTrans bankBridgingTrans = BankBridgingTrans::findByClearedLedgerJournalTransRecId(_ledgerJournalTrans.RecId);

        // For bridging posting, if it is not check related, then set the source to the bridged LedgerJournalTrans.
        if (bankBridgingTrans && !bankBridgingTrans.IsCheck && isOffset)
        {
            _bankVoucher.parmSourceTableId(tableNum(LedgerJournalTrans));
            _bankVoucher.parmSourceRecId(bankBridgingTrans.BridgedLedgerJournalTransRecId);
            LedgerJournalTrans ledgerJournalTransBridged = LedgerJournalTrans::findRecId(bankBridgingTrans.BridgedLedgerJournalTransRecId, false);
            if (ledgerJournalTransBridged.parmBankCurrencyAmount() && BankDocumentTable::findBySource(ledgerJournalTransBridged.TableId, ledgerJournalTransBridged.RecId))
            {
                _bankVoucher.parmBankCurrencyAmount(ledgerJournalTransBridged.parmBankCurrencyAmount());
            }
        }
        else if (_ledgerJournalTrans.BankChequeNum
            && (!ReferOfBankAccountTransForBankTransferInVendPaymJourWithCheckFlight::instance().isEnabled() || isOffset))
        {
            bankDocumentTableMap = BankChequeTable::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.BankChequeNum);
            _bankVoucher.parmSourceTableId(bankDocumentTableMap.TableId);
            _bankVoucher.parmSourceRecId(bankDocumentTableMap.RecId);
            if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::BankChequeReversal)
            {
                _bankVoucher.parmBankCurrencyAmount(-bankDocumentTableMap.parmBankCurrencyAmount());
            }
            else
            {
                _bankVoucher.parmBankCurrencyAmount(bankDocumentTableMap.parmBankCurrencyAmount());
            }
        }
        else if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::BankDepositPaymCancel)
        {
            bankDocumentTableMap = BankDeposit::find(_ledgerJournalTrans.BankChequeDepositTransRefRecID);
            _bankVoucher.parmSourceTableId(bankDocumentTableMap.TableId);
            _bankVoucher.parmSourceRecId(bankDocumentTableMap.RecId);
            _bankVoucher.parmBankCurrencyAmount(-bankDocumentTableMap.parmBankCurrencyAmount());
        }
        else
        {
            _bankVoucher.parmSourceTableId(_ledgerJournalTrans.TableId);
            _bankVoucher.parmSourceRecId(_ledgerJournalTrans.RecId);

            if (_ledgerJournalTrans.parmBankCurrencyAmount() && BankDocumentTable::findBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId))
            {
                _bankVoucher.parmBankCurrencyAmount(_ledgerJournalTrans.parmBankCurrencyAmount());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReceiveBankInfo</Name>
				<Source><![CDATA[
    private void updateReceiveBankInfo(LedgerJournalTrans _ledgerJournalTrans, BankVoucher _bankVoucher)
    {
        if (_ledgerJournalTrans.BankChequeNum && !isOffset)
        {
            _bankVoucher.parmChequeNum('');
            _bankVoucher.parmPaymReference('');
            str chequeInformation = strFmt("@CashManagement:InterBankDescription", _ledgerJournalTrans.BankChequeNum);
            str originTransactionTxt = _bankVoucher.parmTransactionTxt();
            _bankVoucher.parmTransactionTxt(originTransactionTxt == '' ? chequeInformation :  originTransactionTxt + ' ' + chequeInformation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankClientLog_RU</Name>
				<Source><![CDATA[
    protected void updateBankClientLog_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        BankClientOutPaymentLog_RU outPaymentLog;
        BankPaymentOrderJour_RU paymentOrderJour;
        BankCurrencyTransferLog_RU currencyTransferLog;

        paymentOrderJour = _ledgerJournalTrans.bankPaymentOrderJour_RU();

        if (paymentOrderJour)
        {
            outPaymentLog = paymentOrderJour.bankClientPaymentOutLog(true);
            if (outPaymentLog)
            {
                outPaymentLog.PaymStatus = PaymOrderStatus_RU::Posted;
                outPaymentLog.update();
            }
        }
        else
        {
            currencyTransferLog = BankCurrencyTransferLog_RU::findByLedgerTrans(
                _ledgerJournalTrans.JournalNum,
                _ledgerJournalTrans.Voucher);

            outPaymentLog = BankClientOutPaymentLog_RU::bankClientOutPayment(
                currencyTransferLog.TableId,
                currencyTransferLog.RecId,
                true);

            if (outPaymentLog)
            {
                outPaymentLog.PaymStatus = PaymOrderStatus_RU::Posted;
                outPaymentLog.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get tax amount calculated by GTE
    /// </summary>
    /// <param name = "_ledgerJournalTrans">the journal line for which tax is calculated</param>
    /// <returns>tax amount calculated by GTE</returns>    
    protected TaxAmount getTaxAmountGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GTE>
        TaxAmount           taxAmountGTE;         
        ITaxableDocument    taxableDocument;
        ITaxDocument        taxDocumentObject;
        LedgerJournalTrans  ledgerJournalTransGTE;
        ITaxDocumentLine    taxDocumentLineObject;
        Microsoft.Dynamics365.Tax.Core.ITaxDocumentLineExt1 taxDocumentLineObjectExt1;

        #TaxEngineService
                
        taxableDocument = TaxableDocumentObject::construct(
            TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans));
        
        taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
        if (taxDocumentObject)
        {
            taxDocumentLineObject = taxDocumentObject.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                
            if (taxDocumentLineObject)
            {
                taxDocumentLineObjectExt1 = ERCast::asObject(taxDocumentLineObject) as Microsoft.Dynamics365.Tax.Core.ITaxDocumentLineExt1;

                ledgerJournalTransGTE = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, false);

                if (taxDocumentLineObjectExt1)
                {
                    taxAmountGTE = taxDocumentLineObjectExt1.sumByTaxAccountingProviderExcludeSubLines(
                        Microsoft.Dynamics365.Tax.DataModel.Enum.TaxAccountingProvider::Bank,
                        Microsoft.Dynamics365.Tax.DataModel.Enum.TaxAcctPostingProfDistributionSide::Credit,
                        '',
                        '').amountTransactionCurrency();
                    taxAmountGTE -= taxDocumentLineObjectExt1.sumByTaxAccountingProviderExcludeSubLines(
                        Microsoft.Dynamics365.Tax.DataModel.Enum.TaxAccountingProvider::Bank,
                        Microsoft.Dynamics365.Tax.DataModel.Enum.TaxAcctPostingProfDistributionSide::Debit,
                        '',
                        '').amountTransactionCurrency();
                }

                //Because for bank, ledgerJOurnalTrans amount has been put reversely before calling into this method, therefore, tax amount should be reversed.
                taxAmountGTE = -taxAmountGTE;
                    
                if (ledgerJournalTransGTE.parmOffsetLedgerDimension() == 0 && taxDocumentLineObject.priceInclTax())
                {
                    taxAmountGTE = taxDocumentLineObject.getInclTax().amountTransactionCurrency();
                }
            }
        } 

        return taxAmountGTE;
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettlementVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the settlement voucher type.
    /// </summary>
    /// <param name = "_originalLedgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the settlement voucher type is selectedTransact; otherwise, false.
    /// </returns>
    protected boolean checkSettlementVoucher(LedgerJournalTrans _originalLedgerJournalTrans)
    {
        return (_originalLedgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Associates a non fiscal operation to the ledger journal trans whose account type is bank.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    ///     The ledger voucher.
    /// </param>
    /// <param name = "_posting">
    ///     The posting type.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    ///     The ledger journal trans whose account type is bank.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    ///     The original ledger journal trans.
    /// </param>
    /// <param name = "_interCompany">
    ///     The inter company parameter.
    /// </param>
    /// <param name = "_reversalsMayExist">
    ///     The reversal parameter.
    /// </param>
    /// <param name = "_isDueToDueFromAccount">
    ///     The due to due from account parameter.
    /// </param>
    void updateNow(LedgerVoucher _ledgerVoucher,
        LedgerPostingType _posting,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _originalLedgerJournalTrans,
        boolean _interCompany = false,
        boolean _reversalsMayExist = true,
        boolean _isDueToDueFromAccount = false)
    {
        BankVoucher bankVoucher;
        TaxAmount taxAmount;
        LedgerJournalType ledgerJournalType;     

        // <GIN>
        real taxWithholdAmount = 0;
        boolean checkTaxWithholdParameter = TaxWithholdParameters_IN::checkTaxParameters();
        // </GIN>

        CurrencyExchangeHelper exchangeRateHelper;
        DimensionDefault defaultDimension;
        boolean skipDimensionValidation;

        ttsbegin;

        ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            if (!TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans).skipTaxDocument())
            {
                taxAmount = this.getTaxAmountGTE(_ledgerJournalTrans);
            }
            else
            {
                taxAmount = 0;
            }
        }
        else
        {
        // </GTE>
            taxAmount = taxVoucherService.taxAmountForBankType(_originalLedgerJournalTrans, _interCompany, _posting, _isDueToDueFromAccount);
        // <GTE>
        }
        // </GTE>

        // <GIN>
        if (checkTaxWithholdParameter)
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

            if (ledgerJournalTransTaxExt.tdsGroup || ledgerJournalTransTaxExt.tcsGroup)
            {
                if (this.checkSettlementVoucher(_originalLedgerJournalTrans)
                    && _ledgerVoucher.parmCheckBank_IN())
                {
                    taxWithholdAmount = 0;
                    _ledgerVoucher.parmCheckBank_IN(false);
                }
                else
                {
                    taxWithholdAmount = taxVoucherService.taxWithholdAmountForBankType_IN(_originalLedgerJournalTrans);
                }
            }

            if (!taxWithholdAmount
                && (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::BankChequeReversal
                    || _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::BankDepositPaymCancel))
            {
                taxWithholdAmount = this.getWithholdAmount_IN(_ledgerJournalTrans);
            }
        }
        // </GIN>

        if (_posting == LedgerPostingType::InterCompany)
        {
            LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
            exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
            exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
            exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

            // Assume that this is always on account type of ledger
            Debug::assert(_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger);

            LedgerVoucherTransObject ledgerVoucherTransObject = this.initInterCompanyLedgerVoucherTransObject(
                _ledgerJournalTrans,
                ledgerVoucherObject,
                _posting,
                exchangeRateHelper,
                taxAmount);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            if (_originalLedgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                && _originalLedgerJournalTrans.FurtherPostingType == NoYes::Yes)
            {
                // When dealing with bridging posting use the original dimensions posted to the bridging account
                defaultDimension = _originalLedgerJournalTrans.OffsetDefaultDimension;
                skipDimensionValidation = true;
            }
            else
            {
                defaultDimension = _ledgerJournalTrans.DefaultDimension;
            }

            // Create new BankAccountTrans
            bankVoucher = this.initBankVoucher(_ledgerJournalTrans, taxAmount, taxWithholdAmount, defaultDimension, ledgerJournalType, skipDimensionValidation);            
            bankVoucher.post(_ledgerVoucher);

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                LedgerJournalTransUpdateBank::reverseServiceTaxRelatedVoucher_IN(_ledgerVoucher, _ledgerJournalTrans);
            }
        }

        bankVoucher = null;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.updateBankClientLog_RU(_ledgerJournalTrans);
        }

        if (ledgerJournalType == LedgerJournalType::BankChequeReversal)
        {
            if (!BrazilParameters::isEnabled())
            {
                this.cancelCheque(_ledgerJournalTrans);
            }
        }
        else if (ledgerJournalType == LedgerJournalType::BankDepositPaymCancel)
        {
            this.cancelDepositSlip(_ledgerJournalTrans);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInterCompanyLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize data for a new <c>LedgerVoucherTransObject</c> class instance for intercompany accounts.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to pass the transaction data.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> instance.
    /// </param>
    /// <param name="_posting">
    /// The posting type.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The <c>CurrencyExchangeHelper</c> instance.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <returns>
    /// The initialized <c>LedgerVoucherTransObject</c> class instance.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initInterCompanyLedgerVoucherTransObject(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _posting,
        CurrencyExchangeHelper _exchangeRateHelper,
        TaxAmount _taxAmount)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                _ledgerVoucherObject,
                _posting,
                _ledgerJournalTrans.parmLedgerDimension(),
                _ledgerJournalTrans.CurrencyCode,
                _ledgerJournalTrans.amount() + _taxAmount,
                _exchangeRateHelper);

        ledgerVoucherTransObject.parmSourceTableId(_ledgerJournalTrans.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_ledgerJournalTrans.RecId);
        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);
        
        if (ledgerVoucherTransObject.parmTransTxt() == '')
        {
            ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);
        }

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initializes data for a new <c>BankVoucher</c> class instance.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to pass the transaction data.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_taxWithholdAmount">
    /// The tax withhold amount.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimension.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The journal type..
    /// </param>
    /// <param name="_skipDimensionValidation">
    /// The flag skip Dimension Validation.
    /// </param>
    /// <returns>
    /// The new <c>BankVoucher</c> class instance.
    /// </returns>
    protected BankVoucher initBankVoucher(LedgerJournalTrans _ledgerJournalTrans,
        TaxAmount _taxAmount,
        real _taxWithholdAmount,
        DimensionDefault _defaultDimension,
        LedgerJournalType _ledgerJournalType,
        boolean _skipDimensionValidation)
    {
        BankVoucher bankVoucher = BankVoucher::newBankVoucher(
                                    _ledgerJournalTrans.amount() + _taxAmount
                                    // <GIN>
                                    - _taxWithholdAmount
                                    // </GIN>
                                    ,
                                    _ledgerJournalTrans.CurrencyCode,
                                    _ledgerJournalTrans.parmAccount(),
                                    _ledgerJournalTrans.PaymMode,
                                    _ledgerJournalTrans.PaymReference,
                                    _ledgerJournalTrans.BankDepositNum,
                                    _ledgerJournalTrans.Txt,
                                    LedgerPostingType::Bank,
                                    _defaultDimension,
                                    this.ledgerDimension(_ledgerJournalTrans),
                                    _ledgerJournalTrans.BankTransType,
                                    _ledgerJournalTrans.ExchRate,
                                    _ledgerJournalTrans.ExchRateSecond,
                                    Currency::noYes2UnknownNoYes(_ledgerJournalTrans.Triangulation),
                                    _ledgerJournalTrans.ReportingCurrencyExchRate,
                                    _ledgerJournalTrans.ReportingCurrencyExchRateSecondary,
                                    // Pass in the payment order id from the ledger journal trans record when creating the
                                    // bank trans record.
                                    _ledgerJournalTrans.BankChequeNum);        

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            bankVoucher.parmBankClientPaymentRecId_RU(BankClientPayment_RU::recIdByRef(_ledgerJournalTrans));
        }

        bankVoucher.parmFinTag(_ledgerJournalTrans.FinTag);
        bankVoucher.parmReverseTransDate(LedgerJournalTrans::getTransDateByReverse(_ledgerJournalTrans.RecId));
        bankVoucher.parmTransDate(_ledgerJournalTrans.TransDate);
        bankVoucher.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);
        bankVoucher.parmJournalType(_ledgerJournalType);
        bankVoucher.parmReconcile(_ledgerJournalTrans.BankReconcileAccountAtPost);

        this.setBankVoucherSource(_ledgerJournalTrans, bankVoucher);
        if (ReferOfBankAccountTransForBankTransferInVendPaymJourWithCheckFlight::instance().isEnabled())
        {
            this.updateReceiveBankInfo(_ledgerJournalTrans, bankVoucher);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL, #isoHU]))
        {
            bankVoucher.parmExcludeExchAdj_PL(LedgerJournalTrans_Rcash::find(_ledgerJournalTrans.RecId).ExcludeExchAdj_PL);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLV]))
        {
            this.initBankVoucher_LV(bankVoucher, _ledgerJournalTrans);
        }

        bankVoucher.parmSkipDimensionValidation(_skipDimensionValidation);

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
            || _ledgerJournalTrans.orig().AccountType == LedgerJournalACType::FixedAssets)
        {
            LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
            if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
            {               
                bankVoucher.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());               
            }
        }

        return bankVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseServiceTaxRelatedVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse tax related service voucher.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    public static void reverseServiceTaxRelatedVoucher_IN(
        LedgerVoucher _ledgerVoucher,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        CustVendTrans custVendTrans;
        TaxTrans taxTransRelatedVchrOrigPay;
        TaxTrans_W taxTransRelatedVchrOrigPay_W;
        TaxTrans reversedTaxTrans;
        RefRecId voucherGroupId;
        LedgerJournalTrans ledgerJrnalTransOrigPaymnt;
        LedgerTransVoucherLink ledgerTransVoucherLink;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        NumberSeq numberSeqRelatedVoucher;
        NumberSequenceReference numberSeqRefRelatedVoucher;
        Voucher relatedVoucher;
        TaxTrans_IN taxTransIN;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerJournalType ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;

        // Related voucher entries shud be reversed for service tax cheque reveral.
        if (TaxParameters::isServiceTaxEnable_IN()
            && BankParameters::checkParameters_IN()
            && ledgerJournalType == LedgerJournalType::BankChequeReversal)
        {
            if (_ledgerJournalTrans.BankChequeDepositTransRefRecID != 0)
            {
                if (_ledgerJournalTrans.TransactionType == LedgerTransType::Cust)
                {
                    custVendTrans = CustTrans::find(_ledgerJournalTrans.BankChequeDepositTransRefRecID);
                    numberSeqRefRelatedVoucher = CustParameters::numRefCustPaymVoucher();
                }
                else if (_ledgerJournalTrans.TransactionType == LedgerTransType::Vend)
                {
                    custVendTrans = VendTrans::find(_ledgerJournalTrans.BankChequeDepositTransRefRecID);
                    numberSeqRefRelatedVoucher = VendParameters::numRefVendPaymentVoucher();
                }

                numberSeqRelatedVoucher = NumberSeq::newGetVoucher(numberSeqRefRelatedVoucher);
                relatedVoucher = numberSeqRelatedVoucher.voucher();
                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
                exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                ledgerJrnalTransOrigPaymnt = LedgerJournalTrans::findJournalForVoucher(custVendTrans.Voucher, custVendTrans.TransDate);// Get original payment line.
                voucherGroupId = LedgerTransVoucherLink::findVoucherGroupId(ledgerJrnalTransOrigPaymnt.Voucher, ledgerJrnalTransOrigPaymnt.TransDate);

                select firstonly ledgerTransVoucherLink
                    where ledgerTransVoucherLink.VoucherGroupId == voucherGroupId
                        && (ledgerTransVoucherLink.Voucher != ledgerJrnalTransOrigPaymnt.Voucher
                        || ledgerTransVoucherLink.TransDate != ledgerJrnalTransOrigPaymnt.TransDate);

                // Get the tax amount from payment using the related voucher
                ttsbegin;

                ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                    relatedVoucher,
                    _ledgerVoucher.lastTransDate(),
                    _ledgerVoucher.parmSysModuleDefault(),
                    LedgerTransType::Tax);

                while select taxTransRelatedVchrOrigPay
                    where taxTransRelatedVchrOrigPay.Voucher == ledgerTransVoucherLink.Voucher
                        && taxTransRelatedVchrOrigPay.TransDate == ledgerTransVoucherLink.TransDate
                    exists join taxTransRelatedVchrOrigPay_W
                        where taxTransRelatedVchrOrigPay_W.TaxTrans == taxTransRelatedVchrOrigPay.RecId
                            && taxTransRelatedVchrOrigPay_W.TaxType_IN == TaxType_IN::ServiceTax
                {
                    reversedTaxTrans.clear();
                    reversedTaxTrans.data(taxTransRelatedVchrOrigPay);
                    reversedTaxTrans.SourceBaseAmountCur = -taxTransRelatedVchrOrigPay.SourceBaseAmountCur;
                    reversedTaxTrans.SourceBaseAmountCurRegulated = -taxTransRelatedVchrOrigPay.SourceBaseAmountCurRegulated;
                    reversedTaxTrans.SourceRegulateAmountCur = -taxTransRelatedVchrOrigPay.SourceRegulateAmountCur;
                    reversedTaxTrans.SourceTaxAmountCur = -taxTransRelatedVchrOrigPay.SourceTaxAmountCur;
                    reversedTaxTrans.TaxAmount = -taxTransRelatedVchrOrigPay.TaxAmount;
                    reversedTaxTrans.TaxAmountCur = -taxTransRelatedVchrOrigPay.TaxAmountCur;
                    reversedTaxTrans.TaxBaseAmount = -taxTransRelatedVchrOrigPay.TaxBaseAmount;
                    reversedTaxTrans.TaxBaseAmountCur = -taxTransRelatedVchrOrigPay.TaxBaseAmountCur;
                    reversedTaxTrans.TransDate = _ledgerVoucher.lastTransDate();
                    reversedTaxTrans.Voucher = relatedVoucher;
                    reversedTaxTrans.TaxOrigin = (taxTransRelatedVchrOrigPay.TaxOrigin == TaxOrigin::TaxReversed) ? TaxOrigin::Tax : TaxOrigin::TaxReversed;
                    reversedTaxTrans.insert();

                    // Reverse required fields in TaxTrans_IN.
                    taxTransIN.data(TaxTrans_IN::findRefRecId(taxTransRelatedVchrOrigPay.RecId));
                    taxTransIN.DebitAmount = -taxTransIN.DebitAmount;
                    taxTransIN.JournalInvoiceDate = _ledgerVoucher.lastTransDate();
                    taxTransIN.JournalName = _ledgerJournalTrans.ledgerJournalTable().JournalName;
                    taxTransIN.JournalNum = _ledgerJournalTrans.JournalNum;
                    taxTransIN.JournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;
                    taxTransIN.PayableAmount = -taxTransIN.PayableAmount;
                    taxTransIN.RefRecId = reversedTaxTrans.RecId;
                    taxTransIN.SourceBaseAmountCur = -taxTransIN.SourceBaseAmountCur;
                    taxTransIN.SourceBaseAmountCurRegulated = -taxTransIN.SourceBaseAmountCurRegulated;
                    taxTransIN.TaxAmount = -taxTransIN.TaxAmount;
                    taxTransIN.TaxAmountSecondary = -taxTransIN.TaxAmountSecondary;
                    taxTransIN.TaxOrigin = reversedTaxTrans.TaxOrigin;
                    taxTransIN.TransDate = reversedTaxTrans.TransDate;
                    taxTransIN.Voucher = relatedVoucher;
                    taxTransIN.insert();

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                        _ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::ServiceTax_IN,
                        TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(taxTransRelatedVchrOrigPay.RecId),
                        reversedTaxTrans.CurrencyCode,
                        reversedTaxTrans.SourceTaxAmountCur,
                        exchangeRateHelper);

                    if (reversedTaxTrans.RecId)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(reversedTaxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
                }

                _ledgerVoucher.addVoucher(ledgerVoucherObject);

                // Get the voucher transactions for payment related to tax (i.e related voucher for payment)
                if (!LedgerTransVoucherLink::findVoucherGroupId(_ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate()))
                {
                    _ledgerVoucher.createVoucherLinks(_ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate());
                }

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>