<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalDeleteTransaction</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalDeleteTransaction</c> class deletes journal lines.
/// </summary>
public class LedgerJournalDeleteTransaction extends RunBaseBatch implements BatchRetryable
{
    QueryRun queryRun;
    private boolean shouldForceBatch = false;
    LedgerJournalEngine ledgerJournalEngine;

    private const int CurrentVersion = 4;
    private const int Version3 = 3;

    // if this is set in args parms then entire journal deletion should be done which means all lines for a journal
    // should be deleted, if all lines do need to get deleted then we set parmShouldDeleteJournal to true
    internal const str DeleteEntireJournal = 'DeleteJournal';
    private int numOfLines = -1;

    // variables that do need to be packed/unpacked
    boolean addSelectButton;
    private boolean shouldDeleteJournal;
    private boolean useSimpleMethod;
    private boolean isSimpleMethod;
    private boolean isSetBasedDelete;
    private LedgerJournalId journalNumToDelete;

    #LOCALMACRO.CurrentList
        addSelectButton
    #ENDMACRO

    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canDeleteInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if this can delete using setbased method.
    /// </summary>
    /// <param name = "_ledgerJournalTable">LedgerJournalTable for delete</param>
    /// <param name = "_query">query for delete</param>
    /// <returns>True if this can use setbased delete, otherwise false</returns>
    [HookableAttribute(true)]
    private boolean canDeleteInBatch(LedgerJournalTable _ledgerJournalTable, Query _query)
    {
        LedgerJournalTrans ledgerJournalTrans;

        boolean canDeleteSetBased = !CFMParameters::isPaymentRequestsEnabled();

        if (canDeleteSetBased)
        {
            canDeleteSetBased = this.checkForSysQueryRange(_query);
        }

        canDeleteSetBased = canDeleteSetBased && LedgerJournalDeleteTransaction::isPaymentStatusValidForDelete(_ledgerJournalTable, false);

        if (canDeleteSetBased && BudgetControlCheckRequest::isControlConfigured())
        {
            canDeleteSetBased = !BudgetSourceLedgerJournalTable::existsBudgetSourceByDraftLedgerReference(
                _ledgerJournalTable.company(),
                _ledgerJournalTable.JournalNum);
        }

        if (canDeleteSetBased && _ledgerJournalTable.JournalType == LedgerJournalType::Approval)
        {
            select firstOnly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && ledgerJournalTrans.TransferredBy != ''
                    && ledgerJournalTrans.Transferred == true;

            canDeleteSetBased = ledgerJournalTrans == null;
        }

        if (canDeleteSetBased && LedgerJournalTrans::isLegalEntityInCountryRegionForDelAct())
        {
            canDeleteSetBased = false;
        }

        if (canDeleteSetBased && BrazilParameters::isEnabled())
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                   && (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                   || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust);

            canDeleteSetBased = (ledgerJournalTrans.RecId == 0);
        }

        if (canDeleteSetBased)
        {
            canDeleteSetBased = this.canDeleteSetBasedRU(_ledgerJournalTable);
        }

        return canDeleteSetBased;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForSysQueryRange</Name>
				<Source><![CDATA[
    private boolean checkForSysQueryRange(Query _query)
    {
        boolean canDeleteSetBased = true;

        if (LedgerJournalDeleteTransactionSetBasedFlight::instance().isEnabled() && this.parmShouldDeleteJournal())
        {
            // No need to check sys query because the request for deletion is coming either from marking lines to delete or ledgerJournalTable (header) delete
            return canDeleteSetBased;
        }

        QueryBuildDataSource ledgerJournalTransDataSource = _query.dataSourceTable(tableNum(LedgerJournalTrans));
        QueryBuildDataSource ledgerJournalDeleteTransactionTmpDataSource = _query.dataSourceTable(tableNum(LedgerJournalDeleteTransactionTmp));
        for (int i = 1; i <= ledgerJournalTransDataSource.rangeCount(); i++)
        {
            QueryBuildRange range = ledgerJournalTransDataSource.range(i);

            if (range.field() != fieldNum(LedgerJournalTrans, JournalNum)
                && range.field() != fieldNum(LedgerJournalTrans, PaymentStatus)
                && (range.value() != '' || ledgerJournalDeleteTransactionTmpDataSource))
            {
                // change to row-by-row because the user added a SysQuery range
                canDeleteSetBased = false;
                break;
            }
        }

        return canDeleteSetBased;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteSetBasedRU</Name>
				<Source><![CDATA[
    private boolean canDeleteSetBasedRU(LedgerJournalTable _ledgerJournalTable)
    {
        boolean canDeleteSetBased = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            LedgerJournalTrans ledgerJournalTrans;

            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && (ledgerJournalTrans.AccountType == LedgerJournalACType::RCash
                    || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash);

            canDeleteSetBased = (ledgerJournalTrans.RecId == 0);

            if (canDeleteSetBased)
            {
                select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                   && (ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets_RU);

                canDeleteSetBased = (ledgerJournalTrans.RecId == 0);
            }
        }

        return canDeleteSetBased;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase  dialogRunbase  = new DialogRunbase("@SYS28500", this);

        if (this.parmAddSelectButton())
        {
            dialogRunbase.addText("@SYS138664");
            dialogRunbase.addMenuItemButton(MenuItemType::Display,menuitemdisplaystr(RunBaseQueryDialog),DialogMenuItemGroup::BottomGrp);
        }
        return dialogRunbase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last choice that is stored in the last value table.
    /// </summary>
    /// <remarks>
    ///    If no record can be found or the <c>unpack</c> method returns false, the <c>initParmDefault</c>
    ///    method will be called. Normally, this method should not be overridden.
    /// </remarks>
    public void getLast()
    {
        boolean addSelectButtonCopy;

        addSelectButtonCopy = addSelectButton;

        super();

        addSelectButton = addSelectButtonCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerJournalDeleteTransaction</c> object.
    /// </summary>
    /// <returns>A new instance of the <c>LedgerJournalDeleteTransaction</c> object.</returns>
    public static LedgerJournalDeleteTransaction construct()
    {
        return new LedgerJournalDeleteTransaction();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        queryRun = new QueryRun(querystr(LedgerJournalTransDelete));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [CurrentVersion, #CurrentList, queryRun.pack()];
        packed = this.appendVariableToPack(packed, varStr(shouldDeleteJournal), shouldDeleteJournal);
        packed = this.appendVariableToPack(packed, varStr(useSimpleMethod), useSimpleMethod);
        packed = this.appendVariableToPack(packed, varStr(numOfLines), numOfLines);
        packed = this.appendVariableToPack(packed, varStr(journalNumToDelete), journalNumToDelete);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(LedgerJournalDeleteTransaction) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAddSelectButton</Name>
				<Source><![CDATA[
    public boolean parmAddSelectButton(boolean _addSelectButton  = addSelectButton)
    {
        addSelectButton = _addSelectButton;

        return addSelectButton;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalEngine</Name>
				<Source><![CDATA[
    LedgerJournalEngine parmLedgerJournalEngine(LedgerJournalEngine _ledgerJournalEngine = ledgerJournalEngine)
    {
        ledgerJournalEngine = _ledgerJournalEngine;
        return ledgerJournalEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShouldDeleteJournal</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected internal boolean parmShouldDeleteJournal(boolean _deleteJournal = shouldDeleteJournal)
    {
        shouldDeleteJournal = _deleteJournal;
        return shouldDeleteJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalNumToDelete</Name>
				<Source><![CDATA[
    private LedgerJournalId parmJournalNumToDelete(LedgerJournalId _journalNumToDelete = journalNumToDelete)
    {
        journalNumToDelete = _journalNumToDelete;
        return journalNumToDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryRun</Name>
				<Source><![CDATA[
    public QueryRun parmQueryRun(QueryRun _queryRun = queryRun)
    {
        queryRun = _queryRun;
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseSimpleMethod</Name>
				<Source><![CDATA[
    public boolean parmUseSimpleMethod(boolean _useSimpleMethod = useSimpleMethod)
    {
        useSimpleMethod = _useSimpleMethod;
        return useSimpleMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        boolean isInBatchWithDeleteBatchFeatureEnabled = FeatureStateProvider::isFeatureEnabled(LedgerJournalDeleteBatchEnableFeature::instance()) && this.isInBatch();
        LedgerJournalDeleteTransactionInstrumentationLogger deleteLogger = LedgerJournalDeleteTransactionInstrumentationLogger::createLogger();

        if (queryRun.next())
        {
            ledgerJournalTrans = queryRun.get(tableNum(ledgerJournalTrans));
            ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();
        }
        else
        {
            Debug::assert(false);
        }

        #OCCRetryCount
        int backOffWait;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockException;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConfException;
        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        using (SysInstrumentationActivityContext runActivityContext = deleteLogger.activityContextWithCustomProperties(LedgerJournalInstrumentationConstants::ActivityTypeDeleteJournal))
        {
            // Get the total number of results returned by the query
            int actualNumberOfLinesBeingDeleted = QueryRun::getQueryRowCount(queryRun.query(), intMax());
            runActivityContext.addCustomProperty(LedgerJournalInstrumentationConstants::DeleteJournalNumOfLines, ApplicationCommonInstrumentationMagnitude::log10magnitude(actualNumberOfLinesBeingDeleted));
            runActivityContext.addCustomProperty(LedgerJournalInstrumentationConstants::ShouldDeleteJournal, deleteLogger.bool2str(this.parmShouldDeleteJournal()));
            try
            {
                if (LedgerJournalDeleteTransactionUnlockJournalFlight::instance().isEnabled() && !actualNumberOfLinesBeingDeleted)
                {
                    // If actual number of lines to be deleted is 0 then log a warning and unlock journal
                    this.logWarningAndUnlockJournalIfLinesToDeleteIsZero(runActivityContext);
                    return;
                }

                if (this.parmShouldDeleteJournal())
                {
                    LedgerJournalDeleteTransaction::isPaymentStatusValidForDelete(ledgerJournalTable, true);
                }

                if (ledgerJournalTrans.RecId != 0 && RetailPaymentsJournalLineHelper::canDeleteJournalLine(ledgerJournalTable, ledgerJournalTrans))
                {
                    throw error("@MCR28910");
                }

                if (isInBatchWithDeleteBatchFeatureEnabled)
                {
                    isSimpleMethod = this.parmUseSimpleMethod();
                }
                else if (ledgerJournalEngine)
                {
                    isSimpleMethod = ledgerJournalEngine.parmIsSimpleMethod();
                }

                ttsbegin;

                this.deleteJournal(ledgerJournalTable);
                runActivityContext.addCustomProperty(LedgerJournalInstrumentationConstants::DeleteJournalIsSetBasedDelete, deleteLogger.bool2str(isSetBasedDelete));

                ttscommit;

                info(strFmt("@LedgerJournal:LedgerJournalDeleteComplete", ledgerJournalTable.JournalNum));
            }
            catch (deadLockException)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        backOffWait = RandomGenerate::construct().randomInt(100, 5000);
                        sleep(xSession::currentRetryCount() * backOffWait);
                        retry;
                    }
                    else
                    {
                        deleteLogger.logException(
                            deadlockException,
                            strFmt('Maximum retry on deadlock exception. retry count:%1, isBatch:%2',
                                    xSession::currentRetryCount(),
                                    deleteLogger.bool2str(this.isInBatch())));

                        throw deadLockException;
                    }
                }
                else
                {
                    deleteLogger.logException(
                        deadlockException,
                        strFmt('Deadlock. retry count:%1, isBatch:%2',
                            xSession::currentRetryCount(),
                            deleteLogger.bool2str(this.isInBatch())));

                    throw deadLockException;
                }
            }
            catch (updateConfException)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        backOffWait = RandomGenerate::construct().randomInt(100, 5000);
                        sleep(xSession::currentRetryCount() * backOffWait);
                        retry;
                    }
                    else
                    {
                        deleteLogger.logException(
                            updateConfException,
                            strFmt('Maximum retry on update conflict exception. retry count:%1, isBatch:%2',
                                    xSession::currentRetryCount(),
                                    deleteLogger.bool2str(this.isInBatch())));
                        throw Exception::UpdateConflictNotRecovered;
                    }
                }
                else
                {
                    deleteLogger.logException(
                        updateConfException,
                        strFmt('Update conflict. retry count:%1, isBatch:%2',
                            xSession::currentRetryCount(),
                            deleteLogger.bool2str(this.isInBatch())));
                    throw updateConfException;
                }
            }
            catch (transientSqlConnectionError)
            {
                if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    deleteLogger.logException(
                        transientSqlConnectionError,
                        strFmt('Maximum retry on transient SQL connection error. retry count:%1, isBatch:%2',
                                xSession::currentRetryCount(),
                                deleteLogger.bool2str(this.isInBatch())));
                    throw transientSqlConnectionError;
                }
            }

            runActivityContext.addCustomProperty(LedgerJournalInstrumentationConstants::IsBatch, deleteLogger.bool2str(this.isInBatch()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournal</Name>
				<Source><![CDATA[
    protected void deleteJournal(LedgerJournalTable _ledgerJournalTable)
    {
        boolean isInBatchWithDeleteBatchFeatureEnabled = FeatureStateProvider::isFeatureEnabled(LedgerJournalDeleteBatchEnableFeature::instance()) && this.isInBatch();

        if (_ledgerJournalTable && isInBatchWithDeleteBatchFeatureEnabled)
        {
            // update the session so it can pass validation on LedgerJournalTrans.checkAllowEdit()
            LedgerJournalTable::setSessionInfo(_ledgerJournalTable);
        }

        if (this.canDeleteInBatch(_ledgerJournalTable, queryRun.query()))
        {
            LedgerJournalDeleteTransaction::checkMCRIsDeductionParent(_ledgerJournalTable);

            isSetBasedDelete = true;           
   
            // delete the entire journal at once because row-by-row does not perform
            if (isInBatchWithDeleteBatchFeatureEnabled)
            {
                LedgerJournalDeleteTransaction::deleteJournalSetBased([_ledgerJournalTable, this.parmShouldDeleteJournal(), isSimpleMethod]);
            }
            else
            {
                SysOperationSandbox::callStaticMethod(
                            classNum(LedgerJournalDeleteTransaction),
                            staticMethodStr(LedgerJournalDeleteTransaction, deleteJournalSetBased),
                            [_ledgerJournalTable, this.parmShouldDeleteJournal(), isSimpleMethod],
                            "@SYS28500");
            }
        }
        else
        {
            isSetBasedDelete = false;

            if (isInBatchWithDeleteBatchFeatureEnabled)
            {
                LedgerJournalDeleteTransaction::deleteLinesRowByRow([queryRun.pack(), _ledgerJournalTable, this.parmShouldDeleteJournal(), isSimpleMethod]);
            }
            else
            {
                SysOperationSandbox::callStaticMethod(
                            classNum(LedgerJournalDeleteTransaction),
                            staticMethodStr(LedgerJournalDeleteTransaction, deleteLinesRowByRow),
                            [queryRun.pack(), _ledgerJournalTable, this.parmShouldDeleteJournal(), isSimpleMethod],
                            "@SYS28500");
            }
        }

        // Reset LedgerJournalEngine internal caches, and re-calculate balances.
        if (ledgerJournalEngine)
        {
            ledgerJournalEngine.deleteForLedgerJournalTable();
            ledgerJournalEngine.newJournalActive(_ledgerJournalTable, true);
        }

        // clear session if it is not deleting entire journal
        if (isInBatchWithDeleteBatchFeatureEnabled &&
                    !this.parmShouldDeleteJournal())
        {
            LedgerJournalTable::unlockJournal(_ledgerJournalTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer         version     = conpeek(packedClass,1);
        PackedQueryRun  packedQuery;

        switch (version)
        {
            case CurrentVersion:
                [version, #CurrentList, packedQuery] = packedClass;
                shouldDeleteJournal = this.extractPackedVariable(packedClass, varStr(shouldDeleteJournal));
                useSimpleMethod = this.extractPackedVariable(packedClass, varStr(useSimpleMethod));
                numOfLines = this.extractPackedVariable(packedClass, varStr(numOfLines));
                journalNumToDelete = this.extractPackedVariable(packedClass, varStr(journalNumToDelete));
                break;

            case Version3:
                Counter progressTotal;

                [version, progressTotal, addSelectButton, packedQuery] = packedClass;

                break;

            default :
                return false;
        }

        if (packedQuery && SysQuery::isPackedOk(packedQuery))
        {
            queryRun = new QueryRun(packedQuery);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryForJournalNumber</Name>
				<Source><![CDATA[
    private void updateQueryForJournalNumber(LedgerJournalId _journalNum)
    {
        QueryBuildRange rangeJournalNum;
        QueryBuildRange rangePaymentStatus;

        rangeJournalNum = queryRun.query().dataSourceTable(tablenum(LedgerJournalTrans))
            .findRange(fieldnum(LedgerJournalTrans, JournalNum));
        rangeJournalNum.value(queryValue(_journalNum));

        rangePaymentStatus = queryRun.query().dataSourceTable(tablenum(LedgerJournalTrans))
            .findRange(fieldnum(LedgerJournalTrans, PaymentStatus));
        
        if (!rangePaymentStatus)
        {
            rangePaymentStatus =  queryRun.query().dataSourceTable(tablenum(LedgerJournalTrans))
            .addRange(fieldnum(LedgerJournalTrans, PaymentStatus));
        }

        rangePaymentStatus.value(SysQuery::range(CustVendPaymStatus::Rejected, CustVendPaymStatus::Deleted) + ',' + queryValue(CustVendPaymStatus::None));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query selecting lines to delete with the journal number and payment status
    /// </summary>
    /// <param name = "ledgerJournalTrans">The journal line.</param>
    public void updateQueryBuild(LedgerJournalTrans ledgerJournalTrans)
    {
        this.updateQueryForJournalNumber(ledgerJournalTrans.JournalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object _calledFrom = null)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args, boolean displayRunBaseDialogPrompt = true)
    {
        LedgerJournalDeleteTransaction ledgerJournalDeleteTransaction = new LedgerJournalDeleteTransaction();

        if (args.parm() == LedgerJournalDeleteTransaction::DeleteEntireJournal)
        {
            ledgerJournalDeleteTransaction.parmShouldDeleteJournal(true);
        }

        LedgerJournalTable ledgerJournalTable;
        LedgerJournalEngine ledgerJournalEngine;

        boolean shouldProcessRecords;

        switch (args.dataset())
        {
            case tablenum(LedgerJournalTrans):
                ledgerJournalEngine = args.caller().ledgerJournalEngine();
                ledgerJournalTable = ledgerJournalEngine.ledgerJournalTable();

                // if the journal type = allocation, we don't want to display the 'Select' button in the dialog
                ledgerJournalDeleteTransaction.parmAddSelectButton(
                    ledgerJournalTable.JournalType != LedgerJournalType::Allocation &&
                    ledgerJournalTable.JournalType != LedgerJournalType::Elimination);

                ledgerJournalDeleteTransaction.getLast();
                ledgerJournalDeleteTransaction.updateQueryBuild(args.record());
                ledgerJournalDeleteTransaction.queryRun();

                if (displayRunBaseDialogPrompt)
                {
                    if (FeatureStateProvider::isFeatureEnabled(LedgerJournalDeleteBatchEnableFeature::instance()))
                    {
                        int lineCount = ledgerJournalTable.numOfLines();
                        ledgerJournalDeleteTransaction.parmNumOfLines(lineCount);
                        ledgerJournalDeleteTransaction.parmUseSimpleMethod(ledgerJournalEngine.parmIsSimpleMethod());
                        ledgerJournalDeleteTransaction.parmLedgerJournalEngine(ledgerJournalEngine);
                        ledgerJournalDeleteTransaction.parmJournalNumToDelete(ledgerJournalTable.JournalNum);

                        shouldProcessRecords = ledgerJournalDeleteTransaction.prompt() ? true : false;

                        if (ledgerJournalDeleteTransaction.parmShouldForceBatch() &&
                            ledgerJournalDeleteTransaction.batchInfo() &&
                            ledgerJournalDeleteTransaction.batchInfo().parmBatchExecute())
                        {
                            warning("@LedgerJournal:LedgerJournalDeleteForceBatch");
                        }
                    }
                    else
                    {
                        shouldProcessRecords = ledgerJournalDeleteTransaction.prompt() ? true : false;
                    }
                }
                else
                {
                    shouldProcessRecords = (Box::yesNo("@GeneralLedger:DeleteMarkedRecords", DialogButton::No) == DialogButton::Yes) ? true : false;
                }
                break;

            case tableNum(LedgerJournalTable):
                ledgerJournalTable = args.record();
                shouldProcessRecords = true;

                ledgerJournalDeleteTransaction.updateQueryForJournalNumber(ledgerJournalTable.JournalNum);
                break;

            default :
                throw error("@SYS18626");
        }

        if (shouldProcessRecords)
        {
            ledgerJournalDeleteTransaction.parmLedgerJournalEngine(ledgerJournalEngine);
            ledgerJournalDeleteTransaction.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerJournalTrans</c> table records in batch mode for the journal batch number
    /// given all of the <c>LedgerJournalsTrans</c> table records are marked on the form.
    /// </summary>
    /// <param name = "_formRun">The <c>FormRun</c> instance.</param>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> table buffer.</param>
    /// <returns>True if the records were deleted in batch; otherwise, false.</returns>
    public static boolean deleteInBatch(
        FormRun _formRun,
        ledgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.RecId)
        {
            return false;
        }        

        MultiSelectionHelper helper = MultiSelectionHelper::createFromCaller(_formRun);

        boolean deleteHandled = false;
       
        LedgerJournalDeleteTransaction ledgerJournalDeleteTransaction = LedgerJournalDeleteTransaction::construct();   
        LedgerJournalDeleteTransactionTmp ledgerJournalDeleteTransactionTmp;

        delete_from ledgerJournalDeleteTransactionTmp;

        LedgerJournalTrans ledgerJournalTrans = helper.getFirst();
        RecordInsertList refRecIdList = new RecordInsertList(tableNum(LedgerJournalDeleteTransactionTmp));

        while (ledgerJournalTrans.RecId != 0)
        {
            ledgerJournalDeleteTransactionTmp.RefRecId = ledgerJournalTrans.RecId;
            refRecIdList.add(ledgerJournalDeleteTransactionTmp);
            ledgerJournalTrans = helper.getNext();
        }           

        refRecIdList.insertDatabase();

        if (LedgerJournalDeleteTransactionSetBasedFlight::instance().isEnabled())
        {
            // Capture if all lines in journal were marked for deletion or not; if they were then we can do set based delete
            // but if only a subset is selected then we can not do any set based delete and deletion will be done row by row
            LedgerJournalDeleteTransaction::areAllJournalLinesMarkedForDeletion(_ledgerJournalTrans.JournalNum, ledgerJournalDeleteTransactionTmp, ledgerJournalDeleteTransaction);
        }        

        QueryBuildDataSource queryBuildDataSource =  ledgerJournalDeleteTransaction.parmQueryRun().query().dataSourceTable(tableNum(LedgerJournalTrans));
        QueryBuildDataSource tempQBDS = queryBuildDataSource.addDataSource(tableNum(ledgerJournalDeleteTransactionTmp));
        tempQBDS.joinMode(JoinMode::InnerJoin);
        tempQBDS.addLink(fieldNum(LedgerJournalTrans, RecId), fieldNum(LedgerJournalDeleteTransactionTmp, RefRecId));

        ledgerJournalDeleteTransaction.runOperation();

        deleteHandled = true;

        return deleteHandled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areAllJournalLinesMarkedForDeletion</Name>
				<Source><![CDATA[
    private static void areAllJournalLinesMarkedForDeletion(JournalId _journalBatchNumber, LedgerJournalDeleteTransactionTmp _selectedJournalLines, LedgerJournalDeleteTransaction _ledgerJournalDeleteTransaction)
    {
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _journalBatchNumber
            notexists join _selectedJournalLines
                where ledgerJournalTrans.RecId == _selectedJournalLines.RefRecId;

        boolean allJournalLinesMarkedForDeletion = ledgerJournalTrans.RecId ? false : true;
        _ledgerJournalDeleteTransaction.parmShouldDeleteJournal(allJournalLinesMarkedForDeletion);
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournalSetBased</Name>
				<Source><![CDATA[
    private static void deleteJournalSetBased(container _parameters)
    {
        LedgerJournalTable ledgerJournalTable;
        boolean deleteJournal, isSimpleMethod;

        [ledgerJournalTable, deleteJournal, isSimpleMethod] = _parameters;

        LedgerJournalDeleteTransaction::deleteJournalRelatedRowByRow(ledgerJournalTable, deleteJournal);

        LedgerJournalTrans_CN_Extension::releaseNumberForLedgerJournalTable_CN(ledgerJournalTable, isSimpleMethod);
        LedgerJournalTrans::deleteForLedgerJournalTable(ledgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLinesRowByRow</Name>
				<Source><![CDATA[
    private static void deleteLinesRowByRow(container _parameters)
    {
        PackedQueryRun packedQueryRun;
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalVoucherTmp ledgerJournalVoucherTmp;
        boolean deleteJournal, isSimpleMethod;

        [packedQueryRun, ledgerJournalTable, deleteJournal, isSimpleMethod] = _parameters;  

        QueryRun queryRun = new QueryRun(packedQueryRun);
        queryRun.reset();

        ttsbegin;

        // If we are deleting all lines in the journal then clean up related subsystems that need cleanup only
        // if all lines are removed.
        
        // For example, if removing all lines in the approval journal then the we
        // need to put the invoice register back in the pool.  If we just remove one line then we don't.
        if (deleteJournal)
        {
            LedgerJournalDeleteTransaction::deleteJournalRelatedRowByRow(ledgerJournalTable, deleteJournal);
        }

        Voucher oldVoucher;

        NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable);

        if (numberSequenceTable.Continuous)
        {
            LedgerJournalDeleteTransaction::createLedgerJournalVoucherTempData(new Query(queryRun.query()), ledgerJournalVoucherTmp);
        }
        
        while (queryRun.next())
        {
            ledgerJournalTrans = queryRun.get(tableNum(LedgerJournalTrans));

            // validateDelete() is only needed if deleting a subset of the lines.
            if (deleteJournal || ledgerJournalTrans.validateDelete())
            {
                if (LedgerParameters::isChineseVoucher_CN())
                {
                    LedgerJournalEngine ledgerJournalEngine = LedgerJournalEngine::construct(ledgerJournalTable.JournalType);
                    ledgerJournalEngine.parmIsSimpleMethod(isSimpleMethod);
                    ledgerJournalEngine.formMethodDataSourceDeletePre_CN(ledgerJournalTrans);
                }

                // Updating related subsystems is different when deleting all lines
                // in the journal versus some of the lines in the journal.
                if (deleteJournal)
                {
                    LedgerJournalDeleteTransaction::deleteJournalRowByRowWhenDeletingEntireJournal(ledgerJournalTable, ledgerJournalTrans);
                }
                else
                {
                    LedgerJournalDeleteTransaction::deleteLedgerJournalTransRelated(ledgerJournalTrans);

                    ledgerJournalTrans.selectForUpdate(true);
                    ledgerJournalTrans.delete();
                }
            }
            else
            {
                warning(strfmt("@SYS90668", ledgerJournalTrans.Voucher));
            }
        }

        TaxUncommitted::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId, false);

        // When deleting the entire journal we do it set based towards the end of the transaction to lessen the
        // impact of SQL blocking.
        if (deleteJournal)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTrans);
            delete_from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;
        }

        LedgerJournalDeleteTransaction::releaseNumbers(ledgerJournalTable, ledgerJournalVoucherTmp, numberSequenceTable);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalVoucherTempData</Name>
				<Source><![CDATA[
    private static void createLedgerJournalVoucherTempData(Query _query, ledgerJournalVoucherTmp _ledgerJournalVoucherTemp)
    {
        QueryBuildDataSource qbds = _query.dataSourceTable(tableNum(LedgerJournalTrans));
        qbds.addGroupByAndSelectionField(fieldNum(LedgerJournalTrans, JournalNum));
        qbds.addGroupByAndSelectionField(fieldNum(LedgerJournalTrans, Voucher));
        qbds.orderMode(OrderMode::GroupBy);   
     
        QueryBuildDataSource qbdsTmp = _query.dataSourceTable(tableNum(LedgerJournalDeleteTransactionTmp));

        if (qbdsTmp)
        {            
            qbdsTmp.fields().dynamic(NoYes::No);
            qbdsTmp.fields().clearFieldList();
        }

        Map targetToSourceMap = new Map(Types::String, Types::Container);
        targetToSourceMap.insert(fieldStr(LedgerJournalVoucherTmp, JournalNum), [qbds.uniqueId(), fieldStr(LedgerJournalTrans, JournalNum)]);
        targetToSourceMap.insert(fieldStr(LedgerJournalVoucherTmp, Voucher), [qbds.uniqueId(), fieldStr(LedgerJournalTrans, Voucher)]);
        Query::insert_recordset(_ledgerJournalVoucherTemp, targetToSourceMap, _query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseNumbers</Name>
				<Source><![CDATA[
    private static void releaseNumbers(LedgerJournalTable _ledgerJournalTable, ledgerJournalVoucherTmp _ledgerJournalVoucherTemp, NumberSequenceTable _numberSequenceTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        while select Voucher, JournalNum from _ledgerJournalVoucherTemp
            notexists join ledgerJournalTrans
            where _ledgerJournalVoucherTemp.Voucher == ledgerJournalTrans.Voucher &&
                _ledgerJournalVoucherTemp.JournalNum == ledgerJournalTrans.JournalNum
        {
            LedgerJournalTrans::releaseNumber(_ledgerJournalTable.JournalType, _numberSequenceTable, _ledgerJournalVoucherTemp.Voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMCRIsDeductionParent</Name>
				<Source><![CDATA[
    private static void checkMCRIsDeductionParent(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans trans;
        TAMDeduction tamDeduction;

        select firstonly RecId from trans
            join tamDeduction
            where trans.JournalNum == _ledgerJournalTable.JournalNum
               && tamDeduction.LedgerJournalTransParentRecId == trans.RecId;

        if (trans.RecId != 0)
        {
            throw error("@MCR27446");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTemplate</Name>
				<Source><![CDATA[
    private static void deleteTemplate(LedgerJournalTable _ledgerJournalTable)
    {
        // delete associated LedgerJournalTransVoucherTemplate record
        if (_ledgerJournalTable.JournalType == LedgerJournalType::Daily ||
            _ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister)
        {
            LedgerJournalTransVoucherTemplate::deleteForJournalOrVoucher(_ledgerJournalTable.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePaymentOrderBudgetTransRU</Name>
				<Source><![CDATA[
    private static void deletePaymentOrderBudgetTransRU(LedgerJournalTable _ledgerJournalTable)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            PaymentOrderBudgetTrans_RU paymentOrderBudgetTrans_RU;

            LedgerJournalTrans::skipTableMethodsOnDelete(paymentOrderBudgetTrans_RU);

            delete_from paymentOrderBudgetTrans_RU
                where paymentOrderBudgetTrans_RU.JournalNum == _ledgerJournalTable.JournalNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUnpostedDomesticSalesTaxVoucherPL</Name>
				<Source><![CDATA[
    private static void deleteUnpostedDomesticSalesTaxVoucherPL(LedgerJournalTable _ledgerJournalTable)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicSalesTax)) &&
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            ExportSalesInvoiceDomesticTaxVoucher::deleteUnpostedDomesticSalesTaxVoucher(_ledgerJournalTable.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommittedWithholdIN</Name>
				<Source><![CDATA[
    private static void deleteTaxUncommittedWithholdIN(LedgerJournalTable _ledgerJournalTable)
    {
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(tableNum(LedgerJournalTable), _ledgerJournalTable.RecId, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxEngineLedgerJournalTransHeaderDeleteGTE</Name>
				<Source><![CDATA[
    private static void taxEngineLedgerJournalTransHeaderDeleteGTE(LedgerJournalTable _ledgerJournalTable)
    {
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            // delete record of <c>TaxEngineLedgerJournalTransHeader</c> related to this record.
            TaxEngineLedgerJournalTransHeader::deleteByLedgerJournalNum(_ledgerJournalTable.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAdvanceInvoiceLinkEEU</Name>
				<Source><![CDATA[
    private static void deleteAdvanceInvoiceLinkEEU(LedgerJournalTable _ledgerJournalTable)
    {
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]))
        {
            CzCustAdvanceInvoiceLink czCustAdvanceInvoiceLink;
            CzVendAdvanceInvoiceLink czVendAdvanceInvoiceLink;
            LedgerJournalTrans ledgerJournalTrans;

            LedgerJournalTrans::skipTableMethodsOnDelete(czCustAdvanceInvoiceLink);

            delete_from czCustAdvanceInvoiceLink
                exists join ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && ledgerJournalTrans.Voucher == czCustAdvanceInvoiceLink.Voucher
                    && ledgerJournalTrans.TransDate == czCustAdvanceInvoiceLink.TransDate
                    && czCustAdvanceInvoiceLink.PaymentCompany == curext();

            if (LedgerJournalDeleteTransactionSetBasedFlight::instance().isEnabled())
            {
                LedgerJournalTrans::skipTableMethodsOnDelete(czVendAdvanceInvoiceLink);
            }

            delete_from czVendAdvanceInvoiceLink
                where czVendAdvanceInvoiceLink.PaymentCompany == curext()
            exists join ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && ledgerJournalTrans.Voucher == czCustAdvanceInvoiceLink.Voucher
                    && ledgerJournalTrans.TransDate == czCustAdvanceInvoiceLink.TransDate
                    && czVendAdvanceInvoiceLink.Voucher == ledgerJournalTrans.Voucher
                    && czVendAdvanceInvoiceLink.TransDate == ledgerJournalTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxServiceTarrifForJournal</Name>
				<Source><![CDATA[
    private static void deleteTaxServiceTarrifForJournal(LedgerJournalTable _ledgerJournalTable)
    {
        TaxServiceTariff taxServiceTariff;
        LedgerJournalTrans ledgerJournalTrans;

        if (LedgerJournalDeleteTransactionSetBasedFlight::instance().isEnabled())
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(taxServiceTariff);
        }

        delete_from taxServiceTariff
            exists join ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                      && taxServiceTariff.ParentRecId == ledgerJournalTrans.RecId
                      && taxServiceTariff.ParentTableId == tableNum(LedgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBankDocument</Name>
				<Source><![CDATA[
    private static void deleteBankDocument(LedgerJournalTable _ledgerJournalTable)
    {
        BankDocumentTable bankDocumentTable;
        LedgerJournalTrans ledgerJournalTrans;

        if (LedgerJournalDeleteTransactionSetBasedFlight::instance().isEnabled())
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(bankDocumentTable);
        }

        delete_from bankDocumentTable
            exists join ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                && bankDocumentTable.SourceRelationType == ledgerJournalTrans.TableId
                && bankDocumentTable.SourceRecId == ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBudgetControl</Name>
				<Source><![CDATA[
    private static void deleteBudgetControl(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        // Bypass unnecessary calls to delete budget control if none exist for this journal
        boolean isBudgetRemovalNeeded = BudgetControlCheckRequest::isControlConfigured()
                && BudgetSourceLedgerJournalTable::existsBudgetSourceByDraftLedgerReference(_ledgerJournalTable.company(), _ledgerJournalTable.JournalNum);
            
        if (!isBudgetRemovalNeeded)
        {
            return;
        }

        // use a TTS because budget processing is performed on ttsCommit
        ttsBegin;

        while select JournalNum, Voucher from ledgerJournalTrans
            group by ledgerJournalTrans.JournalNum,
                ledgerJournalTrans.Voucher
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
        {
            ledgerJournalTrans.removeBudgetForVoucher();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentStatusValidForDelete</Name>
				<Source><![CDATA[
    internal static boolean isPaymentStatusValidForDelete(LedgerJournalTable _ledgerJournalTable, boolean _throwError)
    {
        LedgerJournalTrans ledgerJournalTrans;
        
        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
               && (ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Confirmed
               || ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Recieved
               || ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Sent);
        
        if (_throwError && ledgerJournalTrans.RecId != 0)
        {
            throw Error(strFmt("@SYS68189", CustVendPaymStatus::None, CustVendPaymStatus::Rejected));
        }

        return (ledgerJournalTrans.RecId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>putRecordsBackInPool</Name>
				<Source><![CDATA[
    private static void putRecordsBackInPool(LedgerJournalTable _ledgerJournalTable)
    {
        if (_ledgerJournalTable.JournalType == LedgerJournalType::Approval)
        {
            VendTrans vendTrans;
            LedgerJournalVoucherChanged journalChanged;

            while select * from vendTrans
                    where vendTrans.JournalNum == _ledgerJournalTable.JournalNum
                join ToVoucher from journalChanged
                    where journalChanged.FromVoucher == vendTrans.Voucher
                       && journalChanged.FromDate == vendTrans.TransDate
            {
                LedgerJournalEngine_Server::removeVoucher(vendTrans, _ledgerJournalTable, journalChanged.ToVoucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRowByRowCommon</Name>
				<Source><![CDATA[
    private static void deleteRowByRowCommon(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTable _ledgerJournalTable)
    {
        _ledgerJournalTrans.uncheckWithholdTransBR();
        _ledgerJournalTrans.updateForRCash();
        _ledgerJournalTrans.updateRAssetForDelete();

        if (_ledgerJournalTable.JournalType == LedgerJournalType::CustomsDeclaration_IT)
        {
            LedgerJournalTrans_Customs_IT::deleteRecord(_ledgerJournalTrans.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournalRowByRowWhenDeletingEntireJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the journal lines and its associated table records.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected static void deleteJournalRowByRowWhenDeletingEntireJournal(LedgerJournalTable _ledgerJournalTable, LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalDeleteTransaction::deleteRowByRowCommon(_ledgerJournalTrans, _ledgerJournalTable);

        LedgerJournalDeleteTransaction::deleteTemplate(_ledgerJournalTable);
        
        _ledgerJournalTrans.updateRelatedForDelete(_ledgerJournalTable);

        if (LedgerJournalTable::hasAnySpecTrans(_ledgerJournalTable.JournalNum))
        {
            LedgerJournalTable::deleteMarkedTransactionsForJournal(_ledgerJournalTable.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLedgerJournalTransRelated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes necessary logic per journal line when deleting a subset of the journal lines.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <remarks>
    /// Used when deleting a subset of the lines in the journal.
    /// </remarks>
    [Wrappable(true)]
    protected static void deleteLedgerJournalTransRelated(
        LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        LedgerJournalEngine_Server::updateCashDisc(_ledgerJournalTrans);

        if (_ledgerJournalTrans.ReasonRefRecID != 0 && ledgerJournalTable.Posted == NoYes::No)
        {
            ReasonTableRef::deleteByReference(_ledgerJournalTrans.ReasonRefRecID);
        }

        LedgerJournalDeleteTransaction::deleteRowByRowCommon(_ledgerJournalTrans, ledgerJournalTable);

        _ledgerJournalTrans.deleteBankDocument();

        if (CFMParameters::isPaymentRequestsEnabled())
        {
            CFMPaymentRequestPaymentLink::deletePaymentRequestLinkJournalTrans(_ledgerJournalTrans);
        }

        SpecTransManager specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans, false);
        specTransManager.deleteAll();

        _ledgerJournalTrans.removeBudgetForVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournalRelatedRowByRow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete lines from journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "deleteJournal">
    /// A boolean value indicating whether to delete lines from journal.
    /// </param>
    [Wrappable(true)]
    protected final static void deleteJournalRelatedRowByRow(LedgerJournalTable _ledgerJournalTable, boolean deleteJournal)
    {
        LedgerJournalDeleteTransactionInstrumentationLogger deleteLogger = LedgerJournalDeleteTransactionInstrumentationLogger::createLogger();
        using (SysInstrumentationActivityContext deleteActivityContext = deleteLogger.activityContext(LedgerJournalInstrumentationConstants::DeleteJournalRelatedRowByRow))
        {
            if (deleteJournal)
            {
                LedgerJournalDeleteTransaction::putRecordsBackInPool(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::deleteAdvanceInvoiceLinkEEU(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::taxEngineLedgerJournalTransHeaderDeleteGTE(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::deleteTaxUncommittedWithholdIN(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::deleteUnpostedDomesticSalesTaxVoucherPL(_ledgerJournalTable);
                LedgerJournalTrans_Error::deleteJournalErrorLinks(_ledgerJournalTable.JournalNum);
                LedgerJournalDeleteTransaction::deletePaymentOrderBudgetTransRU(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::deleteTaxServiceTarrifForJournal(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::deleteBankDocument(_ledgerJournalTable);
                LedgerJournalDeleteTransaction::deleteBudgetControl(_ledgerJournalTable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS28500";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// When this method returns true a job will be forced in batch with the current batch settings.
    /// </summary>
    /// <returns>True to force a batch run, otherwise false</returns>
    [Hookable(false)]
    boolean mustGoBatch()
    {
        if (FeatureStateProvider::isFeatureEnabled(LedgerJournalDeleteBatchEnableFeature::instance()))
        {
            int lineCount = this.parmNumOfLines();
            this.parmShouldForceBatch(this.shouldForceBatch(lineCount));
            return this.parmShouldForceBatch();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Decide if can have batch job option to run operations.
    /// </summary>
    /// <returns>
    ///    True if can have batch job option, otherwise false
    /// </returns>
    /// <remarks>
    ///    This method must be in this class because it is called from the dialogRunbase class.
    ///    The method must return false when the class is not batchable.
    /// </remarks>
    public boolean canGoBatch()
    {
        if (FeatureStateProvider::isFeatureEnabled(LedgerJournalDeleteBatchEnableFeature::instance()))
        {
            return true;
        }
        else 
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShouldForceBatch</Name>
				<Source><![CDATA[
    internal boolean parmShouldForceBatch(boolean _shouldForceBatch = shouldForceBatch)
    {
        shouldForceBatch = _shouldForceBatch;
        return shouldForceBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumOfLines</Name>
				<Source><![CDATA[
    internal int parmNumOfLines(int _numOfLines = numOfLines)
    {
        numOfLines = _numOfLines;
        return numOfLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsSetBasedDelete</Name>
				<Source><![CDATA[
    internal boolean getIsSetBasedDelete()
    {
        return isSetBasedDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldForceBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// check if should force to run in batch job
    /// </summary>
    /// <param name = "_lineCount">number of lines</param>
    /// <returns>True if it should force to run in batch, otherwise no.</returns>
    private boolean shouldForceBatch(int _lineCount)
    {
        return (_lineCount >= this.getTransactionDeleteNumberLinesToForceBatch());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionDeleteNumberLinesToForceBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of transaction line limit to force delete via batch.
    /// </summary>
    /// <returns>The number of lines.</returns>
    private int getTransactionDeleteNumberLinesToForceBatch()
    {
        LedgerParameters ledgerParameters = LedgerParameters::find();
        int numberOfLinesToForceBatch = ledgerParameters.TransactionDeleteNumberLinesToForceBatch;

        if (numberOfLinesToForceBatch <= 0)
        {
            numberOfLinesToForceBatch = 100;
        }
        return numberOfLinesToForceBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canJournalBeDeleted</Name>
				<Source><![CDATA[
    private boolean canJournalBeDeleted(LedgerJournalTable _ledgerJournalTable)
    {
        if (_ledgerJournalTable.Posted)
        {
            throw error(strfmt("@SYS18421", _ledgerJournalTable.JournalNum));
        }

        if (_ledgerJournalTable.checkIsBlockedOrInUse())
        {
            throw error(strFmt("@LedgerJournal:LedgerJournalValidationError", _ledgerJournalTable.JournalNum));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Run the batch job
    /// </summary>
    [Hookable(false)]
    protected void doBatch()
    {
        // validate and lock the journal table if it is running in batch
        if (FeatureStateProvider::isFeatureEnabled(LedgerJournalDeleteBatchEnableFeature::instance()))
        {
            LedgerJournalTable ledgerJournalTable = this.parmLedgerJournalEngine().ledgerJournalTable();
            if (this.canJournalBeDeleted(ledgerJournalTable))
            {
                LedgerJournalTable::lockJournalAndSetSession(ledgerJournalTable, LedgerJournalSystemBlockedReason::Delete);
                this.parmJournalNumToDelete(ledgerJournalTable.JournalNum);
            }
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>logWarningAndUnlockJournalIfLinesToDeleteIsZero</Name>
				<Source><![CDATA[
    private void logWarningAndUnlockJournalIfLinesToDeleteIsZero(SysInstrumentationActivityContext _runActivityContext)
    {
        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(this.parmJournalNumToDelete());
        if (ledgerJournalTable)
        {
            warning(strFmt("@LedgerJournal:LedgerJournalNoLinesToDeleteWarning", ledgerJournalTable.JournalNum));
            _runActivityContext.addCustomProperty(LedgerJournalInstrumentationConstants::CustomPropertyJournalRecId, int642Str(ledgerJournalTable.RecId));
            
            if (ledgerJournalTable.SystemBlockedReason == LedgerJournalSystemBlockedReason::Delete && ledgerJournalTable.SystemBlocked)
            {
                LedgerJournalTable::unlockJournal(ledgerJournalTable);
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>