<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpdateMarking</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventUpdateMarking</c> class is responsible for marking and unmarking inventory transactions.
/// </summary>
public class InventUpdateMarking
{
    protected const int PreReserveAndMatchReservedMarkingStage = 0;
    protected const int SearchMatchAllMarkingStage             = 1;
    protected const int FinalSearchMarkingStage                = SearchMatchAllMarkingStage;

    private InventUpdateMarkingParameters markingParameters;

    private InventMarkingRequestReservation     markingRequestReservation;
    private InventTmpInventTransMarkQuantities  markQuantities;
    
    private Map movementMap;
    private Map issueMovementMap;
    private Map reservationMap;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmMarkingParameters</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected InventUpdateMarkingParameters parmMarkingParameters()
    {
        return markingParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    private void initialize(InventUpdateMarkingParameters _markingParameters)
    {
        markingParameters = _markingParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkingRequestReservation</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected InventMarkingRequestReservation parmMarkingRequestReservation()
    {
        if (!markingRequestReservation)
        {
            markingRequestReservation = InventMarkingRequestReservation::newFromOriginMarkFrom(this.parmMarkingParameters().parmInventTransOriginRecId(), this.parmMarkingParameters().parmInventDimCriteria());
        }
        return markingRequestReservation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkQuantities</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected InventTmpInventTransMarkQuantities parmMarkQuantities()
    {
        if (!markQuantities)
        {
            markQuantities = InventTmpInventTransMarkQuantities::construct();
        }

        return markQuantities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMovementMap</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected Map parmMovementMap()
    {
        if (!movementMap)
        {
            movementMap = new Map(Types::Int64,Types::Class);
        }

        return movementMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addIssueMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds movement to collection of movements which should be reserved after marking is completed.
    /// </summary>
    /// <param name = "_inventTransOriginRecId">
    /// An inventory transaction origin ID.
    /// </param>
    /// <param name = "_movement">
    /// A movement to add to the collection.
    /// </param>
    [Wrappable(false)]
    protected void addIssueMovement(InventTransOriginId _inventTransOriginRecId, InventMovement _movement)
    {
        if (_movement)
        {
            if (!this.parmMovementIssueMap().exists(_inventTransOriginRecId))
            {
                this.parmMovementIssueMap().insert(_inventTransOriginRecId, _movement);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMovementIssueMap</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected Map parmMovementIssueMap()
    {
        if (!issueMovementMap)
        {
            issueMovementMap = new Map(Types::Int64,Types::Class);
        }

        return issueMovementMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReservationMap</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected Map parmReservationMap()
    {
        if (!reservationMap)
        {
            reservationMap = new Map(Types::Int64,Types::Class);
        }

        return reservationMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves movement associated with an inventory transaction.
    /// </summary>
    /// <param name = "_inventTrans">
    /// An inventory transaction to retrieve the movement for.
    /// </param>
    /// <returns>
    /// The associated movement.
    /// </returns>
    [Wrappable(false)]
    protected InventMovement findMovement(InventTrans _inventTrans)
    {
        if (!this.parmMovementMap().exists(_inventTrans.InventTransOrigin))
        {
            this.parmMovementMap().insert(_inventTrans.InventTransOrigin, _inventTrans.inventMovement(true));
        }
        return this.parmMovementMap().lookup(_inventTrans.InventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpdateMarking</c> class.
    /// </summary>
    /// <param name = "_markingParameters">
    /// Parameters used to initialize the <c>InventUpdateMarking</c> instance with.
    /// </param>
    /// <returns>
    /// The <c>InventUpdateMarking</c> instance.
    /// </returns>
    public static InventUpdateMarking createInstance(InventUpdateMarkingParameters _markingParameters)
    {
        InventUpdateMarking updateMarking = new InventUpdateMarking();

        updateMarking.initialize(_markingParameters);

        return updateMarking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectAvailableMarkingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Selects transactions that are to be marked.
    /// </summary>
    /// <param name="_inventDimCriteria">
    ///    The parameter is used as the selection criteria when _<paramref name="_attempt" /> is not 0.
    /// </param>
    /// <param name="_qty">
    ///    The quantity of the transaction. Depending on the sign of the quantity, the selection is performed either for a receipt or an issue.
    /// </param>
    /// <param name="_tmpInventTransMark">
    ///    The temporary information about a transaction to be marked against the selected <c>InventTrans</c> transactions.
    /// </param>
    /// <param name="_attempt">
    ///    The number of tries to select the transactions. Usually at the start it is set to zero. If the quantity of selected transactions is not enough for the marking, the value can be increased and this
    ///    method is called again.
    /// </param>
    /// <param name="_preReserveAccordingToMarking">
    ///    A boolean determining if reservations are done according to the expected marking before the marking is done. Optional.
    /// </param>
    /// <returns>
    ///    The transactions to be marked against an issue or receipt with _<c>tmpInventTransMark.InventTransId</c>.
    /// </returns>
    /// <remarks>
    ///    As the marking is always done in both directions (Issue&lt;-&gt;Receipt), there is another method <c>TmpInventTransMark</c> which returns transactions to be marked against an issue or receipt with
    ///    _<paramref name="_inventTransOriginId" />.
    /// </remarks>
    private InventTrans selectAvailableMarkingTransactions(
        InventDim               _inventDimCriteria,
        TmpInventTransMark      _tmpInventTransMark,
        Integer                 _attempt,
        boolean                 _preReserveAccordingToMarking)
    {
        InventTrans             inventTrans;
        InventDim               inventDim;
        InventDimParm           inventDimParm;

        if (_attempt == 0) // Issue and receipt inventory dimension should be the same
        {
            if (this.parmMarkingParameters().parmQty() > 0)
            {
                select forupdate inventTrans
                    order by StatusReceipt asc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.MarkingRefInventTransOrigin   == 0
                       && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                       && inventTrans.StatusIssue                   == StatusIssue::None
                       && (!_preReserveAccordingToMarking || inventTrans.StatusReceipt == StatusReceipt::Ordered);
            }
            else if (this.parmMarkingParameters().parmQty() < 0)
            {
                select forupdate inventTrans
                    order by StatusIssue desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.MarkingRefInventTransOrigin   == 0
                       && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                       && inventTrans.StatusReceipt                 == StatusReceipt::None
                    && (!_preReserveAccordingToMarking || inventTrans.StatusIssue == StatusIssue::ReservOrdered || inventTrans.StatusIssue == StatusIssue::ReservPhysical);
            }
        }
        else // Issue and receipt inventory transactios are matched based on the attempt stage
        {
            inventDimParm.initFromInventDim(_inventDimCriteria);

            if (this.parmMarkingParameters().parmQty() > 0)
            {
                select forupdate forceplaceholders inventTrans
                    order by StatusReceipt asc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.StatusIssue                   == StatusIssue::None
                       && (!_preReserveAccordingToMarking || inventTrans.StatusReceipt == StatusReceipt::Ordered)
                       &&
                         (_attempt == 3
                       || inventTrans.MarkingRefInventTransOrigin == 0
                       || (_attempt == 2 && inventTrans.MarkingRefInventTransOrigin != _tmpInventTransMark.InventTransOrigin))
                    #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm);
            }
            else if (this.parmMarkingParameters().parmQty() < 0)
            {
                select forupdate forceplaceholders inventTrans
                    order by StatusIssue desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.StatusReceipt                 == StatusReceipt::None
                       && (!_preReserveAccordingToMarking || inventTrans.StatusIssue == StatusIssue::ReservOrdered || inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                       &&
                         (_attempt == 3
                       || inventTrans.MarkingRefInventTransOrigin == 0
                       || (_attempt == 2 && inventTrans.MarkingRefInventTransOrigin  != _tmpInventTransMark.InventTransOrigin))
                    #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm);
            }
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectAvailableMarkedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Selects transactions that are to be marked.
    /// </summary>
    /// <param name="_tmpInventTransMark">
    ///    The temporary information about transactions to be selected.
    /// </param>
    /// <param name="_attempt">
    ///    The number of tries to select the transactions. Usually at the start it is set to zero. If the quantity of selected transactions is not enough for the marking, the value can be increased and this
    ///    method is called again.
    /// </param>
    /// <param name="_preReserveAccordingToMarking">
    ///    A boolean determining if reservations are done according to the expected marking before the marking is done.
    /// </param>
    /// <returns>
    ///    The transactions to be marked against an issue or receipt with _<paramref name="_inventTransOriginId" />.
    /// </returns>
    private InventTrans selectAvailableMarkedTransactions(
        TmpInventTransMark      _tmpInventTransMark,
        Integer                 _attempt,
        boolean                 _preReserveAccordingToMarking)
    {
        InventTrans     inventTrans;

        if (this.parmMarkingParameters().parmQty() > 0)
        {
            select forupdate inventTrans
                order by StatusIssue desc
                where inventTrans.ValueOpen                     == InventTransOpen::Yes
                   && inventTrans.InventTransOrigin             == _tmpInventTransMark.InventTransOrigin
                   && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                   && inventTrans.TransChildType                == InventTransChildType::None
                   && inventTrans.PackingSlipReturned           == NoYes::No
                   && inventTrans.StatusReceipt                 == StatusReceipt::None
                   &&
                     (_attempt == 2
                   || inventTrans.MarkingRefInventTransOrigin == 0
                   || (_attempt == 1 && inventTrans.MarkingRefInventTransOrigin != this.parmMarkingParameters().parmInventTransOriginRecId()));
        }
        else if (this.parmMarkingParameters().parmQty() < 0)
        {
            select forupdate inventTrans
                order by StatusReceipt asc
                where inventTrans.ValueOpen                     == InventTransOpen::Yes
                   && inventTrans.InventTransOrigin             == _tmpInventTransMark.InventTransOrigin
                   && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                   && inventTrans.TransChildType                == InventTransChildType::None
                   && inventTrans.PackingSlipReturned           == NoYes::No
                   && inventTrans.StatusIssue                   == StatusIssue::None
                   && (!_preReserveAccordingToMarking || inventTrans.StatusReceipt == StatusReceipt::Ordered)
                   &&
                     (_attempt == 2
                   || inventTrans.MarkingRefInventTransOrigin == 0
                   || (_attempt == 1 && inventTrans.MarkingRefInventTransOrigin != this.parmMarkingParameters().parmInventTransOriginRecId()));
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectMarkingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Select transactions to be unmarked.
    /// </summary>
    /// <param name="_inventDimCriteria">
    ///    This parameter is used as the selection criteria when _<paramref name="_attempt" /> is not 0.
    /// </param>
    /// <param name="_tmpInventTransMark">
    ///    The temporary information about a transaction to be unmarked against the selected <c>InventTrans</c> transactions.
    /// </param>
    /// <param name="_attempt">
    ///    The number of tries to select the transactions. Usually at the start it is set to zero. If the quantity of selected transactions is not enough to be unmarked, the value can be increased and this
    ///    method is called again.
    /// </param>
    /// <returns>
    ///    The transactions referred to _<c>tmpInventTransMark.InventTransOrigin</c>.
    /// </returns>
    private InventTrans selectMarkingTransactions(
        InventDim           _inventDimCriteria, 
        TmpInventTransMark  _tmpInventTransMark, 
        int                 _attempt)
    {
        InventTrans         inventTrans;
        InventDim           inventDim;
        InventDimParm       inventDimParm;

        if (_attempt == 0) // Issue and receipt inventory dimension should be the same
        { 
            if (this.parmMarkingParameters().parmQty() > 0)
            {
                select forupdate inventTrans
                    order by StatusReceipt desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.MarkingRefInventTransOrigin   == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                       && inventTrans.StatusIssue                   == StatusIssue::None;
            }
            else if (this.parmMarkingParameters().parmQty() < 0)
            {
                select forupdate inventTrans
                    order by StatusIssue desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.MarkingRefInventTransOrigin   == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                       && inventTrans.StatusReceipt                 == StatusReceipt::None;
            }
        }
        else // Issue and receipt inventory transactios are matched based on the attempt stage
        {
            inventDimParm.initFromInventDim(_inventDimCriteria);

            if (this.parmMarkingParameters().parmQty() > 0)
            {
                select forupdate forceplaceholders inventTrans
                    order by StatusReceipt desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.MarkingRefInventTransOrigin   == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.StatusIssue                   == StatusIssue::None
                    #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm);
            }
            else if (this.parmMarkingParameters().parmQty() < 0)
            {
                select forupdate forceplaceholders inventTrans
                    order by StatusIssue desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.MarkingRefInventTransOrigin   == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.StatusReceipt                 == StatusReceipt::None
                    #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm);
            }
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectMarkedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Selects marked transactions to be unmarked.
    /// </summary>
    /// <param name="_inventDimCriteria">
    ///    A parameter used as the selection criteria when _<paramref name="_attempt" /> is not 0.
    /// </param>
    /// <param name="_tmpInventTransMark">
    ///    The temporary information about transactions to be selected.
    /// </param>
    /// <param name="_attempt">
    ///    The number of attempts to select the transactions. Usually in the beginning it is set to zero. If the quantity of selected transactions is not enough to be unmarked, then the value can be increased
    ///    and this method is called again.
    /// </param>
    /// <returns>
    ///    The <c>InventTrans</c> transactions referred to _<paramref name="_inventTransOriginId" />.
    /// </returns>
    private InventTrans selectMarkedTransactions(
        InventDim           _inventDimCriteria, 
        TmpInventTransMark  _tmpInventTransMark, 
        int                 _attempt)
    {
        InventTrans     inventTrans;
        InventDim       inventDim;
        InventDimParm   inventDimParm;

        if (_attempt == 0) // Issue and receipt inventory dimension should be the same
        {
            if (this.parmMarkingParameters().parmQty() > 0)
            {
                select forupdate inventTrans
                    order by StatusIssue desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.MarkingRefInventTransOrigin   == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.StatusReceipt                 == StatusReceipt::None;
            }
            else if (this.parmMarkingParameters().parmQty() < 0)
            {
                select forupdate inventTrans
                    order by StatusReceipt desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.MarkingRefInventTransOrigin   == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.InventDimId                   == _tmpInventTransMark.InventDimId
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.StatusIssue                   == StatusIssue::None;
            }
        }
        else // Issue and receipt inventory transactios are matched based on the attempt stage        
        {
            inventDimParm.initFromInventDim(_inventDimCriteria);

            if (this.parmMarkingParameters().parmQty() > 0)
            {
                select forupdate forceplaceholders inventTrans
                    order by StatusIssue desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.MarkingRefInventTransOrigin   == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.StatusReceipt                 == StatusReceipt::None
                    #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm);
            }
            else if (this.parmMarkingParameters().parmQty() < 0)
            {
                select forupdate forceplaceholders inventTrans
                    order by StatusReceipt desc
                    where inventTrans.ValueOpen                     == InventTransOpen::Yes
                       && inventTrans.InventTransOrigin             == _tmpInventTransMark.InventTransOrigin
                       && inventTrans.TransChildType                == InventTransChildType::None
                       && inventTrans.MarkingRefInventTransOrigin   == this.parmMarkingParameters().parmInventTransOriginRecId()
                       && inventTrans.PackingSlipReturned           == NoYes::No
                       && inventTrans.StatusIssue                   == StatusIssue::None
                    #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm);
            }
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRefTransUnchanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the records that are used to create the <c>TmpInventTransMark</c> records have changed.
    /// </summary>
    /// <returns>
    /// true if none of the records that are used to create <c>TmpInventTransMark</c> records have changed; otherwise, false.
    /// </returns>
    private boolean isRefTransUnchanged()
    {
        TmpInventTransMark      tmpRec;

        //get reference TmpInventTransMark records
        InventTransMarkCollection collection = TmpInventTransMark::markingCollection(InventTransOrigin::find(this.parmMarkingParameters().parmInventTransOriginRecId()), this.parmMarkingParameters().parmInventDimCriteria(), this.parmMarkingParameters().parmQty());
        collection.insertCollectionToTmpTable(tmpRec);

        //check every marked record.
        MapEnumerator tmpMarkEnumerator = this.parmMarkingParameters().parmTmpInventTransMarkMap().getEnumerator();

        while (tmpMarkEnumerator.moveNext())
        {
            TmpInventTransMark tmpMarked = tmpMarkEnumerator.currentValue();

            select firstonly tmpRec
                where tmpRec.InventTransOrigin == tmpMarked.InventTransOrigin
                   && tmpRec.InventDimId       == tmpMarked.InventDimId;

            //check if the origin trans changed or not
            if (!tmpRec || tmpRec.QtyRemain != tmpMarked.QtyRemain + tmpMarked.QtyMarkNow
                        || tmpRec.QtyMarked != tmpMarked.QtyMarked)
            {
                return checkFailed("@SYS5149");
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipUpdateReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the update reservations must be skipped.
    /// </summary>
    /// <returns>
    /// true if update reservations must be skipped; otherwise, false
    /// </returns>
    [Replaceable]
    protected boolean mustSkipUpdateReservations()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inventory transactions by marking and unmarking the inventory transactions against each other.
    /// </summary>
    public void updateMarking()
    {
        if (!this.parmMarkingParameters().parmTmpInventTransMarkMap() || !this.parmMarkingParameters().parmTmpInventTransMarkMap().elements())
        {
            return;
        }

        if (!this.isRefTransUnchanged())
        {
            throw error("@SYS18447");
        }

        ttsbegin;
        
        Enumerator markingStagesEnumerator = this.markingStages();
            
        while (markingStagesEnumerator.moveNext())
        {
            int markingStage = markingStagesEnumerator.current();

            this.executeMarkingStage(markingStage);
        }

        this.updateTransactionReferences();

        this.updateReserveMarkings();

        if (!this.mustSkipUpdateReservations())
        {
            this.updateReservations();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCancelMarking</Name>
				<Source><![CDATA[
    private void checkCancelMarking(
        TmpInventTransMark _tmpInventTransMark)
    {
        InventTransOrigin tmpInventTransMarkOrigin = InventTransOrigin::find(_tmpInventTransMark.InventTransOrigin);

        if (InventPreventUnmarkingTransitTransFlight::instance().isEnabled()
         && !_tmpInventTransMark.PackingSlipId && !_tmpInventTransMark.InvoiceId
         && !InventTable::find(tmpInventTransMarkOrigin.ItemId).modelGroup().inventModelType().isSettled()
         && ((_tmpInventTransMark.TransType == InventTransType::TransferOrderShip    && _tmpInventTransMark.Qty > 0 && InventTransferLine::findTransIdTransitTo(_tmpInventTransMark.InventTransId).RecId)
          || (_tmpInventTransMark.TransType == InventTransType::TransferOrderReceive && _tmpInventTransMark.Qty < 0 && InventTransferLine::findTransIdTransitFrom(_tmpInventTransMark.InventTransId).RecId)))
        {
            throw error("@SCM:InventTransferOrderTransitTransUnmarkError");
        }

        if (WHSInventEnabled::exist(tmpInventTransMarkOrigin.ItemId))
        {
            InventQty                   qtyToReduce;
            InventTransOrigin           inventTransOrigin;
            InventTransOriginIdMarked   inventTransOriginMarked;

            // Markings cannot be reduce to less than the planned cross dock quantity.
            if (inventTrans::findByInventTransOrigin(markingParameters.parmInventTransOriginRecId()).direction() == InventDirection::Issue)
            {
                qtyToReduce = _tmpInventTransMark.qtyMarkNow;
                inventTransOrigin = InventTransOrigin::find(markingParameters.parmInventTransOriginRecId());
                inventTransOriginMarked = _tmpInventTransMark.InventTransOrigin;
            }
            else
            {
                qtyToReduce = -_tmpInventTransMark.qtyMarkNow;
                inventTransOrigin = InventTransOrigin::find(_tmpInventTransMark.InventTransOrigin);
                inventTransOriginMarked = markingParameters.parmInventTransOriginRecId();
            }

            InventTrans   inventTrans;
            InventDim     joinInventDim;
            InventDim     inventDimCriteria = InventDim::find(_tmpInventTransMark.InventDimId);
            InventDimParm inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(inventTransOrigin.inventTable());
    
            select sum(Qty) from inventTrans
                where inventTrans.inventTransOrigin             == inventTransOrigin.RecId
                &&    inventTrans.MarkingRefInventTransOrigin   == inventTransOriginMarked
                &&    (inventTrans.StatusIssue                  == StatusIssue::ReservOrdered
                ||    inventTrans.StatusIssue                   == StatusIssue::OnOrder)
                #InventDimExistsJoin(inventTrans.InventDimId, joinInventDim, inventDimCriteria, inventDimParm);
    
            WHSCrossDockLoadLine    crossDockLoadLine;
            WHSLoadLine             loadLine;

            select sum(InventHandlingQtyRemain) from crossDockLoadLine
                where crossDockLoadLine.InventTransIdDemand == inventTransOrigin.InventTransId
                &&    crossDockLoadLine.InventTransOriginIdSupply == inventTransOriginMarked
                    join InventDimId from loadLine
                        where loadLine.RecId    == crossDockLoadLine.LoadLineRecId
                        &&    loadLine.Invalid  == NoYes::No
                    #InventDimExistsJoin(loadLine.InventDimId, joinInventDim, inventDimCriteria, inventDimParm);
    
            if (max(0, abs(inventTrans.Qty) + qtyToReduce) < crossDockLoadLine.InventHandlingQtyRemain)
            {
                throw error("@WAX:CrossDockReduceMarkingError");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMarkingStage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Execute the specified marking stage.
    /// </summary>
    /// <param name = "_markingStage">
    /// A marking stage.
    /// </param>
    protected void executeMarkingStage(int _markingStage)
    {
        MapEnumerator markingEnumerator = this.parmMarkingParameters().parmTmpInventTransMarkMap().getEnumerator();

        while (markingEnumerator.moveNext())
        {
            TmpInventTransMark  tmpInventTransMark = markingEnumerator.currentValue();

            if (tmpInventTransMark.QtyMarked * tmpInventTransMark.QtyMarkNow < 0)
            {
                this.checkCancelMarking(tmpInventTransMark);
                
                this.cancelMarking(_markingStage, tmpInventTransMark);
            }
            else if (tmpInventTransMark.QtyMarkNow != 0)
            {
                this.applyMarking(_markingStage, tmpInventTransMark);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies marking according to the provided marking records.
    /// </summary>
    /// <param name = "_markingStage">
    /// The current marking stage.
    /// </param>
    /// <param name = "_tmpInventTransMark">
    /// A <c>TmpInventTransMark</c> record describing the marking to apply.
    /// </param>
    protected void applyMarking(int _markingStage, TmpInventTransMark _tmpInventTransMark)
    {
        InventQty qtyRemain = this.parmMarkQuantities().quantityRemain(_tmpInventTransMark, _markingStage == SearchMatchAllMarkingStage);
    
        //if we consumed all the  quantity then we don't need to try and process more for this tmpInventTransMark record
        if (!qtyRemain)
        {
            return;
        }

        InventDim inventDimTransSelect;
        inventDimTransSelect.data(this.parmMarkingParameters().parmInventDimCriteria());

        //try to do pre-reservation
        if (_markingStage == PreReserveAndMatchReservedMarkingStage)
        {
            InventMarkingReservationResult markingReservationResult = this.parmMarkingRequestReservation().reserveBasedOnMarkingRequest(_tmpInventTransMark);
            inventDimTransSelect = markingReservationResult.inventDimReserve;
                            
            if (markingReservationResult.reservationFailed)
            {
                warning(strFmt("@SCM:InventMarkingPreReservationFailedWarning", _tmpInventTransMark.TransType, _tmpInventTransMark.TransRefId, _tmpInventTransMark.InventTransId));
            }
        }
                        
        InventDimId markingInventDimId = this.addMarkingTransactions(_markingStage, inventDimTransSelect, _tmpInventTransMark, -qtyRemain);

        //We have marked in one direction - now we need to mark the opposite set of transactions
        qtyRemain = this.parmMarkQuantities().quantityConsumed(_tmpInventTransMark, _markingStage == SearchMatchAllMarkingStage);
                   
        if (!qtyRemain)
        {
            return;
        }

        this.addMarkedTransactions(_markingStage, _tmpInventTransMark, qtyRemain, markingInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarkingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds marking information to the marking inventory transactions.
    /// </summary>
    /// <param name = "_markingStage">
    /// The current marking stage.
    /// </param>
    /// <param name = "_inventDimTransSelect">
    /// Inventory dimensions used as the selection criteria when selecting marking inventory transactions.
    /// </param>
    /// <param name = "_tmpInventTransMark">
    /// A <c>TmpInventTransMark</c> record describing the marking to apply.
    /// </param>
    /// <param name = "_remainingQty">
    /// Remaining quantity to mark.
    /// </param>
    /// <returns>
    /// The inventory dimension id for applying to marked inventory transactions.
    /// </returns>
    protected InventDimId addMarkingTransactions(
        int                 _markingStage, 
        InventDim           _inventDimTransSelect, 
        TmpInventTransMark  _tmpInventTransMark, 
        InventQty           _remainingQty)
    {
        InventTrans inventTransThis;
        InventQty   remainingQty = _remainingQty;

        Enumerator addMarkingAttemptEnumerator = this.addMarkingAttempts(_markingStage);

        while (addMarkingAttemptEnumerator.moveNext())
        {
            int addMarkingAttempt = addMarkingAttemptEnumerator.current();

            // Select transactions are to be marked
            inventTransThis = this.selectAvailableMarkingTransactions(_inventDimTransSelect, _tmpInventTransMark, addMarkingAttempt, _markingStage == PreReserveAndMatchReservedMarkingStage);

            while (inventTransThis.RecId)
            {
                InventDimId markInventDimId = _tmpInventTransMark.InventDimId;
                InventMovement movement = this.findMovement(inventTransThis);

                if (movement.isItemWHSEnabled())
                {
                    InventDim receiptInventDim = InventDim::find(_tmpInventTransMark.InventDimId);
                    markInventDimId = movement.getInventDimForIssueTransFromReceipt(receiptInventDim, receiptInventDim).inventDimId;
                }

                InventQty markingQuantity = this.addMarking(movement, inventTransThis, _tmpInventTransMark.InventTransOrigin, remainingQty, markInventDimId);

                remainingQty -= markingQuantity;

                //keep track of how much quantity that was consumed from the tmpInventTransMark
                this.parmMarkQuantities().consumeFromQuantityRemain(_tmpInventTransMark, -markingQuantity, -markingQuantity);

                inventTransThis.updateSumUp();

                if (!remainingQty)
                {
                    break;
                }

                next inventTransThis;
            }
            if (!remainingQty)
            {
                break;
            }
        }

        if (remainingQty && _markingStage == FinalSearchMarkingStage)
        {
            checkFailed("@SYS5149");
            throw error("@SYS18447");
        }

        return inventTransThis.inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarkedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds marking information to the marked inventory transactions.
    /// </summary>
    /// <param name = "_markingStage">
    /// The current marking stage.
    /// </param>
    /// <param name = "_tmpInventTransMark">
    /// A <c>TmpInventTransMark</c> record describing the marking to apply.
    /// </param>
    /// <param name = "_remainingQty">
    /// Remaining quantity to mark.
    /// </param>
    /// <param name = "_markInventDimId">
    /// An inventory dimension ID to apply to marked inventory transactions.
    /// </param>
    protected void addMarkedTransactions(
        int                 _markingStage, 
        TmpInventTransMark  _tmpInventTransMark, 
        InventQty           _remainingQty, 
        InventDimId         _markInventDimId)
    {
        InventQty   remainingQty = _remainingQty;

        Enumerator addMarkedAttemptsEnumerator = this.addMarkedAttempts(_markingStage);

        while (addMarkedAttemptsEnumerator.moveNext())
        {
            int addMarkedAttempt = addMarkedAttemptsEnumerator.current();

            // Select transactions are to be marked
            InventTrans inventTrans = this.selectAvailableMarkedTransactions(_tmpInventTransMark, addMarkedAttempt, _markingStage == PreReserveAndMatchReservedMarkingStage);

            while (inventTrans.RecId)
            {
                InventQty markedQty = this.addMarking(this.findMovement(inventTrans), inventTrans, this.parmMarkingParameters().parmInventTransOriginRecId(), remainingQty, _markInventDimId);

                remainingQty -= markedQty;

                inventTrans.updateSumUp();

                if (!remainingQty)
                {
                    break;
                }

                next inventTrans;
            }

            if (!remainingQty)
            {
                break;
            }
        }

        if (remainingQty && _markingStage == FinalSearchMarkingStage)
        {
            checkFailed("@SYS5149");
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the marking field to reference the specified inventory transaction originator.
    /// </summary>
    /// <param name = "_inventTrans">
    /// An <c>InventTrans</c> which should be marked.
    /// </param>
    /// <param name = "_markingInventTransOriginRecId">
    /// An <c>InventTransOriginId</c> which the inventory transaction must be marked against.
    /// </param>
    protected void setMarking(InventTrans _inventTrans, InventTransOriginId _markingInventTransOriginRecId)
    {
        _inventTrans.setMarking(_markingInventTransOriginRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds marking to an inventory transaction.
    /// </summary>
    /// <param name = "_movement">
    /// A movement associated with the inventory transaction.
    /// </param>
    /// <param name = "_inventTrans">
    /// An inventory transaction which should be marked.
    /// </param>
    /// <param name = "_markingInventTransOriginRecId">
    /// An inventory transaction origin id which the inventory transaction must be marked against.
    /// </param>
    /// <param name = "_remainingQty">
    /// Remaining quantity to mark.
    /// </param>
    /// <param name = "_markInventDimId">
    /// An inventory dimension id to apply to open issue transactions.
    /// </param>
    /// <returns>
    /// The marked quantity.
    /// </returns>
    protected InventQty addMarking(
        InventMovement      _movement, 
        InventTrans         _inventTrans, 
        InventTransOriginId _markingInventTransOriginRecId, 
        InventQty           _remainingQty, 
        InventDimId         _markInventDimId)
    {
        InventTransOrigin inventTransOrigin = _inventTrans.inventTransOrigin();

        setPrefix(#prefixField(inventTransOrigin,ReferenceCategory));
        setPrefix(#prefixField(inventTransOrigin,ReferenceId));
        setPrefix(#prefixField(inventTransOrigin,InventTransId));

        if (_inventTrans.financialOpenQty() != _inventTrans.Qty)
        {
            _inventTrans.updateSplit(_inventTrans.financialOpenQty(), 0);
        }

        if (abs(_remainingQty) < abs(_inventTrans.financialOpenQty()))
        {
            _inventTrans.updateSplit(_remainingQty, 0);
        }

        if (_movement && ! _movement.checkAllowManualMarking())
        {
            throw error("@SYS18447");
        }

        this.setMarking(_inventTrans, _markingInventTransOriginRecId);

        if (_inventTrans.StatusIssue == StatusIssue::OnOrder
            || _inventTrans.StatusIssue == StatusIssue::ReservOrdered
            || _inventTrans.StatusIssue == StatusIssue::ReservPhysical)
        {
            _inventTrans.InventDimId  = _markInventDimId;
            InventUpdate::updateTransDimTransferReceipt(_movement, _inventTrans, _inventTrans.inventDim());

            this.addIssueMovement(_inventTrans.InventTransOrigin, _movement);
        }

        _inventTrans.update();

        return _inventTrans.financialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels marking according to the provided marking records.
    /// </summary>
    /// <param name = "_markingStage">
    /// The current marking stage.
    /// </param>
    /// <param name = "_tmpInventTransMark">
    /// A <c>TmpInventTransMark</c> record describing the marking to cancel.
    /// </param>
    protected void cancelMarking(int _markingStage, TmpInventTransMark _tmpInventTransMark)
    {
        this.cancelMarkingTransactions(_markingStage, _tmpInventTransMark, _tmpInventTransMark.QtyMarkNow);

        this.cancelMarkedTransactions(_markingStage, _tmpInventTransMark, -_tmpInventTransMark.QtyMarkNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMarkingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels marking information from the marking inventory transactions.
    /// </summary>
    /// <param name = "_markingStage">
    /// The current marking stage.
    /// </param>
    /// <param name = "_tmpInventTransMark">
    /// A <c>TmpInventTransMark</c> record describing the marking to cancel.
    /// </param>
    /// <param name = "_remainingQty">
    /// Remaining quantity to cancel.
    /// </param>
    protected void cancelMarkingTransactions(
        int                 _markingStage, 
        TmpInventTransMark  _tmpInventTransMark, 
        InventQty           _remainingQty)
    {
        InventQty   remainingQty = _remainingQty;

        Enumerator cancelMarkingAttemptsEnumerator = this.cancelMarkingAttempts(_markingStage);

        while (cancelMarkingAttemptsEnumerator.moveNext())
        {
            int cancelMarkingAttempt = cancelMarkingAttemptsEnumerator.current();

            // Select transactions are to be unmarked
            InventTrans inventTransThis = this.selectMarkingTransactions(this.parmMarkingParameters().parmInventDimCriteria(), _tmpInventTransMark, cancelMarkingAttempt);

            while (inventTransThis.RecId)
            {
                InventQty markingQty = this.removeMarking(this.findMovement(inventTransThis), inventTransThis, remainingQty);

                remainingQty -= markingQty;

                inventTransThis.updateSumUp();

                if (!remainingQty)
                {
                    break;
                }

                next inventTransThis;
            }

            if (!remainingQty)
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMarkedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels marking information from the marked inventory transactions.
    /// </summary>
    /// <param name = "_markingStage">
    /// The current marking stage.
    /// </param>
    /// <param name = "_tmpInventTransMark">
    /// A <c>TmpInventTransMark</c> record describing the marking to cancel.
    /// </param>
    /// <param name = "_remainingQty">
    /// Remaining quantity to cancel.
    /// </param>
    protected void cancelMarkedTransactions(
        int                 _markingStage, 
        TmpInventTransMark  _tmpInventTransMark, 
        InventQty           _remainingQty)
    {
        InventQty   remainingQty = _remainingQty;

        Enumerator cancelMarkedAttemptsEnumerator = this.cancelMarkedAttempts(_markingStage);

        while (cancelMarkedAttemptsEnumerator.moveNext())
        {
            int cancelMarkedAttempt = cancelMarkedAttemptsEnumerator.current();
            // Select transactions are to be unmarked
            InventTrans inventTrans = this.selectMarkedTransactions(this.parmMarkingParameters().parmInventDimCriteria(), _tmpInventTransMark, cancelMarkedAttempt);

            while (inventTrans.RecId)
            {
                InventQty markedQty = this.removeMarking(this.findMovement(inventTrans), inventTrans, remainingQty);

                remainingQty -= markedQty;

                inventTrans.updateSumUp();

                if (!remainingQty)
                {
                    break;
                }

                next inventTrans;
            }

            if (!remainingQty)
            {
                break;
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMarking</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Sets all marking related fields to their default values.
    /// </summary>
    /// <param name = "_inventTrans">
    ///  An <c>InventTrans</c> which should have marking removed.
    /// </param>
    /// <param name = "_inventTransOrigin">
    /// An <c>InventTransOrigin</c> originator of the inventory transaction.
    /// </param>
    protected void clearMarking(InventTrans _inventTrans, InventTransOrigin _inventTransOrigin)
    {
        _inventTrans.clearMarking();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes marking from an inventory transaction.
    /// </summary>
    /// <param name = "_movement">
    /// A movement associated with the inventory transaction.
    /// </param>
    /// <param name = "_inventTrans">
    /// An inventory transaction which should have marking removed.
    /// </param>
    /// <param name = "_remainingQty">
    /// Remaining quantity to remove marking for.
    /// </param>
    /// <returns>
    /// The removed marked quantity.
    /// </returns>
    protected InventQty removeMarking(
        InventMovement  _movement, 
        InventTrans     _inventTrans, 
        InventQty       _remainingQty)
    {
        InventTransOrigin inventTransOrigin = _inventTrans.inventTransOrigin();

        setPrefix(#prefixField(inventTransOrigin,ReferenceCategory));
        setPrefix(#prefixField(inventTransOrigin,ReferenceId));
        setPrefix(#prefixField(inventTransOrigin,InventTransId));

        if (_inventTrans.financialOpenQty() != _inventTrans.Qty)
        {
            _inventTrans.updateSplit(_inventTrans.financialOpenQty(), 0);
        }

        if (abs(_remainingQty) < abs(_inventTrans.financialOpenQty()))
        {
            _inventTrans.updateSplit(_remainingQty, 0);
        }

        this.clearMarking(_inventTrans, inventTransOrigin);
        if (_inventTrans.StatusIssue == StatusIssue::ReservPhysical || _inventTrans.StatusIssue == StatusIssue::ReservOrdered)
        {
            _inventTrans.StatusIssue = StatusIssue::OnOrder;
        }

        if (_movement && ! _movement.checkAllowManualMarking())
        {
            throw error("@SYS18447");
        }

        if (_inventTrans.StatusIssue == StatusIssue::OnOrder && _movement)
        {
            _inventTrans.InventDimId = _movement.inventdim().InventDimId;
            _inventTrans.InventDimFixed = 0;
            InventUpdate::updateTransDimTransferReceipt(_movement, _inventTrans, _inventTrans.inventDim());
            this.autoReserve(_inventTrans, _movement);
        }

        _inventTrans.update();

        return _inventTrans.financialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates transaction references based on the movements being marked against each other.
    /// </summary>
    protected void updateTransactionReferences()
    {
        InventTrans::updateInventRefFields(this.parmMovementMap(), markingParameters.parmReqMarkUpdateMethod());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveMarkings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates reservations based on markings for movements.
    /// </summary>
    protected void updateReserveMarkings()
    {
        MapEnumerator me = this.parmMovementIssueMap().getEnumerator();

        while (me.moveNext())
        {
            this.updateReserveMarking(me.currentValue());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates reservations based on marking for a movement.
    /// </summary>
    /// <param name = "_movementIssue">
    /// The issue movement which should be reserved.
    /// </param>
    protected void updateReserveMarking(InventMovement _movementIssue)
    {
        InventUpd_Reservation::updateReserveRefTransId(_movementIssue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates reservations for movements requiring auto reservation.
    /// </summary>
    protected void updateReservations()
    {
        MapEnumerator me = this.parmReservationMap().getEnumerator();

        while (me.moveNext())
        {
            this.updateReservation(me.currentValue());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates reservation for movement requiring auto reservation.
    /// </summary>
    /// <param name = "_reservation">
    /// The reservation update which should be executed.
    /// </param>
    protected void updateReservation(InventUpd_Reservation _reservation)
    {
        _reservation.parmThrowOnInsufficientOnHand(false);

        if (!_reservation.movement().updateReqExplodeReservation())
        {
            _reservation.updateNow();

            if (_reservation.parmReservationFailed())
            {
                error("@SCM:AutomaticReservationFailed");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tracks movements and quanties if the movement must be auto reserved after marking is completed.
    /// </summary>
    /// <param name = "_inventTrans">
    /// The inventory transaction which must be reserved.
    /// </param>
    /// <param name = "_movement">
    /// The movement associated with the inventory transaction.
    /// </param>
    protected void autoReserve(InventTrans _inventTrans, InventMovement _movement)
    {
        if (_movement.mustBeAutoReserved())
        {
            if (! this.parmReservationMap().exists(_inventTrans.InventTransOrigin))
            {
                this.parmReservationMap().insert(_inventTrans.InventTransOrigin, InventUpd_Reservation::newMovement(_movement, _inventTrans.Qty, false));
            }
            else
            {
                InventUpd_Reservation reservation = this.parmReservationMap().lookup(_inventTrans.InventTransOrigin);
                reservation.parmReservation(reservation.parmReservation() + _inventTrans.Qty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingStages</Name>
				<Source><![CDATA[
    private Enumerator markingStages()
    {
        List markingStage = new List(Types::Integer);

        //determine if we need to loop through the tmp records multiple times to handle reservations first
        if (this.parmMarkingParameters().parmPreReserveAccordingToMarking())
        {
            if (this.parmMarkingRequestReservation().canMovementBeReserved(this.parmMarkingRequestReservation().parmInventTransOriginMarkFrom().inventMovement()))
            {
                markingStage.addEnd(PreReserveAndMatchReservedMarkingStage);
            }
        }

        markingStage.addEnd(SearchMatchAllMarkingStage);

        return markingStage.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMarkingAttempts</Name>
				<Source><![CDATA[
    private Enumerator cancelMarkingAttempts(int _markingStage)
    {
        List attemptsList = new List(Types::Integer);
        
        if (_markingStage == SearchMatchAllMarkingStage)
        {
            attemptsList.addEnd(0);
            attemptsList.addEnd(1);
        }

        return attemptsList.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMarkedAttempts</Name>
				<Source><![CDATA[
    private Enumerator cancelMarkedAttempts(int _markingStage)
    {
        List attemptsList = new List(Types::Integer);
        
        if (_markingStage == SearchMatchAllMarkingStage)
        {
            attemptsList.addEnd(0);
            attemptsList.addEnd(1);
        }

        return attemptsList.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarkingAttempts</Name>
				<Source><![CDATA[
    private Enumerator addMarkingAttempts(int _markingStage)
    {
        List attemptsList = new List(Types::Integer);
        
        attemptsList.addEnd(0);
        attemptsList.addEnd(1);

        if (_markingStage == SearchMatchAllMarkingStage)
        {
            attemptsList.addEnd(2);
            attemptsList.addEnd(3);
        }

        return attemptsList.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarkedAttempts</Name>
				<Source><![CDATA[
    private Enumerator addMarkedAttempts(int _markingStage)
    {
        List attemptsList = new List(Types::Integer);
        
        attemptsList.addEnd(0);

        if (_markingStage == SearchMatchAllMarkingStage)
        {
            attemptsList.addEnd(1);
            attemptsList.addEnd(2);
        }

        return attemptsList.getEnumerator();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>