<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxSales</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxSales</c> class integrates with the calculation of tax from the sales order lines by the
///    <see cref="T:SalesCalcTax_Sales" />.
/// </summary>
/// <remarks>
///    This class is derived from the <c>Tax</c> class, and works as an extension of the main tax
///    engine.The <c>TaxSalesQuotation</c> and <c>TaxSales_Basket</c> classes derive from this class.
/// </remarks>
#isoCountryRegionCodes
class TaxSales extends Tax implements ITaxMarkupCompound
{
    SalesCalcTax_Sales  salesFormLetter;
    SalesLine           salesLine;
    private SalesTable  salesTable;
    MarkupTrans         markupTrans;

    NoYes               markupAdminister;
    TaxAmount           returnTaxAmount;
    Map                 orderBalances;
    RefTableId          parentSourceTableId;
    RefRecId            parentSourceRecId;

    Map                 mcrOrderBalancesAbsoluteValue;

    private boolean pennyDiffAdjusted;
    internal TaxMarkupCompound taxMarkupCompound;
    protected TmpTax tmpTaxMarkupCompound;
    protected boolean isAutoChargesSetupSequenceCompoundFeatureEnabled = AutoChargesSetupSequenceCompoundFeature::instance().IsEnabled();
    protected Common markupAutoOriginSource;

    // <GEERU>
    SalesInvoicePostingType_RU  invoicePostingType;
    // </GEERU>
    // <GIN>
    boolean             qualityOrder;
    private boolean isTaxIntegrationCacheFlightEnabled = TaxIntegrationCacheCalculationResultFlight::instance().isEnabled();
    private boolean isTaxIntegrationEnabledForSales = Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales);

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTaxAdjustmentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the collection of tax adjustment types that can be used to make tax adjustments.
    /// </summary>
    /// <remarks>
    /// All transactions that use tax adjustment functions support summary tax adjustment type by default.
    /// </remarks>
    protected void addTaxAdjustmentTypes()
    {
        super();

        if (salesFormLetter && salesFormLetter.useDetailsSalesTaxAdjustmentType())
        {
            this.addTaxAdjustmentType(TaxAdjustmentType::Detail);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowAdjustBaseAmountForTaxAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction supports adjusting the calculated base amount when the tax is
    /// included in item price and the user adjusts the tax amount.
    /// </summary>
    /// <returns>
    /// true if the transaction supports adjusting the calculated base amount; otherwise, false.
    /// </returns>
    public boolean allowAdjustBaseAmountForTaxAdjustment()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSingleLineAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the transaction supports adjusting a single line.
    /// </summary>
    /// <returns>
    /// true if adjusting a single line is supported; otherwise, false.
    /// </returns>
    public boolean allowSingleLineAdjustment()
    {
        boolean allowSingleLineAdjustment = super();

        if (salesFormLetter)
        {
            allowSingleLineAdjustment = allowSingleLineAdjustment || salesFormLetter.allowSingleLineAdjustment();
        }

        return allowSingleLineAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSONumberSequenceGroupId</Name>
				<Source><![CDATA[
    internal void updateSONumberSequenceGroupId()
    {
        TaxIntegrationSkipUpdateContext taxIntegrationSkipUpdateContext = TaxIntegrationSkipUpdateContext::current();
        if (taxIntegrationSkipUpdateContext && taxIntegrationSkipUpdateContext.parmSkipUpdate())
        {
            return;
        }

        TaxRegistration taxRegistration;
        TmpTaxWorkTrans tmpTaxTrans = this.tmpTaxWorkTrans();

        salesFormLetter.initCursor();
        salesFormLetter.nextLine();
        salesTable = salesFormLetter.orderLine_orderTable() as SalesTable;

        select firstonly TaxId from tmpTaxTrans
            where tmpTaxTrans.HeadingTableId == this.headingTableId()
                && tmpTaxTrans.HeadingRecId == this.headingRecId()
            join NumberSequenceGroupId from taxRegistration
                where taxRegistration.RecId == tmpTaxTrans.TaxId;

        if (salesTable.RecId != 0 && taxRegistration.NumberSequenceGroupId != '' && taxRegistration.NumberSequenceGroupId != salesTable.NumberSequenceGroup)
        {
            ttsbegin;
            salesTable.selectForUpdate(true);
            salesTable.NumberSequenceGroup = taxRegistration.NumberSequenceGroupId;
            salesTable.doUpdate();
            ttscommit;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxMarkupCompound</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public Tax getTaxMarkupCompound()
    {
        return taxMarkupCompound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupAutoOriginSource</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public Common getMarkupAutoOriginSource()
    {
        return markupAutoOriginSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    TaxAmount calc()
    {
        if (!headingRecId)
        {
            return 0;
        }

        TaxAmount taxAmount;
        if (isTaxIntegrationEnabledForSales)
        {
            taxAmount = this.calcUsingTaxIntegration();
            if (!TaxIntegrationNumberSequenceInDataPersistenceFlight::instance().isEnabled()
                && TaxIntegrationUtils::isMultipleTaxIdEnabled())
            {
                this.updateSONumberSequenceGroupId();
            }
            return taxAmount;
        }

        boolean                  moreLines;
        TaxBaseCur               baseAmount;
        AmountCur                lineAmount;
        AmountCur                baseAmountBeforeDiscount;
        
        Map                      amountInclTax   = new Map(Types::Container, Types::Real);
        Map                      amountExclTax   = new Map(Types::Container, Types::Real);
        RefRecId                 adjustRecId[];
        RefTableId               adjustedTableId[];
        AmountCur                pennyDiff[];
        Counter                  counter;
        Counter                  counterMax;
        TableId                  salesLineTableId;
        DiscPct                  cashDisc        = salesFormLetter.taxCashDiscPercent();
        RefRecId                 orderRecId;
        Percent                  endDiscPercent;
        // <GEERU><GIN>
        boolean                  countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        boolean                  success = true;
        // </GIN></GEERU>
        
        // <GEERU>
        real                    fixedExchRateLoc;
        boolean                 fixedExchRate;
        boolean                 countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GBR>
        boolean                 isBrazilParametersEnabled = BrazilParameters::isEnabled();
        // </GBR>

        boolean                 countryRegion_CZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);

        if (this.skipTaxCalculations())
        {
            return 0;
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        System.Diagnostics.Stopwatch stopWatch;
        guid identifier;

        try
        {
            stopWatch = new System.Diagnostics.Stopwatch();
            identifier = newGuid();

            if (TaxCalculationInstrumentationToggle::instance().isEnabled())
            {
                taxEventSourceLog.CalculateTaxStart(identifier, TaxUncommitted::callStackInfo());
            }
            else
            {
                taxEventSourceLog.CalculateTaxStart(identifier);
            }

            stopWatch.Start();

            // <GBR>
            if (isBrazilParametersEnabled)
            {
                useAndConsumption_BR = salesFormLetter.useAndConsumption_BR();
            }
            // </GBR>
            
            salesFormLetter.initCursor();
            moreLines = true;
            
            while (moreLines)
            {
                salesLine = salesFormLetter.nextLine() as SalesLine;
                
                if (salesFormLetter.lineExist())
                {
                    if (this.mustContinueCalculation())
                    {
                        continue;
                    }
                    
                    lineAmount = this.retrieveLineAmount();
                    
                    this.configureTaxForSalesLine();

                    if (salesFormLetter.transTaxGroup() && salesFormLetter.transTaxItemGroup())
                    {
                        taxableDocumentLines++;
                    }
                    
                    baseAmount = this.retrieveBaseAmount(lineAmount);
                    baseAmountBeforeDiscount = baseAmount;

                    // Multiple sales orders can be posted in one invoice. The discount percentage is retrieved from each
                    // sales order header. When new header fields impact tax calculation, please modify tax integration
                    // in the method <c>TaxIntegrationSalesTableDataRetrieval.copyToLineFromHeaderTable</c> to keep
                    // the same behavior.
                    // deduct total discount from the base amount & line amount
                    endDiscPercent = this.retrieveEndDiscPercent();
                    if (endDiscPercent)
                    {
                        //<GIN>
                        // for India scenario, the base amount should always be the line amount - line amount * Total discount
                        // tax will be calculated based on this amount
                        if (countryRegion_IN)
                        {
                            baseAmount += CurrencyExchangeHelper::amount(-baseAmount, this.currencyCode()) * endDiscPercent / 100;
                        }
                        else
                        {
                            //</GIN>
                            baseAmount += salesFormLetter.lineEndDisc(-baseAmount);
                            //<GIN>
                        }
                        //</GIN>
                        lineAmount -= CurrencyExchangeHelper::amount(lineAmount, this.currencyCode()) * endDiscPercent / 100;
                    }
                    
                    // If this is a Tax included scenario then store the line amount and base amounts for later use.
                    if (salesFormLetter.isTaxIncluded())
                    {
                        amountInclTax.insert(this.taxTransOrigin(salesLine), lineAmount);
                        amountExclTax.insert(this.taxTransOrigin(salesLine), baseAmount);
                        taxIncludedInItemPrice = true;
                    }
                    
                    // deduct non tax portion of the cash discount from the base amount
                    if (this.taxParameters().TaxLessCashDisc)
                    {
                        baseAmount        -= baseAmount        * cashDisc / 100;
                    }
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        baseAmount        = CurrencyExchangeHelper::amount(baseAmount, this.currencyCode());
                    }
                    
                    this.parmTaxSourceType_RU(TaxSourceType_RU::InvoiceTrans);
                    // </GEERU>
                    salesLineTableId   = this.sourceTableId();
                    
                    // <GIN>
                    if (isTaxParametersEnabled)
                    {
                        this.parmAssessableValue_IN(salesFormLetter.assessableValue_IN());
                        this.parmMaximumRetailPrice_IN(salesFormLetter.maximumRetailPrice_IN());
                    }
                    // </GIN>

                    this.insertLineInInternal(baseAmount,
                                              salesFormLetter.transQty() * -1,
                                              salesLine.SalesUnit,
                                              salesLine.ItemId,
                                              salesFormLetter.transPcsPrice(),
                                              salesLine.DefaultDimension,
                                              LedgerDimensionFacade::serviceCreateLedgerDimension(salesFormLetter.operationAccount(), salesLine.DefaultDimension),
                                              salesFormLetter.operationPosting());

                    if (isAutoChargesSetupSequenceCompoundFeatureEnabled)
                    {
                        salesTable = salesFormLetter.orderLine_orderTable() as SalesTable;
                        orderRecId = salesTable.RecId;

                        if (taxMarkupCompound)
                        {
                            taxMarkupCompound.processTaxLineCalc(tmpTaxMarkupCompound, orderRecId, this.headingTableId(), this.sourceRecId(), this.sourceTableId());
                        }
                    }

                    // <GBR>
                    if (isBrazilParametersEnabled)
                    {
                        this.updateTaxationOriginOnTaxWorkTrans_BR(salesFormLetter.taxationOrigin_BR());
                    }
                    // </GBR>
                    
                    if (taxCalculateLine)
                    {
                        taxAmount = this.calcTax();
                        
                        this.saveInProcessTransaction();
                        
                        if (!taxCalculateTotal &&
                            (salesFormLetter.exchRate(taxDate)      != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate)      ||
                             salesFormLetter.exchRateSecondary(taxDate)  != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate)    ||
                             salesFormLetter.triangulation(taxDate) != Currency::triangulation(sourceCurrencyCode, taxDate))
                           )
                            this.adjustAmount(salesFormLetter.exchRate(taxDate),salesFormLetter.exchRateSecondary(taxDate));
                    }
                    
                    // <GEERU>
                    this.parmTaxSourceType_RU(TaxSourceType_RU::None);
                    // </GEERU>

                    if (!isAutoChargesSetupSequenceCompoundFeatureEnabled)
                    {
                        salesTable = salesFormLetter.orderLine_orderTable() as SalesTable;
                        orderRecId = salesTable.RecId;
                    }
                    
                    if (salesTable.SalesStatus == SalesStatus::Invoiced
                        || salesTable.SalesStatus == SalesStatus::Canceled)
                    {
                        skipLineMarkup = true;
                        skipTableMarkup = true;
                    }
                    
                    if (!skipLineMarkup && salesLine.SalesStatus != SalesStatus::Invoiced)
                    {
                        this.calcMarkup(amountInclTax, amountExclTax);
                    }

                    if (salesFormLetter.endDisc())
                    {
                        this.addToOrderBalance(orderRecId, baseAmountBeforeDiscount);
                    }
                    else
                    {
                        this.addToOrderBalance(orderRecId, lineAmount);
                    }

                    if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
                    {
                        // Track sum of absolute value of lines per order
                        mcrOrderBalancesAbsoluteValue.insert(orderRecId, this.mcrOrderBalanceAbsoluteValue(orderRecId) + abs(lineAmount) );
                    }
                }
                else
                    moreLines   = false;
            }
           
            if (!skipTableMarkup)
            {
                salesFormLetter.initCursorMarkupHeader(salesFormLetter.tableId(),
                                                   salesFormLetter.recID());

                this.setReasonTableRefRecIdBeingCalculated(salesTable.CreditNoteReasonCode);
                this.calcMarkup(amountInclTax, amountExclTax);
            }
            
            if (! this.checkTaxCodesInTotal())
            {
                throw error("@SYS22772");
            }
            
            if (taxCalculateTotal)
            {
                this.insertTotalInInternal(cashDisc);
                taxAmount = this.calcTax();
                this.saveTotalInProcessTransaction();
            }
            
            if (taxIncludedInItemPrice)
            {
                this.adjustSourceBaseAmount(amountInclTax, amountExclTax);
            }

            if (!pennyDiffAdjusted)
            {
                CurrencyCode accountingCurrencyCode = Ledger::accountingCurrency();

                while select forupdate taxWorkTrans
                    where (taxWorkTrans.SourceTableId == this.sourceTableId()
                            || taxWorkTrans.SourceTableId == tableNum(MarkupTrans))
                        && taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
                {
                    if (reconcileMap.exists([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId, taxWorkTrans.TaxCode]))
                    {
                        taxWorkTrans.SourceBaseAmountCur = reconcileMap.lookup([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId, taxWorkTrans.TaxCode]);

                        // When the base amount is reconciled, the base amount in tax currency and accounting currency will be reconciled in the same currency.
                        // This ensures accuracy and consistency for tax currency and accounting currency calculations.
                        if (taxWorkTrans.SourceCurrencyCode == accountingCurrencyCode)
                        {
                            taxWorkTrans.TaxBaseAmount = taxWorkTrans.SourceBaseAmountCur;
                        }

                        if (taxWorkTrans.SourceCurrencyCode == taxWorkTrans.CurrencyCode)
                        {
                            taxWorkTrans.TaxBaseAmountCur = taxWorkTrans.SourceBaseAmountCur;
                        }

                        taxWorkTrans.update();
                    }
                }
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                fixedExchRateLoc = SalesTable::findRecId(salesFormLetter.salesTableRecID()).FixedExchRate;
                if (fixedExchRateLoc)
                {
                    fixedExchRate = true;
                }
            }
            // </GEERU>
            
            if (taxCalculateTotal)
            {
                if (salesFormLetter.exchRate(taxDate)      != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate)      ||
                    salesFormLetter.exchRateSecondary(taxDate)  != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate)    ||
                    salesFormLetter.triangulation(taxDate) != Currency::triangulation(sourceCurrencyCode, taxDate))
                    // <GEERU>
                    this.adjustAmount(salesFormLetter.exchRate(taxDate), salesFormLetter.exchRateSecondary(taxDate), fixedExchRate);
                // </GEERU>
            }
            
            this.roundTaxOnTaxGroup();
            
            if (this.headingTableId() != tableNum(SalesTable) || SalesTable::findRecId(this.headingRecId()).SalesStatus != SalesStatus::Canceled)
            {
                this.loadTaxAdjustments(amountInclTax);
            }

            this.calculateBankTaxExchangeRate();
            
            taxAmount = this.totalTaxAmount();
            if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
            {
                returnTaxAmount = this.mcrReturnTotalTaxAmount();
            }
        }
        catch (errorEx) // errorEx is the same as Exception::Error
        {
            success = false;
            taxEventSourceLog.TaxProcessError(guid2Str(newGuid()),
                                              errorEx.Message,
                                              errorEx.StackTrace,
                                              methodStr(TaxSales, calc));
            throw Exception::Error;
        }
        finally
        {
            stopWatch.Stop();
            RefTableId sourceTableId = salesFormLetter.getSource().TableId;
            RefRecId sourceRecId = salesFormLetter.getSource().RecId;
            str sourceTableName = tableId2Name(sourceTableId);
            select count(RecId) from taxWorkTrans;
            taxEventSourceLog.CalculateTaxStop(
                identifier,
                SysCountryRegionCode::countryInfo(),
                sourceTableName,
                TaxTelemetryConstants::salesTax,
                stopWatch.ElapsedMilliseconds,
                taxableDocumentLines,
                markupTransTaxableDocumentLines,
                taxWorkTrans.RecId,
                salesFormLetter.isTaxIncluded(),
                sourceTableId,
                sourceTableName,
                sourceRecId,
                success);
        }
        
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUsingTaxIntegration</Name>
				<Source><![CDATA[
    private TaxAmount calcUsingTaxIntegration()
    {
        TaxIntegrationDocumentObject document;
        if (salesFormLetter is SalesCalcTax_ParmTrans)
        {
            SalesCalcTax_ParmTrans parmTrans = salesFormLetter;
            Common source = parmTrans.getSource();
            if (this.canConstructWithRecord(source))
            {
                document = TaxIntegrationDocumentObject::constructWithRecord(source);
            }
            else
            {
                document = TaxIntegrationDocumentObject::construct(
                    tableNum(SalesParmTable),
                    parmTrans.getSalesParmTableRecId());
            }
            if (TaxIntegrationUtils::isTaxIntegrationEnabledForTaxSolutionProvider()
                || TaxIntegrationMultipleTaxIdForSalesOrderFlight::instance().isEnabled())
            {
                document.setDocumentStatus(parmTrans.parmDocumentStatus_W());
            }
        }
        else
        {
            Common source = salesFormLetter.getSource();
            if (this.canConstructWithRecord(source))
            {
                document = TaxIntegrationDocumentObject::constructWithRecord(source);
            }
            else
            {
                document = TaxIntegrationDocumentObject::construct(
                    salesFormLetter.tableId(),
                    salesFormLetter.recid());
            }
        }

        if (this.useTaxUncommitted()
            && TaxUncommitted::existByDocumentId(this.headingTableId(), this.headingRecId()))
        {
            this.tmpTaxWorkTrans().loadFromTaxUncommitted(this.headingTableId(), this.headingRecId());
        }
        else
        {
            this.setFieldsForLegacyTax();
            this.setFieldsForTaxIntegrationDocumentObject(document);

            TaxIntegrationFacade::calculate(document);

            boolean isTaxIntTaxAdjustReportDiffAmountFlightEnabled = TaxIntegrationTaxAdjustReportDiffAmountFlight::instance().isEnabled();
            if (!isTaxIntTaxAdjustReportDiffAmountFlightEnabled)
            {
                this.calculateBankTaxExchangeRate();
            }

            Map amountIncludingTax = document.getAmountIncludingTax();
            if (this.headingTableId() != tableNum(SalesTable) ||
                SalesTable::findRecId(this.headingRecId()).SalesStatus != SalesStatus::Canceled)
            {
                this.loadTaxAdjustments(amountIncludingTax);
            }

            if (isTaxIntTaxAdjustReportDiffAmountFlightEnabled)
            {
                this.calculateBankTaxExchangeRate();
            }

            if (this.useTaxUncommitted())
            {
                TaxUncommitted::createTaxUncommitted(this);
            }
        }

        return this.totalTaxAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canConstructWithRecord</Name>
				<Source><![CDATA[
    private boolean canConstructWithRecord(Common _source)
    {
        return (!(TaxIntegrationReSelectHeaderTableFlight::instance().isEnabled()
                // If the RecId exists but orig() does not exists, the table buffer is a copy.
                // It cannot be updated directly, we need to re-select it from DB.
                // In this case, construct the document with TableId and RecId
                && _source.RecId != 0
                && !_source.orig())
            && TaxIntegrationConstructWithSourceRecordFlight::instance().isEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInternalStructureWithCompanyForLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void insertInternalStructureWithCompanyForLine(TaxInsertInternalStructureParameters _parameters)
    {
        super(_parameters);

        if (isAutoChargesSetupSequenceCompoundFeatureEnabled && taxMarkupCompound)
        {
            this.insertInternalStructureWithCompany(tmpTaxMarkupCompound,
                                                    _parameters.TaxWorkTrans.TaxCode,
                                                    _parameters.TaxBaseAmount,
                                                    _parameters.TaxBaseAmountRaw,
                                                    _parameters.TaxWorkTrans.TaxBaseQty,
                                                    _parameters.TaxWorkTrans.TaxDirection,
                                                    _parameters.UnitAmount,
                                                    _parameters.SourceTaxBaseAmountCur,
                                                    _parameters.SourceTaxBaseAmountCurRaw,
                                                    _parameters.TaxWorkTrans.CalculationDate,
                                                    _parameters.TaxWorkTrans.Warning,
                                                     false,
                                                    _parameters.TaxWorkTrans.FiscalValue_BR,
                                                    _parameters.TaxWorkTrans.TaxReceivableLongTerm_BR,
                                                    _parameters.TaxWorkTrans.SourceCurrencyCode,
                                                    _parameters.TaxWorkTrans.Company
                                                    );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purgeInternalStructure</Name>
				<Source><![CDATA[
    protected void purgeInternalStructure()
    {
        super();

        tmpTaxMarkupCompound = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBankTaxExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the exchange rate amount for bank exchange rate
    /// </summary>
    private void calculateBankTaxExchangeRate()
    {
        boolean isTaxSpecificExchRateEnabledByBusinessProcess = TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByBusinessProcess(TaxIntegrationBusinessProcess::Sales);
        if (this.parmUseTaxExchangeRate()
            && (this.parmAccountingCurrency() != this.getTransactionalCurrency()
                || isTaxSpecificExchRateEnabledByBusinessProcess))
        {
            DocumentStatus documentStatus_W;
            SalesCalcTax_ParmTrans salesFormLetterParmTrans_W = salesFormLetter as SalesCalcTax_ParmTrans;
            if (salesFormLetterParmTrans_W)
            {
                documentStatus_W = salesFormLetterParmTrans_W.parmDocumentStatus_W();
            }

            if (documentStatus_W !=DocumentStatus::Confirmation)
            {
                if (isTaxSpecificExchRateEnabledByBusinessProcess)
                {
                    VatDueDate_W vatDueDate = TaxSpecificExchangeRate::getDateOfVATRegister(this.headingTableId(), this.headingRecId());

                    if (!vatDueDate && salesFormLetterParmTrans_W)
                    {
                        SalesParmTable salesParmTable = salesFormLetterParmTrans_W.getSource();
                        vatDueDate = salesParmTable.VatDueDate_W;
                    }

                    if (!vatDueDate)
                    {
                        vatDueDate = this.parmTaxDate();
                    }

                    TaxSpecificExchangeRateHelper taxSpecificExchangeRateHelper = new TaxSpecificExchangeRateHelper(
                        this.headingTableId(),
                        this.headingRecId(),
                        TransactionType::Sales,
                        this.getTransactionalCurrency(),
                        vatDueDate);

                    taxSpecificExchangeRateHelper.maintainAccountingCurrencyTaxSpecificExchangeRate();
                    taxSpecificExchangeRateHelper.maintainReportingCurrencyTaxSpecificExchangeRate();

                    TmpTaxWorkTrans localTaxWorkTrans;
                    localTaxWorkTrans.setTmpData(taxWorkTrans);

                    while select CurrencyCode from localTaxWorkTrans
                        group by localTaxWorkTrans.CurrencyCode
                    {
                        taxSpecificExchangeRateHelper.maintainTaxSpecificExchangeRate(localTaxWorkTrans.CurrencyCode);
                    }
                }
                else
                {
                    SalesTaxTransactionExchangeRate salesTaxTransactionExchangeRate = SalesTaxTransactionExchangeRate::findBySourceRecord(this.headingTableId(), this.headingRecId());

                    if (!salesTaxTransactionExchangeRate)
                    {
                        SalesTaxExchangeRateHelper::maintainSalesTaxTransactionExchangeRate(SalesTable::findRecId(this.headingRecId()),
                        this.getTransactionalCurrency(), TransactionType::Sales, this.parmTaxDate());
                    }
                }

                this.calculateTaxDifferenceAmount();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldsForLegacyTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields for legacy tax.
    /// </summary>
    /// <remarks>
    /// This method is called by calcUsingTaxIntegration().
    /// </remarks>
    protected void setFieldsForLegacyTax()
    {
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            this.parmVatRegData_W(salesFormLetter.vatRegData_W());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldsForTaxIntegrationDocumentObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields for tax integration document object.
    /// </summary>
    /// <param name = "_document">The tax integration document object.</param>
    protected void setFieldsForTaxIntegrationDocumentObject(TaxIntegrationDocumentObject _document)
    {
        _document.setTransactionDate(this.taxDate);
        // This deliveryDateMarkup() is for header.
        _document.setDeliveryDate(salesFormLetter.deliveryDateMarkup());
        _document.setDocumentDate(salesFormLetter.documentDate());
        _document.setInvoiceDate(salesFormLetter.invoiceDate());

        _document.setTransactionCurrencyCode(salesFormLetter.currencyCode());

        _document.setCompany(this.getCompany());
        _document.setHeadingTableId(this.headingTableId());
        _document.setHeadingRecId(this.headingRecId());

        _document.setSign(-1);
        _document.setSource(TaxModuleType::Sales);
        _document.setBusinessProcess(TaxIntegrationBusinessProcess::Sales);
        _document.setPrepaid(this.isPrePayment());

        _document.setEUROTriangulation(this.getTriangulation());

        _document.setLegacyTax(this);
        _document.setShouldSkipDocumentCharge(skipTableMarkup);
        _document.setShouldSkipLineCharge(skipLineMarkup);

        _document.setCashDiscountPercent(cashDiscPercent);
        _document.setCashDiscountAmount(cashDiscAmount);

        _document.getQuantityType().setSalesUpdate(this.salesFormLetter.getSpecQty());

        _document.setAccountingCurrencyFixedExchangeRate(this.parmExchRate());
        _document.setReportingCurrencyFixedExchangeRate(this.parmReportingCurrencyExchRate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustSourceBaseAmount</Name>
				<Source><![CDATA[
    private void adjustSourceBaseAmount(Map _amountInclTax, Map _amountExclTax)
    {
        RefRecId adjustRecId[];
        RefTableId adjustedTableId[];
        AmountCur pennyDiff[];
        Counter counter;
        Counter counterMax;

        while select sum(SourceTaxAmountCur)
            from taxWorkTrans
            group by SourceTableId, SourceRecId, SourceCurrencyCode
            where (
                taxWorkTrans.SourceTableId  == this.sourceTableId()     ||
                taxWorkTrans.SourceTableId  == tableNum(MarkupTrans))   &&
                taxWorkTrans.TaxDirection   != TaxDirection::UseTax     &&
                taxWorkTrans.TaxOrigin      != TaxOrigin::TaxReversed
        {
            if ((taxWorkTrans.SourceTaxAmountCur
                    || (TaxAdjustSourcebaseWhenTaxAmountAdjustedToZeroFlight::instance().isEnabled()
                        && isSourceTaxAmountCurAdjustToZero))
                && _amountInclTax.exists(this.taxWorkTransSource(taxWorkTrans))
                && _amountExclTax.exists(this.taxWorkTransSource(taxWorkTrans)))
            {
                _amountInclTax.insert(this.taxWorkTransSource(taxWorkTrans), CurrencyExchangeHelper::amount(_amountInclTax.lookup(this.taxWorkTransSource(taxWorkTrans)), sourceCurrencyCode));
                _amountExclTax.insert(this.taxWorkTransSource(taxWorkTrans), CurrencyExchangeHelper::amount(_amountExclTax.lookup(this.taxWorkTransSource(taxWorkTrans)), sourceCurrencyCode));

                if ((_amountExclTax.lookup(this.taxWorkTransSource(taxWorkTrans)) + taxWorkTrans.SourceTaxAmountCur) != _amountInclTax.lookup(this.taxWorkTransSource(taxWorkTrans)))
                {
                    counterMax++;
                    adjustRecId[counterMax] = taxWorkTrans.SourceRecId;
                    adjustedTableId[counterMax] = taxWorkTrans.SourceTableId;
                    pennyDiff[counterMax] =
                        _amountExclTax.lookup(this.taxWorkTransSource(taxWorkTrans)) +
                        taxWorkTrans.SourceTaxAmountCur -
                        _amountInclTax.lookup(this.taxWorkTransSource(taxWorkTrans));
                }
            }
        }
        if (counterMax)
        {
            for (counter = 1; counter <= counterMax; counter++)
            {
                this.adjustPennyDiff(pennyDiff[counter], adjustedTableId[counter], adjustRecId[counter]);
                pennyDiffAdjusted = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesParmTrans</Name>
				<Source><![CDATA[
    protected boolean isSalesParmTrans()
    {
        return (CustParameters::find().EnableSingleLineTaxAdjustment || this.allowSingleLineAdjustment())
            && salesFormLetter is SalesCalcTax_ParmTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustContinueCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to continue the tax calculation.
    /// </summary>
    /// <returns>
    /// true if continue the tax calculation ; otherwise, false.
    /// </returns>
    protected boolean mustContinueCalculation()
    {
        return !salesFormLetter.isNewLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveLineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the line amount from the <c>SalesFormLetter</c> instance.
    /// </summary>
    /// <returns>The line amount.</returns>
    [Replaceable]
    protected AmountCur retrieveLineAmount()
    {
        return -salesFormLetter.transLineAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the line amount excluding tax (base amount) from the <c>SalesFormLetter</c> instance.
    /// </summary>
    /// <param name = "_lineAmount">Line amount.</param>
    /// <returns>The line amount excluding tax.</returns>
    [Replaceable]
    protected TaxBaseCur retrieveBaseAmount(AmountCur _lineAmount)
    {
        if (salesFormLetter.isTaxIncluded())
        {
            return this.amountExclTax(_lineAmount,
                                      false,
                                      true,
                                      salesFormLetter.transQty(),
                                      salesLine.SalesUnit,
                                      salesLine.ItemId,
                                      salesLine.RecId,
                                      salesLine.TableId);
        }
        
        return _lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveEndDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total discount percent from the <c>SalesFormLetter</c> instance.
    /// </summary>
    /// <returns>The total discount percent.</returns>
    [Replaceable]
    protected Percent retrieveEndDiscPercent()
    {
        return salesFormLetter.endDisc();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performes the calculation of the tax markup, based on the <c>salesFormLetter</c> variable. This method is called from the <c>calc</c> method.
    /// </summary>
    /// <param name="_amountInclTax">
    ///   Map which will be used to store the tax included line amounts for tax included in item price scenarios.
    /// </param>
    /// <param name="_amountExclTax">
    ///   Map which will be used to store the tax excluded line amounts for tax included in item price scenarios.
    /// </param>
    protected void calcMarkup(Map _amountInclTax, Map _amountExclTax)
    {
        TaxAmount   taxAmount;
        NoYes       moreMarkup;
        TaxBaseCur  baseAmount;
        DiscPct     cashDisc        = salesFormLetter.taxCashDiscPercent();
        AmountCur   lineAmount;
        // <GEERU>
        boolean     isCounrtyRegionRUPL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL]);
        // </GEERU>
        moreMarkup  = true;
        parentSourceTableId = this.sourceTableId();
        parentSourceRecId = this.sourceRecId();
        while (moreMarkup)
        {
            markupTrans= salesFormLetter.nextMarkupLine();
            if (markupTrans && !this.skipMarkupTransCalculation(markupTrans))
            {
                markupAdminister= NoYes::Yes;

                if (this.skipMarkupTransactionCalculation(markupTrans))
                {
                    continue;
                }

                this.configureTaxForMarkupLine();
                if (salesFormLetter.markupTaxGroup() && salesFormLetter.markupTaxItemGroup())
                {
                    markupTransTaxableDocumentLines++;
                }

                lineAmount = salesFormLetter.markupAmount() * -1;

                // get the amount excluding tax
                if (salesFormLetter.isTaxIncluded())
                {
                    baseAmount = this.amountExclTax(
                                        lineAmount,
                                        false,
                                        false,
                                        0,
                                        '',
                                        '',
                                        markupTrans.RecId,
                                        markupTrans.TableId);
                }
                else
                {
                    baseAmount = lineAmount;
                }

                // If this is a Tax included scenario then store the line amount and base amounts for later use.
                if (salesFormLetter.isTaxIncluded())
                {
                    _amountInclTax.insert(this.taxTransOrigin(markupTrans), lineAmount);
                    _amountExclTax.insert(this.taxTransOrigin(markupTrans), baseAmount);
                    taxIncludedInItemPrice = true;
                }

                // deduct non tax portion of the cash discount from the base amount
                if (this.taxParameters().TaxLessCashDisc)
                {
                    baseAmount -= baseAmount * cashDisc / 100;
                }
                // <GEERU>
                this.parmTaxSourceType_RU(TaxSourceType_RU::MarkupTrans);
                // </GEERU>

                this.insertLineInInternal(baseAmount,
                                          0,
                                          '',
                                          '',
                                          0,
                                          salesFormLetter.markupDefaultDimension(),
                                          salesFormLetter.operationAccountMarkup(),
                                          salesFormLetter.operationPostingMarkup());

                if (isAutoChargesSetupSequenceCompoundFeatureEnabled && taxMarkupCompound)
                {
                    taxMarkupCompound.processTaxLineCalc(tmpTaxMarkupCompound, this.headingRecId(), this.headingTableId(), this.sourceRecId(), this.sourceTableId());
                }

                if (taxCalculateLine)
                {
                    taxAmount = this.calcTax();
                    this.saveInProcessTransaction();
                    // <GEERU>
                    if (!taxCalculateTotal
                        && (salesFormLetter.exchRate(taxDate) != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate)
                            || salesFormLetter.exchRateSecondary(taxDate) != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate)
                            || salesFormLetter.triangulation(taxDate) != Currency::triangulation(sourceCurrencyCode, taxDate)))
                    {
                        this.adjustAmountLine(salesFormLetter.exchRate(taxDate),salesFormLetter.exchRateSecondary(taxDate));
                    }
                    // </GEERU>
                }
            }
            else
            {
                markupAdminister= NoYes::No;
                moreMarkup  = false;
                // <GEERU>
                this.parmTaxSourceType_RU(TaxSourceType_RU::None);
                // </GEERU>
            }
        }
        parentSourceTableId = 0;
        parentSourceRecId = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipMarkupTransCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether markup transaction calculation need to skip.
    /// </summary>
    /// <param name="_markupTrans">
    /// A record of the <c>MarkupTrans</c> table.
    /// </param>
    /// <returns>true if markup transaction calculation need to skip; otherwise, false.</returns>
    [Replaceable, SysObsolete('Use skipMarkupTransactionCalculation() instead.', false, 04\08\2022)]
    protected boolean skipMarkupTransCalculation(MarkupTrans _markupTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipMarkupTransactionCalculation</Name>
				<Source><![CDATA[
    protected boolean skipMarkupTransactionCalculation(MarkupTrans _markupTrans)
    {
        if (isAutoChargesSetupSequenceCompoundFeatureEnabled && _markupTrans.mustBeSkippedForSummaryUpdate(this.getMarkupAutoOriginSource().RecId))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureTaxForMarkupLine</Name>
				<Source><![CDATA[
    protected void configureTaxForMarkupLine()
    {
        NoYes                   moreMarkup;
        TransDate               taxCalculationDate;
        TaxCalculationDateType  taxCalculationDateType = this.taxParameters().TaxCalculationDateType;

        if (markupTrans)
        {
            markupAdminister = NoYes::Yes;

            switch (taxCalculationDateType)
            {
                case TaxCalculationDateType::DeliveryDate:
                    taxCalculationDate = salesFormLetter.deliveryDateMarkup();
                    break;

                case TaxCalculationDateType::DocumentDate:
                    taxCalculationDate = salesFormLetter.documentDate();
                    break;

                case TaxCalculationDateType::InvoiceDate:
                    taxCalculationDate = salesFormLetter.invoiceDate();
                    break;
            }

            // <GIN>
            if (isTaxParametersEnabled && !MarkupTable_IN::isAllowTax(MarkupModuleType::Cust, markupTrans.MarkupCode))
            {
                this.insertIntersection('',
                                        '',
                                        salesFormLetter.transTransId(),
                                        markupTrans.Txt,
                                        taxCalculationDate);
            }
            else
            {
                // </GIN>
                this.insertIntersection(salesFormLetter.markupTaxGroup(),
                                        salesFormLetter.markupTaxItemGroup(),
                                        salesFormLetter.transTransId(),
                                        markupTrans.Txt,
                                        taxCalculationDate);
                // <GIN>
            }
            // </GIN>

            if (! this.checkTaxCodesByLine())
            {
                throw error("@SYS22772");
            }
        }
        else
        {
            markupAdminister    = NoYes::No;
            moreMarkup          = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureTaxForSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Configures tax calculation for sales line.
    /// </summary>
    protected void configureTaxForSalesLine()
    {
        TaxCalculationDateType  taxCalculationDateType  = this.taxParameters().TaxCalculationDateType;
        TransDate               taxCalculationDate;
        
        this.setReasonTableRefRecIdBeingCalculated(salesLine.CreditNoteReasonCode, salesTable.CreditNoteReasonCode);

        switch (taxCalculationDateType)
        {
            case TaxCalculationDateType::DeliveryDate:
                taxCalculationDate = salesFormLetter.deliveryDate();
                break;

            case TaxCalculationDateType::DocumentDate:
                taxCalculationDate = salesFormLetter.documentDate();
                break;

            case TaxCalculationDateType::InvoiceDate:
                taxCalculationDate = salesFormLetter.invoiceDate();
                break;
        }

        this.insertIntersection(salesFormLetter.transTaxGroup(),
                                salesFormLetter.transTaxItemGroup(),
                                salesFormLetter.transTransId(),
                                this.transTxt(),
                                taxCalculationDate);

        if (! this.checkTaxCodesByLine())
            throw error("@SYS22772");
    }

]]></Source>
			</Method>
			<Method>
				<Name>exciseTaxCalculationdate_IN</Name>
				<Source><![CDATA[
    protected TransDateTime exciseTaxCalculationdate_IN(RefRecId _sourceRecId, TableId _sourceTableId)
    {
        TransDateTime                   cusexciseTaxCalculationDateTime;
        CustomerCalculationDateType_IN  customerCalculationDateType;

        customerCalculationDateType = this.taxParameters().CustomerCalculationDateType_IN;
        switch (customerCalculationDateType)
        {
            case CustomerCalculationDateType_IN::DeliveryDate:
                cusexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(salesFormLetter.deliveryDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                break;
            case CustomerCalculationDateType_IN::InvoiceDate:
                cusexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(salesFormLetter.invoiceDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                break;
        }

        return cusexciseTaxCalculationDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesFormLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>SalesCalcTax_Sales</c> class.
    /// </summary>
    /// <returns>
    /// An instance of the <c>SalesCalcTax_Sales</c> class.
    /// </returns>
    public SalesCalcTax_Sales getSalesFormLetter()
    {
        return salesFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailDescription</Name>
				<Source><![CDATA[
    public TaxAdjustmentDetailDescription getTaxAdjustmentDetailDescription(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        return salesFormLetter.getTaxAdjustmentDetailDescription(_sourceTableId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailReference</Name>
				<Source><![CDATA[
    public TaxAdjustmentDetailReference getTaxAdjustmentDetailReference(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        return salesFormLetter.getTaxAdjustmentDetailReference(_sourceTableId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailType</Name>
				<Source><![CDATA[
    public TaxAdjustmentDetailType getTaxAdjustmentDetailType(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        return salesFormLetter.getTaxAdjustmentDetailType(_sourceTableId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init(SalesCalcTax_Sales   _salesForm)
    {
        CustInvoiceTrans        custInvoiceTrans;
        MCRSalesLine            mcrSalesLine;
        salesFormLetter        = _salesForm;
        taxModuleType          = TaxModuleType::Sales;
        // <GIN>
        if ((isVATEnabled || isExciseEnabled)
            && inventQualityOrderTable)
        {
            qualityOrder   = true;
            headingTableId = inventQualityOrderTable.TableId;
            headingRecId   = inventQualityOrderTable.RecId;
        }
        else
        {
            // </GIN>
            headingTableId         = salesFormLetter.tableId();
            headingRecId           = salesFormLetter.recID();
            // <GIN>
        }
        // </GIN>

        salesTable = SalesTable::findRecId(headingRecId);
        taxDate                = salesFormLetter.invoiceDate();
        taxIncludedInItemPrice = salesFormLetter.isTaxIncluded();
        salesFormLetter.tax(this);

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            if (salesLine.SalesQty < 0)
            {
                mcrSalesLine = salesLine.mcrSalesLine();
                if (mcrSalesLine.CustInvoiceTransRecId)
                {
                    custInvoiceTrans = CustInvoiceTrans::findRecId(mcrSalesLine.CustInvoiceTransRecId);
                    taxDate = custInvoiceTrans.InvoiceDate;
                }
            }
        }

        this.setExchRates(
                salesFormLetter.currencyCode(),
                salesFormLetter.exchRate(taxDate),
                salesFormLetter.exchRateSecondary(taxDate),
                Currency::noYes2UnknownNoYes(salesFormLetter.triangulation(salesFormLetter.invoiceDate())),
                taxDate);
        this.setReportingCurrencyExchRate(salesFormLetter.reportingCurrencyExchRate(), 0);
        this.setCashDiscount(salesFormLetter.taxCashDiscPercent(), 0);

        if (isAutoChargesSetupSequenceCompoundFeatureEnabled)
        {
            markupAutoOriginSource = salesFormLetter.getMarkupAutoOriginSource();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileTaxTrans_RU</Name>
				<Source><![CDATA[
    protected boolean inventProfileTaxTrans_RU()
    {
        TaxUpdateMode_RU    taxUpdateMode;
        boolean             ret;

        ret = super();

        if (salesLine.RecId)
        {
            taxUpdateMode = salesLine.inventDim().inventProfile_RU().taxUpdateOutgoing();
            ret = taxUpdateMode == TaxUpdateMode_RU::Standard;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileType_RU</Name>
				<Source><![CDATA[
    protected InventProfileType_RU inventProfileType_RU()
    {
        SalesTable_RU salesTableRU;

        if (salesLine.TableId == tableNum(SalesLine) && salesLine.RecId)
        {
            return salesLine.inventProfileType_RU();
        }

        if (this.sourceTableId() == tableNum(MarkupTrans))
        {
            switch (markupTrans.TransTableId)
            {
                case tableNum(SalesTable):
                    salesTable = SalesTable::findRecId(markupTrans.TransRecId);
                    salesTableRU = salesTable.salesTable_RU();
                    if (salesTableRU.InventProfileType_RU)
                    {
                        return salesTableRU.InventProfileType_RU;
                    }
                    break;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension_RU</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount ledgerDimension_RU(TmpTaxWorkTrans _tmpTaxWorkTrans, TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        TaxType_W      taxType = TaxTable::find(_tmpTaxWorkTrans.TaxCode).TaxType_W;

        if ((taxType == TaxType_W::VAT                                           ||
             taxType == TaxType_W::VATReduced                                    ||
             taxType == TaxType_W::VATZero)                                      &&
             (CustParameters::taxation_RU(taxDate) == CustTaxation_RU::OnPayment ||
             (salesFormLetter && salesFormLetter.getSalesParmTable_RU().vatOnPayment_RU)))
        {
            if (_tmpTaxWorkTrans.TaxDirection == TaxDirection::OutgoingTax)
            {
                return _taxLedgerAccountGroup.TaxDeferredLedgerDimension_RU;
            }
        }

        return super(_tmpTaxWorkTrans, _taxLedgerAccountGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPerLineTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads tax adjustments that are adjusting taxes for a specific line.
    /// </summary>
    /// <param name="_companyId">
    /// A value that specifies whether a tax adjustment can be located in another company. If they can, the
    /// current company and passed in company will be checked for adjustments.
    /// </param>
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="_amountInclTax">
    /// A collection of transaction amounts that include tax amounts.
    /// </param>
    protected void loadPerLineTaxAdjustments(SelectableDataArea _companyId, RefTableId _sourceTableId, RefRecId _sourceRecId, Map _amountInclTax)
    {
        TaxCalculationAdjustment taxCalculationAdjustment;

        taxCalculationAdjustment = TaxCalculationAdjustment::construct(taxWorkTrans, this);
        taxCalculationAdjustment.parmIsSalesParmTrans(this.isSalesParmTrans());
        taxCalculationAdjustment.parmLineAmountIncludesTax(this.lineAmountIncludesTax());
        taxCalculationAdjustment.parmAmountInclTaxMap(_amountInclTax);
        taxCalculationAdjustment.parmHeadingTableId(_sourceTableId);
        taxCalculationAdjustment.parmHeadingRecId(_sourceRecId);
        taxCalculationAdjustment.loadTaxAdjustments(_companyId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads tax adjustments that are adjusting taxes for a transaction.
    /// </summary>
    /// <param name="_amountInclTax">
    /// A collection of transaction amounts that include tax amounts.
    /// </param>
    protected void loadTaxAdjustments(Map _amountInclTax)
    {
        TaxCalculationAdjustment taxCalculationAdjustment;
        TmpTaxWorkTrans tmpTaxWorkTransLocal;

        if (this.allowSingleLineAdjustment())
        {
            tmpTaxWorkTransLocal.setTmpData(taxWorkTrans);
            this.generateTaxCodeMap();
            while select SourceTableId, SourceRecId, DataAreaId from tmpTaxWorkTransLocal
                group by tmpTaxWorkTransLocal.SourceTableId, tmpTaxWorkTransLocal.SourceRecId, tmpTaxWorkTransLocal.DataAreaId
                where tmpTaxWorkTransLocal.HeadingTableId == headingTableId &&
                    tmpTaxWorkTransLocal.HeadingRecId == headingRecId
            {
                this.loadPerLineTaxAdjustments(tmpTaxWorkTransLocal.DataAreaId, tmpTaxWorkTransLocal.SourceTableId, tmpTaxWorkTransLocal.SourceRecId, _amountInclTax);
            }
            this.clearTaxCodeMap();
        }

        if (this.useSalesTaxAdjustments())
        {
            taxCalculationAdjustment = TaxCalculationAdjustment::construct(taxWorkTrans, this);

            if (taxCalculationAdjustment)
            {
                taxCalculationAdjustment.parmIsSalesParmTrans(this.isSalesParmTrans());
                taxCalculationAdjustment.parmLineAmountIncludesTax(salesFormLetter.isTaxIncluded());
                taxCalculationAdjustment.parmAmountInclTaxMap(_amountInclTax);
                taxCalculationAdjustment.loadTaxAdjustments();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTransRecId_RU</Name>
				<Source><![CDATA[
    public RecId markupTransRecId_RU()
    {
        if (invoicePostingType == SalesInvoicePostingType_RU::GoodsInRoute)
        {
            return markupTrans.RecId;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetReturnTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the tax total related to the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The tax total return to the return portion of the order.
    /// </returns>
    TaxAmountCur mcrGetReturnTaxAmount()
    {
        return returnTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrOrderBalanceAbsoluteValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the balance of a sales order.
    /// </summary>
    /// <param name="_recId">
    /// The record ID used to find the appropriate <c>MCRorderBalancesAbsoluteValue</c> record.
    /// </param>
    /// <returns>
    /// The balance of a sales order if one is found; otherwise, 0.
    /// </returns>
    public AmountCur mcrOrderBalanceAbsoluteValue(RecId _recId)
    {
        AmountCur   orderBalanceAbsoluteValue;

        if (MCROrderBalancesAbsoluteValue.exists(_recId))
        {
            orderBalanceAbsoluteValue = MCROrderBalancesAbsoluteValue.lookup(_recId);
        }

        return orderBalanceAbsoluteValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        this.initialize();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    protected void initialize()
    {
        orderBalances = new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        mcrOrderBalancesAbsoluteValue = new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        pennyDiffAdjusted = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount offsetLedgerDimension_RU(TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        LedgerDimensionDefaultAccount defaultAccount;

        if (TaxParameters::find().TaxSpecPosting_RU == NoYes::Yes)
        {
            if (invoicePostingType == SalesInvoicePostingType_RU::GoodsInRoute)
            {
                defaultAccount = _taxLedgerAccountGroup.TaxGoodsInRouteLedgerDimension_RU;
                if (! defaultAccount)
                {
                    throw error(strFmt("@GLS115950", _taxLedgerAccountGroup.TaxAccountGroup));
                }
                return defaultAccount;
            }

            defaultAccount = _taxLedgerAccountGroup.TaxOutgoingOffsetLedgerDimension_RU;

            if (!defaultAccount)
            {
                throw error(strFmt("@GLS103651", _taxLedgerAccountGroup.TaxAccountGroup));
            }
        }
        else
        {
            defaultAccount = super(_taxLedgerAccountGroup);
        }

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderBalance</Name>
				<Source><![CDATA[
    public AmountCur orderBalance(RecId _recId)
    {
        AmountCur   orderBalance;

        if (orderBalances.exists(_recId))
        {
            orderBalance = orderBalances.lookup(_recId);
        }

        return orderBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalBalance</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal AmountCur totalBalance()
    {
        AmountCur totalBalance;

        MapEnumerator mapEnumerator = orderBalances.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            totalBalance += mapEnumerator.currentValue();
        }

        return totalBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoicePostingType_RU</Name>
				<Source><![CDATA[
    public SalesInvoicePostingType_RU parmInvoicePostingType_RU(SalesInvoicePostingType_RU _invoicePostingType = invoicePostingType)
    {
        invoicePostingType = _invoicePostingType;
        return invoicePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceRecId</Name>
				<Source><![CDATA[
    public RefRecId parmParentSourceRecId()
    {
        return parentSourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceTableId</Name>
				<Source><![CDATA[
    public RefTableId parmParentSourceTableId()
    {
        return parentSourceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfile_RU</Name>
				<Source><![CDATA[
    protected PostingProfile postingProfile_RU()
    {
        if (salesLine.TableId == tableNum(SalesLine) && salesLine.RecId)
        {
            return salesLine.PostingProfile_RU ? salesLine.PostingProfile_RU : salesLine.salesTable().PostingProfile;
        }

        if (this.sourceTableId() == tableNum(MarkupTrans))
        {
            switch (markupTrans.TransTableId)
            {
                case tableNum(SalesTable):
                    salesTable = SalesTable::findRecId(markupTrans.TransRecId);
                    return salesTable.PostingProfile;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseChargeAmount_W</Name>
				<Source><![CDATA[
    public TaxAmountCur reverseChargeAmount_W()
    {
        TmpTaxWorkTrans localTaxWorkTrans;
        TaxAmountCur    reverseChargeTaxAmount;

        if (ReverseChargeParameters_W::find().Enabled)
        {
            localTaxWorkTrans.setTmpData(taxWorkTrans);

            while select localTaxWorkTrans
                where localTaxWorkTrans.ReverseCharge_W == NoYes::Yes
            {
                reverseChargeTaxAmount -= CurrencyExchangeHelper::amount(localTaxWorkTrans.SourceBaseAmountCur * localTaxWorkTrans.showTaxValue() / 100, localTaxWorkTrans.CurrencyCode);
            }
        }

        return reverseChargeTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLinesHaveTaxGroups</Name>
				<Source><![CDATA[
    protected boolean sourceLinesHaveTaxGroups()
    {
        return salesFormLetter.doTaxGroupExistsForDocument();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>RecId</c> of the transaction that is to be taxed. For instance, if the tax is called from a <c>SalesLine</c>, this method will return the <c>RecId</c> of that <c>SalesLine</c>.
    /// </summary>
    /// <returns>
    ///    The ID of the transaction to be taxed.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived methods.
    /// </remarks>
    public RecId sourceRecId()
    {
        if (markupAdminister)
        {
            return markupTrans.RecId;
        }
        else
        {
            return salesLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>TableId</c> of the transaction that is to be taxed. That is, if the tax is called from a <c>SalesLine</c>, this method will return the <c>TableId </c>of the <c>SalesLine</c>.
    /// </summary>
    /// <returns>
    ///    The ID of the transaction to be taxed.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived methods.
    /// </remarks>
    public RefTableId sourceTableId()
    {
        if (markupAdminister)
        {
            return markupTrans.TableId;
        }
        else
        {
            return salesLine.TableId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This method returns the actual tax amount.
    /// </summary>
    /// <param name="_includeUseTax">
    ///    A flag that indicates whether use tax should be included in the tax total.
    /// </param>
    /// <returns>
    ///   The actual tax amount in transactional currency.
    /// </returns>
    public container totalTaxAmountBySign_RU(boolean _includeUseTax = false)
    {
        TaxAmountCur positive;
        TaxAmountCur negative;
        while select taxWorkTrans where
            (_includeUseTax || taxWorkTrans.TaxDirection  != TaxDirection::UseTax) &&
              taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed
        {
            if (TaxTrans_RU::taxLineIsRelatedToNegativeLine(taxWorkTrans))
            {
                negative += taxWorkTrans.SourceRegulateAmountCur;
            }
            else
            {
                positive += taxWorkTrans.SourceRegulateAmountCur;
            }
        }

        return [positive, negative];
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction text for the current tax transaction.
    /// </summary>
    /// <returns>
    ///    The <c>ItemId</c> value of the <c>SalesLine</c> record if present; otherwise the sales category of
    ///    the <c>SalesLine</c> record.
    /// </returns>
    protected TransTxt transTxt()
    {
        if (salesLine.ItemId)
        {
            return(salesLine.ItemId);
        }
        else
        {
            return(EcoResCategory::find(salesLine.SalesCategory).Name);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWorkTrans_RU</Name>
				<Source><![CDATA[
    protected void updateTaxWorkTrans_RU(TmpTaxWorkTrans _taxWorkTrans)
    {
        super(_taxWorkTrans);

        if (salesLine &&
            salesLine.inventDim().inventProfile_RU().taxUpdateOutgoing() == TaxUpdateMode_RU::NoCalc)
        {
            _taxWorkTrans.ExemptTax      = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSalesTaxAdjustments</Name>
				<Source><![CDATA[
    public boolean useSalesTaxAdjustments()
    {
        boolean useSalesTaxAdjustment;

        if (salesFormLetter)
        {
            useSalesTaxAdjustment = salesFormLetter.useSalesTaxAdjustments();
        }

        return useSalesTaxAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Replaceable]
    public static TaxSales construct(SalesCalcTax_Sales   _salesForm)
    {
        TaxSales    taxSales;

        taxSales = new TaxSales();

        taxSales.init(_salesForm);

        taxSales.constructTaxMarkupCompound(_salesForm);

        return taxSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructTaxMarkupCompound</Name>
				<Source><![CDATA[
    private void constructTaxMarkupCompound(SalesCalcTax_Sales _salesForm)
    {
        if (isAutoChargesSetupSequenceCompoundFeatureEnabled && TaxMarkupCompound::isRequiredBySource(this, _salesForm.isTaxIncluded()))
        {
            taxMarkupCompound = TaxMarkupCompound::construct(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTaxGroup</Name>
				<Source><![CDATA[
    static TaxGroup custTaxGroup(CustDlvTermId _dlvTermId, TaxGroup _taxGroup, LogisticsLocationRecId _location = 0)
    {
        TaxGroup                     taxGroup;
        LogisticsLocationRoleType    locationRole;

        locationRole = DlvTerm::find(_dlvTermId).TaxLocationRole;

        if (_location && locationRole != LogisticsLocationRoleType::None && LogisticsLocation::find(_location).isRole(locationRole))
        {
            taxGroup = LogisticsLocationExt::find(_location).TaxGroup;
        }
        else
        {
            taxGroup = _taxGroup;
        }
        return taxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToOrderBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This method adds an amount to the orderBalances map.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the order.
    /// </param>
    /// <param name="_amount">
    /// The amount that is added to map.
    /// </param>
    protected void addToOrderBalance(RecId _recId, AmountCur _amount)
    {
        orderBalances.insert(_recId, this.orderBalance(_recId) - _amount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountIncludesTax</Name>
				<Source><![CDATA[
    protected boolean lineAmountIncludesTax()
    {
        return salesFormLetter.isTaxIncluded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether use tax uncommitted.
    /// </summary>
    /// <returns>true if use tax uncommitted; otherwise false.</returns>
    public boolean useTaxUncommitted()
    {
        // Currently, it only uses <c>TaxUncommitted</c> for <c>SalesTable</c> related scenarios.
        // For <c>SalesParmTable</c>, it may be considered in the future.
        if (isTaxIntegrationCacheFlightEnabled
            && isTaxIntegrationEnabledForSales
            && salesFormLetter
            && salesFormLetter.getSource() is SalesTable
            && salesFormLetter.getSpecQty() == SalesUpdate::All)
        {
            return true;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>