<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecuteDisplayReturnOrder</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Handles the logic behind the RF flow used to manage return orders.
/// </summary>
[WHSWorkExecuteMode(WHSWorkExecuteMode::ReturnOrder)]
[WHSWorkExecuteMode(WHSWorkExecuteMode::ReturnOrderAndLocate)]
public class WhsWorkExecuteDisplayReturnOrder extends WHSWorkExecuteDisplay
{
    int64 numberOfReturnDispositionCodes;

    private WMSLocationId suggestedPickPutLocationId;
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>processControl</Name>
				<Source><![CDATA[
    public boolean processControl(WhsControl _control, str _value)
    {
        
        switch (true)
        {
            case _control is WhsControlItemId:
                return this.processItemIdForReturnOrderReceiving(_control);
        }

        return super(_control, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for Return Order screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    public container buildReturnOrder(container _con)
    {
        container ret = _con;

        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.parmMenuItem());

        ret += [this.buildControl(#RFLabel, "@SYS105841", menuItemTable.rfTitle, 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (pass.exists(#RMANum) && pass.lookup(#RMANum) != '')
        {
            ret += [this.buildControl(#RFText, #RMANum, "@WAX3259", 1, pass.lookup(#RMANum), extendedTypeNum(SalesReturnItemNum), '', 0, 0)];
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookupStr(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0)];

            if (pass.exists(#ItemId))
            {
                WHSInventTable whsInventTable = WHSInventTable::find(pass.lookup(#ItemId));
                InventTable inventTable       = InventTable::find(pass.lookup(#ItemId));
                SalesTable salesTable         = SalesTable::findReturnItemNum(pass.lookup(#RMANum));

                InventDim inventDim           = this.getReturnOrderLineInventDim(salesTable, inventTable);

                if (whsInventTable.rfDescription1)
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
                }
                else
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", inventTable.productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
                }

                if (whsInventTable.rfDescription2)
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
                }

                ret = this.buildProductDimensionsFromInventDim(ret, pass.lookup(#ItemId), inventDim);
            }

            WHSLicensePlateId licensePlateId = menuItemTable.GenerateLP? pass.parmLicensePlateId() : '';
            boolean enableLicensePlateIdControl = !(menuItemTable.GenerateLP && licensePlateId);

            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, licensePlateId, #WHSRFUndefinedDataType, '', 0, enableLicensePlateIdControl)];

            if (menuItemTable.DisplayContainerTypeCode)
            {
                ret = this.buildContainerType(ret, pass.lookupStr(#ContainerType), true, true);
            }

            ret += [this.buildControl(#RFText, #Qty, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
            ret  = this.buildUOM(ret, '', false, false, false, pass.lookupStr(#SelectedValueUOM));
            
            if (this.isCatchWeightControlElligible())
            {
                ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight), extendedTypeNum(Weight), '', 0)];
            }

            ret  = this.buildDispositon(ret, pass.lookupStr(#Disposition), true, numberOfReturnDispositionCodes > 1);
        }
        else
        {
            ret += [this.buildControl(#RFText, #RMANum, "@WAX3259", 1, '', extendedTypeNum(SalesReturnItemNum), '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrderSalesSerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls for return order serial number capturing.
    /// </summary>
    /// <param name = "_con">Container containing the form state before the controls are added.</param>
    /// <param name = "_itemId">ID of the item for which serial numbers are captured</param>
    /// <returns>Container containing the form state after the controls are added.</returns>
    protected container buildReturnOrderSalesSerial(
        container   _con,
        ItemId      _itemId)
    {
        FieldId         fieldId;
        FieldName       fieldName;
        DictField       dictField;
        container       ret = _con;

        fieldId     = fieldNum(InventDim, InventSerialId);
        fieldName   = fieldId2name(tableNum(InventDim), fieldId);
        dictField   = new DictField(tableNum(InventDim), fieldId);

        ret += [this.buildControl(#RFText, #ItemId, "@SYS111673", 1, _itemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        ret += [this.buildControl(#RFLabel,
                                  #SerialCounter,
        strFmt("@WAX3121", pass.lookup(#SerialCounter), pass.lookupNum(#SerialQty), InventTable::find(_itemId).inventUnitId()),
                                  1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0)];

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFSerialUnreadable, "@SYS4030029", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrderTrackingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for tracking dimensions of Return Order screen.
    /// </summary>
    /// <param name="_con">
    /// The form state before the controls are added.
    /// </param>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_defaultQty">
    /// The default quantity of the item.
    /// </param>
    /// <returns>
    /// The form state after the controls are added.
    /// </returns>
    protected container buildReturnOrderTrackingDimensions(
        container   _con,
        ItemId      _itemId,
        Qty         _defaultQty)
    {
        container           ret = _con;
        WHSInventTable      whsInventTable;
        ListEnumerator      le;
        str                 qtyString;
        boolean             enable;

        whsInventTable = WHSInventTable::find(_itemId);
        qtyString = WHSWorkExecuteDisplay::num2StrDisplay(_defaultQty);

        InventDim inventDimReturn;
        if (this.countAllReturnOrderLines(SalesTable::findReturnItemNum(pass.lookup(#RMANum)).SalesId) == 1)
        {
            inventDimReturn = this.getReturnOrderLineInventDim(SalesTable::findReturnItemNum(pass.lookup(#RMANum)), InventTable::find(_itemId));
        }

        InventDim inventDimLocal;
        inventDimLocal.inventBatchId = pass.exists(#BatchId) ? pass.lookupStr(#BatchId)  : inventDimReturn.inventBatchId;
        inventDimLocal.inventSerialId = pass.exists(#SerialId) ? pass.lookupStr(#SerialId) : inventDimReturn.inventSerialId;
        inventDimLocal.InventGtdId_RU = pass.exists(#GtdId_RU) ? pass.lookupStr(#GtdId_RU) : inventDimReturn.InventGtdId_RU;
        inventDimLocal.InventProfileId_RU = pass.exists(#ProfileId_RU) ? pass.lookupStr(#ProfileId_RU) : inventDimReturn.InventProfileId_RU;
        inventDimLocal.InventOwnerId_RU = pass.exists(#OwnerId_RU) ? pass.lookupStr(#OwnerId_RU) : inventDimReturn.InventOwnerId_RU;

        ret += [this.buildControl(#RFLabel, "@WAX5546", "@WAX5546", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (whsInventTable.rfDescription1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (whsInventTable.rfDescription2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];

        InventTable inventTable = InventTable::find(_itemId);
        le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            if (!this.mustShowInventoryDimensionForItem(inventTable, le.current()))
            {
                continue;
            }

            switch (le.current())
            {
                case fieldNum(InventDim, InventBatchId):
                    enable = inventDimLocal.inventBatchId ? !InventBatch::exist(pass.lookup(#ItemId), inventDimLocal.inventBatchId) : true;
                    ret += [this.buildControl(#RFText, #BatchId, "@SYS53635", 1, inventDimLocal.inventBatchId, extendedTypeNum(InventBatchId), '', 0, enable)];
                    break;

                case fieldNum(InventDim, InventSerialId):
                    ret = this.buildReturnOrderSerialNumberControl(ret, _itemId, inventDimLocal.inventSerialId);
                    break;

                default:
                    ret += [this.buildControlForTableField(tableNum(InventDim),
                                                            le.current(),
                                                            fieldId2name(tableNum(InventDim), le.current()),
                                                            1,
                                                            inventDimLocal.(le.current()),
                                                            true)];
                    break;
            }
        }

        ret += [this.buildControl(#RFText, #DimQty, "@SYS105177", 1, qtyString, extendedTypeNum(Qty), '', 0)];
        
        if (this.isCatchWeightControlElligible())
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight), extendedTypeNum(Weight), '', 0)];
        }

        str selectedUOM;

        if (pass.hasValue(#DimUOM))
        {
            selectedUOM = pass.lookupStr(#DimUOM);
        }
        else
        {
            selectedUOM = pass.lookupStr(#SelectedValueUOM);
        }

        ret = this.buildTrackingDimReceiptUOM(ret, '', false, true, selectedUOM);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrderSerialNumberControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds control for serial number.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the control is added.
    /// </param>
    /// <param name="_itemId">
    /// The item number.
    /// </param>
    /// <param name="_inventSerialId">
    /// The serial number.
    /// </param>
    /// <returns>
    /// The form state after the control is added.
    /// </returns>
    private container buildReturnOrderSerialNumberControl(container _con, ItemId _itemId, InventSerialId _inventSerialId)
    {
        container ret = _con;

        if (WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving)
        {
            ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, '', extendedTypeNum(InventSerialId), '', 0)];
        }
        else
        {
            //Serial number is shown only if value exists because we can capture serial only for receiving
            if (_inventSerialId
                || this.returnLineHasOptionalSerialId())
            {
                ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, _inventSerialId, extendedTypeNum(InventSerialId), '', 0, _inventSerialId ? !InventSerial::exist(pass.lookup(#ItemId), _inventSerialId) : true)];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnLineHasOptionalSerialId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks that return order line allows blank serial id but it is specified.
    /// </summary>
    /// <returns>
    ///     true if return order line allows blank serial id but it is specified; otherwise, false.
    /// </returns>
    private boolean returnLineHasOptionalSerialId()
    {
        SalesTable  salesTable = SalesTable::findReturnItemNum(pass.lookup(#RMANum));

        return WhsWorkCreateReturnOrder::returnLineHasOptionalSerialId(salesTable.SalesId, pass.lookup(#ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks dimensions for a sales order line.
    /// </summary>
    /// <param name = "_salesLine">The sales order line.</param>
    protected void checkDimensions(SalesLine _salesLine)
    {
        if (_salesLine.InventTransIdReturn)
        {
            InventBatchId   batchId = pass.lookupStr(#BatchId);
            InventSerialId  serialId = pass.lookupStr(#SerialId);

            if (batchId || serialId)
            {
                if (!InventLookupReturn::validateInventSerialBatchIdReturnWithBlank(serialId, batchId, _salesLine.InventTransIdReturn, _salesLine.ItemId, false))
                {
                    if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
                    {
                        if (batchId && !InventLookupReturn::validateInventSerialBatchIdReturn('', batchId, _salesLine.InventTransIdReturn, _salesLine.ItemId))
                        {
                            throw error(strFmt("@SYP4881857", batchId));
                        }
            
                        if (serialId && !InventLookupReturn::validateInventSerialBatchIdReturn(serialId, '', _salesLine.InventTransIdReturn, _salesLine.ItemId))
                        {
                            throw error(strFmt("@SYP4881858", serialId));
                        }
                    }
                    else
                    {
                        if (batchId)
                        {
                            throw error(strFmt("@SYP4881857", batchId));
                        }
                        else
                        {
                            throw error(strFmt("@SYP4881858", serialId));
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowBlankSerialNumber</Name>
				<Source><![CDATA[
    private boolean allowBlankSerialNumber(InventSerialId _serialId)
    {
        return !_serialId
                && WhsInvent::isSerialNumberOptional(pass.lookupStr(#ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDispositionAction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if sales line associated with return order are set to credit only and if so, throw error
    /// </summary>
    /// <param name="_salesTable">
    ///    The sales table record found in displayForm
    /// </param>
    /// <exception cref="Exception::Error">
    ///    If the sales line found has a disposition action of Credit Only, throw error
    /// </exception>
    public void checkDispositionAction(SalesTable    _salesTable)
    {
        SalesLine                   creditOnlySalesLine;
        ReturnDispositionCode       returnDispositionCode;

        while select creditOnlySalesLine
            where creditOnlySalesLine.SalesId                 == _salesTable.SalesId
                && creditOnlySalesLine.ItemId                 == pass.lookup(#ItemId)
                && creditOnlySalesLine.ReturnStatus           == ReturnStatusLine::Awaiting
            outer join RecId, DispositionAction, DispositionCodeId from returnDispositionCode
                where returnDispositionCode.DispositionCodeId == creditOnlySalesLine.ReturnDispositionCodeId
        {
            if (returnDispositionCode.RecId == 0
                || returnDispositionCode.DispositionAction != DispositionAction::CreditOnly)
            {
                break;
            }
        }

        if (!creditOnlySalesLine)
        {
            throw error("@WAX4783");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStatusAndDispositionCode</Name>
				<Source><![CDATA[
    private void checkStatusAndDispositionCode(SalesLine _salesLine)
    {
        WHSDispositionCode  dispositionCode = pass.lookupStr(#Disposition);
        WHSDispositionTable disposition;

        disposition.InventStatusId = _salesLine.inventDim().InventStatusId;
        disposition.ReturnDispositionCodeId = WHSDispositionTable::find(dispositionCode).ReturnDispositionCodeId;

        if (!disposition.isInventoryStatusValid())
        {
            throw error(strFmt("@SYP4881859", disposition.InventStatusId, dispositionCode));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>countReturnOrderLines</Name>
				<Source><![CDATA[
    private int64 countReturnOrderLines(SalesId _salesId)
    {
        SalesLine   returnLine;

        select count(RecId) from returnLine
            where  returnLine.SalesId        == _salesId
                && returnLine.ItemId         == pass.lookup(#ItemId)
                && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                && returnLine.ExpectedRetQty <  0;

        return returnLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countAllReturnOrderLines</Name>
				<Source><![CDATA[
    private int64 countAllReturnOrderLines(SalesId _salesId)
    {
        SalesLine   returnLine;

        select count(RecId) from returnLine
        where  returnLine.SalesId        == _salesId
            && returnLine.ItemId         == pass.lookup(#ItemId)
            && returnLine.ExpectedRetQty <  0;

        return returnLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReceiptDetailDimension</Name>
				<Source><![CDATA[
    private InventDim createReceiptDetailDimension(WHSInventStatusId _inventStatusId)
    {
        InventDim receiptInventDim;

        receiptInventDim = pass.createInventDimFromPass();
        receiptInventDim.wmsLocationId = InventLocation::find(receiptInventDim.InventLocationId).wmsLocationIdDefaultReceipt;
        receiptInventDim.InventStatusId = _inventStatusId;
        receiptInventDim = InventDim::findOrCreate(receiptInventDim);

        return receiptInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Controls the form displayed for return order processing
    /// </summary>
    /// <param name="_con">
    ///    Container that holds information from the RF entries
    /// </param>
    /// <param name="_buttonClicked">
    ///    Button clicked by user action
    /// </param>
    /// <returns>
    ///    Container holding information for next RF screen update
    /// </returns>
    public container displayForm(container _con, str _buttonClicked = '')
    {
        container                   ret = conNull();
        container                   con = _con;
        int                         hasError = 0;
        WHSRFPassthrough            fieldValues = new WHSRFPassthrough(Types::String, Types::String);
        WHSWorkExecuteDisplay       workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        container                   tmpFieldValues;
        boolean                     complete;
        boolean                     recall;
        WHSWorkCreateReturnOrder    workCreateReturnOrder;
        SalesTable                  salesTable;
        SalesLine                   salesLine;
        WHSWorkBuildId              workBuildId;
        WhsWorkExecute              workExecute = WhsWorkExecute::construct();
        WHSMenuItemName             menuItem;
        WHSRFPassthrough            tmpMap;
        container                   tmpPass;
        int                         tmpStep;
        InventSerialId              serialId;
        boolean                     salesSerialProcess;
        ReturnItemNum               returnItemNum;

        pass = WHSRFPassthrough::create(conPeek(_con, 2));

        hasError = this.hasError(_con);

        salesSerialProcess = InventTable::find(pass.lookupStr(#ItemId)).isSalesProcessSerialActive();

        this.processButtonClicked(_buttonClicked);

        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));
        boolean continueToNextStep;

        switch (step)
        {
            case 0:
                if (pass.exists(#WorkComplete))
                {
                    ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                    pass.remove(#WorkComplete);

                    ret = this.addClusterMessages(ret);
                }

                ret = this.buildReturnOrder(ret);
                step = 1;
                break;

            case 1:
                if (hasError)
                {
                    con = this.removeErrorMessages(con);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }
                
                this.populateGeneratedLicensePlateId(fieldValues);

                ret += this.buildReturnOrder(ret);
                [ret, complete] = this.processFieldValues(ret, fieldValues);
                step = 2;
                break;

            case 2:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);

                // Need to have license plate generation after combining the maps, so item ID is present in the pass.
                this.populateGeneratedLicensePlateId(fieldValues);

                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                if (pass.exists(#SerialCounter)
                    &&  _buttonClicked != #RFSerialUnreadable
                    &&  pass.lookupStr(#SerialId) == '')
                {
                    ret = con;
                    ret = conIns(ret, 3, this.buildControl(#RFLabel, #RFError, "@WAX3128", 1, '', 0, '', 0, false, '', WHSRFColorText::Error));
                    break;
                }

                if (pass.exists(#ItemId)
                    && pass.lookup(#ItemId) != ''
                    && !pass.exists(#SerialCounter))
                {
                    salesTable  = SalesTable::findReturnItemNum(pass.lookup(#RMANum));

                    this.checkDispositionAction(salesTable);

                    while select salesLine
                        where salesLine.SalesId         == salesTable.SalesId
                            && salesLine.ItemId         == pass.lookup(#ItemId)
                            && salesLine.ReturnStatus   == ReturnStatusLine::Awaiting
                            && salesLine.ExpectedRetQty <  0
                    {
                        if (InventSite::allowReceiptAtOtherWarehouse(salesLine.inventDim().InventLocationId, pass.lookup(#InventLocationId)))
                        {
                            break;
                        }
                    }

                    if (salesLine.RecId == 0)
                    {
                        throw error("@WAX1239");
                    }
                }

                ret += this.buildReturnOrder(ret);

                [ret, complete] = this.processFieldValues(ret, fieldValues);

                if (complete && this.isWorkCreationDataEntryComplete() && pass.hasValue(#UOM))
                {
                    salesLine = this.getReturnOrderLine(true, pass.exists(#SerialCounter));
                        
                    if (salesLine.RecId == 0)
                    {
                        throw error("@WAX3284");
                    }
                    this.checkStatusAndDispositionCode(salesLine);

                    if (!pass.exists(#ReceiptId))
                    {
                        pass.insert(#ReceiptId, NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                    }

                    if (this.captureTrackingDimensions(pass.lookup(#ItemId)) 
                    &&  !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.lookup(#ReceiptId), pass.lookup(#LicensePlateId)))
                    {
                        ret = conNull();
                        ret = this.buildReturnOrderTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#Qty));
                        step = 3;
                        pass.insert(#DimRunningQty, WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId),
                                                                                           pass.lookup(#UOM),
                                                                                           pass.lookupNum(#Qty),
                                                                                           this.createReceiptDetailDimension(this.getReturnOrderLine().inventDim().InventStatusId).InventDimId));
                        break;
                    }
                    else if (salesSerialProcess && !pass.exists(#AssignSerial))
                    {
                        step = 3;
                        break;
                    }

                    ret = conNull();

                    if (!this.captureTrackingDimensions(pass.lookup(#ItemId))
                        &&  WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem))
                        &&  !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, WHSCatchWeightHelper::convertInventQuantity(salesLine.ItemId,
                                                                                                                                        pass.lookup(#UOM),
                                                                                                                                        pass.lookupNum(#Qty),
                                                                                                                                        salesLine.InventDimId));

                        if (WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId)))
                        {
                            // Store the average weight off in the pass for use on new tags.
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight, WHSCatchWeightHelper::calculateAverageWeight(1,
                                                                                                                                                pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty),
                                                                                                                                                pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight),
                                                                                                                                                InventTable::inventDecimals(SalesLine.ItemId)));
                        }

                        ret = conNull();
                        ret = this.buildCWTagCapture(ret);
                        step = #CatchWeightTagCapture;
                        break;
                    }

                    if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                    {
                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);
                    }

                    if (pass.exists(#SerialId))
                    {
                        serialId = pass.lookup(#SerialId);
                    }

                    // Batch and serial should not be used when processing work
                    this.resetTrackingDimensionsPassValues();

                    if (!pass.exists(#SerialCounter))
                    {
                        ttsbegin;

                        workCreateReturnOrder = new WHSWorkCreateReturnOrder(salesLine);
                        workCreateReturnOrder.parmInventLocationId(pass.lookup(#InventLocationId));
                        
                        workCreateReturnOrder.parmContainerTypeCode(pass.lookupStr(#ContainerType));
                        
                        workCreateReturnOrder.parmInventQty(WHSCatchWeightHelper::convertInventQuantity(salesLine.ItemId,
                                                                                                   pass.lookup(#UOM),
                                                                                                   pass.lookupNum(#Qty),
                                                                                                   this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId).InventDimId));

                        workCreateReturnOrder.parmWeight(pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight));
                        workCreateReturnOrder.parmCreatedBy(curUserId());
                        workCreateReturnOrder.parmTargetLicensePlateId(pass.lookup(#LicensePlateId));
                        workCreateReturnOrder.parmReturnItemNum(pass.lookup(#RMANum));
                        workCreateReturnOrder.parmDispositionCode(pass.lookupStr(#Disposition));
                        workCreateReturnOrder.parmReceiptId(pass.lookup(#ReceiptId));

                        workBuildId = workCreateReturnOrder.createWork();

                        if (this.mustBuildLicensePlateLabels(menuItemTable, workBuildId, salesLine))
                        {
                            this.buildLicensePlateLabels(workBuildId);
                        }

                        if (PdsGlobal::pdsIsCWItem(salesLine.ItemId)
                            && pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList))
                        {
                            WHSCatchWeightTagLastRegistration::updateCatchWeightTagRegistrationWorkLine(str2con(pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList)),
                                WHSWorkTable::findSingleInboundWorkByWorkBuildId(workBuildId).WorkId);
                        }
                        
                        // If salesSerialProcess, AX will not continue executing the code, but go into a recursive call,
                        // variable workCreateReturnOrder and workBuildId be disposed.
                        // save it to pass. Ax can access it in  later if condition
                        pass.insert(#CanCreateWork, workCreateReturnOrder.canCreateWork() ? 1 : 0);
                        pass.insert(#WorkBuildId, workBuildId);

                        ttscommit;

                        if (salesSerialProcess)
                        {
                            pass.insert(#SerialId, '');
                            pass.insert(#SerialCounter, 1);
                            pass.insert(#SerialQty, pass.lookupNum(#Qty));

                            ret = conNull();
                            ret = this.buildReturnOrderSalesSerial(ret, pass.lookup(#ItemId));
                            step = 2;

                            break;
                        }
                    }
                    else if (salesSerialProcess)
                    {
                        InventTrackingRegisterTrans::createFromSerial(serialId, this.getReturnOrderLine(true, true).InventTransId, _buttonClicked == #RFSerialUnreadable, true);

                        if (pass.lookupNum(#SerialCounter) < pass.lookupNum(#SerialQty))
                        {
                            pass.insert(#SerialCounter, pass.lookupNum(#SerialCounter) + 1);

                            ret = conNull();
                            ret = this.buildReturnOrderSalesSerial(ret, pass.lookup(#ItemId));
                            step = 2;

                            break;
                        }
                    }

                    ttsBegin;

                    if (mode == WHSWorkExecuteMode::ReturnOrderAndLocate
                        && pass.exists(#CanCreateWork) && pass.lookupNum(#CanCreateWork))
                    {
                        workLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(workBuildId, userId);
                        // Assign serial is completed, remove it
                        pass.remove(#AssignSerial);

                        workLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(pass.lookup(#WorkBuildId), userId);

                        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                        {
                            throw error("@WAX1459");
                        }
                        workTable = workLine.whsWorkTable();

                        if (workLine)
                        {
                            pass.insert(#DetermineStep, 1);
                            menuItem = pass.lookup(#MenuItem);
                            con = this.updateModeStepPass(con, mode, step, pass);
                            [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, suggestedPickPutLocationId, _buttonClicked, false);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(tmpPass);

                            pass.insert(#MenuItem, menuItem);

                            if (step == #Restart)
                            {
                                step = 0;
                            }
                            else if (step == #StepOne)
                            {
                                step = #StepMax;
                                pass.insert(#DetermineStep, 1);
                            }

                            con = this.updateModeStepPass(ret, mode, step, pass);
                            con = conPoke(con, 1, [mode, step]);
                            workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                            ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(conPeek(ret, 2));
                            pass.insert(#DoingWork, 1);
                            if (pass.exists(#WorkId) && pass.exists(#LineNum))
                            {
                                workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                                if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                                {
                                    throw error("@WAX1459");
                                }
                                workTable = workLine.whsWorkTable();
                            }
                        }
                    }
                    else
                    {
                        returnItemNum = pass.lookup(#RMANum);
                        pass = this.resetPassWithClusterMessages(pass, con, false);
                        pass.insert(#WorkComplete, 1);
                        pass.insert(#RMANum, returnItemNum);

                        [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, 0, menuItemTable);

                        if (!continueToNextStep)
                        {                            
                            con = conPoke(con, 2, pass.pack());
                            step = 0;
                            workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                            ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(conPeek(ret, 2));
                        }
                    }
                    ttscommit;
                }
                break;

            case 3:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    ret = this.buildTrackingDimReceiptUOM(conDel(ret, conLen(ret) - 2, 3), '', false, true, pass.lookupStr(#DimUOM));
                    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
                    break;
                }

                con = this.buildReturnOrderTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));

                if (!fieldValues.empty())
                {
                    if (fieldValues.exists(#SerialId)
                        && this.allowBlankSerialNumber(fieldValues.lookupStr(#SerialId)))
                    {
                        fieldValues.remove(#SerialId);
                    }

                    if (fieldValues.exists(#GtdId_RU)
                        && this.allowBlankGTDNumber_RU(fieldValues.lookupStr(#GtdId_RU)))
                    {
                        fieldValues.remove(#GtdId_RU);
                    }

                    [ret, complete] = this.processFieldValues(con, fieldValues);
                    
                    salesLine = this.getReturnOrderLine();

                    InventHandlingQty dimHandlingQty;

                    if (complete)
                    {
                        //catch weight does not support sales serial
                        if (salesSerialProcess)
                        {
                            pass.insert(#AssignSerial, 1);

                            InventDimId dimId = this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId).inventDimId;
                            
                            InventQty   dimQty = InventTableModule::unitConvert(pass.lookup(#ItemId),
                                                                                ModuleInventPurchSales::Invent,
                                                                                pass.lookup(#UOM),
                                                                                pass.lookupNum(#Qty),
                                                                                dimId);

                            WHSReceiptDetails::createOrUpdateReceiptDetailsHandlingQty(
                                pass.lookup(#ReceiptId),
                                dimId,
                                dimQty,
                                0,
                                salesLine.ItemId);

                            if (this.captureTrackingDimensions(pass.lookup(#ItemId)))
                            {
                                pass.insert(#DimRunningQty, pass.lookupNum(#DimRunningQty) - dimQty);
                            }
                        }
                        else
                        {
                            this.checkDimensions(salesLine);
                            
                            WHSCapturedWeight calcWeight;
                            dimHandlingQty = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId),
                                                                                  pass.lookup(#DimUOM),
                                                                                  pass.lookupNum(#DimQty),
                                                                                  this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId).InventDimId);

                            if (PdsGlobal::pdsIsCWItem(salesLine.ItemId))
                            {
                                if (!WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId)))
                                {
                                    WHSTransWeight enteredWeight;

                                    if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight))
                                    {
                                        enteredWeight = pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum);
                                    }
                                    else
                                    {
                                        enteredWeight = fieldValues.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - fieldValues.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum);
                                    }

                                    calcWeight = WHSCatchWeightHelper::calculateAverageWeight(
                                                                    dimHandlingQty,
                                                                    pass.lookupNum(#DimRunningQty),
                                                                    enteredWeight,
                                                                    InventTable::inventDecimals(salesLine.ItemId));
                                }
                            }

                            InventDim receiptDetailsInventDim = this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId);
                            // Insert or update receiving detail record
                            WHSReceiptDetails::createOrUpdateReceiptDetailsHandlingQty(
                                pass.lookup(#ReceiptId),
                                receiptDetailsInventDim.InventDimId,
                                dimHandlingQty,
                                calcWeight,
                                salesLine.ItemId);

                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId,
                                        WHSReceiptDetails::find(pass.lookup(#ReceiptId), receiptDetailsInventDim.inventDimId).RecId);


                            pass.insert(#DimRunningQty, pass.lookupNum(#DimRunningQty) - dimHandlingQty);
                        }

                        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled()
                        && PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
                        && WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId)))
                        {
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, dimHandlingQty);

                            ret = conNull();
                            ret = this.buildCWTagCapture(ret);

                            step = #CatchWeightTagCapture;

                            ret = this.updateModeStepPass(ret, mode, step, pass);
                            ret = this.displayForm(ret);
                        }
                        else if (pass.lookupNum(#DimRunningQty) == 0)
                        {
                            step = 2;

                            if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
                            &&  WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId)))
                            {
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, dimHandlingQty);

                                ret = conNull();
                                ret = this.buildCWTagCapture(ret);

                                step = #CatchWeightTagCapture;
                            }

                            ret = this.updateModeStepPass(ret, mode, step, pass);
                            ret = this.displayForm(ret);
                        }
                        else
                        {
                            this.removeTrackingDimensionsFromPass(pass.lookup(#ItemId));
                            pass.remove(#DimQty);
                            pass.insert(#DimUOM, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)));

                            ret = conNull();
                            ret = this.buildReturnOrderTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));
                        }
                    }

                    if (pass.exists(#DisplayBatch))
                    {
                        pass.remove(#DisplayBatch);
                    }
                }
                break;
                
            case #SortReceive:
                ret = this.stepSortReceive(con, _buttonClicked);
                break;

            // Catch Weight
            case #CatchWeightTagCapture:
                ret = this.processCWTagCaptureReturns(hasError, con);
                break;

            default:
                if (pass.exists(#WorkId))
                {
                    if (pass.exists(#LineNum))
                    {
                        workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                    }
                    else
                    {
                        workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                    }

                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                    {
                        throw error("@WAX1459");
                    }

                    workTable = workLine.whsWorkTable();
                }

                menuItem = pass.lookup(#MenuItem);
                con = conPoke(con, 2, pass.pack());
                tmpMap = pass;
                tmpStep = step;
                [ret, step, recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, suggestedPickPutLocationId, _buttonClicked, false);
                pass = new WHSRFPassthrough(Types::String, Types::String);
                pass = WHSRFPassthrough::create(tmpPass);
                pass = this.combineMaps(tmpMap, pass);

                if (step == #Restart)
                {
                    returnItemNum = pass.lookup(#RMANum);
                    pass = WHSRFPassthrough::newReset(pass);
                    pass.insert(#WorkComplete, 1);
                    pass.insert(#RMANum, returnItemNum);
                    con = conNull();
                    con = this.buildReturnOrder(con);
                    step = 0;
                }
                else if (step == #StepOne)
                {
                    if (!pass.exists(#RebuildForm))
                    {
                        step = #StepMax;
                        pass.insert(#DetermineStep, 1);
                    }
                    else
                    {
                        ret = conNull();
                        ret = this.buildReturnOrder(ret);
                        pass.remove(#RebuildForm);
                        step = 1;
                    }
                }

                if (recall)
                {
                    con = this.updateModeStepPass(con, mode, step, pass);
                    con = conPoke(con, 1, [mode, step]);
                    workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                    ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                    pass = new WHSRFPassthrough(Types::String, Types::String);
                    pass = WHSRFPassthrough::create(conPeek(ret, 2));
                    if (pass.exists(#WorkId) && pass.exists(#LineNum))
                    {
                        workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                        workTable = workLine.whsWorkTable();
                    }
                }
                break;
        }

        ret = this.updateModeStepPass(ret, mode, step, pass);

        if (step > 2)
        {
            ret = this.addButtons(ret);
        }
        ret = this.addCancelButton(ret, 1, true);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBuildLicensePlateLabels</Name>
				<Source><![CDATA[
    private boolean mustBuildLicensePlateLabels(WHSRFMenuItemTable _rfMenuItem, WHSWorkBuildId _workBuildId, SalesLine _salesLine)
    {
        if (!WHSReturnReceivingSkipPrintForScrapFlight::instance().isEnabled())
        {
            return _workBuildId
                && _salesLine.inventTable().ItemType != ItemType::Service;
        }

        return _workBuildId
            && _rfMenuItem.PrintLabel
            && _salesLine.inventTable().ItemType != ItemType::Service
            && WHSDispositionTable::isReturnDispositionCodeSupportingLicensePlateLabelCreation(pass.parmDispositionCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateGeneratedLicensePlateId</Name>
				<Source><![CDATA[
    private void populateGeneratedLicensePlateId(WHSRFPassthrough _fieldValues)
    {
        if (pass.exists(#ItemId)
            && !pass.parmLicensePlateId()
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
        {
            WHSLicensePlateId licensePlateId = WHSLicensePlate::generateLicensePlateId(pass.lookup(#ItemId), pass.lookupStr(#SelectedValueUOM));

            pass.insert(#LicensePlateId, licensePlateId);
            _fieldValues.insert(#LicensePlateId, licensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabels</Name>
				<Source><![CDATA[
    private void buildLicensePlateLabels(WHSWorkBuildId _workBuildId)
    {
        var builder = WHSWorkExecuteDisplayLicensePlateLabelBuilder::newFromPass(pass);
        builder.parmWorkBuildId(_workBuildId);
        builder.buildLicensePlateLabels();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processButtonClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the button that was clicked by a user, and prepares
    /// the form information based on the button pressed.
    /// </summary>
    /// <param name="_buttonClicked">
    /// Button clicked by user action
    /// </param>
    protected void processButtonClicked(str _buttonClicked)
    {
        WMSLocationId  newSuggestedPickPutLocationId;
        WhsWorkExecute workExecute = WhsWorkExecute::construct();

        if (_buttonClicked == #RFException)          // Exception
        {
            step = #ReceivingExceptionStep1;
        }
        else if (_buttonClicked == #RFOverride)      // Override
        {
            step = #OverrideStep1;
        }
        else if (_buttonClicked == #RFFull)      // Full (Split)
        {
            step = #SplitWork;
        }
        else if (_buttonClicked == #RFNoLocation)      // Suggest Location (NoLocation)
        {
            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
            Set excludeLocationId = new Set(Types::String);

            if (pass.exists(#ExcludedLocations))
            {
                excludeLocationId = this.buildLocationListFromStr(pass.lookup(#ExcludedLocations));
            }
            else
            {
                excludeLocationId = this.buildLocationListFromStr(workLine.wmsLocationId);
            }
            
            container tmpCon;

            [newSuggestedPickPutLocationId, tmpCon] = workExecute.findNewLocation(workLine, excludeLocationId);
            excludeLocationId = Set::create(tmpCon);
            pass.insert(#SuggestLocation, 1);
            pass.insert(#ExcludedLocations, this.buildLocationListFromSet(excludeLocationId));
            if (pass.exists(#PrevStep))
            {
                step = pass.lookup(#PrevStep);
            }
            else
            {
                pass.insert(#NoValidation, '1');
            }
        }
        else if (_buttonClicked == #RFSplitPut)
        {
            this.validateSplitPutAllowed();
            step = #SplitPutWork;
        }

        suggestedPickPutLocationId = newSuggestedPickPutLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLine</Name>
				<Source><![CDATA[
    private SalesLine getReturnOrderLine(
        boolean _matchProductDimensions = true,
        boolean _serialId = false)
    {
        SalesTable                  salesTable  = SalesTable::findReturnItemNum(pass.lookup(#RMANum));
        SalesLine                   returnLine;
        InventDim                   inventDim;
        InventDim                   inventDimCriteria;
        InventDimParm               inventDimParm;
        InventDimParm               inventDimParmAllowBlank;
        InventTransOrigin           transOrigin;
        InventTrackingRegisterTrans trackingTrans;

        if (_matchProductDimensions && InventDimGroupSetup::newItemIdProductDimensionsOnly(pass.lookup(#ItemId)).activeFields().elements())
        {
            inventDimParm.setAllProductDimensions();
        }
        
        inventDimParm.InventLocationIdFlag = NoYes::Yes;
        
        if (pass.exists(#SerialId))
        {
            inventDimParm.InventSerialIdFlag = NoYes::Yes;
            inventDimParmAllowBlank.InventSerialIdFlag = NoYes::Yes;
        }
        
        if (pass.exists(#BatchId))
        {
            inventDimParm.InventBatchIdFlag = NoYes::Yes;
            inventDimParmAllowBlank.InventBatchIdFlag = NoYes::Yes;
        }
        
        pass.initInventDimFromPassParm(inventDimCriteria, inventDimParm);

        InventSite::setReceivingWarehouseCriteria(inventDimCriteria, inventDimParm);

        if (_serialId)
        {
            // Select the first SalesLine that's registered and does not have all Serials needed associated to it.
            while select returnLine
                where returnLine.SalesId         == salesTable.SalesId
                    && returnLine.ItemId         == pass.lookup(#ItemId)
                    && returnLine.ReturnStatus   == ReturnStatusLine::Registered
                join RecId from transOrigin
                    where transOrigin.InventTransId == returnLine.InventTransId
                    #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, inventDimCriteria, inventDimParm, inventDimParmAllowBlank)
            {
                select sum(Qty) from trackingTrans
                    where trackingTrans.InventTransOrigin == transOrigin.RecId;

                if (abs(returnLine.SalesQty) != trackingTrans.Qty)
                {
                    return returnLine;
                }
            }
        }
        else if (pass.exists(#SerialId) || pass.exists(#BatchId))
        {
            returnLine = this.getReturnOrderLineBasedOnMatchingDimensions(salesTable, inventDimCriteria, inventDimParm, inventDimParmAllowBlank);
        }

        if (!returnLine)
        {
            if (!pass.exists(#Qty))
            {
                select firstonly returnLine
                    order by PdsCWExpectedRetQty asc, ExpectedRetQty asc
                    where returnLine.SalesId         == salesTable.SalesId
                        && returnLine.ItemId         == pass.lookup(#ItemId)
                        && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                        #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, inventDimCriteria, inventDimParm, inventDimParmAllowBlank);
            }
            else
            {
                returnLine = this.getReturnOrderLineBasedOnMatchingQuantity(salesTable, inventDimCriteria, inventDimParm, inventDimParmAllowBlank);
            }
        }
        return returnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkCreationDataEntryComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the user has provided the data needed for work creation.
    /// </summary>
    /// <returns>true if the required data is present; false otherwise.</returns>
    protected boolean isWorkCreationDataEntryComplete()
    {
        return pass.lookupStr(#Disposition) != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        WHSDispositionTable dispositionTable;

        select count(RecId) from dispositionTable
            where dispositionTable.ReturnDispositionCodeId != '';

        numberOfReturnDispositionCodes = dispositionTable.RecId;

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLineInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>InventDim</c> record needed for the <c>buildReturnOrder</c> method.
    /// </summary>
    /// <param name = "_returnOrder">
    /// The return order.
    /// </param>
    /// <param name = "_item">
    /// The item being returned.
    /// </param>
    /// <returns>The dimensions used for the return order.</returns>
    [Replaceable]
    protected InventDim getReturnOrderLineInventDim(SalesTable _returnOrder, InventTable _item)
    {
        InventDim inventDim;

        if (this.countReturnOrderLines(_returnOrder.SalesId) == 1)
        {
            inventDim  = this.getReturnOrderLine(false).inventDim();
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLineBasedOnMatchingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Finds the return order line which can cover the return quantity.
    /// </summary>
    /// <param name = "_salesTable">
    ///  The sales header of the return order line.
    /// </param>
    /// <param name = "_inventDimCriteria">
    ///  The inventory dimension criteria.
    /// </param>
    /// <param name = "_inventDimParm">
    ///  The inventory dimension parameter which needs match.
    /// </param>
    /// <param name = "_inventDimParmAllowBlank">
    ///  The inventory dimension parameter which can be blank.
    /// </param>
    /// <returns>
    ///  The suitable return order line.
    /// </returns>
    private SalesLine getReturnOrderLineBasedOnMatchingQuantity(SalesTable       _salesTable,
                                                                InventDim        _inventDimCriteria,
                                                                InventDimParm    _inventDimParm,
                                                                InventDimParm    _inventDimParmAllowBlank)
    {
        SalesLine          returnLine;
        InventDim          inventDim;

        if (pass.hasValue(#UOM))
        {
            Qty retQty = pass.lookupNum(#Qty);

            while select returnLine
                order by PdsCWExpectedRetQty asc, ExpectedRetQty asc // Still need loop because sales unit can be different.
                where returnLine.SalesId        == _salesTable.SalesId
                   && returnLine.ItemId         == pass.lookup(#ItemId)
                   && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                   #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, _inventDimCriteria, _inventDimParm, _inventDimParmAllowBlank)
            {
                
                if (this.isRetQtyCoveredByReturnLine(returnLine, retQty))
                {
                    break;
                }
            }
        }
    
        return returnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLineBasedOnMatchingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Finds the return order line which can cover the return quantity with given dimensions.
    /// </summary>
    /// <param name = "_salesTable">
    ///  The sales header of the return order line.
    /// </param>
    /// <param name = "_inventDimCriteria">
    ///  The inventory dimension criteria.
    /// </param>
    /// <param name = "_inventDimParm">
    ///  The inventory dimension parameter which needs match.
    /// </param>
    /// <param name = "_inventDimParmAllowBlank">
    ///  The inventory dimension parameter which can be blank.
    /// </param>
    /// <returns>
    ///  The suitable return order line.
    /// </returns>
    private SalesLine getReturnOrderLineBasedOnMatchingDimensions(SalesTable       _salesTable,
                                                                 InventDim        _inventDimCriteria,
                                                                 InventDimParm    _inventDimParm,
                                                                 InventDimParm    _inventDimParmAllowBlank)
    {
        SalesLine          returnLine;

        if (pass.hasValue(#UOM))
        {
            Qty retQty = pass.lookupNum(#Qty);

            InventDim          inventDim;
            InventTransOrigin  inventTransOriginReturn;
            InventTrans        inventTransReturn;
            InventDim          inventDimReturn;

            while select returnLine
                order by PdsCWExpectedRetQty asc, ExpectedRetQty asc // Still need loop because sales unit can be different.
            where returnLine.SalesId        == _salesTable.SalesId
                    && returnLine.ItemId         == pass.lookup(#ItemId)
                    && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                    #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, _inventDimCriteria, _inventDimParm, _inventDimParmAllowBlank)
                exists join inventTransOriginReturn
                    where inventTransOriginReturn.InventTransId == returnLine.InventTransIdReturn
                exists join InventDimId from inventTransReturn
                    where inventTransReturn.inventTransOrigin == inventTransOriginReturn.RecId
                #InventDimExistsJoinAllowBlank(inventTransReturn.InventDimId, inventDimReturn, _inventDimCriteria, _inventDimParm, _inventDimParmAllowBlank)
            {
                
                if (this.isRetQtyCoveredByReturnLine(returnLine, retQty))
                {
                    break;
                }
            }
        }
    
        return returnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetQtyCoveredByReturnLine</Name>
				<Source><![CDATA[
    private boolean isRetQtyCoveredByReturnLine(SalesLine _returnLine, Qty _retQty)
    {
        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        UnitOfMeasureRecId unitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(pass.lookup(#UOM));

        boolean isCWItem = PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId));

        ProductQuantity expectedReturnOrderQty;
        UnitOfMeasureSymbol returnLineUnit;

        if (isCWItem)
        {
            expectedReturnOrderQty = _returnLine.PdsCWExpectedRetQty;
            returnLineUnit = _returnLine.pdsCWUnitId();
        }
        else
        {
            expectedReturnOrderQty = _returnLine.ExpectedRetQty;
            returnLineUnit = _returnLine.SalesUnit;
        }
                
        return (expectedReturnOrderQty <= -releasedProductUnitConverter.convert(_retQty,
                                                        unitOfMeasureRecId,
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(returnLineUnit),
                                                        NoYes::No,
                                                        _returnLine.ItemId,
                                                        _returnLine.InventDimId,
                                                        NoYes::No));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCWTagCaptureReturns</Name>
				<Source><![CDATA[
    private container processCWTagCaptureReturns(
        boolean     _hasError,
        container   _con)
    {
        container           ret = _con;
        
        if (_hasError)
        {
            ret = conDel(ret, #RFErrorLoc, 1);
        }

        container           tmpFieldValues;
        WHSRFPassthrough    fieldValues = new WHSRFPassthrough(Types::String, Types::String);

        [ret, tmpFieldValues] = WHSRFControlData::processData(ret, pass);
        fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);
        boolean hasError = this.hasError(ret);

        if (hasError)
        {
            return ret;
        }

        if (!fieldValues.empty())
        {
            boolean complete;
            [ret, complete] = this.processFieldValues(ret, fieldValues);

            if (complete)
            {
                boolean aggregateWeightCapture = WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId));
                WHSCatchWeightTag tag;
                SalesLine returnLine = this.getReturnOrderLine();

                if (!WHSCatchWeightTag::exist(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag)))
                {
                    InventQty calcWeight;
                    
                    if (aggregateWeightCapture && pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) == pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                    {
                        // In case of last tag, we need to account for remainder of the weight from source line.
                        // The following variable stores the weight of all tags that have already been registered --> (n - 1) * wt of individual tag.
                        InventQty totalWeightOfAllRegisteredTags = (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) - 1) * pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);
                        
                        calcWeight = WHSCatchWeightHelper::calculateAverageWeight(1,
                                                                             1,
                                                                             pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - totalWeightOfAllRegisteredTags,
                                                                             InventTable::inventDecimals(returnLine.ItemId));
                    }
                    else
                    {
                        calcWeight = pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);
                    }

                    this.createCatchWeightTagFromReturnLine(returnLine, calcWeight);
                }
                else
                {
                    tag = WHSCatchWeightTag::find(pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag), true);

                    tag.CapturedWeight =  pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);

                    tag.doUpdate();

                    this.trackScannedCatchWeightTags(tag.RecId);

                    this.registerTagEvent(tag, returnLine.InventTransId);
                }

                // Remove current Tag Id and increment Tag Counter
                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag);
                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) + 1));

                // Increment total catch weight value if we did not capture aggregate amount
                if (!aggregateWeightCapture)
                {
                    // Check if we are registering a tag which was already registered in our system. Basically the tag is now returning back via the return order.
                    // In that case we can reuse the weight from the our WHSCatchWeightTag table. Else we will use the user provided weight from the mobile device.
                    if (tag.RecId != 0)
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight,
                            (pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) + tag.CapturedWeight));
                    }
                    else
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight,
                            (pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) + pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight)));
                    }
                }

                // Check to see if all tags have been captured
                if (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) > pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                {
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter);

                    if (this.captureTrackingDimensions(pass.lookup(#ItemId)) && (pass.lookupNum(#DimRunningQty) > 0))
                    {
                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);
                        
                        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
                        {
                            this.removeTrackingDimensionsFromPass(pass.lookup(#ItemId));
                            pass.remove(#DimQty);
                            pass.insert(#DimUOM, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)));

                            ret = conNull();
                        }

                        step = #TrackingDimDetailsStep;
                        ret = this.buildReturnOrderTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));
                    }
                    else
                    {
                        step = 2;
                        ret = conNull();
                        ret += [this.buildControl(#RFLabel, #Scan, "@WAX:CatchWeightAssignCatchWeightTag", 1, '', #WHSRFUndefinedDataType, '', 0)];
                        ret = this.updateModeStepPass(ret, mode, step, pass);
                        ret = this.displayForm(ret);
                    }
                }
                else
                {
                    // Remove tag weight if aggregate weight was not captured
                    if (!aggregateWeightCapture)
                    {
                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagWeight);
                    }

                    ret = conNull();
                    ret = this.buildCWTagCapture(ret);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerTagEvent</Name>
				<Source><![CDATA[
    private void registerTagEvent(WHSCatchWeightTag _tag, InventTransId _returnLineTransId)
    {
        WHSCatchWeightTagEventRegistration eventRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(WHSCatchWeightTagRegistrationEvent::TagRegistered);
        eventRegistration.parmInventTransId(_returnLineTransId);
        eventRegistration.registerEvent(_tag);

        if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId))
        {
            WHSReceiptDetailsRecId receiptDetailsRecId = pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId);
            WHSReceiptDetails::updateCapturedWeight(receiptDetailsRecId, _tag.CapturedWeight);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCatchWeightControlElligible</Name>
				<Source><![CDATA[
    private boolean isCatchWeightControlElligible()
    {
        return PdsGlobal::pdsIsCWItem(pass.lookupStr(#ItemId))
                && (WHSInventTable::shouldCaptureAggregateWeight(pass.lookupStr(#ItemId))
                    || (!this.captureTrackingDimensions(pass.lookupStr(#ItemId)) && !WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId))));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCatchWeightTagFromReturnLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a tag from the return line source.
    /// </summary>
    /// <param name = "_returnLine">Return line buffer</param>
    /// <param name = "_capturedWeight">Weight of the tag.</param>
    private void createCatchWeightTagFromReturnLine(SalesLine _returnLine, WHSCapturedWeight _capturedWeight)
    {
        if (PdsGlobal::pdsIsCWItem(_returnLine.ItemId))
        {
            WHSReceiptDetailsRecId receiptDetailsRecId;
            if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId))
            {
                receiptDetailsRecId = pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::ReceiptDetailRecId);
            }

            ttsbegin;

            WHSCatchWeightTagCreationSource tagSource = WHSCatchWeightTagCreationSource::instantiateFromSource(_returnLine, pass);
            tagSource.parmReceiptDetailsRecId(receiptDetailsRecId);

            WHSCatchWeightTagCreationMethod tagMethod = WHSCatchWeightTagCreationMethod::newSingleTagCreation(
                                                                pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTag),
                                                                _capturedWeight);

            WHSCatchWeightTagCreator tagCreator = WHSCatchWeightTagCreator::construct();
            this.trackAutoGeneratedCatchWeightTags(tagCreator.createCatchWeightTags(tagSource, tagMethod));

            WHSReceiptDetails::updateCapturedWeight(receiptDetailsRecId, _capturedWeight);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowBlankGTDNumber_RU</Name>
				<Source><![CDATA[
    private boolean allowBlankGTDNumber_RU(InventGTDId_RU _inventGTDId)
    {
        return !_inventGTDId && WHSInvent::isGTDNumberOptional(pass.lookupStr(#ItemId));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>