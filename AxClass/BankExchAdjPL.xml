<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankExchAdjPL</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This is the main class for exchange adjustment calculation on bank transactions.
/// </summary>
class BankExchAdjPL extends RunBaseBatch implements BatchRetryable
{
    QueryRun queryRun;
    ToDate toDate;
    PlExchDiffCalcType exchDiffCalcType;
    BankAccountTrans bankAccountTransOutcome, bankAccountTransIncome;
    BankAccountTransPL bankAccountTransOutcomePL, bankAccountTransIncomePL;
    NoYes fullRecalc;
    NumberSeq numberSeq;
    Voucher voucher;
    LedgerVoucher ledgerVoucher;
    TransactionTxt transactionTxt;
    TransTxt transTxt;
    Map oldTransMap;
    DialogField dialogToDate;
    DialogField fullRecalcField;
    CurrencyCode standardCurrency;
    boolean gain;
    
    private boolean gainReporing;

    private const int CurrentVersion = 1;
    #localmacro.CurrentList
        toDate,
        fullRecalc
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the exchange rate adjustment for bank account.
    /// </summary>
    /// <param name="_accountId">
    /// The bank account number for which exch rate adjustment is calculated.
    /// </param>
    public void calcAndPost(CompanyBankAccountId _accountId)
    {
        AmountMST exchAmount;
        AmountMST inSettleAmountMst;
        AmountMST outSettleAmountMst;
        AmountMSTSecondary exchAmountReporting;
        AmountMSTSecondary inSettleAmountReporting;
        AmountMSTSecondary outSettleAmountReporting;
        KeySum keySum;
        LedgerDimensionDefaultAccount ledgerAccount = BankAccountTable::findLedgerDimension(_accountId);
        CurrencyCode currencyCode;
        DimensionDefault dimension;
        
        this.clear();

        try
        {
            ttsbegin;
            if (fullRecalc)
            {
                this.prepare(_accountId);
            }

            keySum = KeySum::construct(4, 1);

            while (this.fetchOutcome(_accountId))
            {
                exchAmount = 0;
                AmountMST totalExchAmount = 0;

                exchAmountReporting = 0;
                AmountMSTSecondary totalExchAmountReporting = 0;

                while (bankAccountTransOutcome.BankTransAmountCur != bankAccountTransOutcomePL.SettleAmountCur_PL)
                {
                    if (! this.fetchIncome(_accountId))
                    {
                        break;
                    }

                    AmountCur settleAmount = min(bankAccountTransIncome.BankTransAmountCur - bankAccountTransIncomePL.SettleAmountCur_PL,
                                                 bankAccountTransOutcomePL.SettleAmountCur_PL - bankAccountTransOutcome.BankTransAmountCur);

                    if (settleAmount == (bankAccountTransIncome.BankTransAmountCur - bankAccountTransIncomePL.SettleAmountCur_PL) &&
                            settleAmount == (bankAccountTransOutcomePL.SettleAmountCur_PL - bankAccountTransOutcome.BankTransAmountCur))
                    {
                        inSettleAmountMst = bankAccountTransIncome.AmountMST - bankAccountTransIncomePL.SettleAmountMST_PL;
                        outSettleAmountMst = bankAccountTransOutcomePL.SettleAmountMST_PL - bankAccountTransOutcome.AmountMST;

                        inSettleAmountReporting = bankAccountTransIncome.AmountReportingCurrency - bankAccountTransIncomePL.SettleAmountReporting_PL;
                        outSettleAmountReporting = bankAccountTransOutcomePL.SettleAmountMST_PL - bankAccountTransOutcome.AmountReportingCurrency;
                    }
                    else if (settleAmount == (bankAccountTransIncome.BankTransAmountCur - bankAccountTransIncomePL.SettleAmountCur_PL))
                    {
                        inSettleAmountMst = bankAccountTransIncome.AmountMST - bankAccountTransIncomePL.SettleAmountMST_PL;
                        outSettleAmountMst = CurrencyExchangeHelper::amount(bankAccountTransOutcome.AmountMST * settleAmount / (bankAccountTransOutcome.BankTransAmountCur ? bankAccountTransOutcome.BankTransAmountCur : -1));

                        inSettleAmountReporting = bankAccountTransIncome.AmountReportingCurrency - bankAccountTransIncomePL.SettleAmountReporting_PL;
                        outSettleAmountReporting = CurrencyExchangeHelper::amount(bankAccountTransOutcome.AmountReportingCurrency * settleAmount / (bankAccountTransOutcome.BankTransAmountCur ? bankAccountTransOutcome.BankTransAmountCur : -1));
                    }
                    else
                    {
                        inSettleAmountMst = CurrencyExchangeHelper::amount(bankAccountTransIncome.AmountMST * settleAmount / (bankAccountTransIncome.BankTransAmountCur ? bankAccountTransIncome.BankTransAmountCur : 1));
                        outSettleAmountMst = bankAccountTransOutcomePL.SettleAmountMST_PL - bankAccountTransOutcome.AmountMST;

                        inSettleAmountReporting = CurrencyExchangeHelper::amount(bankAccountTransIncome.AmountReportingCurrency * settleAmount / (bankAccountTransIncome.BankTransAmountCur ? bankAccountTransIncome.BankTransAmountCur : 1));
                        outSettleAmountReporting = bankAccountTransOutcomePL.SettleAmountReporting_PL - bankAccountTransOutcome.AmountReportingCurrency;
                    }

                    bankAccountTransIncomePL.SettleAmountCur_PL += settleAmount;
                    bankAccountTransIncomePL.SettleAmountMST_PL += inSettleAmountMst;
                    bankAccountTransIncomePL.SettleAmountReporting_PL += inSettleAmountReporting;
                    bankAccountTransIncomePL.update();

                    exchAmount = outSettleAmountMst - inSettleAmountMst;
                    totalExchAmount += exchAmount;

                    exchAmountReporting = outSettleAmountReporting - inSettleAmountReporting;
                    totalExchAmountReporting += exchAmountReporting;

                    bankAccountTransOutcomePL.SettleAmountCur_PL -= settleAmount;
                    bankAccountTransOutcomePL.SettleAmountMST_PL -= outSettleAmountMst;
                    bankAccountTransOutcomePL.ExchAdjustment_PL += exchAmount;
                    bankAccountTransOutcomePL.SettleAmountReporting_PL -= outSettleAmountReporting;
                    bankAccountTransOutcomePL.ExchAdjustmentReporting_PL += exchAmountReporting;
                    bankAccountTransOutcomePL.update();
                }
                    
                if (totalExchAmount)
                {
                    gain = totalExchAmount > 0;
                    keySum.updateNow([bankAccountTransOutcome.DefaultDimension, bankAccountTransOutcome.BankTransCurrencyCode, true, gain], totalExchAmount);
                }
                    
                if (totalExchAmountReporting)
                {
                    gainReporing = totalExchAmountReporting > 0;
                    keySum.updateNow([bankAccountTransOutcome.DefaultDimension, bankAccountTransOutcome.BankTransCurrencyCode, false, gainReporing], totalExchAmountReporting);
                }
            }

            if (keySum.numOfTrans())
            {
                boolean isAccounting;
                for (int idx = 1; idx <= keySum.numOfTrans(); idx ++)
                {
                    [dimension, currencyCode, isAccounting, gain] = keySum.index2Key(idx);

                    if (isAccounting)
                    {
                        exchAmount = keySum.index2Data(idx);
                    }
                    else
                    {
                        exchAmountReporting = keySum.index2Data(idx);
                    }

                    if (oldTransMap && oldTransMap.exists([dimension, currencyCode, isAccounting, gain]))
                    {
                        if (isAccounting)
                        {
                            exchAmount = exchAmount - oldTransMap.lookup([dimension, currencyCode, isAccounting, gain]);
                        }
                        else
                        {
                            exchAmountReporting = exchAmountReporting - oldTransMap.lookup([dimension, currencyCode, isAccounting, gain]);
                        }
                        oldTransMap.remove([dimension, currencyCode, isAccounting, gain]);
                    }
                        
                    if (isAccounting)
                    {
                        this.postTransV2(_accountId,
                                       currencyCode,
                                       exchAmount,
                                       0,
                                       dimension,
                                       ledgerAccount);
                    }
                    else
                    {
                        this.postTransV2(_accountId,
                                       currencyCode,
                                       0,
                                       exchAmountReporting,
                                       dimension,
                                       ledgerAccount);
                    }
                }

                if (oldTransMap && ! oldTransMap.empty())
                {
                    MapEnumerator oldTransEnumerator = oldTransMap.getEnumerator();
                    while (oldTransEnumerator.moveNext())
                    {
                        [dimension, currencyCode, isAccounting, gain] = oldTransEnumerator.currentKey();

                        if (isAccounting)
                        {
                            exchAmount = oldTransEnumerator.currentValue();

                            this.postTransV2(_accountId,
                                       currencyCode,
                                       - exchAmount,
                                       0,
                                       dimension,
                                       ledgerAccount,
                                       true);
                        }
                        else
                        {
                            exchAmountReporting = oldTransEnumerator.currentValue();

                            this.postTransV2(_accountId,
                                       currencyCode,
                                       0,
                                       - exchAmountReporting,
                                       dimension,
                                       ledgerAccount,
                                       true);
                        }
                    }
                }
                if (ledgerVoucher)
                {
                    ledgerVoucher.end();
                    TransactionLog::create(this.transactionLogType(), this.transactionLogTxt());
                }
            }
            else
            {
                info(strFmt("@CashManagement:No_Transactions", _accountId));
            }
            ttscommit;
        }

        catch (Exception::Deadlock)
        {
            retry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method checks if the exchange adjustment is already made for the bank account.
    /// </summary>
    /// <param name="_accountID">
    /// The bank account number for which exch rate adjustment is calculated.
    /// </param>
    /// <returns>
    /// False if any exchange adjustment is already made for the bank account.
    /// </returns>
    boolean checkTrans(CompanyBankAccountId _accountID)
    {
        BankAccountTrans bankAccountTrans;

        select firstonly bankAccountTrans
                order by TransDate desc
                where bankAccountTrans.AccountId == _accountID
                    && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment;

        if (bankAccountTrans && toDate < bankAccountTrans.TransDate)
        {
            info(strfmt(
                    "@SYS68767",
                    bankAccountTrans.Voucher,
                    date2StrUsr(toDate, DateFlags::FormatAll),
                    date2StrUsr(bankAccountTrans.TransDate, DateFlags::FormatAll)));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clear</Name>
				<Source><![CDATA[
    private void clear()
    {
        bankAccountTransOutcome.clear();
        bankAccountTransIncome.clear();
        ledgerVoucher = null;
        oldTransMap = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase dialog = super();
        DialogGroup dialogGroup = dialog.addGroup("@GLS111606");
        dialogGroup.widthMode(FormWidth::ColumnWidth);
        dialogToDate = dialog.addFieldValue(extendedTypeStr(ToDate), toDate, "@GLS111606");

        dialogGroup = dialog.addGroup("@SYS7170");
        dialogGroup.widthMode(FormWidth::ColumnWidth);

        fullRecalcField = dialog.addFieldValue(enumStr(NoYes), fullRecalc, "@SYS7170", "@GLS110758");

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchIncome</Name>
				<Source><![CDATA[
    private boolean fetchIncome(CompanyBankAccountId _accountId)
    {
        if (exchDiffCalcType == PlExchDiffCalcType::FIFO)
        {
            select firstonly bankAccountTransIncome
                    order by TransDate asc, CreatedDateTime asc, BankTransAmountCur asc, BankTransCurrencyCode asc
                    where bankAccountTransIncome.AccountId == _accountId
                        && bankAccountTransIncome.BankTransAmountCur > 0
                        && bankAccountTransIncome.TransDate <= toDate
                        && bankAccountTransIncome.LedgerTransType != LedgerTransType::ExchAdjustment
                        && bankAccountTransIncome.BankTransCurrencyCode == bankAccountTransOutcome.BankTransCurrencyCode
                join forupdate bankAccountTransIncomePL
                    where bankAccountTransIncomePL.BankAccountTrans == bankAccountTransIncome.RecId
                        && bankAccountTransIncome.BankTransAmountCur != bankAccountTransIncomePL.SettleAmountCur_PL
                        && bankAccountTransIncomePL.ExcludeExchAdj_PL != NoYes::Yes;
        }
        else
        {
            select firstonly bankAccountTransIncome
                    order by TransDate desc, BankTransAmountCur desc, BankTransCurrencyCode desc
                    where bankAccountTransIncome.AccountId == _accountId
                        && bankAccountTransIncome.BankTransAmountCur > 0
                        && bankAccountTransIncome.TransDate <= bankAccountTransOutcome.TransDate
                        && bankAccountTransIncome.LedgerTransType != LedgerTransType::ExchAdjustment
                        && bankAccountTransIncome.BankTransCurrencyCode == bankAccountTransOutcome.BankTransCurrencyCode
                join forupdate bankAccountTransIncomePL
                    where bankAccountTransIncomePL.BankAccountTrans == bankAccountTransIncome.RecId
                        && bankAccountTransIncome.BankTransAmountCur != bankAccountTransIncomePL.SettleAmountCur_PL
                        && bankAccountTransIncomePL.ExcludeExchAdj_PL != NoYes::Yes;
        }

        return bankAccountTransIncome.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchOutcome</Name>
				<Source><![CDATA[
    private boolean fetchOutcome(CompanyBankAccountId _accountId)
    {
        if (! bankAccountTransOutcome)
        {
            if (exchDiffCalcType == PlExchDiffCalcType::FIFO)
            {
                select bankAccountTransOutcome
                        order by TransDate asc, BankTransAmountCur asc, BankTransCurrencyCode asc
                        where bankAccountTransOutcome.AccountId == _accountId
                            && bankAccountTransOutcome.BankTransAmountCur < 0
                            && bankAccountTransOutcome.TransDate <= toDate
                            && bankAccountTransOutcome.LedgerTransType != LedgerTransType::ExchAdjustment
                            && bankAccountTransOutcome.BankTransCurrencyCode != standardCurrency
                    join forupdate bankAccountTransOutcomePL
                        where BankAccountTransOutcomePL.BankAccountTrans == BankAccountTransOutcome.RecId
                            && bankAccountTransOutcome.BankTransAmountCur != bankAccountTransOutcomePL.SettleAmountCur_PL
                            && bankAccountTransOutcomePL.ExcludeExchAdj_PL != NoYes::Yes;
            }
            else
            {
                select bankAccountTransOutcome
                        order by TransDate desc, BankTransAmountCur desc, BankTransCurrencyCode desc
                        where bankAccountTransOutcome.AccountId == _accountId
                            && bankAccountTransOutcome.BankTransAmountCur < 0
                            && bankAccountTransOutcome.TransDate <= toDate
                            && bankAccountTransOutcome.LedgerTransType != LedgerTransType::ExchAdjustment
                            && bankAccountTransOutcome.BankTransCurrencyCode != standardCurrency
                    join forupdate bankAccountTransOutcomePL
                        where bankAccountTransOutcomePL.BankAccountTrans == bankAccountTransOutcome.RecId
                            && bankAccountTransOutcome.BankTransAmountCur != bankAccountTransOutcomePL.SettleAmountCur_PL
                            && bankAccountTransOutcomePL.ExcludeExchAdj_PL != NoYes::Yes;
            }
        }
        else
        {
            next bankAccountTransOutcome;
        }

        return bankAccountTransOutcome.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the dilog values to the class variables.
    /// the slip journal for the cash account.
    /// </summary>
    /// <returns>
    /// True on successful execution of the method.
    /// </returns>
    public boolean getFromDialog()
    {
        boolean ret = super();

        if (ret)
        {
            toDate = dialogToDate.value();
            fullRecalc = fullRecalcField.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankAccountTransV2</Name>
				<Source><![CDATA[
    protected BankAccountTrans initBankAccountTransV2(CompanyBankAccountId _accountId,
                                                    CurrencyCode _currencyCode,
                                                    AmountMSTExchAdjustment _exchAmount,
                                                    AmountMSTSecondary _exchAmountReporting,
                                                    DimensionDefault _dimension,
                                                    LedgerVoucherObject _ledgerVoucherObject)
    {
        BankAccountTrans bankAccountTrans;
        BankAccountTable bankAccountTable = BankAccountTable::find(_accountId);

        bankAccountTrans.TransDate = toDate;
        bankAccountTrans.AccountId = _accountId;

        bankAccountTrans.Voucher = _ledgerVoucherObject.parmVoucher();
        bankAccountTrans.Txt = _ledgerVoucherObject.lastTransTxt();
        bankAccountTrans.DefaultDimension = _dimension;

        bankAccountTrans.LedgerTransType = LedgerTransType::ExchAdjustment;
        bankAccountTrans.Reconciled = NoYes::Yes;

        bankAccountTrans.CurrencyCode = bankAccountTable.CurrencyCode;
        bankAccountTrans.BankTransCurrencyCode = _currencyCode;

        bankAccountTrans.AmountCur = 0.0;
        bankAccountTrans.BankTransAmountCur = 0.0;

        bankAccountTrans.AmountMST = _exchAmount;
        bankAccountTrans.AmountReportingCurrency = _exchAmountReporting;

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the bank transaction buffer.
    /// </summary>
    /// <param name ="_accountId">
    /// The bank account for the exchange adjustment.
    /// </param>
    /// <param name ="_currencyCode">
    /// The currency code for the exchange adjustment.
    /// </param>
    /// <param name ="_exchAmount">
    /// The calculated exchange amount.
    /// </param>
    /// <param name ="_dimension">
    /// The default dimension for the bank transaction.
    /// </param>
    /// <param name ="_ledgerVoucherObject">
    /// The ledger voucher object created for transaction posting.
    /// </param>
    /// <returns>
    /// Bank transaction buffer.
    /// </returns>
    [SysObsolete('initBankAccountTrans() is obsolete. Use initBankAccountTransV2() class instead', false, 14\12\2022)]
    protected BankAccountTrans initBankAccountTrans(CompanyBankAccountId       _accountId,
                                                    CurrencyCode               _currencyCode,
                                                    AmountMSTExchAdjustment    _exchAmount,
                                                    DimensionDefault           _dimension,
                                                    LedgerVoucherObject        _ledgerVoucherObject)
    {
        BankAccountTrans  bankAccountTrans;
        BankAccountTable  bankAccountTable = BankAccountTable::find(_accountId);

        bankAccountTrans.TransDate             = toDate;
        bankAccountTrans.AccountId             = _accountId;

        bankAccountTrans.Voucher               = _ledgerVoucherObject.parmVoucher();
        bankAccountTrans.Txt                   = _ledgerVoucherObject.lastTransTxt();
        bankAccountTrans.DefaultDimension      = _dimension;

        bankAccountTrans.LedgerTransType       = LedgerTransType::ExchAdjustment;
        bankAccountTrans.Reconciled            = NoYes::Yes;

        bankAccountTrans.CurrencyCode          = bankAccountTable.CurrencyCode;
        bankAccountTrans.BankTransCurrencyCode = _currencyCode;

        bankAccountTrans.AmountCur             = 0.0;
        bankAccountTrans.BankTransAmountCur    = 0.0;

        bankAccountTrans.AmountMST             = _exchAmount;

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    private void initLedgerVoucher()
    {
        if (! ledgerVoucher)
        {
            numberSeq = NumberSeq::newGetVoucher(BankParameters::numRefBankExchAdjVoucher_PL());
            voucher = numberSeq.voucher();

            transactionTxt = TransactionTxt::construct();
            transactionTxt.setDate(toDate);
            transactionTxt.setType(LedgerTransTxt::BankExchAdj_RU);
            transactionTxt.setVoucher(voucher);
            transTxt = transactionTxt.txt();

            ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                         SysModule::Bank,
                                                         numberSeq.parmVoucherSequenceCode(),
                                                         TransactionLogType::PlBankExchAdj,
                                                         transTxt);

            ledgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(voucher,
                                                                     toDate,
                                                                     SysModule::Bank,
                                                                     LedgerTransType::ExchAdjustment));
            ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transTxt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        Query query = new Query("@SYS24408");
        QueryBuildDataSource qbds = query.addDataSource(tablenum(BankAccountTable));
        qbds.addRange(fieldnum(BankAccountTable, AccountID));

        queryRun = new QueryRun(query);
        toDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        #ISOCountryRegionCodes
        super();

        GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes([
            [#isoPL, GlobalizationConstants::FeatureReferencePL00008] ],
            funcName()
        );

        exchDiffCalcType = BankParameters::find().ExchDiffCalcType_PL;
        standardCurrency = CompanyInfoHelper::standardCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransV2</Name>
				<Source><![CDATA[
    protected void postTransV2(CompanyBankAccountId _accountId,
                             CurrencyCode _currencyCode,
                             AmountMSTExchAdjustment _exchAmount,
                             AmountMSTSecondary _exchAmountReporting,
                             DimensionDefault _dimension,
                             LedgerDimensionDefaultAccount _ledgerAccount,
                             boolean _reversal = false)
    {
        LedgerPostingType exchPostingType;
        LedgerDimensionDefaultAccount exchLedgerAccount;

        if (_exchAmount)
        {
            this.initLedgerVoucher();

            if ((_exchAmount > 0 && !_reversal) || (_reversal && _exchAmount < 0))
            {
                exchPostingType = LedgerPostingType::ExchRateGain;
                exchLedgerAccount = CurrencyLedgerGainLossAccount::ledgerDimension(Ledger::current(), _currencyCode, CurrencyGainLossAccountType::FinancialGain);
            }
            else
            {
                exchPostingType = LedgerPostingType::ExchRateLoss;
                exchLedgerAccount = CurrencyLedgerGainLossAccount::ledgerDimension(Ledger::current(), _currencyCode, CurrencyGainLossAccountType::FinancialLoss);
            }

            BankAccountTrans bankAccountTrans = this.initBankAccountTransV2(_accountId,
                                                         _currencyCode,
                                                         _exchAmount,
                                                         0,
                                                         _dimension,
                                                         ledgerVoucher.findLedgerVoucherObject(voucher));
            bankAccountTrans.insert();

            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucher.findLedgerVoucherObject(voucher, toDate),
                                                                                   exchPostingType,
                                                                                   LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerAccount, _dimension),
                                                                                   _currencyCode,
                                                                                   _exchAmount,
                                                                                   _reversal));
            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucher.findLedgerVoucherObject(voucher, toDate),
                                                                                   exchPostingType,
                                                                                   LedgerDimensionFacade::serviceCreateLedgerDimension(exchLedgerAccount, _dimension),
                                                                                   _currencyCode,
                                                                                   - _exchAmount,
                                                                                   _reversal));
        }

        if (_exchAmountReporting)
        {
            this.initLedgerVoucher();

            if ((_exchAmountReporting > 0 && !_reversal) || (_reversal && _exchAmountReporting < 0))
            {
                exchPostingType = LedgerPostingType::ExchRateGain;
                exchLedgerAccount = CurrencyLedgerGainLossAccount::ledgerDimension(Ledger::current(), _currencyCode, CurrencyGainLossAccountType::FinancialGain);
            }
            else
            {
                exchPostingType = LedgerPostingType::ExchRateLoss;
                exchLedgerAccount = CurrencyLedgerGainLossAccount::ledgerDimension(Ledger::current(), _currencyCode, CurrencyGainLossAccountType::FinancialLoss);
            }

            BankAccountTrans bankAccountTrans = this.initBankAccountTransV2(_accountId,
                                                             _currencyCode,
                                                             0,
                                                             _exchAmountReporting,
                                                             _dimension,
                                                             ledgerVoucher.findLedgerVoucherObject(voucher));
            bankAccountTrans.insert();

            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(ledgerVoucher.findLedgerVoucherObject(voucher, toDate),
                                                                                       exchPostingType,
                                                                                       LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerAccount, _dimension),
                                                                                       _currencyCode,
                                                                                       _exchAmountReporting,
                                                                                       _reversal));
            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(ledgerVoucher.findLedgerVoucherObject(voucher, toDate),
                                                                                       exchPostingType,
                                                                                       LedgerDimensionFacade::serviceCreateLedgerDimension(exchLedgerAccount, _dimension),
                                                                                       _currencyCode,
                                                                                       - _exchAmountReporting,
                                                                                       _reversal));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method posts the exchange adjustment transaction for the bank account.
    /// </summary>
    /// <param name ="_accountId">
    /// The bank account for the exchange adjustment.
    /// </param>
    /// <param name ="_currencyCode">
    /// The currency code for the exchange adjustment.
    /// </param>
    /// <param name ="_exchAmount">
    /// The calculated exchange amount.
    /// </param>
    /// <param name ="_dimension">
    /// The default dimension for the bank transaction.
    /// </param>
    /// <param name ="_ledgerAccount">
    /// The ledger account from ledger journal.
    /// </param>
    /// <param name ="_reversal">
    /// Represents Whether Recalculation is true or false.
    /// </param>
    [SysObsolete('postTrans() is obsolete.  Use postTransV2() instead', false, 14\12\2022)]
    protected void postTrans(CompanyBankAccountId           _accountId,
                             CurrencyCode                   _currencyCode,
                             AmountMSTExchAdjustment        _exchAmount,
                             DimensionDefault               _dimension,
                             LedgerDimensionDefaultAccount  _ledgerAccount,
                             boolean                        _reversal = false)
    {
        LedgerPostingType                   exchPostingType;
        LedgerDimensionDefaultAccount       exchLedgerAccount;

        if (_exchAmount)
        {
            this.initLedgerVoucher();

            if ((_exchAmount > 0 && !_reversal) || (_reversal && _exchAmount < 0))
            {
                exchPostingType = LedgerPostingType::ExchRateGain;
                exchLedgerAccount = CurrencyLedgerGainLossAccount::ledgerDimension(Ledger::current(), _currencyCode, CurrencyGainLossAccountType::FinancialGain);
            }
            else
            {
                exchPostingType = LedgerPostingType::ExchRateLoss;
                exchLedgerAccount = CurrencyLedgerGainLossAccount::ledgerDimension(Ledger::current(), _currencyCode, CurrencyGainLossAccountType::FinancialLoss);
            }

            BankAccountTrans bankAccountTrans = this.initBankAccountTrans(_accountId,
                                                         _currencyCode,
                                                         _exchAmount,
                                                         _dimension,
                                                         ledgerVoucher.findLedgerVoucherObject(voucher));
            bankAccountTrans.insert();

            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucher.findLedgerVoucherObject(voucher, toDate),
                                                                                   exchPostingType,
                                                                                   LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerAccount, _dimension),
                                                                                   _currencyCode,
                                                                                   _exchAmount,
                                                                                   _reversal));
            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucher.findLedgerVoucherObject(voucher, toDate),
                                                                                   exchPostingType,
                                                                                   LedgerDimensionFacade::serviceCreateLedgerDimension(exchLedgerAccount, _dimension),
                                                                                   _currencyCode,
                                                                                   - _exchAmount,
                                                                                   _reversal));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepare</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amounts of exhange adjustment transactions for the bank account.
    /// </summary>
    /// <param name ="_accountId">
    /// The bank account for the exchange adjustment.
    /// </param>
    protected void prepare(CompanyBankAccountId _accountId)
    {
        BankAccountTrans bankAccountTrans;
        BankAccountTransPL bankAccountTransPL;
        LedgerFiscalCalendarPeriod ledgerFiscalCalendarPeriod;
        FiscalCalendarPeriod fiscalCalendarPeriod;

        void addToOldTransMap(boolean _accounting, boolean _gain)
        {
            oldTransMap.insert(
                    [ bankAccountTrans.DefaultDimension,
                        bankAccountTrans.BankTransCurrencyCode,
                        _accounting,
                        _gain ],
                        _accounting ? bankAccountTrans.AmountMST : bankAccountTrans.AmountReportingCurrency);
        }

        select firstOnly fiscalCalendarPeriod
                order by fiscalCalendarPeriod.StartDate asc
                where fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
            join RecId from ledgerFiscalCalendarPeriod
                where ledgerFiscalCalendarPeriod.Ledger == Ledger::current()
                    && ledgerFiscalCalendarPeriod.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId;
        if (fiscalCalendarPeriod)
        {
            update_recordset BankAccountTransPL
                    setting SettleAmountCur_PL = 0, ExchAdjustment_PL = 0, SettleAmountMST_PL = 0, ExchAdjustmentReporting_PL = 0, SettleAmountReporting_PL = 0
                join BankAccountTrans
                    where bankAccountTrans.RecId == bankAccountTransPL.BankAccountTrans
                        && bankAccountTrans.AccountId == _accountId
                        && bankAccountTrans.TransDate >= fiscalCalendarPeriod.StartDate
                        && bankAccountTrans.LedgerTransType != LedgerTransType::ExchAdjustment
                        && bankAccountTrans.BankTransCurrencyCode != standardCurrency;

            oldTransMap = new Map(Types::Container, Types::Real);

            while select sum(AmountMST) from bankAccountTrans
                group by DefaultDimension, BankTransCurrencyCode
                    where bankAccountTrans.AccountId == _accountId
                        && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment
                        && bankAccountTrans.TransDate >= fiscalCalendarPeriod.StartDate
                        && bankAccountTrans.AmountMST > 0
            {
                addToOldTransMap(true, true);
            }

            while select sum(AmountMST) from bankAccountTrans
                group by DefaultDimension, BankTransCurrencyCode
                    where bankAccountTrans.AccountId == _accountId
                        && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment
                        && bankAccountTrans.TransDate >= fiscalCalendarPeriod.StartDate
                        && bankAccountTrans.AmountMST < 0
            {
                addToOldTransMap(true, false);
            }

            while select sum(AmountReportingCurrency) from bankAccountTrans
                group by DefaultDimension, BankTransCurrencyCode
                    where bankAccountTrans.AccountId == _accountId
                        && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment
                        && bankAccountTrans.TransDate >= fiscalCalendarPeriod.StartDate
                        && bankAccountTrans.AmountReportingCurrency > 0
            {
                addToOldTransMap(false, true);
            }

            while select sum(AmountReportingCurrency) from bankAccountTrans
                group by DefaultDimension, BankTransCurrencyCode
                    where bankAccountTrans.AccountId == _accountId
                        && bankAccountTrans.LedgerTransType == LedgerTransType::ExchAdjustment
                        && bankAccountTrans.TransDate >= fiscalCalendarPeriod.StartDate
                        && bankAccountTrans.AmountReportingCurrency < 0
            {
                addToOldTransMap(false, false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        while (queryRun.next())
        {
            BankAccountTable bankAccountTable = queryRun.get(tablenum(BankAccountTable));
            if (this.checkTrans(bankAccountTable.AccountID))
            {
                this.calcAndPost(bankAccountTable.AccountID);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the transaction log text.
    /// </summary>
    /// <returns>
    /// Transaction log text
    /// </returns>
    protected TransTxt transactionLogTxt()
    {
        return "@GLS110756";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the transaction log type.
    /// </summary>
    /// <returns>
    /// Transaction log type.
    /// </returns>
    protected TransactionLogType transactionLogType()
    {
        return TransactionLogType::PlBankExchAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer     version = conpeek(_packedClass, 1);
        container   packedQuery;

        switch (version)
        {
            case CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method validates the dialog fields
    /// </summary>
    /// <param name = '_calledFrom'>
    /// The object that calls the dialog.
    /// </param>
    /// <returns>
    /// False if toDate is null.
    /// </returns>
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret = true;

        if (! toDate)
        {
            ret = checkFailed("@SYS24455");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS55328";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        BankExchAdjPL exchAdj = new BankExchAdjPL();

        setprefix("@SYS24408");

        if (exchAdj.prompt())
        {
            exchAdj.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExclExchAdj_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method sets the exchanged adjustment field for the bank transaction.
    /// </summary>
    /// <param name = "_bankAccountTrans">
    /// The bank transaction record.
    /// </param>
    /// <param name = "_excludeExchAdjustment_PL">
    /// The exclude exchange adjustment value, either yes or no.
    /// </param>
    public static void setExclExchAdj_PL(
        BankAccountTrans _bankAccountTrans,
        PlExcludeExchAdj _excludeExchAdjustment_PL)
    {
        BankAccountTransPL bankAccountTransPL;

        if (_bankAccountTrans)
        {
            update_recordset bankAccountTransPL
                setting ExcludeExchAdj_PL = _excludeExchAdjustment_PL
                where bankAccountTransPL.BankAccountTrans == _bankAccountTrans.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>