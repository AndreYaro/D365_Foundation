<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailStatementPaymentJournal</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Creates and posts retail statement payment Journal.
/// </summary>
[SysObsolete('This class is obsolete. Please use the RetailEodStatementPaymentJournal class.', false, 11\05\2021)]
class RetailStatementPaymentJournal
{
    RetailStatementTable        statementTable;
    private RetailEodStatementConfigurationAccessor statementTableAccessor;
    NumberSeq                   paymJournalNumSeq;

    LedgerJournalName           journalName;

    LedgerJournalTable          ledgerJournal;

    NumberSeq                   numSeq;
    // <GIN>
    LogisticsLocationRecId      logisticsLocationRecId;
    TaxInformationRecId_IN      taxInformationRecId;
    boolean                     isIndia;
    #ISOCountryRegionCodes
    // </GIN>
    // <GEERU>
    #EECountryRegionCodes

    LedgerJournalType           ledgerJournalType;
    RetailParameters            retailParameters;

    boolean                     countryRegion_W;
    boolean                     countryRegion_RU;
    boolean                     correspondenceEnabled;
    LedgerJournalName           rCashJournalName;
    LedgerJournalTable          rCashledgerJournal;
    NumberSeq                   rCashNumSeq;

    boolean                     processGiftCardsAsPrepayments_RU;
    RetailGiftCardPost_RU       giftCardPost_RU;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToRBOStatementVoucher</Name>
				<Source><![CDATA[
    private void addToRBOStatementVoucher(Voucher _voucher, TransDate _transDate)
    {
        RetailStatementVoucher     statementVoucher;
        ;

        select statementVoucher
            where  statementVoucher.statementId == statementTable.statementId
                && statementVoucher.voucher == _voucher
                && statementVoucher.voucherDate == _transDate;

        if (!statementVoucher)
        {
            statementVoucher.statementId = statementTable.statementId;
            statementVoucher.voucher = _voucher;
            statementVoucher.voucherDate = _transDate;
            statementVoucher.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGiftCardEmptySaleJourLine_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Payment posting for transactions containing only add to gift card operations
    /// </summary>
    /// <param name="_transTable">
    /// The retail transaction.
    /// </param>
    /// <param name="_paymTrans">
    /// The retail payment transaction.
    /// </param>
    /// <param name="_custTable">
    /// The customer.
    /// </param>
    private void createGiftCardEmptySaleJourLine_RU(RetailTransactionTable        _transTable,
                                                    RetailTransactionPaymentTrans _paymTrans,
                                                    CustTable                     _custTable)
    {
        LedgerJournalACType             accountType;
        LedgerDimensionAccount          accountNum;
        LedgerDimensionAccount          offsetAccountNum;
        AmountCur                       amountCurToPost;

        offsetAccountNum = RetailStatementPaymentJournal::getNativeNonLedgerAccount(
            _custTable.InvoiceAccount ? _custTable.InvoiceAccount : _custTable.AccountNum,
            enum2int(LedgerJournalACType::Cust));

        [accountType, accountNum] = this.getLedgerOffsetAccount(
                                                    statementTable.storeId,
                                                    _paymTrans.tenderType,
                                                    _paymTrans.cardTypeId,
                                                    _paymTrans.DefaultDimension);

        if (!accountNum &&
            RetailStoreTenderTypeTable::find(RetailStoreTable::find(statementTable.storeId).RecId, _paymTrans.tenderType).function != RetailTenderFunction::Customer)
        {
            throw error(strfmt("@RET260543", RetailTenderTypeTable::find(_paymTrans.tenderType).name, statementTable.storeId));
        }

        amountCurToPost = _paymTrans.amountCur;

        if (accountNum && amountCurToPost)
        {
            this.createTenderedPaymentLines(
                accountType,
                accountNum,
                _transTable.currency,
                _paymTrans.currency,
                -amountCurToPost,
                _transTable.businessDate,
                _paymTrans.exchRate,
                0,
                false,
                _paymTrans.tenderType,
                LedgerJournalACType::Cust,
                offsetAccountNum,
                _paymTrans.DefaultDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTransRCash</Name>
				<Source><![CDATA[
    private void createLedgerJournalTransRCash(LedgerJournalTrans _paymLine)
    {
        LedgerJournalTrans_RCash ledgerJournalTrans_RCash;
        RCashTrans               rCashTrans;
        RCashVoucher             rCashVoucher;

        ledgerJournalTrans_RCash.RefRecId    = _paymLine.RecId;
        ledgerJournalTrans_RCash.TransStatus = RCashTransStatus::Approved;

        if (_paymLine.AmountCurDebit > 0)
        {
            ledgerJournalTrans_RCash.DocType = RCashDocType::ReimbursementSlip;
        }
        else
        {
            ledgerJournalTrans_RCash.DocType = RCashDocType::DisbursementSlip;
        }

        ledgerJournalTrans_RCash.insert();

        rCashVoucher = new RCashVoucher(_paymLine, ledgerJournalTrans_RCash);
        rCashTrans   = rCashVoucher.createOrUpdateTrans(RCashTransStatus::Approved);

        ledgerJournalTrans_RCash.selectForUpdate(true);
        ledgerJournalTrans_RCash.CashDocId = rCashTrans.DocId;
        ledgerJournalTrans_RCash.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentJournal</Name>
				<Source><![CDATA[
    private LedgerJournalTable createPaymentJournal(
        LedgerJournalType _journalType = ledgerJournalType
        )
    {
        LedgerJournalTable    paymJournal;
        // <GEERU>
        boolean                 isRCash = _journalType == LedgerJournalType::RCash;
        // </GEERU>

        // <GEERU>
        if (isRCash)
        {
            if (!rCashJournalName)
                throw error(strFmt("@SYS4002028", "@SYS4002022"));

            rCashNumSeq = NumberSeq::newGetVoucherFromId(rCashJournalName.NumberSequenceTable);
        }
        else
        {
            if (!journalName)
                throw error(strFmt("@SYS4002028", _journalType == LedgerJournalType::CustPayment ? "@SYS4002020" : "@SYS25908"));
        }
        // </GEERU>

        paymJournal.JournalName =
            // <GEERU>
            isRCash ? rCashJournalName.JournalName :
            // </GEERU>
            journalName.JournalName;

        paymJournal.JournalType = _journalType;
        paymJournal.JournalNum = paymJournalNumSeq.num();
        paymJournal.NumberSequenceTable =
            // <GEERU>
            isRCash ? rCashJournalName.NumberSequenceTable :
            // </GEERU>
            journalName.NumberSequenceTable;

        paymJournal.RetailStatementId = statementTable.statementId;
        paymJournal.DefaultDimension = statementTable.DefaultDimension;

        // <GEERU>
        if (countryRegion_W)
        {
            paymJournal.LedgerJournalInclTax = isRCash ?
                rCashJournalName.LedgerJournalInclTax :
                journalName.LedgerJournalInclTax;
        }
        // </GEERU>

        paymJournal.initValue();
        paymJournal.defaultRow();

        paymJournal.insert();

        RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::createPaymentJournal()',
                           'Displaying field values of payment journal header. Journal name = %1, Journal type = %2, Journal num = %3, Statement Id = %4',
                           journalName.JournalName, ledgerJournalType, paymJournal.JournalNum, statementTable.statementId);

        return paymJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates payment journal line for the given values passed as parameters.
    /// </summary>
    /// <param name = "_accountType">
    ///     The given value for account type.
    /// </param>
    /// <param name = "_accountNum">
    ///     The given value for account number.
    /// </param>
    /// <param name = "_currency">
    ///     The given currency value.
    /// </param>
    /// <param name = "_amount">
    ///     The value for amount.
    /// </param>
    /// <param name = "_date">
    ///     The transaction date.
    /// </param>
    /// <param name = "_exchRate">
    ///     The exchange rate.
    /// </param>
    /// <param name = "_invoiceId">
    ///     The invoice Id.
    /// </param>
    /// <param name = "_settle">
    ///     The boolean value for settlement.
    /// </param>
    /// <param name = "_transTxt">
    ///     The transaction text.
    /// </param>
    /// <param name = "_documentNum">
    ///     The given value for document number.
    /// </param>
    /// <param name = "_defaultDimension">
    ///     The default dimension.
    /// </param>
    /// <param name = "_tenderTypeId">
    ///     The given value for tender type Id.
    /// </param>
    /// <param name = "_offsetAccountType">
    ///     The given value for offset account type.
    /// </param>
    /// <param name = "_offsetAccountNum">
    ///     The given value for offset account number.
    /// </param>
    /// <param name = "_prepayment">
    ///     The boolean value for prepayment.
    /// </param>
    /// <param name = "_postingProifle">
    ///     The posting profile.
    /// </param>
    /// <param name = "_paymReference">
    ///     Payment reference for bank transactions.
    /// </param>
    /// <param name = "_bankTransactionType">
    ///     Bank transaction type for bank drop transactions.
    /// </param>
    private void createPaymentJournalLine(
                    LedgerJournalACType     _accountType,
                    LedgerDimensionAccount  _accountNum,
                    CurrencyCode            _currency,
                    AmountCur               _Amount,
                    TransDate               _date,
                    ExchRate                _exchRate,
                    RecId                   _invoiceRecId = 0,
                    boolean                 _settle = false,
                    LedgerJournalTransTxt   _transTxt = '',
                    DocumentNum             _documentNum = '',
                    DimensionDefault        _defaultDimension = 0,
                    RetailTenderTypeId      _tenderTypeId = ''
                    , LedgerJournalACType    _offsetAccountType = LedgerJournalACType::Ledger
                    , LedgerDimensionAccount _offsetAccountNum = 0
                    , boolean                _prepayment = false
                    , PostingProfile         _postingProifle = ''
                    , PaymReference          _paymReference = ''
                    , BankTransactionType    _bankTransactionType = ''
    )
    {
        LedgerJournalTrans paymLine;
        // <GIN>
        AxLedgerJournalTransTaxExtensionIN  paymLineTaxExtension;
        TransTaxInformation                 transTaxInformation;
        // </GIN>
        // <GEERU>
        boolean                 isRCash = _accountType == LedgerJournalACType::RCash;
        LedgerJournalACType     swapAccountType;
        LedgerDimensionAccount  swapAccountNum;

        PostingProfile getPostingProfile()
        {
            PostingProfile postingProifle = _postingProifle;

            if (!postingProifle && isRCash)
            {
                postingProifle = RCashParameters::find().PostingProfile;
            }

            if (!postingProifle && _prepayment)
            {
                postingProifle = CustParameters::find().PrepaymentPostingProfile;
            }

            if (!postingProifle)
            {
                postingProifle = CustParameters::find().PostingProfile;
            }

            return postingProifle;
        }

        // </GEERU>

        if (_Amount)
        {
            // <GEERU>
            if (isRCash)
            {
                if (!rCashledgerJournal)
                {
                    // Initialize a payment journal table
                    rCashledgerJournal = this.createPaymentJournal(LedgerJournalType::RCash);
                }
            }
            else
            {
                // </GEERU>
                if (!ledgerJournal)
                {
                    // Initialize a payment journal table
                    ledgerJournal = this.createPaymentJournal();
                }
                // <GEERU>
            }
            // </GEERU>

            // <GEERU>
            if (countryRegion_W &&
                _offsetAccountType              == LedgerJournalACType::Cust &&
                _accountType                    != LedgerJournalACType::RCash)
            {
                // In cust payment journal Cust account should be offset account. Swap account and offset account, and change amount sign
                swapAccountType     = _accountType;
                swapAccountNum      = _accountNum;
                _accountType        = _offsetAccountType;
                _accountNum         = _offsetAccountNum;
                _offsetAccountType  = swapAccountType;
                _offsetAccountNum   = swapAccountNum;
                _Amount             = - _Amount;
            }
            // </GEERU>

            paymLine.JournalNum =
                // <GEERU>
                isRCash ?
                rCashledgerJournal.JournalNum :
                // </GEERU>
                ledgerJournal.JournalNum;

            paymLine.AccountType = _accountType;
            paymLine.LedgerDimension = _accountNum;

            // <GEERU>
            if (correspondenceEnabled)
            {
                paymLine.OffsetAccountType = _offsetAccountType;
                paymLine.OffsetLedgerDimension = _offsetAccountNum;
            }
            if (countryRegion_RU)
            {
                paymLine.Prepayment = _prepayment;

                if (_accountType       == LedgerJournalACType::Cust ||
                    _offsetAccountType == LedgerJournalACType::Cust)
                {
                    paymLine.CustFactureAutoCreate_RU = CustParameters::find().PrepaymentFactureAutoCreate_RU;

                    if (_prepayment)
                    {
                        paymLine.TaxGroup = CustParameters::find().TaxGroup_RU;
                        paymLine.TaxItemGroup = CustParameters::find().TaxItemGroup_RU;
                    }
                }
            }
            // </GEERU>

            paymLine.CurrencyCode = _currency;
            paymLine.TransDate = _date;
            paymLine.ExchRate = _exchRate;
            paymLine.PaymReference = _paymReference;
            paymLine.BankTransType = _bankTransactionType;

            // <GEERU>
            paymLine.PostingProfile = getPostingProfile();
            // </GEERU>

            // <GEERU>
            if (isRCash && _prepayment)
            {
                paymLine.OffsetPostingProfile_RU = CustParameters::find().PrepaymentPostingProfile;
            }
            // </GEERU>

            // <GBR>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
            {
                paymLine.Txt = "@RET4289";
            }
            // </GBR>
            else
            {
                paymLine.Txt = _transTxt;
            }

            paymLine.DocumentNum = _documentNum;
            paymLine.TransactionType = LedgerTransType::Payment;
            paymLine.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_defaultDimension, RetailStoreTenderTypeTable::find(RetailStoreTable::find(statementTable.storeId).RecId, _tenderTypeId).DefaultDimension, isRCash ? rCashledgerJournal.DefaultDimension : ledgerJournal.DefaultDimension);

            if (countryRegion_W)
            {
                if (paymLine.AccountType == LedgerJournalACType::Ledger)
                {
                    paymLine.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(paymLine.LedgerDimension, paymLine.DefaultDimension);
                }
            }

            // <GEERU>
            if (correspondenceEnabled)
            {
                paymLine.OffsetDefaultDimension = paymLine.DefaultDimension;

                if (paymLine.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    paymLine.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(paymLine.OffsetLedgerDimension, paymLine.OffsetDefaultDimension);
                }
            }
            // </GEERU>

            Voucher lineVoucher;

            if (_accountType != LedgerJournalACType::Ledger)
            {
                paymLine.Voucher =
                    // <GEERU>
                    isRCash ?
                    rCashNumSeq.voucher() :
                    // </GEERU>
                    numSeq.num();

                if (countryRegion_W)
                {
                    lineVoucher = paymLine.Voucher;
                }
            }

            CustInvoiceJour custInvoiceJour = CustInvoiceJour::findRecId(_invoiceRecId);
            CustTransOpen custTransOpen = this.getCustTransOpen(custInvoiceJour);

            paymLine.MarkedInvoice = custInvoiceJour.InvoiceId;
            paymLine.MarkedInvoiceRecId = custTransOpen.RecId;
            paymLine.MarkedInvoiceCompany = custTransOpen.DataAreaId;

            if (custInvoiceJour.InvoiceId)
            {
                paymLine.Approved = NoYes::Yes;
                paymLine.Approver = HcmWorker::userId2Worker(curUserId());
            }

            if (_settle && custTransOpen)
            {
                paymLine.SettleVoucher = this.getSettlementType();
            }

            if (_Amount < 0)
            {
                paymLine.AmountCurDebit = abs(_Amount);
            }
            else
            {
                paymLine.AmountCurCredit = _Amount;
            }

            paymLine.initValue();
            paymLine.defaultRow();

            if (!correspondenceEnabled)
            {
                paymLine.PaymMode = _tenderTypeId;
            }
            paymLine.Approved = NoYes::Yes;

            if (countryRegion_W
                && _accountType != LedgerJournalACType::Ledger
                && lineVoucher)
            {
                paymLine.Voucher = lineVoucher;
            }

            paymLine.insert();

            // <GIN>
            if (isIndia)
            {
                paymLineTaxExtension    = new AxLedgerJournalTransTaxExtensionIN();
                paymLineTaxExtension.parmLedgerJournalTrans(paymLine.RecId);
                paymLineTaxExtension.save();

                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(paymLine);
                if (transTaxInformation)
                {
                    ttsbegin;
                    transTaxInformation.selectForUpdate(true);
                    transTaxInformation.CompanyLocation = logisticsLocationRecId;
                    transTaxInformation.TaxInformation  = taxInformationRecId;
                    TransTaxInformationHelper::initFromTaxInformation(transTaxInformation);
                    transTaxInformation.update();
                    ttscommit;
                }
            }
            // </GIN>

            this.addToRBOStatementVoucher(paymLine.Voucher, _date);

            // mark payment line for settlement
            this.setPaymentLineMark(paymLine, NoYes::Yes, custTransOpen);

            // <GEERU>
            if (isRCash)
            {
                this.createLedgerJournalTransRCash(paymLine);
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the settlement type.
    /// </summary>
    /// <returns>
    ///     The settlement type.
    /// </returns>
    protected SettlementType getSettlementType()
    {
        return SettlementType::SelectedTransact;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates ledger jounral payment trans records for the given values passed as parameters.
    /// </summary>
    /// <param name="_accountType">
    /// The given value for account type.
    /// </param>
    /// <param name="_accountNum">
    /// The given value for account number.
    /// </param>
    /// <param name="_offsetAccountType">
    /// The given value for offset account type.
    /// </param>
    /// <param name="_offsetAccountNum">
    /// The given value for offset account number.
    /// </param>
    /// <param name="_currency">
    /// The given currency value.
    /// </param>
    /// <param name="_Amount">
    /// The value for amount.
    /// </param>
    /// <param name="_date">
    /// The transaction date.
    /// </param>
    /// <param name="_transTxt">
    /// The transaction text.
    /// </param>
    /// <param name="_documentNum">
    /// The given value for document number.
    /// </param>
    /// <param name="_tenderTypeId">
    /// The given value for tender type Id.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimension; optional.
    /// </param>
    /// <param name="_paymReference">
    /// Payment reference for bank transactions.
    /// </param>
    /// <param name="_bankTransactionType">
    /// Bank transaction type for bank drop transactions.
    /// </param>
    public void createPaymentLedgerTrans(
                    RetailAccountType          _accountType,
                    LedgerDimensionAccount     _accountNum,
                    RetailAccountType          _offsetAccountType,
                    LedgerDimensionAccount     _offsetAccountNum,
                    CurrencyCode            _currency,
                    AmountCur               _Amount,
                    TransDate               _date,
                    LedgerJournalTransTxt   _transTxt = '',
                    DocumentNum             _documentNum = '',
                    RetailTenderTypeId      _tenderTypeId = ''
                    , DimensionDefault      _defaultDimension = 0
                    , PaymReference          _paymReference = ''
                    , BankTransactionType    _bankTransactionType = ''
    )
    {
        LedgerDimensionAccount                  ledgerAccountNum;
        LedgerJournalACType                     ledgerAccountType;
        LedgerDimensionAccount                  offsetLedgerAccountNum, noOffsetLedgerAccountNum;
        LedgerJournalACType                     offsetLedgerAccountType, noOffsetLedgerAccountType;

        ledgerAccountNum = _accountNum;
        ledgerAccountType = this.ledgerBank2LedgerJournalACType(_accountType);

        offsetLedgerAccountNum = _offsetAccountNum;
        offsetLedgerAccountType = this.ledgerBank2LedgerJournalACType(_offsetAccountType);

        // When correspondeceEnabled is ON, a single line is added with an account and an offset account
        // otherwise, 2 lines are created, with account and offset in different 
        if (correspondenceEnabled)
        {
            noOffsetLedgerAccountNum = _offsetAccountNum;
            noOffsetLedgerAccountType = this.ledgerBank2LedgerJournalACType(_offsetAccountType);
        }
        else
        {
            noOffsetLedgerAccountNum = 0;
            noOffsetLedgerAccountType = LedgerJournalACType::Ledger;
        }

        this.createPaymentJournalLine(
                    ledgerAccountType,
                    ledgerAccountNum,
                    _currency,
                    _Amount,
                    _date,
                    ExchangeRateHelper::exchRate(_currency, _date),
                    0,
                    false,
                    _transTxt,
                    _documentNum,
                    _defaultDimension,
                    _tenderTypeId,
                    noOffsetLedgerAccountType,
                    noOffsetLedgerAccountNum,
                    false,
                    '',
                    _paymReference,
                    _bankTransactionType
        );

        // <GEERU>
        if (correspondenceEnabled)
        {
            return;
        }
        // </GEERU>

        this.createPaymentJournalLine(
                    offsetLedgerAccountType,
                    offsetLedgerAccountNum,
                    _currency,
                    -_Amount,
                    _date,
                    ExchangeRateHelper::exchRate(_currency, _date),
                    0,
                    false,
                    _transTxt,
                    _documentNum,
                    0,
                    _tenderTypeId,
                    LedgerJournalACType::Ledger,
                    0,
                    false,
                    '',
                    _paymReference,
                    _bankTransactionType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTenderedPaymentLines</Name>
				<Source><![CDATA[
    private void createTenderedPaymentLines(
        LedgerJournalACType     _accountType,
        LedgerDimensionAccount  _accountNum,
        CurrencyCode            _transactionCurrency,
        CurrencyCode            _postingCurrency,
        AmountCur               _amountCur,
        TransDate               _date,
        ExchRate                _exchRate,
        RecId                   _invoiceRecId = 0,
        boolean                 _settle = false,
        RetailTenderTypeId      _tenderTypeId = ''
        , LedgerJournalACType    _offsetAccountType = LedgerJournalACType::Ledger
        , LedgerDimensionAccount _offsetAccountNum = 0
        , DimensionDefault       _defaultDimension = 0
        , boolean                _prepayment = false
        , RetailCardTypeId       _cardTypeId = ''
    )
    {
        AmountCur                       lossGainAmountCur, roundedAmountCur;
        ExchRate                        axExchRate, axTransAgainstPostingExchRate;
        LedgerDimensionDefaultAccount   lossGainAccount;
        RetailStoreTable                storeTable;
        str                             paymReferenceTxt = '';
        str                             paymDescription = '';

        roundedAmountCur = CurrencyExchange::round(_amountCur, _postingCurrency);

        if (roundedAmountCur)
        {
            axExchRate = ExchangeRateHelper::exchRate(_postingCurrency, _date);

            axTransAgainstPostingExchRate = ExchangeRateHelper::getCrossRate_Static(Ledger::current(), _postingCurrency, _date)
                                            * ExchangeRateHelper::getCrossRateReciprocal_Static(Ledger::current(), _transactionCurrency, _date)
                                            / 100;

            if ((_transactionCurrency != _postingCurrency) &&
                (axTransAgainstPostingExchRate != _exchRate))
            {
                lossGainAmountCur = CurrencyExchange::round(roundedAmountCur * _exchRate / axTransAgainstPostingExchRate, _postingCurrency) - roundedAmountCur;

                if (lossGainAmountCur)
                {
                    lossGainAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                        _postingCurrency,
                        (roundedAmountCur < lossGainAmountCur) ? CurrencyGainLossAccountType::RealizedLoss : CurrencyGainLossAccountType::RealizedGain);

                    // create payment journal trans.
                    this.createPaymentJournalLine(
                            LedgerJournalACType::Ledger,
                            LedgerDimensionFacade::serviceCreateLedgerDimension(lossGainAccount, RetailStoreTenderTypeTable::find(RetailStoreTable::find(statementTable.storeId).RecId, _tenderTypeId).DefaultDimension),
                            _postingCurrency,
                            lossGainAmountCur,
                            _date,
                            axExchRate,
                            _invoiceRecId,
                            false,
                            '',
                            '',
                            // <GEERU>
                            _defaultDimension,
                            // </GEERU>
                            _tenderTypeId
                            // <GEERU>
                            , _offsetAccountType
                            , _offsetAccountNum
                            // </GEERU>
                    );
                }
            }

            if (_accountType == LedgerJournalACType::Bank)
            {
                storeTable = RetailStoreTable::find(statementTable.storeId);
                paymReferenceTxt = strFmt("@Retail:PaymentReferenceTxt", storeTable.StoreNumber);
                paymDescription = RetailStatementPaymentJournal::GetTenderTypeName(storeTable, _tenderTypeId, _cardTypeId, _transactionCurrency) + '. ' + storeTable.StoreNumber;
            }

            // create payment journal trans.
            this.createPaymentJournalLine(
                    _accountType,
                    _accountNum,
                    _postingCurrency,
                    roundedAmountCur,
                    _date,
                    axExchRate,
                    _invoiceRecId,
                    _settle,
                    '',
                    '',
                    // <GEERU>
                    _defaultDimension,
                    // </GEERU>
                    _tenderTypeId
                    // <GEERU>
                    , _offsetAccountType
                    , _offsetAccountNum
                    , _prepayment
                    // </GEERU>
                    , ''
                    , paymReferenceTxt
            );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustTransOpen</Name>
				<Source><![CDATA[
    private CustTransOpen getCustTransOpen(CustInvoiceJour _custInvoiceJour)
    {
        CustTrans custTrans;
        CustTransOpen custTransOpen;

        select custTrans
            where custTrans.Invoice == _custInvoiceJour.InvoiceId
                && custTrans.AccountNum == _custInvoiceJour.InvoiceAccount
                && custTrans.TransDate == _custInvoiceJour.InvoiceDate
                && custTrans.Voucher == _custInvoiceJour.LedgerVoucher;

        if (custTrans.rowCount() > 1)
        {
            RetailTracer::Error('Posting', 'RetailStatementPaymentJournal::getCustTransOpen()',
                strFmt("@RET_HF_261214:RetailEodStatementPaymentJournalCustTransError",
                _custInvoiceJour.InvoiceId,
                _custInvoiceJour.InvoiceAccount,
                _custInvoiceJour.InvoiceDate,
                _custInvoiceJour.LedgerVoucher));

            throw error(strFmt("@RET_HF_261214:RetailEodStatementPaymentJournalCustTransError",
                _custInvoiceJour.InvoiceId,
                _custInvoiceJour.InvoiceAccount,
                _custInvoiceJour.InvoiceDate,
                _custInvoiceJour.LedgerVoucher));
        }
        
        if (_custInvoiceJour.InvoiceId)
        {
            custTransOpen = CustTransOpen::findRefId(custTrans.RecId);
        }

        return custTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerOffsetAccount</Name>
				<Source><![CDATA[
    private container getLedgerOffsetAccount(
                RetailStoreId _storeId,
                RetailTenderTypeId _tenderTypeId,
                RetailCardTypeId _cardTypeId,
                DimensionDefault _paymentDimension)
    {
        LedgerJournalACType             offsetAccountType;
        DimensionDefault                offsetAccountDefaultDimension;
        LedgerDimensionDefaultAccount   offsetAccountNum;

        RetailStoreTenderTypeTable         storeTenderTypeTable;
        RetailStoreTenderTypeCardTable     storeTenderTypeCardTable;

        storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(_storeId).RecId, _tenderTypeId);

        switch (storeTenderTypeTable.function)
        {
            case RetailTenderFunction::Customer:
                break;

            case RetailTenderFunction::Card:
                if (_cardTypeId)
                {
                    storeTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(RetailStoreTable::find(_storeId).RecId, _tenderTypeId, _cardTypeId);
                    if (storeTenderTypeCardTable && storeTenderTypeCardTable.LedgerDimension)
                    {
                        offsetAccountType = (storeTenderTypeCardTable.accountType == RetailLedgerBank::Ledger) ? LedgerJournalACType::Ledger : LedgerJournalACType::Bank;
                        offsetAccountNum  = storeTenderTypeCardTable.LedgerDimension;
                        break;
                    }
                }
            default:
                offsetAccountType = this.ledgerBank2LedgerJournalACType(storeTenderTypeTable.accountType);
                offsetAccountNum  = storeTenderTypeTable.LedgerDimension;
                offsetAccountDefaultDimension = storeTenderTypeTable.DefaultDimension;
                break;
        }

        if (offsetAccountType == LedgerJournalACType::Ledger)
        {
            offsetAccountNum = LedgerDimensionFacade::serviceCreateLedgerDimension(offsetAccountNum, LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_paymentDimension, offsetAccountDefaultDimension));
        }

        return [offsetAccountType, offsetAccountNum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenCustTransactions</Name>
				<Source><![CDATA[
    private List getOpenCustTransactions(CustAccount _custAccount, DebCredProposal _balanceType = DebCredProposal::None)
    {
        List openTransactions = new List(Types::Record);
        CustTrans       custTrans;
        CustTransOpen   custTransOpen;
        ;

        // return open transactions for customer filtered by _balanceType parameter
        while select custTrans
            where custTrans.AccountNum == _custAccount
            exists join custTransOpen
                where custTransOpen.RefRecId == custTrans.RecId
        {
            if ((_balanceType == DebCredProposal::Debit && custTrans.remainAmountCur() > 0)
                || (_balanceType == DebCredProposal::Credit && custTrans.remainAmountCur() < 0)
                || (_balanceType == DebCredProposal::None))
            {
                openTransactions.addEnd(custTrans);
            }
        }

        return openTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerBank2LedgerJournalACType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts <c>RetailLedgerBank</c> enum value to <c>LedgerJournalACType</c> enum value.
    /// </summary>
    /// <param name="_ledgerBank">
    /// The <c>RetailLedgerBank</c> enum value.
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalACType</c> enum value.
    /// </returns>
    private LedgerJournalACType ledgerBank2LedgerJournalACType(RetailLedgerBank _ledgerBank)
    {
        return RetailStatementLedgerJournalHelper::ledgerBank2LedgerJournalACType(_ledgerBank);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the class <c>RetailStatementPaymentJournal</c> and builds the query with <c>LedgerJournalName</c> as datasource.
    /// </summary>
    /// <param name="_statementTable">
    /// The current instance of <c>RetailStatementTable</c>.
    /// </param>
    /// <param name="_journalType">
    /// The ledger journal type.
    /// </param>
    void new(RetailStatementTable _statementTable = null
            , LedgerJournalType _journalType = LedgerJournalType::CustPayment
    )
    {
        // Initialize RetailStatementTable
        statementTable = _statementTable;
        statementTableAccessor = RetailEodStatementConfigurationAccessor::construct(statementTable);

        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSource = query.addDataSource(tablenum(LedgerJournalName));
        QueryBuildRange         queryBuildRangeJournalType = queryBuildDataSource.addRange(fieldnum(LedgerJournalName, JournalType));
        QueryBuildRange         queryBuildRangeUserGroupId = queryBuildDataSource.addRange(fieldnum(LedgerJournalName, BlockUserGroupId));
        QueryRun                queryRun;
        // <GIN>;
        RetailStoretable        retailStoreTable;
        // </GIN>
        retailParameters = RetailParameters::find();
        // <GEERU>
        ledgerJournalType                = _journalType;
        countryRegion_W                  = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        countryRegion_RU                 = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        correspondenceEnabled            = countryRegion_W;

        if (countryRegion_W)
        {
            journalName = LedgerJournalName::find(
                ledgerJournalType == ledgerJournalType::Daily           ?
                    retailParameters.DefaultLedgerJournalName_RU :
                    retailParameters.DefaultCustPaymentJournalName_RU);

            rCashJournalName = LedgerJournalName::find(retailParameters.DefaultRCashJournalName);
            processGiftCardsAsPrepayments_RU = statementTableAccessor.isProcessGiftcardsAsPrepayments_RU();
        }
        else
        {
            RetailPrePaymentLedgerJournalNameId prePaymentLedgerJournalName = statementTableAccessor.getPrepaymentLedgerJournalName();

            // </GEERU>
            // Pick default payment journal name mentioned in Posting tab of retail parameters
            if (prePaymentLedgerJournalName)
            {
                journalName = LedgerJournalName::find(prePaymentLedgerJournalName);
            }
            else
            {
                queryBuildRangeJournalType.value(queryValue(LedgerJournalType::CustPayment));
                queryBuildRangeUserGroupId.value(UserGroupList::groupsForUser());

                queryRun = new QueryRun(query);
                if (queryRun.next())
                {
                    journalName = queryRun.getNo(1);
                }
            }
        // <GEERU>
        }
        // </GEERU>

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            isIndia                     = true;
            retailStoreTable            = RetailStoreTable::find(statementTable.storeId);
            logisticsLocationRecId      = InventLocation::getDefaultLogisticsLocation_IN(retailStoreTable.inventLocation, LogisticsLocationRoleType::Delivery).RecId;
            taxInformationRecId         = TaxInformation_IN::findDefaultbyLocation(logisticsLocationRecId).RecId;
        }
        // </GIN>

        // Get the number sequence for slip journal document
        paymJournalNumSeq = NumberSeq::newGetNum(LedgerParameters::numRefJournalNum());
        numSeq = NumberSeq::newGetNumFromId(RetailStatementVoucher::numberSequenceId(statementTable.storeId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the ledger journal trans records.
    /// </summary>
    /// <param name="_journalType">
    /// The journal type.
    /// </param>
    public void postLedgerJournal(
        LedgerJournalType _journalType = ledgerJournalType
    )
    {
        LedgerJournalTrans ledgerJournalTrans;

        LedgerJournalTable ledgerJournal2Post =
            // <GEERU>
            _journalType == LedgerJournalType::RCash ?
            rCashLedgerJournal :
            // </GEERU>
            ledgerJournal;

        if (ledgerJournal2Post)
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournal2Post.JournalNum;

            if (ledgerJournalTrans.RecId)
            {
                // Skip manual entry check for statement posting
                update_recordset ledgerJournalTrans
                    setting SkipBlockedForManualEntryCheck = NoYes::Yes
                    where ledgerJournalTrans.JournalNum == ledgerJournal2Post.JournalNum;

                LedgerJournalPost::postJournal(ledgerJournal2Post, NoYes::No, false, true, true);
            }
            else
            {
                ledgerJournal2Post.delete();
            }
        }
        // <GEERU>
        // clear journal variable after posting so that new journal will be created when createPaymentJounral method is called next time
        if (_journalType == LedgerJournalType::RCash)
        {
            rCashLedgerJournal = null;
        }
        else
        {
            // </GEERU>
            ledgerJournal = null;
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the payment journal records.
    /// </summary>
    public void postPaymentJournal()
    {
        ;
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postPaymentJournal');

        RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournal()', 'Financial posting start');

        // <GEERU>
        if (processGiftCardsAsPrepayments_RU)
        {
            this.postGiftCards_RU();
        }
        // </GEERU>

        this.postPaymentJournalForSales();

        // <GEERU>
        if (RetailParameters::find().AggregateCustPayments_RU)
        {
            this.postPaymentJournalForOthersAggregated_W();
        }
        else
        {
            // </GEERU>
            this.postPaymentJournalForOthers();
            // <GEERU>
        }
        // </GEERU>

        RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournal()', 'Financial posting end');

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postPaymentJournal');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentJournalForGiftCards_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gift card payments posting
    /// </summary>
    private void postPaymentJournalForGiftCards_RU()
    {
        RetailStatementCustUnblocker    custUnblocker = new RetailStatementCustUnblocker();
        RetailTransactionTable          transTable;
        RetailTransactionPaymentTrans   paymTrans;
        RecId                           channelRecId = RetailStoreTable::find(statementTable.storeId).RecId;

        while select businessDate, custAccount, statementId, store, channel, terminal, TransactionId
            from transTable
            order by businessDate, custAccount, store, terminal, TransactionId
            where   transTable.store        == statementTable.storeId
                &&  transTable.statementId  == statementTable.statementId
                &&  transTable.type         == RetailTransactionType::Sales
                join giftCardId, amountCur, currency, exchRate, DefaultDimension, tenderType
                    from paymTrans
                    where paymTrans.store           == transTable.store          &&
                        paymTrans.terminal          == transTable.terminal       &&
                        paymTrans.transactionId     == transTable.transactionId  &&
                        paymTrans.transactionStatus != RetailEntryStatus::Voided &&
                        paymTrans.giftCardId        != ''
        {
            custUnblocker.unblockCustomer(transTable.custAccount);

            giftCardPost_RU.createGiftCardJournalLines(
                paymTrans.giftCardId,
                transTable.custAccount,
                transTable.businessDate,
                paymTrans.currency,
                - paymTrans.amountCur,
                LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(
                    paymTrans.DefaultDimension,
                    RetailStoreTenderTypeTable::find(channelRecId, paymTrans.tenderType).DefaultDimension,
                    statementTable.DefaultDimension),
                transTable);

            this.addToRBOStatementVoucher(giftCardPost_RU.jourLineVoucher(), transTable.businessDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentJournalForOthers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post non-sales transaction payment journal,
    /// e.g. customer deposit, sales order, or sales invoice amount
    /// </summary>
    public void postPaymentJournalForOthers()
    {
        RetailTransactionTable          transTable;
        RetailTransactionPaymentTrans   payTransTable;

        AmountCur                       amountCurToPost, totalCreditAmountCur;
        RetailStatementCustUnblocker    custUnblocker = new RetailStatementCustUnblocker();

        LedgerJournalACType             accountType;
        LedgerDimensionAccount          accountNum;
        // <GEERU>
        LedgerDimensionAccount          offsetAccountNum;
        // </GEERU>

        while select transTable
            where   transTable.store        == statementTable.storeId
                &&  transTable.statementId  == statementTable.statementId
                &&  transTable.type         != RetailTransactionType::Logoff
                &&  transTable.type         != RetailTransactionType::Logon
                &&  (   transTable.type == RetailTransactionType::Payment
                    ||  transTable.salesInvoiceAmount
                    ||  transTable.salesOrderAmount)
        {
            // <GEERU>
            if (correspondenceEnabled)
            {
                offsetAccountNum = RetailStatementPaymentJournal::getNativeNonLedgerAccount(transTable.custAccount, enum2int(LedgerJournalACType::Cust));
            }
            // </GEERU>

            // Unblock the customer
            custUnblocker.unblockCustomer(transTable.custAccount);

            totalCreditAmountCur = this.postRoundingDifference(transTable
                                                              // <GEERU>
                                                              , LedgerJournalACType::Cust
                                                              , offsetAccountNum
                                                              // </GEERU>
            );

            while select sum(amountCur) from payTransTable
            group by tenderType, currency, exchRate, cardTypeId, DefaultDimension
            where  payTransTable.store == transTable.store
               &&  payTransTable.terminal == transTable.terminal
               &&  payTransTable.transactionId == transTable.transactionId
               &&  payTransTable.transactionStatus != RetailEntryStatus::Voided
            {
                if (countryRegion_W)
                {
                    [accountType, accountNum] = RetailStatementLedgerJournalHelper::getStoreTenderTypeAccount(
                                                                statementTable.storeId,
                                                                payTransTable.tenderType,
                                                                payTransTable.cardTypeId);
                }
                else
                {
                    [accountType, accountNum] = this.getLedgerOffsetAccount(
                                                                statementTable.storeId,
                                                                payTransTable.tenderType,
                                                                payTransTable.cardTypeId,
                                                                payTransTable.DefaultDimension);
                }

                amountCurToPost = payTransTable.amountCur;

                if (accountNum && amountCurToPost)
                {
                    this.createTenderedPaymentLines(
                                    accountType,
                                    accountNum,
                                    transTable.currency,
                                    payTransTable.currency,
                                    -amountCurToPost,
                                    transTable.businessDate,
                                    payTransTable.exchRate,
                                    0,
                                    false,
                                    payTransTable.tenderType
                                    // <GEERU>
                                    , LedgerJournalACType::Cust
                                    , offsetAccountNum
                                    , countryRegion_W ? payTransTable.DefaultDimension : 0
                                    , countryRegion_RU ? amountCurToPost > 0 : false
                                    // </GEERU>
                                    , payTransTable.cardTypeId
                    );

                    totalCreditAmountCur += CurrencyExchange::round(amountCurToPost * payTransTable.exchRate / 100, transTable.currency);
                }

                RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForOthers()',
                                   'Displaying field values of tendered payment line. AccountType = %1, AccountNum = %2, Transaction currency = %3, Posting currency = %4, Amount = %5, Trans date = %6, Exch rate = %7, statementId = %8, transactionId = %9',
                                   accountType, accountNum, transTable.currency, payTransTable.currency, -amountCurToPost, paytransTable.transDate, payTransTable.exchRate, payTransTable.statementId, payTransTable.transactionId);
            }

            if (transTable.salesInvoiceAmount + transTable.salesOrderAmount)
            {
                LedgerDimensionDefaultAccount prepaymentLedgerDimension = statementTableAccessor.getPrepaymentLedgerDimension();

                this.createPaymentJournalLine(LedgerJournalACType::Ledger,
                                              LedgerDimensionFacade::serviceCreateLedgerDimension(prepaymentLedgerDimension, transTable.DefaultDimension),
                                              transTable.currency,
                                              transTable.salesInvoiceAmount + transTable.salesOrderAmount,
                                              transTable.businessDate,
                                              ExchangeRateHelper::exchRate(transTable.currency, transTable.businessDate)
                                              , 0
                                              , false
                                              , ''
                                              , ''
                                              , 0
                                              , ''
                                              // <GEERU>
                                              , LedgerJournalACType::Cust
                                              , offsetAccountNum
                                              // </GEERU>
                );
                totalCreditAmountCur -= (transTable.salesInvoiceAmount + transTable.salesOrderAmount);
            }

            // <GEERU>
            if (!correspondenceEnabled)
            {
                // populate the RecId if it is not filled, for backward compatibility
                RecID currentInvoiceRecId;

                if (transTable.InvoiceRecId == 0 && transTable.invoiceId != '' && transTable.salesOrderId != '')
                {
                    currentInvoiceRecId = this.findCustInvoiceJourRecId(transTable.salesOrderId, transTable.invoiceId, transTable.businessDate);

                    RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForOthers()',
                               strFmt('CustInvoiceJour RecId is not populated on transactions matching criteria of Statement Id: %1, Sales Order ID:, Invoice Id: %2 %3. Using RecId: %4.',
                                      transTable.statementId,
                                      transTable.salesOrderId,
                                      transTable.invoiceId,
                                      currentInvoiceRecId));
                }
                else
                {
                    currentInvoiceRecId = transTable.InvoiceRecId;
                }

                // </GEERU>
                this.createPaymentJournalLine(LedgerJournalACType::Cust,
                                                RetailStatementPaymentJournal::getNativeNonLedgerAccount(transTable.custAccount, enum2int(LedgerJournalACType::Cust)),
                                                transTable.currency,
                                                totalCreditAmountCur,
                                                transTable.businessDate,
                                                ExchangeRateHelper::exchRate(transTable.currency, transTable.businessDate),
                                                currentInvoiceRecId,
                                                true);
                // <GEERU>
            }
            // </GEERU>
            RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForOthers()',
                               'Displaying field values of payment journal line. Account type = %1, Account num = %2, Currency = %3, Amount = %4, Trans date = %5, Exch rate = %6',
                                LedgerJournalACType::Cust, RetailStatementPaymentJournal::getNativeNonLedgerAccount(transTable.custAccount, enum2int(LedgerJournalACType::Cust)), transTable.currency, totalCreditAmountCur, transTable.businessDate, ExchangeRateHelper::exchRate(transTable.currency, transTable.transDate));

            // post the payment journal
            this.postLedgerJournal();
            // <GEERU>
            this.postLedgerJournal(LedgerJournalType::RCash);
            // </GEERU>
        }

        custUnblocker.restoreBlockedCustomers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentJournalForOthersAggregated_W</Name>
				<Source><![CDATA[
    private void postPaymentJournalForOthersAggregated_W()
    {
        RetailTransactionTable          transTable;
        RetailTransactionPaymentTrans   payTransTable;

        AmountCur                       amountCurToPost, totalCreditAmountCur;
        RetailStatementCustUnblocker    custUnblocker = new RetailStatementCustUnblocker();

        LedgerJournalACType             accountType;
        LedgerDimensionAccount          accountNum;
        LedgerDimensionAccount          offsetAccountNum;

        while select sum(grossAmount), sum(paymentAmount) from transTable
            group by businessDate, custAccount, currency
            where   transTable.store        == statementTable.storeId
                &&  transTable.statementId  == statementTable.statementId
                &&  transTable.type         != RetailTransactionType::Logoff
                &&  transTable.type         != RetailTransactionType::Logon
                &&  (   transTable.type == RetailTransactionType::Payment
                    ||  transTable.salesInvoiceAmount
                    ||  transTable.salesOrderAmount)
            join sum(amountCur) from payTransTable
                group by tenderType, currency, exchRate, cardTypeId, DefaultDimension
                where  payTransTable.store == transTable.store
                   &&  payTransTable.terminal == transTable.terminal
                   &&  payTransTable.transactionId == transTable.transactionId
                   &&  payTransTable.transactionStatus != RetailEntryStatus::Voided
        {
            offsetAccountNum = RetailStatementPaymentJournal::getNativeNonLedgerAccount(transTable.custAccount, enum2int(LedgerJournalACType::Cust));

            // Unblock the customer
            custUnblocker.unblockCustomer(transTable.custAccount);

            totalCreditAmountCur = this.postRoundingDifference(transTable, LedgerJournalACType::Cust, offsetAccountNum);

            [accountType, accountNum] = RetailStatementLedgerJournalHelper::getStoreTenderTypeAccount(
                                                                statementTable.storeId,
                                                                payTransTable.tenderType,
                                                                payTransTable.cardTypeId);

            amountCurToPost = payTransTable.amountCur;

            if (accountNum && amountCurToPost)
            {
                this.createTenderedPaymentLines(
                                accountType,
                                accountNum,
                                transTable.currency,
                                payTransTable.currency,
                                -amountCurToPost,
                                transTable.businessDate,
                                payTransTable.exchRate,
                                0,
                                false,
                                payTransTable.tenderType,
                                LedgerJournalACType::Cust,
                                offsetAccountNum,
                                payTransTable.DefaultDimension,
                                countryRegion_RU ? amountCurToPost > 0 : false);

                totalCreditAmountCur += CurrencyExchange::round(amountCurToPost * payTransTable.exchRate / 100, transTable.currency);
            }

            RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForOthersAggregated_W()',
                                'Displaying field values of tendered payment line. AccountType = %1, AccountNum = %2, Transaction currency = %3, Transaction date = %4, Posting currency = %5, Amount = %6, Exch rate = %7, statementId = %8',
                                accountType, accountNum, transTable.currency, transTable.businessDate, payTransTable.currency, -amountCurToPost, payTransTable.exchRate, payTransTable.statementId);

            RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForOthersAggregated_W()',
                               'Displaying field values of payment journal line. Account type = %1, Account num = %2, Currency = %3, Amount = %4, Trans date = %5',
                                LedgerJournalACType::Cust, offsetAccountNum, transTable.currency, totalCreditAmountCur, transTable.businessDate);
        }

        // post the payment journal
        this.postLedgerJournal();
        this.postLedgerJournal(LedgerJournalType::RCash);

        custUnblocker.restoreBlockedCustomers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentJournalForSales</Name>
				<Source><![CDATA[
    private void postPaymentJournalForSales()
    {
        RetailTransactionTable             transTable, transTable2;
        RetailTransactionPaymentTrans      payTransTable;

        AmountCur                       amountCurToPost, totalCreditAmountCur, totalRoundAmountCur;
        RetailStatementCustUnblocker       custUnblocker = new RetailStatementCustUnblocker();

        LedgerJournalACType             accountType;
        LedgerDimensionAccount          accountNum;
        LedgerDimensionAccount          offsetAccountNum;

        RecId                           currentInvoiceRecId;
        RecId                           lastInvoiceRecId;
        Container                       postParams;
        boolean                         toSettle;

        CustTable                       custTable;
        CustVendAC                      invoiceAccount;

        void postCreditLedgerJournalLine()
        {
            CurrencyCode                    currency;
            TransDate                       transDate;
            CustAccount                     custAccountNum;
            DimensionDefault                paymentDefaulDimention;

            // <GEERU>
            if (correspondenceEnabled)
            {
                return;
            }
            // </GEERU>
            if (totalCreditAmountCur)
            {
                [custAccountNum, currency, transDate, paymentDefaulDimention] = postParams;

                RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForSales::PostCreditLegerJournalLine()',
                                   'Payment journal credit line: Amount=%1, Account=%2, Currency=%3',
                                   TotalCreditAmountCur, custAccountNum, currency);

                this.createPaymentJournalLine(LedgerJournalACType::Cust,
                                              RetailStatementPaymentJournal::getNativeNonLedgerAccount(custAccountNum, enum2int(LedgerJournalACType::Cust)),
                                              currency,
                                              totalCreditAmountCur,
                                              transDate,
                                              ExchangeRateHelper::exchRate(currency, transDate),
                                              toSettle ? lastInvoiceRecId : 0,
                                              toSettle,
                                              '',
                                              '',
                                              LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(CustTable::find(custAccountNum).DefaultDimension, paymentDefaulDimention));

                // post the payment journal
                this.postLedgerJournal();
            }
        }
        ;

        totalCreditAmountCur = 0;
        lastInvoiceRecId = 0;

        while select sum(grossAmount), sum(paymentAmount) from transTable
            group by store, businessDate, custAccount, currency, exchRate, invoiceId, InvoiceRecId, salesOrderId
            where   transTable.store        == statementTable.storeId
                &&  transTable.statementId  == statementTable.statementId
                &&  transTable.type         != RetailTransactionType::Logoff
                &&  transTable.type         != RetailTransactionType::Logon
                &&  transTable.type         != RetailTransactionType::Payment
                &&  transTable.type         != RetailTransactionType::CustomerOrder
                &&  transTable.type         != RetailTransactionType::AsyncCustomerOrder
                &&  transTable.type         != RetailTransactionType::PendingSalesOrder
                &&  transTable.invoiceId
                &&  !transTable.incomeExpenseAmount
                &&  !transTable.salesInvoiceAmount
                &&  !transTable.salesOrderAmount
            join sum(amountCur) from payTransTable
            group by tenderType, currency, exchRate, cardTypeId, DefaultDimension
            where  payTransTable.store == transTable.store
               &&  payTransTable.terminal == transTable.terminal
               &&  payTransTable.transactionId == transTable.transactionId
               &&  payTransTable.transactionStatus != RetailEntryStatus::Voided
               // <GEERU>
               && (!processGiftCardsAsPrepayments_RU || !payTransTable.giftCardId)
               // </GEERU>
        {
            // populate the RecId if it is not filled, for backward compatibility
            if (transTable.InvoiceRecId == 0 && transTable.invoiceId != '' && transTable.salesOrderId != '')
            {
                currentInvoiceRecId = this.findCustInvoiceJourRecId(transTable.salesOrderId, transTable.invoiceId, transTable.businessDate);

                RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForSales()',
                               strFmt('CustInvoiceJour RecId is not populated on transactions matching criteria of Statement Id: %1, Sales Order ID:, Invoice Id: %2 %3. Using RecId: %4.',
                                      transTable.statementId,
                                      transTable.salesOrderId,
                                      transTable.invoiceId,
                                      currentInvoiceRecId));
            }
            else
            {
                currentInvoiceRecId = transTable.InvoiceRecId;
            }

            if (lastInvoiceRecId != currentInvoiceRecId)
            {
                postCreditLedgerJournalLine();

                CustAccount _custAccount = transTable.custAccount;
                if (!_custAccount)
                {
                    RetailStoreTable storeTable = RetailStoreTable::find(transTable.store);
                    _custAccount = storeTable.DefaultCustAccount;
                }

                // Unblock the customer
                custUnblocker.unblockCustomer(_custAccount);

                select sum(grossAmount), sum(paymentAmount) from transTable2
                    group by store, businessDate, custAccount, currency, exchRate, invoiceId
                    where   transTable2.store       == statementTable.storeId
                        &&  transTable2.statementId == statementTable.statementId
                        &&  transTable2.invoiceId   == transTable.invoiceId
                        &&  transTable2.salesOrderId == transTable.salesOrderId
                        &&  (transTable2.InvoiceRecId == transTable.InvoiceRecId
                            || transTable2.InvoiceRecId == 0)
                        &&  transTable2.type        != RetailTransactionType::Logoff
                        &&  transTable2.type        != RetailTransactionType::Logon
                        &&  transTable2.type        != RetailTransactionType::Payment
                        &&  transTable2.type        != RetailTransactionType::CustomerOrder
                        &&  transTable.type         != RetailTransactionType::AsyncCustomerOrder
                        &&  transTable2.type        != RetailTransactionType::PendingSalesOrder
                        &&  !transTable2.incomeExpenseAmount
                        &&  !transTable2.salesInvoiceAmount
                        &&  !transTable2.salesOrderAmount;

                totalRoundAmountCur = this.postRoundingDifference(transTable2
                                                                  // <GEERU>
                                                                  , LedgerJournalACType::Cust
                                                                  , offsetAccountNum
                                                                  // </GEERU>
                );

                custTable = CustTable::find(_custAccount);
                if (custTable.InvoiceAccount)
                {
                    invoiceAccount = custTable.InvoiceAccount;
                }
                else
                {
                    invoiceAccount = custTable.AccountNum;
                }

                // <GEERU>
                if (correspondenceEnabled)
                {
                    offsetAccountNum = RetailStatementPaymentJournal::getNativeNonLedgerAccount(invoiceAccount, enum2int(LedgerJournalACType::Cust));
                }
                // </GEERU>

                postParams = [invoiceAccount, transTable.currency, transTable.businessDate, payTransTable.DefaultDimension];

                toSettle = true;
                totalCreditAmountCur = totalRoundAmountCur;
                lastInvoiceRecId = currentInvoiceRecId;
            }

            RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForSales()',
                               'Prepare one payment journal line from payment trans: Tender type=%1, Card ID=%2, DefaultDemension=%3',
                               payTransTable.tenderType, payTransTable.cardTypeId, payTransTable.DefaultDimension);

            [accountType, accountNum] = this.getLedgerOffsetAccount(
                                                        statementTable.storeId,
                                                        payTransTable.tenderType,
                                                        payTransTable.cardTypeId,
                                                        payTransTable.DefaultDimension);

            RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForSales()',
                               'Retrieved account for tender type: Account Number=%1, Account Type=%2',
                               accountNum, accountType);

            amountCurToPost = payTransTable.amountCur;

            if (accountNum && amountCurToPost)
            {
                RetailAutoSettle autoSettle = statementTableAccessor.isAutoSettle();

                this.createTenderedPaymentLines(
                                accountType,
                                accountNum,
                                transTable.currency,
                                payTransTable.currency,
                                -amountCurToPost,
                                transTable.businessDate,
                                payTransTable.exchRate,
                                // <GEERU>
                                countryRegion_W && autoSettle ?
                                    currentInvoiceRecId :
                                // </GEERU>
                                0,
                                // <GEERU>
                                countryRegion_W ?
                                    transTable.invoiceId != '' && autoSettle :
                                // </GEERU>
                                false,
                                payTransTable.tenderType
                                // <GEERU>
                                , LedgerJournalACType::Cust
                                , offsetAccountNum
                                , countryRegion_W ? payTransTable.DefaultDimension : 0
                                // </GEERU>
                                , false // Prepayment
                                , payTransTable.cardTypeId
                );

                totalCreditAmountCur += CurrencyExchange::round(amountCurToPost * payTransTable.exchRate / 100, transTable.currency);

                RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForSales()',
                                   'Displaying field values of tendered payment lines. AccountType = %1, AccountNum = %2, Transaction currency = %3, Posting currency = %4, Amount = %5, Trans date = %6, Exch rate = %7, statementId = %8, transactionId = %9',
                                   accountType, accountNum, transTable.currency, payTransTable.currency, -amountCurToPost, paytransTable.transDate, payTransTable.exchRate, payTransTable.statementId, payTransTable.transactionId);
            }

            if (!accountNum &&
                RetailStoreTenderTypeTable::find(RetailStoreTable::find(statementTable.storeId).RecId, payTransTable.tenderType).function != RetailTenderFunction::Customer)
            {
                RetailTracer::Error('Posting', 'RetailStatementPaymentJournal::postPaymentJournalForSales()',
                                    "@RET260543",
                                    RetailTenderTypeTable::find(payTransTable.tenderType).name, statementTable.storeId);
                throw error(strfmt("@RET260543", RetailTenderTypeTable::find(payTransTable.tenderType).name, statementTable.storeId));
            }
        }

        // post the payment journal for the last time
        postCreditLedgerJournalLine();
        // <GEERU>
        if (correspondenceEnabled)
        {
            // post the payment journals
            this.postLedgerJournal();
            this.postLedgerJournal(ledgerJournalType::RCash);
        }
        // </GEERU>

        custUnblocker.restoreBlockedCustomers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymJournalForGiftCardEmptySales_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Payment posting for transactions containing only add to gift card operations
    /// </summary>
    private void postPaymJournalForGiftCardEmptySales_RU()
    {
        RetailTransactionTable          transTable;
        RetailTransactionPaymentTrans   paymTrans;

        RetailStatementCustUnblocker    custUnblocker = new RetailStatementCustUnblocker();

        CustTable                       custTable;

        Query                           qu = new Query();
        QueryBuildDataSource            qbds, qbds_paym, qbds_sales;
        QueryRun                        qrun;

        qbds = qu.addDataSource(tableNum(RetailTransactionTable));

        qbds.addGroupByField(fieldNum(RetailTransactionTable, store));
        qbds.addGroupByField(fieldNum(RetailTransactionTable, businessDate));
        qbds.addGroupByField(fieldNum(RetailTransactionTable, custAccount));
        qbds.addGroupByField(fieldNum(RetailTransactionTable, currency));
        qbds.addGroupByField(fieldNum(RetailTransactionTable, exchRate));

        boolean aggregateBeforePosting = statementTableAccessor.isAggregateBeforePosting();
        if (!aggregateBeforePosting)
        {
            qbds.addGroupByField(fieldNum(RetailTransactionTable, terminal));
            qbds.addGroupByField(fieldNum(RetailTransactionTable, transactionId));
        }

        qbds.addRange(fieldNum(RetailTransactionTable, statementId)).value(statementTable.statementId);
        qbds.addRange(fieldNum(RetailTransactionTable, type)).value(queryValue(RetailTransactionType::Sales));
        qbds.addRange(fieldNum(RetailTransactionTable, invoiceId)).value(SysQuery::valueEmptyString());
        qbds.addRange(fieldNum(RetailTransactionTable, incomeExpenseAmount)).value(queryValue(0));
        qbds.addRange(fieldNum(RetailTransactionTable, salesInvoiceAmount)).value(queryValue(0));
        qbds.addRange(fieldNum(RetailTransactionTable, salesOrderAmount)).value(queryValue(0));

        qbds_paym = qbds.addDataSource(tableNum(RetailTransactionPaymentTrans));
        qbds_paym.joinMode(JoinMode::InnerJoin);
        qbds_paym.fetchMode(QueryFetchMode::One2One);

        qbds_paym.addLink(fieldNum(RetailTransactionTable, store), fieldNum(RetailTransactionPaymentTrans, store));
        qbds_paym.addLink(fieldNum(RetailTransactionTable, terminal), fieldNum(RetailTransactionPaymentTrans, terminal));
        qbds_paym.addLink(fieldNum(RetailTransactionTable, transactionId), fieldNum(RetailTransactionPaymentTrans, transactionId));

        qbds_paym.addSelectionField(fieldNum(RetailTransactionPaymentTrans, amountCur), SelectionField::Sum);

        qbds_paym.addGroupByField(fieldNum(RetailTransactionPaymentTrans, tenderType));
        qbds_paym.addGroupByField(fieldNum(RetailTransactionPaymentTrans, currency));
        qbds_paym.addGroupByField(fieldNum(RetailTransactionPaymentTrans, exchRate));
        qbds_paym.addGroupByField(fieldNum(RetailTransactionPaymentTrans, cardTypeId));
        qbds_paym.addGroupByField(fieldNum(RetailTransactionPaymentTrans, DefaultDimension));

        qbds_paym.addRange(fieldNum(RetailTransactionPaymentTrans, transactionStatus)).value(SysQuery::valueNot(RetailEntryStatus::Voided));
        qbds_paym.addRange(fieldNum(RetailTransactionPaymentTrans, giftCardId)).value(SysQuery::valueEmptyString());

        qbds_sales = qbds.addDataSource(tableNum(RetailTransactionSalesTrans));
        qbds_sales.joinMode(JoinMode::ExistsJoin);

        qbds_sales.addSelectionField(fieldNum(RetailTransactionSalesTrans, TableId));

        qbds_sales.addLink(fieldNum(RetailTransactionTable, store), fieldNum(RetailTransactionSalesTrans, store));
        qbds_sales.addLink(fieldNum(RetailTransactionTable, terminal), fieldNum(RetailTransactionSalesTrans, terminalId));
        qbds_sales.addLink(fieldNum(RetailTransactionTable, transactionId), fieldNum(RetailTransactionSalesTrans, transactionId));

        qbds_sales.addRange(fieldNum(RetailTransactionSalesTrans, transactionStatus)).value(SysQuery::valueNot(RetailEntryStatus::Voided));
        qbds_sales.addRange(fieldNum(RetailTransactionSalesTrans, giftcard)).value(queryValue(NoYes::Yes));
        qbds_sales.addRange(fieldNum(RetailTransactionSalesTrans, SkipSalesLine_RU)).value(queryValue(NoYes::Yes));

        qrun = new QueryRun(qu);
        while (qrun.next())
        {
            transTable = qrun.get(tableNum(RetailTransactionTable));
            paymTrans = qrun.get(tableNum(RetailTransactionPaymentTrans));

            if (custTable.AccountNum != transTable.custAccount)
            {
                custTable = CustTable::find(transTable.custAccount);

                // Unblock the customer
                custUnblocker.unblockCustomer(transTable.custAccount);
            }

            this.createGiftCardEmptySaleJourLine_RU(transTable, paymTrans, custTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReplenishmentJournalForGiftCards_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gift card issue and replenishment posting.
    /// </summary>
    private void postReplenishmentJournalForGiftCards_RU()
    {
        RetailStatementCustUnblocker    custUnblocker = new RetailStatementCustUnblocker();
        RetailTransactionTable          transTable;
        RetailTransactionSalesTrans     salesTrans;

        while select store, terminal, transactionId, businessDate,
                     custAccount, currency, exchRate, invoiceId
            from transTable
            order by store, terminal, TransactionId
            where   transTable.store        == statementTable.storeId
                &&  transTable.statementId  == statementTable.statementId
                &&  transTable.type         == RetailTransactionType::Sales
                join price, currency, comment, channel, store, terminalId, transactionId, lineNum, DefaultDimension, RecId from salesTrans
                where salesTrans.store             == transTable.store          &&
                      salesTrans.terminalId        == transTable.terminal       &&
                      salesTrans.transactionId     == transTable.transactionId  &&
                      salesTrans.transactionStatus != RetailEntryStatus::Voided &&
                      salesTrans.giftcard          == true
        {
            custUnblocker.unblockCustomer(transTable.custAccount);

            giftCardPost_RU.createGiftCardJournalLines(
                salesTrans.comment,
                transTable.custAccount,
                transTable.businessDate,
                salesTrans.currency,
                salesTrans.price,
                LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(salesTrans.DefaultDimension, statementTable.DefaultDimension),
                transTable,
                RetailStatementPaymentJournal::getSalesTransTaxAmountsMap_RU(salesTrans));

            this.addToRBOStatementVoucher(giftCardPost_RU.jourLineVoucher(), transTable.businessDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRoundingDifference</Name>
				<Source><![CDATA[
    private AmountCur postRoundingDifference(RetailTransactionTable _transTable
                                             , LedgerJournalACType     _offsetAccountType = LedgerJournalACType::Ledger
                                             , LedgerDimensionAccount  _offsetAccountNum = 0
    )
    {
        AmountCur           totalRoundAmountCur;
        RetailStoreTable       storeTable = RetailStoreTable::find(statementTable.storeId);
        ;

        totalRoundAmountCur = -(_transTable.grossAmount + _transTable.paymentAmount);
        if (totalRoundAmountCur)
        {
            if (!storeTable.RoundingAccountLedgerDimension)
            {
                throw error(strfmt("@RET4158", storeTable.StoreNumber));
            }

            if (storeTable.MaxRoundingAmount && (abs(totalRoundAmountCur) > storeTable.MaxRoundingAmount))
            {
                throw error(strfmt("@RET4159", totalRoundAmountCur, storeTable.MaxRoundingAmount, storeTable.StoreNumber));
            }

            this.createTenderedPaymentLines(LedgerJournalACType::Ledger,
                                          LedgerDimensionFacade::serviceCreateLedgerDimension(storeTable.RoundingAccountLedgerDimension, storeTable.DefaultDimension),
                                          _transTable.currency,
                                          _transTable.currency,
                                          -totalRoundAmountCur,
                                          _transTable.businessDate,
                                          _transTable.exchRate
                                          , 0
                                          , false
                                          , ''
                                          // <GEERU>
                                          , _offsetAccountType
                                          , _offsetAccountNum
                                          // </GEERU>
            );

            RetailTracer::Info('Posting', 'RetailStatementPaymentJournal::postRoundingDifference()',
                               'Displaying field values of payment journal line for Rounding difference. Account type = %1, Account num = %2, Transaction currency = %3, Posting currency = %4, Amount = %5, Trans date = %6, Exch rate = %7',
                               LedgerJournalACType::Cust, LedgerDimensionFacade::serviceCreateLedgerDimension(storeTable.RoundingAccountLedgerDimension, storeTable.DefaultDimension), _transTable.currency, _transTable.currency, -totalRoundAmountCur, _transTable.businessDate, _transTable.exchRate);
        }

        return totalRoundAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentLineMark</Name>
				<Source><![CDATA[
    private void setPaymentLineMark(LedgerJournalTrans _ledgerJournalTrans, NoYes _shouldMark, CustTransOpen _custTransOpen)
    {
        CustVendOpenTransManager manager;

        if (_custTransOpen)
        {
            // mark/unmark this invoice's open customer transaction
            //  for settlement against the ledger journal payment line
            manager = CustVendOpenTransManager::construct(_ledgerJournalTrans);
            if (!manager.getTransMarkedByOtherSpec(_custTransOpen))
            {
                manager.updateTransMarked(_custTransOpen, _shouldMark);
                // full settlement set
                manager.updateFullSettlement(_custTransOpen, NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNativeNonLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the combination for the specified account.
    /// </summary>
    /// <param name="_account">
    ///    The non-ledger account.
    /// </param>
    /// <param name="_accountType">
    ///    The enumeration value.
    /// </param>
    /// <param name="_enumType">
    ///    The <c>enumid</c> value of the enumeration value.
    /// </param>
    /// <param name="_custVend">
    ///    The <c>ModuleInventCustVend</c> type.
    /// </param>
    /// <returns>
    ///    The record ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    private static recId getNativeNonLedgerAccount(
        LedgerJournalAC _account,
        int _accountType,
        enumId _enumType = enumnum(LedgerJournalACType),
        ModuleInventCustVend _custVend = ModuleInventCustVend::Cust)
    {
        container                   cachedResult;
        container                   cacheKey;

        cacheKey = [funcname() + ':' + curext(), _account, _accountType, _enumType, _custVend];

        cachedResult = DimensionCache::getValue(
            DimensionCacheScope::DimensionConversion,
            cacheKey);

        if (cachedResult == connull())
        {
            // shortcut out if account is empty
            if (!_account)
            {
                cachedResult = [0];
            }
            else
            {
                cachedResult = [LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumberEnumModule(_account, _accountType, _enumType, _custVend)];
            }

            DimensionCache::insertValue(
                DimensionCacheScope::DimensionConversion,
                cacheKey,
                cachedResult);
        }

        return conpeek(cachedResult, 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGiftCards_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts gift card related POS operations.
    /// </summary>
    private void postGiftCards_RU()
    {
        giftCardPost_RU = RetailGiftCardPost_RU::newFromRetailStatement(statementTable);

        this.postReplenishmentJournalForGiftCards_RU();
        this.postPaymentJournalForGiftCards_RU();
        this.postPaymJournalForGiftCardEmptySales_RU();

        giftCardPost_RU.post();

        this.updateGiftCardJournal_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGiftCardJournal_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates gift card journal.
    /// </summary>
    private void updateGiftCardJournal_RU()
    {
        LedgerJournalTable giftCardJournal;
        LedgerJournalTable storeCompanyJournal;

        giftCardJournal = giftCardPost_RU.giftCardJournal();

        if (!giftCardJournal)
        {
            return;
        }

        if (giftCardJournal.dataAreaId == curext())
        {
            giftCardJournal.reread();
            giftCardJournal.RetailStatementId = statementTable.statementId;
            giftCardJournal.Update();
        }

        select firstonly forupdate storeCompanyJournal
            where storeCompanyJournal.OriginalCompany      == retailParameters.GiftCardCompany &&
                    storeCompanyJournal.OriginalJournalNum == giftCardJournal.JournalNum;

        if (storeCompanyJournal)
        {
            storeCompanyJournal.RetailStatementId = statementTable.statementId;
            storeCompanyJournal.Update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTransTaxAmountsMap_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets packed map of retail sales transaction tax amounts.
    /// </summary>
    /// <param name="_salesTrans">
    /// The retail sales transaction.
    /// </param>
    /// <returns>
    /// Packed map of retail sales transaction tax amounts.
    /// </returns>
    private static container getSalesTransTaxAmountsMap_RU(RetailTransactionSalesTrans _salesTrans)
    {
        RetailTransactionTaxTrans   taxTrans;
        Map                         taxAmounts = new Map(Types::String, Types::Real);

        while select TaxCode, sum(Amount) from taxTrans
            group by TaxCode
            where taxTrans.StoreId       == _salesTrans.store          &&
                  taxTrans.TerminalId    == _salesTrans.terminalId     &&
                  taxTrans.TransactionId == _salesTrans.transactionId  &&
                  taxTrans.SaleLineNum   == _salesTrans.lineNum
        {
            taxAmounts.insert(taxTrans.TaxCode, - taxTrans.Amount);
        }

        return taxAmounts.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustInvoiceJourRecId</Name>
				<Source><![CDATA[
    private RecId findCustInvoiceJourRecId(
        SalesIdBase _originalSalesId,
        InvoiceId _invoiceId,
        TransDate _invoiceDate)
    {
        CustInvoiceJour custInvoiceJour = RetailStatementCustomerInvoiceHelper::findInvoiceFromOriginalSalesIdInvoiceIdInvoiceDate(_originalSalesId, _invoiceId, _invoiceDate);
        
        return custInvoiceJour.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetTenderTypeName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tender type name.
    /// </summary>
    /// <param name="_storeTable">
    /// The Retail store record.
    /// </param>
    /// <param name="_tenderTypeId">
    /// The tender type Id.
    /// </param>
    /// <param name="_cardTypeId">
    /// Card Id if the tender type is 'Cards'. Optional.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code. Optional.
    /// </param>
    /// <returns>
    /// The name of tender type card; otherwise empty string.
    /// </returns>
    public static str GetTenderTypeName(RetailStoreTable _storeTable,
                                RetailTenderTypeId _tenderTypeId,
                                RetailCardTypeId _cardTypeId = '',
                                CurrencyCode _currencyCode = '')

    {
        RetailStoreTenderTypeTable      tenderTypeTable;
        RetailStoreTenderTypeCardTable tenderTypeCardTable;
        RetailTenderTypeCardTable tenderCardTable;
        str ret;

        tenderTypeTable = RetailStoreTenderTypeTable::find(_storeTable.RecId, _tenderTypeId);
        if (tenderTypeTable)
        {
            ret = tenderTypeTable.Name;
        }
        else
        {
            ret = "@RET4041";
        }

        if (_cardTypeId)
        {
            tenderTypeCardTable = RetailStoreTenderTypeCardTable::find(_storeTable.RecId, _tenderTypeId, _cardTypeId);
            if (tenderTypeCardTable)
            {
                if (tenderTypeCardTable.Name)
                {
                    ret += ', ' + tenderTypeCardTable.Name;
                }
                else
                {
                    tenderCardTable = RetailTenderTypeCardTable::find(tenderTypeCardTable.cardTypeId);
                    if (tenderCardTable)
                    {
                        ret += ', ' + tenderCardTable.name;
                    }
                    else
                    {
                        ret += ', ' + "@RET4040";
                    }
                }
            }
            else
            {
                ret += ', ' + "@RET4040";
            }
        }

        if (_currencyCode)
        {
            ret += ', ' + _currencyCode;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>