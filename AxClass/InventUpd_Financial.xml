<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpd_Financial</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventUpd_Financial</c> class updates the inventory transaction to purchased for purchase
///    orders or to sold for sales order updates.
/// </summary>
/// <remarks>
///    The <c>InventUpd_Financial</c> class is used when updating the inventory financial. Financial
///    updates in Microsoft Dynamics AX occur when an invoice is posted.See the <see
///    cref="PurchInvoiceJournalPost.postInventory Method" /> for an example of how this class is used.
///    cref="PurchFormLetter_Invoice.updateInventory Method" /> for an example of how this class is used.
/// </remarks>
public class InventUpd_Financial extends InventUpdate
{
    // new parameters

    LedgerVoucher               ledgerVoucher;
    InvoiceId                   invoiceNum;
    AmountCur                   costAmountCur;
    InventQty                   financial;
    InventQty                   remainPhysical;
    UnitQty                     financialUnit;
    UnitQty                     remainPhysicalUnit;
    boolean                     autoLossProfit;
    CurrencyCode                currencyCode;
    ExchRate                    exchRate;
    ExchrateSecondary           exchrateSecondary;
    ExchRatesTriangulation      exchRatesTriangulation;
    CostPricePcsMaxValue        receiptCostPricePcsMax;
    boolean                     skipCWAutoAdjust;

    // internal init

    InventQty                   physical;
    UnitQty                     physicalUnit;
    Integer                     returnMode;
    NoYes                       invoiceReturn;

    // update result 

    InventQty                   updPhysical;
    UnitQty                     updPhysicalUnit;

    InventQty                   updFinancial;
    UnitQty                     updFinancialUnit;

    CostAmount                  updCostAmountLedger;
    CostAmount                  updOperationsAmountLedger;
    // <GEERU>
    AmountCur                   costAmountCurSecCur;

    CostAmount                  updOperationsAmountSecCurLedger;
    CostAmount                  updCostAmountSecCurLedger;
    CostAmount                  updCostAmountInventSecCur;

    InventQty                   remainBeforePhysical;
    UnitQty                     remainBeforePhysicalUnit;
    TransDate                   datePhysicalMaxValue_RU;
    // </GEERU>

    CostAmount                  updCostAmountInvent;
    CostAmount                  updCostAmountPhysical;

    CostAmount                  updPhysicalAmountLedger;
    AmountMSTPhysicalRevenue    updPhysicalRevenueAmountLedger;

    VoucherPhysical             voucherPhysical;
    PackingSlipId               packingSlipId;
    List                        packingSlipList;
    ProjTransDate               projTransDate;

    InventCostOnhandCache       inventCostOnhandCache;

    //inventDim selection criteria
    InventDim                   inventDimCriteria;
    InventDimParm               inventDimParmCriteria;

    PdsCWInventQty              cwFinancial;
    PdsCWInventQty              cwPhysical;
    PdsCWInventQty              cwUpdFinancial;
    PdsCWInventQty              cwRemainPhysical;
    PdsCWInventQty              cwUpdPhysical;
    InventTransOriginId         markingRefInventTransOrigin;
    // <GIN>
    TaxAmountCur                customsLoadOnInventoryMST;
    TaxAmountCur                customsLoadOnInventory;
    InventQty                   updateParmUpdate;
    boolean                     stockTransferScrapQty;

    // </GIN>
    // <GIN><GEERU>
    #ISOCountryRegionCodes
    // </GEERU></GIN>

    boolean                     adjustWMSLocationLoad;

    boolean                     pdsUpdatePhysicalOnly;
    Common                      financialJournalLine;

    CostAmount                  backDateCostAmountAdjustmentSecCur_RU;
    CostAmount                  backDateCostAmountAdjustment;

    private RefRecId            packingSlipRecId;

    private Voucher             transferOrderVoucherMatched;

    private static boolean needAssignNullToTableBuffer = InventUpdateAssignNullToBufferFromListFlight::instance().isEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>backDateCostAmountAdjustment</Name>
				<Source><![CDATA[
    public CostAmount backDateCostAmountAdjustment(CostAmount _costAmount = backDateCostAmountAdjustment)
    {
        backDateCostAmountAdjustment = _costAmount;
        return backDateCostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>backDateCostAmountAdjustmentSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount backDateCostAmountAdjustmentSecCur_RU(CostAmount _costAmount = backDateCostAmountAdjustmentSecCur_RU)
    {
        backDateCostAmountAdjustmentSecCur_RU = _costAmount;
        return backDateCostAmountAdjustmentSecCur_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a list of <c>InventTrans</c> records to be updated financially.
    /// </summary>
    /// <param name="_query">
    /// A query of candidate <c>InventTrans</c> records.
    /// </param>
    /// <returns>
    /// A list of <c>InventTrans</c> records to be updated financially.
    /// </returns>
    /// <remarks>
    /// If late packing slip match is being utilized, this list is ordered in the same order as the packing slips were selected.
    /// </remarks>
    protected List buildInventTransList(Query _query)
    {
        Map                     inventTransReorder;
        List                    inventTransList = new List(Types::Record);
        InventTransList         inventTransListForVoucher;

        QueryRun queryRun       = new QueryRun(_query);

        if (this.parmPackingSlipList() && !this.parmPackingSlipList().empty())
        {
            inventTransReorder = new Map(Types::Container, Types::Class); // key = [PackingSlipId, VoucherPhysical], value = List of InventTrans
        }

        while (queryRun.next())
        {
            InventTrans inventTrans = queryRun.get(tableNum(InventTrans));

            if (inventTransReorder && inventTrans.PackingSlipId)
            {
                if (inventTransReorder.exists([inventTrans.PackingSlipId, inventTrans.VoucherPhysical]))
                {
                    inventTransListForVoucher = inventTransReorder.lookup([inventTrans.PackingSlipId, inventTrans.VoucherPhysical]);
                }
                else
                {
                    inventTransListForVoucher = InventTransList::construct();
                    inventTransReorder.insert([inventTrans.PackingSlipId, inventTrans.VoucherPhysical], inventTransListForVoucher);
                }

                inventTransListForVoucher.addEnd(inventTrans);
            }
            else
            {
                inventTransList.addEnd(inventTrans);
            }
        }

        inventTransList = this.reorderInventTransList(inventTransList, inventTransReorder);

        return inventTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateMovement</Name>
				<Source><![CDATA[
    public boolean checkUpdateMovement()
    {
        boolean         ok = true;

        if (!movement.checkUpdateStandard(ledgerVoucher.lastTransDate()))
        {
            ok = false;
        }

        if (!movement.checkUpdateFinancial(this))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctFinancialTrackingRegister</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Corrects previously financially updated tracking register transactions by reverting them.
    /// </summary>
    /// <param name="_correctedFinancialQty">
    ///    The corrected financial quantity.
    /// </param>
    private void correctFinancialTrackingRegister(InventQty _correctedFinancialQty)
    {
        InventQty               remainingFinancialQty = movement.transIdSum().financial();

        InventTrackingRegisterTrans::creditFinancialJournalTrackingTrans(movement.inventTransOriginId(), financialJournalLine, this.parmRemainPhysical(), _correctedFinancialQty, remainingFinancialQty, movement.inventDimGroupSetup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventUpd_Physical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventUpd_Physical</c> class from the current instance.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public InventUpd_Physical createInventUpd_Physical()
    {
        Percent physicalPercent = physical / (financial ? financial : 1.0);
        physicalPercent = physicalPercent < 1 ? physicalPercent : 1.0;

        return InventUpd_Physical::newInventUpdFinancial(
            movement,
            this,
            physical,
            physicalUnit,
            CurrencyExchangeHelper::mstAmount(this.parmCostAmountCur() * physicalPercent, this.parmCurrencyCode(), ledgerVoucher.lastTransDate(), this.parmExchRatesTriangulation(), this.parmExchRate(), this.parmExchRateSecondary()),
            cwPhysical,
            costAmountCurSecCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransToIssueList</Name>
				<Source><![CDATA[
    public void initInventTransToIssueList(
        StatusIssue             _fromStatus,
        StatusIssue             _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId)
    {
        if (this.parmCustomInventTransListInitialized())
        {
            this.initializeInventTransToIssueListWithCustomInventTransList(_fromStatus,
                                                                           _toStatus,
                                                                           _inventDimId,
                                                                           _inventDimCriteria,
                                                                           _inventDimParm,
                                                                           _inventTransChildType,
                                                                           _inventTransChildRefId);
            return;
        }

        Query query = this.setupInventTransQuery(_inventDimCriteria, _inventDimParm);
        QueryBuildDataSource qbdsInventTrans = query.dataSourceTable(tableNum(InventTrans));
        qbdsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryRange(_fromStatus, _toStatus));
        qbdsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::None));

        issueTransList = this.buildInventTransList(query);
        issueTransListEnumerator = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransToReceiveList</Name>
				<Source><![CDATA[
    public void initInventTransToReceiveList(
        StatusReceipt           _fromStatus,
        StatusReceipt           _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId,
        InventQty               _maxQty,
        boolean                 _addRecordsNotMatchingCriteria = false)
    {
        Query query = this.setupInventTransQuery(_inventDimCriteria, _inventDimParm);
        QueryBuildDataSource qbdsInventTrans = query.dataSourceTable(tableNum(InventTrans));
        qbdsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::None));
        qbdsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryRange(_fromStatus, _toStatus));

        receiptTransList = this.buildInventTransList(query);

        if (!this.parmPackingSlipList() || this.parmPackingSlipList().empty())
        {
            InventCWPostWithInventDimPhysicalMatchContext context;
            context = InventCWPostWithInventDimPhysicalMatchContext::current();
            if (context && context.parmConsiderInventDimPhysicalMatched())
            {
                receiptTransList = this.reorderInventTransListByInventDimPhysicalMatch(receiptTransList, _inventDimCriteria, _inventDimParm);
            }
        }

        receiptTransListEnumerator = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    protected void initUpdate()
    {
        if (!ledgerVoucher)
        {
            throw error(strFmt("@SYS19386",funcName()));
        }

        receiptCostPricePcsMax = InventParameters::find().CostPricePcsMaxValue;

        if (movement.isReturned(financialUnit))
        {
            invoiceReturn = NoYes::Yes;
        }

        UnitQty transQtyUnit = movement.transQtyUnit();
        if (financialUnit != 0.0 && transQtyUnit != 0.0 && sign(financialUnit) * sign(transQtyUnit) < 0)
        {
            returnMode = InventUpdate::financialReturn();
        }

        using (var cache = movement.constructRecordViewCache())
        {
            if (financial > 0)
            {
                physical    = max(financial - movement.transIdSum().received(),0);
            }
            else
            {
                if (financial < 0)
                {
                    physical    = min(financial - movement.transIdSum().deducted(),0);
                }
            }

            if (cwFinancial > 0)
            {
                cwPhysical = max(cwFinancial -movement.transIdSum().pdsCWReceived(),0);
            }
            if (cwFinancial < 0)
            {
                cwPhysical = min(cwFinancial -movement.transIdSum().pdsCWDeducted(),0);
            }

            if (movement.mustBeUnitControlled())
            {
                if (!returnMode)
                {
                    if (financialUnit  > 0)
                    {
                        physicalUnit= max(financialUnit  - movement.remainFinancialUnit(),0);
                    }
                    else
                    {
                        if (financialUnit  < 0)
                        {
                            physicalUnit= min(financialUnit  - movement.remainFinancialUnit(),0);
                        }
                    }
                }
                else
                {
                    if (financialUnit  > 0)
                    {
                        physicalUnit= max(financialUnit  - max(movement.remainFinancialUnit(),0),0);
                    }
                    else
                    {
                        if (financialUnit  < 0)
                        {
                            physicalUnit= min(financialUnit  - min(movement.remainFinancialUnit(),0),0);
                        }
                    }
                }
            }
            else
            {
                physicalUnit= physical;
            }
        }
        adjustWMSLocationLoad = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventOnhandFinancialCache</Name>
				<Source><![CDATA[
    protected InventOnhand    inventOnhandFinancialCache(InventDim    _inventDim)
    {
        if (!inventCostOnhandCache)
        {
            inventCostOnhandCache = inventCostOnhandCache::construct();
        }

        return inventCostOnhandCache.getOnhand(movement, _inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a new instance of the <c>InventUpd_Financial</c> class.
    /// </summary>
    /// <param name = "_inventMovement">
    ///     Inventory movement class used to construct <c>InventUpd_Financial</c> class.
    /// </param>
    /// <returns>
    ///     A new instance of <c>InventUpd_Financial</c> class.
    /// </returns>
    protected static InventUpd_Financial construct(InventMovement _inventMovement)
    {
        return new InventUpd_Financial(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(InventMovement _inventMovement)
    {
        skipCWAutoAdjust = false;
        super(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustWMSLocationLoad</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the load on a <c>wmsLocation</c> location should be adjusted when a physical
    ///    transaction occurs.
    /// </summary>
    /// <param name="_adjustWMSLocationLoad">
    ///    A Boolean value that determines whether to adjust the load on a <c>wmsLocation</c> location;
    ///    optional.
    /// </param>
    /// <returns>
    ///    true if the load on a <c>wmsLocation</c> location should be adjusted; otherwise, false.
    /// </returns>
    public boolean parmAdjustWMSLocationLoad(boolean _adjustWMSLocationLoad = adjustWMSLocationLoad)
    {
        adjustWMSLocationLoad = _adjustWMSLocationLoad;
        return adjustWMSLocationLoad;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoLossProfit</Name>
				<Source><![CDATA[
    public boolean parmAutoLossProfit(boolean _autoLossProfit = autoLossProfit)
    {
        autoLossProfit = _autoLossProfit;
        return autoLossProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckStockTransferScrapQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The check stock transfer scrap quantity parameter.
    /// </summary>
    /// <param name="_stockTransferScrapQty">
    /// The status of the check stock transfer scrap quantity parameter.
    /// </param>
    public void parmCheckStockTransferScrapQty_IN(boolean _stockTransferScrapQty = stockTransferScrapQty)
    {
        stockTransferScrapQty = _stockTransferScrapQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostAmountCur</Name>
				<Source><![CDATA[
    public AmountCur parmCostAmountCur(AmountCur _costAmountCur = costAmountCur)
    {
        costAmountCur = _costAmountCur;
        return costAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostAmountCurSecCur_RU</Name>
				<Source><![CDATA[
    public AmountCur parmCostAmountCurSecCur_RU(AmountCur _costAmountCurSecCur = costAmountCurSecCur)
    {
        costAmountCurSecCur = _costAmountCurSecCur;
        return costAmountCurSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode = currencyCode)
    {
        currencyCode = _currencyCode;
        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomsLoadOnInventory_IN</Name>
				<Source><![CDATA[
    public TaxAmountCur parmCustomsLoadOnInventory_IN(TaxAmountCur _customsLoadOnInventory = customsLoadOnInventory)
    {
        customsLoadOnInventory = _customsLoadOnInventory;
        return customsLoadOnInventory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomsLoadOnInventoryMST_IN</Name>
				<Source><![CDATA[
    public TaxAmountCur parmCustomsLoadOnInventoryMST_IN(TaxAmountCur _customsLoadOnInventoryMST = customsLoadOnInventoryMST)
    {
        customsLoadOnInventoryMST = _customsLoadOnInventoryMST;
        return customsLoadOnInventoryMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackingSlipTransRecId</Name>
				<Source><![CDATA[
    public RefRecId parmPackingSlipTransRecId(RefRecId _packingSlipRecId = packingSlipRecId)
    {
        packingSlipRecId = _packingSlipRecId;
        return packingSlipRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDatePhysicalMaxValue_RU</Name>
				<Source><![CDATA[
    public TransDate parmDatePhysicalMaxValue_RU(TransDate _datePhysicalMaxValue_RU = datePhysicalMaxValue_RU)
    {
        datePhysicalMaxValue_RU = _datePhysicalMaxValue_RU;

        return datePhysicalMaxValue_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRate</Name>
				<Source><![CDATA[
    public ExchRate parmExchRate(ExchRate _exchRate = exchRate)
    {
        exchRate = _exchRate;
        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRateSecondary</Name>
				<Source><![CDATA[
    public ExchrateSecondary parmExchRateSecondary(ExchrateSecondary _exchrateSecondary = exchrateSecondary)
    {
        exchrateSecondary = _exchrateSecondary;
        return exchrateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRatesTriangulation</Name>
				<Source><![CDATA[
    public ExchRatesTriangulation parmExchRatesTriangulation(ExchRatesTriangulation _exchRatesTriangulation = exchRatesTriangulation)
    {
        exchRatesTriangulation = _exchRatesTriangulation;
        return exchRatesTriangulation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinancial</Name>
				<Source><![CDATA[
    public InventQty  parmFinancial(InventQty _financial = financial)
    {
        financial = _financial;
        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinancialJournalLine</Name>
				<Source><![CDATA[
    public Common parmFinancialJournalLine(Common _financialJournalLine = financialJournalLine)
    {
        financialJournalLine = _financialJournalLine;

        return financialJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinancialUnit</Name>
				<Source><![CDATA[
    public UnitQty  parmFinancialUnit(UnitQty _financialUnit = financialUnit)
    {
        financialUnit = _financialUnit;
        return financialUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventCostOnhandCache</Name>
				<Source><![CDATA[
    public inventCostOnhandCache parmInventCostOnhandCache(inventCostOnhandCache _inventCostOnhandCache = inventCostOnhandCache)
    {
        inventCostOnhandCache = _inventCostOnhandCache;

        return inventCostOnhandCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    public InventDim parmInventDim(InventDim _inventDimCriteria  = inventDimCriteria)
    {
        inventDimCriteria = _inventDimCriteria;
        return inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParm</Name>
				<Source><![CDATA[
    public InventDimParm parmInventDimParm(InventDimParm _inventDimParmCriteria = inventDimParmCriteria)
    {
        inventDimParmCriteria = _inventDimParmCriteria;
        return inventDimParmCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceId</Name>
				<Source><![CDATA[
    public InvoiceId parmInvoiceId(InvoiceId  _invoiceNum = invoiceNum)
    {
        invoiceNum = _invoiceNum;
        return invoiceNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceReturn_RU</Name>
				<Source><![CDATA[
    public NoYes parmInvoiceReturn_RU(NoYes _invoiceReturn = invoiceReturn)
    {
        invoiceReturn = _invoiceReturn;
        return invoiceReturn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkingRefInventTransOrigin</Name>
				<Source><![CDATA[
    public InventTransOriginId parmMarkingRefInventTransOrigin(InventTransOriginId _markingRefInventTransOrigin = markingRefInventTransOrigin)
    {
        markingRefInventTransOrigin = _markingRefInventTransOrigin;
        return markingRefInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackingSlipId</Name>
				<Source><![CDATA[
    public PackingSlipId parmPackingSlipId(PackingSlipId _packingSlipId = packingSlipId)
    {
        packingSlipId = _packingSlipId;
        return packingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackingSlipList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>PackingSlipList</c> parameter.
    /// </summary>
    /// <param name="_packingSlipList">
    /// The value to set. Must be a list of <c>VendPackingSlipTrans</c> records.
    /// </param>
    /// <returns>
    /// The value of <c>PackingSLipList</c> parameter.
    /// </returns>
    /// <remarks>
    /// The list indicates processing order.
    /// </remarks>
    public List parmPackingSlipList(List _packingSlipList = packingSlipList)
    {
        packingSlipList = _packingSlipList;
        return packingSlipList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the cwFinancial parameter.
    /// </summary>
    /// <param name="_cwFinancial">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwFinancial parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWFinancial(
        PdsCWInventQty _cwFinancial = cwFinancial)
    {
        cwFinancial = _cwFinancial;
        return cwFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the cwPhysical parameter.
    /// </summary>
    /// <param name="_cwPhysical">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwPhysical parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWPhysical(
        PdsCWInventQty  _cwPhysical = cwPhysical)
    {
        cwPhysical = _cwPhysical;

        return cwPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the cwRemainPhysical parameter.
    /// </summary>
    /// <param name="_cwRemainPhysical">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwRemainPhysical parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWRemainPhysical(
        PdsCWInventQty  _cwRemainPhysical = cwRemainPhysical)
    {
        cwRemainPhysical = _cwRemainPhysical;
        return cwRemainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSUpdatePhysicalOnly</Name>
				<Source><![CDATA[
    public boolean parmPDSUpdatePhysicalOnly(boolean  _pdsUpdatePhysicalOnly = pdsUpdatePhysicalOnly)
    {
        pdsUpdatePhysicalOnly = _pdsUpdatePhysicalOnly;

        return pdsUpdatePhysicalOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPhysical</Name>
				<Source><![CDATA[
    protected InventQty parmPhysical(InventQty  _physical = physical)
    {
        physical = _physical;
        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPhysicalUnit</Name>
				<Source><![CDATA[
    protected UnitQty  parmPhysicalUnit(UnitQty _physicalUnit = physicalUnit )
    {
        physicalUnit = _physicalUnit;
        return physicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDate</Name>
				<Source><![CDATA[
    public ProjTransDate parmProjTransDate(ProjTransDate _projTransDate = projTransDate)
    {
        projTransDate = _projTransDate;
        return projTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainBeforePhysical_RU</Name>
				<Source><![CDATA[
    InventQty parmRemainBeforePhysical_RU(InventQty _remainBeforePhysical = remainBeforePhysical)
    {
        remainBeforePhysical = _remainBeforePhysical;
        return remainBeforePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainBeforePhysicalUnit_RU</Name>
				<Source><![CDATA[
    UnitQty parmRemainBeforePhysicalUnit_RU(UnitQty _remainBeforePhysicalUnit = remainBeforePhysicalUnit)
    {
        remainBeforePhysicalUnit = _remainBeforePhysicalUnit;
        return remainBeforePhysicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainPhysical</Name>
				<Source><![CDATA[
    public InventQty parmRemainPhysical(InventQty  _remainPhysical = remainPhysical)
    {
        remainPhysical = _remainPhysical;
        return remainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty parmRemainPhysicalUnit(InventQty  _remainPhysicalUnit = remainPhysicalUnit)
    {
        remainPhysicalUnit = _remainPhysicalUnit;
        return remainPhysicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipCWAutoAdjust</Name>
				<Source><![CDATA[
    public boolean parmSkipCWAutoAdjust(boolean _skipCWAutoAdjust = skipCWAutoAdjust)
    {
        skipCWAutoAdjust = _skipCWAutoAdjust;
        return skipCWAutoAdjust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherPhysical</Name>
				<Source><![CDATA[
    public VoucherPhysical parmVoucherPhysical(VoucherPhysical _voucherPhysical = voucherPhysical)
    {
        voucherPhysical = _voucherPhysical;
        return voucherPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUpdFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>cwUpdFinancial</c> parameter.
    /// </summary>
    /// <returns>
    /// The <c>cwUpdFinancial</c> parameter.
    /// </returns>
    public PdsCWInventQty pdsCWUpdFinancial()
    {
        return cwUpdFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUpdPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>cwUpdPhysical</c> parameter.
    /// </summary>
    /// <returns>
    /// The <c>cwUpdPhysical</c> parameter.
    /// </returns>
    public PdsCWInventQty pdsCWUpdPhysical()
    {
        return cwUpdPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reorderInventTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method reorders the <c>InventTrans</c> records in the order of late match packing slips selection if needed.
    /// </summary>
    /// <param name="_inventTransList">
    /// The original list of <c>InventTrans</c> records.
    /// </param>
    /// <param name="_inventTransReorder">
    /// A map of <c>InventTrans</c> records per voucher.
    /// </param>
    /// <returns>
    /// The ordered list of <c>InventTrans</c> records.
    /// </returns>
    protected List reorderInventTransList(List _inventTransList, Map _inventTransReorder)
    {
        List orderedInventTransList;

        if (_inventTransReorder)
        {
            if (this.parmPackingSlipList() && !this.parmPackingSlipList().empty())
            {
                orderedInventTransList = new List(Types::Record); // ordered list of InventTrans
            }

            // order InventTrans records on the list the same way as late invoice match processed corresponding packing slips
            ListEnumerator packingSlipListEnumerator = this.parmPackingSlipList().getEnumerator();

            Set inventTransRecId = new Set(Types::Int64);
            VendPackingSlipTrans currentVendPackingSlipTrans;
            InventTransList inventTransListForVoucher;
            InventTrans inventTransCurrent;
            while (packingSlipListEnumerator.moveNext())
            {              
                currentVendPackingSlipTrans = packingSlipListEnumerator.current();

                if (_inventTransReorder.exists([currentVendPackingSlipTrans.PackingSlipId, currentVendPackingSlipTrans.CostLedgerVoucher]))
                {
                    inventTransListForVoucher = _inventTransReorder.lookup([currentVendPackingSlipTrans.PackingSlipId, currentVendPackingSlipTrans.CostLedgerVoucher]);
                    Enumerator inventTransListEnumerator = inventTransListForVoucher.getEnumerator();
                    while (inventTransListEnumerator.moveNext())
                    {                      
                        inventTransCurrent = inventTransListEnumerator.current();
                        if (!inventTransRecId.in(inventTransCurrent.RecId))
                        {
                            orderedInventTransList.addEnd(inventTransCurrent);
                            inventTransRecId.add(inventTransCurrent.RecId);
                        }

                        if (needAssignNullToTableBuffer)
                        {
                            inventTransCurrent = null;
                        }
                    }
                }

                if (needAssignNullToTableBuffer)
                {
                    currentVendPackingSlipTrans = null;
                }
            }

            // add all the rest that didn't go through late invoice match to the end
            orderedInventTransList.appendList(_inventTransList);
        }
        else
        {
            orderedInventTransList = _inventTransList;
        }
        return orderedInventTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnMode</Name>
				<Source><![CDATA[
    public Integer returnMode()
    {
        return returnMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventTrans</Name>
				<Source><![CDATA[
    protected  void setInventTrans(
        InventTrans     _inventTrans,
        InventQty       _addQty,
        CostAmount      _addCostAmount,
        CostAmount      _addOperationsAmount,
        CostAmount      addCostAmountSecCur = 0)
    {
        movement.initInventTransFinancial(_inventTrans,ledgerVoucher.lastTransDate(),invoiceNum,this.parmCurrencyCode());

        _inventTrans.Voucher            = ledgerVoucher.lastVoucher();
        _inventTrans.InvoiceReturned    = invoiceReturn;

        if (_addQty == _inventTrans.Qty)
        {
            _inventTrans.CostAmountPosted       = _addCostAmount;
            _inventTrans.CostAmountOperations   = _addOperationsAmount;
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                _inventTrans.CostAmountSecCurPosted_RU = addCostAmountSecCur;
            }
            // </GEERU>
        }
        else if (abs(_addQty) > abs(_inventTrans.Qty))
        {
            _inventTrans.CostAmountPosted       = CurrencyExchangeHelper::amount(_addCostAmount * _inventTrans.Qty / _addQty);
            _inventTrans.CostAmountOperations   = CurrencyExchangeHelper::amount(_addOperationsAmount * _inventTrans.Qty / _addQty);
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                _inventTrans.CostAmountSecCurPosted_RU = CurrencyExchangeHelper::amount(addCostAmountSecCur * _inventTrans.Qty / _addQty, CompanyInfoHelper::secondaryCurrency_RU());
            }
            // </GEERU>
        }
        else
        {
            throw error(strFmt("@SYS19378",funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupInventTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds and returns a <c>Query</c> of candidate <c>InventTrans</c> records to examine.
    /// </summary>
    /// <param name="_inventDimCriteria">
    /// <c>InventDim</c> criteria;
    /// </param>
    /// <param name="_inventDimParm">
    /// <c>InventDimParm</c> criteria;
    /// </param>
    /// <returns>
    /// Returns a <c>Query</c> of candidate <c>InventTrans</c> records to examine.
    /// </returns>
    protected Query setupInventTransQuery(
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm)
    {
        Query query                 = new Query();

        QueryBuildDataSource qbdsInventTrans = query.addDataSource(tableNum(InventTrans));
        qbdsInventTrans.addSortField(fieldNum(InventTrans, InventDimId));
        qbdsInventTrans.update(true);
        qbdsInventTrans.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(movement.inventTransOriginId()));
        qbdsInventTrans.addRange(fieldNum(InventTrans, PackingSlipId)).value(
            packingSlipId ? queryValue(packingSlipId) : SysQuery::valueUnlimited()); // movement.packingSlipForUpdate_W()
        qbdsInventTrans.addRange(fieldNum(InventTrans, VoucherPhysical)).value(
            voucherPhysical ? queryValue(voucherPhysical) : SysQuery::valueUnlimited());
        qbdsInventTrans.addRange(fieldNum(InventTrans, MarkingRefInventTransOrigin)).value(
            markingRefInventTransOrigin ? SysQuery::value(markingRefInventTransOrigin) : SysQuery::valueUnlimited());
        qbdsInventTrans.addRange(fieldNum(InventTrans, DatePhysical)).value(
            datePhysicalMaxValue_RU ? SysQuery::range(dateNull(), datePhysicalMaxValue_RU) : SysQuery::valueUnlimited());

        if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && !inventDimParmCriteria.isAllFlagNo())
            || (PdsGlobal::pdsIsCWItem(movement.itemId()) && !_inventDimParm.isAllFlagNo()))
        {
            QueryBuildDataSource qbdsInventDim = qbdsInventTrans.addDataSource(tableNum(InventDim));
            qbdsInventDim.relations(true);
            qbdsInventDim.joinMode(JoinMode::ExistsJoin);
            InventDim::queryDatasourceAddRangeSortFromParms(qbdsInventDim, true, _inventDimCriteria, _inventDimParm, null);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCostAmountOffsetsForFinancialIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates cost amount offsets for a Financial issue.
    /// </summary>
    /// <param name = "_inventTrans">The transaction.</param>
    /// <param name = "_inventOnhand">Information about on-hand inventory.</param>
    /// <returns>A container with the result for primary and secondary currencies.</returns>
    protected container calculateCostAmountOffsetsForFinancialIssue(InventTrans _inventTrans, InventOnhand _inventOnhand)
    {
        CostAmount changeCostAmountSecCur;
        
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        if (countryRegion_RU)
        {
            changeCostAmountSecCur = movement.useEnteredPriceAsCost()
                                             ? 0
                                             : movement.inventModelTypeSecCur_RU().financialIssueCostValueSecCur_RU(movement, _inventTrans, _inventOnhand) - _inventTrans.costValueSecCur_RU();
        }
        // </GEERU>

        CostAmount changeCostAmount = this.calculateChangeCostAmount(_inventTrans, _inventOnhand);

        // <GTE>
        if (changeCostAmount && movement.taxEngineInventMovement().taxDocumentLine())
        {
            ITaxDocumentLine taxDocumentLine = movement.taxEngineInventMovement().taxDocumentLine();
            if (taxDocumentLine)
            {
                changeCostAmount += taxDocumentLine.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountAccountingCurrency();
                changeCostAmount -= taxDocumentLine.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountAccountingCurrency();
            }
        }
        // </GTE>

        // Do not add indirect cost on issue. Indirect cost is included in the inventory value
        // except for credit notes at standard cost
        if (this.mustCreateCostTransactions(movement))
        {
            var indirectCostAmount = movement.inventCostIndirectFinancial().update(_inventTrans);

            if (movement.inventModelType().stdCostBased()
               && movement.isReturned(_inventTrans.Qty))
            {
                changeCostAmount += indirectCostAmount;
            }
            // <GEERU>
            if (countryRegion_RU
                        && movement.inventModelTypeSecCur_RU().stdCostBased()
                        && movement.isReturned(_inventTrans.Qty))
            {
                changeCostAmountSecCur += indirectCostAmount;
            }
            // </GEERU>
        }

        return [changeCostAmount, changeCostAmountSecCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateChangeCostAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the change cost amount offset.
    /// </summary>
    /// <param name = "_inventTrans">
    /// Inventory transaction.
    /// </param>
    /// <param name = "_inventOnhand">
    /// Information about on-hand inventory.
    /// </param>
    /// <returns>
    /// A cost amount.
    /// </returns>
    [Replaceable]
    protected CostAmount calculateChangeCostAmount(InventTrans _inventTrans, InventOnhand _inventOnhand)
    {
        CostAmount changeCostAmount = movement.useEnteredPriceAsCost()
                                           ? 0
                                           : movement.inventModelType().financialIssueCostValue(movement, _inventTrans, _inventOnhand) - _inventTrans.costValue();
        
        if (FeatureStateProvider::isFeatureEnabled(AssetReversePOForeignCurrencyFeature::instance())
            && changeCostAmount == 0 
            && movement.isFixedAssetReturn())
        {
            changeCostAmount = this.calculateChangeCostAmountForFixedAassetReturn();
        }

        return changeCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateChangeCostAmountForFixedAassetReturn</Name>
				<Source><![CDATA[
    private CostAmount calculateChangeCostAmountForFixedAassetReturn()
    {
        CostAmount changeCostAmount = 0;

        PurchLine purchLine = movement.buffer();
        if (purchLine.CurrencyCode != Ledger::accountingCurrency())
        {
            VendInvoiceTrans origVendInvoiceTrans = AssetTransVendInvoiceTrans::getOrigVendInvoiceTransForCreditNote(purchLine.RecId);

            if (origVendInvoiceTrans.RecId
                && purchLine.PurchPrice == origVendInvoiceTrans.PurchPrice
                && purchLine.CurrencyCode == origVendInvoiceTrans.CurrencyCode)
            {
                Amount origAmount = origVendInvoiceTrans.LineAmountMST / origVendInvoiceTrans.Qty * purchLine.PurchQty;
                changeCostAmount = origAmount - this.parmCostAmountCur();
            }
        }
        
        return changeCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateCostTransactions</Name>
				<Source><![CDATA[
    protected boolean mustCreateCostTransactions(InventMovement _inventMovement)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinancialIssue</Name>
				<Source><![CDATA[
    protected CostAmountSecCur_RU updateFinancialIssue(CostAmount _costAmountMST, CostAmountSecCur_RU _costAmountSecCur)
    {
        InventTrans     inventTrans;

        InventQty       addQty                  = financial;
        CostAmount      addCostAmount           = _costAmountMST;
        CostAmount      addOperationsAmount     = updOperationsAmountLedger;

        PdsCWInventQty      cwAddQty                = cwFinancial;

        // <GEERU>
        CostAmount      addCostAmountSecCur     = _costAmountSecCur;
        boolean         countryRegion_RU        = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // Initialize the inventCost framework
        if (this.mustCreateCostTransactions(movement))
        {
            movement.inventModelType().initCostTransVariance(movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(financial));
        }

        // update references like Asset, Projects etc.
        this.changeInventTransReferences();

        // <GEERU>
        if (countryRegion_RU && this.mustCreateCostTransactions(movement))
        {
            movement.inventModelTypeSecCur_RU().initCostTransVariance(movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(financial));
        }
        // </GEERU>

        this.initInventTransToIssueList(
            StatusIssue::Deducted,
            StatusIssue::Deducted,
            inventDimCriteria.InventDimId,
            inventDimCriteria,
            inventDimParmCriteria,
            movement.transChildType(),
            movement.transChildRefId());

        while (this.getNextInventTransToIssue(inventTrans))
        {
            if (this.skipInventTransForDifferentSites(inventTrans))
            {
                continue;
            }

            if (!movement.inventTable().checkRefInventTrans(inventTrans)
             || !movement.checkDimPhysical(inventTrans.Qty,inventTrans.inventDim(),true))
            {
                throw error("@SYS18447");
            }

            if (movement.canInventTransBeFinancialUpdated(inventTrans))
            {
                InventQty updateNowQuantity = this.transactionIssueQuantity(inventTrans, addQty);

                if (updateNowQuantity > inventTrans.Qty)
                {
                    inventTrans.updateSplit(updateNowQuantity, cwAddQty);
                }

                InventOnhand inventOnhand = this.inventOnhandFinancialCache(inventTrans.inventDim());

                if (!inventOnhand.checkItemDrawFinancial(inventTrans.Qty, allowNegativeFinancial, true, inventTrans.PdsCWQty))
                {
                    if (movement.transType() == InventTransType::QuarantineOrder
                     && movement.inventLocationId()
                     && InventLocation::find(movement.inventLocationId()).InventLocationType != InventLocationType::Quarantine)
                    {
                        info("@SYS79282");
                    }
                    throw error("@SYS18447");
                }

                movement.inventModelType().preUpdateFinancial(movement, ledgerVoucher, inventTrans, inventOnhand);

                // <GEERU>
                if (countryRegion_RU)
                {
                    movement.inventModelTypeSecCur_RU().preUpdateFinancial(movement, ledgerVoucher, inventTrans, inventOnhand);
                }
                // </GEERU>

                // <GEERU>
                if (countryRegion_RU)
                {
                    this.setInventTrans(inventTrans,addQty,addCostAmount,addOperationsAmount, addCostAmountSecCur);
                }
                else
                {
                    // </GEERU>
                    this.setInventTrans(inventTrans,addQty,addCostAmount,addOperationsAmount);
                    // <GEERU>
                }
                // </GEERU>
                addQty              -= inventTrans.Qty;
                addCostAmount       -= inventTrans.CostAmountPosted;
                addOperationsAmount -= inventTrans.CostAmountOperations;
                cwAddQty            -= inventTrans.PdsCWQty;
                // <GEERU>
                if (countryRegion_RU)
                {
                    addCostAmountSecCur -= inventTrans.CostAmountSecCurPosted_RU;
                }
                // </GEERU>

                movement.transIdSum().setInventTransStatus(inventTrans,StatusReceipt::None,StatusIssue::Sold);
                movement.updateLedgerPhysical(ledgerVoucher,inventTrans,this,inventOnhand);

                if (inventTrans.InvoiceReturned)
                {
                    this.updateStdCostPrice(inventTrans,true);
                }

                CostAmount changeCostAmount;
                CostAmount changeCostAmountSecCur;

                [changeCostAmount, changeCostAmountSecCur] = this.calculateCostAmountOffsetsForFinancialIssue(inventTrans, inventOnhand);

                // <GEERU>
                if (changeCostAmount
                    || (countryRegion_RU
                    && changeCostAmountSecCur))
                // </GEERU>
                {
                    inventTrans.CostAmountPosted += changeCostAmount;
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        inventTrans.CostAmountSecCurPosted_RU += changeCostAmountSecCur;
                    }
                    // </GEERU>

                    if (this.mustUpdateMovementLedgerAdjust())
                    {
                        inventTrans.CostAmountOperations   -= changeCostAmount;

                        this.updateMovementLedgerAdjust(inventTrans, changeCostAmount, changeCostAmountSecCur);
                    }
                    // If inventory is not financial updated project create a never ledger transaction in the project module
                    // <GEERU>
                    else if ((!countryRegion_RU
                            || (countryRegion_RU
                            && changeCostAmount))
                            && inventTrans.ProjId
                            && ProjPost::checkCreateProjCost(inventTrans.ItemId,inventTrans.ProjId))
                    // </GEERU>
                    {
                        ProjPost::newInventNeverLedger(inventTrans,ledgerVoucher.lastTransDate(),ledgerVoucher.lastVoucher(),changeCostAmount).postTrans();
                    }
                }

                if (inventTrans.CostAmountPosted  > 0)
                {
                    throw error("@SYS17181");
                }

                if (this.mustCreateCostTransactions(movement))
                {
                    // Add each inventTrans record to the inventCost framework
                    movement.inventModelType().addCostTransVariance(inventTrans, movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(inventTrans.Qty));

                    movement.inventModelType().postUpdateFinancial(movement, ledgerVoucher, inventTrans, inventOnhand);

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        movement.inventModelTypeSecCur_RU().addCostTransVariance(inventTrans, movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(inventTrans.Qty));
                        movement.inventModelTypeSecCur_RU().postUpdateFinancial(movement, ledgerVoucher, inventTrans, inventOnhand);

                        inventTrans.CostAmountStdSecCur_RU = inventTrans.costValueSecCur_RU();
                    }
                    // </GEERU>
                }
                inventTrans.CostAmountStd = inventTrans.costValue();
                this.updateInventOnhandFinancialCache(inventTrans);

                inventTrans.update();

                this.updateFinancialIssueAmounts(inventTrans);
            }

            if (!addQty)
            {
                break;
            }
        }

        this.verifyCustomInventTransUpdate(addQty);

        if (addQty)
        {
            Info("@SCM:InventOrderPickingGeneralGuide");
            throw error("@SYS6514");
        }

        if (movement.mustRegisterTrackingDimension())
        {
            if (movement.transQty() > 0)
            {
                this.correctFinancialTrackingRegister(updFinancial);
            }
            else
            {
                this.updateTrackingRegisterFinancially(updFinancial);
            }
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            if (this.mustCreateCostTransactions(movement))
            {
                boolean costOK = movement.inventModelType().finalizeCostTransVariance         (movement, ledgerVoucher, InventCostTransState::Financial, movement.isReturned(financial));
                movement.inventModelTypeSecCur_RU().finalizeCostTransVarianceSecCur_RU(movement, ledgerVoucher, InventCostTransState::Financial, costOK, movement.isReturned(financial));
            }
            return inventTrans.CostAmountSecCurPosted_RU;
        }
        else
        {
            if (this.mustCreateCostTransactions(movement))
            {
                // </GEERU>
                // Push the created variance to the inventCostUpdate class
                movement.inventModelType().finalizeCostTransVariance(movement, ledgerVoucher, InventCostTransState::Financial, movement.isReturned(financial));
                // <GEERU>
            }
            return 0;
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateMovementLedgerAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the ledger must be updated for the inventory movement adjustment.
    /// </summary>
    /// <returns>
    /// true if the ledger must be updated; otherwise, false.
    /// </returns>
    protected boolean mustUpdateMovementLedgerAdjust()
    {
        return movement.mustBeBookedBalanceSheet() && movement.mustBeBookedOperations() && !stockTransferScrapQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinancialIssueAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cost amounts and quantities after processing and updating the given <c>InvetnTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">
    /// The newly processed inventory transaction.
    /// </param>
    protected void updateFinancialIssueAmounts(InventTrans _inventTrans)
    {
        updCostAmountPhysical = _inventTrans.CostAmountPhysical;
        if (movement.inventModelType().stdCostBased() == NoYes::Yes)
        {
            updCostAmountInvent += _inventTrans.CostAmountPosted;
        }
        else
        {
            updCostAmountInvent += _inventTrans.costValue();
        }
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (movement.inventModelTypeSecCur_RU().stdCostBased())
            {
                updCostAmountInventSecCur += _inventTrans.CostAmountSecCurPosted_RU;
            }
            else
            {
                updCostAmountInventSecCur += _inventTrans.costValueSecCur_RU();
            }
        }
        // </GEERU>
        updFinancial   += _inventTrans.Qty;
        cwUpdFinancial += _inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMovementLedgerAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the ledger for the inventory movement.
    /// </summary>
    /// <param name = "_inventTrans">
    /// The inventory transaction that is being updated.
    /// </param>
    /// <param name = "_changeCostAmount">
    /// The main change to adjust for.
    /// </param>
    /// <param name = "_changeCostAmountSecCur">
    /// The secondary change to change to adjust for.
    /// </param>
    protected void updateMovementLedgerAdjust(
        InventTrans _inventTrans,
        CostAmount  _changeCostAmount,
        CostAmount  _changeCostAmountSecCur)
    {
        movement.updateLedgerAdjust(ledgerVoucher,
                                    this,
                                    _changeCostAmount,
                                    _inventTrans.ProjAdjustRefId,
                                    this.parmProjTransDate());

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            movement.updateLedgerAdjustSecCur_RU(ledgerVoucher,
                                                 this,
                                                 _changeCostAmountSecCur,
                                                 _inventTrans.ProjAdjustRefId,
                                                 this.parmProjTransDate());
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinancialReceipt</Name>
				<Source><![CDATA[
    protected CostAmountSecCur_RU updateFinancialReceipt(CostAmount _costAmountMST, CostAmountSecCur_RU _costAmountSecCur)
    {
        InventTrans     inventTrans;
        InventOnhand    inventOnhand;

        InventQty       addQty                  = financial;
        CostAmount      addCostAmount           = _costAmountMST;
        CostAmount      addOperationsAmount     = updOperationsAmountLedger;
        CostAmount      changeCostAmountStd;
        CostAmount      returnValue;
        InventQty       returnQty;
        PdsCWInventQty  cwAddQty                = cwFinancial;
        // <GEERU>
        CostAmount      changeCostAmountStdSecCur;
        CostAmount      addCostAmountSecCur         = _costAmountSecCur;
        CostAmount      changeCostAmountSecCur;
        CostAmount      returnValueSecCur;
        CurrencyCode    secondaryCurrencyCode_RU    = CompanyInfoHelper::secondaryCurrency_RU();
        boolean         countryRegion_RU            = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        CostAmount      indirectCostAmount, indirectCostAmountSecCur;
        // </GEERU>

        // Initialize the inventCost framework
        if (this.mustCreateCostTransactions(movement))
        {
            movement.inventModelType().initCostTransVariance(movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(financial));

            // <GEERU>
            if (countryRegion_RU)
            {
                movement.inventModelTypeSecCur_RU().initCostTransVariance(movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(financial));
            }
            // </GEERU>
        }

        // update references like Asset, Projects etc.
        this.changeInventTransReferences();

        this.initInventTransToReceiveList(
            StatusReceipt::Received,
            StatusReceipt::Received,
            inventDimCriteria.InventDimId,
            inventDimCriteria,
            inventDimParmCriteria,
            movement.transChildType(),
            movement.transChildRefId(),
            addQty);

        while (this.getNextInventTransToReceive(inventTrans))
        {
            if (this.skipInventTransForDifferentSites(inventTrans))
            {
                continue;
            }

            CostAmount changeCostAmount = 0;
            if (countryRegion_RU)
            {
                changeCostAmountSecCur = 0;
            }

            if (!movement.inventTable().checkRefInventTrans(inventTrans)
             || !movement.checkDimPhysical(inventTrans.Qty, inventTrans.inventDim(), true, true))
            {
                throw error("@SYS18447");
            }

            if (movement.canInventTransBeFinancialUpdated(inventTrans))
            {
                if (addQty   < inventTrans.Qty)
                {
                    inventTrans.updateSplit(addQty, cwAddQty);
                }

                if (movement.inventModelType().cacheFinancialOnhandOnFinancialUpdate())
                {
                    inventOnhand = this.inventOnhandFinancialCache(inventTrans.inventDim());
                }

                movement.inventModelType().preUpdateFinancial(movement, ledgerVoucher, inventTrans, inventOnhand);

                // <GEERU>
                if (countryRegion_RU)
                {
                    movement.inventModelTypeSecCur_RU().preUpdateFinancial(movement, ledgerVoucher, inventTrans, inventOnhand);
                }
                // </GEERU>

                // <GEERU>
                if (countryRegion_RU)
                {
                    this.setInventTrans(inventTrans,addQty,addCostAmount,addOperationsAmount,addCostAmountSecCur);
                }
                else
                {
                    // </GEERU>
                    this.setInventTrans(inventTrans,addQty,addCostAmount,addOperationsAmount);
                    // <GEERU>
                }
                // </GEERU>

                addQty              -= inventTrans.Qty;
                addCostAmount       -= inventTrans.CostAmountPosted;
                addOperationsAmount -= inventTrans.CostAmountOperations;
                cwAddQty            -= inventTrans.PdsCWQty;

                // <GEERU>
                if (countryRegion_RU)
                {
                    addCostAmountSecCur -= inventTrans.CostAmountSecCurPosted_RU;
                    changeCostAmountSecCur = movement.inventModelTypeSecCur_RU().financialReceiptCostValueSecCur_RU(movement, inventTrans, returnMode) - inventTrans.CostAmountSecCurPosted_RU;
                }
                // </GEERU>
                movement.transIdSum().setInventTransStatus(inventTrans,StatusReceipt::Purchased,StatusIssue::None);
                movement.updateLedgerPhysical(ledgerVoucher, inventTrans, this, null);

                // <GIN>
                if (! stockTransferScrapQty)
                {
                    // </GIN>
                    changeCostAmount += movement.inventModelType().financialReceiptCostValue(movement, inventTrans, returnMode) - inventTrans.CostAmountPosted;
                    // <GIN>
                }

                stockTransferScrapQty = false;
                // </GIN>

                // <GEERU>
                if (this.mustCreateCostTransactions(movement))
                {
                    if (countryRegion_RU)
                    {
                        indirectCostAmount = movement.inventCostIndirectFinancial().update(inventTrans);
                        movement.parmIndirectCostAmount_RU(indirectCostAmount);
                        changeCostAmount  += indirectCostAmount;

                        // Reporting currency
                        indirectCostAmountSecCur = CurrencyExchangeHelper::amountMST2MSTSecond_RU(indirectCostAmount, inventTrans.DateFinancial);
                        movement.parmIndirectCostAmountSecCur_RU(indirectCostAmountSecCur);
                        changeCostAmountSecCur  += indirectCostAmountSecCur;
                    }
                    else
                    {
                        // </GEERU>
                        changeCostAmount += movement.inventCostIndirectFinancial().update(inventTrans);
                        // <GEERU>
                    }
                }
                // </GEERU>

                // </GEERU>
                if (changeCostAmount)
                {
                    inventTrans.CostAmountPosted       += changeCostAmount;
                    inventTrans.CostAmountOperations   -= changeCostAmount;

                    movement.updateLedgerAdjust(ledgerVoucher, this, changeCostAmount, inventTrans.ProjAdjustRefId, this.parmProjTransDate());
                }

                // <GEERU>
                if (countryRegion_RU
                    && changeCostAmountSecCur)
                {
                    inventTrans.CostAmountSecCurPosted_RU += changeCostAmountSecCur;
                    movement.updateLedgerAdjustSecCur_RU(ledgerVoucher, this, changeCostAmountSecCur, inventTrans.ProjAdjustRefId, this.parmProjTransDate());
                }
                // </GEERU>
                if (!inventTrans.checkCostValue(receiptCostPricePcsMax))
                {
                    throw error("@SYS18447");
                }

                if (inventTrans.ReturnInventTransOrigin
                 && (returnMode || movement.isReturned(financial))
                 // <GEERU>
                 && (movement.inventModelType().isSettled()
                    || (countryRegion_RU
                    && movement.inventModelTypeSecCur_RU().isSettled()))
                 // </GEERU>
                 && movement.inventModelGroup().StandardCost)
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        [returnQty, returnValue, returnValueSecCur] = InventTransOrigin::calcReturnCostValue(inventTrans.ReturnInventTransOrigin, inventTrans.InventTransOrigin);
                    }
                    else
                    {
                        // </GEERU>
                        [returnQty,returnValue] = InventTransOrigin::calcReturnCostValue(inventTrans.ReturnInventTransOrigin, inventTrans.InventTransOrigin);
                        // <GEERU>
                    }
                    // </GEERU>

                    if (!returnQty)
                    {
                        throw error("@SYS53016");
                    }

                    // <GEERU>
                    if (!countryRegion_RU
                        || (countryRegion_RU
                        && movement.inventModelType().isSettled()))
                    {
                        // </GEERU>
                        changeCostAmountStd =  -(CurrencyExchangeHelper::amount(movement.inventTable().costPcsPrice(inventTrans.InventDimId) * inventTrans.Qty)
                                               - CurrencyExchangeHelper::amount(inventTrans.Qty * returnValue / returnQty));
                        // <GEERU>
                    }
                    if (countryRegion_RU
                        && movement.inventModelTypeSecCur_RU().isSettled())
                    {
                        changeCostAmountStdSecCur =  -(CurrencyExchangeHelper::amount(movement.inventTable().costPcsPriceSecCur_RU(inventTrans.InventDimId) * inventTrans.Qty, secondaryCurrencyCode_RU)
                                                     - CurrencyExchangeHelper::amount(inventTrans.Qty * returnValueSecCur / returnQty, secondaryCurrencyCode_RU));
                    }
                    // </GEERU>
                }
                // <GEERU>
                if (countryRegion_RU)
                {
                    this.updateStdCostPrice(inventTrans, false, changeCostAmountStd, changeCostAmountStdSecCur);
                }
                else
                {
                    // </GEERU>
                    this.updateStdCostPrice(inventTrans,false,changeCostAmountStd);
                    // <GEERU>
                }
                // </GEERU>

                // Add each inventTrans record to the inventCost framework
                if (this.mustCreateCostTransactions(movement))
                {
                    movement.inventModelType().addCostTransVariance(inventTrans, movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(inventTrans.Qty));

                    movement.inventModelType().postUpdateFinancial(movement, ledgerVoucher, inventTrans, movement.inventModelType().cacheFinancialOnhandOnFinancialUpdate()
                                                                                                         ? this.inventOnhandFinancialCache(inventTrans.inventDim())
                                                                                                         : null);

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        movement.inventModelTypeSecCur_RU().addCostTransVariance(inventTrans, movement, ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), InventCostTransState::Financial, movement.isReturned(inventTrans.Qty));
                        movement.inventModelTypeSecCur_RU().postUpdateFinancial(movement, ledgerVoucher, inventTrans,  movement.inventModelTypeSecCur_RU().cacheFinancialOnhandOnFinancialUpdate()
                                                                                                         ? this.inventOnhandFinancialCache(inventTrans.inventDim())
                                                                                                         : null);
                    }
                    // </GEERU>
                }

                if (movement.inventModelType().cacheFinancialOnhandOnFinancialUpdate())
                {
                    this.updateInventOnhandFinancialCache(inventTrans);
                }

                // <GEERU>
                if (countryRegion_RU)
                {
                    updCostAmountInventSecCur   += inventTrans.costValueSecCur_RU();
                    if (InventTrans.InvoiceReturned)
                    {
                        backDateCostAmountAdjustmentSecCur_RU = CurrencyExchangeHelper::amount(InventTrans.CostAmountSecCurAdjustment_RU, CompanyInfoHelper::secondaryCurrency_RU());
                    }
                }
                // </GEERU>

                inventTrans.update();

                this.updateFinancialReceiptAmounts(inventTrans);
            }

            if (!addQty)
            {
                break;
            }
        }

        if (addQty)
        {
            Info("@SCM:InventOrderRegisterGeneralGuide");
            throw error("@SYS13236");
        }

        if (movement.mustRegisterTrackingDimension())
        {
            if (movement.transQty() < 0)
            {
                this.correctFinancialTrackingRegister(updFinancial);
            }
            else
            {
                this.updateTrackingRegisterFinancially(updFinancial);
            }
        }

        // <GEERU>
        if (this.mustCreateCostTransactions(movement))
        {
            if (countryRegion_RU)
            {
                boolean costOK = movement.inventModelType().finalizeCostTransVariance         (movement, ledgerVoucher, InventCostTransState::Financial, movement.isReturned(financial));
                movement.inventModelTypeSecCur_RU().finalizeCostTransVarianceSecCur_RU(movement, ledgerVoucher, InventCostTransState::Financial, costOK, movement.isReturned(financial));
            }
            else
            {
                // </GEERU>
                // Push the created variance to the inventCostUpdate class
                movement.inventModelType().finalizeCostTransVariance(movement, ledgerVoucher, InventCostTransState::Financial, movement.isReturned(financial));
                // <GEERU>
            }
        }
        // </GEERU>
        this.updateReportFinished();

        if (movement.mustUpdateInventTableCostPrice() && !returnMode && (movement.transSign() * financial > 0))
        {
            movement.inventTable().updateLastCostPrice(updCostAmountInvent,
                                                       updFinancial,
                                                       ledgerVoucher.lastTransDate(),
                                                       movement.inventdim()
                                                       );
            // <GEERU>
            if (countryRegion_RU)
            {
                movement.inventTable().updateLastCostPriceSecCur_RU(updCostAmountInventSecCur,
                                                                    updFinancial,
                                                                    ledgerVoucher.lastTransDate(),
                                                                    movement.inventdim()
                                                                    );
            }
            // </GEERU>
        }
        // <GEERU>
        if (countryRegion_RU)
        {
            return inventTrans.CostAmountSecCurPosted_RU;
        }
        else
        {
            return 0;
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinancialReceiptAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cost amounts and quantities after processing and updating the given <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">
    /// The newly processed inventory transaction.
    /// </param>
    protected void updateFinancialReceiptAmounts(InventTrans _inventTrans)
    {
        updCostAmountInvent += _inventTrans.costValue();

        if (_inventTrans.InvoiceReturned)
        {
            backDateCostAmountAdjustment += CurrencyExchangeHelper::amount(_inventTrans.CostAmountAdjustment);
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            container qtyCon = movement.financialUpdateReceiptQty_IN(_inventTrans);
            updFinancial += conPeek(qtyCon, 1);
            cwUpdFinancial += conPeek(qtyCon, 2);
        }
        else
        {
            //  </GIN>
            updFinancial   += _inventTrans.Qty;
            cwUpdFinancial += _inventTrans.PdsCWQty;
            //  <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventOnhandFinancialCache</Name>
				<Source><![CDATA[
    protected void updateInventOnhandFinancialCache(InventTrans _inventTrans)
    {
        InventSum   inventSum = this.inventOnhandFinancialCache(_inventTrans.inventDim()).inventSumWithoutAvailability(false);

        inventSum.addInventTransOnSum(_inventTrans);
        inventSum.subInventTransOnSum(_inventTrans.orig());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMovement</Name>
				<Source><![CDATA[
    protected void updateMovement()
    {
        boolean     commitBuffer = true;

        updFinancialUnit  = financialUnit;

        movement.addRemainFinancialUnit(-updFinancialUnit, -updFinancial);

        if (movement.pdsCWItem())
        {
            movement.pdsCWAddRemainFinancial(-cwUpdFinancial);
        }

        if (movement.mustBeExpectedAgain())
        {
            if (movement.remainPhysicalUnit()     == 0
             && movement.remainFinancialUnit()    == 0)
            {
                movement.updateDoBuffer();

                movement.setRemainPhysicalUnit(movement.transQtyUnit());
                movement.setRemainPhysical(movement.transQty());

                movement.pdsCWSetRemainPhysical(movement.pdsCWTransQty());

                movement.updateBuffer();

                commitBuffer = false;
            }
        }

        if (commitBuffer)
        {
            movement.updateDoBuffer();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeReceived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transactions that are related to the movement must be received.
    /// </summary>
    /// <returns>
    /// true if the transactions that are related to the movement must be received; otherwise, false
    /// </returns>
    protected boolean mustBeReceived()
    {
        return (financial > 0.0 && movement.mustBeReceived());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transactions that are related to the movement must be registered.
    /// </summary>
    /// <returns>
    /// true if the transactions that are related to the movement must be registered; otherwise, false
    /// </returns>
    protected boolean mustBeDeducted()
    {
        return (financial < 0.0 && movement.mustBeDeducted());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cost amounts on related inventory transaction records.
    /// </summary>
    /// <param name = "_costAmountMST">
    /// A <c>CostAmount</c> value.
    /// </param>
    /// <param name = "_costAmountSecCur">
    /// A <c>CostAmountSecCur_RU</c> value.
    /// </param>
    protected void updateFinancial(CostAmount _costAmountMST, CostAmountSecCur_RU _costAmountSecCur)
    {
        if (financial < 0)
        {
            // <GEERU>
            this.updateFinancialIssue(_costAmountMST, _costAmountSecCur);
            // </GEERU>
        }
        else
        {
            if (financial > 0)
            {
                // <GEERU>
                this.updateFinancialReceipt(_costAmountMST, _costAmountSecCur);
                // </GEERU>
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public CostAmountSecCur_RU updateNow()
    {
		using (var telemetryTask = new InventUpdateInstrumentationTask(this))
        {
            InventInventoryDataServiceSoftReservationHelper::checkSoftReservation(movement);

            // <GEERU>
            CostAmount costAmountMSTSecCur;
			// </GEERU>

			ttsbegin;

			using (var cache = movement.constructRecordViewCache())
			{
				if (physical          || remainPhysical         != movement.remainPhysical()      ||
					physicalUnit      || remainPhysicalUnit     != movement.remainPhysicalUnit())
				{
					if (this.mustBeReceived())
					{
						throw error("@SYS117599");
					}

					if (this.mustBeDeducted())
					{
						throw error("@SYS117598");
					}

					movement.parmExchangeRateDate(this.parmExchangeRateDate());

                    InventUpd_Physical inventUpd_Physical = this.createInventUpd_Physical();
                    this.initializeInventUpd_Physical(inventUpd_Physical);
					inventUpd_Physical.updateNow(ledgerVoucher);

					this.parmInventCostOnhandCache(inventUpd_Physical.parmInventCostOnhandCache());

					updPhysical             = inventUpd_Physical.updPhysical();
					updPhysicalUnit         = inventUpd_Physical.updPhysicalUnit();
					updPhysicalAmountLedger = inventUpd_Physical.updPhysicalAmountLedger();

					cwUpdPhysical           = inventUpd_Physical.pdsCWUpdPhysical();

					financialUnit  = financialUnit  - (physicalUnit- updPhysicalUnit);
					financial      = financial      - (physical    - updPhysical);

					cwFinancial    = cwFinancial    - (cwPhysical  - cwUpdPhysical);

					if (movement.mustDoAutoLossProfitPhysical())
					// Expected order: original financial-> original physical->virtual physical->virtual financial
					// update the physical number, so that during virtual financial, it won't do virtual physical again.
					{
						physical       -=       updPhysical;
						physicalUnit   -=       updPhysicalUnit;

						cwPhysical     -=       cwUpdPhysical;
					}
				}

				if (!this.checkUpdateMovement())
				{
					throw error("@SYS18447");
				}

				if (pdsUpdatePhysicalOnly)
				{
					ttscommit;
					return 0;
				}

				this.updateProjAdjustRefId();

				// <GIN>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
					&& TaxParameters::find().Customs_IN)
				{
					movement.parmCustomsLoadOnInventory_IN(customsLoadOnInventory);
					movement.parmCustomsLoadOnInventoryMST_IN(customsLoadOnInventoryMST);
				}
				// </GIN>

                CostAmount costAmountMST = movement.updateLedgerFinancial(ledgerVoucher, this);

				// <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
				{
					costAmountMSTSecCur = movement.updateLedgerFinancialSecCur_RU(ledgerVoucher, this);
				}
				// </GEERU>

                this.updateFinancial(costAmountMST, costAmountMSTSecCur);
               
				this.updateInventTransPosting(ledgerVoucher.lastTransDate(), ledgerVoucher.lastVoucher());

				if (movement.isPrimaryMovement())
				{
					this.updateMovement();
				}

                if (movement.projId() 
                    && movement.mustBeCostControlled() 
                    && movement.canCommittedCostBeReversed()
                    && !movement.canItemReqBeCancelled())
				{
                    CostControlPostingItem costControlPostingItem= CostControlPosting::newCostControlPostingItem(movement); 
					costControlPostingItem.parmLedgerVoucher(this.parmLedgerVoucher());
					costControlPostingItem.run(ProjCommittedCostUpdateAction::Post);
				}

				if (movement.mustDoProjPhysicalPosting())
				{
					ProjPost::financialInventPost(this);
				}

                if (this.mustCreateCostTransactions(movement))
                {
				    movement.inventCostIndirectFinancial().post(ledgerVoucher);
                }

				if ((movement.mustDoAutoLossProfitFinancial()) || (movement.allowAutoLossProfit() && this.parmAutoLossProfit()))
				{
					movement.updateAutoLossProfit(this);
				}
			}

			// <GEERU>
			movement.updateGoodsInRoute_RU(this);
			// </GEERU>

			if (inventCostOnhandCache)
			{
				inventCostOnhandCache.clearCache(movement);
			}

			ttscommit;

			// <GEERU>
			return costAmountMSTSecCur;
			// </GEERU>
		}
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventUpd_Physical</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes some fields of the <c>InventUpd_Physical</c> instance.
    /// </summary>
    /// <param name = "_inventUpd_Physical">
    ///     The <c>InventUpd_Physical</c> instance.
    /// </param>
    protected void initializeInventUpd_Physical(InventUpd_Physical _inventUpd_Physical)
    {
        _inventUpd_Physical.parmSkipCWAutoAdjust(skipCWAutoAdjust);
        _inventUpd_Physical.parmAllowAutoReserveDim(this.parmAllowAutoReserveDim());
        _inventUpd_Physical.parmExchangeRateDate(this.parmExchangeRateDate());
        _inventUpd_Physical.parmInventCostOnhandCache(this.parmInventCostOnhandCache());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjAdjustRefId</Name>
				<Source><![CDATA[
    protected void updateProjAdjustRefId()
    {
        InventTrans         inventTrans;

        if (!movement.mustSetProjAdjustRefInventTrans())
        {
            return;
        }

        if (this.parmFinancial() <= 0)
        {
            return;
        }

        if (ProjAdjRefIDCorrectionMultiplePackingSlipsFlight::instance().isEnabled())
        {
            while select forupdate inventTrans
            order by InventDimId
            where inventTrans.InventTransOrigin == movement.inventTransOriginId()
              &&  inventTrans.StatusIssue       == StatusIssue::None
              &&  inventTrans.StatusReceipt     == StatusReceipt::Received
              &&  (packingSlipId == '' || inventTrans.PackingSlipId == packingSlipId)
            {
                // Set the InvoiceID to generate setProjAdjustRefId
                InvoiceId origInvoiceId = inventTrans.InvoiceId;
                inventTrans.InvoiceId = invoiceNum;

                movement.setProjAdjustRefId(inventTrans);

                inventTrans.InvoiceId = origInvoiceId;  // Set back to the original InvoiceId

                inventTrans.update();
            }
        }
        else
        {
            while select forupdate inventTrans
            order by InventDimId
            where inventTrans.InventTransOrigin == movement.inventTransOriginId()
              &&  inventTrans.StatusIssue       == StatusIssue::None
              &&  inventTrans.StatusReceipt     == StatusReceipt::Received
            {
                // Set the InvoiceID to generate setProjAdjustRefId
                InvoiceId origInvoiceId = inventTrans.InvoiceId;
                inventTrans.InvoiceId = invoiceNum;

                movement.setProjAdjustRefId(inventTrans);

                inventTrans.InvoiceId = origInvoiceId;  // Set back to the original InvoiceId

                inventTrans.update();
            }
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReportFinished</Name>
				<Source><![CDATA[
    protected void updateReportFinished()
    {
        if ( returnMode
         || !movement.inventTable().AutoReportFinished
         || !movement.canBeAutoRepAsFinished()
         || !movement.inventTable().isFormulaOrBOMAllowed())
        {
            return;
        }

        if (!InventParameters::find().bomJournalNameId)
        {
            throw error("@SYS28923");
        }

        BOMReportFinish reportFinished = BOMReportFinish::newAutoReportFinished(movement.itemId(),
                                                                                movement.inventDimId(),
                                                                                ledgerVoucher.lastTransDate(),
                                                                                -this.parmFinancial(),
                                                                                movement.defaultDimension());

        reportFinished.run();

        InventJournalTable bomJournalHeader = reportFinished.journalTableData().journalTable();
        InventTransOrigin  bomJournalInventTransOrigin;
        InventJournalTrans bomJournalTrans;

        select firstonly RecId from bomJournalInventTransOrigin
            exists join bomJournalTrans
                    where bomJournalTrans.InventTransId == bomJournalInventTransOrigin.InventTransId
                        && bomJournalTrans.JournalId     == bomJournalHeader.JournalId
                        && bomJournalTrans.JournalType   == InventJournalType::BOM
                        && bomJournalTrans.ItemId        == movement.itemId()
                        && bomJournalTrans.BOMLine       == NoYes::No;

        if (bomJournalInventTransOrigin)
        {
            InventQty markedQty = InventTransOrigin::updateMarking(movement.inventTransOriginId(), bomJournalInventTransOrigin.RecId, this.parmFinancial(), ledgerVoucher.lastVoucher());
            InventTransOrigin::updateMarking(bomJournalInventTransOrigin.RecId, movement.inventTransOriginId(), markedQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCostAmountStd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the standard cost amount for an inventory transaction.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction.</param>
    /// <param name = "_changeCostAmountStd">Value added to the standard cost amount.</param>
    /// <returns>The standard cost amount.</returns>
    protected CostAmountStd calculateCostAmountStd(InventTrans _inventTrans, CostAmount _changeCostAmountStd)
    {
        return CurrencyExchangeHelper::amount(movement.inventTable().costPcsPrice(_inventTrans.InventDimId) * _inventTrans.Qty) + _changeCostAmountStd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStdCostPrice</Name>
				<Source><![CDATA[
    protected void updateStdCostPrice(
        InventTrans     _inventTrans,
        boolean         _creditNote = false,
        CostAmount      _changeCostAmountStd = 0,
        CostAmount      _changeCostAmountStdSecCur = 0)
    {
        InventSettlement        inventSettlement;
        // <GEERU>
        boolean                 countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        LedgerVoucherObject     ledgerVoucherObject;

        if (!movement.adjustToFixedReceiptPrice())
        {
            _inventTrans.CostAmountStd = _inventTrans.costValue();
            // <GEERU>
            if (countryRegion_RU)
            {
                _inventTrans.CostAmountStdSecCur_RU  = _inventTrans.costValueSecCur_RU();
            }
            // </GEERU>
        }
        else
        {
            _inventTrans.CostAmountStd = this.calculateCostAmountStd(_inventTrans, _changeCostAmountStd);

            if (_inventTrans.CostAmountStd   != _inventTrans.CostAmountPosted
              && movement.postingOperations() != LedgerPostingType::ProdScrap)
            {
                inventSettlement.initFromInventTrans(_inventTrans, movement.defaultDimension());

                inventSettlement.CostAmountAdjustment   = _inventTrans.CostAmountStd - _inventTrans.CostAmountPosted;
                inventSettlement.TransDate              = _inventTrans.DateFinancial;
                inventSettlement.Voucher                = _inventTrans.Voucher;
                inventSettlement.SettleModel            = InventSettleModel::Adjustment;
                inventSettlement.SettleType             = InventSettleType::CompleteAdjustment;

                if (movement.mustBeBookedOnhand())
                {
                    inventSettlement.BalanceSheetPosting            = movement.postingStdOffset();
                    inventSettlement.BalanceSheetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                            movement.accountStdOffset(),
                                                                            movement.defaultDimension());
                    inventSettlement.Posted                         = NoYes::Yes;

                    if (inventSettlement.CostAmountAdjustment < 0 || (inventSettlement.CostAmountAdjustment > 0 && _creditNote))
                    {
                        inventSettlement.OperationsLedgerDimension  = this.getLedgerDimensionFromDefaultAccount(
                                                                            movement.accountStdLoss(),
                                                                            movement.defaultDimension());
                        inventSettlement.OperationsPosting          = movement.postingStdLoss();
                    }
                    else
                    {
                        inventSettlement.OperationsLedgerDimension  = this.getLedgerDimensionFromDefaultAccount(
                                                                            movement.accountStdProfit(),
                                                                            movement.defaultDimension());
                        inventSettlement.OperationsPosting          = movement.postingStdProfit();
                    }

                    ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
                    CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());

                    ledgerVoucher.addTrans(
                        LedgerVoucherTransObject::newTransactionAmountDefault(
                            ledgerVoucherObject,
                            inventSettlement.OperationsPosting,
                            inventSettlement.OperationsLedgerDimension ,
                            CompanyInfoHelper::standardCurrency(),
                           -inventSettlement.CostAmountAdjustment,
                            currencyExchHelper));

                    ledgerVoucher.addTrans(
                        LedgerVoucherTransObject::newTransactionAmountDefault(
                            ledgerVoucherObject,
                            inventSettlement.BalanceSheetPosting,
                            inventSettlement.BalanceSheetLedgerDimension,
                            CompanyInfoHelper::standardCurrency(),
                            inventSettlement.CostAmountAdjustment,
                            currencyExchHelper));
                    // <GEERU>
                    if (countryRegion_RU &&
                        inventSettlement.CostAmountAdjustment)
                    {
                        ledgerVoucher.bondLast2_RU();
                    }
                    // </GEERU>
                }

                inventSettlement.insert(inventSettlement.SettleTransId);

                _inventTrans.CostAmountAdjustment+= inventSettlement.CostAmountAdjustment;

                updCostAmountLedger+= inventSettlement.CostAmountAdjustment;
            }
            // <GEERU>
            if (countryRegion_RU)
            {
                _inventTrans.CostAmountStdSecCur_RU = CurrencyExchangeHelper::amount(movement.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId) * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU())+ _changeCostAmountStdSecCur;

                if (_inventTrans.CostAmountStdSecCur_RU != _inventTrans.CostAmountSecCurPosted_RU)
                {
                    inventSettlement.clear();
                    inventSettlement.InventTransCurrency_RU = InventTransCurrency_RU::SecondaryCur;
                    inventSettlement.initFromInventTrans(_inventTrans, movement.defaultDimension());
                    inventSettlement.CostAmountAdjustment   = _inventTrans.CostAmountStdSecCur_RU - _inventTrans.CostAmountSecCurPosted_RU;
                    inventSettlement.TransDate              = _inventTrans.DateFinancial;
                    inventSettlement.Voucher                = _inventTrans.Voucher;
                    inventSettlement.SettleModel            = InventSettleModel::Adjustment;
                    inventSettlement.SettleType             = InventSettleType::CompleteAdjustment;

                    if (movement.mustBeBookedOnhandSecCur_RU())
                    {
                        inventSettlement.BalanceSheetPosting            = movement.postingStdOffset();
                        inventSettlement.BalanceSheetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                            movement.accountStdOffset(),
                                                                            movement.defaultDimension());
                        inventSettlement.Posted                         = NoYes::Yes;

                        if (inventSettlement.CostAmountAdjustment < 0 || (inventSettlement.CostAmountAdjustment > 0 && _creditNote))
                        {
                            inventSettlement.OperationsLedgerDimension  = this.getLedgerDimensionFromDefaultAccount(
                                                                                movement.accountStdLoss(),
                                                                                movement.defaultDimension());
                            inventSettlement.OperationsPosting          = movement.postingStdLoss();
                        }
                        else
                        {
                            inventSettlement.OperationsLedgerDimension  = this.getLedgerDimensionFromDefaultAccount(
                                                                                movement.accountStdProfit(),
                                                                                movement.defaultDimension());
                            inventSettlement.OperationsPosting          = movement.postingStdProfit();
                        }

                        ledgerVoucherObject = ledgerVoucher.findOrCreateReferenceSecCur_RU();

                        ledgerVoucher.addTrans(
                            LedgerVoucherTransObject::newBasicSecondary_RU(
                                ledgerVoucherObject,
                                inventSettlement.OperationsPosting,
                                inventSettlement.OperationsLedgerDimension,
                                CompanyInfoHelper::standardCurrency(),
                                -inventSettlement.CostAmountAdjustment,
                                NoYes::No));

                        ledgerVoucher.addTrans(
                            LedgerVoucherTransObject::newBasicSecondary_RU(
                                ledgerVoucherObject,
                                inventSettlement.BalanceSheetPosting,
                                inventSettlement.BalanceSheetLedgerDimension,
                                CompanyInfoHelper::standardCurrency(),
                                inventSettlement.CostAmountAdjustment,
                                NoYes::No));

                        if (inventSettlement.CostAmountAdjustment)
                        {
                            ledgerVoucher.bondLast2_RU();
                        }

                        ledgerVoucher.restoreReferenceSecCur_RU();
                    }

                    inventSettlement.insert(inventSettlement.SettleTransId);

                    _inventTrans.CostAmountSecCurAdjustment_RU += inventSettlement.CostAmountAdjustment;

                    updCostAmountSecCurLedger += inventSettlement.CostAmountAdjustment;
                }
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrackingRegisterFinancially</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates tracking register transactions to the state of being financially updated.
    /// </summary>
    /// <param name="_financialQty">
    ///    The quantity to financially update.
    /// </param>
    private void updateTrackingRegisterFinancially(InventQty _financialQty)
    {
        CustPackingSlipTrans    custPackingSlipTrans;
        Common                  physicalJournalLine;
        InventQty               remainingFinancialQty;

        if (packingSlipId)
        {
            if (packingSlipRecId)
            {
                select firstonly CustPackingSlipTrans
                    where custPackingSlipTrans.RecId == packingSlipRecId;
            }
            else
            {
                select firstonly CustPackingSlipTrans
                    where custPackingSlipTrans.InventTransId == movement.transId()
                       && custPackingSlipTrans.PackingSlipId == packingSlipId;
            }

            physicalJournalLine = custPackingSlipTrans;
            remainingFinancialQty = -custPackingSlipTrans.remainInventFinancial() - _financialQty;
        }
        else
        {
            physicaljournalline = financialJournalLine;
            remainingFinancialQty = 0.0;
        }

        InventTrackingRegisterTrans::associateFinancialJournalTrackingTrans(movement.inventTransOriginId(), financialJournalLine, physicalJournalLine, _financialQty, remainingFinancialQty, movement.inventDimGroupSetup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountInvent</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountInvent(CostAmount _costAmount = updCostAmountInvent)
    {
        updCostAmountInvent = _costAmount;
        return updCostAmountInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountInventSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountInventSecCur_RU(CostAmount _costAmount = updCostAmountInventSecCur)
    {
        updCostAmountInventSecCur = _costAmount;
        return updCostAmountInventSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountLedger(CostAmount _costAmount = updCostAmountLedger)
    {
        updCostAmountLedger = _costAmount;
        return updCostAmountLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountPhysical</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountPhysical(CostAmount _updCostAmountPhysical = updCostAmountPhysical)
    {
        updCostAmountPhysical = _updCostAmountPhysical;
        return updCostAmountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountSecCurLedger_RU</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountSecCurLedger_RU(CostAmount _costAmount = updCostAmountSecCurLedger)
    {
        updCostAmountSecCurLedger = _costAmount;
        return updCostAmountSecCurLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updFinancial</Name>
				<Source><![CDATA[
    public InventQty   updFinancial()
    {
        return updFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updFinancialUnit</Name>
				<Source><![CDATA[
    public UnitQty      updFinancialUnit()
    {
        return updFinancialUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updOperationsAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updOperationsAmountLedger(CostAmount _costAmount = updOperationsAmountLedger)
    {
        updOperationsAmountLedger = _costAmount;
        return updOperationsAmountLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updOperationsAmountSecCurLedger_RU</Name>
				<Source><![CDATA[
    public CostAmount updOperationsAmountSecCurLedger_RU(CostAmount _costAmount = updOperationsAmountSecCurLedger)
    {
        updOperationsAmountSecCurLedger = _costAmount;
        return updOperationsAmountSecCurLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysical</Name>
				<Source><![CDATA[
    public InventQty   updPhysical()
    {
        return updPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updPhysicalAmountLedger(CostAmount _costAmount = updPhysicalAmountLedger)
    {
        updPhysicalAmountLedger = _costAmount;
        return updPhysicalAmountLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalRevenueAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updPhysicalRevenueAmountLedger(AmountMSTPhysicalRevenue _amountMST = 0)
    {
        updPhysicalRevenueAmountLedger = _amountMST;
        return updPhysicalRevenueAmountLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty      updPhysicalUnit()
    {
        return updPhysicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherForVirTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger voucher for a virtual transfer.
    /// </summary>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <returns>
    /// A <c>LedgerVoucher</c> object.
    /// </returns>
    public static ledgerVoucher createLedgerVoucherForVirTransfer(TransDate               _transDate)
    {
        NumberSeq numberSeq = NumberSeq::newGetNum(InventParameters::numRefInventJournalVoucherId());
        InventJournalVoucherId voucherId = numberSeq.num();

        TransactionTxt transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::InventJournalTransfer);
        transactionTxt.setDate(_transDate);
        transactionTxt.setVoucher(voucherId);

        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                              SysModule::Invent,
                                                                              numberSeq.parmNumberSequenceCode());
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherId,
                                                                                    _transDate,
                                                                                    SysModule::Invent,
                                                                                    LedgerTransType::Invent);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAdjustProjItemTrans</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newAdjustProjItemTrans(
        InventMovement  _movement,
        LedgerVoucher   _ledgerVoucher,
        CostAmount      _costAmount,
        CostAmount      _costAmountSecCur_RU = 0)
    {
        InventUpd_Financial financial       = new InventUpd_Financial(_movement);
        ProjItemTrans       projItemTrans   = _movement.buffer();
        // <GEERU>
        boolean         countryRegion_RU        = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(0);
        financial.parmAllowNegativeFinancial(true);
        financial.parmAllowNegativePhysical(true);
        financial.parmPackingSlipId(projItemTrans.PackingSlipId);
        financial.parmProjTransDate(_movement.transDate());
        // <GEERU>
        if (countryRegion_RU)
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoLossProfit</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newAutoLossProfit(
        InventMovement          _movement,
        InventUpd_Financial     _financial)
    {
        InventUpd_Financial financial           = new InventUpd_Financial(_movement);
        CostAmount          costAmount = 0;
        // <GEERU>
        CostAmount          costAmountSec;
        // </GEERU>
        InventTrans         inventTrans;

        PdsCWInventQty      cwRemainPhysical;

        InventQty           qty;
        // <GEERU>
        CostAmount          value, valueSec;
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        financial.setParmAllowDefault();

        financial.parmAllowNegativeFinancial(true);
        financial.parmAllowNegativePhysical(true);

        financial.parmLedgerVoucher(_financial.parmLedgerVoucher());
        financial.parmInvoiceId(_financial.parmInvoiceId());
        if (_movement.projId() && !_movement.mustBeQuarantineControlled())
        {
            financial.parmPackingSlipId(_financial.parmPackingSlipId());
        }
        if (_financial.updFinancial())
        {
            // <GEERU>
            if (countryRegion_RU)
            {
                if (_movement.projId())
                {
                    [ qty, value, valueSec ] = ProjTrans::calcInvoicedCostValue(_financial);
                }
                if (value && _movement.inventModelGroup().inventModelType().stdCostBased())
                {
                    costAmount = CurrencyExchangeHelper::amount(value / -qty * _movement.transQty());
                }
                else
                {
                    costAmount = CurrencyExchangeHelper::amount(_financial.updCostAmountLedger() / -_financial.updFinancial() * _movement.transQty());
                }
            }
            else
            {
                // </GEERU>
                if (_movement.projId() && _movement.inventModelGroup().inventModelType().stdCostBased())
                {
                    [qty,value] = ProjTrans::calcInvoicedCostValue(_financial);
                    costAmount = CurrencyExchangeHelper::amount(value / -qty * _movement.transQty());
                }
                else
                {
                    costAmount = CurrencyExchangeHelper::amount(_financial.updCostAmountLedger() / -_financial.updFinancial() * _movement.transQty());
                }
                // <GEERU>
            }
            // </GEERU>

            // <GEERU>
            if (countryRegion_RU
                && valueSec
                && _movement.inventModelGroup().inventModelTypeSecCur_RU().stdCostBased())
            {
                costAmountSec = CurrencyExchangeHelper::amount(valueSec / -qty * _movement.transQty(), CompanyInfoHelper::secondaryCurrency_RU());
            }
            // </GEERU>
        }
        financial.parmCostAmountCur(-costAmount);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(- costAmountSec);
        }
        // </GEERU>
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());

        boolean cwItem = PdsGlobal::pdsIsCWItem(_movement.itemId());

        if (_financial.movement().mustDoAutoLossProfitFinancial() && _movement.projId())
        // create virtual inventTrans for project
        {
            InventQty remainPhysical = -_financial.parmRemainPhysical();
            UnitQty remainPhysicalUnit = -_financial.parmRemainPhysicalUnit();
            financial.parmPhysical(-_financial.parmPhysical());
            financial.parmPhysicalUnit(-_financial.parmPhysicalUnit());
            financial.parmFinancialUnit(-_financial.parmFinancialUnit());

            if (cwItem)
            {
                cwRemainPhysical  = -_financial.parmPdsCWRemainPhysical();
                financial.parmPdsCWPhysical(-_financial.parmPdsCWPhysical());
                financial.parmPdsCWFinancial(-_financial.parmPdsCWFinancial());
            }

            if (financial.parmFinancial() < 0)
            {
                select sum(PdsCWQty), sum(Qty) from inventTrans
                    where inventTrans.InventTransOrigin == _movement.inventTransOriginId()
                        && inventTrans.StatusIssue       == StatusIssue::Deducted
                        && inventTrans.StatusReceipt     == StatusReceipt::None;

                PdsCWInventQty cwDeducted = cwItem ? inventTrans.PdsCWQty : 0;
                InventQty deducted = inventTrans.Qty;

                if (financial.parmFinancial()< deducted && financial.parmFinancial()-deducted < financial.parmPhysical())
                {
                    financial.parmPhysical(financial.parmFinancial()-deducted);
                    financial.parmPhysicalUnit(financial.calcEstimatedUnit(financial.parmPhysical()));

                    if (cwItem)
                    {
                        financial.parmPdsCWPhysical(
                            financial.parmPdsCWFinancial() - cwDeducted);
                    }
                    remainPhysical      = 0;
                    cwRemainPhysical    = 0;
                }
            }
            else //Receipt  whose status is received is not enough to purchased, happens after upgrade
            {
                select sum(PdsCWQty), sum(Qty) from inventTrans
                    where inventTrans.InventTransOrigin == _movement.inventTransOriginId()
                        && inventTrans.StatusIssue       == StatusIssue::None
                        && inventTrans.StatusReceipt     == StatusReceipt::Received;

                PdsCWInventQty cwReceived = cwItem ? InventTrans.PdsCWQty : 0;
                InventQty received = inventTrans.Qty;
                if (financial.parmFinancial()> received && financial.parmFinancial()-received > financial.parmPhysical())
                {
                    financial.parmPhysical(financial.parmFinancial()-received);
                    financial.parmPhysicalUnit(financial.calcEstimatedUnit(financial.parmPhysical()));

                    if (cwItem)
                    {
                        financial.parmPdsCWPhysical(
                            financial.parmPdsCWFinancial() - cwReceived);
                    }

                    remainPhysical      = 0;
                    cwRemainPhysical    = 0;
                }
            }

            financial.parmRemainPhysical(remainPhysical);
            financial.parmRemainPhysicalUnit(remainPhysical);
            financial.movement().setRemainPhysical(remainPhysical);
            financial.movement().setRemainPhysicalUnit(remainPhysical);

            if (cwItem)
            {
                financial.parmPdsCWRemainPhysical(cwRemainPhysical);
                financial.movement().pdsCWSetRemainPhysical(cwRemainPhysical);
            }
        }
        else if (_financial.parmAutoLossProfit()||!_movement.projId())
        //scrap is On
        {
            financial.parmRemainPhysical(0);
            financial.parmFinancialUnit(-_financial.parmFinancialUnit());
            financial.parmRemainPhysicalUnit(0);

            if (cwItem)
            {
                financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
                financial.parmPdsCWRemainPhysical(0);
            }

            financial.initUpdate();
        }

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckPostInventJournalTrans</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newCheckPostInventJournalTrans(
        InventMovement      _movement,
        LedgerVoucher       _ledgerVoucher,
        CostAmount          _costAmount,
        CostAmount          _costAmountSecCur = 0,
        boolean             _transferReceipt   = NoYes::No)
    {
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        InventUpd_Financial financial = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (! _costAmountSecCur && _transferReceipt == NoYes::No)
            {
                financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate()));
            }
            else
            {
                financial.parmCostAmountCurSecCur_RU(_costAmountSecCur);
            }
        }
        // </GEERU>
        financial.parmFinancial(_movement.transQty());
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(0);

        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.parmPdsCWRemainPhysical(0);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCWAutoAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes a new instance of the <c>InventUpd_Financial</c> class.
    /// </summary>
    /// <param name="_movement">
    /// The <c>InventMovement</c> object that is used to initialize class.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// A <c>LedgerVoucherRecord</c> used to initialize class.
    /// </param>
    /// <returns>
    /// A new initialized instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    public static InventUpd_Financial newCWAutoAdjust(
        InventMovement      _movement,
        LedgerVoucher       _ledgerVoucher)
    {
        CostAmount          costAmount = 0;

        InventUpd_Financial financial = new InventUpd_Financial(_movement);
        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);

        if (_movement.transQty() > 0)
        {
            costAmount = CurrencyExchangeHelper::amount(_movement.transQty() * _movement.inventTable().costPcsPrice(_movement.inventDimId(), _movement.inventdim()));
        }

        financial.parmCostAmountCur(costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(0);
        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.parmPdsCWRemainPhysical(0);

        financial.initUpdate();
        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newGoodsInRouteDelivery_RU</Name>
				<Source><![CDATA[
    static InventUpd_Financial newGoodsInRouteDelivery_RU(InventMovement    _movement,
                                                          LedgerVoucher     _ledgerVoucher,
                                                          InvoiceId         _invoiceId)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();

        financial.parmAllowNegativeFinancial(true);
        financial.parmAllowNegativePhysical(true);

        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmInvoiceId(_invoiceId);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.initUpdate();
        financial.parmPhysical(0);
        financial.parmPhysicalUnit(0);
        financial.parmPdsCWPhysical(0);

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newGoodsInRouteTransit_RU</Name>
				<Source><![CDATA[
    static InventUpd_Financial newGoodsInRouteTransit_RU(InventMovement        _movement,
                                                         InventUpd_Financial   _financial,
                                                         CostAmount            _costAmount,
                                                         CostAmount            _costAmountSec)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();

        financial.parmAllowNegativeFinancial(true);
        financial.parmAllowNegativePhysical(true);

        financial.parmLedgerVoucher(_financial.parmLedgerVoucher());
        financial.parmInvoiceId(_financial.parmInvoiceId());
        financial.parmCostAmountCur         (_costAmount);
        financial.parmCostAmountCurSecCur_RU(_costAmountSec);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.initUpdate();
        if (financial.parmFinancial() < 0)
        {
            financial.parmPhysicalUnit(-financial.parmPhysicalUnit());
            financial.parmPdsCWPhysical(-financial.parmPdsCWPhysical());
        }
        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventUpd_Financial</c> class for doing financial updates of a
    /// quality order.
    /// </summary>
    /// <param name="_movement">
    /// The <c>InventMovement</c> object that wraps the quality order.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The financial voucher to use when you post.
    /// </param>
    /// <param name="_qty">
    /// The quantity to financially post.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    public static InventUpd_Financial newInventQualityOrder(
        InventMovement      _movement,
        LedgerVoucher       _ledgerVoucher,
        InventQty           _qty)
    {
        InventUpd_Financial financial   = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_qty);
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(financial.parmRemainPhysical());

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventQuarantineOrder</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newInventQuarantineOrder(
        InventMovement      _movement,
        LedgerVoucher       _ledgerVoucher,
        InventQty           _qty,
        InventQty           _remainQty,
        CostAmount          _costAmount,
        PdsCWInventQty      _cwQty,
        PdsCWInventQty      _cwRemainQty,
        CostAmount          _costAmountSecCur_RU = 0
        )
    {
        InventUpd_Financial financial   = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_qty);
        financial.parmRemainPhysical(_remainQty);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(financial.parmRemainPhysical());
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.parmPdsCWFinancial(_cwQty);
        financial.parmPdsCWRemainPhysical(_cwRemainQty);
        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTransferLineReceive</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newInventTransferLineReceive(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        CostAmount              _costAmount,
        InventQty               _updateQty,
        InventDim               _inventDim,
        InventDimParm           _inventDimParm,
        PdsCWInventQty          _cwQty = 0,
        CostAmount              _costAmountSecCur_RU = 0
        )
    {
        InventUpd_Financial     financial           = InventUpd_Financial::construct(_movement);
        InventTransferLine      inventTransferLine  = _movement.buffer();

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>
        financial.parmFinancial(_updateQty * _movement.transSign());

        // <GIN>
        if (inventTransferLine.checkForUnitID_IN())
        {
            financial.parmRemainPhysical(max(0, inventTransferLine.converUnit_IN(inventTransferLine.QtyRemainReceive) - _updateQty) * _movement.transSign());
        }
        else
        {
            // </GIN>
            financial.parmRemainPhysical(max(0,inventTransferLine.QtyRemainReceive - _updateQty) * _movement.transSign());
            // <GIN>
        }
        // </GIN>
        financial.parmFinancialUnit(financial.parmFinancial());

        if (_movement.pdsCWItem())
        {
            financial.parmPdsCWFinancial(_cwQty * _movement.transSign());
            financial.parmPdsCWRemainPhysical(
                max(0,
                    inventTransferLine.PdsCWQtyRemainReceive - _cwQty)
                * _movement.transSign());
        }
        financial.parmRemainPhysicalUnit(financial.parmRemainPhysical());
        financial.parmInventDim(_inventDim);
        financial.parmInventDimParm(_inventDimParm);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTransferLineScrap</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newInventTransferLineScrap(
        InventMovement          _movement,

        LedgerVoucher           _ledgerVoucher
        , boolean                 _return = false
        )
    {
        InventUpd_Financial financial   = new InventUpd_Financial(_movement);
        CostAmount          costAmount;

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(costAmount, _ledgerVoucher.lastTransDate()));
            financial.parmFinancial(_return ? -_movement.transQty() : _movement.transQty());
            financial.parmFinancialUnit(financial.parmFinancial());
            financial.parmPdsCWFinancial(_return ? -_movement.pdsCWTransQty() : _movement.pdsCWTransQty());
        }
        else
        {
            // </GEERU>
            financial.parmFinancial(_movement.transQty());
            financial.parmFinancialUnit(_movement.transQty());
            financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
            // <GEERU>
        }
        // </GEERU>

        financial.parmRemainPhysical(0);
        financial.parmRemainPhysicalUnit(0);

        financial.parmPdsCWRemainPhysical(0);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTransferLineShip</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newInventTransferLineShip(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        InventTransferParmLine  _inventTransferParmLine,
        CostAmount              _costAmount,
        InventQty               _updateQty,
        InventDim               _inventDim,
        InventDimParm           _inventDimParm,
        PdsCWInventQty          _cwQty = 0,
        CostAmount              _costAmountSecCur_RU = 0
        )
    {
        InventUpd_Financial     financial           = InventUpd_Financial::construct(_movement);
        InventTransferLine      inventTransferLine = _movement.buffer();

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.parmFinancial(_updateQty * _movement.transSign());
        financial.parmPdsCWFinancial(_cwQty * _movement.transSign());
        financial.parmPdsCWRemainPhysical(
            inventTransferLine.pdsCWCalcNewShipRemain(
                _inventTransferParmLine)*_movement.transSign());

        InventTransferParmTable inventTransferParmTable = _inventTransferParmLine.inventTransferParmTable();
        boolean isTransferOrderShipmentCancellation = inventTransferParmTable.CanceledShipmentJournalRecId != 0;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) || isTransferOrderShipmentCancellation)
        {
            financial.parmRemainPhysical(inventTransferLine.calcNewShipRemain(_inventTransferParmLine, _updateQty) * _movement.transSign());
            financial.parmPdsCWRemainPhysical(inventTransferLine.pdsCWCalcNewShipRemain(_inventTransferParmLine, _cwQty) *_movement.transSign());
        }
        else
        {
            financial.parmRemainPhysical(inventTransferLine.calcNewShipRemain(_inventTransferParmLine)* _movement.transSign());
            financial.parmPdsCWRemainPhysical(
                inventTransferLine.pdsCWCalcNewShipRemain(
                    _inventTransferParmLine)*_movement.transSign());
        }

        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(financial.parmRemainPhysical());

        financial.parmInventDim(_inventDim);
        financial.parmInventDimParm(_inventDimParm);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemReqUnderconsume</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>InventUpd_Financial</c> class that will be used for
    ///    underconsumptions.
    /// </summary>
    /// <param name="_movement">
    ///    The inventory movement for the financial update.
    /// </param>
    /// <param name="_inventConsump">
    ///    The financial quantity for the financial update.
    /// </param>
    /// <param name="_costAmountCur">
    ///    The cost amount for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_voucherPhysical">
    ///    The physical voucher that will limit the inventory transactions that will be updated; optional.
    /// </param>
    /// <param name="_costAmountSecCur_RU">
    ///    The cost amount in reporting currency for the financial update.
    /// </param>
    /// <returns>
    ///    A new <c>InventUpd_Financial</c> instance.
    /// </returns>
    /// <remarks>
    ///    The <c>InventUpd_Financial</c> instance will be used to consume the production order items that
    ///    were underconsumed by an item requirement.The <c>InventUpd_Financial</c> instance will also be used
    ///    to post an income to the project for the underconsumption.
    /// </remarks>
    public static InventUpd_Financial newItemReqUnderconsume(
        InventMovement     _movement,
        InventQty          _inventConsump,
        AmountCur          _costAmountCur,
        LedgerVoucher      _ledgerVoucher,
        VoucherPhysical    _voucherPhysical     = '',
        CostAmount         _costAmountSecCur_RU = 0)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmountCur);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_inventConsump);
        financial.parmFinancialUnit(_inventConsump);
        financial.parmPhysical(financial.parmFinancial());
        financial.parmPhysicalUnit(financial.parmFinancialUnit());
        financial.parmVoucherPhysical(_voucherPhysical);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                              ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmountCur, _ledgerVoucher.lastTransDate())   :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanJob</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newKanbanJob(
        InventMovement          _inventMovement,
        LedgerVoucher           _ledgerVoucher,
        InventQty               _qty,
        InventQty               _remainQty,
        CostAmount              _costAmount,
        CostAmount              _costAmountSecCur_RU = 0)

    {
        InventUpd_Financial financial   = new InventUpd_Financial(_inventMovement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());

        financial.parmFinancial(_qty);
        financial.parmRemainPhysical(_remainQty);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(financial.parmRemainPhysical());

        financial.parmInventDim(null);
        financial.parmInventDimParm(null);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a new instance of <c>InventUpd_Financial</c> class for kanban job record.
    /// </summary>
    /// <param name="_inventMovement">
    ///     The inventory movement related to the kanban job.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///     The ledger voucher related to the transaction for related kanban job movement.
    /// </param>
    /// <param name="_qty">
    ///     The inventory quantity.
    /// </param>
    /// <param name="_remainQty">
    ///     The remaining inventory quantity.
    /// </param>
    /// <param name="_costAmount">
    ///     The cost amount.
    /// </param>
    /// <param name="_costAmountSecCur_RU">
    ///     The cost amount in a second currency.
    /// </param>
    /// <returns>
    ///     A new instance of <c>InventUpd_Financial</c> class for the kanban job record.
    /// </returns>
    public static InventUpd_Financial newKanbanMovement(
        InventMovement          _inventMovement,
        LedgerVoucher           _ledgerVoucher,
        InventQty               _qty,
        InventQty               _remainQty,
        CostAmount              _costAmount,
        CostAmount              _costAmountSecCur_RU = 0)
    {
        InventUpd_Financial financial   = new InventUpd_Financial(_inventMovement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());

        financial.parmFinancial(_qty);
        financial.parmRemainPhysical(_remainQty);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(financial.parmRemainPhysical());

        financial.parmInventDim(null);
        financial.parmInventDimParm(null);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Financial</c> class for any inventory movement.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for which the updates will be made.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher used when you post GL transactions.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    static public InventUpd_Financial newMovement(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher)
    {
        InventUpd_Financial inventUpd_Financial = new InventUpd_Financial(_movement);

        inventUpd_Financial.setParmAllowDefault();
        inventUpd_Financial.parmLedgerVoucher(_ledgerVoucher);
        inventUpd_Financial.initUpdate();

        return inventUpd_Financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostAsset_RU</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newPostAsset_RU(InventMovement               _movement,
                                                      LedgerVoucher                _ledgerVoucher,
                                                      CostAmount                   _costAmount = 0)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_movement);
        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate()));
        financial.parmFinancial(_movement.transQty());
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.initUpdate();
        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostAssetComponent_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>InventUpd_Financial</c> for assembling.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher.
    /// </param>
    /// <param name="_costAmount">
    /// The cost amount.
    /// </param>
    /// <returns>
    /// An instance of <c>InventUpd_Financial</c> for assembling.
    /// </returns>
    public static InventUpd_Financial newPostAssetComponent_JP(
        InventMovement               _movement,
        LedgerVoucher                _ledgerVoucher,
        CostAmount                   _costAmount = 0)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_movement);
        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.initUpdate();
        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdBOMHistoricalCost</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProdBOMHistoricalCost(
        ProdBOM                 _prodBOM,
        LedgerVoucher           _ledgerVoucher,
        InventTransIdSum        _transIdSum
        , NoYes                 _dropRemainPhysical = NoYes::Yes
        )
    {
        // <GEERU>
        InventMovement      inventMovement  = InventMovement::construct(_prodBOM);
        NoYes               stornoPhysical  = InventParameters::find().StornoPhysicalPosting_RU;

        inventMovement.parmStornoPhysical_RU(stornoPhysical);
        inventMovement.parmStornoPhysicalForced_RU(stornoPhysical);

        InventUpd_Financial financial = new InventUpd_Financial(inventMovement);
        // </GEERU>

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_prodBOM.calcCostAmount(_transIdSum.physical()));
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_transIdSum.physical());
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (_dropRemainPhysical || _prodBOM.RemainBOMPhysical == 0)
            {
                financial.parmRemainPhysical(0);
                financial.parmFinancialUnit(- _prodBOM.RemainBOMFinancial);
                financial.parmRemainPhysicalUnit(0);
            }
            else
            {
                financial.parmRemainPhysical(- _prodBOM.RemainInventPhysical);
                financial.parmFinancialUnit(- _prodBOM.RemainBOMFinancial);
                financial.parmRemainPhysicalUnit(- _prodBOM.RemainBOMPhysical);
            }

            financial.parmCostAmountCurSecCur_RU(_prodBOM.calcCostAmountSecCur_RU(_transIdSum.physical()));
        }
        else
        {
            // </GEERU>
            financial.parmRemainPhysical(0);
            financial.parmFinancialUnit(- _prodBOM.RemainBOMFinancial);
            financial.parmRemainPhysicalUnit(0);
            // <GEERU>
        }
        // </GEERU>

        if (PdsGlobal::pdsIsCWItem(_prodBOM.ItemId))
        {
            financial.parmPdsCWFinancial(_transIdSum.pdsCWPhysical());
            financial.parmPdsCWRemainPhysical(0);
        }

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdBOMTransProjHistoricalCost</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProdBOMTransProjHistoricalCost(
        InventMovement      _movement,
        ProdBOM             _prodBOM,
        ProdBOMTransProj    _prodBOMTransProj,
        InventQty           _inventConsump,
        UnitQty             _bomConsump,
        LedgerVoucher       _ledgerVoucher)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_prodBOM.calcCostAmount(-_inventConsump));
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(-_inventConsump);
        financial.parmFinancialUnit(-_bomConsump);
        financial.parmRemainPhysical(0);
        financial.parmRemainPhysicalUnit(0);
        financial.parmVoucherPhysical(_prodBOMTransProj.Voucher);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(_prodBOM.calcCostAmountSecCur_RU(-_inventConsump));
        }
        // </GEERU>

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdReleaseLossProfit_RU</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProdReleaseLossProfit_RU(InventMovement        _movement,
                                                                  InventUpd_Financial   _inventUpd_Financial,
                                                                  InventQty             _financial,
                                                                  UnitQty               _financialUnit,
                                                                  CostAmount            _releaseAmount,
                                                                  LedgerVoucher         _ledgerVoucher)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_releaseAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_financial);
        financial.parmFinancialUnit(_financialUnit);
        financial.parmRemainPhysical(0);
        financial.parmRemainPhysicalUnit(0);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdReleaseTrans_RU</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProdReleaseTrans_RU(ProdReleaseTrans_RU    _prodReleaseTrans,
                                                             LedgerVoucher          _ledgerVoucher,
                                                             CostAmount             _releaseAmount)
    {
        InventDimParm       inventDimParm;
        NoYes               stornoPhysical = InventParameters::find().StornoPhysicalPosting_RU && ! _prodReleaseTrans.OffsetRefRecId;

        InventMovement inventMovement = InventMovement::construct(_prodReleaseTrans);
        inventMovement.parmStornoPhysical_RU(stornoPhysical);
        inventMovement.parmStornoPhysicalForced_RU(stornoPhysical);

        InventUpd_Financial financial = new InventUpd_Financial(inventMovement);
        financial.setParmAllowDefault();

        financial.parmFinancial(_prodReleaseTrans.inventReleaseQty());
        financial.parmFinancialUnit(_prodReleaseTrans.ReleaseQty);
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmCostAmountCur(_releaseAmount);

        if (_prodReleaseTrans.ReleaseQty < 0)
        {
            // if returning items they must match the dimensions specified on the journal line.
            InventDim inventDim = InventDim::find(_prodReleaseTrans.InventDimId);
            inventDimParm.initFromInventDim(inventDim);
            financial.parmInventDim(inventDim);
            financial.parmInventDimParm(inventDimParm);
        }

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdTableHistoricalCost</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProdTableHistoricalCost(
        ProdTable               _prodTable,
        LedgerVoucher           _ledgerVoucher,
        InventTransIdSum        _transIdSum,
        ProdTableJour           _prodTableJour,
        InventMovement          _inventMovement = InventMov_Prod::newFromProdTable(_prodTable)) // Pass the movement, if it exists (used to set the variance list for the invent cost framework)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_inventMovement);

        boolean cwItem = PdsGlobal::pdsIsCWItem(_prodTable.ItemId);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_prodTableJour.AmountFinancial);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_transIdSum.physical());
        financial.parmFinancialUnit(financial.parmFinancial());

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(_prodTableJour.AmountFinancialSecCur_RU);
        }
        // </GEERU>

        if (cwItem)
        {
            financial.parmPdsCWFinancial(_transIdSum.pdsCWPhysical());
        }

        if (!_prodTable.status().isBefore(ProdStatus::ReportedFinished))
        {
            financial.parmRemainPhysical(0);
            financial.parmRemainPhysicalUnit(0);

            if (cwItem)
            {
                financial.parmPdsCWRemainPhysical(0);
            }
        }
        else
        {
            financial.parmRemainPhysical(_prodTable.RemainInventPhysical);
            financial.parmRemainPhysicalUnit(_prodTable.RemainInventPhysical);

            if (cwItem)
            {
                financial.parmPdsCWFinancial(_prodTable.PdsCWRemainInventPhysical);
            }
        }

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdTableScrap</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProdTableScrap(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        InventQty               _qtyError,
        CostAmount              _costAmount,
        CostAmount              _costAmountSecCur_RU = 0
        )
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_qtyError);
        financial.parmFinancialUnit(_qtyError);
        financial.parmRemainPhysical(0);
        financial.parmRemainPhysicalUnit(0);

        if (_qtyError > 0)
        {
            // when updating scrap receipt don't let the quantity be auto-reserved by another demand while waiting for scrap issue transaction.
            financial.parmAllowAutoReserveDim(false);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdUnderconsume</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new <c>InventUpd_Financial</c> instance that will be used for underconsumptions.
    /// </summary>
    /// <param name="_movement">
    ///    The inventory movement for the financial update.
    /// </param>
    /// <param name="_inventConsump">
    ///    The financial quantity for the financial update.
    /// </param>
    /// <param name="_costAmountCur">
    ///    The cost amount for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_voucherPhysical">
    ///    The physical voucher which will limit the inventory transactions that will be updated; optional.
    /// </param>
    /// <param name="_costAmountSecCur_RU">
    ///    The cost amount in reporting currency for the financial update.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    /// <remarks>
    ///    This method creates a new instance of the <c>InventUpd_Financial</c> class that will be used for
    ///    underconsumptions.The instance of the <c>InventUpd_Financial</c> class will be used to consume the
    ///    subproduction items that were underconsumed by the parent production order.The instance of the
    ///    <c>InventUpd_Financial</c> class will also be used to post income to the project for the
    ///    underconsumption.
    /// </remarks>
    public static InventUpd_Financial newProdUnderconsume(
        InventMovement      _movement,
        InventQty           _inventConsump,
        AmountCur           _costAmountCur,
        LedgerVoucher       _ledgerVoucher,
        VoucherPhysical     _voucherPhysical     = '',
        CostAmount          _costAmountSecCur_RU = 0)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmountCur);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_inventConsump);
        financial.parmFinancialUnit(_inventConsump);
        financial.parmPhysical(financial.parmFinancial());
        financial.parmPhysicalUnit(financial.parmFinancialUnit());
        financial.parmVoucherPhysical(_voucherPhysical);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                              ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmountCur, _ledgerVoucher.lastTransDate())   :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProdTableHistoricalCost</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newProjProdTableHistoricalCost(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        InventQty               _financial,
        InventQty               _remainPhysical,
        AmountCur               _costAmountCur,
        CostAmount              _costAmountSecCur_RU = 0
        )
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmountCur);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_financial);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysical(_remainPhysical);
        financial.parmRemainPhysicalUnit(_remainPhysical);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                              ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmountCur, _ledgerVoucher.lastTransDate())   :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchInvoice</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newPurchInvoice(
        InventMov_Purch         _inventMovement,
        LedgerVoucher           _ledgerVoucher,
        InvoiceId               _invoiceNum,
        AmountCur               _amountCur,
        CurrencyCode            _currencyCode,
        ExchRate                _exchRate,
        ExchrateSecondary       _exchrateSecondary,
        ExchRatesTriangulation  _exchRatesTriangulation,
        VendInvoiceInfoLine     _vendInvoiceInfoLine,
        VendInvoiceInfoSubLine  _vendInvoiceInfoSubLine)
    {
        PurchLine               purchLine = _inventMovement.buffer();
        InventQty               unpostedInvoiceInventQty, origPhysical;
        PurchQty                unpostedInvoicePurchQty, origPhysicalUnit;
        PdsCWInventQty          pdsCWUnpostedInvoiceInventQty, pdsCWOrigPhysical;

        _inventMovement.parmPurchParmSubLineRecId(_vendInvoiceInfoSubLine.RecId);
        InventUpd_Financial financial = new InventUpd_Financial(_inventMovement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmInvoiceId(_invoiceNum);
        financial.parmCostAmountCur(_amountCur);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountCur2MSTSecond_RU(_amountCur, _currencyCode, _exchRate, _ledgerVoucher.lastTransDate(), _exchrateSecondary));
        }
        // </GEERU>
        financial.parmCurrencyCode(_currencyCode);
        financial.parmExchRate(_exchRate);
        financial.parmExchRateSecondary(_exchrateSecondary);
        financial.parmExchRatesTriangulation(_exchRatesTriangulation);
        financial.parmFinancial(_vendInvoiceInfoLine.InventNow);
        financial.parmRemainPhysical(_vendInvoiceInfoLine.RemainAfterInvent);
        financial.parmFinancialUnit(_vendInvoiceInfoLine.ReceiveNow);
        financial.parmRemainPhysicalUnit(_vendInvoiceInfoLine.RemainAfter);
        financial.parmAutoLossProfit(purchLine.Scrap);

        if (_inventMovement.pdsCWItem())
        {
            financial.parmPdsCWFinancial(_vendInvoiceInfoLine.PdsCWReceiveNow);
            financial.parmPdsCWRemainPhysical(_vendInvoiceInfoLine.PdsCWRemainAfter);
        }

        if (_vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans))
        {
            VendPackingSlipTrans vendPackingSlipTrans = VendPackingSlipTrans::findRecId(_vendInvoiceInfoSubLine.JournalRefRecId);
            financial.parmPackingSlipId(vendPackingSlipTrans.PackingSlipId);
            financial.parmVoucherPhysical(vendPackingSlipTrans.CostLedgerVoucher);
        }
        financial.initUpdate();

        // Add sum of reserved packing slips so InventTrans quantity will be increased appropriately
        if (_vendInvoiceInfoSubLine.RecId == 0)
        {
            [unpostedInvoiceInventQty,
                unpostedInvoicePurchQty,
                pdsCWUnpostedInvoiceInventQty] =
                    VendInvoiceInfoSubLine::unpostedInvoiceQty(
                        purchLine.InventTransId);

            if (unpostedInvoiceInventQty != 0)
            {
                origPhysical = financial.parmPhysical();

                pdsCWOrigPhysical = financial.parmPdsCWPhysical();

                if (financial.parmFinancial() > 0)
                {
                    financial.parmPhysical(max(financial.parmFinancial() - (_inventMovement.transIdSum().received() - unpostedInvoiceInventQty), 0));

                    if (_inventMovement.pdsCWItem())
                    {
                        financial.parmPdsCWPhysical(
                            max(financial.parmPdsCWFinancial()
                                    - (_inventMovement.transIdSum().pdsCWReceived()
                                    - pdsCWUnpostedInvoiceInventQty),
                                 0));
                    }
                }
                else if (financial.parmFinancial() < 0)
                {
                    financial.parmPhysical(min(financial.parmFinancial() - (_inventMovement.transIdSum().deducted() - unpostedInvoiceInventQty), 0));

                    if (_inventMovement.pdsCWItem())
                    {
                        financial.parmPdsCWPhysical(
                            min(financial.parmPdsCWFinancial()
                                    - (_inventMovement.transIdSum().pdsCWDeducted()
                                    - pdsCWUnpostedInvoiceInventQty),
                                0));
                    }
                }

                // Adjust the expected remaining amount
                if (financial.parmFinancial() > 0)
                {
                    financial.parmRemainPhysical(max(financial.parmRemainPhysical() - (financial.parmPhysical() - origPhysical), 0));

                    financial.parmPdsCWRemainPhysical(
                        max(financial.parmPdsCWRemainPhysical()
                                - (financial.parmPdsCWPhysical()
                                - pdsCWOrigPhysical),
                            0));
                }
                else if (financial.parmFinancial() < 0)
                {
                    financial.parmRemainPhysical(min(financial.parmRemainPhysical() - (financial.parmPhysical() - origPhysical), 0));

                    financial.parmPdsCWRemainPhysical(
                        min(financial.parmPdsCWRemainPhysical()
                                - (financial.parmPdsCWPhysical()
                                - pdsCWOrigPhysical),
                            0));
                }
            }
            if (unpostedInvoicePurchQty != 0)
            {
                origPhysicalUnit = financial.parmPhysicalUnit();
                if (_inventMovement.mustBeUnitControlled())
                {
                    if (!financial.returnMode())
                    {
                        if (financial.parmFinancialUnit() > 0)
                        {
                            financial.parmPhysicalUnit(
                                max(financial.parmFinancialUnit() - (_inventMovement.remainFinancialUnit() - unpostedInvoicePurchQty),0));
                        }
                        else if (financial.parmFinancialUnit() < 0)
                        {
                            financial.parmPhysicalUnit(
                                min(financial.parmFinancialUnit() - (_inventMovement.remainFinancialUnit() - unpostedInvoicePurchQty),0));
                        }
                    }
                    else
                    {
                        if (financial.parmFinancialUnit() > 0)
                        {
                            financial.parmPhysicalUnit(
                               max(financial.parmFinancialUnit() - max(_inventMovement.remainFinancialUnit() - unpostedInvoicePurchQty,0),0));
                        }
                        else if (financial.parmFinancialUnit() < 0)
                        {
                            financial.parmPhysicalUnit(
                                min(financial.parmFinancialUnit() - min(_inventMovement.remainFinancialUnit() - unpostedInvoicePurchQty,0),0));
                        }
                    }
                }
                else
                {
                    financial.parmPhysicalUnit(financial.parmPhysical());
                }

                // Adjust the expected remaining amount
                if (financial.parmFinancialUnit() > 0)
                {
                    financial.parmRemainPhysicalUnit(max(financial.parmRemainPhysicalUnit() - (financial.parmPhysicalUnit() - origPhysicalUnit), 0));
                }
                else if (financial.parmFinancialUnit() < 0)
                {
                    financial.parmRemainPhysicalUnit(min(financial.parmRemainPhysicalUnit() - (financial.parmPhysicalUnit() - origPhysicalUnit), 0));
                }
            }
        }

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchInvoiceProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes a new instance of the <c>InventUpd_Financial</c> class to be used for financial inventory update simulation
    /// during purchase order invoicing.
    /// </summary>
    /// <param name="_inventMovement">
    /// An inventory movement.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// A ledger voucher.
    /// </param>
    /// <param name="_vendInvoiceInfoLine">
    /// A <c>VendInvoiceInfoLine</c> table buffer.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    public static InventUpd_Financial newPurchInvoiceProforma(
        InventMov_Purch         _inventMovement,
        LedgerVoucher           _ledgerVoucher,
        VendInvoiceInfoLine     _vendInvoiceInfoLine)
    {
        PurchLine               purchLine = _inventMovement.buffer();

        InventUpd_Financial financial = new InventUpd_Financial(_inventMovement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmFinancial(_vendInvoiceInfoLine.InventNow);
        financial.parmRemainPhysical(_vendInvoiceInfoLine.RemainAfterInvent);
        financial.parmFinancialUnit(_vendInvoiceInfoLine.ReceiveNow);
        financial.parmRemainPhysicalUnit(_vendInvoiceInfoLine.RemainAfter);
        financial.parmAutoLossProfit(purchLine.Scrap);
        financial.parmPdsCWFinancial(_vendInvoiceInfoLine.PdsCWReceiveNow);
        financial.parmPdsCWRemainPhysical(_vendInvoiceInfoLine.PdsCWRemainAfter);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newRBOTransactionSalesTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventUpd_Financial</c> instance that will be used when new sales transactions are
    /// finished.
    /// </summary>
    /// <param name="_inventMovement">
    /// An instance of the <c>InventMovement</c> class.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An instance of the <c>LedgerVoucher</c> class.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    static InventUpd_Financial newRBOTransactionSalesTrans(InventMovement _inventMovement, LedgerVoucher _ledgerVoucher)
    {
        RetailTransactionSalesTrans transactionSalesTrans = _inventMovement.buffer();

        InventUpd_Financial financial = new InventUpd_Financial(_inventMovement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);

        financial.parmCostAmountCur(transactionSalesTrans.calcReturnCostAmount(transactionSalesTrans.inventNow()));
        financial.parmFinancial(transactionSalesTrans.inventNow());
        financial.parmFinancialUnit(transactionSalesTrans.inventNow());

        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmRemainPhysical(0);
        financial.parmRemainPhysicalUnit(0);
        financial.parmAutoLossProfit(false);
        financial.postingFinancial(false);
        financial.postingPhysical(true);
        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAndInitializeInventoryUpdateForSalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs and initializes the instance that updates the inventory transactions.
    /// </summary>
    /// <param name = "_inventMovement">The inventory movement.</param>
    /// <param name = "_ledgerVoucher">A <c>LedgerVoucher</c>.</param>
    /// <param name = "_invoiceNum">The invoice identifier.</param>
    /// <param name = "_salesOrderParmLine">The sales order.</param>
    /// <param name = "_salesParmSubLine">The sublines of the order.</param>
    /// <param name = "_physicalReduction">The physical reduction of the inventory.</param>
    /// <param name = "_inventDimCriteria_RU">The inventory dimension criteria.</param>
    /// <param name = "_inventDimParm_RU">The inventory dimensions.</param>
    /// <returns>An <c>InventUpd_Financial</c> instance.</returns>
    protected static InventUpd_Financial constructAndInitializeInventoryUpdateForSalesInvoice(
        InventMovement         _inventMovement,
        LedgerVoucher          _ledgerVoucher,
        InvoiceId              _invoiceNum,
        SalesParmLine          _salesOrderParmLine,
        SalesParmSubLine       _salesParmSubLine,
        InventPhysicalReduction _physicalReduction = InventPhysicalReduction::None,
        InventDim              _inventDimCriteria_RU   = null,
        InventDimParm          _inventDimParm_RU       = null
        )
    {
        InventUpd_Financial financial = new InventUpd_Financial(_inventMovement);
        SalesLine           salesLine = _inventMovement.buffer();

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmInvoiceId(_invoiceNum);
        financial.parmCostAmountCur(-salesLine.calcReturnCostAmount(_salesOrderParmLine.InventNow));
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(-salesLine.calcReturnCostAmount(_salesOrderParmLine.InventNow), _ledgerVoucher.lastTransDate()));
            financial.parmRemainBeforePhysical_RU    (-_salesOrderParmLine.RemainBeforeInvent);
            financial.parmRemainBeforePhysicalUnit_RU(-_salesOrderParmLine.RemainBefore);

            if (! _inventDimParm_RU.isAllFlagNo())
            {
                financial.parmInventDim              (_inventDimCriteria_RU);
                financial.parmInventDimParm          (_inventDimParm_RU);
            }
        }
        // </GEERU>
        financial.parmFinancial(-_salesOrderParmLine.InventNow);
        financial.parmRemainPhysical(-_salesOrderParmLine.RemainAfterInvent);
        financial.parmFinancialUnit(-_salesOrderParmLine.DeliverNow);
        financial.parmRemainPhysicalUnit(-_salesOrderParmLine.RemainAfter);
        financial.parmPhysicalReduction(_physicalReduction);
        financial.parmAutoLossProfit(_salesOrderParmLine.Scrap);
        financial.parmAllowAutoReserveDim(!_salesOrderParmLine.Scrap);
        if (_inventMovement.pdsCWItem())
        {
            financial.parmPdsCWFinancial(-_salesOrderParmLine.PdsCWDeliverNow);
            financial.parmPdsCWRemainPhysical(
                -_salesOrderParmLine.PdsCWRemainAfterInvent);
        }
        if (_salesParmSubLine.JournalRefTableId == tableNum(CustPackingSlipTrans))
        {
            CustPackingSlipTrans custPackingSlipTrans = CustPackingSlipTrans::findRecId(_salesParmSubLine.JournalRefRecId);

            financial.parmPackingSlipTransRecId(custPackingSlipTrans.RecId);
            financial.parmPackingSlipId(custPackingSlipTrans.PackingSlipId);
        }

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance that updates the inventory transactions.
    /// </summary>
    /// <param name = "_inventMovement">The inventory movement.</param>
    /// <param name = "_ledgerVoucher">A <c>LedgerVoucher</c>.</param>
    /// <param name = "_invoiceNum">The invoice identifier.</param>
    /// <param name = "_salesOrderParmLine">The sales order.</param>
    /// <param name = "_salesParmSubLine">The sublines of the order.</param>
    /// <param name = "_physicalReduction">The physical reduction of the inventory.</param>
    /// <param name = "_inventDimCriteria_RU">The inventory dimension criteria.</param>
    /// <param name = "_inventDimParm_RU">The inventory dimensions.</param>
    /// <returns>An <c>InventUpd_Financial</c> instance.</returns>
    public static InventUpd_Financial newSalesInvoice(
        InventMovement         _inventMovement,
        LedgerVoucher          _ledgerVoucher,
        InvoiceId              _invoiceNum,
        SalesParmLine          _salesOrderParmLine,
        SalesParmSubLine       _salesParmSubLine,
        InventPhysicalReduction _physicalReduction = InventPhysicalReduction::None,
        InventDim              _inventDimCriteria_RU   = null,
        InventDimParm          _inventDimParm_RU       = null
        )
    {
        InventUpd_Financial financial = InventUpd_Financial::constructAndInitializeInventoryUpdateForSalesInvoice(_inventMovement,
                                                                                                                  _ledgerVoucher,
                                                                                                                  _invoiceNum,
                                                                                                                  _salesOrderParmLine,
                                                                                                                  _salesParmSubLine,
                                                                                                                  _physicalReduction,
                                                                                                                  _inventDimCriteria_RU,
                                                                                                                  _inventDimParm_RU);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesInvoiceProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes a new instance of the <c>InventUpd_Financial</c> class to be used for financial inventory update simulation
    /// during sales order invoicing.
    /// </summary>
    /// <param name="_inventMovement">
    /// An inventory movement.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// A ledger voucher.
    /// </param>
    /// <param name="_salesParmLine">
    /// A <c>SalesParmLine</c> table buffer
    /// </param>
    /// <param name="_salesParmSubLine">
    /// A <c>SalesParmSubLine</c> table buffer
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    public static InventUpd_Financial newSalesInvoiceProforma(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        SalesParmLine   _salesParmLine,
        SalesParmSubLine _salesParmSubLine = null)
    {
        InventUpd_Financial     financial               = new InventUpd_Financial(_inventMovement);
        SalesLine               salesLine               = _inventMovement.buffer();

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmFinancial(-_salesParmLine.InventNow);
        financial.parmRemainPhysical(-_salesParmLine.RemainAfterInvent);
        financial.parmFinancialUnit(-_salesParmLine.DeliverNow);
        financial.parmRemainPhysicalUnit(-_salesParmLine.RemainAfter);
        financial.parmAutoLossProfit(_salesParmLine.Scrap);
        financial.parmPdsCWFinancial(-_salesParmLine.PdsCWDeliverNow);
        financial.parmPdsCWRemainPhysical(-_salesParmLine.PdsCWRemainAfterInvent);

        if (_salesParmSubLine.JournalRefTableId == tableNum(CustPackingSlipTrans))
        {
            CustPackingSlipTrans custPackingSlipTrans = CustPackingSlipTrans::findRecId(_salesParmSubLine.JournalRefRecId);
            financial.parmPackingSlipId(custPackingSlipTrans.PackingSlipId);
        }

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesPackingSlipProject</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newSalesPackingSlipProject(
        InventMovement          _inventMovement,
        LedgerVoucher           _ledgerVoucher,
        InvoiceId               _invoiceNum,
        CustPackingSlipTrans    _custPackingSlipTrans,
        InventPhysicalReduction _physicalReduction = InventPhysicalReduction::None)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_inventMovement);
        SalesLine               salesLine           = _inventMovement.buffer();

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(-salesLine.calcReturnCostAmount(_custPackingSlipTrans.InventQty));
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(-_custPackingSlipTrans.InventQty);
        financial.parmRemainPhysical(-_custPackingSlipTrans.RemainInvent);
        financial.parmFinancialUnit(-_custPackingSlipTrans.Qty);
        financial.parmRemainPhysicalUnit(-_custPackingSlipTrans.Remain);
        financial.parmPhysicalReduction(_physicalReduction);
        financial.parmAutoLossProfit(_custPackingSlipTrans.Scrap);
        financial.parmInvoiceId(_invoiceNum);
        financial.parmFinancialJournalLine(_custPackingSlipTrans);

        if (_inventMovement.pdsCWItem())
        {
            financial.parmPdsCWFinancial(-_custPackingSlipTrans.PdsCWQty);
            financial.parmPdsCWRemainPhysical(
                -_custPackingSlipTrans.PdsCWRemain);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(financial.parmCostAmountCur(), _ledgerVoucher.lastTransDate()));
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newDeliveredSalesPackingSlipProject</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newDeliveredSalesPackingSlipProject(
        InventMovement _inventMovement,
        LedgerVoucher _ledgerVoucher,
        InvoiceId _invoiceNum,
        CustPackingSlipTrans _custPackingSlipTrans,
        InventPhysicalReduction _physicalReduction = InventPhysicalReduction::None)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_inventMovement);
        SalesLine salesLine = _inventMovement.buffer();

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(-salesLine.calcReturnCostAmount(_custPackingSlipTrans.InventQty));
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(-_custPackingSlipTrans.InventQty);
        financial.parmFinancialUnit(-_custPackingSlipTrans.Qty);
        financial.parmRemainPhysical(-salesLine.RemainInventPhysical);
        financial.parmRemainPhysicalUnit(-salesLine.RemainSalesPhysical);
        financial.parmPhysicalReduction(_physicalReduction);
        financial.parmAutoLossProfit(_custPackingSlipTrans.Scrap);
        financial.parmInvoiceId(_invoiceNum);
        financial.parmFinancialJournalLine(_custPackingSlipTrans);
        financial.parmPackingSlipId(_custPackingSlipTrans.PackingSlipId);

        if (_inventMovement.pdsCWItem())
        {
            financial.parmPdsCWFinancial(-_custPackingSlipTrans.PdsCWQty);
            financial.parmPdsCWRemainPhysical(-salesLine.PdsCWRemainInventPhysical);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(financial.parmCostAmountCur(), _ledgerVoucher.lastTransDate()));
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesPackingSlipProjectProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventUpd_Financial</c> instance that will be used when item requirements are
    /// packing slip updated.
    /// </summary>
    /// <param name="_inventMovement">
    /// The inventory movement for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_invoiceNum">
    /// The invoice number that will be set on the inventory transaction.
    /// </param>
    /// <param name="_scrap">
    /// A Boolean value that indicates whether to scrap.
    /// </param>
    /// <param name="_deliverNow">
    /// The deliver now quantity.
    /// </param>
    /// <param name="_remainAfter">
    /// The remain after quantity.
    /// </param>
    /// <param name="_physicalReduction">
    /// An <c>InventPhysicalReduction</c> enumeration value that indicates whether physical reduction is
    /// allowed; optional.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The inventory reference transaction ID that will limit the inventory transactions that will be
    /// updated; optional.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Financial</c> class.
    /// </returns>
    public static InventUpd_Financial newSalesPackingSlipProjectProd(
        InventMovement          _inventMovement,
        LedgerVoucher           _ledgerVoucher,
        InvoiceId               _invoiceNum,
        boolean                 _scrap,
        SalesQty                _deliverNow,
        SalesQty                _remainAfter,
        InventPhysicalReduction _physicalReduction = InventPhysicalReduction::None,
        InventTransOriginId     _markingRefInventTransOrigin = 0)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_inventMovement);
        SalesLine               salesLine = _inventMovement.buffer();

        EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                                                                  salesLine.InventDimId,
                                                                                                                                  salesLine.SalesUnit,
                                                                                                                                  salesLine.inventTable().inventUnitId(),
                                                                                                                                  NoYes::Yes);


        InventQty inventNow = ecoResProductUnitConverter.convertValue(_deliverNow);
        InventQty remainAfterInvent = ecoResProductUnitConverter.convertValue(_remainAfter);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(-salesLine.calcReturnCostAmount(inventNow));
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(-inventNow);
        financial.parmRemainPhysical(-remainAfterInvent);
        financial.parmFinancialUnit(-_deliverNow);
        financial.parmRemainPhysicalUnit(-_remainAfter);
        financial.parmPhysicalReduction(_physicalReduction);
        financial.parmAutoLossProfit(_scrap);
        financial.parmInvoiceId(_invoiceNum);
        financial.parmMarkingRefInventTransOrigin(_markingRefInventTransOrigin);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(CurrencyExchangeHelper::amountMST2MSTSecond_RU(financial.parmCostAmountCur(), _ledgerVoucher.lastTransDate()));
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventUpd_Financial</c> class that will be used when new
    /// statements are created.
    /// </summary>
    /// <param name="_inventMovement">
    /// An instance of <c>InventMovement</c> class.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An instance of <c>LedgerVoucher</c> class.
    /// </param>
    /// <param name="_invoiceId">
    /// The ID of the invoice.
    /// </param>
    /// <returns>
    /// An instance of <c>InventUpd_Financial</c> class.
    /// </returns>
    static InventUpd_Financial newStatement(InventMovement _inventMovement, LedgerVoucher _ledgerVoucher,InvoiceId _invoiceId)
    {
        RetailTransactionSalesTrans transactionSalesTrans = _inventMovement.buffer();

        InventUpd_Financial financial = new InventUpd_Financial(_inventMovement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmInvoiceId(_invoiceId);

        financial.parmCostAmountCur(transactionSalesTrans.calcReturnCostAmount(transactionSalesTrans.inventNow()));
        financial.parmFinancial(transactionSalesTrans.inventNow());
        financial.parmFinancialUnit(transactionSalesTrans.inventNow());

        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmRemainPhysical(0);
        financial.parmRemainPhysicalUnit(0);
        financial.parmAutoLossProfit(false);
        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVirtuelCounting</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newVirtuelCounting(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        CostAmount              _costAmount,
        CostAmount              _costAmountSecCur_RU = 0)

    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(0);

        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.parmPdsCWRemainPhysical(0);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVirtuelQuarantineLoss</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newVirtuelQuarantineLoss(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        CostAmount              _costAmount,
        CostAmount              _costAmountSecCur_RU = 0)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(0);

        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.parmPdsCWRemainPhysical(0);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(
                prmisDefault(_costAmountSecCur_RU)                                          ?
                CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate())  :
                _costAmountSecCur_RU);
        }
        // </GEERU>

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVirtuelTransfer</Name>
				<Source><![CDATA[
    public static InventUpd_Financial newVirtuelTransfer(
        InventMovement          _movement,
        LedgerVoucher           _ledgerVoucher,
        CostAmount            _costAmount,
        CostAmount            _costAmountSecCur_RU = 0)
    {
        InventUpd_Financial     financial           = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial.parmCostAmountCurSecCur_RU(prmisDefault(_costAmountSecCur_RU) ?
                                                    CurrencyExchangeHelper::amountMST2MSTSecond_RU(_costAmount, _ledgerVoucher.lastTransDate()) :
                                                    _costAmountSecCur_RU);
        }
        // </GEERU>
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_movement.transQty());
        financial.parmRemainPhysical(0);
        financial.parmFinancialUnit(financial.parmFinancial());
        financial.parmRemainPhysicalUnit(0);
        financial.parmAllowNegativeFinancial(true);

        financial.parmPdsCWFinancial(_movement.pdsCWTransQty());
        financial.parmPdsCWRemainPhysical(0);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfNewProdCoByHistoricalCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes a new instance of the <c>InventUpd_Financial</c> class.
    /// </summary>
    /// <param name="_pmfProdCoBy">
    /// A <c>PmfProdCoBy</c> record that is used to initialize the class.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// A <c>LedgerVoucher</c> record that is used to initialize the class.
    /// </param>
    /// <param name="_prodTableJourCoProduct">
    /// A <c>ProdTableJour</c> record that is used to initialize the class.
    /// </param>
    /// <param name="_movement">
    /// An <c>InventMovement</c> object that is used to initialize the class.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Finanical</c> class.
    /// </returns>
    public static InventUpd_Financial pmfNewProdCoByHistoricalCost(
        PmfProdCoBy             _pmfProdCoBy,
        LedgerVoucher           _ledgerVoucher,
        ProdTableJour           _prodTableJourCoProduct,
        InventMovement          _movement)
    {
        InventUpd_Financial financial = new InventUpd_Financial(_movement);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_prodTableJourCoProduct.AmountFinancial);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
        financial.parmFinancial(_prodTableJourCoProduct.QtyGood);
        financial.parmFinancialUnit(_prodTableJourCoProduct.QtyGood);
        financial.parmPdsCWFinancial(_prodTableJourCoProduct.PdsCWBatchGood);

        if (!_pmfProdCoBy.prodTable().status().isBefore(ProdStatus::ReportedFinished))
        {
            financial.parmRemainPhysical(0);
            financial.parmRemainPhysicalUnit(0);
            financial.parmPdsCWRemainPhysical(0);
        }
        else
        {
            financial.parmRemainPhysical(-_pmfProdCoBy.RemainCoByPhysical);
            financial.parmRemainPhysicalUnit(-_pmfProdCoBy.RemainCoByPhysical);
            financial.parmPdsCWRemainPhysical(-_pmfProdCoBy.PdsCWRemainPhysical);
        }

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVirtuelTransfer</Name>
				<Source><![CDATA[
    public static void updateVirtuelTransfer(
        ItemId                  _itemId,
        InventDimId             _fromInventDimId,
        InventDimId             _toInventDimId,
        TransDate               _transDate,
        InventQty               _qty, // Positive
        NoYes                   _mustBeQuarantineControlled,
        boolean                 _allowReservationOfReceipt = true,
        PdsCWInventQty          _cwQty  = 0,
        LedgerVoucher           _ledgerVoucher = null,
        NumberSeq               _numberSeq = null,
        InventCostOnhandCache   _inventCostOnhandCache = null
        )

    {
        InventTransId           inventTransId;
        boolean                 mustEndLedgerVoucher = false;

        ttsbegin;

        if (_fromInventDimId == _toInventDimId)
        {
            throw error("@SYS16985");
        }

        if (_qty == 0)
        {
            throw error("@SYS54003");
        }

        if (_numberSeq != null)
        {
            inventTransId = _numberSeq.num();
        }
        else
        {
            inventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
        }

        InventMov_Vir_Transfer movement_Receipt = InventMov_Vir_Transfer::newParameters(
            inventTransId,
            _itemId,
            _toInventDimId,
            _transDate,
            _qty,
            _mustBeQuarantineControlled,
            _cwQty
            );

        InventMov_Vir_Transfer movement_Issue = InventMov_Vir_Transfer::newParameters(
            inventTransId,
            _itemId,
            _fromInventDimId,
            _transDate,
           -_qty,
           _mustBeQuarantineControlled,
           -_cwQty
           );

        LedgerVoucher ledgerVoucher = _ledgerVoucher;
        if (ledgerVoucher == null)
        {
            ledgerVoucher = InventUpd_Financial::createLedgerVoucherForVirTransfer(_transDate);
            mustEndLedgerVoucher = true;
        }

        InventUpd_Financial financial = InventUpd_Financial::newVirtuelTransfer(movement_Issue, ledgerVoucher, 0);
        financial.parmInventCostOnhandCache(_inventCostOnhandCache);
        financial.updateNow();

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            financial = InventUpd_Financial::newCheckPostInventJournalTrans(movement_Receipt,
                                                                            ledgerVoucher,
                                                                            -financial.updCostAmountInvent(),
                                                                            -financial.updCostAmountInventSecCur_RU());
        }
        else
        {
            // </GEERU>
            financial = InventUpd_Financial::newCheckPostInventJournalTrans(movement_Receipt, ledgerVoucher, -financial.updCostAmountInvent());
            // <GEERU>
        }
        // </GEERU>
        financial.parmAllowReserveOrdered(_allowReservationOfReceipt);
        financial.parmInventCostOnhandCache(_inventCostOnhandCache);
        financial.updateNow();

        if (mustEndLedgerVoucher)
        {
            ledgerVoucher.end();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVirtuelTransferClosing</Name>
				<Source><![CDATA[
    // This method is used for creating the virtual InventTrans used in inventory closing.
    // The purpose of this class is to create the transaction of the correct type in the correct way, and to skip a few checks that are harmful.
    // (For details on these checks, see InventMov_Vir_Transfer_Closing.)
    // It returns the created InventTransId.
    public static InventTransId updateVirtuelTransferClosing(
        ItemId                  _itemId,
        InventDimId             _inventDimId,
        TransDate               _transDate,
        InventQty               _qty, // Positive
        PdsCWInventQty          _cwQty,
        CostAmount              _costAmount,
        Voucher                 _voucherId
        , CostAmount              _costAmountSecCur_RU = 0
        )
    {
        ttsbegin;

        if (_qty == 0)
        {
            throw error("@SYS54003");
        }

        InventTransId inventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();

        InventMov_Vir_Transfer movement_Receipt = InventMov_Vir_Transfer_Closing::newParameters(
            inventTransId,
            _itemId,
            _inventDimId,
            _transDate,
            _qty,
            _cwQty
            );

        InventMov_Vir_Transfer movement_Issue = InventMov_Vir_Transfer_Closing::newParameters(
            inventTransId,
            _itemId,
            _inventDimId,
            _transDate,
           -_qty,
            -_cwQty
            );

        NumberSeq numberSeq = NumberSeq::newGetNum(InventParameters::numRefInventClosingVoucherId());

        TransactionTxt transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::InventJournalTransfer);
        transactionTxt.setDate(_transDate);
        transactionTxt.setVoucher(_voucherId);

        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                   SysModule::Invent,
                                                                   numberSeq.parmNumberSequenceCode());
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(_voucherId,
                                                                                  _transDate,
                                                                                  SysModule::Invent,
                                                                                  LedgerTransType::Invent);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        // <GEERU>
        InventUpd_Financial financial = InventUpd_Financial::newVirtuelTransfer(movement_Receipt, ledgerVoucher, _costAmount, _costAmountSecCur_RU);
        // </GEERU>
        financial.parmAllowReserveOrdered(false);
        financial.parmSkipCWAutoAdjust(true);
        financial.updateNow();

        // <GEERU>
        financial = InventUpd_Financial::newVirtuelTransfer(movement_Issue, ledgerVoucher, -financial.updCostAmountInvent(), -financial.updCostAmountInventSecCur_RU());
        // </GEERU>
        financial.parmSkipCWAutoAdjust(true);
        financial.updateNow();

        ledgerVoucher.end();

        ttscommit;

        return inventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromContainerMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an <c>InventUpd_Financial</c> class from a container movement.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_costAmount">
    /// Cost amount for financial update
    /// </param>
    /// <param name="_qty">
    /// Transaction quantity.
    /// </param>
    /// <param name="_cwQty">
    /// Catch weight transaction quantity.
    /// </param>
    /// <returns>
    /// A newly created instance of <c>InventUpd_Financial</c> class
    /// </returns>
    [Hookable(false)]
    internal static InventUpd_Financial newFromContainerMovement(
        InventMovement   _movement,
        LedgerVoucher    _ledgerVoucher,
        CostAmount       _costAmount,
        InventQty        _qty,
        PdsInventQty     _cwQty)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _movement.itemId(), _cwQty))
        {
            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _movement.itemId());

            return InventUpd_Financial::createFromWorkMovement(_movement, _ledgerVoucher, _costAmount, _qty, 0, null);
        }

        return InventUpd_Financial::createFromWorkMovement(_movement, _ledgerVoucher, _costAmount, _qty, _cwQty, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsNewInventWHSQuarantine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and returns a new instance of <c>InventUpd_Financial</c> class
    /// that will be used each time a Quarantine transaction gets executed.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_costAmount">
    /// Cost amount for financial update
    /// </param>
    /// <param name="_qty">
    /// Transaction quantity.
    /// </param>
    /// <returns>
    /// A newly created instance of <c>InventUpd_Financial</c> class.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static InventUpd_Financial whsNewInventWHSQuarantine(InventMovement  _movement,
                                                                LedgerVoucher   _ledgerVoucher,
                                                                CostAmount      _costAmount,
                                                                InventQty       _qty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _movement.itemId());
        
        return InventUpd_Financial::createFromWorkMovement(_movement, _ledgerVoucher, _costAmount, _qty, 0, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromQuarantineWorkMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an <c>InventUpd_Financial</c> class from a quarantine work movement.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_costAmount">
    /// Cost amount for financial update
    /// </param>
    /// <param name="_qty">
    /// Transaction quantity.
    /// </param>
    /// <param name="_cwQty">
    /// Catch weight transaction quantity.
    /// </param>
    /// <returns>
    /// A newly created instance of <c>InventUpd_Financial</c> class.
    /// </returns>
    [Hookable(false)]
    internal static InventUpd_Financial newFromQuarantineWorkMovement(
        InventMovement  _movement,
        LedgerVoucher   _ledgerVoucher,
        CostAmount      _costAmount,
        InventQty       _qty,
        PdsInventQty    _cwQty)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _movement.itemId(), _cwQty))
        {
            return InventUpd_Financial::whsNewInventWHSQuarantine(_movement, _ledgerVoucher, _costAmount, _qty);
        }

        return InventUpd_Financial::createFromWorkMovement(_movement, _ledgerVoucher, _costAmount, _qty, _cwQty, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromWorkMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an <c>InventUpd_Financial</c> class from a work movement.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for the financial update.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <param name="_costAmount">
    ///  Cost amount for financial update
    /// </param>
    /// <param name="_qty">
    /// Transaction quantity.
    /// </param>
    /// <param name="_cwQty">
    /// Catch weight transaction quantity.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the on-hand cache.
    /// </param>
    /// <returns>
    /// A newly created instance of <c>InventUpd_Financial</c> class
    /// </returns>
    [Hookable(false)]
    internal static InventUpd_Financial newFromWorkMovement(
        InventMovement        _movement,
        LedgerVoucher         _ledgerVoucher,
        CostAmount            _costAmount,
        InventQty             _qty,
        PdsCWInventQty        _cwQty,
        InventCostOnhandCache _inventCostOnhandCache)
    {
        return InventUpd_Financial::createFromWorkMovement(_movement, _ledgerVoucher, _costAmount, _qty, _cwQty, _inventCostOnhandCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromWorkMovement</Name>
				<Source><![CDATA[
    private static InventUpd_Financial createFromWorkMovement(
        InventMovement        _movement,
        LedgerVoucher         _ledgerVoucher,
        CostAmount            _costAmount,
        InventQty             _qty,
        PdsCWInventQty        _cwQty,
        InventCostOnhandCache _inventCostOnhandCache)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _movement.itemId(), _cwQty, _qty);

        InventUpd_Financial financial = InventUpd_Financial::newMovement(_movement, _ledgerVoucher);

        financial.setParmAllowDefault();
        financial.parmLedgerVoucher(_ledgerVoucher);
        financial.parmCostAmountCur(_costAmount);
        financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());

        financial.parmFinancial(_qty);
        financial.parmFinancialUnit(_qty);
        financial.parmPdsCWFinancial(_cwQty);

        if (_movement.isPrimaryMovement())
        {
            financial.parmRemainPhysicalUnit(_movement.remainPhysical() - _qty);
            financial.parmRemainPhysical(_movement.remainPhysical() - _qty);
            financial.parmPdsCWRemainPhysical(_movement.pdsCWRemainPhysical() - _cwQty);
        }
        else
        {
            financial.parmRemainPhysicalUnit(_movement.remainPhysical());
            financial.parmRemainPhysical(_movement.remainPhysical());
            financial.parmPdsCWRemainPhysical(_movement.pdsCWRemainPhysical());
        }

        financial.parmInventCostOnhandCache(_inventCostOnhandCache);

        financial.initUpdate();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferOrderVoucherMatched</Name>
				<Source><![CDATA[
    internal Voucher parmTransferOrderVoucherMatched(Voucher _transferOrdervoucherMatched = transferOrdervoucherMatched)
    {
        transferOrdervoucherMatched = _transferOrdervoucherMatched;
        return transferOrdervoucherMatched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reorderInventTransListByInventDimPhysicalMatch</Name>
				<Source><![CDATA[
    private List reorderInventTransListByInventDimPhysicalMatch(List _inventTransList, InventDim _inventDimCriteria, InventDimParm _inventDimParm)
    {
        if (_inventTransList.elements() == 1)
        {
            return _inventTransList;
        }

        InventDimParm inventDimParm;

        // Fetch physical dimension from inventDim criteria.
        inventDimParm.initPhysicalDimensionsFromInventDim(movement.inventDimGroupSetup(), _inventDimCriteria);

        List inventTransListSameDimId;
        List inventTransListSamePhysicalDim;
        List inventTransListLowPriority;

        ListEnumerator inventTransListEnumerator = _inventTransList.getEnumerator();
        InventTrans inventTrans;
        boolean isAddedInList;
        while (inventTransListEnumerator.moveNext())
        {
            inventTrans = null;
            inventTrans = inventTransListEnumerator.current();
            isAddedInList = false;
            if (inventTrans.InventDimId == _inventDimCriteria.InventDimId)
            {
                if (!inventTransListSameDimId)
                {
                    inventTransListSameDimId = new List(Types::Record);
                }
                inventTransListSameDimId.addEnd(inventTrans);
                isAddedInList = true;
            }
            else if ((inventDimParm.InventBatchIdFlag && !_inventDimParm.InventBatchIdFlag)
                    || (inventDimParm.InventLocationIdFlag && !_inventDimParm.InventLocationIdFlag)
                    || (inventDimParm.WMSLocationIdFlag && !_inventDimParm.WMSLocationIdFlag))
            {
                // Batch dimension flag or locationId flag is cleaned up, need to compare inventory dimension from physical dimension of inventDim criteria
                InventDim inventDim = InventTrans.inventdim();
                if (InventDim::isInventDimEqual(inventDim, _inventDimCriteria, inventDimParm.selectedDimFields()))
                {
                    if (!inventTransListSamePhysicalDim)
                    {
                        inventTransListSamePhysicalDim = new List(Types::Record);
                    }
                    inventTransListSamePhysicalDim.addEnd(inventTrans);
                    isAddedInList = true;
                }
            }

            if (!isAddedInList)
            {
                if (!inventTransListLowPriority)
                {
                    inventTransListLowPriority = new List(Types::Record);
                }

                inventTransListLowPriority.addEnd(inventTrans);
            }
        }
   
        List orderedInventTransList = new List(Types::Record);
        if (inventTransListSameDimId)
        {
            orderedInventTransList.appendList(inventTransListSameDimId);
        }

        if (inventTransListSamePhysicalDim)
        {
            orderedInventTransList.appendList(inventTransListSamePhysicalDim);
        }

        if (inventTransListLowPriority)
        {
            orderedInventTransList.appendList(inventTransListLowPriority);
        }

        return orderedInventTransList;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>