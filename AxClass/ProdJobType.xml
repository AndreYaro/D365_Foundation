<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProdJobType</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProdJobType
{
    JmgJobRefCost jmgJobRefCost;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activation</Name>
				<Source><![CDATA[
    NoYes activation(RouteGroup routeGroup)
    {
        return RouteJobSetup::find(routeGroup.RouteGroupId,this.routeJobType()).Activation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRouteExecutedPct</Name>
				<Source><![CDATA[
    void addRouteExecutedPct(
        ProdRoute       _prodRoute,
        ProdExecutedPct _executedPct)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmount</Name>
				<Source><![CDATA[
    CostAmount calcAmount(ProdRouteTrans prodRouteTrans)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCalcHours</Name>
				<Source><![CDATA[
    Hours calcCalcHours(
        BOMCalcData             itemCalcData,
        RouteMap                primaryRoute,
        RouteOprMap             primaryOpr,
        RouteMap                route,
        RouteOprMap             opr,
        RouteAutoConsump        routeAutoConsump        = RouteAutoConsump::Always,
        NoYes                   includeConstantConsump  = NoYes::Yes
        )
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCalcQty</Name>
				<Source><![CDATA[
    Qty  calcCalcQty(
        BOMCalcData         itemCalcData,
        RouteMap            primaryRoute,
        RouteOprMap         primaryOpr,
        RouteMap            route,
        RouteOprMap         opr,
        RouteAutoConsump    routeAutoConsump= RouteAutoConsump::Always,
        boolean             inclSecondary   = false,
        NoYes               includeConstantConsump  = NoYes::Yes
        )
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCalcQtyError</Name>
				<Source><![CDATA[
    Qty   calcCalcQtyError(
        BOMCalcData             itemCalcData,
        RouteMap                primaryRoute,
        RouteOprMap             primaryOpr,
        RouteMap                route,
        RouteOprMap             opr,
        RouteAutoConsump        routeAutoConsump= RouteAutoConsump::Always,
        NoYes                   includeConstantConsump  = NoYes::Yes
        )
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCalcQtyGood</Name>
				<Source><![CDATA[
    Qty calcCalcQtyGood(
        BOMCalcData             itemCalcData,
        RouteMap                primaryRoute,
        RouteOprMap             primaryOpr,
        RouteMap                route,
        RouteOprMap             opr,
        RouteAutoConsump        routeAutoConsump= RouteAutoConsump::Always,
        NoYes                   includeConstantConsump = NoYes::Yes
        )
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcJobSchedJobTime</Name>
				<Source><![CDATA[
    Hours calcJobSchedJobTime(
        ProdRouteJob    _prodRouteJob,
        ProdRoute       _prodRoute,
        Hours           _calcTime)
    {
        if (_prodRouteJob.JobStatus >= ProdJobStatus::Completed || _prodRoute.OprFinished)
            return 0;
        else
            return _calcTime * (100 - min(_prodRouteJob.ExecutedPct,100)) / 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRouteSchedJobTime</Name>
				<Source><![CDATA[
    Hours calcRouteSchedJobTime(
        ProdRoute   _prodRoute,
        Hours       _calcTime)
    {
        if (_prodRoute.OprFinished)
            return 0;
        else
            return _calcTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWrkCtrHours</Name>
				<Source><![CDATA[
    public Hours calcWrkCtrHours(BOMCalcData    _itemCalcData,
                                 RouteMap       _primaryRoute,
                                 RouteOprMap    _primaryOpr,
                                 WrkCtrId       _wrkCtrId,
                                 RouteMap       _route,
                                 RouteOprMap    _opr,
                                 ItemId         _itemId         = '', // BOM itemId
                                 InventDimId    _inventDimId    = '') // BOM item's dimension
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcProcessingPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes job's processing percentage based on route/job card feedback
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route
    /// </param>
    protected void calcProcessingPercentage(ProdRoute _prodRoute)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJobSequence</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the job follows the job sequence.
    /// </summary>
    /// <param name="_currentJob">
    ///    A map instance that contains the job information for which to check the sequence.
    /// </param>
    /// <param name="_prevJob">
    ///    The previous job information.
    /// </param>
    /// <param name="_nextJob">
    ///    The next job information.
    /// </param>
    /// <param name="_identifierFieldIds">
    ///    A container with the field Ids that will be used in building a job identifier.
    /// </param>
    /// <param name="_link">
    ///    A <c>SchedJobLink</c> enumeration value forced by the caller thateplaces the link information that
    ///    is on the data record; optional.
    /// </param>
    /// <returns>
    ///    true if the job does not break the sequence; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method implements the default checks for job sequence. The special rules should be implemented
    ///    in the derived classes.
    /// </remarks>
    public boolean checkJobSequence(RouteJobMap     _currentJob,
                                    RouteJobMap     _prevJob,
                                    RouteJobMap     _nextJob,
                                    container       _identifierFieldIds,
                                    SchedJobLink    _link = SchedJobLink::None)
    {
        boolean         ret = true;
        boolean         isLinkParamDefault = prmisdefault (_link);
        boolean         isProdJobTypeCheckJobSequenceFlightEnabled = ProdJobTypeCheckJobSequenceFlight::instance().isEnabled();

        boolean checkLinkSequence (RouteJobMap _linkPrevJob, RouteJobMap _linkNextJob)
        {
            SchedJobLink    link = _linkPrevJob.Link;

            if (!isLinkParamDefault)
            {
                link = _link;
            }

            switch (link)
            {
                case SchedJobLink::SF:
                    if (_linkNextJob.ToDate      >   _linkPrevJob.FromDate ||
                        (_linkNextJob.ToDate     ==  _linkPrevJob.FromDate &&
                         _linkNextJob.ToTime     >   _linkPrevJob.FromTime))
                    {
                        if (isProdJobTypeCheckJobSequenceFlightEnabled)
                        {
                            return checkFailed(strfmt("@SCM:JobCheckJobSequenceStartFinish",
                                                  _linkNextJob.RefId,
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                        else
                        {
                            return checkFailed(strfmt("@SYS118117",
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                    }
                    break;

                case SchedJobLink::FF:
                    if (_linkNextJob.ToDate      !=  _linkPrevJob.ToDate ||
                        _linkNextJob.ToTime      !=  _linkPrevJob.ToTime)
                    {
                        if (isProdJobTypeCheckJobSequenceFlightEnabled)
                        {
                            return checkFailed(strfmt("@SCM:JobCheckJobSequenceFinishFinish",
                                                  _linkNextJob.RefId,
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                        else
                        {
                            return checkFailed(strfmt("@SYS118118",
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                    }
                    break;

                case SchedJobLink::FS:
                    if (_linkNextJob.FromDate    <   _linkPrevJob.ToDate ||
                        (_linkNextJob.FromDate   ==  _linkPrevJob.ToDate &&
                         _linkNextJob.FromTime   <   _linkPrevJob.ToTime))
                    {
                        if (isProdJobTypeCheckJobSequenceFlightEnabled)
                        {
                            return checkFailed(strfmt("@SCM:JobCheckJobSequenceFinishStart",
                                                  _linkNextJob.RefId,
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                        else
                        {
                            return checkFailed(strfmt("@SYS118119",
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                    }
                    break;

                case SchedJobLink::SS:
                    if (_linkNextJob.FromDate    !=   _linkPrevJob.FromDate ||
                        _linkNextJob.FromTime    !=   _linkPrevJob.FromTime)
                    {
                        if (isProdJobTypeCheckJobSequenceFlightEnabled)
                        {
                            return checkFailed(strfmt("@SCM:JobCheckJobSequenceStartStart",
                                                  _linkNextJob.RefId,
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                        else
                        {
                            return checkFailed(strfmt("@SYS118120",
                                                  _linkPrevJob.composeJobDescriptionText(_identifierFieldIds),
                                                  _linkNextJob.composeJobDescriptionText(_identifierFieldIds)));
                        }
                    }
                    break;
            }

            return true;
        }

        if (_nextJob.RefId && _currentJob.RefId)
        {
            ret = checkLinkSequence(_currentJob, _nextJob);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalCategoryHours</Name>
				<Source><![CDATA[
    boolean checkJournalCategoryHours(ProdJournalRoute   prodJournalRoute,
                                NoYes             mandatory= NoYes::No
                               )
    {
        boolean ok = true;

        if (prodJournalRoute.CategoryHoursId)
            ok = RouteCostCategory::checkExist(prodJournalRoute.CategoryHoursId);
        else if (mandatory)
            ok = checkFailed("@SYS17486");
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalCategoryQty</Name>
				<Source><![CDATA[
    boolean checkJournalCategoryQty(ProdJournalRoute   prodJournalRoute,
                                NoYes             mandatory= NoYes::No
                               )
    {
        boolean ok = true;

        if (prodJournalRoute.CategoryQtyId)
            ok = RouteCostCategory::checkExist(prodJournalRoute.CategoryQtyId);
        else
        if (mandatory)
            ok = checkFailed("@SYS14518");
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalEmployee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that the employee that is specified on the route journal is valid.
    /// </summary>
    /// <param name="_prodJournalRoute">
    /// The <c>ProdRouteJournal</c> record to be checked.
    /// </param>
    /// <param name="_mandatory">
    /// A Boolean value that indicates whether the employee is mandatory on the route card journal.
    /// </param>
    /// <returns>
    /// true if the check is successful; otherwise, false.
    /// </returns>
    public boolean checkJournalEmployee(ProdJournalRoute _prodJournalRoute, NoYes _mandatory  = NoYes::No)
    {
        boolean ok = true;

        if (_prodJournalRoute.Worker)
        {
            ok = HcmWorkerLookup::newCustomOptions(true, true, true, false, false, true, true, true, true, false).validateWorker(_prodJournalRoute.Worker);
            if (!ok)
            {
                error(strfmt("@SYS39817", HcmWorker::find(_prodJournalRoute.Worker).PersonnelNumber));
            }
        }
        else if (_mandatory)
        {
            ok = checkFailed("@SYS24420");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalHours</Name>
				<Source><![CDATA[
    boolean checkJournalHours(ProdJournalRoute prodJournalRoute, boolean ask = false)
    {
        if (ask)
            return false;

        if (prodJournalRoute.Hours)
            return checkFailed(strfmt("@SYS22230",prodJournalRoute.JobType));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalJobActivation</Name>
				<Source><![CDATA[
    boolean checkJournalJobActivation(ProdJournalRoute   prodJournalRoute,
                                      NoYes             mandatory= NoYes::No
                                      )
    {
        boolean     ok = true;

        if (prodJournalRoute.OprNum)
        {
            if (! this.activation(prodJournalRoute.prodRoute().routeGroup()))
                ok = checkFailed(strfmt("@SYS27617",this.routeJobType()));
        }
        else if (mandatory)
            ok = checkFailed("@SYS24422");

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalJobId</Name>
				<Source><![CDATA[
    boolean checkJournalJobId(ProdJournalRoute   prodJournalRoute,
                             NoYes             mandatory= NoYes::No
                            )
    {
        boolean        ok = true;

        if (prodJournalRoute.JobId)
        {
            ProdRouteJob prodRouteJob = prodJournalRoute.prodRouteJob();
            ok = prodRouteJob.checkValid();
        }
        else if (mandatory)
            ok = checkFailed("@SYS24417");
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalNumOfError</Name>
				<Source><![CDATA[
    boolean checkJournalNumOfError(ProdJournalRoute prodJournalRoute, boolean ask = false)
    {
        if (ask)
            return false;

        if (prodJournalRoute.QtyError)
            return checkFailed(strfmt("@SYS22228",prodJournalRoute.JobType));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalNumOfGood</Name>
				<Source><![CDATA[
    boolean checkJournalNumOfGood(ProdJournalRoute prodJournalRoute,boolean ask = false)
    {
        if (ask)
            return false;

        if (prodJournalRoute.QtyGood)
            return checkFailed(strfmt("@SYS22229",prodJournalRoute.JobType));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalOprId</Name>
				<Source><![CDATA[
    boolean checkJournalOprId(
        ProdJournalRoute    prodJournalRoute,
        NoYes               mandatory= NoYes::No
        )
    {
        boolean     ok = true;

        if (prodJournalRoute.OprId)
            ok = RouteOprTable::checkExist(prodJournalRoute.OprId);
        else if (mandatory)
            ok = checkFailed("@SYS24421");

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalOprNum</Name>
				<Source><![CDATA[
    boolean checkJournalOprNum(ProdJournalRoute   prodJournalRoute,
                             NoYes             mandatory= NoYes::Yes
                            )
    {
        boolean     ok = true;

        if (prodJournalRoute.OprNum)
        {
            ProdRoute prodRoute = prodJournalRoute.prodRoute();
            ok          = prodRoute.checkValid();
        }
        else if (mandatory)
            ok = checkFailed("@SYS24422");

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalPayrollCategoryHours</Name>
				<Source><![CDATA[
    boolean checkJournalPayrollCategoryHours(ProdJournalRoute   prodJournalRoute,
                                   NoYes             mandatory= NoYes::No
                                  )
    {
        boolean ok = true;

        if (mandatory)
            ok = checkFailed("@SYS24419");

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalPayrollCategoryQty</Name>
				<Source><![CDATA[
    boolean checkJournalPayrollCategoryQty(ProdJournalRoute   prodJournalRoute,
                                   NoYes             mandatory= NoYes::No
                                  )
    {
        boolean ok = true;

        if (mandatory)
            ok = checkFailed("@SYS24418");
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalWIPLedgerAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the work in process ledger accounts can be determined for the specified <c>ProdJournalRoute</c> record.
    /// </summary>
    /// <param name="_prodJournalRoute">
    /// A <c>ProdJournalRoute</c> record which represent a route card journal line or a job card journal line.
    /// </param>
    /// <returns>
    /// true if the work in process ledger accounts can be determined; otherwise, false.
    /// </returns>
    public boolean checkJournalWIPLedgerAccounts(ProdJournalRoute _prodJournalRoute)
    {
        boolean         ok = true;
        ProdRouteTrans  prodRouteTrans;

        prodRouteTrans.initFromProdJournalRoute(_prodJournalRoute);
        prodRouteTrans.initFromProdJournalRouteHour(_prodJournalRoute);
        prodRouteTrans.CategoryId = _prodJournalRoute.CategoryHoursId;

        if (this.mustWIPBePosted(prodRouteTrans))
        {
            ok = this.checkProdRouteTransWIPAccounts(prodRouteTrans);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalWrkCtrId</Name>
				<Source><![CDATA[
    boolean checkJournalWrkCtrId(
        ProdJournalRoute    prodJournalRoute,
        NoYes               mandatory= NoYes::No
        )
    {
        boolean ok = true;

        if (prodJournalRoute.WrkCtrId)
            ok = WrkCtrTable::checkExist(prodJournalRoute.WrkCtrId);
        else if (mandatory)
            ok = checkFailed("@SYS17694");

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProdRouteTransWIPAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the work in the process ledger accounts can be determined for the specified
    ///    <c>ProdRouteTrans</c> record.
    /// </summary>
    /// <param name="_prodRouteTrans">
    ///    A <c>ProdRouteTrans</c> record that represents a route transaction.
    /// </param>
    /// <returns>
    ///    true if the work in the process ledger accounts can be determined; otherwise, false.
    /// </returns>
    protected boolean checkProdRouteTransWIPAccounts(ProdRouteTrans  _prodRouteTrans)
    {
        boolean     ok          = true;
        ProdTable   prodTable   = ProdTable::find(_prodRouteTrans.TransRefId);

        switch (prodTable.ProdPostingType)
        {
            case ProdPostingType::ItemWrkCtr:
                setprefix(fieldLabelValue(_prodRouteTrans.TableId, fieldnum(ProdRouteTrans,WrkCtrId), _prodRouteTrans.WrkCtrId));
                break;
            case ProdPostingType::ItemCategory:
                setprefix(fieldLabelValue(_prodRouteTrans.TableId, fieldnum(ProdRouteTrans,CategoryId), _prodRouteTrans.CategoryId));
                break;
            case ProdPostingType::ProdGroup:
                setprefix(fieldLabelValue(prodTable.TableId, fieldnum(ProdTable,ProdGroupId), prodTable.ProdGroupId));
                break;
        }

        if (!this.wipValuationLedgerDimension(_prodRouteTrans))
        {
            ok = checkFailed("@SYS81903");
        }

        if (!this.wipIssueLedgerDimension(_prodRouteTrans))
        {
            ok = checkFailed("@SYS81904");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTrans</Name>
				<Source><![CDATA[
    boolean checkProjTrans(ProdJournalRoute _prodJournalRoute, ProdJournalRouteProj _prodJournalRouteProj)
    {
        ProdRouteTrans  prodRouteTrans;
        ProdRoute       prodRouteSecondary;
        boolean         ok  = true;

        if (!_prodJournalRoute.willCostBePosted(_prodJournalRouteProj.TransType))
        {
            return true;
        }

        prodRouteTrans.initFromProdJournalRoute(_prodJournalRoute);

        switch (_prodJournalRouteProj.TransType)
        {
            case ProdRouteTransType::Qty:
                prodRouteTrans.initFromProdJournalRouteQty(_prodJournalRoute);
                break;
            case ProdRouteTransType::Time:
                prodRouteTrans.initFromProdJournalRouteHour(_prodJournalRoute);
                break;
        }

        if (this.mustProjBePosted(prodRouteTrans))
        {
            ok = ProjPost::newProdCheckTrans(_prodJournalRoute, _prodJournalRouteProj).checkTrans();

            // Verify qty category for secondary operations
            if (_prodJournalRouteProj.TransType == ProdRouteTransType::Qty)
            {
                if (_prodJournalRoute.OprPriority == RouteOprPriority::Primary &&
                   (_prodJournalRoute.QtyGood > 0 || _prodJournalRoute.QtyError > 0))
                {
                    while select QtyCategoryId from prodRouteSecondary
                        where prodRouteSecondary.ProdId  == _prodJournalRoute.ProdId
                              && prodRouteSecondary.OprNum == _prodJournalRoute.OprNum
                              && prodRouteSecondary.OprPriority != RouteOprPriority::Primary
                              && prodRouteSecondary.QtyCategoryId
                    {
                        ok = ok && ProdRoute::checkProjCategoryId(prodRouteSecondary.QtyCategoryId);
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costEstimateHours</Name>
				<Source><![CDATA[
    NoYes costEstimateHours(RouteGroup routeGroup)
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costEstimateQty</Name>
				<Source><![CDATA[
    NoYes costEstimateQty(RouteGroup routeGroup)
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionFromDefaultAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Wraps <c>LedgerDimensionFacade::serviceCreateLedgerDimension</c> method.
    /// </summary>
    /// <param name="_defaultAccount">
    /// The ID of the <c>DimensionAttributeValueCombination</c> record that represents the default account.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of a default dimension set to use; optional.
    /// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    /// <remarks>
    /// Calling this method with an empty default account will not throw an exception.
    /// </remarks>
    protected LedgerDimensionAccount getLedgerDimensionFromDefaultAccount(
        LedgerDimensionDefaultAccount   _defaultAccount,
        DimensionDefault                _defaultDimension)
    {
        if (!_defaultAccount)
            return 0;
        else
            return LedgerDimensionFacade::serviceCreateLedgerDimension(_defaultAccount, _defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdJournalRoute</Name>
				<Source><![CDATA[
    ProdJournalRoute initProdJournalRoute(ProdRoute      prodRoute,
                                        ProdJournalRoute prodJournalRoute  = null,
                                        ProdRouteJob     prodRouteJob      = null,
                                        boolean          resetCategoryId   = false
                                   )
    {
        WrkCtrTable         wrkCtrTable;
        date                searchDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (prodRoute.ProdId)
        {
            prodJournalRoute.ProdId        = prodRoute.ProdId;
        }

        prodJournalRoute.OprNum        = prodRoute.OprNum;
        prodJournalRoute.OprPriority   = prodRoute.OprPriority;
        prodJournalRoute.OprId         = prodRoute.OprId;

        if (! prodRouteJob)
        {
            if (prodRoute)
            {
                if (prodRoute.FromDate)
                {
                    searchDate = prodRoute.FromDate;
                }
                else if (prodJournalRoute.TransDate)
                {
                    searchDate = prodJournalRoute.TransDate;
                }

                wrkCtrTable                 = prodRoute.getResource(true, true, searchDate, searchDate, prodRoute.prodTable().inventDim().InventSiteId, false, true);
            }

            prodJournalRoute.JobId          = '';
        }
        else
        {
            wrkCtrTable = WrkCtrTable::find(prodRouteJob.WrkCtrId);

            if (prodRouteJob.RealizedStartDate == prodJournalRoute.TransDate)
                prodJournalRoute.FromTime = prodRouteJob.RealizedStartTime;
        }

        DimensionMerge   dimMerge = DimensionMerge::newFromTable(null, prodJournalRoute.companyInfo().RecId);

        prodJournalRoute.WrkCtrId           = wrkCtrTable.WrkCtrId;
        prodJournalRoute.Worker             = wrkCtrTable.Worker;
        prodJournalRoute.DefaultDimension   = prodJournalRoute.mergeDimension(prodRoute.DefaultDimension, wrkCtrTable.DefaultDimension, dimMerge);

        prodJournalRoute.JobType       = this.routeJobType();

        if (prodJournalRoute.isProjMethodConsumed())
            prodJournalRoute.DefaultDimension = prodJournalRoute.copyDimension(prodRoute.DefaultDimension);

        return prodJournalRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdJournalRouteProj</Name>
				<Source><![CDATA[
    ProdJournalRouteProj initProdJournalRouteProj(ProdRouteTransType    _type,
                                                  ProdJournalRoute      _prodJournalRoute,
                                                  ProdJournalRouteProj  _prodJournalRouteProj  = null)
    {
        _prodJournalRouteProj.JournalId = _prodJournalRoute.JournalId;
        _prodJournalRouteProj.LineNum = _prodJournalRoute.LineNum;
        _prodJournalRouteProj.TransType = _type;

        ProjJournalTransMapForm::construct(_prodJournalRouteProj, _prodJournalRoute).initProdJournalRouteProj(_type);

        return _prodJournalRouteProj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRouteJobSetup</Name>
				<Source><![CDATA[
    RouteJobSetup initRouteJobSetup(RouteJobSetup routeJobSetup = null)
    {
        routeJobSetup.Activation        = NoYes::Yes;
        routeJobSetup.SchedCapacity     = NoYes::No;
        routeJobSetup.SchedWorkTime     = NoYes::No;
        routeJobSetup.JobCtrlTime       = NoYes::No;

        return routeJobSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWrkCtrHoursResourceIndependent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the calculation of work center hours depends on the resource.
    /// </summary>
    /// <param name="_primaryOpr">
    ///    A <c>RouteOprMap</c> map for the primary operation.
    /// </param>
    /// <returns>
    ///    true if the calculation of wrkCtrHours is resource independent; otherwise, false.
    /// </returns>
    public boolean isWrkCtrHoursResourceIndependent(RouteOprMap _primaryOpr)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCalcBePosted</Name>
				<Source><![CDATA[
    boolean mustCalcBePosted(ProdRouteTrans prodRouteTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustJobBeControlled</Name>
				<Source><![CDATA[
    NoYes mustJobBeControlled(RouteGroup routeGroup)
    {
        return RouteJobSetup::find(routeGroup.RouteGroupId,this.routeJobType()).JobCtrlTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustProjBePosted</Name>
				<Source><![CDATA[
    boolean mustProjBePosted(ProdRouteTrans prodRouteTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustWIPBePosted</Name>
				<Source><![CDATA[
    boolean mustWIPBePosted(ProdRouteTrans prodRouteTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>numType</Name>
				<Source><![CDATA[
    Integer numType()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJmgJobRefCost</Name>
				<Source><![CDATA[
    public JmgJobRefCost parmJmgJobRefCost(JmgJobRefCost _value = jmgJobRefCost)
    {
        jmgJobRefCost = _value;
        return jmgJobRefCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWCalcCalcQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the catch weight error quantity.
    /// </summary>
    /// <param name="_itemCalcData">
    /// The calculation settings.
    /// </param>
    /// <param name="_primaryRoute">
    /// The primary route.
    /// </param>
    /// <param name="_primaryOpr">
    /// The primary operation.
    /// </param>
    /// <param name="_route">
    /// The current route.
    /// </param>
    /// <param name="_opr">
    /// The current operation.
    /// </param>
    /// <param name="_routeAutoConsump">
    /// The auto consumption settings; optional.
    /// </param>
    /// <param name="_includeConstantConsump">
    /// A Boolean value that determines whether the constant consumption should be included; optional.
    /// </param>
    /// <returns>
    /// The calculated catch weight error quantity.
    /// </returns>
    public PdsCWInventQty  pdsCWCalcCalcQtyError(
        BOMCalcData             _itemCalcData,
        RouteMap                _primaryRoute,
        RouteOprMap             _primaryOpr,
        RouteMap                _route,
        RouteOprMap             _opr,
        RouteAutoConsump        _routeAutoConsump= RouteAutoConsump::Always,
        NoYes                   _includeConstantConsump  = NoYes::Yes
        )
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWCalcCalcQtyGood</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the catch weight good quantity.
    /// </summary>
    /// <param name="_itemCalcData">
    /// The calculation settings.
    /// </param>
    /// <param name="_primaryRoute">
    /// The primary route.
    /// </param>
    /// <param name="_primaryOpr">
    /// The primary operation.
    /// </param>
    /// <param name="_route">
    /// The current route.
    /// </param>
    /// <param name="_opr">
    /// The current operation.
    /// </param>
    /// <param name="_routeAutoConsump">
    /// The auto consumption settings; optional.
    /// </param>
    /// <param name="_includeConstantConsump">
    /// A Boolean value that determines whether the constant consumption should be included; optional.
    /// </param>
    /// <returns>
    /// The calculated catch weight good quantity.
    /// </returns>
    public PdsCWInventQty pdsCWCalcCalcQtyGood(
        BOMCalcData             _itemCalcData,
        RouteMap                _primaryRoute,
        RouteOprMap             _primaryOpr,
        RouteMap                _route,
        RouteOprMap             _opr,
        RouteAutoConsump        _routeAutoConsump= RouteAutoConsump::Always,
        NoYes                   _includeConstantConsump = NoYes::Yes
        )
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingCalcIssue</Name>
				<Source><![CDATA[
    LedgerPostingType postingCalcIssue(ProdRouteTrans prodRouteTrans)
    {
        return LedgerPostingType::ProdWrkCtrIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingCalcOffsetIssue</Name>
				<Source><![CDATA[
    LedgerPostingType postingCalcOffsetIssue(ProdRouteTrans prodRouteTrans)
    {
        return LedgerPostingType::ProdWrkCtrIssueOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingWIPIssue</Name>
				<Source><![CDATA[
    LedgerPostingType postingWIPIssue(ProdRouteTrans prodRouteTrans)
    {
        return LedgerPostingType::ProdWIPIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingWIPValuation</Name>
				<Source><![CDATA[
    LedgerPostingType postingWIPValuation(ProdRouteTrans prodRouteTrans)
    {
        return LedgerPostingType::ProdWIPValuation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>propertyId</Name>
				<Source><![CDATA[
    PropertyId propertyId(
        RouteMap    route,
        RouteOprMap opr)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceIssueLedgerDimension</Name>
				<Source><![CDATA[
    LedgerDimensionAccount resourceIssueLedgerDimension(ProdRouteTrans prodRouteTrans)
    {
        switch (ProdTable::find(prodRouteTrans.TransRefId).ProdPostingType)
        {
            case ProdPostingType::ItemWrkCtr    :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(WrkCtrTable::find(prodRouteTrans.WrkCtrId).ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ItemCategory  :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(RouteCostCategory::find(prodRouteTrans.CategoryId).ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ProdGroup     :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
        }
        return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceIssueOffsetLedgerDimension</Name>
				<Source><![CDATA[
    LedgerDimensionAccount resourceIssueOffsetLedgerDimension(ProdRouteTrans prodRouteTrans)
    {
        switch (ProdTable::find(prodRouteTrans.TransRefId).ProdPostingType)
        {
            case ProdPostingType::ItemWrkCtr    :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(WrkCtrTable::find(prodRouteTrans.WrkCtrId).ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ItemCategory  :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(RouteCostCategory::find(prodRouteTrans.CategoryId).ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ProdGroup     :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
        }
        return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>routeJobType</Name>
				<Source><![CDATA[
    RouteJobType routeJobType()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleAllJobs</Name>
				<Source><![CDATA[
    boolean scheduleAllJobs()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleCapacity</Name>
				<Source><![CDATA[
    NoYes  scheduleCapacity(RouteGroup routeGroup)
    {
        return RouteJobSetup::find(routeGroup.RouteGroupId,this.routeJobType()).SchedCapacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleNextJobLink</Name>
				<Source><![CDATA[
    SchedJobLink scheduleNextJobLink()
    {
        return SchedJobLink::FS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleNextJobLinkType</Name>
				<Source><![CDATA[
    SchedJobLinkType scheduleNextJobLinkType()
    {
        return SchedJobLinkType::Soft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulePrevJobLink</Name>
				<Source><![CDATA[
    SchedJobLink schedulePrevJobLink()
    {
        return SchedJobLink::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulePrevJobLinkType</Name>
				<Source><![CDATA[
    SchedJobLinkType schedulePrevJobLinkType()
    {
        return SchedJobLinkType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleSecondaryJobs</Name>
				<Source><![CDATA[
    boolean scheduleSecondaryJobs()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleWorkTime</Name>
				<Source><![CDATA[
    NoYes scheduleWorkTime(RouteGroup routeGroup)
    {
        return RouteJobSetup::find(routeGroup.RouteGroupId, this.routeJobType()).SchedWorkTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCalcConsumptionProdRoute</Name>
				<Source><![CDATA[
    void setCalcConsumptionProdRoute(ProdRoute          prodRoute,
                               BOMCalcData      itemCalcData
                              )
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCostCategoryHoursFromResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a cost category based on a resource and route operation's job type
    /// </summary>
    /// <param name="_prodJournalRoute">
    /// The route card journal line
    /// </param>
    /// <param name="_wrkCtrTable">
    /// The distinct resource
    /// </param>
    internal void setCostCategoryHoursFromResource(ProdJournalRoute  _prodJournalRoute,
                                                   WrkCtrTable       _wrkCtrTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCalcLedger</Name>
				<Source><![CDATA[
    void updateCalcLedger( LedgerVoucher    _ledgerVoucher,
                           ProdTableJour     prodTableJour,
                           ProdRouteTrans    prodRouteTrans
                          )
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        // <GEERU>
        boolean                     correction_RU = _ledgerVoucher.findLedgerVoucherObject().parmCorrection() || InventParameters::find().StornoPhysicalPosting_RU;
        // </GEERU>

        setprefix(#PreFixField(ProdRouteTrans,OprNum));

        if (prodRouteTrans.Calculated)
            throw error("@SYS22231");

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());

        boolean getReversalCurrencyExchange = false;

        if (prodRouteTrans.PostingWIPValuation && prodRouteTrans.Amount)
        {
            // For reverse
            if (InventoryReportingCurrencyTriangulationFeature::instance().isEnabled())
            {
                currencyExchHelper = InventoryReportingCurrencyTriangulationHelper::getReversalCurrencyExchangeHelperFromGL(
                        currencyExchHelper,
                        prodRouteTrans.PostingWIPValuation,
                        prodRouteTrans.VoucherWIP,
                        prodRouteTrans.DataAreaId,
                        prodRouteTrans.DateWIP,
                        CompanyInfoHelper::standardCurrency());

                getReversalCurrencyExchange = true;
            }

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucherObject,
                    prodRouteTrans.PostingWIPValuation,
                    prodRouteTrans.wipValuationLedgerDimension,
                    CompanyInfoHelper::standardCurrency(),
                   -prodRouteTrans.Amount,
                    currencyExchHelper);

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            // <GEERU>
            if (prodRouteTrans.Amount > 0)
            {
                ledgerVoucherTransObject.parmCorrect(correction_RU);
            }
            // </GEERU>

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucherObject,
                    prodRouteTrans.PostingWIPIssue,
                    prodRouteTrans.wipIssueLedgerDimension,
                    CompanyInfoHelper::standardCurrency(),
                    prodRouteTrans.Amount,
                    currencyExchHelper);

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            // <GEERU>
            if (prodRouteTrans.Amount > 0)
            {
                ledgerVoucherTransObject.parmCorrect(correction_RU);
            }
            // </GEERU>

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // <GEERU>
            _ledgerVoucher.bondLast2_RU();
            // </GEERU>
        }

        if (getReversalCurrencyExchange && InventoryReportingCurrencyTriangulationFeature::instance().isEnabled())
        {
            currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        }

        if (this.mustCalcBePosted(prodRouteTrans))
        {
            prodRouteTrans.PostingCalcIssueOffset     = this.postingCalcOffsetIssue(prodRouteTrans);
            prodRouteTrans.PostingCalcIssue           = this.postingCalcIssue(prodRouteTrans);
            prodRouteTrans.IssueOffsetLedgerDimension = this.resourceIssueOffsetLedgerDimension(prodRouteTrans);
            prodRouteTrans.IssueLedgerDimension       = this.resourceIssueLedgerDimension(prodRouteTrans);

            if (jmgJobRefCost)
            {
                prodRouteTrans.Amount = CurrencyExchangeHelper::amount(jmgJobRefCost.getProdRouteTransCost(prodRouteTrans));
            }

            // <GEERU>
            ledgerVoucherTransObject =
            // </GEERU>
                LedgerVoucherTransObject::newTransactionAmountDefault(
                    _ledgerVoucher.findLedgerVoucherObject(),
                    prodRouteTrans.PostingCalcIssueOffset,
                    prodRouteTrans.IssueOffsetLedgerDimension,
                    CompanyInfoHelper::standardCurrency(),
                    prodRouteTrans.Amount,
            // <GEERU>
                    currencyExchHelper);

            if (prodRouteTrans.Amount < 0)
            {
                ledgerVoucherTransObject.parmCorrect(correction_RU);
            }

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
            // </GEERU>

            // <GEERU>
            ledgerVoucherTransObject =
            // </GEERU>
                LedgerVoucherTransObject::newTransactionAmountDefault(
                    _ledgerVoucher.findLedgerVoucherObject(),
                    prodRouteTrans.PostingCalcIssue,
                    prodRouteTrans.IssueLedgerDimension,
                    CompanyInfoHelper::standardCurrency(),
                   -prodRouteTrans.Amount,
            // <GEERU>
                    currencyExchHelper);

            if (prodRouteTrans.Amount < 0)
            {
                ledgerVoucherTransObject.parmCorrect(correction_RU);
            }

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            _ledgerVoucher.bondLast2_RU();
            // </GEERU>
            prodTableJour.AmountFinancial+= prodRouteTrans.Amount;
        }
        else
        {
            prodRouteTrans.PostingCalcIssueOffset       = LedgerPostingType::None;
            prodRouteTrans.PostingCalcIssue             = LedgerPostingType::None;
            prodRouteTrans.IssueOffsetLedgerDimension   = 0;
            prodRouteTrans.IssueLedgerDimension         = 0;
            if (this.mustProjBePosted(prodRouteTrans))
                prodTableJour.AmountFinancial+= prodRouteTrans.Amount;
        }

        prodRouteTrans.Calculated    = NoYes::Yes;
        prodRouteTrans.DateCalc      = _ledgerVoucher.lastTransDate();
        prodRouteTrans.VoucherCalc   = _ledgerVoucher.lastVoucher();
        prodRouteTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjLedger</Name>
				<Source><![CDATA[
    void updateProjLedger(LedgerVoucher              _ledgerVoucher,
                          ProdRouteTrans             _prodRouteTrans,
                          ProdJournalRoute           _prodJournalRoute,
                          ProdJournalRouteProj  _prodJournalRouteProj,
                          ProjTransIdBase            _projTransId)
    {
        if (_prodRouteTrans.Amount && this.mustProjBePosted(_prodRouteTrans))
            ProjPost::newCreateProdTransAndLedger(_prodRouteTrans, _prodJournalRoute, _prodJournalRouteProj, _projTransId, _ledgerVoucher).postTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRealConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the realized consumption of a production order.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> record.
    /// </param>
    /// <param name="_prodRouteTrans">
    /// The <c>ProdRouteTrans</c> record.
    /// </param>
    /// <param name="_addValues">
    /// True if values should be added to existing consumption; false otherwise.
    /// </param>
    /// <param name="_pmfAllocation">
    /// The allocation percentage.
    /// </param>
    public void updateRealConsumption(ProdTable        _prodTable,
                               ProdRouteTrans   _prodRouteTrans,
                                      boolean          _addValues = true,
                                      Percent          _pmfAllocation = 100)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRealConsumptionCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the obtained consumption for the co-product or byproduct.
    /// </summary>
    /// <param name="_prodTable">
    /// A production record.
    /// </param>
    /// <param name="_prodRouteTrans">
    /// A production route transaction.
    /// </param>
    /// <param name="_allocation">
    /// A cost allocation percentage.
    /// </param>
    /// <param name="_cobyRecId">
    /// The record ID of the co-product or byproduct record.
    /// </param>
    public void updateRealConsumptionCoBy(
        ProdTable       _prodTable,
        ProdRouteTrans  _prodRouteTrans,
        Percent         _allocation,
        RecId           _cobyRecId
        )
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWIPLedger</Name>
				<Source><![CDATA[
    void updateWIPLedger( LedgerVoucher     _ledgerVoucher,
                          ProdRouteTrans     prodRouteTrans
                         )
    {
        // <GEERU>
        boolean                  correction_RU = _ledgerVoucher.findLedgerVoucherObject().parmCorrection() ||
                                                 (prodRouteTrans.Amount < 0 && prodRouteTrans.StornoPhysical_RU);
        // </GEERU>

        setprefix(#PreFixField(ProdRouteTrans,OprNum));

        if (this.mustWIPBePosted(prodRouteTrans))
        {
            prodRouteTrans.PostingWIPValuation          = this.postingWIPValuation(prodRouteTrans);
            prodRouteTrans.PostingWIPIssue              = this.postingWIPIssue(prodRouteTrans);
            prodRouteTrans.wipValuationLedgerDimension  = this.wipValuationLedgerDimension(prodRouteTrans);
            prodRouteTrans.wipIssueLedgerDimension      = this.wipIssueLedgerDimension(prodRouteTrans);

            if (prodRouteTrans.Amount)
            {
                LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
                CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());

                // <GEERU>
                LedgerVoucherTransObject ledgerVoucherTransObject =
                // </GEERU>
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucherObject,
                        prodRouteTrans.PostingWIPValuation,
                        prodRouteTrans.wipValuationLedgerDimension,
                        CompanyInfoHelper::standardCurrency(),
                        prodRouteTrans.Amount,
                // <GEERU>
                        currencyExchHelper);
                ledgerVoucherTransObject.parmCorrect(correction_RU);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                // </GEERU>

                // <GEERU>
                ledgerVoucherTransObject =
                // </GEERU>
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucherObject,
                        prodRouteTrans.PostingWIPIssue,
                        prodRouteTrans.wipIssueLedgerDimension,
                        CompanyInfoHelper::standardCurrency(),
                       -prodRouteTrans.Amount,
                // <GEERU>
                        currencyExchHelper);
                ledgerVoucherTransObject.parmCorrect(correction_RU);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                _ledgerVoucher.bondLast2_RU();
                // </GEERU>
            }
        }
        else
        {
            prodRouteTrans.PostingWIPValuation          = LedgerPostingType::None;
            prodRouteTrans.PostingWIPIssue              = LedgerPostingType::None;
            prodRouteTrans.wipValuationLedgerDimension  = 0;
            prodRouteTrans.wipIssueLedgerDimension      = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipIssueLedgerDimension</Name>
				<Source><![CDATA[
    LedgerDimensionAccount wipIssueLedgerDimension(ProdRouteTrans prodRouteTrans)
    {
        switch (ProdTable::find(prodRouteTrans.TransRefId).ProdPostingType)
        {
            case ProdPostingType::ItemWrkCtr    :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(WrkCtrTable::find(prodRouteTrans.WrkCtrId).wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ItemCategory  :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(RouteCostCategory::find(prodRouteTrans.CategoryId).wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ProdGroup     :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
        }
        return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).wipIssueLedgerDimension, prodRouteTrans.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipValuationLedgerDimension</Name>
				<Source><![CDATA[
    LedgerDimensionAccount wipValuationLedgerDimension(ProdRouteTrans prodRouteTrans)
    {
        switch (ProdTable::find(prodRouteTrans.TransRefId).ProdPostingType)
        {
            case ProdPostingType::ItemWrkCtr    :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(WrkCtrTable::find(prodRouteTrans.WrkCtrId).wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ItemCategory  :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(RouteCostCategory::find(prodRouteTrans.CategoryId).wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
            case ProdPostingType::ProdGroup     :
                return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
        }
        return LedgerDimensionFacade::serviceCreateLedgerDimension(ProdGroup::find(ProdTable::find(prodRouteTrans.TransRefId).ProdGroupId).wipValuationLedgerDimension, prodRouteTrans.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditJobCtrlTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the field <c>JobCtrlTime</c> is currently editable for the given <c>RouteJobSetup</c>.
    /// </summary>
    /// <param name = "_routeJobSetup">A <c>RouteJobSetup</c> record.</param>
    /// <returns>
    /// true if the field is editable; otherwise, false.
    /// </returns>
    public NoYes allowEditJobCtrlTime(RouteJobSetup _routeJobSetup)
    {
        return _routeJobSetup.Activation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditSchedCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the field <c>SchedCapacity</c> is currently editable for the given <c>RouteJobSetup</c>.
    /// </summary>
    /// <param name = "_routeJobSetup">A <c>RouteJobSetup</c> record.</param>
    /// <returns>
    /// true if the field is editable; otherwise, false.
    /// </returns>
    public NoYes allowEditSchedCapacity(RouteJobSetup _routeJobSetup)
    {
        return _routeJobSetup.Activation && _routeJobSetup.SchedWorkTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditSchedWorkTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the field <c>SchedWorkTime</c> is currently editable for the given <c>RouteJobSetup</c>.
    /// </summary>
    /// <param name = "_routeJobSetup">A <c>RouteJobSetup</c> record.</param>
    /// <returns>
    /// true if the field is editable; otherwise, false.
    /// </returns>
    public NoYes allowEditSchedWorkTime(RouteJobSetup _routeJobSetup)
    {
        return _routeJobSetup.Activation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetRouteJobSetupFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets fields that depend on certain values from other fields.
    /// </summary>
    /// <param name = "_routeJobSetup">A <c>RouteJobSetup</c> record.</param>
    public void resetRouteJobSetupFields(RouteJobSetup _routeJobSetup)
    {
        if (!_routeJobSetup.Activation)
        {
            _routeJobSetup.JobCtrlTime   = NoYes::No;
            _routeJobSetup.SchedWorkTime = NoYes::No;
            _routeJobSetup.SchedCapacity = NoYes::No;
        }
        else if (!_routeJobSetup.SchedWorkTime)
        {
            _routeJobSetup.SchedCapacity = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static ProdJobType construct(RouteJobType jobType)
    {
        switch (jobType)
        {
            case RouteJobType::QueueBefore     : return new ProdJobType_QueueBefore();
            case RouteJobType::Setup           : return new ProdJobType_Setup();
            case RouteJobType::Process         : return new ProdJobType_Process();
            case RouteJobType::Overlap         : return new ProdJobType_Overlap();
            case RouteJobType::Transport       : return new ProdJobType_Transport();
            case RouteJobType::QueueAfter      : return new ProdJobType_QueueAfter();
            case RouteJobType::Burden            : return new ProdJobType_Burden();
        }
        return new ProdJobType();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>