<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqTransCache</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class ReqTransCache
{
    ReqProcessId            processId;

    Map                     mapLevelItem;       // BOMLevel, SetItemId

    ReqPlanId               reqPlanId;
    RefRecId                reqPlanVersionRefRecId;

    boolean                 itemsAvailInList;
    SetEnumerator           se_itemId;

    BOMLevel                currentLevel;

    Query                   pmfCoReqTransQuery;
    Map                     pmfFormulaTaskGroupMap;
    PmfReqTaskGroupId       pmfReqTaskGroupIdMax;
    boolean                 useReqTransFilter;

    private ReqCalcRecordCacheReqPo  reqCalcRecordCacheReqPo;
    private ReqProcessStatus         currentProcessStatus;

    private readonly boolean reqTransCacheProcessDataAreaPredicateFlightEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>add</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds an item to the local set variables.
    /// </summary>
    /// <param name="_reqTrans">
    ///    The <c>ReqTrans</c> record to add to the cache.
    /// </param>
    public void add(ReqTrans _reqTrans)
    {
        ReqProcessTransFilter reqProcessTransFilter;
        Set setItemId;

        // Update mapLevelItem and other caches
        if (mapLevelItem.exists(_reqTrans.Level))
        {
            if (!mapLevelItem.lookup(_reqTrans.Level).in(_reqTrans.ItemId))
            {
                setItemId = mapLevelItem.lookup(_reqTrans.Level);
                this.addItemToCache(setItemId, _reqTrans);
            }
        }
        else
        {
            setItemId = new Set(Types::String);
            this.addItemToCache(setItemId, _reqTrans);
        }

        if (useReqTransFilter)
        {
            select firstonly RecId from reqProcessTransFilter
            where   reqProcessTransFilter.ProcessDataAreaId == curExt2dataareaid(tablenum(ReqProcessList))
                &&  reqProcessTransFilter.ProcessId         == processId
                &&  reqProcessTransFilter.ReqTrans          == _reqTrans.RecId;

            if (!reqProcessTransFilter)
            {
                reqProcessTransFilter.ProcessDataAreaId = curExt2dataareaid(tablenum(ReqProcessList));
                reqProcessTransFilter.ProcessId = processId;
                reqProcessTransFilter.ReqTrans = _reqTrans.RecId;
                reqProcessTransFilter.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addItemToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the item to the cache.
    /// </summary>
    /// <param name="_itemSet">
    /// The set including the items.
    /// </param>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c> record to be used.
    /// </param>
    public abstract void addItemToCache(Set _itemSet, ReqTrans _reqTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllItems</Name>
				<Source><![CDATA[
    public abstract Set getAllItems()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqProcessTransFilterRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a set of filter records that indicate the requirement transactions to process.
    /// </summary>
    /// <remarks>
    ///    The method examines <c>ReqTrans</c> records stamped with the process ID of the current master
    ///    planning process and for those requirement transactions it creates filter records in the
    ///    <c>ReqProcessTransFilter</c> table.
    /// </remarks>
    public void createReqProcessTransFilterRecords()
    {
        ReqProcessTransFilter   reqProcessTransFilter;
        ReqProcessTransFilter   reqProcessTransFilterExist;
        ReqTrans                reqTrans;
        selectableDataArea      processDataAreaId = curExt2dataareaid(tablenum(ReqProcessTransFilter));

        if (useReqTransFilter) 
        {
            ttsbegin;

            insert_recordset reqProcessTransFilter (ReqTrans, ProcessId, ProcessDataAreaId)
                select RecId, processId, processDataAreaId from reqTrans
                    where   reqTrans.ReqProcessId   == processId
                        &&  reqTrans.PlanVersion == this.parmReqPlanVersionRefRecId()
                notexists join reqProcessTransFilterExist
                    where   reqProcessTransFilterExist.ReqTrans             == reqTrans.RecId
                    &&      reqProcessTransFilterExist.ProcessId            == processId
                    &&      reqProcessTransFilterExist.ProcessDataAreaId    == processDataAreaId;

            reqTrans.skipDataMethods(true);

            while select forUpdate reqTrans
                where reqTrans.ReqProcessId == processId
                   && reqTrans.PlanVersion == this.parmReqPlanVersionRefRecId()
            exists join reqProcessTransFilterExist
                where   reqProcessTransFilterExist.ReqTrans             == reqTrans.RecId
                &&      reqProcessTransFilterExist.ProcessId            == processId
                &&      reqProcessTransFilterExist.ProcessDataAreaId    == processDataAreaId
            {
                reqTrans.ReqProcessId = '';
                reqTrans.doUpdate();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endProcess</Name>
				<Source><![CDATA[
    public abstract void endProcess()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstPlanGroupIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first planning group issue in the same group as the issue specified in the <paramref name="_issue"/> parameter.
    /// </summary>
    /// <param name="_issue">
    /// An issue in the planning group.
    /// </param>
    /// <returns>
    /// A pointer to the found issue record.
    /// </returns>
    public ReqTrans findFirstPlanGroupIssue(ReqTrans _issue)
    {
        ReqTrans reqTrans;

        select forupdate firstonly reqTrans
            order by PmfPlanGroupPriority
                where reqTrans.PlanVersion      == _issue.PlanVersion
                    && reqTrans.RefType         == _issue.RefType
                    && reqTrans.PmfPlanGroupId  == _issue.PmfPlanGroupId
                    && reqTrans.RefId           == _issue.RefId;

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNextPlanGroupIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the next planning group issue (sorted according to priority) in the same group as the issue specified in the <paramref name="_issue"/> parameter.
    /// </summary>
    /// <param name="_issue">
    /// An issue in the planning group.
    /// </param>
    /// <returns>
    /// A pointer to the found issue record.
    /// </returns>
    public ReqTrans findNextPlanGroupIssue(ReqTrans _issue)
    {
        ReqTrans reqTrans;

        select forupdate firstonly reqTrans
            order by PmfPlanGroupPriority
                where reqTrans.PlanVersion           == _issue.PlanVersion
                    && reqTrans.RefType              == _issue.RefType
                    && reqTrans.PmfPlanGroupId       == _issue.PmfPlanGroupId
                    && reqTrans.RefId                == _issue.RefId
                    && reqTrans.PmfPlanGroupPriority >  _issue.PmfPlanGroupPriority;

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPrimaryPlanGroupIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the primary issue (sorted according to priority) in the same planning group as the issue specified in the <paramref name="_issue"/> parameter.
    /// </summary>
    /// <param name="_issue">
    /// An issue in the planning group.
    /// </param>
    /// <returns>
    /// A pointer to the found issue record.
    /// </returns>
    public ReqTrans findPrimaryPlanGroupIssue(ReqTrans _issue)
    {
        ReqTrans reqTrans;

        select forupdate firstonly reqTrans
            where reqTrans.PlanVersion               == _issue.PlanVersion
                && reqTrans.RefType                  == _issue.RefType
                && reqTrans.PmfPlanGroupId           == _issue.PmfPlanGroupId
                && reqTrans.RefId                    == _issue.RefId
                && reqTrans.PmfPlanGroupPrimaryIssue == NoYes::Yes;

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the current BOM level that is used by the <c>ReqTransCache</c> class to fetch items.
    /// </summary>
    /// <returns>
    ///    The current BOM level; otherwise, -1 or the <c>maxint</c> enumeration value.
    /// </returns>
    public BOMLevel getCurrentLevel()
    {
        return currentLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the items in a given item list.
    /// </summary>
    /// <param name="_level">
    ///    The BOM level for which to retrieve items.
    /// </param>
    /// <returns>
    ///    A <c>Set</c> with the items in an item list.
    /// </returns>
    abstract public Set getItems(BOMLevel _level)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRerunFromLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the BOM level from which coverage should be re-run.
    /// </summary>
    /// <returns>
    /// The BOM level from which coverage should be re-run
    /// </returns>
    public abstract BOMLevel getRerunFromLevel()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPlanGroupIssueQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the quantity field on the first priority issues of each planning group.
    /// </summary>
    /// <param name="_primaryPlanGroupIssues">
    /// A <c>Set</c> containing the <c>ReqTrans</c> records of the primary planning group issues.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds master scheduling settings.
    /// </param>
    public void initPlanGroupIssueQuantities(Set _primaryPlanGroupIssues, ReqPlanData _reqPlanData)
    {
        SetEnumerator   enumerator = _primaryPlanGroupIssues.getEnumerator();
        ReqTrans        primaryIssue;
        ReqTrans        firstPriorityIssue;
        ReqTrans        localPrimaryIssue;

        while (enumerator.moveNext())
        {
            primaryIssue = enumerator.current();

            // Get the first priority issue
            firstPriorityIssue = this.findFirstPlanGroupIssue(primaryIssue);

            if (primaryIssue.PmfPlanGroupPriority != firstPriorityIssue.PmfPlanGroupPriority)
            {
                // The primary issue from the Set must be selected for update
                // Use a strict query to try to find the same primaryIssue record
                select forupdate firstonly localPrimaryIssue
                    where localPrimaryIssue.PlanVersion              == primaryIssue.PlanVersion
                       && localPrimaryIssue.RefType                  == primaryIssue.RefType
                       && localPrimaryIssue.PmfPlanGroupId           == primaryIssue.PmfPlanGroupId
                       && localPrimaryIssue.RefId                    == primaryIssue.RefId
                       && localPrimaryIssue.PmfPlanGroupPrimaryIssue == NoYes::Yes
                       && localPrimaryIssue.BOMRefRecId              == primaryIssue.BOMRefRecId
                       && localPrimaryIssue.PmfPlanGroupPriority     == primaryIssue.PmfPlanGroupPriority;

                // Move the quantity from the primary issue to the first priority issue
                firstPriorityIssue.Qty += localPrimaryIssue.Qty;
                firstPriorityIssue.update(_reqPlanData);

                localPrimaryIssue.Qty = 0;
                localPrimaryIssue.update(_reqPlanData);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProcessItemsFromQuery</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    public void insertProcessItemsFromQuery(container _con)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemMarkedForProcessing</Name>
				<Source><![CDATA[
    public abstract boolean isItemMarkedForProcessing(ItemId _itemId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>issuesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a query than can be used to retrieve issues from the database.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to filter transaction by.
    /// </param>
    /// <param name="_covInventDimId">
    /// The inventory dimension ID to filter transaction by.
    /// </param>
    /// <returns>
    /// A new <c>Query</c> object.
    /// </returns>
    public Query issuesQuery(ItemId        _itemId,
                             InventDimId   _covInventDimId)
    {
        Query query = this.reqTransQuery(_itemId, _covInventDimId);
        QueryBuildDataSource reqTrans_ds;

        reqTrans_ds = query.dataSourceTable(tableNum(ReqTrans));
        reqTrans_ds.addRange(fieldNum(ReqTrans, Direction)).value(queryValue(InventDirection::Issue));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>issuesAndSafetyStockQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a query than can be used to retrieve issues and safety stock changes from the database.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to filter transaction by.
    /// </param>
    /// <param name="_covInventDimId">
    /// The inventory dimension ID to filter transaction by.
    /// </param>
    /// <returns>
    /// A new <c>Query</c> object.
    /// </returns>
    public Query issuesAndSafetyStockQuery(ItemId        _itemId,
                             InventDimId   _covInventDimId)
    {
        Query query = this.reqTransQuery(_itemId, _covInventDimId);
        QueryBuildDataSource reqTrans_ds;

        reqTrans_ds = query.dataSourceTable(tableNum(ReqTrans));
        reqTrans_ds.addRange(fieldNum(ReqTrans, Direction)).value(strFmt('((%1.%2 == %3) || (%4.%5 == %6))',
            reqTrans_ds.name(),
            fieldStr(ReqTrans, Direction),
            enum2int(InventDirection::Issue),
            reqTrans_ds.name(),
            fieldStr(ReqTrans, RefType),
            enum2int(ReqRefType::SafetyInvent)
            ));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemDimSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a set of used <c>InventDimIds</c> for a specific item.
    /// </summary>
    /// <param name="_itemId">
    ///    A string that holds the <c>itemID</c>.
    /// </param>
    /// <returns>
    ///    A set of used <c>InventDimIds</c> for a specific item.
    /// </returns>    
    public Set itemDimSet(ItemId _itemId)
    {
        return this.itemDimSetForCurrentLevel(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemDimSetForCurrentLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a set of used <c>InventDimIds</c> for a specific item.
    /// </summary>
    /// <param name="_itemId">
    ///    A string that holds the <c>itemID</c>.
    /// </param>
    /// <param name="_ignoreLevel">
    ///   A boolean that determines whether the item level should be ignored; optional.
    /// </param>
    /// <returns>
    ///    A set of used <c>InventDimIds</c> for a specific item.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public Set itemDimSetForCurrentLevel(ItemId _itemId, boolean _ignoreLevel = false)
    {
        Set         itemDimSet = new Set(Types::String);

        ReqTrans                    reqTrans;
        ReqProcessTransFilter       reqProcessTransFilter;

        if (useReqTransFilter)
        {
            select CovInventDimId from reqTrans
            group by CovInventDimId, Level
                where   reqTrans.ItemId      == _itemId
                &&      reqTrans.PlanVersion == this.parmReqPlanVersionRefRecId()
                &&      (reqTrans.Level      == currentLevel  || _ignoreLevel)
            exists join reqProcessTransFilter
                where   reqProcessTransFilter.ProcessDataAreaId == curExt2dataareaid(tablenum(ReqProcessTransFilter))
                &&      reqProcessTransFilter.ProcessId         == processId
                &&      reqProcessTransFilter.ReqTrans          == reqTrans.RecId;
        }
        else
        {
            select CovInventDimId from reqTrans
            group by CovInventDimId, Level
                where   reqTrans.ItemId == _itemId
                &&      reqTrans.PlanVersion == this.parmReqPlanVersionRefRecId()
                &&      (reqTrans.Level == currentLevel || _ignoreLevel);
        }

        // loop covDimId's
        while (reqTrans)
        {
            itemDimSet.add(reqTrans.CovInventDimId);
            next reqTrans;
        }

        return itemDimSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>levelCount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of BOM levels of the items that are processed.
    /// </summary>
    /// <returns>
    ///    The number of BOM levels.
    /// </returns>
    public abstract int levelCount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCovDimIdAsTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified coverage dimension and dependent coverage dimensions to the <c>ReqDependency</c>
    ///    object.
    /// </summary>
    /// <param name="_reqLevelAnalyzer">
    ///    An object that holds all tasks and dependencies.
    /// </param>
    /// <param name="_itemId">
    ///    A string that holds the <c>itemID</c> value.
    /// </param>
    /// <param name="_covDimId">
    ///    A string that holds the inventory dimension ID.
    /// </param>
    /// <param name="_reqPlanData">
    ///    A <c>reqPlanData</c> object that holds cached data.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The coverage dimensions have circular dependencies.
    /// </exception>
    public void addCovDimIdAsTask(
        ReqDependencyAnalyzer   _reqLevelAnalyzer,
        ItemId                  _itemId,
        InventDimId             _covDimId,
        ReqPlanData             _reqPlanData)
    {
        ReqCalc::addCovDimIdAsTask(_reqLevelAnalyzer, _itemId, _covDimId, _reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>listCovDimSorted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a sorted list of coverage dimensions.
    /// </summary>
    /// <param name="_itemId">
    ///    A string that holds the <c>itemID</c>.
    /// </param>
    /// <param name="_reqPlanData">
    ///    An object of type <c>ReqPlanData</c> that holds cached data.
    /// </param>
    /// <param name="_reversed">
    ///    A Boolean that determines whether the list should be in a reversed order; optional.
    /// </param>
    /// <returns>
    ///    A list of coverage dimensions.
    /// </returns>
    public List listCovDimSorted(
        ItemId          _itemId,
        ReqPlanData     _reqPlanData,
        boolean         _reversed = false)
    {
        Set                         itemDimSet;
        SetEnumerator               se;

        ReqDependencyAnalyzer       reqLevelAnalyzer;

        InventDimId                 covDimId;

        reqLevelAnalyzer  = ReqDependencyAnalyzer::construct(Types::String);

        itemDimSet = this.itemDimSet(_itemId);
        se         = itemDimSet.getEnumerator();

        // loop covDimId's
        while (se.moveNext())
        {
            covDimId = se.current();
            // add current covDimId to analyzer object and eventual dependent covDimIds
            this.addCovDimIdAsTask(reqLevelAnalyzer,_itemId,covDimId,_reqPlanData);
        }

        return reqLevelAnalyzer.getScheduleByLevel(_reversed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageItemError</Name>
				<Source><![CDATA[
    public abstract void manageItemError(ItemId _itemId, boolean _errors)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a map of all planned orders.
    /// </summary>
    /// <returns>
    ///    A map of all planned orders.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public Map mapPlannedOrder()
    {
        #macrolib.Req

        ReqTrans                    reqTrans;
        Map                         plannedOrderMap;
        ReqProcessTransFilter       reqProcessTransFilter;
        ReqProcessItem              reqProcessItem;

        plannedOrderMap = new Map(typeName2Type(extendedtypestr(recId)), Types::Record);

        if (useReqTransFilter)
        {
            select reqTrans
                where #ReqRefTypeIsPlannedOrder(reqTrans.RefType)
                &&      reqTrans.PlanVersion == reqPlanVersionRefRecId
            exists join reqProcessTransFilter
                where reqProcessTransFilter.ReqTrans == reqTrans.RecId
                    && reqProcessTransFilter.ProcessId == processId
                    && (!reqTransCacheProcessDataAreaPredicateFlightEnabled || reqProcessTransFilter.ProcessDataAreaId == curext2DataAreaId(tablenum(ReqProcessTransFilter)));
        }
        else
        {
            select reqTrans
                where   #ReqRefTypeIsPlannedOrder(reqTrans.RefType)
                &&      reqTrans.PlanVersion == reqPlanVersionRefRecId
            exists join reqProcessItem
                where   reqProcessItem.ItemId    == reqTrans.ItemId
                &&      reqProcessItem.ProcessId == processId;
        }

        while (reqTrans)
        {
            plannedOrderMap.insert(reqTrans.RecId, reqTrans);
            next reqTrans;
        }

        return plannedOrderMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markProcessWithError</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the current process with an error status.
    /// </summary>
    public void markProcessWithError()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveNextLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Advances the current BOM level that is used by the <c>ReqTransCache</c> class to the next level, by
    ///    using the order set by the <c>ReqLevelOrder</c> enumeration value that is specified in the
    ///    <c>resetLevel</c> method.
    /// </summary>
    /// <returns>
    ///    true if the next level exists; otherwise, false.
    /// </returns>
    public abstract boolean moveNextLevel()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        currentLevel = 0;

        mapLevelItem        = new Map(Types::Integer,Types::Class);       // BOMLevel, SetItemId
        reqCalcRecordCacheReqPo = ReqCalcRecordCacheReqPo::newStandard();

        if (#PmfEnabled)
        {
            pmfCoReqTransQuery = new Query();
            pmfCoReqTransQuery.addDataSource(tablenum(PmfCoReqTransItem));
            pmfCoReqTransQuery.dataSourceTable(tablenum(PmfCoReqTransItem))
                .addRange(fieldnum(PmfCoReqTransItem, ReqProcessId))
                .value(processId);
        }

        reqTransCacheProcessDataAreaPredicateFlightEnabled = ReqTransCacheProcessDataAreaPredicateFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>noteDownPlannedProdOrderId</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    public void noteDownPlannedProdOrderId(InventTransRefId _refId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessId</Name>
				<Source><![CDATA[
    public ReqProcessId parmProcessId(ReqProcessId _processId)
    {
        processId = _processId;
        return processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanId</Name>
				<Source><![CDATA[
    protected ReqPlanId parmReqPlanId(ReqPlanId _reqPlanId)
    {
        reqPlanId = _reqPlanId;
        return reqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanVersionRefRecId</Name>
				<Source><![CDATA[
    public RefRecId parmReqPlanVersionRefRecId(RefRecId _reqPlanVersionRefRecId = reqPlanVersionRefRecId)
    {
        reqPlanVersionRefRecId = _reqPlanVersionRefRecId;
        return reqPlanVersionRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseReqTransFilter</Name>
				<Source><![CDATA[
    public boolean parmUseReqTransFilter(boolean _useReqTransFilter = useReqTransFilter)
    {
        useReqTransFilter = _useReqTransFilter;
        return useReqTransFilter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCreateExpiryTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates expiry transactions for receipts with open quantity that has an expiration date.
    /// </summary>
    /// <param name="_deleteExistingExpiryRecords">
    /// Indicates if any existing expiry records should be deleted.
    /// </param>
    public void pdsCreateExpiryTrans(boolean _deleteExistingExpiryRecords)
    {
        #LOCALMACRO.MatchStatement
            select PlanVersion, ItemId, CovInventDimId, PdsExpiryDate, Level, RefType, sum(Qty), sum(CovQty)
                    from reqTransReceiptCovSafety
                    group by reqTransReceiptCovSafety.PlanVersion,
                         reqTransReceiptCovSafety.ItemId,
                         reqTransReceiptCovSafety.CovInventDimId,
                         reqTransReceiptCovSafety.PdsExpiryDate,
                         reqTransReceiptCovSafety.Level,
                         reqTransReceiptCovSafety.RefType
                    where reqTransReceiptCovSafety.RefType      == ReqRefType::SafetyInvent &&
                          reqTransReceiptCov.PdsExpiryDate      == reqTransReceiptCovSafety.PdsExpiryDate &&
                          reqTransReceiptCov.ItemId             == reqTransReceiptCovSafety.ItemId &&
                          reqTransReceiptCov.PlanVersion        == reqTransReceiptCovSafety.PlanVersion &&
                          reqTransReceiptCov.Level              == reqTransReceiptCovSafety.Level &&
                          reqTransReceiptCov.CovInventDimId     == reqTransReceiptCovSafety.CovInventDimId;

            expiryQty = -1 * (reqTransReceiptCov.Qty + reqTransReceiptCov.CovQty + reqTransReceiptCovSafety.CovQty);
            if ((expiryQty && !mustCreateExpiryTransWithNoGroupByRefTypeEnabled)
                || (expiryQty < 0 && mustCreateExpiryTransWithNoGroupByRefTypeEnabled))
            {
                reqTransExpiration.initExpiryFromReqTransReceiptCov(reqTransReceiptCov, expiryQty);
                ReqTransRecIdPreallocationScope::assignRecId(reqTransExpiration);
                expiryRecList.add(reqTransExpiration);
            }
        #ENDMACRO

        #LOCALMACRO.InsertStatement
        while select PlanVersion, ItemId, CovInventDimId, PdsExpiryDate, Level, RefType, sum(Qty), sum(CovQty)
            from reqTransReceiptCov
            group by reqTransReceiptCov.PlanVersion,
                     reqTransReceiptCov.ItemId,
                     reqTransReceiptCov.CovInventDimId,
                     reqTransReceiptCov.PdsExpiryDate,
                     reqTransReceiptCov.Level,
					 reqTransReceiptCov.RefType
            where reqTransReceiptCov.RefType        != ReqRefType::SafetyInvent &&
                  reqTransReceiptCov.PlanVersion    == this.parmReqPlanVersionRefRecId() &&
                  reqTransReceiptCov.PdsExpiryDate
        #ENDMACRO

        #LOCALMACRO.InsertStatementNoGroupByRefType
        while select PlanVersion, ItemId, CovInventDimId, PdsExpiryDate, Level, sum(Qty), sum(CovQty)
            from reqTransReceiptCov
            group by reqTransReceiptCov.PlanVersion,
                     reqTransReceiptCov.ItemId,
                     reqTransReceiptCov.CovInventDimId,
                     reqTransReceiptCov.PdsExpiryDate,
                     reqTransReceiptCov.Level
            where reqTransReceiptCov.RefType        != ReqRefType::SafetyInvent &&
                  reqTransReceiptCov.PlanVersion    == this.parmReqPlanVersionRefRecId() &&
                  reqTransReceiptCov.PdsExpiryDate
        #ENDMACRO

        ReqTrans                reqTransExpiration;
        ReqTrans                reqTransFilter;
        ReqProcessTransFilter   reqProcessTransFilter;
        ReqRefType              expiryRefType       = ReqRefType::PdsExpiredBatch;
        InventDirection         expiryDirection     = InventDirection::Issue;
        ReqOpenStatus           expiryOpenStatus    = ReqOpenStatus::Zero;
        boolean                 mustCreateExpiryTransWithNoGroupByRefTypeEnabled = ReqCreateExpiryTransNoGroupByRefTypeToggle::instance().isEnabled();

        ttsbegin;

        this.populateReqTransReceiptCov();

        RecordInsertList expiryRecList = new RecordInsertList(tableNum(ReqTrans), true, true, true);

        if (_deleteExistingExpiryRecords)
        {
            // Delete any existing expiry records
            if (useReqTransFilter)
            {
                delete_from reqTransExpiration
                    where reqTransExpiration.PlanVersion == this.parmReqPlanVersionRefRecId()
                        && reqTransExpiration.RefType == ReqRefType::PdsExpiredBatch
                    exists join reqTransFilter
                        where reqTransFilter.PlanVersion == reqTransExpiration.PlanVersion
                           && reqTransFilter.ItemId == reqTransExpiration.ItemId
                           && reqTransFilter.CovInventDimId == reqTransExpiration.CovInventDimId
                    exists join reqProcessTransFilter
                        where reqProcessTransFilter.ProcessId == processId
                           && reqProcessTransFilter.ProcessDataAreaId == curext2DataAreaId(tablenum(ReqProcessTransFilter))
                           && reqProcessTransFilter.ReqTrans == reqTransFilter.RecId;
            }
            else
            {
                ReqProcessItem reqProcessItem;

                delete_from reqTransExpiration
                    where reqTransExpiration.PlanVersion == this.parmReqPlanVersionRefRecId()
                        && reqTransExpiration.RefType == ReqRefType::PdsExpiredBatch
                    exists join reqProcessItem
                        where reqProcessItem.ItemId == reqTransExpiration.ItemId
                            && reqProcessItem.ProcessId == processId;
            }
        }

        ReqTransReceiptCov reqTransReceiptCov, reqTransReceiptCovSafety;
        InventQty expiryQty;

        // Create one new expiration record per expiry date for each item/dimension
        if (useReqTransFilter)
        {
            if (mustCreateExpiryTransWithNoGroupByRefTypeEnabled)
            {
                #InsertStatementNoGroupByRefType
                exists join reqTransFilter
                    where reqTransFilter.PlanVersion    == reqTransReceiptCov.PlanVersion
                       && reqTransFilter.ItemId         == reqTransReceiptCov.ItemId
                       && reqTransFilter.CovInventDimId == reqTransReceiptCov.CovInventDimId
                exists join reqProcessTransFilter
                where   reqProcessTransFilter.ProcessId         == processId
                &&      reqProcessTransFilter.ProcessDataAreaId == curext2DataAreaId(tablenum(ReqProcessTransFilter))
                &&      reqProcessTransFilter.ReqTrans          == reqTransFilter.RecId
                {
                    #MatchStatement
                }
            }
            else
            {
                #InsertStatement
                exists join reqTransFilter
                    where reqTransFilter.PlanVersion    == reqTransReceiptCov.PlanVersion
                       && reqTransFilter.ItemId         == reqTransReceiptCov.ItemId
                       && reqTransFilter.CovInventDimId == reqTransReceiptCov.CovInventDimId
				exists join reqProcessTransFilter
				where   reqProcessTransFilter.ProcessId         == processId
				&&      reqProcessTransFilter.ProcessDataAreaId == curext2DataAreaId(tablenum(ReqProcessTransFilter))
				&&      reqProcessTransFilter.ReqTrans          == reqTransFilter.RecId
                {
                    #MatchStatement
                }
            }
        }
        else
        {
            if (mustCreateExpiryTransWithNoGroupByRefTypeEnabled)
            {
                #InsertStatementNoGroupByRefType
                {
					#MatchStatement
				}
            }
            else
            {
                #InsertStatement
				{
					#MatchStatement
				}
			}
        }

        expiryRecList.insertDatabase();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfAddPmfCoReqTransItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add items to the pmf list.
    /// </summary>
    /// <param name="_inventTable">
    /// The co-product item to add.
    /// </param>
    /// <param name="_level">
    /// The current BOM level.
    /// </param>
    /// <returns>
    /// The added co-product transaction.
    /// </returns>
    public PmfCoReqTransItem pmfAddPmfCoReqTransItem(InventTable _inventTable, BOMLevel _level)
    {
        PmfCoReqTransItem   pmfCoReqTransItem;

        pmfCoReqTransItem.clear();
        pmfCoReqTransItem.ReqProcessId  = processId;
        pmfCoReqTransItem.ItemId        = _inventTable.ItemId;
        pmfCoReqTransItem.Level         = _level;
        pmfCoReqTransItem.Price         = _inventTable.inventTableModuleInvent().price();
        pmfCoReqTransItem.TaskGroupId   = this.pmfGetCoItemTaskGroupId(_inventTable);
        pmfCoReqTransItem.insert();

        return pmfCoReqTransItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoCreateItemIdList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the co-product processing list for all co-products associated
    /// with the given <paramref name="_taskGroupId">task group</paramref>.
    /// </summary>
    /// <param name="_level">
    /// The BOM level of the co-products to find.
    /// </param>
    /// <param name="_taskGroupId">
    /// The task group Id of the co-products to find.
    /// </param>
    /// <returns>
    /// An ordered <c>List</c> of co-product items to be processed.
    /// </returns>
    public List pmfCoCreateItemIdList(BOMLevel _level, PmfReqTaskGroupId _taskGroupId)
    {
        PmfCoReqTransItem       coReqTransItem;
        InventTable             inventTable;
        List                    coItemList = new List(Types::String);

        while select ItemId from coReqTransItem
            // Formula items must be processed before the co-product items
            order by inventTable.PmfProductType desc, coReqTransItem.TransDate, coReqTransItem.TransTime,
                coReqTransItem.Price, inventTable.ItemId
            where coReqTransItem.ReqProcessId == processId
                && coReqTransItem.Level       == _level
                && coReqTransItem.TaskGroupId == _taskGroupId
            join PmfProductType, ItemId from inventTable
                where inventTable.ItemId == coReqTransItem.ItemId
        {
            coItemList.addEnd(coReqTransItem.ItemId);
        }

        return coItemList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoUpdateTransDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the co-product earliest requirement date and time for the co-prodcuts
    /// associated with the given <paramref name="_taskGroupId">task group</paramref>.
    /// </summary>
    /// <param name="_level">
    /// The BOM level of the co-products to update.
    /// </param>
    /// <param name="_taskGroupId">
    /// The task group Id of the co-products to update.
    /// </param>
    /// <remarks>
    /// It really only makes sense to call this method during coverage calculation as
    /// that is when requirements might change after the initial load. It is safe, though, to
    /// call this method any time.
    /// <p/>
    /// After this method is complete then the items can be reselected with the most
    /// current date and time ordering.
    /// </remarks>
    public void pmfCoUpdateTransDateTime(BOMLevel _level, PmfReqTaskGroupId _taskGroupId)
    {
        PmfCoReqTransItem   coReqTransItem;
        ReqTrans            reqTransCoIssue;

        ttsbegin;

        while select forupdate coReqTransItem
            where coReqTransItem.ReqProcessId == processId
                && coReqTransItem.Level       == _level
                && coReqTransItem.TaskGroupId == _taskGroupId
        {
            reqTransCoIssue = this.pmfFindFirstCoIssue(coReqTransItem.ItemId);
            if (reqTransCoIssue.RecId)
            {
                if (coReqTransItem.TransDate != reqTransCoIssue.ReqDate || coReqTransItem.TransTime != reqTransCoIssue.ReqTime)
                {
                    coReqTransItem.TransDate = reqTransCoIssue.ReqDate;
                    coReqTransItem.TransTime = reqTransCoIssue.ReqTime;
                    coReqTransItem.update();
                }
            }
            else
            {
                // When there are no issues it must be placed at the end
                coReqTransItem.TransDate = maxDate();
                coReqTransItem.TransTime = 0;
                coReqTransItem.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfFindFirstCoIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds first reqTrans related to the end item of the co-product.
    /// </summary>
    /// <param name="_itemId">
    /// End item id.
    /// </param>
    /// <returns>Returns issue reqTrans related to the end item of the co-product.</returns>
    protected ReqTrans pmfFindFirstCoIssue(ItemId _itemId)
    {
        ReqTrans    issue;

        select firstonly forupdate issue
            order by ReqDate, ReqTime
            where issue.PlanVersion   == this.parmReqPlanVersionRefRecId()
                && issue.ItemId       == _itemId
                && issue.Direction    == InventDirection::Issue;

        return issue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfGetCoItemBOMs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>Set</c> containing the active Co-Product BOM ids that is associated with the item.
    /// </summary>
    /// <param name="_inventTable">
    /// The item to get the BOMs for.
    /// </param>
    /// <returns>
    /// A <c>Set</c> containing the active Co-Product BOM ids that is associated with the item.
    /// </returns>
    protected Set pmfGetCoItemBOMs(InventTable _inventTable)
    {
        Set             bomIds = new Set(Types::String);
        BOMVersion      bomVersion;
        PmfFormulaCoBy  formulaCoBy;

        if (_inventTable.PmfProductType == PmfProductType::Co_Product)
        {
            // Find all the formulas where the item is a co-product output
            while select BOMId
                from bomVersion
                where  bomVersion.Active     == NoYes::Yes
                    && bomVersion.Approved   == NoYes::Yes
                exists join formulaCoBy
                where formulaCoBy.bomVersionRefRecId == bomVersion.RecId
                    && formulaCoBy.ItemId            == _inventTable.ItemId
            {
                bomIds.add(bomVersion.BOMId);
            }
        }
        else
        {
            // Find all the formulas where the item is a primary output and there are also co-product outputs
            while select BOMId
                from bomVersion
                where  bomVersion.Active     == NoYes::Yes
                    && bomVersion.Approved   == NoYes::Yes
                    && bomVersion.ItemId     == _inventTable.ItemId
                exists join formulaCoBy
                where formulaCoBy.bomVersionRefRecId == bomVersion.RecId
            {
                bomIds.add(bomVersion.BOMId);
            }
        }

        return bomIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfGetCoItemTaskGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the task group id of a Co-Product item.
    /// </summary>
    /// <param name="_inventTable">
    /// The co-product item to get the task group for.
    /// </param>
    /// <returns>
    /// The task group id for the item.
    /// </returns>
    protected pmfReqTaskGroupId pmfGetCoItemTaskGroupId(InventTable _inventTable)
    {
        pmfReqTaskGroupId   pmfReqTaskGroupId;
        Set                 bomIdSet;
        SetEnumerator       setEnumerator;

        if (!pmfFormulaTaskGroupMap)
        {
            // Key is BOMId and values are task group ids
            pmfFormulaTaskGroupMap = new Map(Types::String, Types::Integer);
        }

        // Get all BOM ids that could be used to produce this item or that the item is producing
        bomIdSet = this.pmfGetCoItemBOMs(_inventTable);

        // Loop though and search if any of these BOM ids has already gotten a task group assigned
        setEnumerator = bomIdSet.getEnumerator();
        while (setEnumerator.moveNext())
        {
            if (pmfFormulaTaskGroupMap.exists(setEnumerator.current()))
            {
                pmfReqTaskGroupId = pmfFormulaTaskGroupMap.lookup(setEnumerator.current());
                break;
            }
        }

        // If no task group was found then take the next available task group id
        if (!pmfReqTaskGroupId)
        {
            pmfReqTaskGroupIdMax++;
            pmfReqTaskGroupId = pmfReqTaskGroupIdMax;
        }

        // Save the relationship between all the BOMids and the task group number
        setEnumerator.reset();
        while (setEnumerator.moveNext())
        {
            pmfFormulaTaskGroupMap.insert(setEnumerator.current(), pmfReqTaskGroupId);
        }

        return pmfReqTaskGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a query than can be used to retrieve receipts from the database.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to filter transaction by.
    /// </param>
    /// <param name="_covInventDimId">
    /// The inventory dimension ID to filter transaction by.
    /// </param>
    /// <returns>
    /// A new <c>Query</c> object.
    /// </returns>
    public Query receiptsQuery(ItemId        _itemId,
                               InventDimId   _covInventDimId)
    {
        Query query = this.reqTransQuery(_itemId, _covInventDimId);
        QueryBuildDataSource reqTrans_ds;

        reqTrans_ds = query.dataSourceTable(tableNum(ReqTrans));
        reqTrans_ds.addRange(fieldNum(ReqTrans, Direction)).value(queryValue(InventDirection::Receipt));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqProcessList</Name>
				<Source><![CDATA[
    public abstract ReqProcessList reqProcessList()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a query than can be used to retrieve receipts from the database.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to filter transaction by.
    /// </param>
    /// <param name="_covInventDimId">
    /// The inventory dimension ID to filter transaction by.
    /// </param>
    /// <returns>
    /// A new <c>Query</c> object.
    /// </returns>
    public Query reqTransQuery(ItemId        _itemId,
                               InventDimId   _covInventDimId)
    {
        Query query = new Query();
        QueryBuildDataSource reqTrans_ds;
        QueryBuildDataSource reqProcessTransFilter_ds;

        reqTrans_ds = query.addDataSource(tableNum(ReqTrans));
        reqTrans_ds.addRange(fieldNum(ReqTrans, ItemId)).value(queryValue(_itemId));
        reqTrans_ds.addRange(fieldNum(ReqTrans, CovInventDimId)).value(queryValue(_covInventDimId));
        reqTrans_ds.addRange(fieldNum(ReqTrans, PlanVersion)).value(queryValue(this.parmReqPlanVersionRefRecId()));

        if (useReqTransFilter)
        {
            reqProcessTransFilter_ds = reqTrans_ds.addDataSource(tableNum(ReqProcessTransFilter));
            reqProcessTransFilter_ds.joinMode(JoinMode::ExistsJoin);
            reqProcessTransFilter_ds.addLink(fieldNum(ReqTrans, RecId), fieldNum(ReqProcessTransFilter, ReqTrans));
            reqProcessTransFilter_ds.addRange(fieldNum(ReqProcessTransFilter, ProcessID)).value(queryValue(processId));
            reqProcessTransFilter_ds.addRange(fieldNum(ReqProcessTransFilter, ProcessDataAreaID)).value(queryValue(curExt2dataareaid(tablenum(ReqProcessTransFilter))));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the current BOM level that is used by the <c>ReqTransCache</c> class to the initial value.
    /// </summary>
    public void resetLevel()
    {
        currentLevel = -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrentItem</Name>
				<Source><![CDATA[
    public abstract void setCurrentItem(ItemId _itemId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrentLevel</Name>
				<Source><![CDATA[
    public void setCurrentLevel(BOMLevel _level)
    {
        currentLevel    = _level;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessStatus</Name>
				<Source><![CDATA[
    public ReqProcessStatus parmProcessStatus(ReqProcessStatus _processStatus = currentProcessStatus)
    {
        currentProcessStatus = _processStatus;
        return currentProcessStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRerunFromLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the level from which coverage planning should be re-run.
    /// </summary>
    /// <param name="_fromLevel">
    /// The level from which coverage planning should be re-run.
    /// </param>
    public abstract void setRerunFromLevel(BOMLevel _fromLevel)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setThreadParameters</Name>
				<Source><![CDATA[
    public abstract void setThreadParameters(ReqProcessThreadId      _threadId,
                                    boolean                 _thisIsChildThread,
                                    ReqProcessNumThreads    _maxThreads)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>startExternThreads</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    public void startExternThreads(Batch _batch)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExternThreads</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    internal void createExternThreads(Batch _batch, ReqProcessNumThreads _numberOfThreads)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update(ReqTrans _reqTrans)
    {
        this.add(_reqTrans);
        this.reqPoCacheDelete(_reqTrans.RefId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateListCovDimSorted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the list of sorted coverage dimensions.
    /// </summary>
    /// <param name="_itemId">
    ///    A string that holds the <c>itemID</c>.
    /// </param>
    /// <param name="_listCovDimSorted">
    ///    A list that holds the coverage dimensions.
    /// </param>
    /// <param name="_elementsInItemDimSet">
    ///    An integer that holds the previous number of elements.
    /// </param>
    /// <remarks>
    ///    During coverage calculation, new coverage dimensions might have been created. These coverage
    ///    dimensions are added to the list of sorted coverage dimensions.
    /// </remarks>
    void updateListCovDimSorted(
        ItemId      _itemId,
        List        _listCovDimSorted,
        Counter     _elementsInItemDimSet)
    {
        Set             itemDimSet;

        Set             itemDimSetFromList  = new Set(Types::String);
        Set             setMissingDimInList;
        SetEnumerator   se;

        //get set containing used covDimIds - must be reread
        itemDimSet  = this.itemDimSet(_itemId);

        if (itemDimSet.elements() == _elementsInItemDimSet)
        {
            return ;
        }

        // create set from the listCovDimSorted
        itemDimSetFromList = Set::create(_listCovDimSorted.pack());

        //investigate if missing dimensions exists
        setMissingDimInList = Set::difference(itemDimSet,itemDimSetFromList);

        if (setMissingDimInList.elements())
        {
            se = setMissingDimInList.getEnumerator();

            while (se.moveNext())
            {
                // add to end of list
                _listCovDimSorted.addEnd(se.current());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqProcessItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the list of items in the database for a given level.
    /// </summary>
    /// <param name="_level">
    ///    The <c>BOMLevel</c> value to update.
    /// </param>
    abstract public void updateReqProcessItems(BOMLevel _level)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqProcessItemsAllLevels</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the list of items in the database for all level.
    /// </summary>
    abstract public void updateReqProcessItemsAllLevels()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a master planning process.
    /// </summary>
    /// <param name="_processId">
    /// The ID of the process to cancel.
    /// </param>
    static public void cancelProcess(ReqProcessId _processId)
    {
        ReqProcessList  reqProcessList;

        update_recordset reqProcessList setting Cancelled = true where
            reqProcessList.ProcessId == _processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelFailedProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a master planning process and marks it as failed due to an infrastructure issue.
    /// </summary>
    /// <param name="_processId">
    /// The ID of the process to cancel.
    /// </param>
    static public void cancelFailedProcess(ReqProcessId _processId)
    {
        ReqProcessList reqProcessList;
        
        var instrumentationLogger = ReqInstrumentationLogger::createLogger(classStr(ReqTransCache));
        
        using (var activityContext = instrumentationLogger.transCache().cancelFailedProcess())
        {
            update_recordset reqProcessList setting Cancelled = true, InfrastructureFailure = true
                where reqProcessList.ProcessId == _processId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteProcessData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all the temporary data for a process.
    /// </summary>
    /// <param name="_processId">
    /// The master planning process ID.
    /// </param>
    /// <param name="_deleteTaskTrace">
    /// A boolean indicating whether or not to delete the task trace information.
    /// </param>
    public static void deleteProcessData(ReqProcessId _processId,
                                         boolean      _deleteTaskTrace)
    {
        var instrumentationLogger = ReqInstrumentationLogger::createLogger(classStr(ReqTransCache));
        
        using (var activityContext = instrumentationLogger.transCache().deleteProcessData())
        {
            try
            {
                ReqProcessItem::cleanUpProcess(_processId);

                ReqProcessThreadList::cleanUpProcess(_processId);

                ReqProcessList::cleanUpProcess(_processId);

                ReqCalcCapacityConflictOrders::cleanUpProcess(_processId);

                ReqProcessTransFilter::cleanUpProcess(_processId);

                PmfCoReqTransItem::cleanUpProcess(_processId);

                if (_deleteTaskTrace)
                {
                    ReqCalcTaskTrace::deleteProcessId(_processId);
                }

                ReqCalcTask::cleanUpProcess(_processId);

                ReqCalcTasksBundle::cleanUpProcess(_processId);

                ReqTransCache::cleanUpFirmingRelatedData(_processId);

                ReqProcessItemDetails::cleanUpProcess(_processId);
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpFirmingRelatedData</Name>
				<Source><![CDATA[
    private static void cleanUpFirmingRelatedData(ReqProcessId _processId)
    {
        var firmingRunId = ReqProcessAutoFirmingRun::findFirmingRunIdForProccessId(_processId);
        ReqPlannedOrderGroupFirmingParameters::cleanUpFirmingRun(firmingRunId);
        ReqTransPoMarkFirmPurchaseLineNumberSequence::cleanUpFirmingRun(firmingRunId);
        ReqUnfirmedOrders::cleanUpProcess(_processId);
        ReqProcessAutoFirmingRun::cleanUpProcess(_processId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemDimId2cachekey</Name>
				<Source><![CDATA[
    public static str itemDimId2cachekey(
        ItemId      _itemId,
        InventDimId _covInventDimId
        )
    {
        return _covInventDimId+'#'+_itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqProcessListDSExecuteQueryPre</Name>
				<Source><![CDATA[
    public static void reqProcessListDSExecuteQueryPre(boolean           _allCompanies,
                                                              ReqProcessTmpList _reqProcessTmpList)
    {
        ReqProcessList       reqProcessList;
        DataArea             dataArea;

        delete_from _reqProcessTmpList;

        if (!_allCompanies)
        {
            while select reqProcessList
            {
                _reqProcessTmpList.initFromReqProcessList(reqProcessList);
                _reqProcessTmpList.insert();
            }
        }
        else
        {
            if (_allCompanies)
            {
                while select IsVirtual, Id from dataArea
                    where dataArea.IsVirtual == NoYes::No
                {
                    changecompany(dataArea.Id)
                    {
                        reqProcessList = null;

                        while select reqProcessList
                        {
                            _reqProcessTmpList.initFromReqProcessList(reqProcessList);
                            _reqProcessTmpList.insert();
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateReqTransReceiptCov</Name>
				<Source><![CDATA[
    private void populateReqTransReceiptCov()
    {
        // insert_recordset sourced by view that handles NULL from left join
        ReqTransSafetyReceiptCovView    reqTransSafetyReceiptCovView;
        ReqTransReceiptCov              reqTransReceiptCov;
        ReqProcessItem                  reqProcessItem;

        delete_from reqTransReceiptCov
            where reqTransReceiptCov.PlanVersion  == this.parmReqPlanVersionRefRecId();

        insert_recordset reqTransReceiptCov
                  (PlanVersion, ItemId, CovInventDimId, PdsExpiryDate, ReqProcessId, Level, RefType, Qty, CovQty)
            select PlanVersion, ItemId, CovInventDimId, PdsExpiryDate, ReqProcessId, Level, RefType, Qty, SumCovQty
                from reqTransSafetyReceiptCovView
                where reqTransSafetyReceiptCovView.PlanVersion  == this.parmReqPlanVersionRefRecId()
                exists join reqProcessItem
                    where reqProcessItem.ItemId    == reqTransSafetyReceiptCovView.ItemId
                        && reqProcessItem.ProcessId == processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProcessMultithreaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the planning process can span multiple threads.
    /// </summary>
    /// <returns>true, if the planning process can span multiple threads; otherwise, false.</returns>
    public abstract boolean isProcessMultithreaded()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPoCacheLookup</Name>
				<Source><![CDATA[
    public ReqPo reqPoCacheLookup(InventTransRefId _refId)
    {
        return reqCalcRecordCacheReqPo.lookup(this.parmReqPlanVersionRefRecId(), _refId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPoCacheInsert</Name>
				<Source><![CDATA[
    public boolean reqPoCacheInsert(ReqPO _reqPo)
    {
        return reqCalcRecordCacheReqPo.insert(this.parmReqPlanVersionRefRecId(), _reqPo.RefId, _reqPo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPoCacheDelete</Name>
				<Source><![CDATA[
    public boolean reqPoCacheDelete(InventTransRefId _refId)
    {
        return reqCalcRecordCacheReqPo.remove(this.parmReqPlanVersionRefRecId(), _refId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>