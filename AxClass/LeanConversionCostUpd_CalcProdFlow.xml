<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanConversionCostUpd_CalcProdFlow</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LeanConversionCostUpd_CalcProdFlow</c> class reverses the indirect and direct manufacturing
///    cost during a backflush costing.
/// </summary>

class LeanConversionCostUpd_CalcProdFlow extends LeanConversionCostUpd
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addDirectManufacturingToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the direct manufacturing transactions to the ledger voucher.
    /// </summary>
    protected void addDirectManufacturingToLedger()
    {
        ProdRouteTrans      prodRouteTrans;
        CostAmount          routeCostAmount;

        SysDaSearchObject searchObject = new SysDaSearchObject(this.buildAddDirectManufacturingOrOutsourcingToLedgerQuery(prodRouteTrans, true));
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            routeCostAmount = CurrencyExchangeHelper::amount(prodRouteTrans.Amount);

            if (routeCostAmount)
            {
                // Reverse cost posted on WIP with original amount, account and dimension.
                this.addLedger(prodRouteTrans.PostingWIPValuation,
                               prodRouteTrans.wipValuationLedgerDimension,
                               -routeCostAmount,
                               true);

                this.addLedger(prodRouteTrans.PostingWIPIssue,
                               prodRouteTrans.wipIssueLedgerDimension,
                               routeCostAmount,
                               true);

                // <GEERU>
                if (countryRegion_RU)
                {
                    ledgerVoucher.bondLast2_RU();
                }
                // </GEERU>

                // Now post them to the absorption account
                this.addLedger(prodRouteTrans.PostingCalcIssueOffset,
                               LedgerDimensionFacade::serviceCreateLedgerDimension(prodRouteTrans.IssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension),
                               routeCostAmount,
                               false);

                this.addLedger(prodRouteTrans.PostingCalcIssue,
                               LedgerDimensionFacade::serviceCreateLedgerDimension(prodRouteTrans.IssueLedgerDimension, prodRouteTrans.DefaultDimension),
                               -routeCostAmount,
                               false);

                // <GEERU>
                if (countryRegion_RU)
                {
                    ledgerVoucher.bondLast2_RU();
                }
                // </GEERU>
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectMaterialFinished</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds materials that are reported as finished to the internal storage structures to calculate
    ///    indirect cost. During backflush costing, no additional direct materials are reported as finished.
    /// </summary>
    /// <param name="_inventItemPrice">
    ///    The price of the finished good.
    /// </param>
    /// <param name="_qty">
    ///    The quantity that has been reported as finished.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The function name was incorrectly used, if this functionis called during the backflush costing.
    /// </exception>

    public void addDirectMaterialFinished(InventItemPrice _inventItemPrice, Qty _qty)
    {
        // No finished good reporting allowed during production flow calculation
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDirectOutsourcingToLedger</Name>
				<Source><![CDATA[
    protected void addDirectOutsourcingToLedger()
    {
        ProdRouteTrans      prodRouteTrans;

        SysDaSearchObject searchObject = new SysDaSearchObject(this.buildAddDirectManufacturingOrOutsourcingToLedgerQuery(prodRouteTrans, false));
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            CostAmount costAmount = CurrencyExchangeHelper::amount(prodRouteTrans.Amount);

            this.addLedger(prodRouteTrans.PostingCalcIssue,
                           LedgerDimensionFacade::serviceCreateLedgerDimension(prodRouteTrans.IssueLedgerDimension, prodRouteTrans.DefaultDimension),
                           costAmount,
                           false);

            this.addLedger(prodRouteTrans.PostingCalcIssueOffset,
                           LedgerDimensionFacade::serviceCreateLedgerDimension(prodRouteTrans.IssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension),
                           -costAmount,
                           false);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addIndirectCostToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the indirect cost transactions to the ledger voucher
    /// </summary>

    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addIndirectCostToLedger()
    {
        ProdIndirectTrans   prodIndirectTrans;
        CostAmount          indirectCostAmount;

        SysDaSearchObject searchObject = new SysDaSearchObject(this.buildAddOrClearIndirectQuery(prodIndirectTrans, false));
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            indirectCostAmount = CurrencyExchangeHelper::amount(prodIndirectTrans.Amount);

            // Reverse indirect cost posted on estimation account with original amount, account and dimension.
            this.addLedger(prodIndirectTrans.PostingEstimatedIndirectAbsorption,
                           prodIndirectTrans.EstimatedIndirectAbsorpLedgerDimension,
                           indirectCostAmount,
                           true);

            this.addLedger(prodIndirectTrans.PostingEstimatedIndirectAbsorptionOffset,
                           prodIndirectTrans.EstimIndirectAbsorpOffsetLedgerDimension,
                           -indirectCostAmount,
                           true);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>

            // Now post them to the absorption account
            this.addLedger(prodIndirectTrans.PostingIndirectAbsorption,
                           LedgerDimensionFacade::serviceCreateLedgerDimension(prodIndirectTrans.IndirectAbsorptionLedgerDimension, prodIndirectTrans.DefaultDimension),
                           -indirectCostAmount,
                           false);

            this.addLedger(prodIndirectTrans.PostingIndirectAbsorptionOffset,
                           LedgerDimensionFacade::serviceCreateLedgerDimension(prodIndirectTrans.IndirectAbsorptionOffsetLedgerDimension, prodIndirectTrans.DefaultDimension),
                           indirectCostAmount,
                           false);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOnDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a check on the period date should be performed or if it is okay not to check the
    ///    date.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    During the backflush costing no check on the period date should be performed. Therefore it is okay
    ///    to skip the check.
    /// </remarks>
    protected boolean checkOnDate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAddDirectManufacturingOrOutsourcingToLedgerQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildAddDirectManufacturingOrOutsourcingToLedgerQuery(
        ProdRouteTrans      _prodRouteTrans,
        boolean             _isManufacturing)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);
        queryProdRouteTrans.projection().addSum(fieldStr(ProdRouteTrans, Amount))
                                        .add(fieldStr(ProdRouteTrans, DefaultDimension))
                                        .add(fieldStr(ProdRouteTrans, PostingWIPIssue))
                                        .add(fieldStr(ProdRouteTrans, WIPIssueLedgerDimension))
                                        .add(fieldStr(ProdRouteTrans, PostingWIPValuation))
                                        .add(fieldStr(ProdRouteTrans, WIPValuationLedgerDimension))
                                        .add(fieldStr(ProdRouteTrans, PostingCalcIssue))
                                        .add(fieldStr(ProdRouteTrans, IssueLedgerDimension))
                                        .add(fieldStr(ProdRouteTrans, PostingCalcIssueOffset))
                                        .add(fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension));

        queryProdRouteTrans = this.buildGroupByClauseForAddDirectManufacturingOrOutsourcingToLedgerQuery(queryProdRouteTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForAddDirectManufacturingOrOutsourcingToLedgerQuery(_prodRouteTrans, _isManufacturing);
        queryProdRouteTrans.whereClause(whereClause);

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForAddDirectManufacturingOrOutsourcingToLedgerQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForAddDirectManufacturingOrOutsourcingToLedgerQuery(SysDaQueryObject _queryProdRouteTrans)
    {
        _queryProdRouteTrans.groupByClause()
            .add(fieldStr(ProdRouteTrans, DefaultDimension))
            .add(fieldStr(ProdRouteTrans, PostingWIPIssue))
            .add(fieldStr(ProdRouteTrans, WIPIssueLedgerDimension))
            .add(fieldStr(ProdRouteTrans, PostingWIPValuation))
            .add(fieldStr(ProdRouteTrans, WIPValuationLedgerDimension))
            .add(fieldStr(ProdRouteTrans, PostingCalcIssue))
            .add(fieldStr(ProdRouteTrans, IssueLedgerDimension))
            .add(fieldStr(ProdRouteTrans, PostingCalcIssueOffset))
            .add(fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension));

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForAddDirectManufacturingOrOutsourcingToLedgerQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForAddDirectManufacturingOrOutsourcingToLedgerQuery(
        ProdRouteTrans      _prodRouteTrans,
        boolean             _isManufacturing)
    {
        SysDaQueryExpression addDirectOperationToLedgerWhereClause = 
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, VoucherCalc)), new SysDaValueExpression(ledgerVoucher.lastVoucher()))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, DateCalc)), new SysDaValueExpression(ledgerVoucher.lastTransDate())));

        if (_isManufacturing)
        {
            addDirectOperationToLedgerWhereClause = addDirectOperationToLedgerWhereClause
                                           .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, WrkCtrId)), new SysDaValueExpression('')));
        }
        else
        {
            addDirectOperationToLedgerWhereClause = addDirectOperationToLedgerWhereClause
                                           .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, ServiceItemId)), new SysDaValueExpression('')))
                                           .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, IssueLedgerDimension)), new SysDaValueExpression(0)))
                                           .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension)), new SysDaValueExpression(0)));
        }

        return addDirectOperationToLedgerWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAddOrClearIndirectQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildAddOrClearIndirectQuery(
        ProdIndirectTrans       _prodIndirectTrans,
        boolean                 _isClear)
    {
        SysDaQueryObject queryProdIndirectTrans = new SysDaQueryObject(_prodIndirectTrans);
        queryProdIndirectTrans.projection().addSum(fieldStr(ProdIndirectTrans, Amount))
                                           .add(fieldStr(ProdIndirectTrans, DefaultDimension))
                                           .add(fieldStr(ProdIndirectTrans, PostingEstimatedIndirectAbsorption))
                                           .add(fieldStr(ProdIndirectTrans, EstimatedIndirectAbsorpLedgerDimension))
                                           .add(fieldStr(ProdIndirectTrans, PostingEstimatedIndirectAbsorptionOffset))
                                           .add(fieldStr(ProdIndirectTrans, EstimIndirectAbsorpOffsetLedgerDimension))
                                           .add(fieldStr(ProdIndirectTrans, PostingIndirectAbsorption))
                                           .add(fieldStr(ProdIndirectTrans, IndirectAbsorptionLedgerDimension))
                                           .add(fieldStr(ProdIndirectTrans, PostingIndirectAbsorptionOffset))
                                           .add(fieldStr(ProdIndirectTrans, IndirectAbsorptionOffsetLedgerDimension));

        queryProdIndirectTrans = this.buildGroupByClauseForAddOrClearIndirectQuery(queryProdIndirectTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForAddOrClearIndirectQuery(_prodIndirectTrans, _isClear);
        queryProdIndirectTrans.whereClause(whereClause);

        return queryProdIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForAddOrClearIndirectQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForAddOrClearIndirectQuery(SysDaQueryObject _queryProdIndirectTrans)
    {
        _queryProdIndirectTrans.groupByClause()
            .add(fieldStr(ProdIndirectTrans, DefaultDimension))
            .add(fieldStr(ProdIndirectTrans, PostingEstimatedIndirectAbsorption))
            .add(fieldStr(ProdIndirectTrans, EstimatedIndirectAbsorpLedgerDimension))
            .add(fieldStr(ProdIndirectTrans, PostingEstimatedIndirectAbsorptionOffset))
            .add(fieldStr(ProdIndirectTrans, EstimIndirectAbsorpOffsetLedgerDimension))
            .add(fieldStr(ProdIndirectTrans, PostingIndirectAbsorption))
            .add(fieldStr(ProdIndirectTrans, IndirectAbsorptionLedgerDimension))
            .add(fieldStr(ProdIndirectTrans, PostingIndirectAbsorptionOffset))
            .add(fieldStr(ProdIndirectTrans, IndirectAbsorptionOffsetLedgerDimension));

        return _queryProdIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForAddOrClearIndirectQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForAddOrClearIndirectQuery(
        ProdIndirectTrans       _prodIndirectTrans,
        boolean                 _isClear)
    {
        SysDaQueryExpression addIndirectCostToLedgerWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, VoucherCalc)), new SysDaValueExpression(ledgerVoucher.lastVoucher()))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, DateCalc)), new SysDaValueExpression(ledgerVoucher.lastTransDate())));

        if (_isClear)
        {
            addIndirectCostToLedgerWhereClause = addIndirectCostToLedgerWhereClause
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Posted)), new SysDaValueExpression(NoYes::Yes)));
        }

        return addIndirectCostToLedgerWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildClearOutsourcingOrResourcesWIPAccountQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildClearOutsourcingOrResourcesWIPAccountQuery(
        ProdRouteTrans      _prodRouteTrans,
        boolean             _isResources)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);

        queryProdRouteTrans.projection().addSum(fieldStr(ProdRouteTrans, Amount));

        if (!_isResources)
        {
            queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, ServiceItemId));
        }

        queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, DefaultDimension));

        if (_isResources)
        {
            queryProdRouteTrans.projection()
                .add(fieldStr(ProdRouteTrans, PostingCalcIssueOffset))
                .add(fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension));
        }
        else
        {
            queryProdRouteTrans.projection()
                .add(fieldStr(ProdRouteTrans, PostingCalcIssue))
                .add(fieldStr(ProdRouteTrans, IssueLedgerDimension));
        }

        queryProdRouteTrans = this.buildGroupByClauseForClearOutsourcingOrResourcesWIPAccountQuery(queryProdRouteTrans, _isResources);

        SysDaQueryExpression whereClause = this.buildWhereClauseForClearOutsourcingOrResourcesWIPAccountQuery(_prodRouteTrans, _isResources);
        queryProdRouteTrans.whereClause(whereClause);

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForClearOutsourcingOrResourcesWIPAccountQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForClearOutsourcingOrResourcesWIPAccountQuery(
        SysDaQueryObject       _queryProdRouteTrans,
        boolean                _isResources)
    {
        _queryProdRouteTrans.groupByClause().add(fieldStr(ProdRouteTrans, DefaultDimension));

        if (_isResources)
        {
            _queryProdRouteTrans.groupByClause()
                .add(fieldStr(ProdRouteTrans, PostingCalcIssueOffset))
                .add(fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension));
        }
        else
        {
            _queryProdRouteTrans.groupByClause()
                .add(fieldStr(ProdRouteTrans, PostingCalcIssue))
                .add(fieldStr(ProdRouteTrans, IssueLedgerDimension))
                .add(fieldStr(ProdRouteTrans, ServiceItemId));
        }

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForClearOutsourcingOrResourcesWIPAccountQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForClearOutsourcingOrResourcesWIPAccountQuery(
        ProdRouteTrans      _prodRouteTrans,
        boolean             _isResources)
    {
        SysDaQueryExpression clearDirectWIPAccountToLedgerWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefType)), new SysDaValueExpression(ProdTransRefType::ProductionFlow))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefId)), new SysDaValueExpression(productionFlowReference.planReference().PlanName)))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, VoucherCalc)), new SysDaValueExpression(ledgerVoucher.lastVoucher())))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, DateCalc)), new SysDaValueExpression(ledgerVoucher.lastTransDate())))
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension)), new SysDaValueExpression(0)));

        if (_isResources)
        {
            clearDirectWIPAccountToLedgerWhereClause = clearDirectWIPAccountToLedgerWhereClause
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, WrkCtrId)), new SysDaValueExpression('')));
        }
        else
        {
            clearDirectWIPAccountToLedgerWhereClause = clearDirectWIPAccountToLedgerWhereClause
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, ServiceItemId)), new SysDaValueExpression('')));
        }

        return clearDirectWIPAccountToLedgerWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventTableJoinClauseForClearResourcesWIPAccountQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildInventTableJoinClauseForClearResourcesWIPAccountQuery(
        ProdRouteTrans          _prodRouteTrans,
        InventTable             _inventTable)
    {
        SysDaQueryObject queryInventTable = new SysDaQueryObject(_inventTable);

        queryInventTable.projection().add(fieldStr(InventTable, CostGroupId));
        queryInventTable.groupByClause().add(fieldStr(InventTable, CostGroupId));
        queryInventTable.whereClause(new SysDaEqualsExpression(
                                     new SysDaFieldExpression(_inventTable, fieldStr(InventTable, ItemId)), new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, ServiceItemId))));
        
        return queryInventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateDirectManufacturingOrOutsourcingTransQuery</Name>
				<Source><![CDATA[
    protected SysDaUpdateObject buildUpdateDirectManufacturingOrOutsourcingTransQuery(
        ProdRouteTrans          _prodRouteTrans,
        LedgerDimensionAccount  _issueLedgerDimension,
        LedgerDimensionAccount  _issueOffsetLedgerDimension,
        DimensionDefault        _defaultDimension,
        boolean                 _isManufacturing)
    {
        SysDaUpdateObject queryProdRouteTrans = new SysDaUpdateObject(_prodRouteTrans);
        queryProdRouteTrans.settingClause()
                .add(fieldStr(ProdRouteTrans, Calculated), new SysDaValueExpression(NoYes::Yes))
                .add(fieldStr(ProdRouteTrans, IssueLedgerDimension), new SysDaValueExpression(_issueLedgerDimension))
                .add(fieldStr(ProdRouteTrans, IssueOffsetLedgerDimension), new SysDaValueExpression(_issueOffsetLedgerDimension));
        
        if (_isManufacturing)
        {
            queryProdRouteTrans.settingClause()
                    .add(fieldStr(ProdRouteTrans, PostingCalcIssue), new SysDaValueExpression(LedgerPostingType::ProdWrkCtrIssue))
                    .add(fieldStr(ProdRouteTrans, PostingCalcIssueOffset), new SysDaValueExpression(LedgerPostingType::ProdWrkCtrIssueOffsetAccount));
        }
        else
        {
            queryProdRouteTrans.settingClause()
                    .add(fieldStr(ProdRouteTrans, PostingCalcIssue), new SysDaValueExpression(LedgerPostingType::ProdLeanWIPServiceClearing))
                    .add(fieldStr(ProdRouteTrans, PostingCalcIssueOffset), new SysDaValueExpression(LedgerPostingType::ProdLeanWIPServiceReceipt));
        }

        queryProdRouteTrans.settingClause()
                .add(fieldStr(ProdRouteTrans, DateCalc), new SysDaValueExpression(ledgerVoucher.lastTransDate()))
                .add(fieldStr(ProdRouteTrans, VoucherCalc), new SysDaValueExpression(ledgerVoucher.lastVoucher()));

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateDirectManufacturingOrOutsourcingTransQuery(_prodRouteTrans, _defaultDimension, _isManufacturing);
        queryProdRouteTrans.whereClause(whereClause);

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForUpdateDirectManufacturingOrOutsourcingTransQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForUpdateDirectManufacturingOrOutsourcingTransQuery(
        ProdRouteTrans      _prodRouteTrans,
        DimensionDefault    _defaultDimension,
        boolean             _isManufacturing)
    {
        SysDaQueryExpression updateDirectOperationTransWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefType)), new SysDaValueExpression(ProdTransRefType::ProductionFlow))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefId)), new SysDaValueExpression(productionFlowReference.planReference().PlanName)));

        if (!_isManufacturing)
        {
            updateDirectOperationTransWhereClause = updateDirectOperationTransWhereClause
                .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, VoucherWIP)), new SysDaValueExpression(ledgerVoucher.lastVoucher()))); // exclude unused qty records
        }

        updateDirectOperationTransWhereClause = updateDirectOperationTransWhereClause
            .and(new SysDaLessThanOrEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, DateWIP)), new SysDaValueExpression(ledgerVoucher.lastTransDate())))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, Calculated)), new SysDaValueExpression(NoYes::No)))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, DefaultDimension)), new SysDaValueExpression(_defaultDimension)));

        if (_isManufacturing)
        {
            updateDirectOperationTransWhereClause = updateDirectOperationTransWhereClause
                 .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, WrkCtrId)), new SysDaValueExpression('')));
        }
        else
        {
            updateDirectOperationTransWhereClause = updateDirectOperationTransWhereClause
                .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, ServiceItemId)), new SysDaValueExpression('')));
        }

        return updateDirectOperationTransWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateIndirectTransQuery</Name>
				<Source><![CDATA[
    protected SysDaUpdateObject buildUpdateIndirectTransQuery(
        ProdIndirectTrans           _prodIndirectTrans,
        LedgerDimensionAccount      _absorptionLedgerDimension,
        LedgerDimensionAccount      _absorptionOffsetLedgerDimension,
        DimensionDefault            _defaultDimension,
        CostSheetNodeCode           _costSheetNodeCode)
    {
        SysDaUpdateObject queryProdIndirectTrans = new SysDaUpdateObject(_prodIndirectTrans);
        queryProdIndirectTrans.settingClause()
            .add(fieldStr(ProdIndirectTrans, Calculated), new SysDaValueExpression(NoYes::Yes))
            .add(fieldStr(ProdIndirectTrans, IndirectAbsorptionLedgerDimension), new SysDaValueExpression(_absorptionLedgerDimension))
            .add(fieldStr(ProdIndirectTrans, IndirectAbsorptionOffsetLedgerDimension), new SysDaValueExpression(_absorptionOffsetLedgerDimension))
            .add(fieldStr(ProdIndirectTrans, PostingIndirectAbsorption), new SysDaValueExpression(LedgerPostingType::IndirectAbsorption))
            .add(fieldStr(ProdIndirectTrans, PostingIndirectAbsorptionOffset), new SysDaValueExpression(LedgerPostingType::IndirectAbsorptionOffSet))
            .add(fieldStr(ProdIndirectTrans, DateCalc), new SysDaValueExpression(ledgerVoucher.lastTransDate()))
            .add(fieldStr(ProdIndirectTrans, VoucherCalc), new SysDaValueExpression(ledgerVoucher.lastVoucher()));

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateIndirectTransQuery(_prodIndirectTrans, _defaultDimension, _costSheetNodeCode);
        queryProdIndirectTrans.whereClause(whereClause);

        return queryProdIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForUpdateIndirectTransQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForUpdateIndirectTransQuery(
        ProdIndirectTrans       _prodIndirectTrans,
        DimensionDefault        _defaultDimension,
        CostSheetNodeCode       _costSheetNodeCode)
    {
        SysDaQueryExpression updateIndirectTransWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, TransRefType)), new SysDaValueExpression(ProdTransRefType::ProductionFlow))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, TransRefId)), new SysDaValueExpression(productionFlowReference.planReference().PlanName)))
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, VoucherEstimation)), new SysDaValueExpression(ledgerVoucher.lastVoucher())))
                    .and(new SysDaLessThanOrEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, DateEstimation)), new SysDaValueExpression(ledgerVoucher.lastTransDate())))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Calculated)), new SysDaValueExpression(NoYes::No)))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Posted)), new SysDaValueExpression(NoYes::Yes)))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, DefaultDimension)), new SysDaValueExpression(_defaultDimension)))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Code)), new SysDaValueExpression(_costSheetNodeCode)));

        return updateIndirectTransWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateDirectOutsourcingQueryOnProdGroup</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateDirectOutsourcingQueryOnProdGroup(ProdRouteTrans _prodRouteTrans)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);
        queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, DefaultDimension));

        queryProdRouteTrans = this.buildGroupByClauseForUpdateDirectOutsourcingQueryOnProdGroup(queryProdRouteTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateDirectOutsourcingQuery(_prodRouteTrans);
        queryProdRouteTrans.whereClause(whereClause);

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateDirectOutsourcingQueryOnServiceItemId</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateDirectOutsourcingQueryOnServiceItemId(ProdRouteTrans _prodRouteTrans)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);
        queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, DefaultDimension))
                                        .add(fieldStr(ProdRouteTrans, ServiceItemId));

        queryProdRouteTrans = this.buildGroupByClauseForUpdateDirectOutsourcingQueryOnServiceItemId(queryProdRouteTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateDirectOutsourcingQuery(_prodRouteTrans);
        queryProdRouteTrans.whereClause(whereClause);

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForUpdateDirectOutsourcingQueryOnProdGroup</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForUpdateDirectOutsourcingQueryOnProdGroup(SysDaQueryObject _queryProdRouteTrans)
    {
        _queryProdRouteTrans.groupByClause().add(fieldStr(ProdRouteTrans, DefaultDimension));

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForUpdateDirectOutsourcingQueryOnServiceItemId</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForUpdateDirectOutsourcingQueryOnServiceItemId(SysDaQueryObject _queryProdRouteTrans)
    {
        _queryProdRouteTrans.groupByClause()
            .add(fieldStr(ProdRouteTrans, DefaultDimension))
            .add(fieldStr(ProdRouteTrans, ServiceItemId));

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForUpdateDirectOutsourcingQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForUpdateDirectOutsourcingQuery(ProdRouteTrans _prodRouteTrans)
    {
        SysDaQueryExpression updateDirectOutsourcingWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefType)), new SysDaValueExpression(ProdTransRefType::ProductionFlow))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefId)), new SysDaValueExpression(productionFlowReference.planReference().PlanName)))
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, VoucherWIP)), new SysDaValueExpression(ledgerVoucher.lastVoucher()))) // exclude unused qty records
                    .and(new SysDaLessThanOrEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, DateWIP)), new SysDaValueExpression(ledgerVoucher.lastTransDate())))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, Calculated)), new SysDaValueExpression(NoYes::No)))
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, ServiceItemId)), new SysDaValueExpression('')));

        return updateDirectOutsourcingWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateIndirectQueryExcludingOffsetDimension</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateIndirectQueryExcludingOffsetDimension(
        ProdIndirectTrans      _prodIndirectTrans,
        CostSheetNodeTable     _costSheetNodeTable)
    {
        SysDaQueryObject queryProdIndirectTrans = new SysDaQueryObject(_prodIndirectTrans);
        queryProdIndirectTrans.projection()
            .add(fieldStr(ProdIndirectTrans, DefaultDimension))
            .add(fieldStr(ProdIndirectTrans, Code));

        queryProdIndirectTrans = this.buildGroupByClauseForUpdateIndirectQuery(queryProdIndirectTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateIndirectQuery(_prodIndirectTrans);
        queryProdIndirectTrans.whereClause(whereClause);

        queryProdIndirectTrans.joinClause(
            SysDaJoinKind::InnerJoin, 
            this.buildCostSheetNodeTableJoinClauseForUpdateIndirectQueryExcludingOffsetDimension(
                _prodIndirectTrans, 
                _costSheetNodeTable));

        return queryProdIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateIndirectQueryIncludingOffsetDimension</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateIndirectQueryIncludingOffsetDimension(
        ProdIndirectTrans      _prodIndirectTrans,
        CostSheetNodeTable     _costSheetNodeTable)
    {
        SysDaQueryObject queryProdIndirectTrans = new SysDaQueryObject(_prodIndirectTrans);
        queryProdIndirectTrans.projection()
            .add(fieldStr(ProdIndirectTrans, DefaultDimension))
            .add(fieldStr(ProdIndirectTrans, Code));

        queryProdIndirectTrans = this.buildGroupByClauseForUpdateIndirectQuery(queryProdIndirectTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateIndirectQuery(_prodIndirectTrans);
        queryProdIndirectTrans.whereClause(whereClause);

        queryProdIndirectTrans.joinClause(
            SysDaJoinKind::InnerJoin,
            this.buildCostSheetNodeTableJoinClauseForUpdateIndirectQueryIncludingOffsetDimension(
                _prodIndirectTrans,
                _costSheetNodeTable));

        return queryProdIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForUpdateIndirectQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForUpdateIndirectQuery(SysDaQueryObject _queryProdIndirectTrans)
    {
        _queryProdIndirectTrans.groupByClause()
            .add(fieldStr(ProdIndirectTrans, DefaultDimension))
            .add(fieldStr(ProdIndirectTrans, Code));

        return _queryProdIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForUpdateIndirectQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForUpdateIndirectQuery(ProdIndirectTrans _prodIndirectTrans)
    {
        SysDaQueryExpression updateIndirectWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, TransRefType)), new SysDaValueExpression(ProdTransRefType::ProductionFlow))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, TransRefId)), new SysDaValueExpression(productionFlowReference.planReference().PlanName)))
                    .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, VoucherEstimation)), new SysDaValueExpression(ledgerVoucher.lastVoucher())))
                    .and(new SysDaLessThanOrEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, DateEstimation)), new SysDaValueExpression(ledgerVoucher.lastTransDate())))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Calculated)), new SysDaValueExpression(NoYes::No)))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Posted)), new SysDaValueExpression(NoYes::Yes)));

        return updateIndirectWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCostSheetNodeTableJoinClauseForUpdateIndirectQueryExcludingOffsetDimension</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildCostSheetNodeTableJoinClauseForUpdateIndirectQueryExcludingOffsetDimension(
        ProdIndirectTrans       _prodIndirectTrans,
        CostSheetNodeTable      _costSheetNodeTable)
    {
        SysDaQueryObject queryCostSheetNodeTable = new SysDaQueryObject(_costSheetNodeTable);

        queryCostSheetNodeTable.projection().add(fieldStr(CostSheetNodeTable, IndirectAbsorptionLedgerDimension));
        queryCostSheetNodeTable.groupByClause().add(fieldStr(CostSheetNodeTable, IndirectAbsorptionLedgerDimension));

        queryCostSheetNodeTable.whereClause(new SysDaEqualsExpression(new SysDaFieldExpression(_costSheetNodeTable, fieldStr(CostSheetNodeTable, SheetId)), new SysDaValueExpression(CostSheetTable::defaultCostSheetTable().SheetId))
                                       .and(new SysDaEqualsExpression(new SysDaFieldExpression(_costSheetNodeTable, fieldStr(CostSheetNodeTable, Code)), new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Code)))));

        return queryCostSheetNodeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCostSheetNodeTableJoinClauseForUpdateIndirectQueryIncludingOffsetDimension</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildCostSheetNodeTableJoinClauseForUpdateIndirectQueryIncludingOffsetDimension(
        ProdIndirectTrans       _prodIndirectTrans,
        CostSheetNodeTable      _costSheetNodeTable)
    {
        SysDaQueryObject queryCostSheetNodeTable = new SysDaQueryObject(_costSheetNodeTable);

        queryCostSheetNodeTable.projection().add(fieldStr(CostSheetNodeTable, IndirectAbsorptionLedgerDimension))
                                            .add(fieldStr(CostSheetNodeTable, IndirectAbsorptionOffsetLedgerDimension));

        queryCostSheetNodeTable.groupByClause().add(fieldStr(CostSheetNodeTable, IndirectAbsorptionLedgerDimension))
                                               .add(fieldStr(CostSheetNodeTable, IndirectAbsorptionOffsetLedgerDimension));

        queryCostSheetNodeTable.whereClause(new SysDaEqualsExpression(new SysDaFieldExpression(_costSheetNodeTable, fieldStr(CostSheetNodeTable, SheetId)), new SysDaValueExpression(CostSheetTable::defaultCostSheetTable().SheetId))
                                       .and(new SysDaEqualsExpression(new SysDaFieldExpression(_costSheetNodeTable, fieldStr(CostSheetNodeTable, Code)), new SysDaFieldExpression(_prodIndirectTrans, fieldStr(ProdIndirectTrans, Code)))));

        return queryCostSheetNodeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateDirectManufacturingQueryOnProdGroup</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateDirectManufacturingQueryOnProdGroup(ProdRouteTrans _prodRouteTrans)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);
        queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, DefaultDimension));

        queryProdRouteTrans = this.buildGroupByClauseForUpdateDirectManufacturingQueryOnProdGroup(queryProdRouteTrans);

        SysDaQueryExpression whereClause = this.buildWhereClauseForUpdateDirectManufacturingQueryOnProdGroup(_prodRouteTrans);
        queryProdRouteTrans.whereClause(whereClause);

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateDirectManufacturingQueryOnItemWrkCtr</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateDirectManufacturingQueryOnItemWrkCtr(
        ProdRouteTrans      _prodRouteTrans,
        WrkCtrTable         _wrkCtrTable)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);
        queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, DefaultDimension));

        queryProdRouteTrans = this.buildGroupByClauseForUpdateDirectManufacturingQueryOnItemWrkCtr(queryProdRouteTrans);

        SysDaQueryExpression whereClause = this.buildCommonWhereClauseForDirectManufacturingQuery(_prodRouteTrans);
        queryProdRouteTrans.whereClause(whereClause);
        
        queryProdRouteTrans.joinClause(SysDaJoinKind::InnerJoin, this.buildJoinClauseForUpdateDirectManufacturingQueryOnItemWrkCtr(_prodRouteTrans, _wrkCtrTable));

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateDirectManufacturingQueryOnRouteCostCategory</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildUpdateDirectManufacturingQueryOnRouteCostCategory(
        ProdRouteTrans      _prodRouteTrans,
        RouteCostCategory   _routeCostCategory)
    {
        SysDaQueryObject queryProdRouteTrans = new SysDaQueryObject(_prodRouteTrans);
        queryProdRouteTrans.projection().add(fieldStr(ProdRouteTrans, DefaultDimension));

        queryProdRouteTrans = this.buildGroupByClauseForUpdateDirectManufacturingQueryOnRouteCostCategory(queryProdRouteTrans);

        SysDaQueryExpression whereClause = this.buildCommonWhereClauseForDirectManufacturingQuery(_prodRouteTrans);
        queryProdRouteTrans.whereClause(whereClause);

        queryProdRouteTrans.joinClause(SysDaJoinKind::InnerJoin, this.buildJoinClauseForUpdateDirectManufacturingQueryOnRouteCostCategory(_prodRouteTrans, _routeCostCategory));

        return queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForUpdateDirectManufacturingQueryOnProdGroup</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForUpdateDirectManufacturingQueryOnProdGroup(SysDaQueryObject _queryProdRouteTrans)
    {
        _queryProdRouteTrans.groupByClause().add(fieldStr(ProdRouteTrans, DefaultDimension));

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForUpdateDirectManufacturingQueryOnItemWrkCtr</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForUpdateDirectManufacturingQueryOnItemWrkCtr(SysDaQueryObject _queryProdRouteTrans)
    {
        _queryProdRouteTrans.groupByClause()
            .add(fieldStr(ProdRouteTrans, DefaultDimension))
            .add(fieldStr(ProdRouteTrans, WrkCtrId));

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGroupByClauseForUpdateDirectManufacturingQueryOnRouteCostCategory</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildGroupByClauseForUpdateDirectManufacturingQueryOnRouteCostCategory(SysDaQueryObject _queryProdRouteTrans)
    {
        _queryProdRouteTrans.groupByClause()
            .add(fieldStr(ProdRouteTrans, DefaultDimension))
            .add(fieldStr(ProdRouteTrans, CategoryId));

        return _queryProdRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCommonWhereClauseForDirectManufacturingQuery</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildCommonWhereClauseForDirectManufacturingQuery(ProdRouteTrans _prodRouteTrans)
    {
        SysDaQueryExpression updateDirectManufacturingWhereClause =
                         new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefType)), new SysDaValueExpression(ProdTransRefType::ProductionFlow))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, TransRefId)), new SysDaValueExpression(productionFlowReference.planReference().PlanName)))
                    .and(new SysDaLessThanOrEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, DateWIP)), new SysDaValueExpression(ledgerVoucher.lastTransDate())))
                    .and(new SysDaEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, Calculated)), new SysDaValueExpression(NoYes::No)));

        return updateDirectManufacturingWhereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForUpdateDirectManufacturingQueryOnProdGroup</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForUpdateDirectManufacturingQueryOnProdGroup(ProdRouteTrans _prodRouteTrans)
    {
        return this.buildCommonWhereClauseForDirectManufacturingQuery(_prodRouteTrans)
                   .and(new SysDaNotEqualsExpression(new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, WrkCtrId)), new SysDaValueExpression('')));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildJoinClauseForUpdateDirectManufacturingQueryOnItemWrkCtr</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildJoinClauseForUpdateDirectManufacturingQueryOnItemWrkCtr(
        ProdRouteTrans          _prodRouteTrans,
        WrkCtrTable             _wrkCtrTable)
    {
        SysDaQueryObject queryWrkCtrTable = new SysDaQueryObject(_wrkCtrTable);

        queryWrkCtrTable.projection()
                .add(fieldStr(WrkCtrTable, ResourceIssueLedgerDimension))
                .add(fieldStr(WrkCtrTable, ResourceIssueOffsetLedgerDimension));

        queryWrkCtrTable.groupByClause()
                .add(fieldStr(WrkCtrTable, ResourceIssueLedgerDimension))
                .add(fieldStr(WrkCtrTable, ResourceIssueOffsetLedgerDimension));

        queryWrkCtrTable.whereClause(new SysDaEqualsExpression(
                                     new SysDaFieldExpression(_wrkCtrTable, fieldStr(WrkCtrTable, WrkCtrId)), new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, WrkCtrId))));
        
        return queryWrkCtrTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildJoinClauseForUpdateDirectManufacturingQueryOnRouteCostCategory</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildJoinClauseForUpdateDirectManufacturingQueryOnRouteCostCategory(
        ProdRouteTrans                _prodRouteTrans,
        RouteCostCategory             _routeCostCategory)
    {
        SysDaQueryObject queryRouteCostCategory = new SysDaQueryObject(_routeCostCategory);

        queryRouteCostCategory.projection()
                .add(fieldStr(RouteCostCategory, ResourceIssueLedgerDimension))
                .add(fieldStr(RouteCostCategory, ResourceIssueOffsetLedgerDimension));

        queryRouteCostCategory.groupByClause()
                .add(fieldStr(RouteCostCategory, ResourceIssueLedgerDimension))
                .add(fieldStr(RouteCostCategory, ResourceIssueOffsetLedgerDimension));

        queryRouteCostCategory.whereClause(new SysDaEqualsExpression(
                                           new SysDaFieldExpression(_routeCostCategory, fieldStr(RouteCostCategory, CostCategoryId)), new SysDaFieldExpression(_prodRouteTrans, fieldStr(ProdRouteTrans, CategoryId))));
        
        return queryRouteCostCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildIndirectCostItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting indirect cost ledger dimension for an item.
    /// </summary>
    /// <param name="_prodIndirectTrans">Indirect cost transactions.</param>
    /// <returns>The built parameter instance.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventPostingCostItemLedgerDimensionParameters buildIndirectCostItemLedgerDimensionParameter(
        ProdIndirectTrans _prodIndirectTrans)
    {
        return InventPostingCostItemLedgerDimensionParameters::newFromParameters(
            InventAccountType::InventStdCostRoundingVariance, '', '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearIndirectWIPAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears WIP accounts for indirect cost.
    /// </summary>
    /// <remarks>
    ///    This method offsets with a rounding account.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void clearIndirectWIPAccount()
    {
        ProdIndirectTrans   prodIndirectTrans;

        SysDaSearchObject searchObject = new SysDaSearchObject(this.buildAddOrClearIndirectQuery(prodIndirectTrans, true));
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            CostAmount indirectCostAmount = CurrencyExchangeHelper::amount(prodIndirectTrans.Amount);

            this.addLedger(prodIndirectTrans.PostingIndirectAbsorptionOffset,
                           LedgerDimensionFacade::serviceCreateLedgerDimension(prodIndirectTrans.IndirectAbsorptionOffsetLedgerDimension, prodIndirectTrans.DefaultDimension),
                           -indirectCostAmount,
                           false);

            this.addLedger(InventPosting::accountType2LedgerPostingType(InventAccountType::InventStdCostRoundingVariance),
                           LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::costItemLedgerDimensionFromParameter(this.buildIndirectCostItemLedgerDimensionParameter(prodIndirectTrans)), leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId)),
                           indirectCostAmount,
                           false);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMaterialCostItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting direct material cost ledger dimension for an item.
    /// </summary>
    /// <param name="_inventMovement">The invent movement to use for creating the parameter.</param>
    /// <returns>The built parameter instance.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventPostingCostItemLedgerDimensionParameters buildMaterialCostItemLedgerDimensionParameter(
        InventMovement  _inventMovement)
    {
        return InventPostingCostItemLedgerDimensionParameters::newFromParameters(
            InventAccountType::InventStdCostRoundingVariance,
            '',
            _inventMovement.itemId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMaterialWIPAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears a WIP account for direct material cost.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The invent movement to use for clearing the WIP account.
    /// </param>
    /// <param name="_inventItemPrice">
    ///    The <c>inventItemPrice</c> to use to clear the WIP.
    /// </param>
    /// <param name="_qty">
    ///    The quantity to clear from the WIP.
    /// </param>
    /// <remarks>
    ///    This method offsets with a rounding account.The quantity parameter can be used to control the sign
    ///    of the postings. The <c>InventItemPrice</c> cannot be initialized in this method, as the date when the costing
    ///    of the production flow happens is not availiable in the <c>InventMovement</c> class.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void clearMaterialWIPAccount(
        InventMovement  _inventMovement,
        InventItemPrice _inventItemPrice,
        Qty             _qty = 0
        )
    {
        Qty                 costQuantity = _qty;

        if (costQuantity == 0)
        {
            // Try to get the quantity from the movement
            costQuantity = _inventMovement.transQty();
        }

        if (costQuantity == 0)
        {
            return;
        }

        CostAmount costAmount = CurrencyExchangeHelper::amount(costQuantity * _inventItemPrice.pcsPrice());

        this.addLedger(InventPosting::accountType2LedgerPostingType(InventAccountType::InventStdCostRoundingVariance),
                       LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::costItemLedgerDimensionFromParameter(this.buildMaterialCostItemLedgerDimensionParameter(_inventMovement)), leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId)),
                       costAmount,
                       false);

        this.addLedger(_inventMovement.postingOperations(),
                       LedgerDimensionFacade::serviceCreateLedgerDimension(_inventMovement.accountOperations(), _inventMovement.defaultDimension()),
                       -costAmount,
                       false);

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerVoucher.bondLast2_RU();
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOutsourcingCostItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting direct outsourcing cost ledger dimension for an item.
    /// </summary>
    /// <param name="_inventTable">An item.</param>
    /// <param name="_prodRouteTrans">Route transactions.</param>
    /// <returns>The built parameter instance.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventPostingCostItemLedgerDimensionParameters buildOutsourcingCostItemLedgerDimensionParameter(
        InventTable     _inventTable,
        ProdRouteTrans  _prodRouteTrans)
    {
        return InventPostingCostItemLedgerDimensionParameters::newFromParameters(
            InventAccountType::InventStdCostRoundingVariance,
            _inventTable.CostGroupId,
            _prodRouteTrans.ServiceItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearOutsourcingWIPAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears WIP accounts for direct outsourcing cost.
    /// </summary>
    /// <remarks>
    ///    This method offsets with a rounding account.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void clearOutsourcingWIPAccount()
    {
        ProdRouteTrans      prodRouteTrans;
        InventTable         inventTable;

        SysDaQueryObject clearOutsourcingWIPAccountQueryObject = this.buildClearOutsourcingOrResourcesWIPAccountQuery(prodRouteTrans, false);
        clearOutsourcingWIPAccountQueryObject.joinClause(SysDaJoinKind::InnerJoin, this.buildInventTableJoinClauseForClearResourcesWIPAccountQuery(prodRouteTrans, inventTable));

        SysDaSearchObject searchObject = new SysDaSearchObject(clearOutsourcingWIPAccountQueryObject);
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            CostAmount costAmount = CurrencyExchangeHelper::amount(prodRouteTrans.Amount);

            this.addLedger(prodRouteTrans.PostingCalcIssue,
                           LedgerDimensionFacade::serviceCreateLedgerDimension(prodRouteTrans.IssueLedgerDimension, prodRouteTrans.DefaultDimension),
                           -costAmount,
                           false);

            this.addLedger(InventPosting::accountType2LedgerPostingType(InventAccountType::InventStdCostRoundingVariance),
                           LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::costItemLedgerDimensionFromParameter(this.buildOutsourcingCostItemLedgerDimensionParameter(inventTable, prodRouteTrans)), leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId)),
                           costAmount,
                           false);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildResourceCostItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting direct manufacturing cost ledger dimension for an item.
    /// </summary>
    /// <param name="_prodRouteTrans">Route transactions.</param>
    /// <returns>The built parameter instance.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventPostingCostItemLedgerDimensionParameters buildResourceCostItemLedgerDimensionParameter(
        ProdRouteTrans  _prodRouteTrans)
    {
        return InventPostingCostItemLedgerDimensionParameters::newFromParameters(
            InventAccountType::InventStdCostRoundingVariance, '', '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearResourcesWIPAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears WIP accounts for direct manufacturing cost.
    /// </summary>
    /// <remarks>
    ///    This method offsets with a rounding account.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void clearResourcesWIPAccount()
    {
        ProdRouteTrans      prodRouteTrans;

        SysDaSearchObject searchObject = new SysDaSearchObject(this.buildClearOutsourcingOrResourcesWIPAccountQuery(prodRouteTrans, true));
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            CostAmount costAmount = CurrencyExchangeHelper::amount(prodRouteTrans.Amount);

            if (costAmount)
            {
                this.addLedger(prodRouteTrans.PostingCalcIssueOffset,
                               LedgerDimensionFacade::serviceCreateLedgerDimension(prodRouteTrans.IssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension),
                               -costAmount,
                               false);

                this.addLedger(InventPosting::accountType2LedgerPostingType(InventAccountType::InventStdCostRoundingVariance),
                               LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::costItemLedgerDimensionFromParameter(this.buildResourceCostItemLedgerDimensionParameter(prodRouteTrans)), leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId)),
                               costAmount,
                               false);
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearWIPAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears WIP accounts for conversion and indirect cost.
    /// </summary>
    /// <remarks>
    ///    This method offsets with a rounding account.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void clearWIPAccounts()
    {
        this.clearResourcesWIPAccount();
        this.clearOutsourcingWIPAccount();
        this.clearIndirectWIPAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIndirectConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Triggers the calculation of the indirect cost.
    /// </summary>
    /// <param name="_inventCostProdIndirect">
    /// The indirect cost calculation object.
    /// </param>

    protected void createIndirectConsumption(InventCostProdIndirect    _inventCostProdIndirect)
    {
        InventItemCostGroupRollupList           inventItemCostGroupRollupList;
        Map                                     itemCostGroupListMap;
        Map                                     reverseItemCostGroupListMap;
        MapEnumerator                           inventSiteIndirectMapEnum;
        MapEnumerator                           itemCostGroupListMapEnum;

        if (inventSiteConsumptionMap && inventSiteConsumptionMap.elements() != 0)
        {
            inventSiteIndirectMapEnum   = inventSiteConsumptionMap.getEnumerator();

            while (inventSiteIndirectMapEnum.moveNext())
            {
                itemCostGroupListMap   = inventSiteIndirectMapEnum.currentValue();

                // Post the physical one
                _inventCostProdIndirect.calcInvent(InventCostProdIndirectData_Invent::newConsumptionFromLeanProductionFlow(productionFlowReference.planReference().PlanName,
                                                          leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId),
                                                          inventSiteIndirectMapEnum.currentKey(),
                                                          NoYes::Yes,
                                                          itemCostGroupListMap));

                // now loop over this map and reverse the signs of the list
                reverseItemCostGroupListMap = new Map(Types::String, Types::Class);

                itemCostGroupListMapEnum = itemCostGroupListMap.getEnumerator();
                while (itemCostGroupListMapEnum.moveNext())
                {
                    inventItemCostGroupRollupList = itemCostGroupListMapEnum.currentValue();
                    inventItemCostGroupRollupList.reverseSign();
                    reverseItemCostGroupListMap.insert(itemCostGroupListMapEnum.currentKey(), inventItemCostGroupRollupList);
                }

                // Now post it financially with the sign reversed
                _inventCostProdIndirect.calcInvent(InventCostProdIndirectData_Invent::newConsumptionFromLeanProductionFlow(productionFlowReference.planReference().PlanName,
                                                    leanCostingFacade.getDefaultDimensions(productionFlowReference.RecId),
                                                    inventSiteIndirectMapEnum.currentKey(),
                                                    NoYes::No,
                                                    reverseItemCostGroupListMap));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findItemPriceOrThrowError</Name>
				<Source><![CDATA[
    private InventItemPrice findItemPriceOrThrowError(
        InventTable     _inventTable,
        ToDate          _toDate,
        InventDim       _inventDim)
    {
        InventItemPrice itemPrice = InventItemPrice::stdCostFindDate(_inventTable, _toDate, '', _inventDim);
        if (!itemPrice)
        {
            throw error(strFmt("@SYS120478", _inventTable.ItemId, _inventDim.InventSiteId), "", SysInfoActionMissingItemPrice::construct(_inventTable));
        }

        return itemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDirectManufacturing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the direct manufacturing cost.
    /// </summary>

    protected void processDirectManufacturing()
    {
        // Update all the existing indirect cost financially
        this.updateDirectManufacturing();

        // Now add these transactions to GL
        this.addDirectManufacturingToLedger();

        // Do not call super here, no new direct manufacturing transactions should be added during production flow calculation
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDirectOutsourcing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the direct outsourcing cost.
    /// </summary>
    protected void processDirectOutsourcing()
    {
        this.updateDirectOutsourcing();

        this.addDirectOutsourcingToLedger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIndirect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the indirect cost.
    /// </summary>

    protected void processIndirect()
    {
        // Update all the existing indirect cost financially
        this.updateIndirect();

        // Now add these transactions to GL
        this.addIndirectCostToLedger();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDirectManufacturing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the direct manufacturing cost to be calculated in bulk.
    /// </summary>

    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateDirectManufacturing()
    {
        RouteCostCategory           routeCostCategory;
        ProdRouteTrans              prodRouteTrans;
        ProdGroup                   prodGroup = leanCostingFacade.getProductionGroup(productionFlowReference.RecId);
        WrkCtrTable                 wrkCtrTable;
        LedgerDimensionAccount      issueLedgerDimension;
        LedgerDimensionAccount      issueOffsetLedgerDimension;

        // Now bulk update all the prodRouteTrans
        if (prodGroup &&
            ((prodGroup.ResourceIssueLedgerDimension && prodGroup.ResourceIssueOffsetLedgerDimension)
            || ProdParameters::find().ProdPostingType == ProdPostingType::ProdGroup))
        {
            SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateDirectManufacturingQueryOnProdGroup(prodRouteTrans));
            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while (searchStatement.next(searchObject))
            {
                // Take the accounts from the production group
                issueLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
                issueOffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);

                this.updateDirectManufacturingTrans(issueLedgerDimension, issueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
            }
        }
        else
        {
            if (ProdParameters::find().ProdPostingType == ProdPostingType::ItemWrkCtr)
            {
                SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateDirectManufacturingQueryOnItemWrkCtr(prodRouteTrans, wrkCtrTable));
                SysDaSearchStatement searchStatement = new SysDaSearchStatement();

                while (searchStatement.next(searchObject))
                {
                    // Take the accounts from the work center
                    issueLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(wrkCtrTable.ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
                    issueOffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(wrkCtrTable.ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);

                    this.updateDirectManufacturingTrans(issueLedgerDimension, issueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
                }
            }
            else
            {
                SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateDirectManufacturingQueryOnRouteCostCategory(prodRouteTrans, routeCostCategory));
                SysDaSearchStatement searchStatement = new SysDaSearchStatement();

                while (searchStatement.next(searchObject))
                {
                    // Take the accounts from the route cost category
                    issueLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(routeCostCategory.ResourceIssueLedgerDimension, prodRouteTrans.DefaultDimension);
                    issueOffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(routeCostCategory.ResourceIssueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);

                    this.updateDirectManufacturingTrans(issueLedgerDimension, issueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDirectManufacturingTrans</Name>
				<Source><![CDATA[
    private void updateDirectManufacturingTrans(
        LedgerDimensionAccount  _issueLedgerDimension,
        LedgerDimensionAccount  _issueOffsetLedgerDimension,
        DimensionDefault        _defaultDimension
        )
    {
        ProdRouteTrans          prodRouteTrans;

        new SysDaUpdateStatement().execute(
            this.buildUpdateDirectManufacturingOrOutsourcingTransQuery(
                   prodRouteTrans,
                    _issueLedgerDimension,
                    _issueOffsetLedgerDimension,
                    _defaultDimension,
                    true));

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDirectOutsourcing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the direct outsourcing cost to be calculated in bulk.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateDirectOutsourcing()
    {
        ProdRouteTrans              prodRouteTrans;
        ProdGroup                   prodGroup = leanCostingFacade.getProductionGroup(productionFlowReference.RecId);
        LedgerDimensionAccount      issueLedgerDimension;
        LedgerDimensionAccount      issueOffsetLedgerDimension;

        // Now bulk update all the prodRouteTrans
        if (prodGroup &&
            ((prodGroup.LeanWIPServiceClearingLedgerDimension && prodGroup.LeanWIPServiceReceiptLedgerDimension)
            || ProdParameters::find().ProdPostingType == ProdPostingType::ProdGroup))
        {
            SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateDirectOutsourcingQueryOnProdGroup(prodRouteTrans));
            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while (searchStatement.next(searchObject))
            {
                // Take the accounts from the production group
                issueLedgerDimension        = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.LeanWIPServiceClearingLedgerDimension, prodRouteTrans.DefaultDimension);
                issueOffsetLedgerDimension  = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.LeanWIPServiceReceiptLedgerDimension, prodRouteTrans.DefaultDimension);

                this.updateDirectOutsourcingTrans(issueLedgerDimension, issueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
            }
        }
        else
        {
            SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateDirectOutsourcingQueryOnServiceItemId(prodRouteTrans));
            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while (searchStatement.next(searchObject))
            {
                issueLedgerDimension        = LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::ProdLeanWIPServiceClearing, prodRouteTrans.ServiceItemId)), prodRouteTrans.DefaultDimension);
                issueOffsetLedgerDimension  = LedgerDimensionFacade::serviceCreateLedgerDimension(InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::ProdLeanWIPServiceReceipt, prodRouteTrans.ServiceItemId)), prodRouteTrans.DefaultDimension);

                this.updateDirectOutsourcingTrans(issueLedgerDimension, issueOffsetLedgerDimension, prodRouteTrans.DefaultDimension);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDirectOutsourcingTrans</Name>
				<Source><![CDATA[
    private void updateDirectOutsourcingTrans(
        LedgerDimensionAccount  _issueLedgerDimension,
        LedgerDimensionAccount  _issueOffsetLedgerDimension,
        DimensionDefault        _defaultDimension
        )
    {
        ProdRouteTrans          prodRouteTrans;

        new SysDaUpdateStatement().execute(
            this.buildUpdateDirectManufacturingOrOutsourcingTransQuery(
                   prodRouteTrans,
                    _issueLedgerDimension,
                    _issueOffsetLedgerDimension,
                    _defaultDimension,
                    false));

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIndirect</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the indirect cost to be calculated in bulk.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateIndirect()
    {
        ProdIndirectTrans           prodIndirectTrans;
        CostSheetNodeTable          costSheetNodeTable;
        ProdGroup                   prodGroup = leanCostingFacade.getProductionGroup(productionFlowReference.RecId);
        LedgerDimensionAccount      absorptionLedgerDimension;
        LedgerDimensionAccount      absorptionOffsetLedgerDimension;

        // Now bulk update all the prodIndirectTrans
        if (prodGroup &&
            ((prodGroup.IndirectAbsorptionOffsetLedgerDimension && prodGroup.EstimIndirectAbsorpOffsetLedgerDimension)
            || ProdParameters::find().ProdPostingType == ProdPostingType::ProdGroup))
        {
            SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateIndirectQueryExcludingOffsetDimension(prodIndirectTrans, costSheetNodeTable));
            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while (searchStatement.next(searchObject))
            {
                absorptionLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(costSheetNodeTable.IndirectAbsorptionLedgerDimension, prodIndirectTrans.DefaultDimension);
                absorptionOffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(prodGroup.IndirectAbsorptionOffsetLedgerDimension, prodIndirectTrans.DefaultDimension);

                this.updateIndirectTrans(absorptionLedgerDimension, absorptionOffsetLedgerDimension, prodIndirectTrans.DefaultDimension, prodIndirectTrans.Code);
            }
        }
        else
        {
            SysDaSearchObject searchObject = new SysDaSearchObject(this.buildUpdateIndirectQueryIncludingOffsetDimension(prodIndirectTrans, costSheetNodeTable));
            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while (searchStatement.next(searchObject))
            {
                absorptionLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(costSheetNodeTable.IndirectAbsorptionLedgerDimension, prodIndirectTrans.DefaultDimension);
                absorptionOffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(costSheetNodeTable.IndirectAbsorptionOffsetLedgerDimension, prodIndirectTrans.DefaultDimension);

                this.updateIndirectTrans(absorptionLedgerDimension, absorptionOffsetLedgerDimension, prodIndirectTrans.DefaultDimension, prodIndirectTrans.Code);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIndirectTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>ProdIndirectTrans</c> with a ledger dimension
    /// </summary>
    /// <param name="_absorptionLedgerDimension">
    /// The absorption ledger dimension to be set.
    /// </param>
    /// <param name="_absorptionOffsetLedgerDimension">
    /// The absorption offset ledger dimension to be set.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimension from the indirect cost transactions to update.
    /// </param>
    /// <param name="_costSheetNodeCode">
    /// The costing sheet node code from the indirect cost transactions to update.
    /// </param>
    private void updateIndirectTrans(
        LedgerDimensionAccount  _absorptionLedgerDimension,
        LedgerDimensionAccount  _absorptionOffsetLedgerDimension,
        DimensionDefault        _defaultDimension,
        CostSheetNodeCode       _costSheetNodeCode
        )
    {
        ProdIndirectTrans           prodIndirectTrans;

        new SysDaUpdateStatement().execute(this.buildUpdateIndirectTransQuery(
            prodIndirectTrans,
            _absorptionLedgerDimension,
            _absorptionOffsetLedgerDimension,
            _defaultDimension,
            _costSheetNodeCode));

    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected static LeanConversionCostUpd_CalcProdFlow construct()
    {
        return new LeanConversionCostUpd_CalcProdFlow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new <c>LeanConversionCostUpd_CalcProdFlow</c> object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object that is used for posting ledger transactions.
    /// </param>
    /// <param name="_leanProductionFlowReference">
    ///    The production flow reference for which the conversion cost is posted.
    /// </param>
    /// <param name="_leanCostingFacade">
    ///    The lean costing facade object to use for retrieving resource consumptions.
    /// </param>
    /// <returns>
    ///    A new <c>LeanConversionCostUpd_CalcProdFlow</c> object.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanConversionCostUpd_CalcProdFlow newFromParameters(
        LedgerVoucher                   _ledgerVoucher,
        LeanProductionFlowReference     _leanProductionFlowReference,
        LeanCostingFacadeBase           _leanCostingFacade
        )
    {
        LeanConversionCostUpd_CalcProdFlow       costUpd = LeanConversionCostUpd_CalcProdFlow::construct();

        costUpd.parmLedgerVoucher(_ledgerVoucher);
        costUpd.parmProductionFlowReference(_leanProductionFlowReference);
        costUpd.parmLeanCostingFacade(_leanCostingFacade);

        return costUpd;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>