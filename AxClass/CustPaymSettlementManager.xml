<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustPaymSettlementManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustPaymSettlementManager</c> class tracks the pending settlements for a customer payment.
/// </summary>
/// <remarks>
/// The methods on this class support updates to the payment and the pending settlements against it.
/// </remarks>
public class CustPaymSettlementManager
{
    private boolean initializedWithoutCustPayment = false;

    private SpecTransManager specTransMgr;
    private DiscGraceDays discGraceDays;
    private LedgerJournalTrans custPaymToSettle;
    private AmountCur markedTotalInPaymCur;
    private Map markedTotalInPaymCurList;
    private CustParameters custParms;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToMarkedTotal</Name>
				<Source><![CDATA[
    public void addToMarkedTotal(CustTransOpen _transOpen, AmountCur _amountToAdd)
    {
        if (markedTotalInPaymCurList.exists(_transOpen.RecId))
        {
            Debug::assert(false);

            markedTotalInPaymCurList.remove(_transOpen.RecId);
        }

        markedTotalInPaymCurList.insert(_transOpen.RecId, _amountToAdd);

        markedTotalInPaymCur += _amountToAdd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCashDiscAmountToTake</Name>
				<Source><![CDATA[
    public AmountCur calcCashDiscAmountToTake(CustTransOpen _custTransOpen)
    {
        AmountCur cashDiscToTake;
        CustTransCashDisc cashDisc = this.findCashDisc(_custTransOpen);
        CustVendCashDiscountHelper cashDiscountHelper = CustVendCashDiscountHelper::construct(_custTransOpen);

        cashDiscountHelper.parmFullCashDiscountForTier(cashDisc.CashDiscAmount);
        cashDiscountHelper.parmCashDiscountTaken(this.getCashDiscAmountTaken(_custTransOpen));

        cashDiscToTake = cashDiscountHelper.determineCashDiscForOpenAmount();

        return cashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the settled amount for the specified open transaction.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_settleAmountInTransCur">
    /// The suggested settle amount.
    /// </param>
    /// <param name="_settleRemainingAmount">
    /// A Boolean value that indicates whether to use a special cash discount type.
    /// </param>
    /// <returns>
    /// The settle amount.
    /// </returns>
    private AmountCur calcSettleAmount(
        CustTransOpen _markedCustTransOpen,
        AmountCur _settleAmountInTransCur,
        boolean _settleRemainingAmount = false)
    {
        CustVendTransOpenData transOpenData;
        UnspecificSpecific cashDiscType;
        AmountCur settleAmountInTransCur;
        AmountCur cashDiscToTake;

        changecompany(_markedCustTransOpen.company())
        {
            if (_settleRemainingAmount)
            {
                // recalculate the settle amount assuming full transaction is being paid less discount
                cashDiscToTake = this.calcCashDiscAmountToTake(_markedCustTransOpen);

                settleAmountInTransCur = specTransMgr.findUnmarkedAmountForRef(
                    _markedCustTransOpen.AmountCur,
                    _markedCustTransOpen.company(),
                    _markedCustTransOpen.TableId,
                    _markedCustTransOpen.RecId) - cashDiscToTake;
            }
            else
            {
                cashDiscType = CustParameters::findByCompany(_markedCustTransOpen.company()).CashDisc;

                transOpenData = CustVendTransOpenData::construct(_markedCustTransOpen);

                SpecTrans specTrans = specTransMgr.findByRef(_markedCustTransOpen.company(), _markedCustTransOpen.TableId, _markedCustTransOpen.RecId);

                settleAmountInTransCur = transOpenData.findSettlementAmount(
                    _settleAmountInTransCur,
                    cashDiscType,
                    custPaymToSettle.TransDate,
                    true,
                    specTrans.Balance01,
                    specTrans.CashDiscToTake);
            }
        }

        return settleAmountInTransCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePartialApplicableCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the applicable partial cash discount based on the amount to settle.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to find the cash discount transaction.
    /// </param>
    /// <param name="_settleAmountInTransCur">
    /// The amount to settle in open transaction currency.
    /// </param>
    /// <returns>
    /// The applicable partial cash discount.
    /// </returns>
    public AmountCur calculatePartialApplicableCashDiscount(CustTransOpen _custTransOpen, AmountCur _settleAmountInTransCur)
    {
        AmountCur cashDiscAmountToTake;
        AmountCur fullCashDiscAmount;
        CustVendCashDiscountHelper cashDiscountHelper;

        cashDiscountHelper = CustVendCashDiscountHelper::construct(_custTransOpen);

        fullCashDiscAmount = this.findCashDisc(_custTransOpen).CashDiscAmount;
        cashDiscountHelper.parmFullCashDiscountForTier(fullCashDiscAmount);
        cashDiscountHelper.parmCashDiscountTaken(this.getCashDiscAmountTaken(_custTransOpen));

        cashDiscountHelper.parmRemainingOpenBalance(specTransMgr.findUnmarkedAmountForRef(
            _custTransOpen.AmountCur,
            _custTransOpen.company(),
            tableNum(CustTransOpen),
            _custTransOpen.RecId));

        cashDiscAmountToTake = cashDiscountHelper.determineCashDiscForPartialSettlement(_settleAmountInTransCur);

        return cashDiscAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertPaymAmountCurToTransAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the payment currency to the currency of the open transaction.
    /// </summary>
    /// <param name="_transOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_paymAmountCur">
    /// The amount to convert to the currency of the open transaction.
    /// </param>
    /// <returns>
    /// The amount in the currency of the open transaction.
    /// </returns>
    public AmountCur convertPaymAmountCurToTransAmountCur(CustTransOpen _transOpen, AmountCur _paymAmountCur)
    {
        CustTrans trans;
        CurrencyExchangeHelper paymExchHelper;
        CurrencyExchangeHelper transExchHelper;
        AmountCur convertedAmount;
        AmountCur tempAmount;
        CrossExchRate crossRate;
        CurrencyCode paymMstCurrency;
        CurrencyCode transMstCurrency;

        trans = _transOpen.custTrans();

        // get stored cross rate (stored with exchange rate factor of 100)
        crossRate = specTransMgr.findByRef(trans.company(), trans.TableId, trans.RecId).CrossRate;

        if (trans.CurrencyCode == custPaymToSettle.CurrencyCode)
        {
            // the amounts are interchangeable
            convertedAmount = _paymAmountCur;
        }
        else if (crossRate != 0)
        {
            // paym currency to marked trans currency using the cross rate
            tempAmount = CurrencyExchange::calculateAmount(_paymAmountCur, 100 / crossRate);

            convertedAmount = CurrencyExchange::round(tempAmount, trans.CurrencyCode);
        }
        else
        {
            paymExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(custPaymToSettle.Company).RecId),custPaymToSettle.TransDate);

            if (custPaymToSettle.ExchRate != 0)
            {
                paymExchHelper.parmExchangeRate1(custPaymToSettle.ExchRate);
            }

            if (custPaymToSettle.ExchRateSecond != 0)
            {
                paymExchHelper.parmExchangeRate2(custPaymToSettle.ExchRateSecond);
            }

            // paym currency to paym company currency
            tempAmount = paymExchHelper.calculateTransactionToAccounting( custPaymToSettle.CurrencyCode, _paymAmountCur, false);

            transExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(trans.company()).RecId), custPaymToSettle.TransDate);

            if (custPaymToSettle.Company != trans.company())
            {
                changecompany(trans.company())
                {
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(custPaymToSettle.Company)
                {
                    paymMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (paymMstCurrency != transMstCurrency)
                {
                    // paym company currency to trans company currency
                    tempAmount = transExchHelper.calculateTransactionToAccounting( paymMstCurrency, tempAmount, false);
                }
            }

            // trans company currency to trans currency
            convertedAmount = transExchHelper.calculateAccountingToTransaction(trans.CurrencyCode, tempAmount, true);
        }

        return convertedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertTransAmountCurToPaymAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the currency of the open transaction to the currency of the
    /// payment.
    /// </summary>
    /// <param name="_transOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_transAmountCur">
    /// The amount to convert to the payment currency.
    /// </param>
    /// <returns>
    /// The amount in the currency of the open transaction.
    /// </returns>
    public AmountCur convertTransAmountCurToPaymAmountCur(CustTransOpen _transOpen, AmountCur _transAmountCur)
    {
        CustTrans trans;
        CurrencyExchangeHelper paymExchHelper;
        CurrencyExchangeHelper transExchHelper;
        AmountCur convertedAmount;
        AmountCur tempAmount;
        CrossExchRate crossRate;
        CurrencyCode paymMstCurrency;
        CurrencyCode transMstCurrency;

        trans = _transOpen.custTrans();

        // get stored cross rate (stored with exchange rate factor of 100)
        crossRate = specTransMgr.findByRef(_transOpen.company(), _transOpen.TableId, _transOpen.RecId).CrossRate;

        if (trans.CurrencyCode == custPaymToSettle.CurrencyCode)
        {
            // the amounts are interchangeable
            convertedAmount = _transAmountCur;
        }
        else if (crossRate != 0)
        {
            // paym to marked transaction currency using the cross rate
            tempAmount = CurrencyExchange::calculateAmount(_transAmountCur, crossRate);

            convertedAmount = CurrencyExchange::round(tempAmount, custPaymToSettle.CurrencyCode);
        }
        else
        {
            transExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(trans.company()).RecId),custPaymToSettle.TransDate);

            // trans currency to trans company currency
            tempAmount = transExchHelper.calculateTransactionToAccounting( trans.CurrencyCode, _transAmountCur, false);

            if (custPaymToSettle.Company != trans.company())
            {
                changecompany(trans.company())
                {
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(custPaymToSettle.Company)
                {
                    paymMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (transMstCurrency != paymMstCurrency)
                {
                    // trans company currency to paym company currency
                    tempAmount = transExchHelper.calculateAccountingToTransaction(paymMstCurrency, tempAmount, false);
                }
            }

            paymExchHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(custPaymToSettle.Company).RecId));

            if (custPaymToSettle.ExchRate != 0)
            {
                paymExchHelper.parmExchangeRate1(custPaymToSettle.ExchRate);
            }

            if (custPaymToSettle.ExchRateSecond != 0)
            {
                paymExchHelper.parmExchangeRate2(custPaymToSettle.ExchRateSecond);
            }

            // paym company currency to paym currency
            convertedAmount = paymExchHelper.calculateAccountingToTransaction(custPaymToSettle.CurrencyCode, tempAmount, true);
        }

        return convertedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all the pending settlements of the current payment.
    /// </summary>
    public void deleteAll()
    {
        if (custPaymToSettle.parmLedgerDimension())
        {
            specTransMgr.deleteAll();

            this.resetMarkedTotal();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount to take for the specified customer open transaction.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The customer open transaction for which to get the cash discount amount.
    /// </param>
    /// <returns>
    /// The cash discount amount to take for the open transaction.
    /// </returns>
    /// <remarks>
    /// The cash discount to take is calculated as the discount amount minus the discount taken. The cash
    /// discount to take will be zero when the use cash discount is never, or the open transaction is a
    /// credit note and discount is not allowed on credit notes.
    /// </remarks>
    protected CashDiscAmount determineCashDiscAmountToTake(CustTransOpen _custTransOpen)
    {
        CashDiscAmount cashDiscAmountToTake;
        CustVendCashDiscountHelper cashDiscountHelper;

        cashDiscountHelper = CustVendCashDiscountHelper::construct(_custTransOpen);

        if (custPaymToSettle.TransDate == dateNull())
        {
            cashDiscountHelper.parmDiscountDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }
        else
        {
            cashDiscountHelper.parmDiscountDate(custPaymToSettle.TransDate);
        }

        cashDiscountHelper.parmGraceDays(discGraceDays);
        cashDiscountHelper.parmCashDiscountTaken(this.getCashDiscAmountTaken(_custTransOpen));

        cashDiscAmountToTake = cashDiscountHelper.determineCashDiscForOpenAmount();

        return cashDiscAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the cash discount that is associated with the specified open transaction.
    /// </summary>
    /// <param name="_associatedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// The cash discount that is associated with the specified open transaction.
    /// </returns>
    /// <remarks>
    /// This is in the scope of the current payment.
    /// </remarks>
    public CustTransCashDisc findCashDisc(CustTransOpen _associatedCustTransOpen)
    {
        CustTransCashDisc cashDisc;

        changecompany(_associatedCustTransOpen.company())
        {
            cashDisc = CustTransCashDisc::findByUseCashDisc(
                tableNum(CustTransOpen),
                _associatedCustTransOpen.RecId,
                _associatedCustTransOpen.UseCashDisc,
                custPaymToSettle.TransDate,
                discGraceDays);
        }

        return cashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustParameters</Name>
				<Source><![CDATA[
    private CustParameters findCustParameters(CompanyId _company)
    {
        Debug::assert(_company != '');

        if ((custParms.RecId == 0) || (custParms.company() != _company))
        {
            custParms = CustParameters::findByCompany(_company);
        }

        return custParms;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountTaken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount taken that corresponds to the open transaction in the transaction
    /// currency.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to get the cash discount amount.
    /// </param>
    /// <returns>
    /// The cash discount amount taken in the transaction currency.
    /// </returns>
    public CashDiscAmount getCashDiscAmountTaken(CustTransOpen _custTransOpen)
    {
        CashDiscAmount cashDiscAmountTaken;

        changecompany(_custTransOpen.company())
        {
            cashDiscAmountTaken = _custTransOpen.getCashDiscAlreadyTaken()
                + specTransMgr.findCashDiscountMarkedToBeTaken(_custTransOpen.company(), tableNum(CustTransOpen), _custTransOpen.RecId);
        }

        return cashDiscAmountTaken;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount to take for the specified open transaction.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to get the cash discount amount to take.
    /// </param>
    /// <returns>
    /// The cash discount amount to take for the open transaction.
    /// </returns>

    public CashDiscAmount getCashDiscAmountToTake(CustTransOpen _custTransOpen)
    {
        CashDiscAmount returnCashDiscToTake;
        SpecTrans specTrans;

        specTrans = specTransMgr.findByRef(_custTransOpen.company(), _custTransOpen.TableId, _custTransOpen.RecId);

        if (specTrans.RecId != 0)
        {
            // Get cash discount amount stored on associated SpecTrans record
            returnCashDiscToTake = specTrans.CashDiscToTake;
        }
        else
        {
            returnCashDiscToTake = this.determineCashDiscAmountToTake(_custTransOpen);
        }

        return returnCashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cross rate of the pending settlement for the specified open transaction.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// The cross rate.
    /// </returns>
    /// <remarks>
    /// This is in the scope of the current payment.
    /// </remarks>
    public CrossExchRate getCrossRate(CustVendTransOpen _markedCustTransOpen)
    {
        // display cross rate using exchange rate factor of 1
        return CurrencyEuroDenomination::displayStoredExchangeRate_Static(
            specTransMgr.findByRef(
                _markedCustTransOpen.company(),
                _markedCustTransOpen.TableId,
                _markedCustTransOpen.RecId).CrossRate,
            ExchangeRateDisplayFactor::One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustTransOpenPrevSettledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount settled that corresponds to the open transaction in the transaction currency.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to get the cash discount amount.
    /// </param>
    /// <returns>
    /// The amount settled in the transaction currency.
    /// </returns>
    public AmountCur getCustTransOpenPrevSettledAmount(CustTransOpen _custTransOpen)
    {
        AmountCur prevSettledAmount;

        changecompany(_custTransOpen.company())
        {
            prevSettledAmount = _custTransOpen.getPrevSettledAmount();
        }

        return prevSettledAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total amount of the transactions marked for settlement for the current payment.
    /// </summary>
    /// <returns>
    /// The total amount of the transactions marked for settlement.
    /// </returns>
    /// <remarks>
    /// The amount is in the currency of the payment.
    /// </remarks>
    public AmountCur getMarkedTotal()
    {
        return markedTotalInPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount of the pending settlement for the specified open transaction.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// The amount of the settlement.
    /// </returns>
    /// <remarks>
    /// This is in the scope of the current payment.
    /// </remarks>
    public AmountCur getSettleAmount(CustTransOpen _markedCustTransOpen)
    {
        AmountCur settleAmount;
        SpecTrans specTrans;
        AmountCur cashDiscToTake;

        specTrans = specTransMgr.findByRef(
            _markedCustTransOpen.company(),
            _markedCustTransOpen.TableId,
            _markedCustTransOpen.RecId);

        if (specTrans.RecId == 0)
        {
            // not marked
            cashDiscToTake = this.calcCashDiscAmountToTake(_markedCustTransOpen);

            settleAmount = specTransMgr.findUnmarkedAmountForRef(
                _markedCustTransOpen.AmountCur,
                _markedCustTransOpen.company(),
                _markedCustTransOpen.TableId,
                _markedCustTransOpen.RecId) - cashDiscToTake;

            // <GBR>
            if (BrazilParameters::isEnabled() &&
                (_markedCustTransOpen.FineAmount_BR || _markedCustTransOpen.InterestAmount_BR))
            {
                settleAmount += _markedCustTransOpen.InterestAmount_BR + _markedCustTransOpen.FineAmount_BR;
            }
            // </GBR>
        }
        else
        {
            settleAmount = specTrans.Balance01;
        }

        return settleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForExistingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs initialization for existing pending settlements.
    /// </summary>
    private void initForExistingTrans()
    {
        Map markedTransList;
        MapEnumerator enumerator;
        CustTransOpen transOpen;
        SpecTrans spec;
        AmountCur settleAmountInPaymCur;
        AmountCur settleAmountInTransCur;

        this.resetMarkedTotal();

        markedTransList = specTransMgr.getAllSpecTransMap();

        enumerator = new MapEnumerator(markedTransList);
        while (enumerator.moveNext())
        {
            spec = enumerator.currentValue();
            transOpen = spec.custTransOpen();

            settleAmountInTransCur = this.getSettleAmount(transOpen);

            settleAmountInPaymCur =
                this.convertTransAmountCurToPaymAmountCur(transOpen, settleAmountInTransCur);

            this.addToMarkedTotal(transOpen, settleAmountInPaymCur);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAlreadyMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified open transaction is marked for settlement by another payment.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// true if the open transaction is marked for settlement; otherwise, false.
    /// </returns>
    public boolean isAlreadyMarked(CustTransOpen _markedCustTransOpen)
    {
        return specTransMgr.existForOtherSpec(
            _markedCustTransOpen.company(),
            _markedCustTransOpen.TableId,
            _markedCustTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAlreadyFullyMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified open transaction is fully marked for settlement by other payments.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// true if the open transaction is fully marked for settlement; otherwise, false.
    /// </returns>
    public boolean isAlreadyFullyMarked(CustTransOpen _markedCustTransOpen)
    {
        return specTransMgr.checkTransFullyMarkedByOtherSpec(_markedCustTransOpen);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymSettled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets whether the current payment has any pending settlements.
    /// </summary>
    /// <returns>
    /// true if the current payment has pending settlements; otherwise, false.
    /// </returns>
    public boolean isPaymSettled()
    {
        return specTransMgr.getSpecTransCount() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified open transaction is marked for settlement by the current payment.
    /// </summary>
    /// <param name="_settledCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// true if the open transaction is marked for settlement; otherwise, false.
    /// </returns>
    public boolean isTransMarked(CustTransOpen _settledCustTransOpen)
    {
        return specTransMgr.exist(
            _settledCustTransOpen.company(),
            _settledCustTransOpen.TableId,
            _settledCustTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the specified open transaction for settlement to the customer payment.
    /// </summary>
    /// <param name="_owningCustPaym">
    /// The payment.
    /// </param>
    /// <param name="_transOpenToMark">
    /// The open transaction.
    /// </param>
    /// <param name="_trans">
    /// The customer transaction.
    /// </param>
    /// <param name="_allowMarkingPastPaymAmount">
    /// A Boolean value that determines whether the total of the open transactions marked for settlement
    /// will be allowed to exceed the payment amount.
    /// </param>
    /// <param name="_performValidation">
    /// A Boolean value that determines whether validation will be performed.
    /// </param>
    /// <returns>
    /// true if the transaction was marked; otherwise, false.
    /// </returns>
    public boolean markTrans(
        LedgerJournalTrans _owningCustPaym,
        CustTransOpen _transOpenToMark,
        CustTrans _trans,
        boolean _allowMarkingPastPaymAmount,
        boolean _performValidation)
    {
        CustParameters parms;
        AmountCur discAmountToTake;
        AmountCur discAmountInTransCur;
        AmountCur paymAmountInPaymCur;
        AmountCur remainingPaymAmountInPaymCur;
        AmountCur remainingTransAmountInPaymCur;
        AmountCur settleAmountInPaymCur;
        AmountCur settleAmountInTransCur;
        AmountCur transAmountInPaymCur;
        AmountCur transAmountInTransCur;
        int markedCount;

        if (_performValidation && this.isAlreadyFullyMarked(_transOpenToMark))
        {
            return false;
        }

        transAmountInTransCur = specTransMgr.findUnmarkedAmountForRef(
            _transOpenToMark.AmountCur,
            _transOpenToMark.company(),
            _transOpenToMark.TableId,
            _transOpenToMark.RecId);

        discAmountToTake = this.calcCashDiscAmountToTake(_transOpenToMark);
        discAmountInTransCur = discAmountToTake;

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            // Setting Interest/Fine amounts
            this.updateInterestAndFine_BR(_transOpenToMark.company(), _transOpenToMark, _owningCustPaym.TransDate, _transOpenToMark.AmountCur, discAmountInTransCur);

            // Adding Interest/Fine Amounts
            transAmountInTransCur += _transOpenToMark.InterestAmount_BR + _transOpenToMark.FineAmount_BR;
        }
        // </GBR>

        parms = this.findCustParameters(_transOpenToMark.company());

        if (_allowMarkingPastPaymAmount || (parms.MaxMSTOverUnder != 0) || (parms.MaxMSTDiff != 0))
        {
            // the settle amount is not restricted by the paym amount or we
            // don't want to restrict the settle amount to ensure the penny
            // difference and over/under will be used when applicable
            settleAmountInTransCur = transAmountInTransCur - discAmountInTransCur;

            settleAmountInPaymCur =
                this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, settleAmountInTransCur);
        }
        else
        {
            // determine the settle amount when the marked total isn't allowed to exceed the paym amount
            paymAmountInPaymCur = custPaymToSettle.displayCustPaymAmount();

            if (((paymAmountInPaymCur < 0) && (transAmountInTransCur < 0)) ||
                ((paymAmountInPaymCur > 0) && (transAmountInTransCur > 0)))
            {
                // the settle amount could be restricted
                transAmountInPaymCur =
                    this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, (transAmountInTransCur - discAmountInTransCur));

                remainingPaymAmountInPaymCur = (paymAmountInPaymCur - this.getMarkedTotal());
                remainingTransAmountInPaymCur = transAmountInPaymCur;

                if (abs(remainingTransAmountInPaymCur) <= abs(remainingPaymAmountInPaymCur))
                {
                    // settle amount: full amount of the invoice
                    settleAmountInPaymCur = transAmountInPaymCur;

                    settleAmountInTransCur = transAmountInTransCur - discAmountInTransCur;
                }
                else
                {
                    // settle amount: remaining amount of the paym
                    settleAmountInPaymCur = remainingPaymAmountInPaymCur;

                    settleAmountInTransCur =
                        this.convertPaymAmountCurToTransAmountCur(_transOpenToMark, settleAmountInPaymCur);

                    // <GBR>
                    if (BrazilParameters::isEnabled() &&
                        (_transOpenToMark.InterestAmount_BR || _transOpenToMark.FineAmount_BR))
                    {
                        // Setting Interest/Fine amounts to zero
                        if (this.isTransMarked(_transOpenToMark))
                        {
                            this.updateInterestAndFine_BR(
                                _transOpenToMark.company(),
                                _transOpenToMark,
                                _owningCustPaym.TransDate,
                                0,
                                0);
                        }
                    }
                    // </GBR>
                }
            }
            else
            {
                // the settle amount is not restricted
                settleAmountInTransCur = transAmountInTransCur - discAmountInTransCur;

                settleAmountInPaymCur =
                    this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, settleAmountInTransCur);
            }
        }

        if ((!BrazilParameters::isEnabled() && settleAmountInTransCur != _transOpenToMark.AmountCur)
            || (BrazilParameters::isEnabled() && (settleAmountInTransCur != (_transOpenToMark.AmountCur + _transOpenToMark.InterestAmount_BR + _transOpenToMark.FineAmount_BR))))
        {
            // At this point the settleAmountInTransCur is the amount being paid. If partial discount is allowed
            // this would be the amount after subtracting the discount.

            // The transaction is not fully settled, so need to calculate the discount based on the amount being paid
            discAmountInTransCur =
                this.calculatePartialApplicableCashDiscount(_transOpenToMark, settleAmountInTransCur);

            settleAmountInPaymCur =
                this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, settleAmountInTransCur);
        }

        if (settleAmountInTransCur != 0)
        {
            specTransMgr.insert(
                _transOpenToMark.company(),
                _transOpenToMark.TableId,
                _transOpenToMark.RecId,
                settleAmountInTransCur,
                _trans.CurrencyCode,
                NoYes::No,
                discAmountInTransCur,
                custPaymToSettle.TransDate
                );

            markedCount = specTransMgr.getSpecTransCount();

            _owningCustPaym.updateMarkedInvoiceWithTrans(markedCount, _transOpenToMark, _trans);

            this.addToMarkedTotal(_transOpenToMark, settleAmountInPaymCur);
        }

        return (settleAmountInTransCur != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustPaymSettlementManager</c> class.
    /// </summary>
    /// <param name="_custPaym">
    /// The customer payment that owns the pending settlements.
    /// </param>
    protected void new(LedgerJournalTrans _custPaym)
    {
        LedgerJournalTrans payment;

        specTransMgr = SpecTransManager::newFromSpec(_custPaym, true);

        // clear the payment amount so it isn't included in the balance
        payment.data(_custPaym);
        payment.convertCustPaymAmountCurToDebitCredit(0);

        this.resetMarkedTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSpecTransMgr</Name>
				<Source><![CDATA[
    public SpecTransManager parmSpecTransMgr(SpecTransManager _specTransMgr = specTransMgr)
    {
        specTransMgr = _specTransMgr;

        return specTransMgr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeFromMarkedTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the pending settlement of the specified open transaction to the customer payment.
    /// </summary>
    /// <param name = "_transOpen">
    /// The <c>CustTransOpen</c> table buffer.
    /// </param>
    protected void removeFromMarkedTotal(CustTransOpen _transOpen)
    {
        AmountCur amount;

        if (markedTotalInPaymCurList.exists(_transOpen.RecId))
        {
            amount = markedTotalInPaymCurList.lookup(_transOpen.RecId);

            markedTotalInPaymCurList.remove(_transOpen.RecId);

            markedTotalInPaymCur -= amount;
        }
        else
        {
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetMarkedTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the payment amount.
    /// </summary>
    protected void resetMarkedTotal()
    {
        markedTotalInPaymCur = 0.0;

        markedTotalInPaymCurList = new Map(Types::Int64, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the payment information and performs the necessary updates.
    /// </summary>
    /// <param name="_newPaym">
    /// The new payment.
    /// </param>
    /// <remarks>
    /// Use this method when the payment is changed during ordinary processing.
    /// </remarks>
    public void setPaym(LedgerJournalTrans _newPaym)
    {
        DiscGraceDays newGraceDays;
        ExchRate prevExchRate;
        TransDate prevTransDate;

        prevExchRate = custPaymToSettle.ExchRate;
        prevTransDate = custPaymToSettle.TransDate;

        newGraceDays = CustPaymModeTable::discGraceDays(_newPaym.PaymMode);

        this.setPaymCore(_newPaym, newGraceDays);

        if ((prevExchRate != _newPaym.ExchRate) ||
            (discGraceDays != newGraceDays) ||
            (prevTransDate != _newPaym.TransDate))
        {
            this.updateExistingTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymCore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the payment information.
    /// </summary>
    /// <param name="_newPaym">
    /// The new payment.
    /// </param>
    /// <param name="_newGraceDays">
    /// The new grace days for the discount.
    /// </param>
    /// <remarks>
    /// Use this method when the payment is changed and manual control of the necessary updates is
    /// required. This method does not perform any related updates
    /// </remarks>
    public void setPaymCore(LedgerJournalTrans _newPaym, DiscGraceDays _newGraceDays)
    {
        discGraceDays = _newGraceDays;

        custPaymToSettle.data(_newPaym);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the pending settlement of the specified open transaction to the customer payment.
    /// </summary>
    /// <param name="_owningCustPaym">
    /// The payment.
    /// </param>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    public void unmarkTrans(LedgerJournalTrans _owningCustPaym, CustTransOpen _markedCustTransOpen)
    {
        int newMarkedCount;

        specTransMgr.delete(_markedCustTransOpen.company(), _markedCustTransOpen.TableId, _markedCustTransOpen.RecId);

        newMarkedCount = specTransMgr.getSpecTransCount();

        _owningCustPaym.updateMarkedInvoice(newMarkedCount);

        this.removeFromMarkedTotal(_markedCustTransOpen);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cash discount and the pending settlement of the associated open transaction.
    /// </summary>
    /// <param name="_associatedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_newDiscAmountInTransCur">
    /// The new cash discount amount in the currency of the transaction.
    /// </param>
    /// <returns>
    /// true if the discount record was updated; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The pending settlement is not required and is updated as needed.
    /// </remarks>
    public boolean updateCashDiscAmount(
        CustTransOpen _associatedCustTransOpen,
        CashDiscAmount _newDiscAmountInTransCur)
    {
        CustTrans trans;
        CustTransCashDisc cashDisc;
        AmountCur prevSettleAmountInTransCur;
        AmountCur newDiscAmountInTransCur;
        AmountCur newSettleAmountInPaymCur;
        AmountCur newSettleAmountInTransCur;
        AmountCur cashDiscAmountToTake;
        boolean isUpdated = false;

        trans = _associatedCustTransOpen.custTrans();

        newDiscAmountInTransCur = CurrencyExchange::round(_newDiscAmountInTransCur, trans.CurrencyCode);

        if ((newDiscAmountInTransCur > 0 && _associatedCustTransOpen.AmountCur < 0) ||
            (newDiscAmountInTransCur < 0 && _associatedCustTransOpen.AmountCur > 0))
        {
            // the sign of the discount can't be different than the sign of the invoice amount
            throw error("@SYS68141");
        }

        if (abs(newDiscAmountInTransCur) > abs(specTransMgr.findUnmarkedAmountForRef(
            _associatedCustTransOpen.AmountCur,
            _associatedCustTransOpen.company(),
            _associatedCustTransOpen.TableId,
            _associatedCustTransOpen.RecId)))
        {
            // the discount can't be greater than the invoice amount
            throw error("@SYS114327");
        }

        changecompany(_associatedCustTransOpen.company())
        {
            cashDisc = this.findCashDisc(_associatedCustTransOpen);

            if (cashDisc.RecId == 0)
            {
                if (abs(newDiscAmountInTransCur) > 0)
                {
                    // create a discount for the new amount
                    cashDisc = null;
                    cashDisc.CashDiscdate = custPaymToSettle.TransDate;
                    cashDisc.RefTableId = _associatedCustTransOpen.TableId;
                    cashDisc.RefRecId = _associatedCustTransOpen.RecId;
                    cashDisc.CashDiscAmount = newDiscAmountInTransCur;
                    cashDisc.insert();

                    // update the trans open for the discount
                    _associatedCustTransOpen.selectForUpdate(true);
                    _associatedCustTransOpen.PossibleCashDisc = newDiscAmountInTransCur;
                    _associatedCustTransOpen.UseCashDisc = UseCashDisc::Always;
                    _associatedCustTransOpen.update();
                    _associatedCustTransOpen.selectForUpdate(false);

                    isUpdated = true;
                }
            }
            else
            {
                // update the discount for the new amount
                cashDisc.selectForUpdate(true);
                cashDisc.CashDiscAmount = newDiscAmountInTransCur;
                cashDisc.update();

                isUpdated = true;
            }
        }

        if (this.isTransMarked(_associatedCustTransOpen))
        {
            this.removeFromMarkedTotal(_associatedCustTransOpen);

            prevSettleAmountInTransCur = this.getSettleAmount(_associatedCustTransOpen);

            // <GBR>
            if (BrazilParameters::isEnabled() &&
                (_associatedCustTransOpen.InterestAmount_BR || _associatedCustTransOpen.FineAmount_BR))
            {
                newSettleAmountInTransCur =
                    this.calcSettleAmount(_associatedCustTransOpen, _associatedCustTransOpen.AmountCur +
                                                                    _associatedCustTransOpen.InterestAmount_BR +
                                                                    _associatedCustTransOpen.FineAmount_BR -
                                                                    newDiscAmountInTransCur);
            }
            else
            {
            // </GBR>
                newSettleAmountInTransCur =
                    this.calcSettleAmount(_associatedCustTransOpen, prevSettleAmountInTransCur, true);
            // <GBR>
            }
            // </GBR>

            // get the discount to take
            cashDiscAmountToTake = this.determineCashDiscAmountToTake(_associatedCustTransOpen);

            this.updateSettleAmountCore(
                _associatedCustTransOpen,
                newSettleAmountInTransCur,cashDiscAmountToTake);

            newSettleAmountInPaymCur =
                this.convertTransAmountCurToPaymAmountCur(_associatedCustTransOpen, newSettleAmountInTransCur);

            this.addToMarkedTotal(_associatedCustTransOpen, newSettleAmountInPaymCur);
        }

        return isUpdated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cash discount amount to take associated with the specified open transaction.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to update the amount to settle.
    /// </param>
    /// <param name="_updateCashDiscToTake">
    /// The changed cash discount amount to take.
    /// </param>
    public void updateCashDiscToTake(CustTransOpen _custTransOpen, AmountCur _updateCashDiscToTake)
    {
        AmountCur cashDiscToTake;
        AmountCur settleAmount;
        CustTrans custTrans;

        if (this.isAlreadyFullyMarked(_custTransOpen) == NoYes::No)
        {
            // Round the entered amount
            custTrans = _custTransOpen.custTrans();

            _updateCashDiscToTake = CurrencyExchange::round(_updateCashDiscToTake, custTrans.CurrencyCode);

            cashDiscToTake = this.validateCashDiscAmountToTake(_custTransOpen, _updateCashDiscToTake);

            settleAmount = this.getSettleAmount(_custTransOpen);

            AmountCur remainingTransAmount = specTransMgr.findUnmarkedAmountForRef(
                _custTransOpen.AmountCur,
                _custTransOpen.company(),
                _custTransOpen.TableId,
                _custTransOpen.RecId);

            if (abs(settleAmount) > abs(remainingTransAmount - cashDiscToTake))
            {
                // Settle amount is greater than the open trans amount less the discount - adjust the discount to take
                cashDiscToTake = remainingTransAmount - settleAmount;
            }

            // The applicable discount was changed, update amounts
            this.updateSettleAmountCore(_custTransOpen,settleAmount,cashDiscToTake);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cross rate of the pending settlement to the specified open transaction.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_newCrossRate">
    /// The new cross rate.
    /// </param>
    /// <remarks>
    /// This is in the scope of the current payment.
    /// </remarks>
    public void updateCrossRate(CustTransOpen _markedCustTransOpen, CrossExchRate _newCrossRate)
    {
        AmountCur settleAmountInTransCur;
        AmountCur newTransAmountInPaymCur;
        CrossExchRate updateCrossRate;

        settleAmountInTransCur = this.getSettleAmount(_markedCustTransOpen);

        this.removeFromMarkedTotal(_markedCustTransOpen);

        updateCrossRate = CurrencyEuroDenomination::prepareExchangeRateForStorage_Static(_newCrossRate, ExchangeRateDisplayFactor::One);

        specTransMgr.updateCrossRate(
            _markedCustTransOpen.company(),
            _markedCustTransOpen.TableId,
            _markedCustTransOpen.RecId,
            updateCrossRate);

        newTransAmountInPaymCur =
            this.convertTransAmountCurToPaymAmountCur(_markedCustTransOpen, settleAmountInTransCur);

        this.addToMarkedTotal(_markedCustTransOpen, newTransAmountInPaymCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExistingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs updates for any existing pending settlements.
    /// </summary>
    /// <remarks>
    /// Use this method when the current payment changes.
    /// </remarks>
    private void updateExistingTrans()
    {
        Map markedTransList;
        MapEnumerator enumerator;
        CustTrans trans;
        CustTransOpen transOpen;
        SpecTrans spec;
        AmountCur newSettleAmountInPaymCur;
        AmountCur newSettleAmountInTransCur;
        AmountCur prevSettleAmountInTransCur;

        this.resetMarkedTotal();

        markedTransList = specTransMgr.getAllSpecTransMap();

        enumerator = new MapEnumerator(markedTransList);
        while (enumerator.moveNext())
        {
            spec = enumerator.currentValue();
            transOpen = spec.custTransOpen();
            trans = spec.custTrans();

            prevSettleAmountInTransCur = this.getSettleAmount(transOpen);

            newSettleAmountInTransCur =
                this.calcSettleAmount(transOpen, prevSettleAmountInTransCur);

            this.updateSettleAmountCore(transOpen, newSettleAmountInTransCur);

            newSettleAmountInPaymCur =
                this.convertTransAmountCurToPaymAmountCur(transOpen, newSettleAmountInTransCur);

            this.addToMarkedTotal(transOpen, newSettleAmountInPaymCur);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Fine amount and Fine Amount Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that should be updated
    /// </param>
    /// <param name="_transOpenToMark">
    /// The open transaction for which to calculate the fine amount and Fine amount Currency
    /// </param>
    /// <param name="_paymentDate">
    /// The date used to calculate the Fine amount
    /// </param>
    /// <param name="_amountCur">
    /// Amount used to calculate Fine Amount
    /// </param>
    /// <param name="_cashDiscAmount">
    /// Cash Discount Amount should be considered on Fine calculation
    /// </param>
    void updateFine_BR(
        CompanyId _refCompany,
        CustVendTransOpen _transOpenToMark,
        TransDate _paymentDate,
        AmountCur _amountCur,
        AmountCur _cashDiscAmount)

    {
        CustVendFine_BR custVendFine;
        FineCalculator_BR fineCalculator;
        AmountCur currentAmount = 0;
        CustVendTransOpenData custVendTransOpenData;
        PaymCalendarIDerivationSource calendarDerivation;

        custVendTransOpenData = CustVendTransOpenData::construct(_transOpenToMark);
        custVendFine = _transOpenToMark.CustVendTransOpen::custVendFine_BR();

        changecompany(_refCompany)
        {
            currentAmount = this.getSettleAmount( _transOpenToMark) - _transOpenToMark.FineAmount_BR - _transOpenToMark.InterestAmount_BR;
            calendarDerivation = _transOpenToMark.getCalendarDerivation_BR();

            if (_amountCur == 0
                || _transOpenToMark.UseCashDisc == UseCashDisc::Always
                || ((_transOpenToMark.AmountCur - _cashDiscAmount) == currentAmount))
            {
                fineCalculator = new FineCalculator_BR(custVendFine, _paymentDate, _transOpenToMark.DueDate, _amountCur, custVendTransOpenData.custVendTrans().CurrencyCode, calendarDerivation);
            }
            else
            {
                fineCalculator = new FineCalculator_BR(custVendFine, _paymentDate, _transOpenToMark.DueDate, currentAmount, custVendTransOpenData.custVendTrans().CurrencyCode, calendarDerivation);
            }
            // Calculating and updating fine amount
            _transOpenToMark.FineAmount_BR = fineCalculator.calculate();

            // updating FinInterest Amount Currency
            _transOpenToMark.FineAmountPaymCur_BR = this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, _transOpenToMark.FineAmount_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFineAmountPaymCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates Fine amount in Payment Transaction
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that shold be updated
    /// </param>
    /// <param name="_transOpenToMark">
    /// The open transaction for which to calculate the fine amount and Fine amount Currency
    /// </param>
    /// <param name="_fineAmount">
    /// Fine Amount used.
    /// </param>
    public void updateFineAmountPaymCur_BR(
        CompanyId _refCompany,
        CustVendTransOpen _transOpenToMark,
        FineAmount_BR _fineAmount)

    {
        CustTransCashDisc cashDisc;
        AmountCur discAmountInTransCur;
        AmountCur prevSettleAmountInTransCur;
        AmountCur newSettleAmountInPaymCur;
        AmountCur newSettleAmountInTransCur;

        if (_fineAmount < 0)
        {
            throw error("@GLS1233");
        }

        changecompany(_refCompany)
        {
            // updating FinInterest Amount
            _transOpenToMark.FineAmount_BR = _fineAmount;
            _transOpenToMark.FineAmountPaymCur_BR = this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, _fineAmount);

            cashDisc = this.findCashDisc(_transOpenToMark);
            discAmountInTransCur = cashDisc.CashDiscAmount;
        }

        if (this.isTransMarked(_transOpenToMark))
        {
            this.removeFromMarkedTotal(_transOpenToMark);

            prevSettleAmountInTransCur = this.getSettleAmount(_transOpenToMark);

            newSettleAmountInTransCur = this.calcSettleAmount(_transOpenToMark, _transOpenToMark.AmountCur + _transOpenToMark.InterestAmount_BR + _transOpenToMark.FineAmount_BR - discAmountInTransCur);

            this.updateSettleAmountCore(
                _transOpenToMark,
                newSettleAmountInTransCur);

            newSettleAmountInPaymCur = this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, newSettleAmountInTransCur);

            this.addToMarkedTotal(_transOpenToMark, newSettleAmountInPaymCur);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinInterestAmountPaymCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Interest amount in Payment Transaction
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that shold be updated
    /// </param>
    /// <param name="_transOpenToMark">
    /// The open transaction for which to calculate the fine amount and Fine amount Currency
    /// </param>
    /// <param name="_finInterestAmount">
    /// Interest Amount defined
    /// </param>
    public void updateFinInterestAmountPaymCur_BR(
        CompanyId _refCompany,
        CustVendTransOpen _transOpenToMark,
        FinInterestAmount_BR _finInterestAmount)

    {
        CustTransCashDisc cashDisc;
        AmountCur discAmountInTransCur;
        AmountCur prevSettleAmountInTransCur;
        AmountCur newSettleAmountInPaymCur;
        AmountCur newSettleAmountInTransCur;

        if (_finInterestAmount < 0)
        {
            throw error("@GLS931");
        }

        changecompany(_refCompany)
        {
            // updating FinInterest Amount Currency
            _transOpenToMark.InterestAmount_BR = _finInterestAmount;
            _transOpenToMark.InterestAmountPaymCur_BR = this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, _finInterestAmount);

            cashDisc = this.findCashDisc(_transOpenToMark);
            discAmountInTransCur = cashDisc.CashDiscAmount;
        }

        if (this.isTransMarked(_transOpenToMark))
        {
            this.removeFromMarkedTotal(_transOpenToMark);

            prevSettleAmountInTransCur = this.getSettleAmount(_transOpenToMark);

            newSettleAmountInTransCur = this.calcSettleAmount(_transOpenToMark, _transOpenToMark.AmountCur + _transOpenToMark.InterestAmount_BR + _transOpenToMark.FineAmount_BR - discAmountInTransCur);
            this.updateSettleAmountCore(
                _transOpenToMark,
                newSettleAmountInTransCur);

            newSettleAmountInPaymCur = this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, newSettleAmountInTransCur);

            this.addToMarkedTotal(_transOpenToMark, newSettleAmountInPaymCur);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterest_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Interest amount and Interest Amount Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that should be updated
    /// </param>
    /// <param name="_transOpenToMark">
    /// The open transaction for which to calculate the fine amount and Fine amount Currency
    /// </param>
    /// <param name="_paymentDate">
    /// The date used to calculate the Interest amount
    /// </param>
    /// <param name="_amountCur">
    /// Amount used to calculate the Interest Amount
    /// </param>
    /// <param name="_cashDiscAmount">
    /// Cash Discount Amount should be considered on Interest calculation
    /// The Cash Discount Date used
    /// </param>
    public void updateInterest_BR(
        CompanyId _refCompany,
        CustVendTransOpen _transOpenToMark,
        TransDate _paymentDate,
        AmountCur _amountCur,
        AmountCur _cashDiscAmount)

    {
        CustVendInterest_BR custVendFinInterest;
        InterestCalculator_Br finInterestCalculator;
        AmountCur currentAmount;
        CustVendTransOpenData custVendTransOpenData;
        PaymCalendarIDerivationSource calendarDerivation;

        custVendTransOpenData = CustVendTransOpenData::construct(_transOpenToMark);
        custVendFinInterest = _transOpenToMark.CustVendTransOpen::custVendInterest_BR();

        changecompany(_refCompany)
        {
            currentAmount = this.getSettleAmount( _transOpenToMark) - _transOpenToMark.FineAmount_BR - _transOpenToMark.InterestAmount_BR;
            calendarDerivation = _transOpenToMark.getCalendarDerivation_BR();
            if (_amountCur == 0
                || _transOpenToMark.UseCashDisc == UseCashDisc::Always
                || ((_transOpenToMark.AmountCur - _cashDiscAmount) == currentAmount))
            {
                finInterestCalculator = new InterestCalculator_Br(custVendFinInterest, _paymentDate, _transOpenToMark.DueDate, _amountCur, custVendTransOpenData.custVendTrans().CurrencyCode, calendarDerivation);
            }
            else
            {
                finInterestCalculator = new InterestCalculator_Br(custVendFinInterest, _paymentDate, _transOpenToMark.DueDate, currentAmount, custVendTransOpenData.custVendTrans().CurrencyCode, calendarDerivation);
            }

            // Calculating and updating fine amount
            _transOpenToMark.InterestAmount_BR = finInterestCalculator.calculate();

            // updating FinInterest Amount Currency
            _transOpenToMark.InterestAmountPaymCur_BR = this.convertTransAmountCurToPaymAmountCur(_transOpenToMark, _transOpenToMark.InterestAmount_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterestAndFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Interest and Fine amounts and Interest and Fine Amounts Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that should be updated
    /// </param>
    /// <param name="_transOpenToMark">
    /// The open transaction for which to calculate the interest and fine amounts
    /// </param>
    /// <param name="_paymentDate">
    /// The date used to calculate the interest and fine amounts
    /// </param>
    /// <param name="_amountCur">
    /// Amount used to calculate the interest and fine amounts
    /// </param>
    /// <param name="_cashDiscAmount">
    /// Cash Discount Amount should be considered on Interest calculation
    /// The Cash Discount Date used
    /// </param>
    public void updateInterestAndFine_BR(CompanyId _refCompany,
                                        CustVendTransOpen _transOpenToMark,
                                        TransDate _paymentDate,
                                        AmountCur _amountCur,
                                        AmountCur _cashDiscAmount)

    {
        boolean selectForUpdate;

        this.updateInterest_BR(_refCompany, _transOpenToMark, _paymentDate, _amountCur, _cashDiscAmount);
        this.updateFine_BR(_refCompany, _transOpenToMark, _paymentDate, _amountCur, _cashDiscAmount);

        selectForUpdate = _transOpenToMark.selectForUpdate();

        _transOpenToMark.selectForUpdate(true);
        _transOpenToMark.update();
        _transOpenToMark.selectForUpdate(selectForUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the amount of the pending settlement to the specified open transaction.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_newSettleAmount">
    /// The new amount of the settlement.
    /// </param>
    /// <remarks>
    /// The new settlement amount may be adjusted. This is in the scope of the current payment.
    /// </remarks>
    public void updateSettleAmount(CustTransOpen _markedCustTransOpen, AmountCur _newSettleAmount)
    {
        CustTrans trans;
        AmountCur inputSettleAmountInTransCur;
        AmountCur settleAmountInTransCur;
        AmountCur settleAmountInPaymCur;
        NoYes cashDiscForPartialPaym;
        AmountCur cashDiscAmountToTake;

        cashDiscForPartialPaym = this.findCustParameters(_markedCustTransOpen.company()).CashDiscForPartialPaym;

        this.removeFromMarkedTotal(_markedCustTransOpen);

        trans = _markedCustTransOpen.custTrans();

        inputSettleAmountInTransCur = CurrencyExchange::round(_newSettleAmount, trans.CurrencyCode);

        settleAmountInTransCur = this.calcSettleAmount(_markedCustTransOpen, inputSettleAmountInTransCur);

        cashDiscAmountToTake = this.calculatePartialApplicableCashDiscount(_markedCustTransOpen,settleAmountInTransCur);

        AmountCur remainingTransAmount = specTransMgr.findUnmarkedAmountForRef(
            _markedCustTransOpen.AmountCur,
            _markedCustTransOpen.company(),
            _markedCustTransOpen.TableId,
            _markedCustTransOpen.RecId);

        if (abs(settleAmountInTransCur) > abs(remainingTransAmount - cashDiscAmountToTake))
        {
            // Settle amount is greater than the open trans amount less the discount
            if (abs(remainingTransAmount) > abs(settleAmountInTransCur))
            {
                // adjust the cash discount to take
                cashDiscAmountToTake = remainingTransAmount - settleAmountInTransCur;
            }
            else
            {
                // adjust the settled amount
                settleAmountInTransCur = remainingTransAmount - cashDiscAmountToTake;
            }
        }

        this.updateSettleAmountCore(
            _markedCustTransOpen,
            settleAmountInTransCur,cashDiscAmountToTake);

        settleAmountInPaymCur = this.convertTransAmountCurToPaymAmountCur(_markedCustTransOpen, settleAmountInTransCur);

        this.addToMarkedTotal(_markedCustTransOpen, settleAmountInPaymCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleAmountCore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the amount of the pending settlement.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_settleAmountInTransCur">
    /// The amount of the settlement.
    /// </param>
    /// <param name="_discountAmount">
    /// The cash discount amount of the settlement.
    /// </param>
    /// <remarks>
    /// This method is in the scope of the current payment and does not update the
    /// balance.
    /// </remarks>
    private void updateSettleAmountCore(CustTransOpen _markedCustTransOpen, AmountCur _settleAmountInTransCur, AmountCur _discountAmount = 0)
    {
        specTransMgr.updateSettleBalanceAndDisc(
            _markedCustTransOpen.company(),
            _markedCustTransOpen.TableId,
            _markedCustTransOpen.RecId,
            _settleAmountInTransCur ,
            _discountAmount ,
            custPaymToSettle.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleAmountForInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the amount of the pending settlement to the specified open transaction.
    /// </summary>
    /// <param name="_markedCustTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name="_newSettleAmount">
    /// The new amount of the settlement.
    /// </param>
    /// <param name="_cashDiscAmountToTake">
    /// The cash discount amount of the settlement.
    /// </param>

    public void updateSettleAmountForInvoiceLines(CustTransOpen _markedCustTransOpen, AmountCur _newSettleAmount, AmountCur _cashDiscAmountToTake)
    {
        this.updateSettleAmountCore(
            _markedCustTransOpen,
            _newSettleAmount, _cashDiscAmountToTake);

        this.removeFromMarkedTotal(_markedCustTransOpen);
        this.addToMarkedTotal(_markedCustTransOpen, this.convertTransAmountCurToPaymAmountCur(_markedCustTransOpen, _newSettleAmount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the cash discount amount to take.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to validate.
    /// </param>
    /// <param name="_cashDiscAmountToTake">
    /// The cash discount amount to take to validate.
    /// </param>
    /// <returns>
    /// The valid cash discount amount to take.
    /// </returns>
    public CashDiscAmount validateCashDiscAmountToTake(
        CustTransOpen _custTransOpen,
        AmountCur _cashDiscAmountToTake
        )
    {
        CustVendCashDiscountHelper cashDiscountHelper;
        CashDiscAmount returnCashDiscAmountToTake = _cashDiscAmountToTake;

        cashDiscountHelper = CustVendCashDiscountHelper::construct(_custTransOpen);
        returnCashDiscAmountToTake = cashDiscountHelper.validateCashDiscToTake(_cashDiscAmountToTake);

        return returnCashDiscAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustPaymSettlementManager</c> class.
    /// </summary>
    /// <param name="_custPaym">
    /// The customer payment that owns the settlements.
    /// </param>
    /// <returns>
    /// A new instance of the <c>CustPaymSettlementManager</c> class.
    /// </returns>
    /// <remarks>
    /// Use this method when the customer payment is known.
    /// </remarks>
    public static CustPaymSettlementManager construct(LedgerJournalTrans _custPaym)
    {
        CustPaymSettlementManager manager;

        Debug::assert(_custPaym.RecId != 0);

        manager = new CustPaymSettlementManager(_custPaym);
        manager.setPaymCore(_custPaym, CustPaymModeTable::discGraceDays(_custPaym.PaymMode));
        manager.initForExistingTrans();

        return manager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustPaymSettlementManager</c> class.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>CustPaymSettlementManager</c> class.
    /// </returns>
    /// <remarks>
    /// Use this method to create an instance that will not cause null reference errors when there is no
    /// active customer payment.
    /// </remarks>
    public static CustPaymSettlementManager newForEmpty()
    {
        CustPaymSettlementManager manager;
        LedgerJournalTrans trans;

        trans.AccountType = LedgerJournalACType::Cust;
        trans.Company = curext();

        manager = new CustPaymSettlementManager(trans);
        manager.initializedWithoutCustPayment = true;

        return manager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wasInitializedWithoutCustPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>CustPaymSettlementManager</c> instance was initialized
    /// without a customer payment.
    /// </summary>
    /// <returns>
    /// true if the <c>CustPaymSettlementManager</c> instance was initialized
    /// without a customer payment; otherwise, false.
    /// </returns>
    public boolean wasInitializedWithoutCustPayment()
    {
        return initializedWithoutCustPayment;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>