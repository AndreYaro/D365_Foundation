<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsWorkTransactionType</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkTransactionType</c> class is the abstract base class for work transaction types.
/// </summary>
/// <remarks>The sub-classes must not contain any transient state, as the instance will be reused for performance reasons.</remarks>
public abstract class WhsWorkTransactionType
{
    private static SysGlobalObjectCache cache = classfactory.globalObjectCache();
    private const str cacheScope = classStr(WhsWorkTransactionType);

    WhsWorkTransType workTransType;
    boolean decrementLoadLineWorkCreatedQty;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isForShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if the work trans type is shipment related.
    /// </summary>
    /// <returns>
    /// true, if the work is of an shipment related work trans type; otherwise, false
    /// </returns>
    [Hookable(false)]
    public boolean isForShipment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLineForShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean isWorkLineForShipment(WHSWorkLine _workLine)
    {
        return this.isForShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLineForOutboundShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final boolean isWorkLineForOutboundShipment(WHSWorkLine _workLine)
    {
        return this.isOutbound() && this.isWorkLineForShipment(_workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateLPWithTargetLPForNoStopWorkLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean mustUpdateLPWithTargetLPForNoStopWorkLine(WHSWorkLine _workLine)
    {
        return this.isForOutboundShipment() && WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInbound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if the work trans type is inbound.
    /// </summary>
    /// <returns>
    /// true, if the work is of an inbound work trans type; otherwise, false
    /// </returns>
    public boolean isInbound()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForInboundShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final boolean isForInboundShipment()
    {
        return this.isInbound() && this.isForShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForExternalInboundShipment</Name>
				<Source><![CDATA[
    internal boolean isForExternalInboundShipment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeConnectedToPackingWork</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean canBeConnectedToPackingWork()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOutbound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if the work trans type is outbound.
    /// </summary>
    /// <returns>
    /// true, if the work is of an outbound work trans type; otherwise, false
    /// </returns>
    public boolean isOutbound()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForOutboundShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final boolean isForOutboundShipment()
    {
        return this.isOutbound() && this.isForShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInternalMovement</Name>
				<Source><![CDATA[
    internal boolean isInternalMovement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSerialNumberAssignmentEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isSerialNumberAssignmentEnabled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActiveInSalesSerialProcess</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isActiveInSalesSerialProcess()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlankSerialNumberAssignmentAllowed</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isBlankSerialNumberAssignmentAllowed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOverPickSupported</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isOverPickSupported()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemRelatedPicking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if the WorkTransType is not a container or whole license plate.
    /// </summary>
    /// <returns>
    /// true, if the work is related to item picking; otherwise, false
    /// </returns>
    [Hookable(false)]
    public boolean isItemRelatedPicking()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDecrementLoadLineWorkCreatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if load line work created qty will be decremented or not.
    /// </summary>
    /// <param name = "_decrementLoadLineWorkCreatedQty">true if load lines work created quantity is being decremented, otherwise, false.</param>
    /// <returns>true if the load line work created quantity should be decremented; otherwise, false.</returns>
    public boolean parmDecrementLoadLineWorkCreatedQty(boolean _decrementLoadLineWorkCreatedQty = decrementLoadLineWorkCreatedQty)
    {
        decrementLoadLineWorkCreatedQty = _decrementLoadLineWorkCreatedQty;
        return decrementLoadLineWorkCreatedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkTypeValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if a work type is valid for the transaction type.
    /// </summary>
    /// <param name = "_workType">The work type.</param>
    /// <returns>true if valid; otherwise, false.</returns>
    public boolean isWorkTypeValid(WHSWorkType _workType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReplenishmentAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if creating a replenishment link is allowed.
    /// </summary>
    /// <returns>true, if a replenishment order can be created; otherwise, false.</returns>
    public boolean isReplenishmentAllowed()
    {
        return this.isOutbound();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNegativeAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if negative quantities are allowed.
    /// </summary>
    /// <returns>true, if negative quantities are allowed; otherwise, false.</returns>
    public boolean isNegativeAllowed()
    {
        return this.isOutbound();
    }

]]></Source>
			</Method>
			<Method>
				<Name>openSourceOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Opens the form for the source order of a work.
    /// </summary>
    /// <param name="_whsWorkTable">
    ///     <c>WHSWorkTable</c> record to use to find the source record.
    /// </param>
    public void openSourceOrder(WHSWorkTable _whsWorkTable)
    {
        WHSWorkOrderInterface workOrder = WHSWorkOrderInterface::createInstanceFromBuffer(_whsWorkTable);
        this.openSourceOrderByWorkOrder(workOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openSourceOrderByWorkOrder</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public void openSourceOrderByWorkOrder(WHSWorkOrderInterface _workOrder)
    {
        str menuItemDisplayString = this.sourceOrderMenuItemDisplayStr();

        if (menuItemDisplayString)
        {
            Args args = new Args();
            MenuFunction menuFunction = new MenuFunction(menuItemDisplayString, MenuItemType::Display);
            args.record(this.findSourceOrderByWorkOrder(_workOrder));
            menuFunction.run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceOrderMenuItemDisplayStr</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public str sourceOrderMenuItemDisplayStr()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSourceOrderByWorkOrder</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public Common findSourceOrderByWorkOrder(WHSWorkOrderInterface _workOrder)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSourceOrderLineByInventTransId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public Common findSourceOrderLineByInventTransId(InventTransId _inventTransId)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowingAssigningTargetLPForHandledByLP</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isAllowingAssigningTargetLPForHandledByLP()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWholeLPWithChildrenPrevented</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isWholeLPWithChildrenPrevented()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateConsolidationSupported</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isLicensePlateConsolidationSupported()
    {
        return this.isForOutboundShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveAccountNumber</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean canHaveAccountNumber()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canMoveReservationFromWorkLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean canMoveReservationFromWorkLine()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkSplittingAllowed</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isWorkSplittingAllowed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAutoReallocationSupported</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isAutoReallocationSupported()
    {
        return WHSWorkLineAutoReallocatorBase::isWorkTransTypeSupported(workTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isManualReallocationSupported</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isManualReallocationSupported()
    {
        return WHSWorkLineManualReallocatorBase::isWorkTransTypeSupported(workTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateSpecificReservationRequired</Name>
				<Source><![CDATA[
    internal boolean isLicensePlateSpecificReservationRequired()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInboundClusterSupported</Name>
				<Source><![CDATA[
    internal boolean isInboundClusterSupported()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLocDirCodeForWorkTemplateLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the location directive code on a work template line.
    /// </summary>
    /// <param name = "_templateLine">The template line.</param>
    /// <param name = "_isLastLine">true for the last line in the template; otherwise, false.</param>
    /// <returns>An error message, when invalid; otherwise, an empty string.</returns>
    public WHSWorkTemplateErrorText validateLocDirCodeForWorkTemplateLine(WHSWorkTemplateLine _templateLine, boolean _isLastLine)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFinalPutLocationRequirements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that all requirements are met by the location for a final put work line.
    /// </summary>
    /// <param name="_location">The location to validate.</param>
    /// <param name="_locationProfile">location profile of the location being validated.</param>
    /// <returns>An error message, when invalid; otherwise, an empty string.</returns>
    public WHSMessage validateFinalPutLocationRequirements(
        WMSLocation         _location,
        WHSLocationProfile  _locationProfile)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a work.
    /// </summary>
    /// <param name = "_workTable">The work to cancel.</param>
    /// <param name = "_cancellingProductReceipt">true if product receipt is being cancelled; otherwise, false.</param>
    public void cancelWork(WHSWorkTable _workTable, boolean _cancellingProductReceipt)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustContainerLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ajust the container lines for the workline.
    /// </summary>
    /// <param name = "_workLine">The workline to cancel.</param>
    /// <param name = "_inventQty">The quantity to cancel.</param>
    [Hookable(false)]
    internal void adjustContainerLine(WHSWorkLine _workLine, InventQty _inventQty)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWorkLineQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a quantity for a work line.
    /// </summary>
    /// <param name = "_workLine">The work line.</param>
    /// <param name = "_inventQty">The quantity to cancel.</param>
    public void cancelWorkLineQuantity(WHSWorkLine _workLine, Qty _inventQty)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>locationDirectiveQueryName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the default query to use for location directives.
    /// </summary>
    /// <param name = "_whsLocDirTable">The location directive.</param>
    /// <returns>The name of the query.</returns>
    public QueryName locationDirectiveQueryName(WHSLocDirTable _whsLocDirTable)
    {
        throw error(strFmt("@WAX1705", workTransType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTemplateQueryName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the default query to use for work templates.
    /// </summary>
    /// <param name = "_whsWorkTemplateTable">The work template.</param>
    /// <returns>The name of the query.</returns>
    public QueryName workTemplateQueryName(WHSWorkTemplateTable _whsWorkTemplateTable)
    {
        throw error(strFmt("@WAX1705", workTransType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderLineNumFromInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the order line number for an inventory transaction id.
    /// </summary>
    /// <param name = "_inventTransId">The inventory transaction id.</param>
    /// <returns>The order line number.</returns>
    public LineNum findOrderLineNumFromInventTransId(InventTransId _inventTransId)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the corresponding <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name = "_inventTransId">The inventory transaction id.</param>
    /// <returns>The inventory transaction origin.</returns>
    public InventTransOrigin findInventTransOrigin(InventTransId _inventTransId)
    {
        if (this.hasInventTransOrigin())
        {
            return InventTransOrigin::findByInventTransId(_inventTransId);
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes if the transaction type has a corresponding inventory transaction origin record.
    /// </summary>
    /// <returns>true if the transaction type has a corresponding inventory transaction origin record; otherwise, false.</returns>
    protected boolean hasInventTransOrigin()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workExecuteMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the work executed mode.
    /// </summary>
    /// <param name="_hasTargetLicensePlate">
    /// true if the work has a target license plate; otherwise, false.
    /// </param>
    /// <returns>
    /// The work execute mode.
    /// </returns>
    WHSWorkExecuteMode workExecuteMode(boolean _hasTargetLicensePlate)
    {
        throw error(strFmt("@WAX1705", workTransType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationDirectiveQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the LocationDirective query based on the work trans type.
    /// </summary>
    /// <param name="_parameters">The location directive query parameters.</param>
    public void buildLocationDirectiveQuery(WhsLocationDirectiveTableQueryParameters _parameters)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationDirectiveQuerySingleOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the LocationDirective query for single order scope based on the work trans type.
    /// </summary>
    /// <param name="_parameters">The location directive query parameters.</param>
    public void buildLocationDirectiveQuerySingleOrder(WhsLocationDirectiveTableQueryParameters _parameters)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleOrderLocationDirectiveScopeSupported</Name>
				<Source><![CDATA[
    protected internal boolean isSingleOrderLocationDirectiveScopeSupported()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFromName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the from-name for a license plate label.
    /// </summary>
    /// <param name = "_whsWorkTable">The work associated with the label.</param>
    /// <param name = "_label">The license plate label</param>
    /// <returns>The from-name.</returns>
    public WHSFromName findFromName(WhsWorkTable _whsWorkTable, WHSLicensePlateLabel _label)
    {
        return InventLocation::find(_whsWorkTable.InventLocationId).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findToName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the to-name for a license plate label.
    /// </summary>
    /// <param name = "_whsWorkTable">The work associated with the label.</param>
    /// <param name = "_label">The license plate label</param>
    /// <returns>The to-name.</returns>
    public WHSFromName findToName(WhsWorkTable _whsWorkTable, WHSLicensePlateLabel _label)
    {
        return _label.AccountName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the customer purchase order number for a license plate label.
    /// </summary>
    /// <param name = "_label">The license plate label</param>
    /// <returns>The purchase order number.</returns>
    public CustPurchaseOrder findCustPurchaseOrder(WHSLicensePlateLabel _label)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAccountNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the account number for a work.
    /// </summary>
    /// <param name = "_whsWorkTable">The work header table.</param>
    /// <param name = "_whsWorkLine">The work line table.</param>
    /// <returns>The account number if found; otherwise, an empty string.</returns>
    public AccountNum findAccountNum(WhsWorkTable _whsWorkTable, WhsWorkLine _whsWorkLine)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAccountName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the account name for an account number.
    /// </summary>
    /// <param name = "_accountNum">The account number.</param>
    /// <returns>The account name if found; otherwise, an empty string.</returns>
    public AccountName findAccountName(AccountNum _accountNum)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFromAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the from-address for a license plate label.
    /// </summary>
    /// <param name = "_whsWorkTable">The work associated with the label.</param>
    /// <param name = "_label">The license plate label</param>
    /// <returns>The from-address.</returns>
    public LogisticsPostalAddress findFromAddress(WhsWorkTable _whsWorkTable, WHSLicensePlateLabel _label)
    {
        InventSite inventSite = InventSite::find(_whsWorkTable.InventSiteId);
        return LogisticsPostalAddress::findByLocation(LogisticsLocation::find(InventSite::getLocationFromRole(inventSite.RecId, LogisticsLocationRoleType::Delivery)).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findToAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the to-address for a license plate label.
    /// </summary>
    /// <param name = "_whsWorkTable">The work associated with the label.</param>
    /// <param name = "_label">The license plate label</param>
    /// <returns>The to-address.</returns>
    public LogisticsPostalAddress findToAddress(WhsWorkTable _whsWorkTable, WHSLicensePlateLabel _label)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkCenterLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the work center location for a work.
    /// </summary>
    /// <param name = "_whsWorkTable">The work associated with the label.</param>
    /// <returns>The work center location id.</returns>
    public WMSLocationId findWorkCenterLocationId(WhsWorkTable _whsWorkTable)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderedAndRemainQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ordered and remaining quantity for a work.
    /// </summary>
    /// <param name = "_whsWorkTable">The work header table.</param>
    /// <param name = "_whsWorkLine">The work line table.</param>
    /// <returns>A container with the two quantities.</returns>
    public container findOrderedAndRemainQty(WhsWorkTable _whsWorkTable, WhsWorkLine _whsWorkLine)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>expectedSerialNumberQty</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public InventQty expectedSerialNumberQty(WhsWorkLine _whsWorkLine)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the quantity being over picked is within the acceptable overdelivery range.
    /// </summary>
    /// <param name="_workLine">The work line that is being overpicked.</param>
    /// <param name="_overpickInventQty">The additional quantity to be over picked.</param>
    /// <returns>
    /// true if the quantity is within an acceptable range; otherwise, an exception is thrown.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the validateShippingOverpick method. Extenders should move their logic to wrap or override the validateShippingOverpickHandlingQuantity method.', false, 30\9\2019)]
    public boolean validateShippingOverpickQty(WHSWorkLine _workLine, InventQty _overpickInventQty)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the item is a warehouse enabled catch weight item and calling the relevant shipping overpick quantity validation.
    /// </summary>
    /// <param name="_workLine">The work line that is being overpicked.</param>
    /// <param name="_overpickInventHandlingQty">The additional quantity in the handling unit to be over picked.</param>
    /// <returns>
    /// True if the handling quantity is within an acceptable range; otherwise, an exception is thrown.
    /// </returns>
    [Hookable(false)]
    final public boolean validateShippingOverpick(WHSWorkLine _workLine, InventHandlingQty _overpickInventHandlingQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _workLine.ItemId))
        {
            return this.validateShippingOverpickHandlingQuantity(_workLine, _overpickInventHandlingQty);
        }

        return this.validateShippingOverpickQty(_workLine, _overpickInventHandlingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateShippingOverpickHandlingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if a shipping overpick is possible from the handling quantity.
    /// </summary>
    /// <param name = "_workLine">The work line to be checked.</param>
    /// <param name = "_overpickInventHandlingQty">The quantity in the handling unit that is being overpicked.</param>
    /// <returns>
    /// true if the handling quantity is within an acceptable range; otherwise, an exception is thrown.
    /// </returns>
    /// <remarks>
    /// The method is an extension and is not meant to be called directly. Callers should call the validateShippingOverpick method.
    /// </remarks>
    [Wrappable(true)]
    protected boolean validateShippingOverpickHandlingQuantity(
        WHSWorkLine         _workLine,
        InventHandlingQty   _overpickInventHandlingQty)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInitialPickDimTrackingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the initial picking dimension tracking records when executing a work.
    /// </summary>
    /// <param name = "_workTable">The work to insert the tracking records for.</param>
    /// <param name = "_workLine">The work line to insert the tracking records for.</param>
    /// <param name = "_workInventTrans">The work transaction to insert the tracking records for.</param>
    /// <param name = "_inventDim">The below location dimension set used for picking.</param>
    /// <param name = "_usedDimQuantities">A map with the dimension quantities used.</param>
    /// <param name = "_itemId2FieldIdList">A cache list of fields for items.</param>
    public void insertInitialPickDimTrackingRecords(
        WHSWorkTable        _workTable,
        WHSWorkLine         _workLine,
        WHSWorkInventTrans  _workInventTrans,
        InventDim           _inventDim,
        Map                 _usedDimQuantities,
        Map                 _itemId2FieldIdList)
    {
        InventDim inventDimCriteria = this.initInitialPickDimTrackingInventDim(
            _workLine,
            _workInventTrans,
            _inventDim,
            _itemId2FieldIdList);

        this.createDimTrackingRecordsAndUpdateUsedDimHandlingQty(
            _workInventTrans.ItemId,
            _workInventTrans.InventQtyRemain,
            _workInventTrans.RemainingTransactionWeight,
            _workInventTrans.InventTransIdParent,
            _workLine,
            _workTable.workTransType,
            inventDimCriteria,
            _usedDimQuantities);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInitialPickDimTrackingInventDim</Name>
				<Source><![CDATA[
    protected InventDim initInitialPickDimTrackingInventDim(
        WHSWorkLine         _workLine,
        WHSWorkInventTrans  _workInventTrans,
        InventDim           _inventDim,
        Map                 _itemId2FieldIdList)
    {
        List fieldIdList;

        if (_itemId2FieldIdList.exists(_workInventTrans.ItemId))
        {
            fieldIdList = _itemId2FieldIdList.lookup(_workInventTrans.ItemId);
        }
        else
        {
            WHSReservationHierarchyProvider reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();

            List hierarchyList = reservationHierarchyProvider.getDimListBelowLocation(InventTable::find(_workInventTrans.ItemId), WHSReservationHierarchySortOrder::BottomUp);

            //check flexible dimensions and remove from the List flexible dimension. It remains the _workInventTrans.InventDimIdFrom dimensions.
            if (_workLine.OrderCommittedInventDimId)
            {
                hierarchyList = WHSReservationHierarchyProvider::removeFlexibleDimensions(hierarchyList, _workLine.ItemId);
            }

            fieldIdList = WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(hierarchyList);

            _itemId2FieldIdList.insert(_workInventTrans.ItemId, fieldIdList);
        }

        InventDim inventDimCriteria = InventDim::find(_workInventTrans.InventDimIdFrom);
        inventDimCriteria.initFromInventDim(_inventDim, fieldIdList);

        return inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingRecordsAndUpdateUsedDimHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create <c>WHSDimTracking</c> records and update with the correct quantities.
    /// </summary>
    /// <param name="_itemId">
    /// The item identifier.
    /// </param>
    /// <param name="_handlingQtyRemain">
    /// The quantity remaining in the handling unit.
    /// </param>
    /// <param name="_transWeightRemaining">
    /// The weight remaining on the work line. Only will be populated for warehouse enabled
    /// catch weight items.
    /// </param>
    /// <param name="_inventTransId">
    /// The item identifier.
    /// </param>
    /// <param name="_workLine">
    /// The quantity remaining in the handling unit.
    /// </param>
    /// <param name="_workTransType">
    /// The work transaction type of the work header that the dim tracking records are created against.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria for locating reservations.
    /// </param>
    /// <param name="_usedDimQuantities">
    /// Retains the the quantities that have already been consumed during the calling process.
    /// </param>
    protected void createDimTrackingRecordsAndUpdateUsedDimHandlingQty(
        ItemId              _itemId,
        InventHandlingQty   _handlingQtyRemain,
        WHSTransWeight      _transWeightRemaining,
        InventTransId       _inventTransId,
        WHSWorkLine         _workLine,
        WHSWorkTransType    _workTransType,
        InventDim           _inventDimCriteria,
        Map                 _usedDimQuantities)
    {
        this.createDimTrackingRecordsAndUpdateUsedDimHandlingQuantities(_itemId,
            _handlingQtyRemain,
            _transWeightRemaining,
            _inventTransId,
            _workLine,
            _workTransType,
            _inventDimCriteria,
            _usedDimQuantities,
            PdsGlobal::pdsIsCWItem(_itemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingRecordsAndUpdateUsedDimHandlingQuantities</Name>
				<Source><![CDATA[
    private void createDimTrackingRecordsAndUpdateUsedDimHandlingQuantities(
        ItemId              _itemId,
        InventHandlingQty   _handlingQtyRemain,
        WHSTransWeight      _transWeightRemaining,
        InventTransId       _inventTransId,
        WHSWorkLine         _workLine,
        WHSWorkTransType    _workTransType,
        InventDim           _inventDimCriteria,
        Map                 _usedDimQuantities,
        boolean             _useCWAsHandlingQty)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _itemId, _handlingQtyRemain, _transWeightRemaining);

        List reservationHiearchyListAllFields = WHSreservationHierarchyProvider::construct().getDimListAllFromInventTable(
                                                                inventTable::find(_itemId),
                                                                WHSReservationHierarchySortOrder::BottomUp);

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(_inventDimCriteria);

        InventSerialIdFlag inventSerialIdFlag = NoYes::No;
 
        if (!_inventDimCriteria.inventSerialId
            && !this.isWorkExecutedManually()
            && WhsWorkExecuteDisplay::isBlanksSerialNumberAssignmentAllowed(_workLine, _itemId)
            && WHSInventOnHand::getWorkPhysicalInventHandlingQty(_itemId, _inventDimCriteria.InventDimId) > _handlingQtyRemain
            && this.hasMultipleDimensionValues(_inventDimCriteria, fieldNum(InventDim, inventSerialId), _itemId))
        {
            inventSerialIdFlag = NoYes::Yes;
        }

        if (!_inventDimCriteria.InventGtdId_RU
            && WHSInvent::isGTDNumberOptional(_itemId)
            && WHSInventOnHand::getWorkPhysicalInventHandlingQty(_itemId, _inventDimCriteria.InventDimId) > _handlingQtyRemain
            && this.hasMultipleDimensionValues(_inventDimCriteria, fieldNum(InventDim, InventGTDId_RU), _itemId))
        {
            inventDimParm.InventGTDIdFlag_RU = NoYes::Yes;
        }

        InventHandlingQty handlingQtyRemain = _handlingQtyRemain;

        boolean includeDeltaRecords = InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId);

        InventSumUnionDeltaPhysicalQty inventSumUnionDeltaPhysicalQty;
        InventDim inventDim;

        CreatedTransactionId inventUpdateTtsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
        WHSReservationHierarchyLevel reservationLevel = WHSInventReserve::find(_itemId, _inventDimCriteria.inventDimId).HierarchyLevel;
        WHSReservationHierarchyLevel deltaReservationLevel = WHSInventReserveDelta::findHierachyLevelFromInventDim(inventUpdateTtsId, _itemId, _inventDimCriteria.inventDimId);
        
        SysDaQueryObject inventSumUnionDeltaPhysicalQtyQuery = this.buildInventSumUnionDeltaPhysicalQtyQuery(
                                                                        inventDim,
                                                                        inventSumUnionDeltaPhysicalQty,
                                                                        _inventDimCriteria,
                                                                        inventDimParm,
                                                                        _itemId,
                                                                        inventSerialIdFlag);

        var querySearchObject    = new SysDaSearchObject(inventSumUnionDeltaPhysicalQtyQuery);
        var querySearchStatement = new SysDaSearchStatement();

        while (querySearchStatement.findNext(querySearchObject) && handlingQtyRemain > 0)
        {
            [handlingQtyRemain, reservationLevel] = this.createDimTrackingRecords(handlingQtyRemain,
                                                            inventSumUnionDeltaPhysicalQty,
                                                            includeDeltaRecords,
                                                            _itemId,
                                                            inventDim,
                                                            true,
                                                            reservationLevel,
                                                            deltaReservationLevel,
                                                            _workTransType,
                                                            _useCWAsHandlingQty,
                                                            _transWeightRemaining,
                                                            _workLine,
                                                            _usedDimQuantities,
                                                            _inventTransId,
                                                            reservationHiearchyListAllFields);
        }       
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventSumUnionDeltaPhysicalQtyQuery</Name>
				<Source><![CDATA[
    private SysDaQueryObject buildInventSumUnionDeltaPhysicalQtyQuery(
        InventDim _inventDim,
        InventSumUnionDeltaPhysicalQty _inventSumUnionDeltaPhysicalQty,
        InventDim _inventDimCriteria,
        InventDimParm _inventDimParm,
        ItemId _itemId,
        InventSerialIdFlag _inventSerialIdFlag)
    {
        SysDaQueryObject inventSumUnionDeltaPhysicalQtyQuery = new SysDaQueryObject(_inventSumUnionDeltaPhysicalQty);
        
        SysDaQueryObject inventDimQuery = InventDimQueryBuilder::newFromQuery(_inventDim, _inventDimCriteria, _inventDimParm)
            .joinClause(new SysDaFieldExpression(_inventSumUnionDeltaPhysicalQty, fieldStr(InventSumUnionDeltaPhysicalQty, InventDimId)));

        inventSumUnionDeltaPhysicalQtyQuery.joinClause(
            SysDaJoinKind::InnerJoin,
            inventDimQuery);

        // We order by serial to favor blank serials over non-blanks. This is to support scenarios where the blank serial is being picked.
        if (_inventSerialIdFlag)
        {
            inventDimQuery.orderByClause(new SysDaOrderBys().add(fieldStr(InventDim, inventSerialId)));
        }

        SysDaEqualsExpression equalsExpression = new SysDaEqualsExpression(
            new SysDaFieldExpression(_inventSumUnionDeltaPhysicalQty, fieldStr(InventSumUnionDeltaPhysicalQty, ItemId)),
            new SysDaValueExpression(_itemId));

        SysDaGreaterThanExpression greaterThanExpression = new SysDaGreaterThanExpression(
            new SysDaFieldExpression(_inventSumUnionDeltaPhysicalQty, fieldStr(InventSumUnionDeltaPhysicalQty, PhysicalInvent)),
            new SysDaValueExpression(0));

        SysDaAndExpression andExpression = new SysDaAndExpression(equalsExpression, greaterThanExpression);

        inventSumUnionDeltaPhysicalQtyQuery.whereClause(andExpression);
        
        return inventSumUnionDeltaPhysicalQtyQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimTrackingRecords</Name>
				<Source><![CDATA[
    private container createDimTrackingRecords(InventHandlingQty _handlingQtyRemain,
        InventSumUnionDeltaPhysicalQty _inventSumUnionDeltaPhysicalQty,
        boolean _includeDeltaRecords,
        ItemId _itemId,
        InventDim _inventDim,
        boolean _shouldTakeInventReserveDeltaReservationLevel,
        WHSReservationHierarchyLevel _reservationLevel,
        WHSReservationHierarchyLevel _deltaReservationLevel,
        WHSWorkTransType _workTransType,
        boolean _useCWAsHandlingQty,
        WHSTransWeight _transWeightRemaining,
        WHSWorkLine _workLine,
        Map _usedDimQuantities,
        InventTransId _inventTransId,
        List _reservationHiearchyListAllFields)
    {
        // By looping through the physical inventory we get the dimensions on the deepest level in the hierarchy since this is where the actual on-hand is.
        // We need to take reservations into account.
        // We need to determine whether the caller has a reservations above the deepest level,
        // If yes, we can apply the available for reservation physical qty from deepest level in the hierarchy.
        // Otherwise, we just need to apply the physical qty, instead of getting available for reservation physical qty to avoid conflicting with the callers own reservations.
        WHSReservationHierarchyLevel deepestLevel = WHSReservationHierarchyInventDimUtil::deepestLevelFromInventDimParm(_reservationHiearchyListAllFields, _inventDim.toDimParm());

        InventHandlingQty   availHandlingQty;
        WHSTransWeight      transWeight;

        // There are scenarios where the data in the WSHInventReserveDelta is not yet merged with the data in WHSInventReserve.
        // If the reservation level in the WHSInventReserve is not the deepestLevel, we want to take the hierarchy level from the WHSInventReserveDelta too,
        // as we may have a reservation at deepest level there.
        if (_reservationLevel != deepestLevel
                && _workTransType == WHSWorkTransType::Purch
                && _shouldTakeInventReserveDeltaReservationLevel)
        {
            _reservationLevel = _deltaReservationLevel;
        }

        // Apply the physical qty if reservations are on the deepest level or caller is the return order which does not have reservations.
        if (deepestLevel == _reservationLevel
                || (_reservationLevel == 0
                    && _workTransType == WHSWorkTransType::ReturnOrder))
        {
            if (_useCWAsHandlingQty)
            {
                availHandlingQty = _inventSumUnionDeltaPhysicalQty.PdsCWPhysicalInvent;
                transWeight      = _inventSumUnionDeltaPhysicalQty.PhysicalInvent;
            }
            else
            {
                availHandlingQty = _inventSumUnionDeltaPhysicalQty.PhysicalInvent;
                transWeight      = _transWeightRemaining;
            }
        }
        else
        {
            WHSInventReserveQuantities inventReserveQuantities
                    = WHSInventOnHand::getAvailQuantitiesForLevel(_itemId,
                                        _inventDim,
                                        deepestLevel,
                                        _includeDeltaRecords);

            if (_useCWAsHandlingQty)
            {
                availHandlingQty    = inventReserveQuantities.CWAvailPhysical;
                transWeight         = inventReserveQuantities.AvailPhysical;
            }
            else
            {
                availHandlingQty    = inventReserveQuantities.AvailPhysical;
            }
        }

        if (availHandlingQty <= 0)
        {
            return [_handlingQtyRemain, _reservationLevel];
        }

        // If the disposition code specified on the batch prevents picking, we must throw an error during dim tracking record creation.
        if (_workLine.WorkType  == WHSWorkType::Pick
                &&  _inventDim.InventBatchId
                &&  !InventBatch::find(_inventDim.InventBatchId, _itemId).validateBatchDispCodeForPicking(_workTransType))
        {
            throw error(strFmt("@WAX5580", _inventDim.InventBatchId));
        }

        str hashKey = strFmt('%1,%2', _inventSumUnionDeltaPhysicalQty.ItemId, _inventSumUnionDeltaPhysicalQty.InventDimId);

        InventQty usedQty;

        if (_usedDimQuantities.exists(hashKey))
        {
            usedQty = _usedDimQuantities.lookup(hashKey);
        }
        else
        {
            usedQty = 0;
        }

        if (availHandlingQty - usedQty > 0)
        {
            WHSDimTracking dimTracking = this.initializeDimensionTracking(
                                                        _workLine,
                                                        _inventTransId,
                                                        _inventSumUnionDeltaPhysicalQty.InventDimId,
                                                        min(availHandlingQty - usedQty, _handlingQtyRemain));

            if (_useCWAsHandlingQty)
            {
                //  If we are moving the full inventory qty for a catch weight item then we should use inventory weight when moving the item around.
                if (availHandlingQty == dimTracking.Qty)
                {
                    dimTracking.CapturedWeight = transWeight;
                }
                else
                {
                    // Else calculate the weight based off inventory values.
                    dimTracking.CapturedWeight = WHSCatchWeightHelper::calculateMovingWeight(_itemId, dimTracking.InventDimId, dimTracking.Qty);
                }
            }

            dimTracking.insert();

            _usedDimQuantities.insert(hashKey, usedQty + dimTracking.Qty);

            _handlingQtyRemain -= dimTracking.Qty;
        }

        return [_handlingQtyRemain, _reservationLevel];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlankSerialNotAllowed</Name>
				<Source><![CDATA[
    private static boolean isBlankSerialNotAllowed(InventDim _inventDimCriteria, ItemId _itemId)
    {
        return _inventDimCriteria.inventSerialId
            || !WhsInvent::isSerialNumberOptional(_itemId)
            || WHSInventTable::captureSerial(_itemId) != WHSRFWhenToCapture::Receiving;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumDenormalizedInventDimCriteriaHasMultipleValues</Name>
				<Source><![CDATA[
    private static boolean inventSumDenormalizedInventDimCriteriaHasMultipleValues(InventDim _inventDimCriteria, FieldId _dimFieldId, ItemId _itemId)
    {
        InventSum inventSum;
        SysDaNotEqualsExpression notEmptyExpression;
        FieldId denormalizedFieldId = InventDim::getInventSumFieldIdFromInventDimFieldId(_dimFieldId);
        
        SysDaQueryObject inventSumDenormalizedInventDimCriteria = new SysDaQueryObject(inventSum);
        SysDaGroupBys groupBy = new SysDaGroupBys();
        groupBy.add(fieldId2Name(tableNum(InventSum), denormalizedFieldId));
        inventSumDenormalizedInventDimCriteria.groupByClause(groupBy);

        inventSumDenormalizedInventDimCriteria.firstOnlyHint = SysDaFirstOnlyHint::FirstOnly10;

        if (_dimFieldId != fieldNum(InventDim, InventSerialId)
            || WhsWorkTransactionType::isBlankSerialNotAllowed(_inventDimCriteria, _itemId))
        {
            notEmptyExpression = new SysDaNotEqualsExpression(
                new SysDaFieldExpression(inventSum, fieldId2Name(tableNum(InventSum), denormalizedFieldId)),
                new SysDaValueExpression(SysQuery::valueEmptyString()));
        }

        SysDaEqualsExpression itemExpression = new SysDaEqualsExpression(
            new SysDaFieldExpression(inventSum, fieldStr(InventSum, ItemId)),
            new SysDaValueExpression(_itemId));

        SysDaGreaterThanExpression physicalInventGreaterThanZeroExpression;
        boolean isCW = PdsGlobal::pdsIsCWItem(_itemId);
        
        if (isCW)
        {
            physicalInventGreaterThanZeroExpression = new SysDaGreaterThanExpression(
                new SysDaFieldExpression(inventSum, fieldStr(InventSum, PdsCWPhysicalInvent)),
                new SysDaValueExpression(0));
        }
        else
        {
            physicalInventGreaterThanZeroExpression = new SysDaGreaterThanExpression(
                new SysDaFieldExpression(inventSum, fieldStr(InventSum, PhysicalInvent)),
                new SysDaValueExpression(0));
        }

        SysDaEqualsExpression closedQtyExpression = new SysDaEqualsExpression(
            new SysDaFieldExpression(inventSum, fieldStr(InventSum, ClosedQty)),
            new SysDaValueExpression(enum2int(NoYes::No)));

        SysDaAndExpression andExpression = new SysDaAndExpression(itemExpression, physicalInventGreaterThanZeroExpression);
        andExpression = new SysDaAndExpression(andExpression, closedQtyExpression);
        
        if (notEmptyExpression)
        {
            andExpression = new SysDaAndExpression(andExpression, notEmptyExpression);
        }

        SysDaBinaryExpression inventDimCriteriaRange = InventDim::buildRangeCriteriaToTableWithDimFields(inventSum, _inventDimCriteria, InventDim::dimFieldsList(), false);

        if (inventDimCriteriaRange)
        {
            andExpression = new SysDaAndExpression(andExpression, inventDimCriteriaRange);
        }

        inventSumDenormalizedInventDimCriteria.whereClause(andExpression);

        var querySearchObject    = new SysDaSearchObject(inventSumDenormalizedInventDimCriteria);
        var querySearchStatement = new SysDaSearchStatement();

        int counter = 0;
        while (querySearchStatement.findNext(querySearchObject))
        {
            counter++;

            if (counter > 1)
            {
                break;
            }
        }

        return counter > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumWithDeltaDenormalizedInventDimCriteriaHasMultipleValues</Name>
				<Source><![CDATA[
    private static boolean inventSumWithDeltaDenormalizedInventDimCriteriaHasMultipleValues(InventDim _inventDimCriteria, FieldId _dimFieldId, ItemId _itemId)
    {
        InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumView;
        SysDaNotEqualsExpression notEmptyExpression;
        
        FieldId denormalizedFieldId = InventDim::getInventSumInventDimUnionDeltaInventDimPhysicalQtyFieldIdFromInventDimFieldId(_dimFieldId);

        SysDaQueryObject inventSumWithDeltaDenormalizedInventDimCriteria = new SysDaQueryObject(inventSumView);
        SysDaGroupBys groupBy = new SysDaGroupBys();
        groupBy.add(fieldId2Name(tableNum(InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty), denormalizedFieldId));
        inventSumWithDeltaDenormalizedInventDimCriteria.groupByClause(groupBy);

        inventSumWithDeltaDenormalizedInventDimCriteria.firstOnlyHint = SysDaFirstOnlyHint::FirstOnly10;

        if (_dimFieldId != fieldNum(InventDim, InventSerialId)
            || WhsWorkTransactionType::isBlankSerialNotAllowed(_inventDimCriteria, _itemId))
        {
            notEmptyExpression = new SysDaNotEqualsExpression(
                new SysDaFieldExpression(inventSumView, fieldId2Name(tableNum(InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty), denormalizedFieldId)),
                new SysDaValueExpression(SysQuery::valueEmptyString()));
        }

        SysDaEqualsExpression itemExpression = new SysDaEqualsExpression(
            new SysDaFieldExpression(inventSumView, fieldStr(InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty, ItemId)),
            new SysDaValueExpression(_itemId));

        SysDaGreaterThanExpression physicalInventGreaterThanZeroExpression;
        boolean isCW = PdsGlobal::pdsIsCWItem(_itemId);
        
        if (isCW)
        {
            physicalInventGreaterThanZeroExpression = new SysDaGreaterThanExpression(
                new SysDaFieldExpression(inventSumView, fieldStr(InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty, PdsCWPhysicalInvent)),
                new SysDaValueExpression(0));
        }
        else
        {
            physicalInventGreaterThanZeroExpression = new SysDaGreaterThanExpression(
                new SysDaFieldExpression(inventSumView, fieldStr(InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty, PhysicalInvent)),
                new SysDaValueExpression(0));
        }

        SysDaAndExpression andExpression = new SysDaAndExpression(itemExpression, physicalInventGreaterThanZeroExpression);
        
        if (notEmptyExpression)
        {
            andExpression = new SysDaAndExpression(andExpression, notEmptyExpression);
        }

        SysDaBinaryExpression inventDimCriteriaRange = InventDim::buildRangeCriteriaToTableWithDimFields(inventSumView, _inventDimCriteria, InventDim::dimFieldsList(), false);

        if (inventDimCriteriaRange)
        {
            andExpression = new SysDaAndExpression(andExpression, inventDimCriteriaRange);
        }

        inventSumWithDeltaDenormalizedInventDimCriteria.whereClause(andExpression);

        var querySearchObject    = new SysDaSearchObject(inventSumWithDeltaDenormalizedInventDimCriteria);
        var querySearchStatement = new SysDaSearchStatement();

        int counter = 0;
        while (querySearchStatement.findNext(querySearchObject))
        {
            counter++;

            if (counter > 1)
            {
                break;
            }
        }

        return counter > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMultipleDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if for specified dim criteria there is more than one value for a inventory dimension field in physical inventory.
    /// </summary>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria.
    /// </param>
    /// <param name="_dimFieldId">
    /// The inventory dimension field being evaluated for multiple values in inventory.
    /// </param>
    /// <param name="_itemId">
    /// The Id of the item which we are trying determine if inventory allows defaulting of the next dimension.
    /// </param>
    /// <returns>
    /// Return true if there is only a single value based on the query.
    /// </returns>
    private boolean hasMultipleDimensionValues(
        InventDim   _inventDimCriteria,
        FieldId     _dimFieldId,
        ItemId      _itemId)
    {
        InventDim               inventDim;
        InventDim               returnDim;
        Query                   query;
        QueryBuildDataSource    qbds;
        QueryRun                queryRun;
        Counter                 i;

        if (WhsWorkTransactionType::shouldUseDenormalizedView())
        {
            if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId))
            {
                return WhsWorkTransactionType::inventSumWithDeltaDenormalizedInventDimCriteriaHasMultipleValues(_inventDimCriteria, _dimFieldId, _itemId);
            }

            return WhsWorkTransactionType::inventSumDenormalizedInventDimCriteriaHasMultipleValues(_inventDimCriteria, _dimFieldId, _itemId);
        }
        else
        {
            query = new Query();
            qbds = query.addDataSource(tableNum(InventDim));
            qbds.addGroupByField(_dimFieldId);
            InventDim::queryAddRangeCriteria(qbds, _inventDimCriteria);

            if (_dimFieldId != fieldNum(InventDim, InventSerialId)
            || _inventDimCriteria.inventSerialId
            || !WhsInvent::isSerialNumberOptional(_itemId)
            || WHSInventTable::captureSerial(_itemId) != WHSRFWhenToCapture::Receiving)
            {
                qbds.addRange(_dimFieldId).value(SysQuery::valueNotEmptyString());
            }

            boolean isCW = PdsGlobal::pdsIsCWItem(_itemId);

            if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId))
            {
                qbds = qbds.addDataSource(tableNum(InventSumUnionDeltaPhysicalQty));
                qbds.addRange(fieldNum(InventSumUnionDeltaPhysicalQty, ItemId)).value(_itemId);
                qbds.relations(true);

                if (isCW)
                {
                    qbds.addRange(fieldNum(InventSumUnionDeltaPhysicalQty, PdsCWPhysicalInvent)).value(SysQuery::value('>0'));
                }
                else
                {
                    qbds.addRange(fieldNum(InventSumUnionDeltaPhysicalQty, PhysicalInvent)).value(SysQuery::value('>0'));
                }
            }
            else
            {
                qbds = qbds.addDataSource(tableNum(InventSum));
                qbds.addRange(fieldNum(InventSum, ItemId)).value(_itemId);
                qbds.relations(true);
                qbds.addRange(fieldNum(InventSum, ClosedQty)).value(SysQuery::value(NoYes::No));

                if (isCW)
                {
                    qbds.addRange(fieldNum(InventSum, PdsCWPhysicalInvent)).value(SysQuery::value('>0'));
                }
                else
                {
                    qbds.addRange(fieldNum(InventSum, PhysicalInvent)).value(SysQuery::value('>0'));
                }
            }

            return SysQuery::countLoops(new QueryRun(query)) > 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseDenormalizedView</Name>
				<Source><![CDATA[
    private static boolean shouldUseDenormalizedView()
    {
        return WHSWorkTransactionTypeUseDenormalizedViewFlight::instance().isEnabled()
            && InventUseDimOfInventSumToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkExecutedManually</Name>
				<Source><![CDATA[
    private boolean isWorkExecutedManually()
    {
        var context = WHSWorkExecuteManuallyContext::current();

        return context && context.isWorkExecutedManually;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDimensionTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the dimension tracking record.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <param name = "_inventTransId">The inventory transaction id.</param>
    /// <param name = "_inventDimId">The inventory dimension id from <c>InventSumUnionDeltaPhysicalQty</c>.</param>
    /// <param name = "_trackingQuantity">The tracking dimension quantity.</param>
    /// <returns>A new initialized dimension tracking record.</returns>
    protected WHSDimTracking initializeDimensionTracking(
        WHSWorkLine     _workLine,
        InventTransId   _inventTransId,
        InventDimId     _inventDimId,
        ProductQuantity _trackingQuantity)
    {
        WHSDimTracking  dimTracking;

        dimTracking.WorkId              = _workLine.WorkId;
        dimTracking.LineNum             = _workLine.LineNum;
        dimTracking.InventTransIdParent = _inventTransId;
        dimTracking.InventDimId         = _inventDimId;
        dimTracking.Qty                 = _trackingQuantity;

        return dimTracking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustOrderTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work line represents a CW or non-cw item and adjust the order transactions with over picked quantities.
    /// </summary>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_inventDiffHandlingQty">
    /// The quantity that is being overpicked in handling units.
    /// </param>
    /// <param name="_workLineInventHandlingQty">
    /// The quantity on the work line in handling units.
    /// </param>
    [Hookable(false)]
    final public void adjustOrderTrans(
        WHSWorkLine         _workLine,
        InventHandlingQty   _inventDiffHandlingQty,
        InventHandlingQty   _workLineInventHandlingQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _workLine.ItemId))
        {
            this.adjustOrderTransHandlingQuantities(_workLine, _inventDiffHandlingQty, _workLineInventHandlingQty);
        }
        else
        {
            this.adjustOrderTransQty(_workLine, _inventDiffHandlingQty, _workLineInventHandlingQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustOrderTransHandlingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update order transactions with over picked quantity.
    /// </summary>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_inventDiffHandlingQty">
    /// The quantity that is being overpicked in handling units.
    /// </param>
    /// <param name="_workLineInventHandlingQty">
    /// The quantity on the work line in handling units.
    /// </param>
    /// <remarks>
    /// The method is an extension and is not meant to be called directly. Callers should call the adjustOrderTrans method.
    /// </remarks>
    [Wrappable(true)]
    protected void adjustOrderTransHandlingQuantities(
        WHSWorkLine         _workLine,
        InventHandlingQty   _inventDiffHandlingQty,
        InventHandlingQty   _workLineInventHandlingQty)
    {
        if (!this.canAdjustOrderTransHandlingQuantities())
        {
            throw error(strFmt("@WAX:OverPickingUnsupportedWorkTypeErrorMessage", workTransType));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAdjustOrderTransHandlingQuantities</Name>
				<Source><![CDATA[
    protected boolean canAdjustOrderTransHandlingQuantities()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustOrderTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update order transactions with over picked quantity.
    /// </summary>
    /// <param name="_workLine">
    /// The work line that is being over picked.
    /// </param>
    /// <param name="_inventDiffQty">
    /// The quantity that is being overpicked in inventory units.
    /// </param>
    /// <param name="_workLineInventQty">
    /// The quantity on the work line in inventory units.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the adjustOrderTrans method. Extenders should move their logic to wrap or override the adjustOrderTransHandlingQuantities method.', false, 30\9\2019)]
    public void adjustOrderTransQty(
        WHSWorkLine      _workLine,
        InventQty        _inventDiffQty,
        InventQty        _workLineInventQty)
    {
        if (!this.canAdjustOrderTransHandlingQuantities())
        {
            throw error(strFmt("@WAX:OverPickingUnsupportedWorkTypeErrorMessage", workTransType));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveOverpick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserve newly overpicked quantity if it was not reserved automatically.
    /// </summary>
    /// <param name="_movement">
    /// The order line movement.
    /// </param>
    /// <param name="_inventDiffHandlingQty">
    /// The newly added quantity that should be reserved in the handling unit if it wasn't already.
    /// </param>
    /// <param name="_inventDimId">
    /// The Id for the dimension set to reserve against.
    /// </param>
    protected void reserveOverpick(
        InventMovement      _movement,
        InventHandlingQty   _inventDiffHandlingQty,
        InventDimId         _inventDimId)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _movement.itemId()))
        {
            this.reserveOverpickHandlingQuantities(_movement, _inventDiffHandlingQty, _inventDimId, true);
        }
        else
        {
            this.reserveOverpickQty(_movement, _inventDiffHandlingQty, _inventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveOverpickHandlingQuantities</Name>
				<Source><![CDATA[
    private void reserveOverpickHandlingQuantities(
        InventMovement      _movement,
        InventHandlingQty   _inventDiffHandlingQty,
        InventDimId         _inventDimId,
        boolean             _useCWAsHandlingQty)
    {
        InventDim             inventDimCriteria = InventDim::find(_inventDimId);

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(_movement.inventDim());
        InventUpd_Reservation reservation;

        if (_useCWAsHandlingQty)
        {
            reservation = InventUpd_Reservation::newMovement(_movement,
                                                        -WhsInvent::defaultCatchWeightReserveQuantity(_movement.itemId(), _inventDiffHandlingQty),
                                                        false,
                                                        false,
                                                        false,
                                                        -_inventDiffHandlingQty);
        }
        else
        {
            reservation = InventUpd_Reservation::newMovement(_movement,
                                                    -_inventDiffHandlingQty,
                                                    false);
        }

        reservation.parmAllowReserveReduction(false);
        reservation.parmAllowReserveOrdered(false);
        reservation.parmInventDimCriteria(inventDimCriteria);
        reservation.parmInventDimParm(inventDimParm);
        reservation.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveOverpickQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserve newly overpicked quantity if it was not reserved automatically.
    /// </summary>
    /// <param name="_movement">
    /// The order line movement.
    /// </param>
    /// <param name="_inventDiffQty">
    /// The newly added quantity that should be reserved if it wasn't already.
    /// </param>
    /// <param name="_inventDimId">
    /// The Id for the dimension set to reserve against.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the reserveOverpick method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    final protected void reserveOverpickQty(
        InventMovement _movement,
        InventQty      _inventDiffQty,
        InventDimId    _inventDimId)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _movement.itemId());

        this.reserveOverpickHandlingQuantities(_movement, _inventDiffQty, _inventDimId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransIdRange</Name>
				<Source><![CDATA[
    final protected void addInventTransIdRange(
        InventTransId   _inventTransId,
        Query           _query,
        TableId         _tableId,
        FieldId         _fieldId)
    {
        if (_inventTransId)
        {
            SysQuery::findOrCreateRange(_query.dataSourceTable(_tableId), _fieldId).value(queryValue(_inventTransId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUnitStructureWhenWorkIsCanceled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates unit structure for a work.
    /// </summary>
    /// <param name = "_workId">The id of the work to update the structure for.</param>
    final protected void updateUnitStructureWhenWorkIsCanceled(WHSWorkId _workId)
    {
        WHSUOMStructureReceiptHandler::unregisterAtWorkCancel(_workId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadLinesWhenWorkIsCanceled</Name>
				<Source><![CDATA[
    final protected void updateLoadLinesWhenWorkIsCanceled(WHSWorkId _workId)
    {
        WHSWorkLineLoadLineDetailsEnumerator enumerator = WHSWorkLineLoadLineDetailsEnumerator::newFromWorkId(_workId);
        while (enumerator.moveNext())
        {
            WHSLoadLine loadLine = enumerator.currentLoadLine();
            if (loadLine)
            {
                this.updateLoadLineWhenWorkIsCanceled(_workId, loadLine, enumerator.currentInventQtyWork());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetWaveWhenWorkIsCancelled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the wave when the work is cancelled.
    /// </summary>
    /// <param name = "_waveId">The wave Id.</param>
    [Hookable(false)]
    internal protected void resetWaveWhenWorkIsCancelled(WHSWaveId _waveId)
    {
        if (this.shouldResetWaveWhenWorkIsCancelled())
        {
            WHSWaveTable::resetWhenWorkIsRemoved(_waveId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldResetWaveWhenWorkIsCancelled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides if the wave should reset when the work is cancelled.
    /// </summary>
    /// <returns>True if the reset should be executed; otherwise false.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true), Replaceable(true)]
    internal boolean shouldResetWaveWhenWorkIsCancelled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadLineWhenWorkIsCanceled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the update of a single load line when work related to the load line is cancelled.
    /// </summary>
    /// <param name = "_cancelledWorkId">The <c>WHSWorkId</c> work Id of the work being cancelled.</param>
    /// <param name = "_loadLine">The <c>WHSLoadLine</c> load line.</param>
    /// <param name = "_currentInventQtyWork">The work created quantity for the load line that is related to the work being cancelled.</param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true), Replaceable(true)]
    internal void updateLoadLineWhenWorkIsCanceled(
        WHSWorkId   _cancelledWorkId,
        WHSLoadLine _loadLine,
        InventQty   _currentInventQtyWork)
    {
        _loadLine.WorkCreatedQty -= _currentInventQtyWork;
        if (_loadLine.Invalid)
        {
            if (WHSInvalidLoadLineNegativeWorkCreatedQtyThrowErrorFlight::instance().isEnabled())
            {
                _loadLine.validateNonNegativeWorkCreatedQty();
            }

            _loadLine.doUpdate();
        }
        else
        {
            _loadLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelReplenishmentWork</Name>
				<Source><![CDATA[
    final protected void cancelReplenishmentWork(WHSWorkId _workId)
    {
        WHSReplenWorkLink replenWorkLink;
        WHSReplenWorkLink otherDemandReplenWorkLink;
        WHSWorkTable      workTable;

        while select WorkId from workTable
            where workTable.CancelReplenWhenDemandCanceled    == NoYes::Yes
            exists join replenWorkLink
                where replenWorkLink.ReplenWorkId             == workTable.WorkId
                    && replenWorkLink.DemandWorkId            == _workId
            notExists join otherDemandReplenWorkLink
                where otherDemandReplenWorkLink.ReplenWorkId  == replenWorkLink.ReplenWorkId
                    && otherDemandReplenWorkLink.DemandWorkId != _workId
                    && otherDemandReplenWorkLink.InventQty    != 0
        {
            WHSWorkTable::cancelWork(workTable.WorkId);
        }

        // If there is replenishment work associated with the work remove the replenishment/demand work link
        update_recordset replenWorkLink
            setting InventQty = 0
            where replenWorkLink.DemandWorkId == _workId;

    }

]]></Source>
			</Method>
			<Method>
				<Name>singletonFromType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the singleton instance of a <c>WhsWorkTransactionType</c> class based on a <c>WHSWorkTransType</c> enum.
    /// </summary>
    /// <param name = "_type">The type enum determining the sub-class.</param>
    /// <returns>A strategy instance; or null.</returns>
    static public WhsWorkTransactionType singletonFromType(WHSWorkTransType _type)
    {
        WhsWorkTransTypeStrategyFactoryAttribute attribute = new WhsWorkTransTypeStrategyFactoryAttribute(_type);
        WhsWorkTransactionType instance = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(WhsWorkTransactionType), attribute) as WhsWorkTransactionType;

        if (instance)
        {
            instance.workTransType = _type;
        }
        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>singletonFromTypeOrDefault</Name>
				<Source><![CDATA[
    public static WhsWorkTransactionType singletonFromTypeOrDefault(WHSWorkTransType _type)
    {
        WhsWorkTransactionType instance = WhsWorkTransactionType::singletonFromType(_type);
        if (!instance)
        {
            instance = new WHSNoneWorkTransactionType();
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTransTypesForOutboundShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static container workTransTypesForOutboundShipment()
    {
        const MethodName methodName = methodStr(WHSWorkTransactionType, isForOutboundShipment);
        return WHSWorkTransactionType::workTransTypesByMethodName(methodName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTransTypesSupportingInboundCluster</Name>
				<Source><![CDATA[
    internal static container workTransTypesSupportingInboundCluster()
    {
        const MethodName methodName = methodStr(WHSWorkTransactionType, isInboundClusterSupported);
        return WHSWorkTransactionType::workTransTypesByMethodName(methodName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTransTypesSupportingConnectedPackingWork</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static container workTransTypesSupportingConnectedPackingWork()
    {
        const MethodName methodName = methodStr(WHSWorkTransactionType, canBeConnectedToPackingWork);
        return WHSWorkTransactionType::workTransTypesByMethodName(methodName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTransTypesByMethodName</Name>
				<Source><![CDATA[
    private static container workTransTypesByMethodName(MethodName _methodName)
    {
        container cacheKey = [_methodName];

        container workTransTypes = cache.find(cacheScope, cacheKey);
        if (workTransTypes)
        {
            return workTransTypes;
        }

        SysDictClass sysDictClass = new SysDictClass(classNum(WHSWorkTransactionType));

        container enumValues = WHSEnumValuesCache::newFromEnumName(enumStr(WHSWorkTransType)).getEnumValues();

        for (int enumValueIndex = 1; enumValueIndex <= conLen(enumValues); enumValueIndex++)
        {
            WHSWorkTransType type = conPeek(enumValues, enumValueIndex);
            WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(type);
            
            if (sysDictClass.callObject(_methodName, workTransactionType))
            {
                workTransTypes += type;
            }
        }

        cache.insert(cacheScope, cacheKey, workTransTypes);
        return workTransTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTransTypesForOutboundShipmentQueryRangeStr</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static str workTransTypesForOutboundShipmentQueryRangeStr()
    {
        return WhsWorkTransactionType::buildQueryRangeFromWorkTransTypesContainer(WhsWorkTransactionType::workTransTypesForOutboundShipment());
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryRangeFromWorkTransTypesContainer</Name>
				<Source><![CDATA[
    private static str buildQueryRangeFromWorkTransTypesContainer(container workTransTypes)
    {
        if (workTransTypes == conNull())
        {
            return '';
        }

        WHSWorkTransType type = conPeek(workTransTypes, 1);
        str queryRange = queryValue(type);
        for (int i = 2; i <= conLen(workTransTypes); i++)
        {
            type = conPeek(workTransTypes, i);
            queryRange = queryRangeConcat(queryRange, queryValue(type));
        }

        return queryRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkCleanUpOnLockUnlockWorkAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if work cleanUp on lock or unlock of work is allowed.
    /// </summary>
    /// <returns>True, if work cleanUp on lock or unlock of work is allowed; otherwise, false.</returns>
    public boolean isWorkCleanUpOnLockUnlockWorkAllowed()
    {
        return this.isOutbound();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFinalPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates final put location.
    /// </summary>
    /// <param name = "_location">Final put location.</param>
    /// <param name = "_locationProfile">Final put location profile.</param>
    /// <returns>Error text if validation is failed.</returns>
    [Hookable(false)]
    internal protected WHSMessage validateFinalPutLocation(
        WMSLocation         _location,
        WHSLocationProfile  _locationProfile)
    {
        if (_locationProfile.LocType != WhsParameters::find().ShipFinalLocType
            && !_locationProfile.isPackingLocationProfile())
        {
            return strFmt("@WAX:FinalPutLocationMustBePackingStationLocProfOrFinalShippingLoc", _location.wmsLocationId, workTransType);
        }
        if (_locationProfile.checkIfLocationIsFinalShippingLocationAndNonLPControlled())
        {
            return strFmt("@WAX:FinalPutLocationMustBeLPControlled", _location.wmsLocationId, workTransType);
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAccountNameFromSourceDocumentDetails</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal AccountName findAccountNameFromSourceDocumentDetails(
        InventTransId _inventTransId,
        WHSOrderNum _orderNum,
        InventLocationId _inventLocationId)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterLocationDirectiveTableQuery</Name>
				<Source><![CDATA[
    internal Query filterLocationDirectiveTableQuery(Query _query, WHSLocDirTable _locDirTable)
    {
        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportsShipmentProcessingPolicy</Name>
				<Source><![CDATA[
    internal boolean supportsShipmentProcessingPolicy()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>