<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqDemPlanForecastAttributeManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    A <c>ReqDemPlanForecastAttributeManager</c> manages forecast attributes.
/// </summary>
class ReqDemPlanForecastAttributeManager
{
    #ReqDemPlan

    // Definition of dependencies between forecasting attributes.
    // Map key:     Forecasting attribute
    // Map value:   Forecast attributes that need to be enabled, to enable forecast attribute from the map key.
    // Example:     A1 => [A2, A3], means that A1 attribute cannot be enabled without A2 and A3 attribute being enabled.
    Map dependingAttributesMap;

    // Reverse of dependingAttributesMap used during disabling of forecast attributes.
    // Map key:     Forecasting attribute
    // Map value:   Forecast attributes that need to be disabled, to disable forecast attribute from the map key.
    // Example:     A1 => [A2, A3], means that A1 attribute cannot be disabled without A2 and A3 attribute being disabled.
    Map dependingAttributesReverseMap;

    private Set attributeTypesWithDisabledConfigurationKeys;
    private boolean reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getMandatoryGranularityAttributes</Name>
				<Source><![CDATA[
    [Hookable]
    protected Set getMandatoryGranularityAttributes()
    {
        Set mandatoryGranularityAttributes = new Set(Types::Enum);
        mandatoryGranularityAttributes.add(ReqDemPlanForecastAttributeType::DataAreaId);
        mandatoryGranularityAttributes.add(ReqDemPlanForecastAttributeType::Site);
        mandatoryGranularityAttributes.add(ReqDemPlanForecastAttributeType::AllocationKey);
        return mandatoryGranularityAttributes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultEnabledAttributes</Name>
				<Source><![CDATA[
    [Hookable]
    protected Set getDefaultEnabledAttributes()
    {
        Set defaultEnabledAttributes = new Set(Types::Enum);
        defaultEnabledAttributes.add(ReqDemPlanForecastAttributeType::ItemId);
        return defaultEnabledAttributes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConfigurableGranularityAttributes</Name>
				<Source><![CDATA[
    [Hookable]
    protected Set getConfigurableGranularityAttributes()
    {
        Set configurableGranularityAttributes = new Set(Types::Enum);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::ItemId);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::Warehouse);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::StatusId);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::CustGroupId);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::CustAccount);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::LogisticsCountryRegionCode);
        configurableGranularityAttributes.add(ReqDemPlanForecastAttributeType::LogisticsAddressStateId);
        return configurableGranularityAttributes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGranularityAttributesBILevels</Name>
				<Source><![CDATA[
    [Hookable]
    protected Set getGranularityAttributesBILevels()
    {
        Set granularityAttributesBILevels = new Set(Types::Container);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::ItemId,                       '[Released products].[Released product].[Released product]',            'Released products']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::AllocationKey,                '[Item allocation keys].[Item allocation key].[Item allocation key]',   'Item allocation keys']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::Site,                         '[Sites].[Site].[Site]',                                                'Sites']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::Warehouse,                    '[Warehouses].[Warehouse].[Warehouse]',                                 'Warehouses']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::Color,                        '[Colors].[Colors].[Colors]',                                           'Colors']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::Configuration,                '[Configurations].[Configurations].[Configurations]',                   'Configurations']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::Size,                         '[Sizes].[Sizes].[Sizes]',                                              'Sizes']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::Style,                        '[Styles].[Styles].[Styles]',                                           'Styles']);        
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::StatusId,                     '[Inventory status].[Inventory status].[Inventory status]',             'Inventory status']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::CustGroupId,                  '[Customer groups].[Customer group].[Customer group]',                  'Customer groups']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::CustAccount,                  '[Customers].[Customer].[Customer]',                                    'Customers']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::LogisticsCountryRegionCode,   '[Country Region].[Country Region].[Country Region]',                   'Country Region']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::LogisticsAddressStateId,      '[States].[State].[State]',                                             'States']);
        granularityAttributesBILevels.add([ReqDemPlanForecastAttributeType::ProductVersion, '[ProductVersions].[ProductVersions].[ProductVersions]', 'Versions']);

        return granularityAttributesBILevels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defineDependencies</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defines dependencies between forecast attributes.
    /// </summary>
    private void defineDependencies()
    {
        var itemIdDependencies = [ReqDemPlanForecastAttributeType::Configuration, ReqDemPlanForecastAttributeType::Color, ReqDemPlanForecastAttributeType::Size, ReqDemPlanForecastAttributeType::Style, ReqDemPlanForecastAttributeType::ProductVersion];

        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::ProductVersion,
            [ReqDemPlanForecastAttributeType::ItemId]);

        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::ItemId,
            itemIdDependencies);

        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::Configuration,
            [ReqDemPlanForecastAttributeType::ItemId]);
        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::Color,
            [ReqDemPlanForecastAttributeType::ItemId]);
        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::Size,
            [ReqDemPlanForecastAttributeType::ItemId]);
        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::Style,
            [ReqDemPlanForecastAttributeType::ItemId]);

        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::CustAccount,
            [ReqDemPlanForecastAttributeType::CustGroupId]);

        dependingAttributesMap.insert(
            ReqDemPlanForecastAttributeType::LogisticsAddressStateId,
            [ReqDemPlanForecastAttributeType::LogisticsCountryRegionCode]);
    
        this.defineDependenciesDelegate(dependingAttributesMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defineDependenciesDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Delegate for adding dependencies between forecast attributes.
    /// </summary>
    /// <param name="_dependingAttributesMap">
    ///     Definition of dependencies between forecasting attributes.
    /// </param>
    delegate void defineDependenciesDelegate(Map _dependingAttributesMap)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableAttributesWithDisabledConfigurationKeys</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disables attributes with disabled configuration keys.
    /// </summary>
    public void disableAttributesWithDisabledConfigurationKeys()
    {
        int infologLineTry = infologLine();

        try
        {
            var biLevelsEnumerator = this.getGranularityAttributesBILevels().getEnumerator();

            while (biLevelsEnumerator.moveNext())
            {
                ReqDemPlanForecastAttributeType attributeType = conPeek(biLevelsEnumerator.current(), 1);
                if (!this.configurationKeyIsEnabledForAttribute(attributeType) && this.isAttributeEnabled(attributeType))
                {
                    ttsbegin;
                
                    this.logWarningConfigurationKeyDisabledForAttribute(attributeType);
                    var attribute = ReqDemPlanForecastAttribute::findByAttributeType(attributeType, true);
                    attribute.Enabled = false;
                    attribute.update();

                    ReqDemPlanPivotAttributes pivotAttributeForDelete;
                    delete_from pivotAttributeForDelete 
                        where pivotAttributeForDelete.Attribute == attribute.RecId;

                    ttscommit;
                }
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConsistency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the persisted state of attributes is consistent. Adds a warning to the infolog if the check fails.
    /// </summary>
    /// <returns>
    /// true, if persisted state of attributes is consistent; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If an attribute is enabled but the corresponding configuration key is disabled then the check will fail.
    /// If configuration key is disabled for a pivot attribute then the check will fail.
    /// </remarks>
    [Hookable(false)]
    internal boolean checkConsistency()
    {
        var biLevelsEnumerator = this.getGranularityAttributesBILevels().getEnumerator();

        while (biLevelsEnumerator.moveNext())
        {
            ReqDemPlanForecastAttributeType attributeType = conPeek(biLevelsEnumerator.current(), 1);
            if (!this.configurationKeyIsEnabledForAttribute(attributeType) && this.isAttributeEnabled(attributeType))
            {
                warning(strFmt("@DMP:ConfigurationKeyIsDisabledForEnabledForecastAttributeWarning", enum2Str(attributeType)));
                this.logWarningConfigurationKeyDisabledForAttribute(attributeType);
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logWarningConfigurationKeyDisabledForAttribute</Name>
				<Source><![CDATA[
    private void logWarningConfigurationKeyDisabledForAttribute(ReqDemPlanForecastAttributeType _attribute)
    {
        var logger = ReqDemPlanInstrumentationLogger::createLogger(classStr(ReqDemPlanForecastAttributeManager));
        logger.logWarning(
            strFmt('Configuration key for attribute %1 is disabled',
            enum2Symbol(enumNum(ReqDemPlanForecastAttributeType), _attribute)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Disables given forecast attribute type.
    /// </summary>
    /// <param name="_forecastAttributeType">
    ///     A forecast attribute type that should be enabled\disabled.
    /// </param>
    public void disableAttribute(ReqDemPlanForecastAttributeType _forecastAttributeType)
    {
        ReqDemPlanForecastAttribute forecastAttribute;
        int infologLineTry = infologLine();

        try
        {
            ttsBegin;

            forecastAttribute = ReqDemPlanForecastAttribute::findOrCreate(_forecastAttributeType, true);
            forecastAttribute.Enabled = NoYes::No;
            forecastAttribute.update();

            this.disableDependingAttributes(_forecastAttributeType);

            ttsCommit;
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableDependingAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Disables depending forecast attributes.
    /// </summary>
    /// <param name="_attributeType">
    ///     A <c>ReqDemPlanForecastAttributeType</c> for which depenging attributes should be disabled.
    /// </param>
    private void disableDependingAttributes(ReqDemPlanForecastAttributeType _attributeType)
    {
        ReqDemPlanForecastAttributeType dependingAttribute;

        container attributeDependencies;
        int       i;

        if (!dependingAttributesReverseMap.exists(_attributeType))
        {
            return;
        }

        attributeDependencies = dependingAttributesReverseMap.lookup(_attributeType);

        for (i = 1; i <= conLen(attributeDependencies); i++)
        {
            dependingAttribute = conPeek(attributeDependencies, i);

            if (this.isAttributeEnabled(dependingAttribute))
            {
                if (this.isAttributeConfigurable(dependingAttribute))
                {
                    info(strFmt("@DMP1413", dependingAttribute, _attributeType));
                }
                this.disableAttribute(dependingAttribute);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Enables given forecast attribute type.
    /// </summary>
    /// <param name="_forecastAttributeType">
    ///     A forecast attribute type that should be enabled\disabled.
    /// </param>
    public void enableAttribute(ReqDemPlanForecastAttributeType _forecastAttributeType)
    {
        int infologLineTry = infologLine();

        try
        {
            ttsBegin;

            var forecastAttribute = ReqDemPlanForecastAttribute::findOrCreate(_forecastAttributeType, true);
            forecastAttribute.Enabled = NoYes::Yes;
            forecastAttribute.update();

            this.enableDependingAttributes(_forecastAttributeType);

            ttsCommit;
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryEnableAttribute</Name>
				<Source><![CDATA[
    private void tryEnableAttribute(ReqDemPlanForecastAttributeType _forecastAttributeType)
    {
        if (this.configurationKeyIsEnabledForAttribute(_forecastAttributeType))
        {
            this.enableAttribute(_forecastAttributeType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableDependingAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Enables depending forecast attributes.
    /// </summary>
    /// <param name="_attributeType">
    ///     A <c>ReqDemPlanForecastAttributeType</c> for which depending attributes should be enabled.
    /// </param>
    private void enableDependingAttributes(ReqDemPlanForecastAttributeType _attributeType)
    {
        ReqDemPlanForecastAttributeType dependingAttribute;

        container attributeDependencies;
        int       i;

        if (!dependingAttributesMap.exists(_attributeType))
        {
            return;
        }

        attributeDependencies = dependingAttributesMap.lookup(_attributeType);

        for (i = 1; i <= conLen(attributeDependencies); i++)
        {
            dependingAttribute = conPeek(attributeDependencies, i);

            if (!this.isAttributeEnabled(dependingAttribute))
            {
                if (this.isAttributeConfigurable(dependingAttribute))
                {
                    info(strFmt("@DMP1414", _attributeType, dependingAttribute));
                }
                this.tryEnableAttribute(dependingAttribute);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableMandatoryOrDefaultAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Goes through the added forecast attribute records and enables them along with their dependencies.
    /// </summary>
    public void enableMandatoryOrDefaultAttributes()
    {
        Set                         mandatoryAttributes        = this.getMandatoryGranularityAttributes();
        Set                         defaultEnabledAttributes   = this.getDefaultEnabledAttributes();
        ReqDemPlanForecastAttribute forecastAttribute;
        boolean                     enableDefaultAttributes    = false;

        if (this.getAllEnabledAttributes().empty())
        {
            enableDefaultAttributes = true;
        }

        int infologLineTry = infologLine();

        try
        {
            while select Attribute from forecastAttribute
            {
                if (mandatoryAttributes.in(forecastAttribute.Attribute)
                    || (enableDefaultAttributes && defaultEnabledAttributes.in(forecastAttribute.Attribute)))
                {
                    this.tryEnableAttribute(forecastAttribute.Attribute);
                }
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllAttributesExceptCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs an ordered list of all attributes except for company.
    /// </summary>
    /// <returns>
    ///     The ordered list of attributes.
    /// </returns>
    public List getAllAttributesExceptCompany()
    {
        List                        list;
        ReqDemPlanForecastAttribute attribute;
        int infologLineTry = infologLine();

        try
        {
            list = new List(Types::Record);

            while select attribute
                order by attribute.Attribute
                where attribute.Attribute != ReqDemPlanForecastAttributeType::DataAreaId
            {
                list.addEnd(attribute);
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs an ordered list of all attributes.
    /// </summary>
    /// <returns>
    ///     The ordered list of attributes.
    /// </returns>
    public List getAllAttributes()
    {
        List                        list;
        ReqDemPlanForecastAttribute attribute;
        int infologLineTry = infologLine();

        try
        {
            list = new List(Types::Record);

            while select attribute
                order by attribute.Attribute
            {
                list.addEnd(attribute);
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllDisabledAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds all disabled forecast attributes.
    /// </summary>
    /// <returns>
    ///     The ordered list of disabled forecast attributes.
    /// </returns>
    public List getAllDisabledAttributes()
    {
        ReqDemPlanForecastAttribute attribute;
        List                        result;
        int infologLineTry = infologLine();

        try
        {
            result = new List(Types::Record);

            while select attribute
                order by attribute.Attribute
                where !attribute.Enabled
            {
                result.addEnd(attribute);
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllEnabledAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds all enabled attributes.
    /// </summary>
    /// <returns>
    ///     The ordered list of all enabled attributes.
    /// </returns>
    public List getAllEnabledAttributes()
    {
        ReqDemPlanForecastAttribute attribute;
        List                        result;
        int infologLineTry = infologLine();

        try
        {
            result = new List(Types::Record);

            while select attribute
                order by attribute.Attribute
                where attribute.Enabled
            {
                result.addEnd(attribute);
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllPivotAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets all the pivot attributes selected.
    /// </summary>
    /// <returns>The list of attributes.</returns>
    public List getAllPivotAttributes()
    {
        ReqDemPlanPivotAttributes pivotAttributes;
        ReqDemPlanForecastAttribute attribute;
        List result;
        int infologLineTry = infologLine();

        try
        {
            result = new List(Types::Record);

            while select attribute
                join pivotAttributes
                order by pivotAttributes.Position
                where pivotAttributes.Attribute == attribute.RecId
            {
                result.addEnd(attribute);
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonPivotAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets all the attributes which are not selected for pivoting.
    /// </summary>
    /// <returns>The list of attributes.</returns>
    public List getNonPivotAttributes()
    {
        ReqDemPlanPivotAttributes pivotAttributes;
        ReqDemPlanForecastAttribute attribute;
        List result;
        int infologLineTry = infologLine();

        try
        {
            result = new List(Types::Record);

            while select attribute
                notexists join pivotAttributes
                order by pivotAttributes.Attribute
                where pivotAttributes.Attribute == attribute.RecId
            {
                result.addEnd(attribute);
            }
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailableNonPivotAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets all the attributes which are not selected for pivoting and can be selected as pivot attributes.
    /// </summary>
    /// <returns>The list of attributes.</returns>
    public List getAvailableNonPivotAttributes()
    {
        List result = new List(Types::Record);

        var attributeEnumerator = this.getNonPivotAttributes().getEnumerator();
        while (attributeEnumerator.moveNext())
        {
            ReqDemPlanForecastAttribute attribute = attributeEnumerator.current();
            if (this.configurationKeyIsEnabledForAttribute(attribute.Attribute))
            {
                result.addEnd(attribute);
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a table field according to the specified attribute.
    /// </summary>
    /// <param name="_tableId">
    ///     The ID of the table in which the fields should be searched.
    /// </param>
    /// <param name="_attribute">
    ///     The forecast attribute.
    /// </param>
    /// <returns>
    ///     The ID of the field in the specified table.
    /// </returns>
    public FieldId getAttributeField(TableId _tableId, ReqDemPlanForecastAttribute _attribute)
    {
        var attributeList = new List(Types::Record);
        attributeList.addEnd(_attribute);

        var fields = this.getAttributeFields(_tableId, attributeList);
        var enumerator = fields.getEnumerator();
        enumerator.moveNext();
        return enumerator.current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a list of table fields according to the specified list of forecast attributes.
    /// </summary>
    /// <param name="_tableId">
    ///     The ID of the table in which the fields should be searched.
    /// </param>
    /// <param name="_attributesList">
    ///     The list of forecast attributes.
    /// </param>
    /// <returns>
    ///     The list of table field IDs.
    /// </returns>
    public List getAttributeFields(TableId _tableId, List _attributesList)
    {
        ListEnumerator              listEnumerator;
        FieldName                   fieldName;
        FieldId                     fieldId;
        List                        result                  = new List(Types::Integer);
        ReqDemPlanForecastAttribute attribute;

        listEnumerator = _attributesList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            attribute = listEnumerator.current();

            fieldName   = enum2Symbol(enumNum(ReqDemPlanForecastAttributeType), enum2int(attribute.Attribute));
            fieldId     = fieldName2id(_tableId, fieldName);

            if (!fieldId)
            {
                throw error(strFmt("@DMP1445", fieldName, tableId2pname(_tableId)));
            }
            result.addEnd(fieldId);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeTypesByFieldNameMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the mapping from field IDs to attribute types for the specified table.
    /// </summary>
    /// <param name="_tableId">The ID of the table in which the fields should be searched.</param>
    /// <returns>The mapping from field IDs to attribute types for the specified table.</returns>
    public Map getAttributeTypesByFieldNameMap()
    {
        Map         map             = new Map(Types::String, Types::Enum);
        SysDictEnum dictEnum        = new SysDictEnum(enumNum(ReqDemPlanForecastAttributeType));
        int         enumIntValue;

        for (int i = 1; i <= enumCnt(ReqDemPlanForecastAttributeType); i++)
        {
            enumIntValue = dictEnum.index2Value(i);

            map.insert(dictEnum.index2Symbol(i), enumIntValue);
        }

        return map;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoRevertedMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts value into dependingAttributesMapReverted.
    /// </summary>
    /// <param name="_keyAttribute">
    ///     The map key.
    /// </param>
    /// <param name="_valueAttribute">
    ///     The map value.
    /// </param>
    private void insertIntoRevertedMap(ReqDemPlanForecastAttributeType _keyAttribute, ReqDemPlanForecastAttributeType _valueAttribute)
    {
        container attributes;

        if (dependingAttributesReverseMap.exists(_keyAttribute))
        {
            attributes = dependingAttributesReverseMap.lookup(_keyAttribute);
        }

        attributes += [_valueAttribute];
        dependingAttributesReverseMap.insert(_keyAttribute, attributes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMissingAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts all missing forecast attribute types into the database
    ///     based on <c>ReqDemPlanForecastAttributeType</c> enum values and enables the necessary attributes.
    /// </summary>
    public void insertMissingAttributes()
    {
        this.syncMissingAttributes();

        this.enableMandatoryOrDefaultAttributes();
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncMissingAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes any missing attributes to the database, but does not enable them.
    /// </summary>
    internal void syncMissingAttributes()
    {
        DictEnum                        dictEnum        = new DictEnum(EnumNum(ReqDemPlanForecastAttributeType));
        Set                             allAttributes   = new Set(Types::Enum);
        ReqDemPlanForecastAttributeType attributeType;
        
        for (int i = 0; i < dictEnum.values(); i++)
        {
            attributeType = dictEnum.index2Value(i);
            allAttributes.add(attributeType);
        }

        ReqDemPlanForecastAttribute forecastAttribute;
        Set                         persistedAttributes;
        int infologLineTry = infologLine();

        try
        {
            persistedAttributes = new Set(Types::Enum);

            while select Attribute from forecastAttribute
            {
                persistedAttributes.add(forecastAttribute.Attribute);
            }

            SetEnumerator se = Set::difference(allAttributes, persistedAttributes).getEnumerator();
            RecordInsertList missingAttributes = new RecordInsertList(tableNum(ReqDemPlanForecastAttribute));
            Set configurableAttributes  = this.getConfigurableGranularityAttributes();
            Set biLevels                = this.getGranularityAttributesBILevels();

            while (se.moveNext())
            {
                forecastAttribute.clear();
                forecastAttribute.Attribute = se.current();
            
                if (configurableAttributes.in(forecastAttribute.Attribute))
                {
                    forecastAttribute.Configurable = NoYes::Yes;
                }

                SetEnumerator biLevelsEnumerator = biLevels.getEnumerator();

                while (biLevelsEnumerator.moveNext())
                {
                    container biLevel = biLevelsEnumerator.current();
                    if (conPeek(biLevel, 1) == forecastAttribute.Attribute)
                    {
                        forecastAttribute.BIDimensionLevel = conPeek(biLevel, 2);
                        break;
                    }
                }

                missingAttributes.add(forecastAttribute);
            }

            missingAttributes.insertDatabase();
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupPivotAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets up the attributes by which the forecast should be aggregated.
    /// </summary>
    /// <param name = "_forecastAttributes">The list of forecast attributes.</param>
    public void setupPivotAttributes(List _forecastAttributes)
    {
        int infologLineTry = infologLine();

        try
        {
            ttsbegin;

            ReqDemPlanPivotAttributes pivotAttributes;
            delete_from pivotAttributes;

            var position = 1;
            var enumerator = _forecastAttributes.getEnumerator();
            while (enumerator.moveNext())
            {
                ReqDemPlanForecastAttribute attribute = enumerator.current();
                pivotAttributes.Attribute = attribute.RecId;
                pivotAttributes.Position = position;
                pivotAttributes.insert();
                ++position;
            }

            ttscommit;
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAttributeConfigurable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if given forecast attribute type is configurable.
    /// </summary>
    /// <param name="_forecastAttributeType">
    ///     Forecast attribute type that should be checked.
    /// </param>
    /// <returns>
    ///     A <c>boolean</c> stating if attribute is configurable.
    /// </returns>
    private boolean isAttributeConfigurable(ReqDemPlanForecastAttributeType _forecastAttributeType)
    {
        boolean ret;
        int infologLineTry = infologLine();

        try
        {
            ret = ReqDemPlanForecastAttribute::findByAttributeType(_forecastAttributeType).Configurable;
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAttributeEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if given forecast attribute type is enabled.
    /// </summary>
    /// <param name="_forecastAttributeType">
    ///     Forecast attribute type that should be checked.
    /// </param>
    /// <returns>
    ///     A <c>boolean</c> stating if attribute is enabled.
    /// </returns>
    public boolean isAttributeEnabled(ReqDemPlanForecastAttributeType _forecastAttributeType)
    {
        boolean ret;
        int infologLineTry = infologLine();

        try
        {
            ret = ReqDemPlanForecastAttribute::findByAttributeType(_forecastAttributeType).Enabled == NoYes::Yes;   
        }
        #ReqDemPlanCatchRetryWithoutPrepareTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, infologLineTry)

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled = ReqDemPlanCreateForecastService::isTransientSqlConnectionErrorRetryEnabled();
        dependingAttributesMap          = new Map(Types::Enum, Types::Container);
        dependingAttributesReverseMap   = new Map(Types::Enum, Types::Container);
        this.defineDependencies();
        this.reverseDependingAttributesMap();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseDependingAttributesMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reverses dependency map of forecast attributes.
    /// </summary>
    private void reverseDependingAttributesMap()
    {
        MapIterator dependingAttributesMapIterator = new MapIterator (dependingAttributesMap);
        container   currentDependingAttributes;
        int         i;

        while (dependingAttributesMapIterator.more())
        {
            currentDependingAttributes = dependingAttributesMapIterator.value();

            for (i = 1; i <= conLen(currentDependingAttributes); i++)
            {
                this.insertIntoRevertedMap(conPeek(currentDependingAttributes, i), dependingAttributesMapIterator.key());
            }

            dependingAttributesMapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeGranularityKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines the attribute values into the granularity key.
    /// </summary>
    /// <param name = "_values">The values to combine.</param>
    /// <returns>The compound key.</returns>
    public str makeGranularityKey(container _values)
    {
        var result = '';
        for (var i = 1; i <= conLen(_values); ++i)
        {
            if (result)
            {
                result += num2char(#GranularityDelimiterAsciiCode);
            }
            result += conPeek(_values, i);
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitGranularityKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the compound granularity key into attribute values.
    /// </summary>
    /// <param name = "_key">The key to split.</param>
    /// <returns>The list of attribute values.</returns>
    public List splitGranularityKey(str _key)
    {
        return strSplit(_key, num2char(#GranularityDelimiterAsciiCode));
    }

]]></Source>
			</Method>
			<Method>
				<Name>makePivotAttributeKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines the attribute values into the attribute key.
    /// </summary>
    /// <param name = "_buffer">The buffer with attribute values.</param>
    /// <returns>The compound key.</returns>
    public str makePivotAttributeKey(Common _buffer)
    {
        container   granularityKeyCont;
        var         pivotAttributes     = this.getAllPivotAttributes();
        var         pivotFields         = this.getAttributeFields(_buffer.TableId, pivotAttributes);
        var         enumerator          = pivotFields.getEnumerator();

        while (enumerator.moveNext())
        {
            var fieldContent = _buffer.(enumerator.current());
            granularityKeyCont += fieldContent ? fieldContent : #AttributeKeyEmptyValueReplacement;
        }

        return con2Str(granularityKeyCont, #AttributeKeyDelimiter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ReqDemPlanForecastAttributeManager construct()
    {
        return new ReqDemPlanForecastAttributeManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPivotAttributesNameText</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds string with pivot attributes names.
    /// </summary>
    /// <returns>A string with delimited attribute names.</returns>
    public str getPivotAttributesNameText()
    {
        container   granularityKeyCont;
        var         attributeEnumerator = this.getAllPivotAttributes().getEnumerator();

        while (attributeEnumerator.moveNext())
        {
            var attribute = attributeEnumerator.current() as ReqDemPlanForecastAttribute;
            granularityKeyCont += attribute.Attribute == ReqDemPlanForecastAttributeType::ItemId ? "@SYS12836" : enum2str(attribute.Attribute);
        }

        return con2Str(granularityKeyCont, #AttributeKeyDelimiter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPivotAttributesNameValueText</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds string with pivot attributes names and values.
    /// </summary>
    /// <param name = "_aggregatedForecast">A forecast record for which text should be built.</param>
    /// <returns>A string with delimited attribute names and values.</returns>
    public str getPivotAttributesNameValueText(ReqDemPlanAggregatedForecast _aggregatedForecast)
    {
        container   granularityKeyCont;
        var         enabledAttributes   = this.getAllPivotAttributes();
        var         attributeEnumerator = enabledAttributes.getEnumerator();
        var         fieldEnumerator     = this.getAttributeFields(tableNum(ReqDemPlanAggregatedForecast), enabledAttributes)
                                            .getEnumerator();

        while (fieldEnumerator.moveNext() && attributeEnumerator.moveNext())
        {
            var fieldContent = _aggregatedForecast.(fieldEnumerator.current());

            if (fieldContent)
            {
                var attribute = attributeEnumerator.current() as ReqDemPlanForecastAttribute;
                granularityKeyCont += strFmt("@SYS76766", enum2str(attribute.Attribute), fieldContent);
            }
        }

        return con2Str(granularityKeyCont, #AttributeKeyDelimiter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertProductAttributeToInventDimFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified product attribute to field ID from the <c>InventDim</c> table.
    /// </summary>
    /// <param name = "_attribute">The attribute.</param>
    /// <returns>The field ID from the <c>InventDim</c> table.</returns>
    /// <remarks>
    /// If the attribute does not represent a product attribute then 0 is returned. 
    /// </remarks>
    public static FieldId convertProductAttributeToInventDimFieldId(ReqDemPlanForecastAttributeType _attribute)
    {
        #InventDimDevelop

        switch (_attribute)
        {
            case ReqDemPlanForecastAttributeType::DataAreaId:
            case ReqDemPlanForecastAttributeType::AllocationKey:
            case ReqDemPlanForecastAttributeType::ItemId:
            case ReqDemPlanForecastAttributeType::Site:
            case ReqDemPlanForecastAttributeType::Warehouse:
                // special handling already done
                return 0;

            case ReqDemPlanForecastAttributeType::Configuration:
                return fieldNum(InventDim, configId);

            case ReqDemPlanForecastAttributeType::Color:
                return fieldNum(InventDim, InventColorId);
    
            case ReqDemPlanForecastAttributeType::ProductVersion:
                return fieldNum(InventDim, InventVersionId);

            case ReqDemPlanForecastAttributeType::Size:
                return fieldNum(InventDim, InventSizeId);

            case ReqDemPlanForecastAttributeType::Style:
                return fieldNum(InventDim, InventStyleId);

            default:
                // other fields cannot be derived from just having the item in the allocation key
                return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configurationKeyIsEnabledForAttribute</Name>
				<Source><![CDATA[
    private boolean configurationKeyIsEnabledForAttribute(ReqDemPlanForecastAttributeType _attributeType)
    {
        if (!attributeTypesWithDisabledConfigurationKeys)
        {
            attributeTypesWithDisabledConfigurationKeys = new Set(Types::Enum);
            var biLevelsEnumerator = this.getGranularityAttributesBILevels().getEnumerator();
            while (biLevelsEnumerator.moveNext())
            {
                var attributeType = conPeek(biLevelsEnumerator.current(), 1);
                var productInventDimFieldId = ReqDemPlanForecastAttributeManager::convertProductAttributeToInventDimFieldId(attributeType);
                if (productInventDimFieldId)
                {
                    var field = new SysDictField(tableNum(InventDim), productInventDimFieldId);
                    var configurationKeyId = field.configurationKeyId();
                    if (configurationKeyId && !isConfigurationkeyEnabled(field.configurationKeyId()))
                    {
                        attributeTypesWithDisabledConfigurationKeys.add(attributeType);
                    }
                }
            }
        }

        return !attributeTypesWithDisabledConfigurationKeys.in(_attributeType);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>