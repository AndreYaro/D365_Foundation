<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProdUpdHistoricalCost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProdUpdHistoricalCost</c> class is used for ending the production order.
/// </summary>
/// <remarks>
/// When production is ended, all transactions for the production will be financially updated, and then
/// the obtained cost amount will be calculated. The production order should have a status of Report as
/// Finished before it will be ended.
/// </remarks>
class ProdUpdHistoricalCost extends ProdUpd
{
    ProdParmHistoricalCost  prodParmHistoricalCost;
    ProdTableJour           prodTableJour;
    CostAmount              totalCostAmount;
    InventTransId           scrapTransId;
    NoYesId                     endJob_RU;
    NoYesId                     calculatingWIP_RU;
    ProdParametersDim           prodParametersDim;
    ProdCalculatingMethod_RU    calculatingMethod_RU;
    NoYesId                     useDatePhysicalMaxValue_RU;

    #ISOCountryRegionCodes
    boolean                     countryRegion_RU;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocationPercentMainItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cost allocation percent of the main item.
    /// </summary>
    /// <returns>
    /// The cost allocation percent of the main item.
    /// </returns>
    protected Percent allocationPercentMainItem()
    {
        return 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdTableJour</Name>
				<Source><![CDATA[
    void initProdTableJour(Voucher _voucher)
    {
        prodTableJour.clear();
        prodTableJour.initFromProdTable(prodTable);

        prodTableJour.JournalType    = ProdJourType::HistoricalCost;

        prodTableJour.Voucher        = _voucher;
        prodTableJour.TransDate      = prodParmHistoricalCost.CalcDate;

        InventQty qtyGood = prodTable.reportedFinishedGood();
        InventQty qtyError = prodTable.reportedFinishedError();
        if (countryRegion_RU)
        {
            qtyError += prodTable.releasedError_RU();
        }

        if (
            (endJob_RU || !countryRegion_RU) &&
            (
            qtyGood + qtyError == 0 ||
            (qtyGood           == 0 && (prodParmHistoricalCost.ScrapMethod == ProdScrapMethod::Allocation ||
                                       (prodTable.inventTable().modelGroup().inventModelType().stdCostBased() &&
                                        (!ProdPostScrapStdCostModelFeature::instance().isEnabled() || prodTable.ProjId)))))
            )
        {
            throw error("@SYS76448");
        }

        prodTableJour.QtyGood        = qtyGood  - prodTable.historicalCostQtyGood();
        prodTableJour.QtyError       = qtyError - prodTable.historicalCostQtyError();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerVoucher</Name>
				<Source><![CDATA[
    LedgerVoucher newLedgerVoucher()
    {
        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(
            DetailSummary::Summary,
            SysModule::Prod,
            NumberSeq::newGetNum(ProdParameters::numRefProdCalcVoucherId()).parmNumberSequenceCode(),
            TransactionLogType::Unspecified,
            '',
            false,
            (isConfigurationkeyEnabled(configurationKeyNum(Project)) ? !ProdParametersDim::projPostExPostingType(prodTable) : !prodTable.prodParametersDim().PostExPostingType));

        ledgerVoucher.parmCheckBlockedDimensions(false);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerVoucherObject</Name>
				<Source><![CDATA[
    LedgerVoucherObject newLedgerVoucherObject(
        LedgerVoucher       _ledgerVoucher,
        Voucher             _voucher = NumberSeq::newGetNum(ProdParameters::numRefProdCalcVoucherId()).num()
        )
    {
        TransactionTxt          transactionTxt = TransactionTxt::construct();

        transactionTxt.setType(LedgerTransTxt::ProdHistoricalCost);
        transactionTxt.setDate(prodParmHistoricalCost.CalcDate);
        transactionTxt.setVoucher(_voucher);
        transactionTxt.setKey1(prodTable.ProdId);
        transactionTxt.setKey2(prodTable.ItemId);

        if (TransactionTextContext::isTypeSupported(LedgerTransTxt::ProdHistoricalCost))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::ProdHistoricalCost);
            transactionTextContext.setTableBuffer(prodTable);
            transactionTextContext.setTableBuffer(prodParmHistoricalCost);
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(_voucher,prodParmHistoricalCost.CalcDate,SysModule::Prod,LedgerTransType::Production);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        _ledgerVoucher.addVoucher(ledgerVoucherObject);

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onUpdateProdCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the possibility to perform additional actions when the production order was calculated.
    /// </summary>
    /// <param name="_prodCalcTrans">
    /// The production calculation record that was updated.
    /// </param>
    /// <remarks>
    /// Right now, only used for batch orders because the burden processing did already update the real cost amount
    /// </remarks>
    protected void onUpdateProdCalculation(ProdCalcTrans    _prodCalcTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmBuffer</Name>
				<Source><![CDATA[
    ParmBuffer parmParmBuffer(ParmBuffer _prodParmHistoricalCost = prodParmHistoricalCost)
    {
        if (!_prodParmHistoricalCost.RecId)
        {
            throw error("@SYS84961");
        }

        prodParmHistoricalCost = _prodParmHistoricalCost;

        return prodParmHistoricalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postScrap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the scrap quantity.
    /// </summary>
    /// <param name="_ledgerVoucherReceipt">
    /// The <c>LedgerVoucher</c> that should be used for posting.
    /// </param>
    public void postScrap(LedgerVoucher _ledgerVoucherReceipt)
    {
        this.postScrapForProductionOutput(_ledgerVoucherReceipt,
                                          prodTable.inventTable(),
                                          prodTableJour,
                                          InventTransOriginProdTable::findInventTransOriginId(prodTable.DataAreaId, prodTable.ProdId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateProdJobType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs actions after update.
    /// </summary>
    /// <param name="_prodJobType">
    /// The production job type.
    /// </param>
    /// <param name="_prodRouteTrans">
    /// The route transaction.
    /// </param>
    protected void postUpdateProdJobType(
        ProdJobType     _prodJobType,
        ProdRouteTrans  _prodRouteTrans)
    {
        // do nothing
    }

]]></Source>
			</Method>
			<Method>
				<Name>projEnd</Name>
				<Source><![CDATA[
    private void projEnd()
    {
        ProjItemTrans           projItemTrans;
        ProjTransPosting        projTransPosting;
        ProjItemTransCost       projItemTransCost;

        if (!prodTable.isProjMethodConsumed())
        {
            return;
        }

        if (prodTableJour.QtyError)
        {
            if (prodParmHistoricalCost.ScrapMethod == ProdScrapMethod::ScrapAccount)
            {
                while select forupdate projItemTransCost
                    where projItemTransCost.InventTransId == scrapTransId
                {
                    projItemTransCost.InventTransId = prodTable.InventTransId;
                    projItemTransCost.setItemLineNum();
                    projItemTransCost.update();
                }

                update_recordset projTransPosting
                    setting InventTransId = prodTable.InventTransId
                    join projItemTrans
                        where projItemTrans.ProjTransId == projTransPosting.TransId &&
                            projItemTrans.InventTransId == prodTable.InventTransId;
            }
            else
            {
                prodTable.deleteProdTableProj(ProjItemTypeProdTable::ErrorQuantity);
            }
        }
        else
        {
            prodTable.deleteProdTableProj(ProjItemTypeProdTable::ErrorQuantity);
        }

        InventQty qtyUnderconsumed = prodTable.qtyUnderconsumed();
        if (qtyUnderconsumed)
        {
            ProjInventJournalTransMapForm::updateOrCreateProdTableProj(prodTable, ProjItemTypeProdTable::Underconsumed, prodTableJour.TransDate, qtyUnderconsumed);
        }
        else
        {
            prodTable.deleteProdTableProj(ProjItemTypeProdTable::Underconsumed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCalcValues</Name>
				<Source><![CDATA[
    [Replaceable]
    void resetCalcValues()
    {
        ProdCalcTrans    prodCalcTrans;

        update_recordset prodCalcTrans
            setting RealQty = 0, RealConsump = 0, RealCostAmount = 0, RealCostAdjustment = 0
            where prodCalcTrans.TransRefId   == prodParmHistoricalCost.ProdId
               && prodCalcTrans.TransRefType == ProdTransRefType::Production;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Starts the end of production order.
    /// </summary>
    /// <remarks>
    ///    Before the method is started, parameters should be set up by using the <c>newParmBuffer</c> method.
    /// </remarks>
    void run()
    {
        #OCCRetryCount

        setPrefix(ProdMultiHistoricalCost::description());
        setPrefix(#PreFixField(ProdParmHistoricalCost,ProdId));

        try
        {
            using (var m = ProdInstrumentationSegmentFactory::create(ProdInstrumentationActivities::UpdateHistoricalCostRun, prodParmHistoricalCost.RecId))
            {
                ttsbegin;
                this.setParameters();
                
                if (isProdUpdProductionTypeTelemetryFlightEnabled)
                {
                    this.addInstrumentationAdditionalParametersToStopEvent(m);
                }

                if (!ProdTable.status().runHistoricalCost(prodParmHistoricalCost, true))
                {
                    throw error(strFmt("@SYP4882028", prodTable.ProdId));
                }

                if (countryRegion_RU)
                {
                    prodParametersDim           = prodTable.prodParametersDim();
                    calculatingWIP_RU           = prodParametersDim.CalculatingWIP_RU && ! prodTable.ProjId;
                    calculatingMethod_RU        = prodParametersDim.CalculatingMethod_RU;
                    endJob_RU                   = !calculatingWIP_RU || prodParmHistoricalCost.EndJob_RU;
                    useDatePhysicalMaxValue_RU  = calculatingWIP_RU && !endJob_RU;

                    if (!this.validate())
                    {
                        throw Exception::Error;
                    }
                }

                InventQualityManagementCreateHandler::createProductionEndBefore(prodTable);

                InventQualityManagementBlockHandler::blockProductionEnd(prodTable);

              

                if (countryRegion_RU)
                {
                    this.setParameters();
                }
                else if (!this.validate())
                {
                    throw Exception::Error;
                }

                if (! ProdJournalTable::checkNotMissingPosting(prodTable.ProdId,''))
                {
                    throw Exception::Error;
                }

                LedgerVoucher ledgerVoucher = this.newLedgerVoucher();
                LedgerVoucherObject ledgerVoucherObject = this.newLedgerVoucherObject(ledgerVoucher);


                if (!ProdTableJour::isHistoricalCost(prodTable.ProdId)) // do not change cost accounted productions from 3.0
                {
                    // Remove all indirect costs after the closing date
                    this.resetCalcValues();
                }
            
                this.initProdTableJour(ledgerVoucherObject.parmVoucher());
              
        
                this.updateBOMUnderconsumption(ledgerVoucher);
                this.updateBOMConsumption(ledgerVoucher);
                this.updateRouteConsumption(ledgerVoucher);
                this.updateIndirectCost(ledgerVoucher);
                if (countryRegion_RU)
                {
                    this.updateRelease_RU(ledgerVoucher);
                }
                this.updateProduction(ledgerVoucher);
                if (endJob_RU || !countryRegion_RU)
                {
                    this.updateJobJournal(ParmJobStatus::Executed);

                    // Shop Floor Control - Begin
                    if (Global::isConfigurationkeyEnabled(configurationKeyNum(Jmgjob)))
                    {
                        JmgJobTable::synchronizeProdTable(prodTable, true);
                        if (FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
                        {
                            JmgSerialNumberSpecification::deleteByProdId(prodTable.ProdId);
                        }
                    }
                    // Shop Floor Control - End
                }

                ledgerVoucher.end();

                this.projEnd();

                prodTableJour.insert();

                this.ledgerUpdateFinished(ledgerVoucher);

                if (endJob_RU || !countryRegion_RU)
                {
                    TransactionLog::create(TransactionLogType::ProdEnd,  strFmt("@SYS76498", prodTable.ProdId, "@SYS85535"));
                }

                InventQualityManagementCreateHandler::createProductionEndAfter(prodTable);
                
                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            this.updateJobJournal(ParmJobStatus::ContainErrors);
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParameters</Name>
				<Source><![CDATA[
    void setParameters()
    {
        this.initProdTablePessimisticLock();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerUpdateFinished</Name>
				<Source><![CDATA[
    public void ledgerUpdateFinished(LedgerVoucher _ledgerVoucher)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProdStandardVarianceList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>inventCostTransVarianceList</c> class that will be passed to the
    ///    inventory movement of the production order financial update.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher.
    /// </param>
    /// <param name="_movement">
    ///    The Inventory movement of the production order financial update.
    /// </param>
    protected void setProdStandardVarianceList(LedgerVoucher _ledgerVoucher, InventMovement _movement)
    {
        ProdStandardVarianceList prodStandardVarianceList = ProdStandardVarianceList::construct();
        prodStandardVarianceList.parmProdTable(prodTable);
        prodStandardVarianceList.parmProdQty(prodTableJour.QtyGood);        
        prodStandardVarianceList.parmProdTableJour(prodTableJour);
        prodStandardVarianceList.parmInventItemPrice(InventItemPrice::stdCostFindDate(prodTable.inventTable(),
                                                                                      _ledgerVoucher.lastTransDate(),
                                                                                      prodTable.InventDimId));
        if (prodStandardVarianceList.run(true) &&
            prodStandardVarianceList.inventCostTransVarianceList().length() > 0)
        {
            _movement.parmInventCostTransVarianceList(prodStandardVarianceList.inventCostTransVarianceList());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Makes the cost accounting for BOM component.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher.
    /// </param>
    /// <remarks>
    ///    New transactions for raw materials are created in General Ledger and then real costs are calculated for BOM components.
    /// </remarks>
    void updateBOMConsumption(LedgerVoucher _ledgerVoucher)
    {
        ProdBOM                     prodBOM;
        InventTransOriginProdBOM    inventTransOriginProdBOM;
        InventUpd_Financial         financial;
        InventTransIdSum            inventTransIdSum;

        setPrefix("@SYS28536");

        while select forupdate prodBOM
            where prodBOM.ProdId              == prodTableJour.ProdId &&
                  prodBOM.RemainBOMFinancial  != 0
            join InventTransOrigin from inventTransOriginProdBOM
                where inventTransOriginProdBOM.ProdBOMDataAreaId    == prodBOM.DataAreaId
                   && inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
        {
            using (var m = ProdInstrumentationSegmentFactory::create(ProdInstrumentationActivities::UpdateHistoricalCostBOMConsumption, prodBOM.RecId))
            {
                if (prodTable.isProjMethodConsumed())
                {
                    this.updateProjBOMConsumption(prodBOM);
                }
                else
                {
                    if (countryRegion_RU)
                    {
                        if (useDatePhysicalMaxValue_RU)
                        {
                            inventTransIdSum = InventTransIdSum_DataPhysical_RU::newDataPhysical(prodBOM.InventTransId, prodParmHistoricalCost.CalcDate);
                        }
                        else
                        {
                            inventTransIdSum = InventTransIdSum::newTransOriginId(inventTransOriginProdBOM.InventTransOrigin);
                        }

                        financial = InventUpd_Financial::newProdBOMHistoricalCost(prodBOM, _ledgerVoucher, inventTransIdSum, endJob_RU);
                        financial.parmDatePhysicalMaxValue_RU(useDatePhysicalMaxValue_RU ? prodParmHistoricalCost.CalcDate : dateNull());
                    }
                    else
                    {
                        financial = InventUpd_Financial::newProdBOMHistoricalCost(prodBOM,_ledgerVoucher, InventTransIdSum::newTransOriginId(inventTransOriginProdBOM.InventTransOrigin));
                    }
                    financial.updateNow();

                    this.updateCalcBOM(prodBOM, financial, _ledgerVoucher.lastTransDate());
                    prodTableJour.AmountFinancial -= CurrencyExchangeHelper::amount((financial.updCostAmountInvent() - financial.backDateCostAmountAdjustment()) * this.getRealBomConsumption(prodBOM, financial, 100.00) / (-financial.updFinancial()));

                    if (countryRegion_RU)
                    {
                        prodTableJour.AmountFinancialSecCur_RU -= CurrencyExchangeHelper::amount((financial.updCostAmountInventSecCur_RU() - financial.backDateCostAmountAdjustmentSecCur_RU()) * this.getRealBomConsumption(prodBOM, financial, 100.00) / (-financial.updFinancial()));
                    }
                }
            }
        }

        boolean skipUpdateNonePhysicalRemain = calculatingWIP_RU && !endJob_RU;

        if (!skipUpdateNonePhysicalRemain)
        {
            // Clean up remaining inventory that is not being consumed
            ProdBOM::updateNonePhysicalRemain(prodTableJour.ProdId);
            // Reread because Classes\ProdBOMType\update will update ProdTable.
            prodTable.reread();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMUnderconsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates inventory transactions when parent production orders underconsume their subproduction items.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object to which the postings must be added.
    /// </param>
    /// <remarks>
    ///    This method will handle the scenario when a parent production order that is using the consumed
    ///    method under consumes its subproduction items.Two inventory transactions will be created. The first
    ///    inventory transaction will consume the underconsumed subproduction items. The second inventory
    ///    transaction will post an income to project. Both inventory transactions are returned marked against
    ///    each other.
    /// </remarks>
    void updateBOMUnderconsumption(LedgerVoucher _ledgerVoucher)
    {
        ProdBOM                         prodBOM;

        ProdJournalBOM                  prodJournalBOMIncome;

        if (!prodTable.isProjMethodConsumed())
            return;

        while select forupdate prodBOM
            where prodBOM.ProdId == prodTable.ProdId &&
                prodBOM.InventRefType == InventRefType::Production &&
                prodBOM.RemainBOMFinancial  != 0
        {
            ProdTable prodTableRef = prodBOM.prodTableRef();
            if (prodTableRef.isProjMethodConsumed())
            {
                InventQty qtyUnderconsumed = prodTableRef.qtyUnderconsumed();
                if (qtyUnderconsumed)
                {
                    ProjInventJournalTransMapForm::updateOrCreateProdTableProj(prodTableRef, ProjItemTypeProdTable::Underconsumed, prodTableJour.TransDate, qtyUnderconsumed);
                    ProdTableProj prodTableProj = prodTableRef.prodTableProj(ProjItemTypeProdTable::Underconsumed, true);

                    //Financial update to consume the sub-production items that were under-consumed by the parent production order.
                    InventMovement movement = InventMov_Virtuel::newProdUnderconsume(
                                                                       prodBOM,
                                                                       prodTableJour.TransDate,
                                                                       qtyUnderconsumed);

                    InventUpd_Financial financial = InventUpd_Financial::newProdUnderconsume(
                                                                            movement,
                                                                            qtyUnderconsumed,
                                                                            prodBOM.calcCostAmount(qtyUnderconsumed),
                                                                            _ledgerVoucher,
                                                                            _ledgerVoucher.lastVoucher());

                    if (countryRegion_RU)
                    {
                        financial.parmCostAmountCurSecCur_RU(prodBOM.calcCostAmountSecCur_RU(qtyUnderconsumed));
                    }
                    financial.updateNow();

                    //Create new prodBOM record for the financial update that will post an income to the project.
                    prodJournalBOMIncome.clear();
                    prodJournalBOMIncome.initValue();
                    prodJournalBOMIncome.ProdId = prodBOM.ProdId;
                    prodJournalBOMIncome.ItemId = prodBOM.ItemId;
                    prodJournalBOMIncome.initFromInventTable(prodBOM.inventTable());
                    prodJournalBOMIncome.createProdBOM();
                    ProdBOM prodBOMIncome = prodJournalBOMIncome.prodBOM();

                    //Financial update to post an income to the project for the under-consumption.
                    InventMovement movementIncome = InventMov_Virtuel::newProdUnderconsumeProjIncome(
                                                                               prodBOMIncome,
                                                                               prodBOM,
                                                                               prodTableJour.TransDate,
                                                                               -qtyUnderconsumed);

                    InventUpd_Financial financialIncome = InventUpd_Financial::newProdUnderconsume(
                                                                                    movementIncome,
                                                                                    -qtyUnderconsumed,
                                                                                    -financial.updCostAmountLedger(),
                                                                                    _ledgerVoucher);
                    financialIncome.updateNow();

                    if (!ProjPost::newCheckTrans(prodTableProj).checkTrans())
                    {
                        throw Exception::Error;
                    }

                    ProjPost::newCreateProjTransItem(prodTableProj,
                                                     _ledgerVoucher,
                                                     financialIncome.movement().projAdjustRefId(),
                                                     false,
                                                     movementIncome.transId()).postTrans();
                }
                else
                {
                    prodTableRef.deleteProdTableProj(ProjItemTypeProdTable::Underconsumed);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCalcBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cost calculation for a BOM.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production BOM.
    /// </param>
    /// <param name="_financial">
    /// The inventory financial update object.
    /// </param>
    /// <param name="_priceDate">
    /// The date for price calculation; optional.
    /// </param>
    /// <returns>
    /// A container with 2 elemets, first one is the calculated cost in the main currency, the second element is the cost in the secondary currency.
    /// </returns>
    /// <remarks>
    /// The return type has been changed to a container to return calculated cost in the secondary currency in addition to the cost in the main currency.
    /// </remarks>
    public container updateCalcBOM(
        ProdBOM             _prodBOM,
        InventUpd_Financial _financial,
        TransDate           _priceDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
        )
    {
        InventItemPrice     inventItemPrice;
        CostGroupId         costGroupId;
        CostAmount          costAmount;
        CostAmount          costAmountSec;

        setPrefix(#PreFixField(_prodBOM,ItemId));

        InventTable inventTableChild = _prodBOM.inventTable();

        ItemCalcType calcType = inventTableChild.inventItemType().calculationType();

        ProdCalcTrans prodCalcTrans = ProdCalcTrans::findIdRefCalcType(_prodBOM.TableId, _prodBOM.RecId, calcType, true);

        // For std cost item, find the itemprice that needs to be applied
        if (inventTableChild.modelGroup().inventModelType().stdCostBased())
        {
            inventItemPrice = InventItemPrice::stdCostFindDate(inventTableChild, _priceDate, _prodBOM.InventDimId);

            // Now get the costGroup from the inventItemCostGroupRollup table
            costGroupId = inventItemPrice.costGroupId();
        }
        else
        {
            costGroupId = inventTableChild.costGroup();
        }

        if (! prodCalcTrans.RecId)
        {
            prodCalcTrans.initFromProdTable(prodTable, calcType);
            prodCalcTrans.initFromProdBOM(_prodBOM);

            prodCalcTrans.Production        = NoYes::No;

            if (countryRegion_RU                                               &&
                inventTableChild.modelGroup().inventModelType().stdCostBased() &&
                InventParameters::isCostBreakdownActivated())
            {
                prodCalcTrans.bom           = inventTableChild.inventItemType().canHaveBOM();
            }
            else
            {
                prodCalcTrans.bom               = NoYes::No;
            }

            prodCalcTrans.Resource      = inventTableChild.ItemId;
            prodCalcTrans.UnitId        = InventTableModule::find(inventTableChild.ItemId,ModuleInventPurchSales::Invent).UnitId;
            prodCalcTrans.OprId         = '';
            prodCalcTrans.BOMCalcTransMap::setInventDimStr(_prodBOM.InventDimId);
            prodCalcTrans.InventDimId   = _prodBOM.InventDimId;
            prodCalcTrans.CalcGroupId   = inventTableChild.bomCalcGroup().CalcGroupId;
            prodCalcTrans.CostGroupId   = costGroupId;
            prodCalcTrans.LineNum       = ProdCalcTrans::lastLineNum(prodTable.ProdId, ProdTransRefType::Production) + 1;
        }

        Qty realBomConsumptionAfterAllocation = this.getRealBomConsumption(_prodBOM, _financial, this.allocationPercentMainItem() );
        prodCalcTrans.RealConsump     =  prodCalcTrans.RealConsump + realBomConsumptionAfterAllocation;

        // For std cost item get current cost price
        if (!_financial.movement().inventModelType().stdCostBased())
        {
            costAmount = _financial.updCostAmountInvent();
        }
        else
        {
            if (_financial.updFinancial() != 0)
            {
                costAmount = _financial.movement().inventModelType().inventCostMovement().totalCostAmount() * this.getRealBomConsumption(_prodBOM, _financial, 100.00) / (-_financial.updFinancial());
            }
            else
            {
                costAmount = 0;
            }

            prodCalcTrans.CostGroupId     =  costGroupId;
        }
        
        if (countryRegion_RU)
        {
            if (!_financial.movement().inventModelTypeSecCur_RU().stdCostBased())
            {
                costAmountSec = _financial.updCostAmountInventSecCur_RU();
            }
            else
            {
                if (_financial.updFinancial() != 0)
                {
                    costAmountSec = _financial.movement().inventModelTypeSecCur_RU().inventCostMovement().totalCostAmountSecCur_RU();
                }
                else
                {
                    costAmountSec = 0;
                }
            }
        }

        if (prodTable.ProdType == ProdType::Process)
        {
            prodCalcTrans.RealCostAmount  =  prodCalcTrans.RealCostAmount  - (costAmount * this.allocationPercentMainItem()/100);
        }
        else
        {
            prodCalcTrans.RealCostAmount  =  prodCalcTrans.RealCostAmount  - costAmount;
        }

        if (countryRegion_RU)
        {
            prodCalcTrans.write();
        }

        ProdCalcTrans::updateRealCalcCostBreakdown(prodCalcTrans, inventItemPrice);

        if (! countryRegion_RU)
        {
            prodCalcTrans.write();
        }

        return [ costAmount, costAmountSec ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCalcProduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates total achieved cost amount for a production order.
    /// </summary>
    /// <remarks>
    ///    This method takes total achieved cost amount of production order from <c>InventUpd_Financial</c> class and inserts it to the price calculation table.
    /// </remarks>
    void updateCalcProduction()
    {
        ItemCalcType calcType = ItemCalcType::Production;

        ProdCalcTrans prodCalcTrans = ProdCalcTrans::findIdRefCalcType(prodTable.TableId, prodTable.RecId, calcType, true);

        if (! prodCalcTrans.RecId)
        {
            InventTable inventTable = prodTable.inventTable();
            InventTableModule inventTableModuleInvent = inventTable.inventTableModuleInvent();
            prodCalcTrans.initFromProdTable(prodTable, calcType);

            prodCalcTrans.Production    = NoYes::Yes;
            prodCalcTrans.bom           = NoYes::Yes;
            prodCalcTrans.Resource      = prodTable.ItemId;
            prodCalcTrans.UnitId        = inventTableModuleInvent.UnitId;
            prodCalcTrans.OprId         = '';
            prodCalcTrans.BOMCalcTransMap::setInventDimStr(prodTable.InventDimId);
            prodCalcTrans.InventDimId   = prodTable.InventDimId;

            prodCalcTrans.CalcGroupId        = inventTable.bomCalcGroup().CalcGroupId;
            prodCalcTrans.CostGroupId        = inventTable.costGroup();
            prodCalcTrans.LineNum            = ProdCalcTrans::lastLineNum(prodTable.ProdId, ProdTransRefType::Production) + 1;
        }

        this.onUpdateProdCalculation(prodCalcTrans);

        prodCalcTrans.RealQty                += prodTableJour.QtyGood;
        prodCalcTrans.RealCostAmount         += totalCostAmount;

        prodCalcTrans.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCalcRefProduction</Name>
				<Source><![CDATA[
    void updateCalcRefProduction(ProdTable  _prodTable)
    {
        ProdBOM         prodBOM;
        PriceDate       priceDate;

        if ((!_prodTable.RecId || !_prodTable.InventRefId) && _prodTable.InventRefType != InventRefType::ProdLine)
        {
            return;
        }

        select  prodBOM
            where   prodBOM.ProdId == _prodTable.InventRefId &&
                    prodBOM.InventRefType == InventRefType::Production &&
                    prodBOM.InventRefTransId == _prodTable.InventTransId &&
                    prodBOM.InventRefId == _prodTable.ProdId;

        if (!prodBOM.RecId)
        {
            return;
        }

        ProdTable parentProdTable = ProdTable::find(_prodTable.InventRefId);

        if (ProdTableJour::isHistoricalCost(parentProdTable.ProdId))
        {
            return;
        }

        // if the item that is currently updated is a std cost item
        // check for future cost prices
        if (prodBOM.inventTable().modelGroup().inventModelType().stdCostBased())
        {
            // Find the last cost price, revaluation entries to this date have been created
            priceDate = dateMax();
        }
        else
        {
            priceDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        ProdCalcTrans::updateRealCalcBOM(parentProdTable, prodBOM, priceDate);
        ProdCalcTrans::updateRealCalcProduction(parentProdTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>indirectProductionItemCalcTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the indirect item calculation types for production.
    /// </summary>
    /// <returns>A container with the item calculation types.</returns>
    protected container indirectProductionItemCalcTypes()
    {
        return [ItemCalcType::IndirectRate,
                ItemCalcType::IndirectSurcharge,
                ItemCalcType::IndirectInUnitBased,
                ItemCalcType::IndirectOutUnitBased];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRealCalcIndirect</Name>
				<Source><![CDATA[
    [Replaceable]
    protected CostCalcTransData updateRealCalcIndirect(LedgerVoucher _ledgerVoucher)
    {
        return ProdCalcTrans::updateRealCalcIndirect(prodTable, true, _ledgerVoucher.lastTransDate(), _ledgerVoucher.lastVoucher(), calculatingWIP_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIndirectCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the indirect cost records, reverts the indirect WIP and posts the realized amounts to the absorption accounts.
    /// </summary>
    /// <param name="_ledgerVoucher">An instance of the <c>LedgerVoucher</c> class that handles posting to ledger.</param>
    void updateIndirectCost(LedgerVoucher _ledgerVoucher)
    {
        ProdCalcTrans               prodCalcTrans;
        ProdIndirectTrans           prodIndirectTrans;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        boolean                     correction_RU;

        // update realized amounts - both in ProdCalcTrans and ProdIndirectTrans
        CostCalcTransData costCalcTransData = this.updateRealCalcIndirect(_ledgerVoucher);
        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

        // use the costCalcTransData object return from the actual costing sheet calculation to restrict the number of nodes loaded
        CostSheet costSheet = CostSheetFactory::construct().createCostSheet(CostSheetModeStrategyCalculate::newParameter(CostPriceType::COGM, costCalcTransData));

        if (countryRegion_RU)
        {
            correction_RU = _ledgerVoucher.findLedgerVoucherObject().parmCorrection() || InventParameters::find().StornoPhysicalPosting_RU;

            if (calculatingWIP_RU)
            {
                prodCalcTrans.selectForUpdate(true);
            }
        }

        totalCostAmount = prodTableJour.AmountFinancial;

        // add transactions to the voucher
        while select prodCalcTrans
            where prodCalcTrans.TransRefId   == prodTable.ProdId
               && prodCalcTrans.TransRefType == ProdTransRefType::Production
               && (! useDatePhysicalMaxValue_RU || prodCalcTrans.TransDate <= prodParmHistoricalCost.CalcDate)
               && prodCalcTrans.CalcType in this.indirectProductionItemCalcTypes()
        {
            CostSheetNodeCalculation calculationNode = costSheet.findNodeByCode(prodCalcTrans.Resource);

            if (calculationNode == null)
            {
                continue;
            }

            AmountMST indirectCostAmount = CurrencyExchangeHelper::amount(prodCalcTrans.realCostAmountTotal());
            if (calculatingWIP_RU)
            {
                indirectCostAmount -= prodCalcTrans.FinancialIndirectAmount_RU;
            }

            // Also negative indirect costs can occur
            if (indirectCostAmount != 0.00
             && (!countryRegion_RU || prodCalcTrans.mustIndirectCostPosted_RU())
             && calculationNode.getAcctEstimatedIndirectAbsorption()
             && calculationNode.getAcctEstimatedIndirectAbsorptionOffset()
             && calculationNode.getAcctIndirectAbsorption()
             && calculationNode.getAcctIndirectAbsorptionOffset())
            {
                prodTableJour.AmountFinancial += CurrencyExchangeHelper::amount(prodCalcTrans.realCostAmountTotal());
                totalCostAmount += prodCalcTrans.realCostAmountTotal();

                if (calculatingWIP_RU)
                {
                    prodTableJour.AmountFinancial            -= prodCalcTrans.FinancialIndirectAmount_RU;
                    prodCalcTrans.FinancialIndirectAmount_RU += indirectCostAmount;
                    prodCalcTrans.update();
                }
                DimensionDefault defaultDimension = prodIndirectTrans.mergeDimension(calculationNode.getDefaultDimension(), prodTable.DefaultDimension);
                ledgerVoucherTransObject =
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                    _ledgerVoucher.findLedgerVoucherObject(),
                    LedgerPostingType::IndirectAbsorption,
                    LedgerDimensionFacade::serviceCreateLedgerDimension(calculationNode.getAcctIndirectAbsorption(), defaultDimension),
                    CompanyInfoHelper::standardCurrency(),
                    -indirectCostAmount,
                    exchangeRateHelper);
                if (countryRegion_RU && indirectCostAmount < 0)
                {
                    ledgerVoucherTransObject.parmCorrect(correction_RU);
                }

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                ledgerVoucherTransObject =
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        _ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::IndirectAbsorptionOffset,
                        LedgerDimensionFacade::serviceCreateLedgerDimension(calculationNode.getAcctIndirectAbsorptionOffset(), defaultDimension),
                        CompanyInfoHelper::standardCurrency(),
                        indirectCostAmount,
                        exchangeRateHelper);
                if (countryRegion_RU && indirectCostAmount < 0)
                {
                    ledgerVoucherTransObject.parmCorrect(correction_RU);
                }

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                if (countryRegion_RU)
                {
                    _ledgerVoucher.bondLast2_RU();
                }
            }
        }

        TransDate transDate = _ledgerVoucher.lastTransDate();

        // Revert posted WIP transactions on this production order for previous vouchers;
        // remember that ProdIndirectTrans has already been updated in ProdCalcTrans::updateRealCalcIndirect()
        while select forupdate prodIndirectTrans
            where prodIndirectTrans.TransRefId          == prodTable.ProdId
               && prodIndirectTrans.TransRefType        == ProdTransRefType::Production
               && prodIndirectTrans.VoucherEstimation   != _ledgerVoucher.lastVoucher()
               && prodIndirectTrans.Posted              == NoYes::Yes
               && (! useDatePhysicalMaxValue_RU || prodIndirectTrans.DateEstimation <= prodParmHistoricalCost.CalcDate)
               && (! calculatingWIP_RU          || prodIndirectTrans.Calculated     == NoYes::No)
        {
            if (countryRegion_RU)
            {
                if (calculatingWIP_RU)
                {
                    prodIndirectTrans.Calculated = NoYes::Yes;
                    prodIndirectTrans.update();
                }

                if (prodIndirectTrans.mustIndirectCostPosted_RU() == NoYes::No)
                {
                    continue;
                }
            }
            if (FeatureStateProvider::isFeatureEnabled(InventoryReportingCurrencyTriangulationFeature::instance()))
            {
                exchangeRateHelper = InventoryReportingCurrencyTriangulationHelper::getReversalCurrencyExchangeHelperFromGL(
                    exchangeRateHelper,
                    LedgerPostingType::IndirectEstimatedAbsorption,
                    prodIndirectTrans.VoucherEstimation,
                    prodIndirectTrans.DataAreaId,
                    prodIndirectTrans.DateEstimation,
                    CompanyInfoHelper::standardCurrency());
            }
            else
            {
                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                    Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                    max(prodIndirectTrans.DateEstimation, transDate));
            }
            // Reverse indirect cost posted on estimation accounts with original amount, account and dimension.
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                        _ledgerVoucher.findLedgerVoucherObject(),
                                        LedgerPostingType::IndirectEstimatedAbsorption,
                                        prodIndirectTrans.EstimatedIndirectAbsorpLedgerDimension,
                                        CompanyInfoHelper::standardCurrency(),
                                        CurrencyExchangeHelper::amount(prodIndirectTrans.Amount),
                                        exchangeRateHelper);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            if (countryRegion_RU && prodIndirectTrans.Amount > 0)
            {
                ledgerVoucherTransObject.parmCorrect(correction_RU);
            }
            // Posting should occur either on the day it was made or on the ending date
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // Offset Account
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                        _ledgerVoucher.findLedgerVoucherObject(),
                                        LedgerPostingType::IndirectEstimatedAbsorptionOffset,
                                        prodIndirectTrans.EstimIndirectAbsorpOffsetLedgerDimension,
                                        CompanyInfoHelper::standardCurrency(),
                                        -CurrencyExchangeHelper::amount(prodIndirectTrans.Amount),
                                        exchangeRateHelper);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            if (countryRegion_RU && prodIndirectTrans.Amount > 0)
            {
                ledgerVoucherTransObject.parmCorrect(correction_RU);
            }

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (countryRegion_RU)
            {
                _ledgerVoucher.bondLast2_RU();
            }
        }

        _ledgerVoucher.lastTransDate(transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Makes the cost accounting for a production order.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher.
    /// </param>
    /// <remarks>
    ///    New transactions for a production order are created in General Ledger and then the total realized cost amount is calculated.
    /// </remarks>
    void updateProduction(LedgerVoucher _ledgerVoucher)
    {
        InventMovement              movement = InventMovement::construct(prodTable);

        ProdRouteTrans              prodRouteTrans;
        boolean                     prevCorrection_RU;
        InventTransIdSum            transIdSum = InventTransIdSum::newTransOriginId(movement.inventTransOriginId());
        InventTable                 inventTable = InventTable::find(prodTable.ItemId);
        InventTransOrigin           inventTransOrigin;
        InventTrans                 inventTrans;

        if (countryRegion_RU)
        {
            if (calculatingWIP_RU)
            {
                this.updateWIPProduction_RU(_ledgerVoucher);
                return;
            }

            prevCorrection_RU = _ledgerVoucher.findLedgerVoucherObject().parmCorrection();
        }

        setPrefix("@SYS28546");

        prodTableJour.QtyGood = transIdSum.physical();

        this.updateCalcProduction();

        prodTable.RealDate = prodParmHistoricalCost.CalcDate;

        this.postScrap(_ledgerVoucher);

        if (countryRegion_RU)
        {
            movement.parmStornoPhysical_RU(InventParameters::find().StornoPhysicalPosting_RU);
        }

        if (prodTableJour.QtyGood != 0)
        {
            // round the AmountFinancial before passing it into the inventory engine
            prodTableJour.AmountFinancial = CurrencyExchangeHelper::amount(prodTableJour.AmountFinancial);

            if (prodTable.isProjMethodFinished() || prodTable.isProjMethodConsumed())
            {
                if (countryRegion_RU)
                {
                    _ledgerVoucher.findLedgerVoucherObject().parmCorrection(prevCorrection_RU);
                }

                this.updateProjProduction(_ledgerVoucher, transIdSum);
            }
            else
            {
                prodTable.update();
                this.setProdStandardVarianceList(_ledgerVoucher, movement);

                if (countryRegion_RU)
                {
                    while select sum(Amount) from prodRouteTrans
                        group by DateCalc
                        where prodRouteTrans.TransRefId == prodTable.ProdId &&
                              prodRouteTrans.Calculated == NoYes::Yes
                    {
                        prodTableJour.AmountFinancialSecCur_RU += CurrencyExchangeHelper::amountMST2MSTSecond_RU(prodRouteTrans.Amount, prodRouteTrans.DateCalc);
                    }
                }

                // Pass the movement, so that the variance list can be passed
                InventUpd_Financial financial = InventUpd_Financial::newProdTableHistoricalCost(prodTable,_ledgerVoucher,transIdSum,prodTableJour, movement);

                financial.updateNow();

                prodTableJour.AmountFinancial = financial.updCostAmountLedger();

                if (countryRegion_RU)
                {
                    prodTableJour.AmountFinancialSecCur_RU = financial.updCostAmountSecCurLedger_RU();
                }
            }
        }
        else
        if (prodTableJour.AmountFinancial != 0)
        {
            if (inventTable.CostModel)
            {
                select TableId from inventTransOrigin
                    where inventTransOrigin.InventTransId       == prodTableJour.InventTransId
                        join sum(Qty), sum(CostAmountPosted), sum(CostAmountAdjustment),
                             sum(CostAmountSecCurPosted_RU), sum (CostAmountSecCurAdjustment_RU) from inventTrans
                            where inventTrans.InventTransOrigin     == inventTransOrigin.RecId
                               && inventTrans.StatusReceipt         == StatusReceipt::Purchased
                               && inventTrans.StatusIssue           == StatusIssue::None
                               && inventTrans.PackingSlipReturned   == NoYes::No;

                inventTable.updateLastCostPrice(inventTrans.costValue(),inventTrans.Qty,prodParmHistoricalCost.CalcDate,prodTable.inventDim());

                if (countryRegion_RU)
                {
                    inventTable.updateLastCostPriceSecCur_RU(inventTrans.costValueSecCur_RU(), inventTrans.Qty, prodParmHistoricalCost.CalcDate, prodTable.inventDim());
                }
            }
        }

        prodTable.SchedStatus  = ProdSchedStatus::None;

        prodTable.ProdStatus   = ProdStatus::Completed;
        prodTable.update();

        WrkCtrCapResHandler::construct().deleteOrderReservations(WrkCtrCapRefType::Production, prodTable.ProdId);

        this.addUpdateRec(prodTable);

        this.updateCalcRefProduction(prodTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjBOMConsumption</Name>
				<Source><![CDATA[
    private void updateProjBOMConsumption(ProdBOM _prodBOM)
    {
        InventUpd_Financial                 financial;
        ProdBOMTransProj                    prodBOMTransProj;
        LedgerVoucher                       ledgerVoucherProj;
        InventQty                           inventConsump;
        UnitQty                             bomConsump;
        InventQty                           inventConsumpFromInventory;
        UnitQty                             bomConsumpFromInventory;
        InventMovement                      movement;
        Map                                 ledgerVoucherMap;
        CostAmount                          costAmount;
        CostAmount                          costAmountSec;

        LedgerVoucher getLedgerVoucher(InventMovement _movement)
        {
            container           key;
            Voucher             voucher;
            InventTransId       inventTransId = _movement.transId();
            LedgerPostingType   postingBalanceSheet = _movement.postingBalanceSheet();
            LedgerDimensionDefaultAccount       accountBalanceSheet = _movement.accountBalanceSheet();
            LedgerPostingType   postingOperations = _movement.postingOperations();
            LedgerDimensionDefaultAccount       accountOperations = _movement.accountOperations();
            LedgerVoucher       ledgerVoucherLocal;

            key = [inventTransId,
                    postingBalanceSheet,
                    accountBalanceSheet,
                    postingOperations,
                    accountOperations];

            if (ledgerVoucherMap.exists(key))
            {
                ledgerVoucherLocal = ledgerVoucherMap.lookup(key);
            }
            else
            {
                ledgerVoucherLocal = this.newLedgerVoucher();
                voucher = NumberSeq::newGetNum(ProdParameters::numRefProdCalcVoucherId()).num();
                this.newLedgerVoucherObject(ledgerVoucherLocal, voucher);
                ledgerVoucherMap.insert(key, ledgerVoucherLocal);
            }

            return ledgerVoucherLocal;
        }

        ProdTable prodTableRef = _prodBOM.prodTableRef();
        ledgerVoucherMap = new Map(Types::Container, Types::Class);

        while select prodBOMTransProj
            where prodBOMTransProj.InventTransId == _prodBOM.InventTransId
        {
            InventTransIdSum_VoucherPhysical inventTransIdSum = InventTransIdSum_VoucherPhysical::newVoucherPhysical(InventTransOriginProdBOM::findInventTransOriginId(_prodBOM.DataAreaId, _prodBOM.InventTransId),
                prodBOMTransProj.Voucher);

            if (inventTransIdSum.physical())
            {
                if (_prodBOM.InventRefType == InventRefType::Production)
                {
                    if (prodTableRef.isProjMethodConsumed())
                    {
                        //Values for items that are taken from inventory
                        inventConsumpFromInventory = prodBOMTransProj.inventConsumpFromInventory();
                        bomConsumpFromInventory = prodBOMTransProj.calcBOMConsump(inventConsumpFromInventory);

                        //Values for items that are taken from child production
                        inventConsump = prodBOMTransProj.inventConsumpFromSubProduction();
                        bomConsump = prodBOMTransProj.calcBOMConsump(inventConsump);
                    }
                    else
                    {
                        inventConsumpFromInventory = 0;
                        bomConsumpFromInventory = 0;

                        inventConsump = prodBOMTransProj.inventConsumpTotal();
                        bomConsump = prodBOMTransProj.calcBOMConsump(inventConsump);
                    }
                }
                else
                {
                    inventConsumpFromInventory = 0;
                    bomConsumpFromInventory = 0;

                    inventConsump = prodBOMTransProj.inventConsumpTotal();
                    bomConsump = prodBOMTransProj.calcBOMConsump(inventConsump);
                }

                if (_prodBOM.InventRefType == InventRefType::Production && prodTableRef.isProjMethodConsumed())
                {
                    //Values for items that are taken from child production are financially updated such that the
                    //Operations and Balance sheet will cancel out
                    InventMovement movementReverse = prodBOMTransProj.inventMovementReverse();

                    ledgerVoucherProj = getLedgerVoucher(movementReverse);

                    financial = InventUpd_Financial::newProdBOMTransProjHistoricalCost(
                                                        movementReverse,
                                                        _prodBOM,
                                                        prodBOMTransProj,
                                                        inventConsump,
                                                        bomConsump,
                                                        ledgerVoucherProj);

                    financial.parmMarkingRefInventTransOrigin(InventTransOrigin::findByInventTransId(_prodBOM.InventRefTransId).RecId);
                }
                else
                {
                    movement = InventMovement::construct(prodBOMTransProj);

                    ledgerVoucherProj = getLedgerVoucher(movement);

                    financial = InventUpd_Financial::newProdBOMTransProjHistoricalCost(
                                                        movement,
                                                        _prodBOM,
                                                        prodBOMTransProj,
                                                        inventConsump,
                                                        bomConsump,
                                                        ledgerVoucherProj);
                }

                if (inventConsump)
                {
                    financial.updateNow();

                    [ costAmount, costAmountSec ] = this.updateCalcBOM(_prodBOM, financial, ledgerVoucherProj.lastTransDate());

                    prodTableJour.AmountFinancial-= costAmount;
                    if (countryRegion_RU)
                    {
                        prodTableJour.AmountFinancialSecCur_RU -= costAmountSec;
                    }
                }

                //Values for items that are taken from inventory are posted to project as costs
                if (_prodBOM.InventRefType == InventRefType::Production && prodTableRef.isProjMethodConsumed() && inventConsumpFromInventory)
                {
                    movement = InventMovement::construct(prodBOMTransProj);

                    ledgerVoucherProj = getLedgerVoucher(movement);

                    InventUpd_Financial financialProj = InventUpd_Financial::newProdBOMTransProjHistoricalCost(
                                                                                movement,
                                                                                _prodBOM,
                                                                                prodBOMTransProj,
                                                                                inventConsumpFromInventory,
                                                                                bomConsumpFromInventory,
                                                                                ledgerVoucherProj);

                    financialProj.updateNow();

                    if (!ProjPost::newCheckTrans(prodBOMTransProj).checkTrans())
                        throw Exception::Error;

                    [ costAmount, costAmountSec ] = this.updateCalcBOM(_prodBOM, financialProj, ledgerVoucherProj.lastTransDate());

                    ProjPost::newCreateProjTransItem(prodBOMTransProj, ledgerVoucherProj, financialProj.movement().projAdjustRefId()).postTrans();

                    prodTableJour.AmountFinancial-= costAmount;

                    if (countryRegion_RU)
                    {
                        prodTableJour.AmountFinancialSecCur_RU -= costAmountSec;
                    }
                }
            }
        }

        MapEnumerator mapEnumerator = ledgerVoucherMap.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            ledgerVoucherProj = mapEnumerator.currentValue();
            ledgerVoucherProj.end();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjProduction</Name>
				<Source><![CDATA[
    private void updateProjProduction(LedgerVoucher _ledgerVoucher, InventTransIdSum transIdSum)
    {
        InventMovement          movement = InventMovement::construct(prodTable);
        AmountCur               costAmountCur;
        InventQty               financialInventQty;
        InventQty               remainPhysicalInventQty;

        AmountCur               costAmountCurSplit;
        InventQty               financialInventQtySplit;
        InventQty               remainPhysicalInventQtySplit;
        InventUpd_Financial     financialSplit;

        AmountCur               costAmountCurSec;
        AmountCur               costAmountCurSplitSec;

        InventQty overDelivery = -prodTable.overDelivery();

        if (overDelivery)
        {
            financialInventQty = transIdSum.physical() - overDelivery;
            if (transIdSum.physical())
            {
                costAmountCur  = CurrencyExchangeHelper::amount(prodTableJour.AmountFinancial / transIdSum.physical() * financialInventQty, '');
                if (countryRegion_RU)
                {
                    costAmountCurSec = CurrencyExchangeHelper::amount(prodTableJour.AmountFinancialSecCur_RU / transIdSum.physical() * financialInventQty, CompanyInfoHelper::secondaryCurrency_RU());
                }
            }
            if (prodTable.status().isBefore(ProdStatus::ReportedFinished))
            {
                if (transIdSum.physical())
                {
                    remainPhysicalInventQty  = ((prodTable.RemainInventPhysical / transIdSum.physical()) * financialInventQty);
                }
            }

            financialInventQtySplit = overDelivery;
            costAmountCurSplit = prodTableJour.AmountFinancial - costAmountCur;

            if (countryRegion_RU)
            {
                costAmountCurSplitSec = prodTableJour.AmountFinancialSecCur_RU - costAmountCurSec;
            }
            if (prodTable.status().isBefore(ProdStatus::ReportedFinished))
            {
                remainPhysicalInventQtySplit = prodTable.RemainInventPhysical - remainPhysicalInventQty;
            }

            this.updateProjProductionSplit(_ledgerVoucher, movement, financialInventQtySplit);
        }
        else
        {
            financialInventQty = transIdSum.physical();
            costAmountCur = prodTableJour.AmountFinancial;

            if (countryRegion_RU)
            {
                costAmountCurSec = prodTableJour.AmountFinancialSecCur_RU;
            }
            if (prodTable.status().isBefore(ProdStatus::ReportedFinished))
            {
                remainPhysicalInventQty = prodTable.RemainInventPhysical;
            }

            financialInventQtySplit = 0;
            costAmountCurSplit = 0;

            if (countryRegion_RU)
            {
                costAmountCurSplitSec = 0;
            }
            remainPhysicalInventQtySplit = 0;
        }

        if (prodTable.isProjMethodFinished())
        {
            if (!ProjPost::newCheckTrans(prodTable).checkTrans())
            {
                throw Exception::Error;
            }
        }

        this.setProdStandardVarianceList(_ledgerVoucher, movement);

        InventUpd_Financial financial = InventUpd_Financial::newProjProdTableHistoricalCost(
                                                                movement,
                                                                _ledgerVoucher,
                                                                financialInventQty,
                                                                remainPhysicalInventQty,
                                                                costAmountCur);

        if (countryRegion_RU)
        {
            financial.parmCostAmountCurSecCur_RU(costAmountCurSec);
        }
        financial.updateNow();

        if (overDelivery)
        {
            ProjInventJournalTransMapForm::updateOrCreateProdTableProj(prodTable, ProjItemTypeProdTable::Overdelivery, _ledgerVoucher.lastTransDate());
            ProdTableProj prodTableProj = prodTable.prodTableProj(ProjItemTypeProdTable::Overdelivery);
            InventMovement inventMovementProj = prodTable.inventMovementProj(prodTableProj);
            this.setProdStandardVarianceList(_ledgerVoucher, inventMovementProj);

            financialSplit = InventUpd_Financial::newProjProdTableHistoricalCost(
                                                            inventMovementProj,
                                                            _ledgerVoucher,
                                                            financialInventQtySplit,
                                                            remainPhysicalInventQtySplit,
                                                            costAmountCurSplit);

            if (countryRegion_RU)
            {
                financialSplit.parmCostAmountCurSecCur_RU(costAmountCurSplitSec);
            }

            LedgerVoucher ledgerVoucherSplit = this.newLedgerVoucher();
            this.newLedgerVoucherObject(ledgerVoucherSplit);
            financialSplit.parmLedgerVoucher(ledgerVoucherSplit);

            financialSplit.updateNow();

            if (prodTable.isProjMethodConsumed())
            {
                if (!ProjPost::newCheckTrans(prodTableProj).checkTrans())
                {
                    throw Exception::Error;
                }

                ProjPost::newCreateProjTransItem(prodTableProj,
                                                 ledgerVoucherSplit,
                                                 financialSplit.movement().projAdjustRefId(),
                                                 false,
                                                 financialSplit.movement().transId()).postTrans();
            }

            ledgerVoucherSplit.end();
        }
        else
        {
            prodTable.deleteProdTableProj(ProjItemTypeProdTable::Overdelivery);
        }

        prodTableJour.AmountFinancial = financial.updCostAmountLedger();

        if (countryRegion_RU)
        {
            prodTableJour.AmountFinancialSecCur_RU = financial.updCostAmountSecCurLedger_RU();
        }

        if (overDelivery)
        {
            prodTableJour.AmountFinancial += financialSplit.updCostAmountLedger();
            if (countryRegion_RU)
            {
                prodTableJour.AmountFinancialSecCur_RU += financialSplit.updCostAmountSecCurLedger_RU();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjProductionSplit</Name>
				<Source><![CDATA[
    private void updateProjProductionSplit(LedgerVoucher _ledgerVoucher, InventMovement _movement, InventQty _remainFinancialInventQty)
    {
        if (!_movement.hasVirtualTransactions())
        {
            return;
        }

        InventUpd_Physical::newProdAutoLossProfit(_movement, _remainFinancialInventQty).updateNow(_ledgerVoucher);

        InventMov_Virtuel movement_Virtuel = InventMov_Virtuel::newProjProductionSplit(_movement, 0);
        InventMov_Virtuel movement_VirtuelOrig = InventMov_Virtuel::newProjProductionSplit(_movement, -_remainFinancialInventQty);
        movement_Virtuel.parmInventMovVirtuelOrig(movement_VirtuelOrig);

        InventUpd_Estimated estimated_Virtuel = InventUpd_Estimated::newInventMovement(movement_Virtuel);
        estimated_Virtuel.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelease_RU</Name>
				<Source><![CDATA[
    public void updateRelease_RU(LedgerVoucher _ledgerVoucher)
    {
        InventUpd_Financial financial, financialScrap;

        ProdReleaseTrans_RU prodReleaseTrans,
                            offsetProdReleaseTrans;

        Price               totalPrice;

        if (prodTable.useReleaseFromProduction_RU())
        {
            setPrefix("@GLS115790");

            while select forupdate prodReleaseTrans
                where prodReleaseTrans.ProdId       == prodTable.ProdId &&
                      prodReleaseTrans.Calculated   == NoYes::No        &&
                      prodReleaseTrans.Cancelled    == NoYes::No        &&
                      (!useDatePhysicalMaxValue_RU  || prodReleaseTrans.DateWIP <= prodParmHistoricalCost.CalcDate)
            {
                if (prodReleaseTrans.OffsetRefRecId)
                {
                    totalPrice                          = -ProdReleaseTrans_RU::findRecId(prodReleaseTrans.OffsetRefRecId).AmountReleased;
                    prodReleaseTrans.Cancelled          = NoYes::Yes;

                    offsetProdReleaseTrans              = ProdReleaseTrans_RU::findRecId(prodReleaseTrans.OffsetRefRecId, true);
                    offsetProdReleaseTrans.Cancelled    = NoYes::Yes;
                    offsetProdReleaseTrans.update();
                }
                else
                {
                    Price price = InventTable::findCostPcsPrice(prodReleaseTrans.ItemId, prodReleaseTrans.InventDimId);
                    totalPrice = CurrencyExchangeHelper::amount(InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(prodReleaseTrans.InventTransId).RecId).physical() * price);
                }

                financial = InventUpd_Financial::newProdReleaseTrans_RU(prodReleaseTrans, _ledgerVoucher, totalPrice);
                financial.updateNow();

                prodReleaseTrans.PostingCalcReceiptOffset       = financial.movement().postingOperations();
                prodReleaseTrans.PostingCalcReceipt             = financial.movement().postingBalanceSheet();
                prodReleaseTrans.ReceiptOffsetLedgerDimension   = financial.movement().accountOperations();
                prodReleaseTrans.ReceiptLedgerDimension         = financial.movement().accountBalanceSheet();
                prodReleaseTrans.DateCalc                       = _ledgerVoucher.lastTransDate();
                prodReleaseTrans.VoucherCalc                    = _ledgerVoucher.lastVoucher();
                prodReleaseTrans.Calculated                     = NoYes::Yes;
                prodReleaseTrans.AmountReleased                 = financial.updCostAmountLedger();
                prodReleaseTrans.update();

                prodTableJour.AmountFinancial           += financial.updCostAmountLedger();
                prodTableJour.AmountFinancialSecCur_RU  += financial.updCostAmountSecCurLedger_RU();

                if (calculatingWIP_RU)
                {
                    ProdWIPHistoricalCostTable_RU::createReleaseRecord(prodTable.ProdId,
                                                                       prodReleaseTrans.ItemId,
                                                                       prodReleaseTrans.RecId,
                                                                       prodTableJour.TransDate,
                                                                       prodTableJour.Voucher,
                                                                       prodReleaseTrans.AmountReleased,
                                                                       0,
                                                                       false,
                                                                       false,
                                                                       false);
                }

                if (prodReleaseTrans.isScrap())
                {
                    InventTrans inventTrans = InventTrans::findTransId(prodReleaseTrans.AutodetectionInventTransId);

                    InventMov_Virtuel movementScrap = InventMov_Virtuel::newAutoLossProfit(financial, inventTrans, inventTrans.inventTransOrigin().InventTransId);
                    movementScrap.parmTransQty(inventTrans.Qty);
                    movementScrap.parmAccountOperations(prodReleaseTrans.scrapLedger());
                    movementScrap.parmPostingOperations(LedgerPostingType::ProdScrap);
                    movementScrap.parmAccountBalanceSheet(prodReleaseTrans.ReceiptLedgerDimension);
                    movementScrap.parmPostingBalanceSheet(prodReleaseTrans.PostingCalcReceipt);
                    movementScrap.parmTransRefId(prodReleaseTrans.ProdId);
                    movementScrap.parmTransType(InventTransType::ProdRelease_RU);

                    NoYes stornoPhysical = InventParameters::find().StornoPhysicalPosting_RU && ! prodReleaseTrans.OffsetRefRecId;
                    movementScrap.parmStornoPhysical_RU(stornoPhysical);
                    movementScrap.parmStornoPhysicalForced_RU(stornoPhysical);

                    financialScrap = InventUpd_Financial::newProdReleaseLossProfit_RU(movementScrap,
                                                                                      financial,
                                                                                      -financial.parmFinancial(),
                                                                                      -financial.parmFinancialUnit(),
                                                                                      -totalPrice,
                                                                                      _ledgerVoucher);
                    financialScrap.updateNow();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRouteConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the cost accounting for operations from production route.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher.
    /// </param>
    /// <remarks>
    ///    New route transactions are created in general ledger and then real costs are posted for operations.
    /// </remarks>
    void updateRouteConsumption(LedgerVoucher _ledgerVoucher)
    {
        JmgJobRefCost   jmgJobRefCost;

        setPrefix("@SYS28537");

        if (prodParmHistoricalCost.UseTACost == NoYes::Yes)
        {
            jmgJobRefCost = JmgJobRefCost::construct(prodTable.ProdId);
        }

        this.updateProdRouteTransactions(_ledgerVoucher, jmgJobRefCost, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWIPProduction_RU</Name>
				<Source><![CDATA[
    public void updateWIPProduction_RU(LedgerVoucher _ledgerVoucher)
    {
        InventMovement                  movement = InventMovement::construct(prodTable);
        InventTransIdSum                transIdSum;

        ProdWIPHistoricalCostTable_RU   wipHistoricalCostTable;

        CurrencyCode                    standardCurrency = CompanyInfoHelper::standardCurrency();

        setPrefix("@SYS28546");

        prodTable.doUpdate();
        Amount newReceiptAmount = ProdCalculatingWIPEngine_RU::runFromProdTable(prodTable.ProdId, _ledgerVoucher, endJob_RU);
        prodTable.reread();

        select sum(DifferenceAmount) from wipHistoricalCostTable
            where wipHistoricalCostTable.ProdId                 == prodTable.ProdId                             &&
                  wipHistoricalCostTable.wipHistoricalTransType == ProdWIPHistoricalTransType_RU::Production    &&
                  wipHistoricalCostTable.Voucher                == prodTableJour.Voucher                        &&
                  wipHistoricalCostTable.TransDate              == prodTableJour.TransDate                      &&
                  wipHistoricalCostTable.Cancelled              == NoYes::No                                    &&
                  wipHistoricalCostTable.CanBeCancelled         == NoYes::Yes;

        totalCostAmount = wipHistoricalCostTable.DifferenceAmount;

        if (useDatePhysicalMaxValue_RU)
        {
            transIdSum = InventTransIdSum_DataPhysical_RU::newDataPhysical(prodTable.InventTransId, prodParmHistoricalCost.CalcDate);
        }
        else
        {
            transIdSum = InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(prodTable.InventTransId).RecId);
        }

        if (transIdSum.physical() != 0)
        {
            if (newReceiptAmount < 0)
            {
                throw error(strFmt("@GLS115874", newReceiptAmount, prodTable.ProdId));
            }

            prodTableJour.AmountFinancial = CurrencyExchangeHelper::amount(newReceiptAmount, standardCurrency);
            if (movement.mustBeBookedFinancially() && movement.mustBeBookedOnhandSecCur_RU())
            {
                prodTableJour.AmountFinancialSecCur_RU = CurrencyExchangeHelper::amountMST2MSTSecond_RU(prodTableJour.AmountFinancial, prodParmHistoricalCost.CalcDate);
            }

            this.setProdStandardVarianceList(_ledgerVoucher, movement);

            InventUpd_Financial financial = InventUpd_Financial::newProdTableHistoricalCost(prodTable, _ledgerVoucher, transIdSum, prodTableJour, movement);
            financial.parmDatePhysicalMaxValue_RU(useDatePhysicalMaxValue_RU ? prodParmHistoricalCost.CalcDate : dateNull());
            financial.updateNow();

            prodTableJour.AmountFinancial           = financial.updCostAmountLedger();
            prodTableJour.AmountFinancialSecCur_RU  = financial.updCostAmountSecCurLedger_RU();

            totalCostAmount += prodTableJour.AmountFinancial;

            ProdWIPHistoricalCostTable_RU::createProductionRecord(prodTable.ProdId,
                                                                  prodTable.ItemId,
                                                                  prodTableJour.TransDate,
                                                                  prodTableJour.Voucher,
                                                                  prodTableJour.TransDate,
                                                                  prodTableJour.Voucher,
                                                                  prodTableJour.AmountFinancial,
                                                                  0,
                                                                  false,
                                                                  false);
        }

        prodTableJour.AmountFinancial = totalCostAmount;

        this.updateCalcProduction();

        if (endJob_RU)
        {
            prodTable.SchedStatus  = ProdSchedStatus::None;

            prodTable.ProdStatus   = ProdStatus::Completed;
            prodTable.update();

            WrkCtrCapResHandler::construct().deleteOrderReservations(WrkCtrCapRefType::Production, prodTable.ProdId);

            this.addUpdateRec(prodTable);

            this.updateCalcRefProduction(prodTable);
        }
        else
        {
            prodTable.doUpdate();
        }

        this.addUpdateRec(prodTable);
        this.updateCalcRefProduction(prodTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate()
    {
        ProdTable locProdTable;
        ProdBOM   prodBOM;

        boolean ret = super();

        if (calculatingWIP_RU)
        {
            locProdTable = ProdTable::find(prodParmHistoricalCost.ProdId);
            if (locProdTable.status().isBefore(ProdStatus::StartedUp))
            {
                ret = checkFailed(strFmt("@SYS84960", locProdTable.ProdStatus));
            }

            if (! locProdTable.checkWIPCalcMethod_RU())
            {
                ret = checkFailed("@SYS25493");
            }
        }
        else
        {
            if (ProdTable::find(prodParmHistoricalCost.ProdId,true).status().isBefore(ProdStatus::ReportedFinished))
                ret = checkFailed(strFmt("@SYS84960", ProdTable::find(prodParmHistoricalCost.ProdId).ProdStatus));
        }

        if (ret)
        {
            locProdTable = ProdTable::find(prodParmHistoricalCost.ProdId);
            if (countryRegion_RU)
            {
                if (calculatingWIP_RU)
                {
                    if (locProdTable.inventTable().modelGroup().InventModel == InventModel::StdCost)
                    {
                        ret = checkFailed(strFmt("@GLS115875",
                                                 enum2str(InventModel::StdCost),
                                                 locProdTable.ProdId));
                    }

                    if (ret && locProdTable.lastWIPCalculationDate_RU(UnknownNoYes::Yes) >= prodParmHistoricalCost.CalcDate)
                    {
                        ret = checkFailed("@GLS115876");
                    }

                    if (ret && locProdTable.lastWIPCalculationDate_RU(UnknownNoYes::No) >= prodParmHistoricalCost.CalcDate)
                    {
                        ret = Box::yesNo(strFmt("@GLS115877", prodParmHistoricalCost.CalcDate), DialogButton::No) == DialogButton::Yes;
                    }

                    if (ret && endJob_RU)
                    {
                        ret = locProdTable.checkMaxPhysicalDataForEndJob_RU(prodParmHistoricalCost.CalcDate);
                    }

                    ret = ret && prodTable.checkReleaseProportionallyFixedPrice_RU();

                    if (ret && locProdTable.RemainInventPhysical > 0 && endJob_RU)
                    {
                        ret = checkFailed("@GLS115878");
                    }
                }

                ret = ret && locProdTable.checkEqualityReleaseQty_RU(prodParmHistoricalCost.CalcDate);

                if (ret && !locProdTable.isReceiptQtyEqual_RU(prodParmHistoricalCost.CalcDate) &&
                    Box::yesNo(strFmt("@GLS110612" + ' ' + "@SYS73804", "@GLS115791"), DialogButton::No) == DialogButton::No)
                {
                    ret = checkFailed("@GLS115791");
                }
            }
            if (locProdTable.isProjMethodConsumed())
            {
                if (locProdTable.qtyError())
                    ret = ProjInventJournalTransMapForm::construct(locProdTable.prodTableProj(ProjItemTypeProdTable::ErrorQuantity), locProdTable).validateWritePost();

                if (ret && locProdTable.overDelivery())
                    ret = ProjInventJournalTransMapForm::construct(locProdTable.prodTableProj(ProjItemTypeProdTable::Overdelivery), locProdTable).validateWritePost();

                if (ret)
                {
                    while select prodBOM
                        where prodBOM.ProdId == prodTable.ProdId &&
                            prodBOM.InventRefType == InventRefType::Production
                    {
                        ProdTable prodTableRef = prodBOM.prodTableRef();
                        if (prodTableRef.isProjMethodConsumed())
                        {
                            if (ret && prodTableRef.ProdStatus!=ProdStatus::Completed)
                            {
                                ret = checkFailed(strFmt("@SYS115521", prodTable.ProdId));
                            }
                            if (ret && prodTableRef.qtyUnderconsumed())
                            {
                                ret = ProjInventJournalTransMapForm::construct(prodTableRef.prodTableProj(ProjItemTypeProdTable::Underconsumed), prodTableRef).validateWritePost();
                            }
                        }
                    }
                }
            }

            if (locProdTable.CollectRefLevel > 0)
            {
                ProdParameters prodParameters = ProdParameters::find();
                if (prodParameters.SkipUpdateOfProdCalcTransWhenPosting)
                {
                    warning("@CostManagement:Message_ProductionOrderWillNotBeUpdatedWarning");
                }
            }
        }

        if (endJob_RU || !countryRegion_RU)
        {
            if (ret)
            {
                ret = ProdUpdHistoricalCost::checkNoProdEndBeforeConsumption(prodParmHistoricalCost.ProdId,
                                                                             prodParmHistoricalCost.CalcDate,
                                                                             prodTable);
            }
        }

        // Shop Floor Control begin
        if (ret)
        {
            ret = this.validateSFC();
        }
        // Shop Floor Control end

        // Check if a not finished, not canceled inventory closing exists
        if (ret)
        {
            if (InventClosingPrintDetailedUnfinishedClosingInfoFlight::instance().isEnabled())
            {
                ret = InventClosing::checkUnfinishedClosing();
            }
            else
            {
                if (InventClosing::unresolvedClosingExist())
                {
                    ret = checkFailed("@SYS116068");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSFC</Name>
				<Source><![CDATA[
    public boolean validateSFC()
    {
        boolean hasRegistration;
        if (Global::isConfigurationkeyEnabled(configurationKeyNum(Jmgjob)))
        {
            JmgProdShopFloorValidation jmgProdShopFloorValidation = new JmgProdShopFloorValidation();
            boolean hasActiveJournalReg = jmgProdShopFloorValidation.hasActiveJournalRegistrations(prodTable.ProdId);
            boolean hasActiveRawReg     = jmgProdShopFloorValidation.hasActiveRawRegistrations(prodTable.ProdId);
            hasRegistration             = hasActiveJournalReg || hasActiveRawReg;
        }
        return !hasRegistration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoProdEndBeforeConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that the financial update of the production order does not occur before any physical updates
    /// of the inventory or route transactions related to the production order.
    /// </summary>
    /// <param name="_prodId">
    /// A production order ID that it is to be ended.
    /// </param>
    /// <param name="_prodEndDate">
    /// An ending date of the production order.
    /// </param>
    /// <param name="_prodTable">
    /// A production order table buffer is used in the search for inventory transactions of the production
    /// order; optional.
    /// </param>
    /// <returns>
    /// A Boolean value that indicates whether the check is successfull and the production order can be
    /// ended or not.
    /// </returns>

    public static boolean checkNoProdEndBeforeConsumption(ProdId    _prodId,
                                                          TransDate _prodEndDate,
                                                          ProdTable _prodTable = null)
    {
        InventTrans                 inventTrans;
        ProdTable                   prodTable = _prodTable.RecId ? _prodTable : ProdTable::find(_prodId);
        InventTransOriginProdTable  inventTransOriginProdTable;
        InventTransOriginProdBOM    inventTransOriginProdBOM;
        ProdBOM                     prodBOM;
        ProdRouteTrans              prodRouteTrans;

        // find max physical date on production order transactions
        select TableId from inventTransOriginProdTable
            where inventTransOriginProdTable.ProdOrderDataAreaId    == prodTable.DataAreaId
               && inventTransOriginProdTable.ProdOrderId            == prodTable.ProdId
                join maxof(DatePhysical) from inventTrans
                where   inventTrans.InventTransOrigin   == inventTransOriginProdTable.InventTransOrigin
                    && ((inventTrans.StatusReceipt == StatusReceipt::Received && inventTrans.StatusIssue == StatusIssue::None)
                    || (inventTrans.StatusReceipt == StatusReceipt::None && inventTrans.StatusIssue == StatusIssue::Deducted));

        if (_prodEndDate < inventTrans.DatePhysical)
        {
            return checkFailed(strFmt("@SYS127717", _prodId, inventTrans.DatePhysical));
        }

        // find max physical date on production order lines transactions
        select TableId from prodBOM
            where   prodBOM.ProdId  == _prodId
                join    TableId from inventTransOriginProdBOM
                    where inventTransOriginProdBOM.ProdBOMDataAreaId    == prodBOM.DataAreaId
                       && inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
                    join    maxof(DatePhysical) from inventTrans
                        where   inventTrans.InventTransOrigin           == inventTransOriginProdBOM.InventTransOrigin
                             && ((inventTrans.StatusReceipt == StatusReceipt::Received && inventTrans.StatusIssue == StatusIssue::None)
                             || (inventTrans.StatusReceipt == StatusReceipt::None && inventTrans.StatusIssue == StatusIssue::Deducted));

        if (_prodEndDate < inventTrans.DatePhysical)
        {
            return checkFailed(strFmt("@SYS127718", _prodId, inventTrans.DatePhysical));
        }

        // find max estimation date on route transactions
        select maxof(DateWIP) from prodRouteTrans
            where   prodRouteTrans.TransRefId   == _prodId  &&
                    prodRouteTrans.TransRefType == ProdTransRefType::Production &&
                    prodRouteTrans.Cancelled    == NoYes::No;

        if (_prodEndDate < prodRouteTrans.DateWIP)
        {
            return checkFailed(strFmt("@SYS127719", _prodId, prodRouteTrans.DateWIP));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static ProdUpdHistoricalCost construct()
    {
        return new ProdUpdHistoricalCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParmBuffer</Name>
				<Source><![CDATA[
    static ProdUpdHistoricalCost newParmBuffer(ProdParmHistoricalCost prodParmHistoricalCost)
    {
        if (! prodParmHistoricalCost.ParmId)
        {
            prodParmHistoricalCost.skipTTSCheck(true);
            prodParmHistoricalCost.ParmBuffer::initParmId();
            prodParmHistoricalCost.insert();
        }

        ProdUpdHistoricalCost prodUpdHistoricalCost = ProdUpdHistoricalCost::construct();
        prodUpdHistoricalCost.parmParmBuffer(prodParmHistoricalCost);

        return prodUpdHistoricalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPreviousJob</Name>
				<Source><![CDATA[
    static void runPreviousJob(ProdParmHistoricalCost  prodParmHistoricalCost,
                               RunbaseRecsMapable      _multi = null)
    {
        using (var m = ProdInstrumentationSegmentFactory::create(ProdInstrumentationActivities::UpdateHistoricalCostRunPreviousJob, prodParmHistoricalCost.RecId))
        {
            ProdTable prodTable = ProdTable::find(prodParmHistoricalCost.ProdId);

            if (prodParmHistoricalCost.AutoReportAsFinished)
            {
                ProdParmReportFinished prodParmReportFinished = ProdUpdReportFinished::initParmBufferFromHistCost(prodParmHistoricalCost);

                prodParmReportFinished.insert();
                prodTable.status().runReportFinished(prodParmReportFinished,false,_multi,true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRealBomConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns consumption from a ProdBom.
    /// </summary>
    /// <param name="_prodBOM">
    /// The <c>ProdBom</c> record.
    /// </param>
    /// <param name="_financial">
    /// The <c>InventUpd_Financial</c> related to the <c>ProdBom</c> record.
    /// </param>
    /// <param name="_costAllocationPct">
    /// The cost allocation percentage.
    /// </param>
    /// <returns>
    /// The bom consumption.
    /// </returns>
    protected Qty getRealBomConsumption(ProdBOM _prodBOM, InventUpd_Financial _financial, PmfCostAllocationPct _costAllocationPct)
    {
        if (prodTable.ProdType == ProdType::Process)
        {
            return - _financial.updFinancial() * _costAllocationPct / 100;
        }
        else
        {
            return - _financial.updFinancial();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostScrapForProductionOutputMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inventory movement used when posting the scrap quantity for one of production outputs.
    /// </summary>
    /// <param name="_quantityError">The error quantity.</param>
    /// <param name="_inventTrans">The inventory transaction used to create the movement.</param>
    /// <returns>An instance of the movement class.</returns>
    protected InventMov_Virtuel getPostScrapForProductionOutputMovement(
        ProdReportedError   _quantityError,
        InventTrans         _inventTrans)
    {
        return InventMov_Virtuel::newProdTableScrap(prodTable, _quantityError, prodParmHistoricalCost.CalcDate, this.getInventDimId(_inventTrans, _quantityError));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReportedAsFinishedReceipt</Name>
				<Source><![CDATA[
    private InventTrans findReportedAsFinishedReceipt(ProdTableJour _prodTableJour)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select InventDimId, ItemId from inventTrans
            order by DatePhysical desc
            where inventTrans.StatusReceipt == StatusReceipt::Received
                && inventTrans.StatusIssue  == StatusIssue::None
            exists join inventTransOrigin
            where inventTransOrigin.RecId          == inventTrans.InventTransOrigin
                && inventTransOrigin.InventTransId == _prodTableJour.InventTransId;

        // produced LOT is fully scrapped => take the last reported as finished product or co/by product attributes
        if (!inventTrans.RecId)
        {
            ProdJournalProd prodJournalProd;

            select InventDimId, ItemId from prodJournalProd
                order by TransDate desc
                exists join inventTransOrigin
                where inventTransOrigin.InventTransId  == prodJournalProd.InventTransId
                    && inventTransOrigin.InventTransId == _prodTableJour.InventTransId;

            inventTrans.ItemId      = prodJournalProd.ItemId;
            inventTrans.InventDimId = prodJournalProd.InventDimId;
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postScrapForProductionOutput</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the scrap quantity for one of production outputs.
    /// </summary>
    /// <param name="_ledgerVoucherReceipt">
    /// The <c>LedgerVoucher</c> that should be used for posting.
    /// </param>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record.
    /// </param>
    /// <param name="_prodTableJour">
    /// The <c>ProdTableJour</c> record.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// The <c>InventTransOriginId</c> value.
    /// </param>
    protected void postScrapForProductionOutput(LedgerVoucher        _ledgerVoucherReceipt,
                                                InventTable          _inventTable,
                                                ProdTableJour        _prodTableJour,
                                                InventTransOriginId  _inventTransOriginId)
    {
        if (countryRegion_RU && prodTable.useReleaseFromProduction_RU())
            return;

        boolean isStandardCostItem = _inventTable.modelGroup().inventModelType().stdCostBased();

        if (_prodTableJour.QtyError && prodParmHistoricalCost.ScrapMethod == ProdScrapMethod::ScrapAccount 
            && (!isStandardCostItem || (ProdPostScrapStdCostModelFeature::instance().isEnabled() && _prodTableJour.QtyGood == 0)))
        {
            if (_prodTableJour.QtyError + _prodTableJour.QtyGood == 0)
            {
                throw error("@SYS20578");
            }

            CostAmount scrapAmount = CurrencyExchangeHelper::amount(_prodTableJour.QtyError * _prodTableJour.AmountFinancial / (_prodTableJour.QtyGood + _prodTableJour.QtyError), '');
            InventTrans inventTrans = this.findReportedAsFinishedReceipt(_prodTableJour);

            // Create movement based on production or co/by product for the scrap
            // Ensure that the inventory transactions created for the scrap quantity contains correct item ID and dimensions.
            InventMov_Virtuel movement = this.getPostScrapForProductionOutputMovement(_prodTableJour.QtyError, inventTrans);

            if (countryRegion_RU)
            {
                movement.parmStornoPhysical_RU(InventParameters::find().StornoPhysicalPosting_RU);
            }

            if (isStandardCostItem)
            {
                var logger = ProdInstrumentationLogger::createLogger(classStr(ProdUpdHistoricalCost));
                using(var activityContext = logger.prodOrder().scrapLotStandardCostItem())
                {
                    logger.logScrapLotStandardCostItem(prodTable, prodParmHistoricalCost);
                    InventUpd_Physical physical = InventUpd_Physical::newCheckPostInventJournalTrans(movement);                

                    if (ProdUpdHistoricalCostStdFullScrapResolveLPFlight::instance().isEnabled())
                    {
                        using (WHSSkipLPControlledCheckForInventoryCleanupContext context = WHSSkipLPControlledCheckForInventoryCleanupContext::construct())
                        {
                            context.parmSkipCheck(true);
                            physical.parmAllowAutoReserveDim(false);
                            physical.updateNow(_ledgerVoucherReceipt);
                        }
                    }
                    else
                    {
                        physical.updateNow(_ledgerVoucherReceipt);
                    }

                    // compute scrap quantity variance as a delta between actual and standard cost and post to standard cost quantity variance instead of rounding variance.
                    this.setProdStandardVarianceList(_ledgerVoucherReceipt, movement);
                }
            }

            InventUpd_Financial financial = InventUpd_Financial::newProdTableScrap(movement, _ledgerVoucherReceipt, _prodTableJour.QtyError, scrapAmount);

            this.updateFinancialForProductionScrap(financial);

            if (prodTable.isProjMethodConsumed())
            {
                ProjInventJournalTransMapForm::updateOrCreateProdTableProj(prodTable, ProjItemTypeProdTable::ErrorQuantity, _ledgerVoucherReceipt.lastTransDate());
                ProdTableProj prodTableProj = prodTable.prodTableProj(ProjItemTypeProdTable::ErrorQuantity);

                if (!ProjPost::newCheckTrans(prodTableProj).checkTrans())
                {
                    throw Exception::Error;
                }

                ProjPost::newCreateProjTransItem(prodTableProj,
                                                 _ledgerVoucherReceipt,
                                                 financial.movement().projAdjustRefId(),
                                                 false,
                                                 movement.transId()).postTrans();
            }

            LedgerVoucher ledgerVoucherScrap = this.newLedgerVoucher();
            this.newLedgerVoucherObject(ledgerVoucherScrap);

            movement.parmAccountOperations(prodParmHistoricalCost.LedgerDimension);
            movement.parmPostingOperations(LedgerPostingType::ProdScrap);

            financial   = InventUpd_Financial::newProdTableScrap(movement,ledgerVoucherScrap,-_prodTableJour.QtyError,-scrapAmount);
            
            this.updateFinancialForProductionScrap(financial);

            ledgerVoucherScrap.end();

            _prodTableJour.AmountFinancial   -=  scrapAmount;
            _prodTableJour.ScrapVoucher       = ledgerVoucherScrap.lastVoucher();

            if (_inventTransOriginId)
            {
                InventTransPosting inventTransPosting;

                inventTrans.skipEvents(true);
                inventTrans.skipDataMethods(true);
                update_recordset inventTrans
                    setting MarkingRefInventTransOrigin = _inventTransOriginId,
                            InventTransOrigin           = _inventTransOriginId
                    where inventTrans.InventTransOrigin == movement.inventTransOriginId();

                update_recordset inventTransPosting
                    setting InventTransOrigin   = _inventTransOriginId
                    where inventTransPosting.TransDate          == _ledgerVoucherReceipt.lastTransDate()
                      &&  inventTransPosting.Voucher            == _ledgerVoucherReceipt.lastVoucher()
                      &&  inventTransPosting.InventTransOrigin  == movement.inventTransOriginId();

                update_recordset inventTransPosting
                    setting InventTransOrigin   = _inventTransOriginId
                    where inventTransPosting.TransDate          == ledgerVoucherScrap.lastTransDate()
                      &&  inventTransPosting.Voucher            == ledgerVoucherScrap.lastVoucher()
                      &&  inventTransPosting.InventTransOrigin  == movement.inventTransOriginId();
            }
            else if (prodTable.RecId)
            {
                InventTransOriginProdTable::writeOriginOwnerRelationship(prodTable.dataAreaId, prodTable.ProdId, movement.inventTransOriginId());
            }

            if (prodTable.isProjMethodConsumed())
            {
                ProjItemTrans projItemTrans;

                scrapTransId = movement.transId();

                update_recordset projItemTrans
                    setting InventTransId = prodTable.InventTransId
                    where projItemTrans.InventTransId == scrapTransId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimId</Name>
				<Source><![CDATA[
    private InventDimId getInventDimId(InventTrans _inventTrans, ProdReportedError _quantityError)
    {
        InventDimGroupFieldSetup inventDimGroupFieldSetup = InventDimGroupSetup::newItemId(_inventTrans.ItemId).getFieldSetup(fieldNum(InventDim, InventSerialId));

        InventDimId localInventDimId;
        if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isSerialNumberControlEnabled())
        {
            InventDim localInventDim = InventDim::find(_inventTrans.InventDimId,true);
            if (abs(_quantityError) == 1)
            {
                localinventDim.inventSerialId = NumberSeq::newGetNum(NumberSeqReference::findReference(extendedTypeNum(InventSerialId))).num();
            }
            else
            {
                InventNumGroupId serialNumGroupId = _inventTrans.inventTable().SerialNumGroupId;
                if (serialNumGroupId && !InventNumGroup::find(serialNumGroupId).ManualAllocation)
                {
                    localInventDim.inventSerialId = '';
                }
                else
                {
                    throw Error(strFmt("@SCM:ScrapSerialNumberControlledItemWithoutAutoNumberGroup", _inventTrans.ItemId));
                }
            }
            localInventDimId = InventDim::findOrCreate(localInventDim).inventDimId;
        }
        else
        {
            localInventDimId = _inventTrans.inventDimId;
        }
        
        return localInventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDateCalcOnCancelledProdRouteTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stamps the date calc on cancelled route transactions.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher.
    /// </param>
    /// <remarks>
    /// The reason is to avoid the appearance of cancelled route transactions in Work in Progress reports.
    /// The Calculated flag is not set to avoid any side-effects.
    /// </remarks>
    protected void setDateCalcOnCancelledProdRouteTrans(LedgerVoucher _ledgerVoucher)
    {
        ProdRouteTrans prodRouteTrans;

        update_recordset prodRouteTrans
            setting
                DateCalc      = _ledgerVoucher.lastTransDate()
            where prodRouteTrans.TransRefId    == prodTable.ProdId &&
                  prodRouteTrans.TransRefType  == ProdTransRefType::Production &&
                  prodRouteTrans.DateCalc     == dateNull()       &&
                  (! useDatePhysicalMaxValue_RU || prodRouteTrans.DateWIP <= prodParmHistoricalCost.CalcDate) &&
                  prodRouteTrans.Cancelled    == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProdRouteTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the route transactions of a production.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> that should be used for posting.
    /// </param>
    /// <param name="_jmgJobRefCost">
    /// The <c>JmgJobRefCost</c> class instance used for resolving shop floor control clock registrations.
    /// </param>
    /// <param name="_includeBurdenTransactions">
    /// True if burden transactions should be included; false otherwise.
    /// </param>
    protected void updateProdRouteTransactions(LedgerVoucher _ledgerVoucher,
                                               JmgJobRefCost _jmgJobRefCost = null,
                                               boolean _includeBurdenTransactions = true)
    {
        ProdRouteTrans         prodRouteTrans;

        while select forupdate prodRouteTrans
            where prodRouteTrans.TransRefId    == prodTable.ProdId &&
                  prodRouteTrans.TransRefType  == ProdTransRefType::Production &&
                  prodRouteTrans.Calculated    == NoYes::No        &&
                  (! useDatePhysicalMaxValue_RU || prodRouteTrans.DateWIP <= prodParmHistoricalCost.CalcDate) &&
                  prodRouteTrans.Cancelled     == NoYes::No        &&
                  (_includeBurdenTransactions || prodRouteTrans.JobType       != RouteJobType::Burden)
        {
            ProdJobType prodJobType = prodRouteTrans.prodJobType();

            prodJobType.parmJmgJobRefCost(_jmgJobRefCost);
            prodJobType.updateCalcLedger(_ledgerVoucher, prodTableJour, prodRouteTrans);
            prodJobType.updateRealConsumption(prodTable,
                                              prodRouteTrans,
                                              true,
                                              this.allocationPercentMainItem());

            this.postUpdateProdJobType(prodJobType, prodRouteTrans);
        }

        this.setDateCalcOnCancelledProdRouteTrans(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLPValidationForProductionScrap</Name>
				<Source><![CDATA[
    private boolean skipLPValidationForProductionScrap(InventUpd_Financial financial)
    {
        return !financial.movement().inventdim().LicensePlateId
               &&  financial.movement().inventdim().wmsLocation().whsLocationIsLPControlled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinancialForProductionScrap</Name>
				<Source><![CDATA[
    private void updateFinancialForProductionScrap(InventUpd_Financial financial)
    {
        if (this.skipLPValidationForProductionScrap(financial))
        {
            using (WHSSkipLPControlledCheckForInventoryCleanupContext context = WHSSkipLPControlledCheckForInventoryCleanupContext::construct())
            {
                context.parmSkipCheck(true);

                financial.updateNow();
            }
        }
        else
        {
            financial.updateNow();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>