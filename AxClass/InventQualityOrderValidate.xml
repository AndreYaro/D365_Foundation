<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventQualityOrderValidate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventQualityOrderValidate</c> class performs the validation of a quality order.
/// </summary>
/// <remarks>
/// Validation of a quality order includes posting the consumption of items destroyed during
/// destructive testing.
/// </remarks>
public class InventQualityOrderValidate extends RunBase
{
    HcmWorkerRecId              worker;
    boolean                     acceptError;
    NoYes                       quarantineOnFailure;
    NoYes                       updateInventStatus;
    Query                       updateInventStatusQuery;

    boolean                     allowEditQuarantineOnFailure;

    DialogField                 fieldWorker;
    DialogField                 fieldAcceptError;
    DialogField                 fieldQuarantineOnFailure;
    FormBuildCheckBoxControl    controlBuildUpdateInventStatus;

    InventQualityOrderTable     inventQualityOrderTable;
    InventQualityOrderId        inventQualityOrderId;

    Voucher                     voucher;
    NumberSeq                   numberSeq;

    LedgerVoucher               ledgerVoucher;

    DialogRunbase               dialog;

    InventQualityReferenceType  qualityReferenceType;

    WHSInventoryStatusConvert   inventStatusConvert;

    private List                dimensionQtyList;
    private boolean             isItemAndWarehouseQualityManagementProcessEnabled;

    private InventDimItemTmp    inventStatusConvertConversionTable;
    private boolean             useInventStatusConvertConversionTable;
    private TableName           inventStatusConvertConversionTablePhysicalName;
    private boolean             inventQualityOrderValidateConvertUseDimIdV2FlightEnabled = InventQualityOrderValidateConvertUseDimIdV2Flight::instance().isEnabled();
    private boolean             inventQualityOrderValidateConvertUseTempDBForNonWHSWarehousesFlightEnabled = InventQualityOrderValidateConvertUseTempDBForNonWHSWarehousesFlight::instance().isEnabled();

    private Set                 inventStatusConvertConversionTableSet = new Set(Types::String);

    #define.CurrentVersion(6)
    #LOCALMACRO.CurrentList
        inventQualityOrderId,
        worker,
        acceptError,
        quarantineOnFailure,
        allowEditQuarantineOnFailure,
        updateInventStatus,
        isItemAndWarehouseQualityManagementProcessEnabled,
        useInventStatusConvertConversionTable,
        inventStatusConvertConversionTablePhysicalName
    #ENDMACRO
    #LOCALMACRO.CurrentList5
        inventQualityOrderId,
        worker,
        acceptError,
        quarantineOnFailure,
        allowEditQuarantineOnFailure,
        updateInventStatus,
        isItemAndWarehouseQualityManagementProcessEnabled
    #ENDMACRO
    #LOCALMACRO.CurrentList4
        inventQualityOrderId,
        worker,
        acceptError,
        quarantineOnFailure,
        allowEditQuarantineOnFailure,
        updateInventStatus
    #ENDMACRO
    #LOCALMACRO.CurrentList3
        inventQualityOrderId,
        worker,
        acceptError,
        quarantineOnFailure,
        allowEditQuarantineOnFailure
    #ENDMACRO
    #LOCALMACRO.CurrentList2
        inventQualityOrderId,
        worker,
        acceptError
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>acceptError_modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event on the accept error check box.
    /// </summary>
    /// <param name="_fieldAcceptErrorControl">
    /// The accept error check box.
    /// </param>
    /// <returns>
    /// true if the field is modified; otherwise, false.
    /// </returns>
    public boolean acceptError_modified(FormCheckBoxControl _fieldAcceptErrorControl)
    {
        boolean isFieldModified = _fieldAcceptErrorControl.modified();

        if (isFieldModified)
        {
            this.enableQuarantineOnFailure();
        }

        return isFieldModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventoryStatusUpdateControls</Name>
				<Source><![CDATA[
    private void addInventoryStatusUpdateControls()
    {
        inventQualityOrderTable qualityOrderTable = this.parmQualityOrder();

        if (qualityOrderTable.allowUpdateInventoryStatus())
        {
            InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(inventQualityOrderTable.InventRefTransId);
            this.validatePutWorkLine(inventTransOrigin);

            DialogGroup updateInventStatusGroup = dialog.addGroup();
            updateInventStatusGroup.columns(2);

            DictType dictTypeUpdateInventStatus = new DictType(extendedTypeNum(InventTestUpdateInventStatus));
            controlBuildUpdateInventStatus = updateInventStatusGroup.formBuildGroup().addControl(FormControlType::CheckBox, 'UpdateInventoryStatus');
            controlBuildUpdateInventStatus.label(dictTypeUpdateInventStatus.label());
            controlBuildUpdateInventStatus.helpText(dictTypeUpdateInventStatus.help());
            controlBuildUpdateInventStatus.value(updateInventStatus);
            controlBuildUpdateInventStatus.allowEdit(qualityOrderTable.FailedInventStatusId || qualityOrderTable.PassedInventStatusId);

            FormBuildButtonControl buttonInventStatusSelection = updateInventStatusGroup.formBuildGroup().addControl(FormControlType::Button, 'WHSInventStatusSelection');
            buttonInventStatusSelection.text("@SYS7444");
            buttonInventStatusSelection.helpText("@SYS4110685");

            buttonInventStatusSelection.registerOverrideMethod(
                methodStr(FormButtonControl, clicked),
                methodStr(InventQualityOrderValidate, WHSInventStatusSelection_clicked),
                this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTestDestructiveWHSItemBelowLocDimSpecifiedWarning</Name>
				<Source><![CDATA[
    private void addTestDestructiveWHSItemBelowLocDimSpecifiedWarning()
    {
        if (inventQualityOrderTable.TestDestructive
            && WHSItemBelowLocationDimSpecifiedQualityOrderTestDestructiveShowWarningFlight::instance().isEnabled())
        {
            InventTable inventTable = InventTable::find(inventQualityOrderTable.ItemId);
            InventDim inventDim = InventDim::find(inventQualityOrderTable.InventDimId);

            if (WhsReservationHierarchyInventDimUtil::isLocationOrBelowSpecified(inventTable, inventDim))
            {
                dialog.addGroup("@SYS866");
                dialog.addText("@WAX:Warning_InventQualityOrderTestDestructiveWHSItemWithBelowLocationDimention", 440);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a ledger voucher and transaction text in order to post item consumption.
    /// </summary>
    void beginLedger()
    {
        TransactionTxt      transactionTxt = TransactionTxt::construct();

        numberSeq           = NumberSeq::newGetNum(InventParameters::numRefInventJournalVoucherId());
        voucher             = numberSeq.num();

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                             SysModule::Invent,
                                                             numberSeq.parmNumberSequenceCode());

        transactionTxt.setType(LedgerTransTxt::InventJournalLossProfit);
        transactionTxt.setDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        transactionTxt.setVoucher(voucher);
        transactionTxt.setKey1(inventQualityOrderId);
        transactionTxt.setKey2(inventQualityOrderTable.ItemId);

        if (TransactionTextContext::isTypeSupported(LedgerTransTxt::InventJournalLossProfit))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::InventJournalLossProfit);
            transactionTextContext.setTableBuffer(InventJournalTrans::findInventTransId(inventQualityOrderTable.InventTransId));
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher,
                                                                                  DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                                                  SysModule::Invent,
                                                                                  LedgerTransType::Invent);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDimensionQtyList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a list of inventory dimensions and quantities for which quality orders are responsible.
    /// </summary>
    /// <returns>
    /// A list filled with containers. Each container holds 2 elements: an <c>InventDimId</c> and a container which packs an inventory quantity and a catch weight quantity.
    /// </returns>
    /// <remarks>
    /// Each container holds an <c>InventDimId</c> value and a quantity.
    /// </remarks>
    protected List buildDimensionQtyList()
    {
        InventQty                       quantity                        = inventQualityOrderTable.BlockingQty;
        PdsCWInventQty                  cwQuantity                      = inventQualityOrderTable.PdsCWBlockingQty;
        InventBlockingQualityOrder      inventBlockingQualityOrder;
        InventTransOriginBlockingIssue  inventTransOriginBlockingIssue;
        List                            result                          = new List(Types::Container);
        InventTrans                     inventTrans;
        InventDim                       inventDim;

        void updateResult(InventDimId _inventDimId, InventQty _quantity, PdsCWInventQty _cwQuantity)
        {
            result.addEnd([_inventDimId, [_quantity, _cwQuantity]]);
            quantity -= _quantity;
            cwQuantity -= _cwQuantity;
        }

        WHSQualityOrderInventory qualityOrderInventory;

        while select qualityOrderInventory
            where qualityOrderInventory.QualityOrderId == inventQualityOrderId
        {
            // Catch weight is not considered here.
            updateResult(qualityOrderInventory.InventDimId, qualityOrderInventory.InventHandlingQty, 0);
                
            if (quantity <= 0)
            {
                return result;
            }
        }

        if (!quantity && WHSModifyQualityOrderPopulateDimensionsContext::currentUseQualityOrderQuantityParameter())
        {
            quantity = inventQualityOrderTable.Qty;
            cwQuantity = inventQualityOrderTable.PdsCWQty;
        }

        while select sum(Qty),
            sum(PdsCWQty),
            InventDimId from inventTrans
            group by StatusIssue, InventDimId
            order by StatusIssue asc, InventDimId desc                  // take physically reserved first
            where inventTrans.StatusReceipt     == StatusReceipt::None
            exists join inventDim
            where inventDim.inventDimId     == inventTrans.InventDimId
               && inventDim.wMSLocationId  != ''
            exists join inventTransOriginBlockingIssue
            where inventTransOriginBlockingIssue.InventTransOrigin  == inventTrans.InventTransOrigin
            join TableId from inventBlockingQualityOrder
            where inventBlockingQualityOrder.InventBlocking         == inventTransOriginBlockingIssue.InventBlockingIssue
              &&  inventBlockingQualityOrder.InventQualityOrderId   == inventQualityOrderTable.QualityOrderId
        {
            InventQty inventTransQty = min(-inventTrans.Qty, quantity);
            PdsCWInventQty cwTransQty = min(-inventTrans.PdsCWQty, cwQuantity);
            updateResult(inventTrans.InventDimId, inventTransQty, cwTransQty);

            if (quantity <= 0)
            {
                break;
            }
        }

        if (quantity > 0 && this.whsNeedToReSyncQualityOrderDimensions())
        {
            WHSWorkLine        workLine;

            if(WHSQOValidationInventDimSelectingWorkLineFlight::instance().isEnabled())
            {
                InventDimParm inventDimParmLocationAndAbove = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(inventQualityOrderTable.ItemId));
               
                select firstonly WorkStatus, WorkId, LineNum
                    from workLine
                    order by workLine.LineNum desc
                    where workLine.WorkType      == WHSWorkType::Put
                    &&    workLine.InventTransId == inventQualityOrderTable.InventRefTransId
                    #WHSInventDimExistsJoinWork(workLine.InventDimId, inventDim, inventQualityOrderTable.inventDim(), inventDimParmLocationAndAbove);

            }
            else
            {
                select firstonly WorkStatus, WorkId, LineNum
                    from workLine
                    order by workLine.LineNum desc
                    where workLine.WorkType      == WHSWorkType::Put
                    &&    workLine.InventTransId == inventQualityOrderTable.InventRefTransId;
            }
                    
            if (workLine && workLine.WorkStatus == WHSWorkStatus::Closed)
            {
                if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLine.WorkId))
                {
                    WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(workLine.WorkId).registeredReceiptByWorkLine(
                        workLine.LineNum,
                        WHSWorkInventoryTransactionQueryParameters::construct().setIncludeArchivedTransactions(true));

                    WHSWorkInventoryTransactionDescriptorEnumerator enumerator = inventoryTransactionDescriptor.getEnumerator();

                    while (enumerator.moveNext())
                    {
                        WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = enumerator.current();
                        WHSInventoryQuantityPair inventoryQuantityPair = inventoryTransactionDescriptorElement.getInventoryFormatQuantity();

                        InventQty inventTransQty = min(inventoryQuantityPair.parmInventQty(), quantity);
                        PdsCWInventQty cwTransQty = min(inventoryQuantityPair.parmCwInventQty(), cwQuantity);
                        InventDimId inventDimId = inventoryTransactionDescriptorElement.parmInventoryDimensionsDescriptor().convertToInventDim(true).inventDimId;
                        updateResult(inventDimId, inventTransQty, cwTransQty);

                        if (quantity <= 0)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    WHSWorkInventTrans workInventTrans;
                    InventTransOrigin  inventTransOrigin;

                    while select sum(Qty), sum(PdsCWQty), InventDimId
                        from inventTrans
                        group by InventDimId
                        where inventTrans.StatusIssue == StatusIssue::None
                    exists join inventTransOrigin
                        where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                    exists join workInventTrans
                        where workInventTrans.WorkId  == workLine.WorkId
                        &&    workInventTrans.LineNum == workLine.LineNum
                        &&    workInventTrans.InventTransIdTo == inventTransOrigin.InventTransId
                    {
                        InventQty inventTransQty = min(inventTrans.Qty, quantity);
                        PdsCWInventQty cwTransQty = min(inventTrans.PdsCWQty, cwQuantity);
                        updateResult(inventTrans.InventDimId, inventTransQty, cwTransQty);

                        if (quantity <= 0)
                        {
                            break;
                        }
                    }
                }
            }
        }

        if (quantity > 0)
        {
            // Use quality order dimensions for any remaining quantity.
            result.addEnd([inventQualityOrderTable.InventDimId, [quantity, cwQuantity]]);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>commitLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Completes final validations after all ledger transactions have been posted.
    /// </summary>
    void commitLedger()
    {
        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a standard dialog box where parameters for the validation can be specified.
    /// </summary>
    /// <returns>
    ///    A standard dialog box.
    /// </returns>
    Object dialog()
    {
        dialog = super();

        this.addTestDestructiveWHSItemBelowLocDimSpecifiedWarning();

        fieldWorker              = dialog.addFieldValue(extendedTypeStr(HcmWorkerRecId), worker, "@SYS113827", "@SYS319492");

        fieldAcceptError         = dialog.addFieldValue(enumStr(NoYes), acceptError, "@SYS14646", "@SYS113891");
        fieldAcceptError.registerOverrideMethod(
            methodStr(FormCheckBoxControl, modified),
            methodStr(InventQualityOrderValidate, acceptError_modified),
            this);

        fieldQuarantineOnFailure = dialog.addFieldValue(extendedTypeStr(InventTestQuarantineOnFailure), quarantineOnFailure);

        this.addInventoryStatusUpdateControls();

        this.enableQuarantineOnFailure();

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableQuarantineOnFailure</Name>
				<Source><![CDATA[
    private void enableQuarantineOnFailure()
    {
        if (   !allowEditQuarantineOnFailure
            || fieldAcceptError.value() == NoYes::Yes)
        {
            fieldQuarantineOnFailure.enabled(false);
            fieldQuarantineOnFailure.skip(true);
            fieldQuarantineOnFailure.value(NoYes::No);
        }
        else
        {
            fieldQuarantineOnFailure.enabled(true);
            fieldQuarantineOnFailure.skip(false);
            fieldQuarantineOnFailure.value(quarantineOnFailure);
        }

        fieldQuarantineOnFailure.visible(this.parmQualityOrder().allowQuarantineUponFailure());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets values from the dialog box and stores them in internal variables.
    /// </summary>
    /// <returns>
    ///    true if the retrieval from the dialog box is successful; otherwise, false.
    /// </returns>
    boolean getFromDialog()
    {
        boolean ret = super();

        this.parmWorker(fieldWorker.value());
        this.parmAcceptError(fieldAcceptError.value());
        this.parmQuarantineOnFailure(fieldQuarantineOnFailure.value());

        if (this.parmQualityOrder().allowUpdateInventoryStatus())
        {
            FormCheckBoxControl fieldUpdateInventStatus = dialog.formRun().control(controlBuildUpdateInventStatus.id());
            this.parmUpdateInventStatus(fieldUpdateInventStatus.value());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public boolean init()
    {
        boolean ret = super();

        this.initAllowEditQuarantineOnFailure();
        this.initUpdateInventStatusQuery();
        this.initIsWHSQualityManagementProcessEnabled();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAllowEditQuarantineOnFailure</Name>
				<Source><![CDATA[
    protected void initAllowEditQuarantineOnFailure()
    {
        allowEditQuarantineOnFailure = this.qualityReferenceType().allowEditQuarantineOnFailure();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the class for first time use.
    /// </summary>
    public void initParmDefault()
    {
        super();
        worker = DirPersonUserEx::findUserWorkerReference();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePutWorkLine</Name>
				<Source><![CDATA[
    private void validatePutWorkLine(InventTransOrigin _inventTransOrigin)
    {
        WHSOrderNum workLineOrderNum = this.retrieveFirstOpenOrInProcessWorkLineOrderNumber(_inventTransOrigin);

        boolean existsClosedWorkLine = this.existsClosedWorkLineForInventTransOrigin(_inventTransOrigin);
            
        if (workLineOrderNum
            || existsClosedWorkLine)
        {
            dialog.addText("@WAX:QualityOrderValidateOpenPutWorkLineWarningPart1");
        }

        if (workLineOrderNum)
        {
            dialog.addText(strFmt("@WAX:QualityOrderValidateOpenPutWorkLineWarningPart2", workLineOrderNum));
        }

        if (existsClosedWorkLine)
        {
            dialog.addText("@WAX:QualityOrderValidateOpenPutWorkLineWarningPart3");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveFirstOpenOrInProcessWorkLineOrderNumber</Name>
				<Source><![CDATA[
    private WHSOrderNum retrieveFirstOpenOrInProcessWorkLineOrderNumber(InventTransOrigin _inventTransOrigin)
    {
        WHSWorkLine workline;

        select firstonly OrderNum from workLine
            where workLine.WorkType         == WHSWorkType::Put
                && (workLine.WorkStatus     == WHSWorkStatus::Open
                    || workLine.WorkStatus  == WHSWorkStatus::InProcess)
                && workLine.OrderNum        == inventQualityOrderTable.InventRefId
                && workLine.InventTransId   == _inventTransOrigin.InventTransId;

        return workline.OrderNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsClosedWorkLineForInventTransOrigin</Name>
				<Source><![CDATA[
    private boolean existsClosedWorkLineForInventTransOrigin(InventTransOrigin _inventTransOrigin)
    {
        WHSWorkLine workline;

        select firstonly WorkId from workLine
            order by workLine.LineNum desc
            where workLine.WorkType         == WHSWorkType::Put
                && workLine.WorkStatus      == WHSWorkStatus::Closed
                && workLine.OrderNum        == inventQualityOrderTable.InventRefId
                && workLine.InventTransId   == _inventTransOrigin.InventTransId;

        return workline.WorkId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdateInventStatusQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory status update query.
    /// </summary>
    public void initUpdateInventStatusQuery()
    {
        useInventStatusConvertConversionTable = false;
        inventStatusConvertConversionTablePhysicalName = '';
    
        inventQualityOrderTable = this.parmQualityOrder();

        if (inventQualityOrderTable.allowUpdateInventoryStatus())
        {
            updateInventStatusQuery = new Query();

            QueryBuildDataSource dsInventSum = updateInventStatusQuery.addDataSource(tableNum(InventSum));
            QueryBuildRange itemIdRange = SysQuery::findOrCreateRange(dsInventSum, fieldNum(InventSum, ItemId));
            itemIdRange.value(queryValue(inventQualityOrderTable.ItemId));
            itemIdRange.status(RangeStatus::Locked);

            QueryBuildDataSource dsInventDim = dsInventSum.addDataSource(tableNum(InventDim));
            dsInventDim.relations(true);

            if (inventQualityOrderTable.InventRefTransId)
            {
                InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(inventQualityOrderTable.InventRefTransId);

                boolean existsClosedWorkLine;

                if (inventQualityOrderTable.ReferenceType == InventTestReferenceType::Purch || inventQualityOrderTable.ReferenceType == InventTestReferenceType::Production)
                {
                    existsClosedWorkLine = this.existsClosedWorkLineForInventTransOrigin(inventTransOrigin);
                }

                InventTrans         inventTrans;
                InventDim           inventDim;
                InventDim           qualityOrderInventDim = inventQualityOrderTable.inventDim();

                if (existsClosedWorkLine)
                {
                    
                    InventParameters    inventParameters = InventParameters::find();

                    boolean mustFindWorkInventTrans  =  inventParameters.QualityOrderWorkInventoryDimensionPolicy == WHSQualityOrderFollowWorkInventDim::Always
                                                            || (inventParameters.QualityOrderWorkInventoryDimensionPolicy == WHSQualityOrderFollowWorkInventDim::NoTrackingDim
                                                                && !qualityOrderInventDim.anyTrackingDimensionSpecified());

                    if (mustFindWorkInventTrans)
                    {
                        while select inventDim
                        exists join inventTrans
                        where inventTrans.inventTransOrigin == inventTransOrigin.RecId
                            && InventTrans.inventDimId      == inventDim.inventDimId
                            && (!qualityOrderInventDim.LicensePlateId || inventDim.LicensePlateId == qualityOrderInventDim.LicensePlateId)
                        {
                            InventQualityOrderValidate::updateInventoryStorageDimensionByQualityOrderReferenceType(inventQualityOrderTable, inventDim, mustFindWorkInventTrans);

                            this.addInventDimToInventStatusConvertConversionTable(inventDim, inventQualityOrderTable.ItemId);

                            this.queryAddRange(dsInventDim, inventDim);
                        }
                    }
                    else
                    {
                        this.addInventDimRange(inventQualityOrderTable, dsInventDim, inventTransOrigin, qualityOrderInventDim, true, false);
                    }
                }
                else
                {
                    if (WHSQOInventStatusUpdateQueryTrackDimRangeV2Flight::instance().isEnabled())
                    {
                        this.addInventDimRange(inventQualityOrderTable, dsInventDim, inventTransOrigin, qualityOrderInventDim, false, inventQualityOrderValidateConvertUseTempDBForNonWHSWarehousesFlightEnabled);
                    }
                    else
                    {
                        InventDim::queryAddRange(dsInventDim, inventQualityOrderTable.inventDim());
                    }

                    QueryBuildDataSource dsInventTrans = dsInventDim.addDataSource(tableNum(InventTrans));
                    dsInventTrans.joinMode(JoinMode::ExistsJoin);
                    dsInventTrans.relations(true);
                    QueryBuildDataSource dsInventTransOrigin = dsInventTrans.addDataSource(tableNum(InventTransOrigin));
                    dsInventTransOrigin.joinMode(JoinMode::ExistsJoin);
                    dsInventTransOrigin.relations(true);
                    QueryBuildRange inventTransIdRange = SysQuery::findOrCreateRange(dsInventTransOrigin, fieldNum(InventTransOrigin,InventTransId));
                    inventTransIdRange.value(inventQualityOrderTable.InventRefTransId);
                }
                
                if (useInventStatusConvertConversionTable)
                {
                    inventStatusConvertConversionTablePhysicalName = inventStatusConvertConversionTable.getPhysicalTableName();
                            
                    // detach the tempdb table from the pool manager so it does not get cleaned up before WhsInventoryStatusConvert can use it
                    inventStatusConvertConversionTable.takeOwnershipOfTempDBTable(true);
                }
            }
            else
            {
                InventDim::queryAddRange(dsInventDim, inventQualityOrderTable.inventDim());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventDimRange</Name>
				<Source><![CDATA[
    private void addInventDimRange(InventQualityOrderTable _inventQualityOrderTable, QueryBuildDataSource _dsInventDim, InventTransOrigin _inventTransOrigin, InventDim _qualityOrderInventDim, boolean _updateStorageDimensions, boolean _useConversionTable)
    {
        InventTrans         inventTrans;
        InventDim           inventDim;

        boolean useConversionTable = _useConversionTable;

        if (!_updateStorageDimensions)
        {
            this.queryAddRange(_dsInventDim, _qualityOrderInventDim);
        }

        while select inventDim
        exists join inventTrans
        where inventTrans.inventTransOrigin == _inventTransOrigin.RecId
            && InventTrans.inventDimId      == inventDim.inventDimId
        {
            if (_updateStorageDimensions || InventDim::isInventDimParmEqual(_qualityOrderInventDim, inventDim, _qualityOrderInventDim.toDimParm(), false))
            {
                inventDim.clearStorageDimensions();
                if (_updateStorageDimensions)
                {
                    InventQualityOrderValidate::updateInventoryStorageDimensionByQualityOrderReferenceType(_inventQualityOrderTable, inventDim, false);
                }   
                
                if (useConversionTable)
                {
                    this.addInventDimToInventStatusConvertConversionTable(inventDim, _inventQualityOrderTable.ItemId);
                }

                if (inventDim.anyTrackingDimensionSpecified()
                    && InventDim::isInventDimEqual(inventDim, _qualityOrderInventDim, InventDim::dimTrackingDimEnabledFieldList()))
                {
                    // clear any previous added ranges for inventory dimension and only use the one where tracking dimension matches
                    _dsInventDim.clearRanges();
                    this.queryAddRange(_dsInventDim, inventDim);

                    if (inventQualityOrderValidateConvertUseTempDBForNonWHSWarehousesFlightEnabled)
                    {
                        // as soon as we are going to use only one range where the tracking dimension matches, there is no need to use a conversion table anymore
                        useConversionTable = false;
                        useInventStatusConvertConversionTable = false;
                    }

                    break;
                }
                else
                {
                    this.queryAddRange(_dsInventDim, inventDim);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemIdInventDimIdStrKey</Name>
				<Source><![CDATA[
    private str getItemIdInventDimIdStrKey(ItemId _itemId, InventDimId _inventDimId)
    {
        return strFmt("%1$%2", _itemId, _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventDimToInventStatusConvertConversionTable</Name>
				<Source><![CDATA[
    private void addInventDimToInventStatusConvertConversionTable(InventDim _inventDim, ItemId _itemId)
    {
        if (inventQualityOrderValidateConvertUseDimIdV2FlightEnabled)
        {
            InventDim conversionTableInventDim = InventDim::findOrCreate(_inventDim);

            str inventStatusConvertConversionTableSetKey = this.getItemIdInventDimIdStrKey(_itemId, conversionTableInventDim.inventDimId);
                        
            if (!inventStatusConvertConversionTableSet.in(inventStatusConvertConversionTableSetKey))
            {
                inventStatusConvertConversionTable.clear();
                inventStatusConvertConversionTable.ItemId = _itemId;
                inventStatusConvertConversionTable.InventDimId = conversionTableInventDim.inventDimId;
                inventStatusConvertConversionTable.insert();

                inventStatusConvertConversionTableSet.add(inventStatusConvertConversionTableSetKey);

                useInventStatusConvertConversionTable = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryAddRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds ranges to an inventDim datasource based on the values in the inventDim criteria.
    /// </summary>
    /// <param name="_dsInventDim">
    /// The InventDim datasource.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventDim criteria that will be set as ranges on the data source.
    /// </param>
    /// <remarks>
    /// Ranges will only be added for non-empty inventory dimensions.
    /// </remarks>
    private void queryAddRange(
        QueryBuildDataSource    _dsInventDim,
        InventDim               _inventDimCriteria)
    {
        ListEnumerator      enumerator = InventDim::dimFieldsList().getEnumerator();
        FieldId             inventDimFieldId;
        QueryBuildRange     queryRange;

        // Fields might not have been selected on the specified buffers, or might have been updated since selection
        _inventDimCriteria.checkInvalidFieldAccess(false);

        while (enumerator.moveNext())
        {
            inventDimFieldId = enumerator.current();

            if (_inventDimCriteria.(inventDimFieldId))
            {
                queryRange = _dsInventDim.addRange(inventDimFieldId);
                queryRange.value(queryValue(_inventDimCriteria.(inventDimFieldId)));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryStorageDimensionByQualityOrderReferenceType</Name>
				<Source><![CDATA[
    private static void updateInventoryStorageDimensionByQualityOrderReferenceType(
        InventQualityOrderTable _inventQualityOrderTable,
        InventDim               _inventDim,
        boolean                 _mustFindInventTrans)
    {
        if (!_inventQualityOrderTable.InventRefTransId)
        {
            return;
        }

        switch (_inventQualityOrderTable.ReferenceType)
        {
            case InventTestReferenceType::Purch:
            case InventTestReferenceType::Production:
                InventQualityOrderValidate::updateInventoryStorageDimensionFromLastClosedPutWorkline(_inventQualityOrderTable, _inventDim, _mustFindInventTrans);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryStorageDimensionFromLastClosedPutWorkline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the last closed put work line by type and status and update the inventory storage dimensions.
    /// </summary>
    /// <param name = "_inventQualityOrderTable">The quality order record.</param>
    /// <param name = "_inventDim">The current inventory dimension to be merged with work line inventory dimensions.</param>
    /// <param name = "_mustFindInventTrans">A flag controlling if the inventory transaction must be found.</param>
    private static void updateInventoryStorageDimensionFromLastClosedPutWorkline(
        InventQualityOrderTable _inventQualityOrderTable,
        InventDim               _inventDim,
        boolean                 _mustFindInventTrans)
    {
        WHSWorkLine workLine;
        WHSWorkTable workTable;

        if (_mustFindInventTrans)
        {
            select firstonly workLine
                order by workLine.LineNum desc
                join workTable
                    where workTable.WorkId == workLine.WorkId
                    && (!_inventDim.LicensePlateId || workTable.TargetLicensePlateId == _inventDim.LicensePlateId)
                    && workLine.WorkType        == WHSWorkType::Put
                    && workLine.WorkStatus      == WHSWorkStatus::Closed
                    && workLine.OrderNum        == _inventQualityOrderTable.InventRefId
                    && workLine.InventTransId   == _inventQualityOrderTable.InventRefTransId;
        
            if (workLine.RecId)
            {             
                InventDim inventDimStorageDimFromWorkLine;

                if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(workLine.WorkId))
                {
                    WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(workLine.WorkId).registeredReceiptByWorkLine(
                        workLine.LineNum,
                        WHSWorkInventoryTransactionQueryParameters::construct()
                            .setIncludeArchivedTransactions(true)
                            .setFirstOnly(true));

                    WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = inventoryTransactionDescriptor.firstOrDefault();

                    if (inventoryTransactionDescriptorElement)
                    {
                        inventDimStorageDimFromWorkLine = inventoryTransactionDescriptorElement
                            .parmInventoryDimensionsDescriptor()
                            .parmStorageDimensions()
                            .convertToInventDim();
                    }
                    else
                    {
                        inventDimStorageDimFromWorkLine.initFromInventDim(workLine.inventDim(), InventDim::dimStorageDimEnabledFieldList());
                    }
                }
                else
                {
                    InventTrans InventTrans;
                    InventTransOrigin transOrig;
                    InventDim fulltransInventDim;

                    select firstonly fulltransInventDim
                        where fulltransInventDim.wmsLocationId == workLine.wMSLocationId
                        join InventTrans
                        where InventTrans.inventDimId == fulltransInventDim.inventDimId
                        join transOrig
                        where InventTrans.InventTransOrigin == transOrig.RecId
                        && transOrig.ReferenceId == workLine.WorkId;

                    inventDimStorageDimFromWorkLine.initFromInventDim(fulltransInventDim ? fulltransInventDim : workLine.inventDim(), InventDim::dimStorageDimEnabledFieldList());
                }

                _inventDim.mergeUsedDim(InventDimGroupSetup::newItemId(workLine.ItemId), inventDimStorageDimFromWorkLine);
            }
        }
        else 
        {
            select firstonly workLine
            order by workLine.LineNum desc
            where  workLine.WorkType        == WHSWorkType::Put
                && workLine.WorkStatus      == WHSWorkStatus::Closed
                && workLine.OrderNum        == _inventQualityOrderTable.InventRefId
                && workLine.InventTransId   == InventTransOrigin::findByInventTransId(_inventQualityOrderTable.InventRefTransId).InventTransId;
        
            if (workLine.RecId)
            {
                InventDim inventDimStorageDimFromWorkLine;
                inventDimStorageDimFromWorkLine.initFromInventDim(workLine.inventDim(), InventDim::dimStorageDimEnabledFieldList());
                _inventDim.mergeUsedDim(InventDimGroupSetup::newItemId(workLine.ItemId), inventDimStorageDimFromWorkLine);
                _inventDim.wMSLocationId = workLine.WMSLocationId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventStatusByOrderStatus</Name>
				<Source><![CDATA[
    private WHSInventStatusId inventStatusByOrderStatus()
    {
        switch (inventQualityOrderTable.OrderStatus)
        {
            case InventTestOrderStatus::Fail:
                return inventQualityOrderTable.FailedInventStatusId;

            case InventTestOrderStatus::Pass:
                return inventQualityOrderTable.PassedInventStatusId;

            default:
                return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceDate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets system invoice date.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TransDate</c> class.
    /// </returns>
    public TransDate invoiceDate_IN()
    {
        return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packedUpdateInventStatusQuery = this.parmQualityOrder().allowUpdateInventoryStatus() ? updateInventStatusQuery.pack() : conNull();

        return [#CurrentVersion, #CurrentList, packedUpdateInventStatusQuery];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    public void getLast()
    {
        super();
        
        if (inventQualityOrderValidateConvertUseDimIdV2FlightEnabled)
        {
            useInventStatusConvertConversionTable = false;
            inventStatusConvertConversionTablePhysicalName = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcceptError</Name>
				<Source><![CDATA[
    public NoYes parmAcceptError(NoYes _acceptError = acceptError)
    {
        acceptError = _acceptError;

        return acceptError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsItemAndWarehouseQualityManagementProcessEnabled</Name>
				<Source><![CDATA[
    internal boolean parmIsItemAndWarehouseQualityManagementProcessEnabled(boolean _isItemAndWarehouseQualityManagementProcessEnabled = isItemAndWarehouseQualityManagementProcessEnabled)
    {
        isItemAndWarehouseQualityManagementProcessEnabled = _isItemAndWarehouseQualityManagementProcessEnabled;

        return isItemAndWarehouseQualityManagementProcessEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventStatusConvert</Name>
				<Source><![CDATA[
    public WHSInventoryStatusConvert parmInventStatusConvert(WHSInventoryStatusConvert _inventStatusConvert = null)
    {
        if (prmisDefault(_inventStatusConvert) && !inventStatusConvert)
        {
            inventStatusConvert = WHSInventoryStatusConvert::construct();
        }
        else if (!prmisDefault(_inventStatusConvert))
        {
            inventStatusConvert = _inventStatusConvert;
        }

        return inventStatusConvert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQualityOrder</Name>
				<Source><![CDATA[
    protected InventQualityOrderTable parmQualityOrder()
    {
        if (!inventQualityOrderTable)
        {
            inventQualityOrderTable = InventQualityOrderTable::find(inventQualityOrderId);
        }

        return inventQualityOrderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQualityOrderId</Name>
				<Source><![CDATA[
    public InventQualityOrderId parmQualityOrderId(InventQualityOrderId _inventQualityOrderId = inventQualityOrderId)
    {
        inventQualityOrderId = _inventQualityOrderId;

        return inventQualityOrderId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQualityReferenceType</Name>
				<Source><![CDATA[
    public InventQualityReferenceType parmQualityReferenceType(InventQualityReferenceType _qualityReferenceType = qualityReferenceType)
    {
        qualityReferenceType = _qualityReferenceType;

        return qualityReferenceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuarantineOnFailure</Name>
				<Source><![CDATA[
    NoYes parmQuarantineOnFailure(NoYes _quarantineOnFailure = quarantineOnFailure)
    {
        quarantineOnFailure = _quarantineOnFailure;

        return quarantineOnFailure;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateInventStatus</Name>
				<Source><![CDATA[
    public boolean parmUpdateInventStatus(boolean _updateInventoryStatus = updateInventStatus)
    {
        updateInventStatus = _updateInventoryStatus;

        return updateInventStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateInventStatusQuery</Name>
				<Source><![CDATA[
    public Query parmUpdateInventStatusQuery(Query _updateInventStatusQuery = updateInventStatusQuery)
    {
        updateInventStatusQuery = _updateInventStatusQuery;

        return updateInventStatusQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorker</Name>
				<Source><![CDATA[
    HcmWorkerRecId parmWorker(HcmWorkerRecId _worker = worker)
    {
        worker = _worker;

        return worker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qualityReferenceType</Name>
				<Source><![CDATA[
    protected InventQualityReferenceType qualityReferenceType()
    {
        if (!qualityReferenceType)
        {
            throw error(Error::missingParameter(this));
        }

        return qualityReferenceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyInventQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the <c>InventQualityOrderTable</c> record.
    /// </summary>
    /// <param name = "_orderStatus">The original quality order status.</param>
    protected void modifyInventQualityOrder(InventTestOrderStatus _orderStatus)
    {
        InventTestOrderStatus pdsUpdatedOrderStatus;

        if (#PdsShelfEnabled)
        {
            if (acceptError)
            {
                inventQualityOrderTable.OrderStatus = InventTestOrderStatus::Pass;
            }
            else
            {
                inventQualityOrderTable.updateQualityOrderLineTestResult();
                inventQualityOrderTable.setTestResult();
            }

            if (inventQualityOrderTable.allowUpdateBatchDisposition())
            {
                PdsUpdateDispositionStatus_Quality::newQuality(inventQualityOrderTable).runOperation();
            }

            pdsUpdatedOrderStatus = inventQualityOrderTable.OrderStatus;
            inventQualityOrderTable.OrderStatus = InventTestOrderStatus::Open;
        }

        if (_orderStatus == InventTestOrderStatus::Open
            && inventQualityOrderTable.TestDestructive == NoYes::Yes)
        {
            if (isItemAndWarehouseQualityManagementProcessEnabled || this.whsNeedToReSyncQualityOrderDimensions())
            {
                using (var context = WHSModifyQualityOrderPopulateDimensionsContext::newFromParameter(true))
                {
                    dimensionQtyList = this.buildDimensionQtyList();
                }

                this.updateInventTransDimensionFromQualityOrder();
            }

            this.updateInventory();
        }

        if (#PdsBatchAttribEnabled)
        {
            boolean updateBatchAttribute = inventQualityOrderTable.pdsValidateBatchAttributes('', acceptError);

            if (inventQualityOrderTable.ReferenceType == InventTestReferenceType::Inventory)
            {
                if (!acceptError
                            && !updateBatchAttribute)
                {
                    throw error("@PDS1037");
                }
                else if (!updateBatchAttribute)
                {
                    warning("@PDS1037");
                }
            }
        }

        if (!#PdsShelfEnabled)
        {
            if (acceptError)
            {
                inventQualityOrderTable.OrderStatus = InventTestOrderStatus::Pass;
            }
            else
            {
                inventQualityOrderTable.updateQualityOrderLineTestResult();
                inventQualityOrderTable.setTestResult();
            }
        }
        else
        {
            inventQualityOrderTable.OrderStatus = pdsUpdatedOrderStatus;
        }

        this.initInventQualityOrderTableValidationFields(inventQualityOrderTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>InventQualityOrderTable</c> record.
    /// </summary>
    /// <param name = "_orderStatus">The original quality order status.</param>
    protected void updateInventQualityOrder(InventTestOrderStatus _orderStatus)
    {
        this.modifyInventQualityOrder(_orderStatus);

        if (InventQualityOrderDualWriteToggle::instance().isEnabled())
        {
            using (var context = InventQualityOrderValidateProcessingUpdateContext::enterExecutionScope())
            {
                inventQualityOrderTable.update();
			}
		}
		else 
        {
			inventQualityOrderTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the actual quality order validation.
    /// </summary>
    /// <exception cref="M:Exception::UpdateConflict">
    ///    An update conflict exists.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    ///    An update conflict exists.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    Standard validation in the <c>validate</c> method failed.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The quality order is not open.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The relation to the reference is not completely specified.
    /// </exception>
    void run()
    {
        #OCCRetryCount
        InventTestOrderStatus       tmpOrderStatus;

        PdsCWInventQty              cwQtyDifference;
        PdsCWInventQty              cwQty;
        container                   c;

        InventBlockingQualityOrderSync  inventBlockingQualityOrderSync;
        InventQty                       qtyDifference;
        ListEnumerator                  dimensionQtyListEnumerator;
        InventDimId                     inventDimId;
        InventQty                       qty;

        int                             retryCount;

        if (!this.validate())
        {
            throw error("@SYS27040");
        }

        try
        {
            ttsbegin;
            inventQualityOrderTable = InventQualityOrderTable::find(inventQualityOrderId, true);

            if (InventTable::isItemCatchWeightAndWarehouseProcessEnabled(inventQualityOrderTable.ItemId)
                && (inventQualityOrderTable.UpdateInventStatus == NoYes::Yes
                    || this.UpdateInventStatus == NoYes::Yes))
            {
                WHSInventTable::ensureInventoryStatusChangedAllowedForItem(inventQualityOrderTable.ItemId, true);
            }

            tmpOrderStatus = inventQualityOrderTable.OrderStatus;

            if (inventQualityOrderTable.OrderStatus != InventTestOrderStatus::Open)
            {
                throw error("@SYS113888");
            }

            if (inventQualityOrderTable.Qty)
            {
                if (tmpOrderStatus == InventTestOrderStatus::Open
                    && inventQualityOrderTable.TestDestructive  == NoYes::Yes)
                {
                    if (!this.validateAgainstReference())
                    {
                        throw error(strFmt("@SYS114386", inventQualityOrderTable.QualityOrderId));
                    }

                    // <GIN>
                    if (TaxParameters::isExciseEnable_IN()
                    && (inventQualityOrderTable.ApplyIndiaTaxes_IN    == ApplyIndiaTaxes_IN::Excise
                        || inventQualityOrderTable.ApplyIndiaTaxes_IN == ApplyIndiaTaxes_IN::Both))
                    {
                        if (this.validateQualityOrder_IN())
                        {
                            this.updateExciseRegisters_IN();
                            inventQualityOrderTable.ValidateDate_IN = this.invoiceDate_IN();
                        }
                        else
                        {
                            throw error("@SYS104318");
                        }
                    }
                    // </GIN>
                }

                this.updateInventQualityOrder(tmpOrderStatus);

                dimensionQtyList = this.buildDimensionQtyList();

                using (var relatedInfo = InventBlockingRelatedTransactionInfoSingleton::instance().initializeRelatedBlockingTransactionRecordSet(inventQualityOrderTable))
                {
                    // Update or delete related inventory blocking
                    inventBlockingQualityOrderSync = InventBlockingQualityOrderSync::construct();
                    [qtyDifference, cwQtyDifference] = inventBlockingQualityOrderSync.onQualityOrderBlockingRequestDelete(inventQualityOrderTable); // Quality order no longer requires blocking

                    if (qtyDifference > 0 && inventQualityOrderTable.mustCreateQuarantineOrder())
                    {
                        dimensionQtyListEnumerator = dimensionQtyList.getEnumerator();
                        while (qtyDifference > 0 && dimensionQtyListEnumerator.moveNext())
                        {
                            [inventDimId, c] = dimensionQtyListEnumerator.current();
                            [qty, cwQty] = c;
                            qty = min(qty, qtyDifference);
                            cwQty = min(cwQty, cwQtyDifference);
                            InventQuarantineOrder::createFromQualityOrder(inventQualityOrderTable, inventDimId, qty, cwQty);
                            qtyDifference -= qty;
                        }
                    }
                }

                boolean whsStatusChange;

                if (qtyDifference > 0
                    && isItemAndWarehouseQualityManagementProcessEnabled
                    && WHSQualityOrderInventory::existsWithInventQualityOrderId(inventQualityOrderId))
                {
                    if (inventQualityOrderTable.TestDestructive == NoYes::No
                        &&  this.canQualityOutWorkBeCreated()
                        &&  (inventQualityOrderTable.FailedInventStatusId
                            && inventQualityOrderTable.OrderStatus == InventTestOrderStatus::Fail)
                        ||  (inventQualityOrderTable.PassedInventStatusId
                            && inventQualityOrderTable.OrderStatus == InventTestOrderStatus::Pass))
                    {
                        this.changeInventoryStatus();
                        whsStatusChange = true;
                    }
                }
                if (!whsStatusChange)
                {
                    this.updateInventoryStatus();
                }

                if (qtyDifference > 0
                    && isItemAndWarehouseQualityManagementProcessEnabled
                    && (this.canQualityOutWorkBeCreated()
                        || !WHSCreateQualityOutWorkForPurchAndProdRefTypeOnlyV2Flight::instance().isEnabled()))
                {
                    this.createQualityOutWork(qtyDifference);
                }

                this.onQualityOrderValidated();
            }
            else
            {
                warning(strFmt("@SYS113887", inventQualityOrderTable.QualityOrderId));
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (retryCount < #RetryNum)
            {
                retryCount++;
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onQualityOrderValidated</Name>
				<Source><![CDATA[
    public void onQualityOrderValidated()
    {
        // for extensibility purposes
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventQualityOrderTableValidationFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the validation related fields for the <c>InventQualityOrderTable</c> record.
    /// </summary>
    /// <param name = "_inventQualityOrderTable">The <c>InventQualityOrderTable</c> record to set.</param>
    protected void initInventQualityOrderTableValidationFields(InventQualityOrderTable _inventQualityOrderTable)
    {
        _inventQualityOrderTable.ValidatedByWorker = worker;
        _inventQualityOrderTable.ValidatedDateTime = DateTimeUtil::utcNow();
        _inventQualityOrderTable.QuarantineOnFailure = quarantineOnFailure;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer     version      = RunBase::getVersion(packedClass);
        container   packedStatusSelectionQuery;        

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedStatusSelectionQuery] = packedClass;

                if (packedStatusSelectionQuery != conNull())
                {
                    updateInventStatusQuery = new Query(packedStatusSelectionQuery);
                }

                break;

            case 5:
                [version, #CurrentList5, packedStatusSelectionQuery] = packedClass;

                if (packedStatusSelectionQuery != conNull())
                {
                    updateInventStatusQuery = new Query(packedStatusSelectionQuery);
                }

                break;

            case 4:
                [version, #CurrentList4, packedStatusSelectionQuery] = packedClass;

                if (packedStatusSelectionQuery != conNull())
                {
                    updateInventStatusQuery = new Query(packedStatusSelectionQuery);
                }

                break;

            case 3:
                [version, #CurrentList3] = packedClass;
                break;

            case 2:
                [version, #CurrentList2] = packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExciseRegisters_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the excise register information.
    /// </summary>
    protected void updateExciseRegisters_IN()
    {
        switch (inventQualityOrderTable.ReferenceType)
        {
            case InventTestReferenceType::Purch:

                if (!PurchLine::findInventTransId(inventQualityOrderTable.InventRefTransId).AssetId)
                {
                    VendorCalculationDateType_IN vendorCalculationDateType = TaxParameters::find().VendorCalculationDateType_IN;
                    if (vendorCalculationDateType    == VendorCalculationDateType_IN::DeliveryDate
                        || vendorCalculationDateType == VendorCalculationDateType_IN::DocumentDate)
                    {
                        TaxPurchQualityOrder_IN purchQualityOrderTaxes = TaxPurchQualityOrder_IN::construct(inventQualityOrderTable);
                        purchQualityOrderTaxes.updateExciseRegister_IN(null, inventQualityOrderTable);
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the posting of inventory and ledger transactions.
    /// </summary>
    protected void updateInventory()
    {
        if (!inventQualityOrderTable.TestDestructive || !inventQualityOrderTable.InventTransId)
        {
            return;
        }

        ttsbegin;

        this.beginLedger();

        InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newInventQualityOrder(
                    InventMovement::construct(inventQualityOrderTable),
                    ledgerVoucher,
                    -1 * inventQualityOrderTable.Qty);

        inventUpd_Financial.updateNow();

        this.commitLedger();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inventory status based on the results of the quality order validation.
    /// </summary>
    public void updateInventoryStatus()
    {
        if (this.parmUpdateInventStatus() && this.parmQualityOrder().allowUpdateInventoryStatus())
        {
            WHSInventStatusId newInventoryStatusId = this.inventStatusByOrderStatus();

            if (newInventoryStatusId)
            {
                WHSInventoryStatusConvert statusConvert = this.parmInventStatusConvert();  
                statusConvert.parmQuery(updateInventStatusQuery);
                statusConvert.parmToStatus(newInventoryStatusId);
                statusConvert.parmThrowOnError(true);
                statusConvert.parmInventBlockingComplete(this.parmQualityOrder().CompleteBlocking);                

                if (useInventStatusConvertConversionTable && inventQualityOrderValidateConvertUseDimIdV2FlightEnabled)
                {
                    if (inventStatusConvertConversionTablePhysicalName)
                    {
                        statusConvert.parmConversionInventDimItemTablePhysicalName(inventStatusConvertConversionTablePhysicalName);
                    }
                    else if (inventStatusConvertConversionTable.RecId)
                    {
                        inventStatusConvertConversionTablePhysicalName = inventStatusConvertConversionTable.getPhysicalTableName();
                        statusConvert.parmConversionInventDimItemTablePhysicalName(inventStatusConvertConversionTablePhysicalName);
                        
                        // detach the tempdb table from the pool manager so it does not get cleaned up before WhsInventoryStatusConvert can use it
                        inventStatusConvertConversionTable.takeOwnershipOfTempDBTable(true); 
                    }
                    else
                    {
                        throw error(Error::wrongUseOfFunction(funcName()));
                    }
                }
                else
                {
                    statusConvert.parmConversionInventDimItemTablePhysicalName('');
                }

                statusConvert.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Standard validation method for <c>RunBase</c> classes.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called. Default value is null.
    /// </param>
    /// <returns>
    /// true if the validation succeeded; otherwise, false.
    /// </returns>
    boolean validate(Object _calledFrom = null)
    {
        boolean ret;

        if (worker)
        {
            ret = HcmWorker::checkExist(worker);
        }
        else
        {
            ret = checkFailed("@SYS342565");
        }

        if (ret)
        {
            if (!InventQualityOrderTable::exist(inventQualityOrderId))
            {
                ret = checkFailed(strFmt("@SYS113826", inventQualityOrderId));
            }
        }

        if (ret)
        {
            if (!this.checkForQualityItemSamplingWork())
            {
                ret = checkFailed("@WAX:WHSQualityWorkExistsValidate");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAgainstReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the issue transactions match for the quality orders that have references to receipts
    /// and marks against them.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method returns true when the quality order is not related to a receipt or when the receipt
    /// transactions with the same inventory dimensions can be found.
    /// </remarks>
    public boolean validateAgainstReference()
    {
        InventTrans                     inventTransQualityOrder;
        InventTrans                     inventTransReference;
        InventDimParm                   inventDimParm;
        InventDim                       inventDimReceipt;
        InventDimParm                   inventDimParmReceipt;
        PmfQtyDataCarrier               outQuantities = new PmfQtyDataCarrier();
        InventDim                       inventDimQualityOrderTrans;
        Counter                         dimParmLoop;
        boolean                         isDimParmSet;

        List                            dimFields;

        #define.dimExactMatch(0)
        #define.dimMinMatchQualityTrans(1)
        #define.dimMinMatchQualityTransAllowBlankReceipt(2)

        boolean allowMarking()
        {
            ListEnumerator  enumerator;
            FieldId         dimFieldId;

            if (dimParmLoop == #dimExactMatch)
            {
                return true;
            }

            enumerator = dimFields.getEnumerator();
            while (enumerator.moveNext())
            {
                dimFieldId = enumerator.current();
                if ( inventDimReceipt.(dimFieldId) != inventDimQualityOrderTrans.(dimFieldId)  &&
                     inventDimParmReceipt.(InventDim::dim2dimParm(dimFieldId)) &&
                    (dimParmLoop != #dimMinMatchQualityTransAllowBlankReceipt || inventDimReceipt.(dimFieldId)))  // In third loop, allow dimension value on quality order transaction to match blank value on receipt dimension
                {
                    return false;
                }
            }
            return true;
        }

        void setInventDimParmReceipt()
        {
            switch (dimParmLoop)
            {
                case #dimExactMatch:
                    // First try to find receipt transactions that match quality order transactions 100% (same dimID)
                    if (!isDimParmSet)
                    {
                        inventDimParmReceipt.setAllInventDim();
                        isDimParmSet = true;
                    }
                    break;
                case #dimMinMatchQualityTrans: //Fall through
                // Secondly and third try to find receipt transaction that as minimum match all dimensions stated on quality order transaction
                case #dimMinMatchQualityTransAllowBlankReceipt:
                    // In third loop, allow dimension value on quality order transaction to match blank value on receipt dimension. (see local method allowMarking)
                    inventDimParmReceipt.initFromInventDim(inventDimQualityOrderTrans);
                    break;
            }
        }

        switch (inventQualityOrderTable.ReferenceType)
        {
            case    InventTestReferenceType::Purch:
            case    InventTestReferenceType::Production:
                if (!inventQualityOrderTable.InventRefTransId)
                {
                    return checkFailed("@SYS114396");
                }

                InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(inventQualityOrderTable.ItemId);
                inventDimParm.setAllInventDim();

                dimFields = inventDimGroupSetup.activeFields();

                InventTransOriginId qualityOrderInventTransOriginId = InventTransOriginQualityOrder::findInventTransOriginId(inventQualityOrderTable.DataAreaId, inventQualityOrderTable.QualityOrderId);
                InventTransOriginId referenceInventTransOriginId = InventTransOrigin::findByInventTransId(inventQualityOrderTable.InventRefTransId).RecId;
                // Validate marked quality order transactions
                select firstonly RecId  from inventTransQualityOrder
                    where   inventTransQualityOrder.InventTransOrigin           == qualityOrderInventTransOriginId
                         && inventTransQualityOrder.MarkingRefInventTransOrigin != referenceInventTransOriginId
                         && inventTransQualityOrder.StatusIssue                 != StatusIssue::Sold
                         && inventTransQualityOrder.StatusIssue                 != StatusIssue::None
                         && inventTransQualityOrder.StatusReceipt               == StatusReceipt::None
                         && inventTransQualityOrder.MarkingRefInventTransOrigin;
                // Quality order transactions may only be marked against receipts with the same lot as the reference lot on the quality order
                if (inventTransQualityOrder.RecId)
                {
                    return checkFailed(strFmt("@SYS114397", inventQualityOrderTable.InventRefTransId));
                }

                // Validate quality order transactions not yet marked and mark them
                while (dimParmLoop <= #dimMinMatchQualityTransAllowBlankReceipt)
                {
                    boolean continueLoop = false;
                    // Loop quality order transactions to validate and mark
                    while select sum(Qty),
                                 sum(PdsCWQty),
                                 InventDimId  from inventTransQualityOrder
                        group by InventDimId
                        where   inventTransQualityOrder.InventTransOrigin           == qualityOrderInventTransOriginId
                             && inventTransQualityOrder.StatusIssue                 != StatusIssue::Sold
                             && inventTransQualityOrder.StatusIssue                 != StatusIssue::None
                             && inventTransQualityOrder.StatusReceipt               == StatusReceipt::None
                             &&!inventTransQualityOrder.MarkingRefInventTransOrigin
                    {
                        InventQty markQty = -1 * inventTransQualityOrder.Qty;
                        PdsCWInventQty cwMarkQty = -1 * inventTransQualityOrder.PdsCWQty;
                        inventDimQualityOrderTrans = inventTransQualityOrder.inventDim();
                        setInventDimParmReceipt();

                        // Loop related receipt transactions.
                        while select Qty
                            , PdsCWQty,
                            ItemId
                            from inventTransReference
                            where    inventTransReference.InventTransOrigin             == referenceInventTransOriginId
                                 && !inventTransReference.MarkingRefInventTransOrigin
                                 && (inventTransReference.InventDimId                   == inventTransQualityOrder.InventDimId || dimParmLoop != #dimExactMatch)
                                 && (inventTransReference.StatusReceipt                 == StatusReceipt::Registered
                                 ||  inventTransReference.StatusReceipt                 == StatusReceipt::Received)
                            join inventDimReceipt
                                where inventDimReceipt.InventDimId == inventTransReference.InventDimId
                        {
                            if (allowMarking())
                            {
                                // Mark receipt and quality order to ensure the right costing.
                                InventQty markQtyUpd = min(markQty,inventTransReference.Qty);

                                PdsCWInventQty cwMarkQtyUpd = min(cwMarkQty, inventTransReference.PdsCWQty);

                                // Issue part

                                InventQty markedIssue = InventTransOrigin::updateMarking( qualityOrderInventTransOriginId,
                                                                                          referenceInventTransOriginId,
                                                                                          -1 * markQtyUpd,
                                                                                          '',
                                                                                          SortOrder::Ascending,
                                                                                          false,
                                                                                          inventDimQualityOrderTrans,
                                                                                          inventDimParm
                                                                                          , -1 * cwMarkQtyUpd
                                                                                          , outQuantities
                                                                                          );

                                PdsCWInventQty cwMarkedIssue = outQuantities.parmCwQty();

                                // Receipt part
                                InventQty markedReceipt = InventTransOrigin::updateMarking(   referenceInventTransOriginId,
                                                                                              qualityOrderInventTransOriginId,
                                                                                              markQtyUpd,
                                                                                              '',
                                                                                              SortOrder::Ascending,
                                                                                              false,
                                                                                              inventDimReceipt,
                                                                                              inventDimParmReceipt
                                                                                              , cwMarkQtyUpd
                                                                                              , outQuantities
                                                                                              );
                                PdsCWInventQty cwMarkedReceipt = outQuantities.parmCwQty();
                                if (markedIssue != -1 * markedReceipt)
                                {
                                    return checkFailed(strFmt("@SYS114399", inventDimQualityOrderTrans.preFix()));
                                }

                                markQty -= markedReceipt;
                                cwMarkQty -= cwMarkedReceipt;
                                // break out of this loop since full quantity has been marked. No need to look for more receipts.
                                if (markQty <= 0
                                    || (PdsGlobal::pdsIsCWItem(inventTransReference.ItemId) && cwMarkQty <= 0)
                                    )
                                {
                                    break;
                                }
                            }
                        }
                        if (markQty > 0
                            || (PdsGlobal::pdsIsCWItem(inventTransReference.ItemId) && cwMarkQty > 0)
                           )
                        {
                            // Only possible to fail in third loop
                            if (dimParmLoop == #dimMinMatchQualityTransAllowBlankReceipt)
                                return checkFailed(strFmt("@SYS114399", inventDimQualityOrderTrans.preFix()));

                            continueLoop = true;
                        }
                    }

                    if (!continueLoop)
                    {
                        // break out of this loop since full quantity has been marked. No need to look for more receipts.
                        break;
                    }
                    dimParmLoop++;
                }
                break;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateQualityOrder_IN</Name>
				<Source><![CDATA[
    private boolean validateQualityOrder_IN()
    {
        #ISOCountryRegionCodes
        TaxGroupData            taxGroupData;
        PurchLine               purchLine;
        SalesLine               salesLine;
        TaxOnItem               taxOnItem;
        TaxTable                taxTable;
        boolean                 ok = true;
        RefRecId                eccNumber;
        TransTaxInformation     transTaxInformation;

        if (TaxParameters::find().Excise_IN)
        {
            switch (inventQualityOrderTable.ReferenceType)
            {
                case InventTestReferenceType::Sales:

                    select firstonly RecId, InventTransId, TaxGroup, TaxItemGroup from salesLine
                            where salesLine.InventTransId == inventQualityOrderTable.InventRefTransId
                        join TaxCode from taxGroupData
                            where taxGroupData.TaxGroup == salesLine.TaxGroup
                        join TaxCode from taxOnItem
                            where taxOnItem.TaxItemGroup == salesLine.TaxItemGroup
                                  && taxOnItem.TaxCode      == taxGroupData.TaxCode
                        join TaxCode, TaxType_IN from  taxTable
                            where taxTable.TaxCode    == taxOnItem.TaxCode
                                  && taxTable.TaxType_IN == TaxType_IN::Excise;

                    if (salesLine.RecId)
                    {
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(salesLine);

                        if (transTaxInformation.ExciseType != ExciseType_IN::None)
                        {
                            if (transTaxInformation.ExciseType == ExciseType_IN::Manufacturer)
                            {
                                eccNumber = TaxInformation_IN::find(transTaxInformation.TaxInformation).ManECCRegistrationNumberTable;
                            }
                            else
                            {
                                eccNumber = TaxInformation_IN::find(transTaxInformation.TaxInformation).TraderECCRegistrationNumberTable;
                            }
                        }
                        if (eccNumber == 0)
                        {
                            ok = checkFailed("@GLS60823");
                        }

                        if (transTaxInformation.ExciseTariffCodes == 0)
                        {
                            ok = checkFailed("@GLS60824");
                        }

                        if (!transTaxInformation.ExciseDSA
                            && transTaxInformation.ExciseRecordType == ExciseRecordType_IN::None)
                        {
                            ok = checkFailed("@GLS60825");
                        }
                    }
                    break;

                case InventTestReferenceType::Purch:

                    select firstonly
                        RecId, InventTransId, TaxGroup, TaxItemGroup
                        from purchLine
                            where purchLine.InventTransId == inventQualityOrderTable.InventRefTransId
                        join  TaxCode from  taxGroupData
                            where taxGroupData.TaxGroup == purchLine.TaxGroup
                        join  TaxCode from taxOnItem
                            where taxOnItem.TaxItemGroup == purchLine.TaxItemGroup
                                && taxOnItem.TaxCode      == taxGroupData.TaxCode
                        join  TaxCode, TaxType_IN
                            from  taxTable
                            where taxTable.TaxCode    == taxOnItem.TaxCode
                                && taxTable.TaxType_IN == TaxType_IN::Excise;

                    if (purchLine.RecId)
                    {
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);

                        if (transTaxInformation.ExciseType != ExciseType_IN::None)
                        {
                            if (transTaxInformation.ExciseType == ExciseType_IN::Manufacturer)
                            {
                                eccNumber = TaxInformation_IN::find(transTaxInformation.TaxInformation).ManECCRegistrationNumberTable;
                            }
                            else
                            {
                                eccNumber = TaxInformation_IN::find(transTaxInformation.TaxInformation).TraderECCRegistrationNumberTable;
                            }
                        }
                        else
                        {
                            eccNumber = TaxInformation_IN::find(transTaxInformation.TaxInformation).eccNumber;
                        }

                        if (eccNumber == 0)
                        {
                            ok = checkFailed("@GLS60826");
                        }

                        if (transTaxInformation.ExciseTariffCodes == 0)
                        {
                            ok = checkFailed("@GLS60827");
                        }

                        if (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::None && transTaxInformation.ExciseDSA == NoYes::No)
                        {
                            ok = checkFailed("@GLS60828");
                        }
                    }
                    break;
            }
        }
        else
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsInventStatusSelection_clicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the clicked event on the inventory status update selection button.
    /// </summary>
    /// <param name="_buttonControl">
    /// The inventory status update selection button.
    /// </param>
    public void whsInventStatusSelection_clicked(FormButtonControl _buttonControl)
    {
        if (!inventQualityOrderTable)
        {
            inventQualityOrderTable = InventQualityOrderTable::find(inventQualityOrderId);
        }

        QueryRun queryRun = new QueryRun(updateInventStatusQuery);
        queryRun.saveUserSetup(false);
        if (queryRun.prompt())
        {
            updateInventStatusQuery = queryRun.query();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static InventQualityOrderValidate construct()
    {
        return new InventQualityOrderValidate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static public ClassDescription description()
    {
        return "@SYS113886";
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the <c>InventQualityOrderValidate</c> record's prompt.
    /// </summary>
    /// <param name = "_inventQualityOrderValidate">The quality order to prompt for</param>
    /// <returns>true if the prompt is successful; otherwise, false.</returns>
    protected static boolean runPrompt(InventQualityOrderValidate _inventQualityOrderValidate)
    {
        return _inventQualityOrderValidate.prompt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipRunPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the runPrompt method should be skipped.
    /// </summary>
    /// <returns>true if runPrompt must be skipped; otherwise, false.</returns>
    protected static boolean mustSkipRunPrompt()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipRunPromptWithArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the runPrompt method should be skipped.
    /// </summary>
    /// <param name = "_args">An instance of the <c>Args</c>.</param>
    /// <returns>true if runPrompt must be skipped; otherwise, false.</returns>
    protected static boolean mustSkipRunPromptWithArgs(Args _args)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args _args)
    {
        InventQualityOrderValidate  inventQualityOrderValidate;

        switch (_args.dataset())
        {
            case tableNum(InventQualityOrderTable):
                inventQualityOrderValidate = InventQualityOrderValidate::newQualityOrderTable(_args.record());
                break;
            default:
                throw error(strFmt("@SYS29104",classId2Name(classIdGet(inventQualityOrderValidate))));
        }

        if (!InventQualityOrderValidate::mustSkipRunPromptWithArgs(_args) &&
            !InventQualityOrderValidate::mustSkipRunPrompt() &&
            InventQualityOrderValidate::runPrompt(inventQualityOrderValidate))
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
            {
                inventQualityOrderValidate.runOperation();
            }

            if (_args.record() && FormDataUtil::isFormDataSource(_args.record()))
            {
                FormDataSource formDataSource = FormDataUtil::getFormDataSource(_args.record());
                formDataSource.reread();
                formDataSource.active();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newQualityOrderTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and initializes an <c>InventQualityOrderValidate</c> instance based on an
    ///    <c>InventQualityOrderTable</c> record.
    /// </summary>
    /// <param name="_table">
    ///    The <c>InventQualityOrderTable</c> record from which to create the instance.
    /// </param>
    /// <returns>
    ///    An <c>InventQualityOrderValidate</c> instance.
    /// </returns>
    static InventQualityOrderValidate newQualityOrderTable(InventQualityOrderTable _table)
    {
        InventQualityOrderValidate inventQualityOrderValidate = InventQualityOrderValidate::construct();

        inventQualityOrderValidate.getLast();
        inventQualityOrderValidate.parmQualityOrderId(_table.QualityOrderId);
        inventQualityOrderValidate.parmQuarantineOnFailure(_table.QuarantineOnFailure);
        inventQualityOrderValidate.parmUpdateInventStatus(_table.UpdateInventStatus);
        inventQualityOrderValidate.parmQualityReferenceType(InventQualityReferenceType::newFromQualityOrder(_table));        

        inventQualityOrderValidate.init();

        return inventQualityOrderValidate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForQualityItemSamplingWork</Name>
				<Source><![CDATA[
    private boolean checkForQualityItemSamplingWork()
    {
        boolean ret = true;

        WHSWorkTable workTable;
        
        select firstOnly RecId from workTable
            where workTable.InventQualityOrderId == inventQualityOrderId
                && (workTable.WorkStatus == WHSWorkStatus::Open
                    || workTable.WorkStatus == WHSWorkStatus::InProcess);
    
        if (workTable.RecId > 0)
        {
            ret = false;
        }
        else
        {
            WHSQualityOrderInventory qualityOrderInventory;

            select firstOnly RecId from qualityOrderInventory
                exists join workTable
                where qualityOrderInventory.WorkId == workTable.WorkId
                    && qualityOrderInventory.QualityOrderId == inventQualityOrderId
                    && (workTable.WorkStatus == WHSWorkStatus::Open
                        || workTable.WorkStatus == WHSWorkStatus::InProcess);
    
            if (qualityOrderInventory.RecId > 0)
            {
                ret = false;
            }
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQualityOutWork</Name>
				<Source><![CDATA[
    private void createQualityOutWork(InventQty _qtyDifference)
    {
        WHSWorkCreateQualityOut workCreate;
        ListEnumerator          dimensionQtyListEnumerator = dimensionQtyList.getEnumerator();
        InventQty               runningQty = _qtyDifference;
        WHSWorkBuildId          workBuildId;

        // Only attempt to create quality out work if there have been work templates setup
        if (WHSWorkTemplateTable::validTemplateExistsForWorkTransType(WHSWorkTransType::QualityOrder))
        {
            while (runningQty > 0 && dimensionQtyListEnumerator.moveNext())
            {
                InventDimId             inventDimId;
                InventQty               qty;

                if (PdsGlobal::pdsIsCWItem(inventQualityOrderTable.ItemId))
                {
                    container               conLoc;
                    [inventDimId, conLoc] = dimensionQtyListEnumerator.current();
                    qty = conPeek(conLoc, 2);
                }
                else 
                {
                    [inventDimId, qty] = dimensionQtyListEnumerator.current();
                }

                workCreate = WHSWorkCreateQualityOut::newFromParms(inventQualityOrderTable, workBuildId);
                workCreate.parmStartInventDim(inventDimId);
                workCreate.parmUpdateQty(qty);

                workBuildId = workCreate.createWork();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeInventoryStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the status of inventory that was sampled by the quality order.
    /// </summary>
    protected void changeInventoryStatus()
    {
        ListEnumerator  dimensionQtyListEnumerator = dimensionQtyList.getEnumerator();
        InventDimId     inventDimId;
        InventQty       qty;

        List newDimensionList = new List(Types::Container);

        ttsbegin;
    
        while (dimensionQtyListEnumerator.moveNext())
        {
            // Get current inventory dimension and qty
            [inventDimId, qty] = dimensionQtyListEnumerator.current();
    
            InventDim inventDimFrom = InventDim::find(inventDimId);
    
            // Check availability of inventory
            InventQty availPhys = WHSInventOnHand::getPhysicalAvailQty(inventQualityOrderTable.ItemId, InventDimFrom, true);
            if (qty > availPhys)
            {
                // If we don't have enough available inventory try reservation thefting
                if (InventLocation::find(inventDimFrom.InventLocationId).AllowMarkingReservationRemoval >= WHSAllowMarkingReservationRemoval::Reservation)
                {
                    WHSReservation::staticRemoveReservation(inventQualityOrderTable.ItemId, inventDimFrom.inventDimId, qty, InventTransType::QualityOrder, inventQualityOrderTable.QualityOrderId, '', true);
                }
            }
    
            // Create new status inventDim
            InventDim inventDimTo = InventDim::find(inventDimId);
            inventDimTo.InventStatusId = inventQualityOrderTable.OrderStatus == InventTestOrderStatus::Fail ? inventQualityOrderTable.FailedInventStatusId : inventQualityOrderTable.PassedInventStatusId;
            inventDimTo = InventDim::findOrCreate(inventDimTo);
    
            // Create Quarantine work
            WHSWorkQuarantine quarantineWork;
            quarantineWork.clear();
            quarantineWork.setWorkId();
            quarantineWork.ItemId = inventQualityOrderTable.ItemId;
            quarantineWork.Qty = qty;
            quarantineWork.InventQtyRemain = qty;
            quarantineWork.TransDateTime  = DateTimeUtil::utcNow();
            quarantineWork.InventDimIdFrom = inventDimId;
            quarantineWork.InventDimIdTo = inventDimTo.inventDimId;
            // We have to insert the record in the loop rather than using a set-based operation
            // in order for the execute method below to work correctly.
            quarantineWork.insert();
            quarantineWork.execute(quarantineWork.InventQtyRemain);
    
            // Insert new values into dimension list
            newDimensionList.addEnd([inventDimTo.inventDimId, qty]);
        }
    
        // Replace old dimension list with new dimension list
        dimensionQtyList = newDimensionList;
    
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIsWHSQualityManagementProcessEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if we are going to be using advanced quality management process in warehouse.
    /// </summary>
    private void initIsWHSQualityManagementProcessEnabled()
    {
        if (inventQualityOrderId)
        {
            isItemAndWarehouseQualityManagementProcessEnabled = InventQualityReferenceType::newFromQualityOrder(InventQualityOrderTable::find(inventQualityOrderId)).isItemAndWarehouseQualityManagementProcessEnabled();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransDimensionFromQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quality order inventTrans records to hold the full physical inventory dimension of the quality order inventory.
    /// </summary>
    private void updateInventTransDimensionFromQualityOrder()
    {
        ListEnumerator          dimensionQtyListEnumerator = dimensionQtyList.getEnumerator();
        InventQty               runningQty;
        InventDimId             inventDimId;
        InventQty               qty;
        
        ttsbegin;
    
        while (dimensionQtyListEnumerator.moveNext())
        {
            [inventDimId, qty] = dimensionQtyListEnumerator.current();
            runningQty = qty;
    
            InventTrans             qualityOrderInventTrans;
            InventTransOrigin       inventTransOrigin;
            InventDim               inventDim;

            // We can assume that any inventTrans with location filled has already been updated to the correct inventDim
            while select forUpdate qualityOrderInventTrans
                exists join inventTransOrigin
                where qualityOrderInventTrans.InventTransOrigin == InventTransOrigin.RecId &&
                      inventTransOrigin.InventTransId == inventQualityOrderTable.InventTransId
                exists join inventDim
                where qualityOrderInventTrans.inventDimId == inventDim.inventDimId &&
                        inventDim.wMSLocationId == ''
            {
                if (!runningQty)
                {
                    break;
                }
    
                InventMovement movement = qualityOrderInventTrans.inventMovement();
                InventDim fromInventDim = qualityOrderInventTrans.inventDim();
                InventDim toInventDim = InventDim::find(inventDimId);
    
                InventQty changeQuantity;
                if (runningQty > qualityOrderInventTrans.Qty)
                {
                    changeQuantity = qualityOrderInventTrans.Qty;
                    runningQty += qualityOrderInventTrans.Qty;
                }
                else
                {
                    changeQuantity = -runningQty;
                    runningQty = 0;
                }

                InventDimParm fromInventDimParm;
                fromInventDimParm.initFromInventDim(fromInventDim);

                InventDimParm toInventDimParm;
                toInventDimParm.initFromInventDim(toInventDim);

                InventUpd_Picked::newParameters(
                        movement,
                        toInventDim,
                        toInventDimParm,
                        fromInventDim,
                        fromInventDimParm,
                        changeQuantity)
                    .updateNow();
            }
        }
    
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsNeedToReSyncQualityOrderDimensions</Name>
				<Source><![CDATA[
    private boolean whsNeedToReSyncQualityOrderDimensions()
    {
        //on whs enabled warehouses we didn't sync all dimensions when doing quality order reservation because we needed to delay the reservation if work is created.
        return  inventQualityOrderTable.inventDim().inventLocation().WHSEnabled
            &&  InventMovement::construct(inventQualityOrderTable).canHaveReservedWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canQualityOutWorkBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Controls if the warehouse work can be created for the quality order.
    /// </summary>
    protected boolean canQualityOutWorkBeCreated()
    {
        return inventQualityOrderTable.ReferenceType == InventTestReferenceType::Production
            || inventQualityOrderTable.ReferenceType == InventTestReferenceType::Purch;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>