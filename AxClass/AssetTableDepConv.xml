<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetTableDepConv</Name>
	<SourceCode>
		<Declaration><![CDATA[
//
//  The primary functionality of this class type is to calculate the
//  asset depreciation amounts for fixed assets employing a depreciation
//  convention. For this purpose this class type must always be used in
//  conjuction with the AssetTableMethod_SL and AssetTableMethod_RB asset
//  depreciation amount calculation classes.
//
//  This secondary functionality of this class type is to calculate the
//  asset depreciation start date for fixed assets employing a depreciation
//  convention.
//
public abstract class AssetTableDepConv
{
    #Define.monthsInYear(12)
    #Define.monthsInHalfYear(6)
    #Define.monthsInQuarter(3)

    AssetBook                   assetBook;
    AssetTableInterval          depreciationInterval;
    AssetDepreciationProfile    depreciationProfile;
    boolean                     isFirstYear;
    boolean                     islastYear;
    TransDate                   assetPeriodDate;
    TransDate                   lastDepreciationDate;
    AssetServiceLife            startingServiceLife;
    AssetDepreciationTime       lastYear;
    AssetDepreciationTime       numberOfyear;
    boolean                     firstMonth;
    TransDate                   lastYearDepreciationDate;
    boolean                     isOtherAdjustment;
    boolean                     isProratedDaysCalculation;
    boolean                     isPartialMonthCalculation;
    internal boolean isReportingCurrencyDepreciation;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustLastDepreciationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the projected depreciation date based on a given depreciation convention.
    /// </summary>
    /// <param name="_endDate">
    /// A date to adjust
    /// </param>
    /// <param name="_partialPeriod">
    /// Value model's life remaining.
    /// </param>
    /// <returns>
    /// Adjusted date of the last projected depreciation date.
    /// </returns>
    protected TransDate adjustLastDepreciationDate(TransDate _endDate, real _partialPeriod = 0)
    {
        return _endDate - 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLastDepreciationDatePartialPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the projected depreciation date based on a given depreciation convention for
    /// value models with partial period that have a partial period.
    /// </summary>
    /// <param name="_endDate">
    /// A date to adjust
    /// </param>
    /// <param name="_partialPeriod">
    /// Depreciation book's life remaining.
    /// </param>
    /// <returns>
    /// Adjusted date of the last projected depreciation date.
    /// </returns>
    /// <remarks>
    /// This method is used for None and Half Year Start depreciation conventions.
    /// </remarks>
    protected TransDate adjustLastDepreciationDatePartialPeriod(TransDate _endDate, real _partialPeriod)
    {
        TransDate returnDate = _endDate;

        int numberOfDays;
        TransDate firstDayOfMonthAcq;
        TransDate lastDayOfMonthAcq;
        TransDate firstDayOfMonthLastDepr;
        TransDate lastDayOfMonthLastDepr;
        int dateDifferenceAcqMonth;
        int dateDifferenceLastDeprMonth;
        int dayOfPeriod;

        real partOfPeriod = frac(_partialPeriod);

        // If the life remaining has a partial value, the number of days in the last period will be prorated
        // based on the number of days used in the first period of depreciation.
        if (partOfPeriod)
        {
            if (depreciationProfile.DepreciationYear == AssetDepreciationYear::Fiscal)
            {
                returnDate += 1;

                // Determine if Acquisition period length matches the last period of depreciation.
                firstDayOfMonthAcq = depreciationInterval.findFirstDayOfMonth(assetBook.DepreciationStartDate);
                lastDayOfMonthAcq = depreciationInterval.findLastDayOfMonth(assetBook.DepreciationStartDate);
                dateDifferenceAcqMonth = date2num(lastDayOfMonthAcq) - date2num(firstDayOfMonthAcq) + 1;

                firstDayOfMonthLastDepr = depreciationInterval.findFirstDayOfMonth(returnDate);
                lastDayOfMonthLastDepr = depreciationInterval.findLastDayOfMonth(returnDate);
                dateDifferenceLastDeprMonth = date2num(lastDayOfMonthLastDepr) - date2num(firstDayOfMonthLastDepr) + 1;

                // If the periods match, match the day of period of the acquistion, to the same date if the last depreciation period.
                if (dateDifferenceLastDeprMonth == dateDifferenceAcqMonth
                    && frac(assetBook.LifeTime) == 0)
                {
                    dateDifferenceLastDeprMonth = assetBook.DepreciationStartDate - firstDayOfMonthAcq - 1;
                    returnDate = returnDate + dateDifferenceLastDeprMonth;
                }
                else
                {
                    if (dateDifferenceLastDeprMonth > 0)
                    {
                        numberOfDays = real2int(partOfPeriod * dateDifferenceLastDeprMonth);
                        returnDate = firstDayOfMonthLastDepr + numberOfDays;
                    }
                }
            }
            else
            {
                dayOfPeriod = dayOfMth(assetBook.DepreciationStartDate) - 1;
                if (dayOfPeriod > 0 && dayOfPeriod < 31)
                {
                    returnDate += 1;
                    returnDate = mkDate(dayOfPeriod, mthOfYr(returnDate), year(returnDate));
                }
            }
        }

        return returnDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLifeTimeRest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the value of Life Time Remaining
    /// </summary>
    /// <param name="_lifeTimeRest">
    /// Life Time Remaining number
    /// </param>
    /// <returns>
    /// Life Time Remaining number
    /// </returns>
    protected AssetDepreciationTime adjustLifeTimeRest(AssetDepreciationTime  _lifeTimeRest)
    {
        return round(_lifeTimeRest, 0.01);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_RB</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calculates the "Reducing Balance" type period depreciation amount
    /// for the asset's current transaction.
    /// </summary>
    /// <param name="_basisForDepreciation">
    /// Amount to be taken as the base amount to calculate depreciation.
    /// </param>
    /// <param name="_prevDepAmountThisYear">
    /// Depreciation amount for the current year.
    /// </param>
    /// <param name="_depreciationDate">
    /// The depreciation start date.
    /// </param>
    /// <param name="_periods">
    /// The period for which to calculate depreciation amount.
    /// </param>
    /// <returns>
    /// Returns the depreciation amount.
    /// </returns>
    public AssetAmount calc_RB(AssetAmount _basisForDepreciation,
                               AssetAmount _prevDepAmountThisYear,
                               TransDate   _depreciationDate,
                               AssetDepreciationTime _periods)
    {
        //
        //  This is the default implementation.
        //  Overriding this method offers a way to change to returned value.
        //
        try
        {
            this.setAssetPeriodDate(_depreciationDate, _periods, depreciationProfile.AssetEndDependOnServiceLife ? false : true);
            return this.calc_ReducingBalance(_basisForDepreciation, _depreciationDate);
        }
        catch
        {
            //
            //  An error has occurred within this calculation process.
            //  Report which AssetId and BookId the error occurred on.
            //  The actual error caught may provide more detailed information in the infolog.
            //
            throw error(strFmt("@FixedAssets:FA_MessageError_DepreciationAmountCannotBeCalculated", assetBook.AssetId, assetBook.BookId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_ReducingBalance</Name>
				<Source><![CDATA[
    //
    //  This is the base calculation for the Reducing Balance depreciation methods.
    //
    protected AssetAmount calc_ReducingBalance(AssetAmount _basisForDepreciation,
                                               TransDate   _depreciationDate)
    {
        ;
        //
        //  _basisForDepreciation  =
        //      amount to depreciate - total depreciations for all prior years - any extraordinary depreciations.
        //
        //  This amount is then divided by the number of accrual periods in the year based on the depreciation date.
        //
        return _basisForDepreciation / depreciationInterval.assetDepreciationTime(_depreciationDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_SL</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calculates the "Straight Line" type period depreciation amount
    /// for the asset's current transaction.
    /// </summary>
    /// <param name="_basisForDepreciation">
    /// Amount to be taken as the base amount to calculate depreciation.
    /// </param>
    /// <param name="_prevDepAmountThisYear">
    /// Depreciation amount for the current year.
    /// </param>
    /// <param name="_prevDepAmountExternal">
    /// Depreciation amount from other method.
    /// </param>
    /// <param name="_prevDepAmountPriorYears">
    /// Depreciation amount for previous years.
    /// </param>
    /// <param name="_depreciationDate">
    /// The depreciation start date.
    /// </param>
    /// <param name="_periods">
    /// The period for which to calculate depreciation amount.
    /// </param>
    /// <returns>
    /// Returns the depreciation amount.
    /// </returns>
    public AssetAmount calc_SL(AssetAmount   _basisForDepreciation,
                               AssetAmount   _prevDepAmountThisYear,
                               AssetAmount   _prevDepAmountExternal,
                               AssetAmount   _prevDepAmountPriorYears,
                               TransDate     _depreciationDate,
                               AssetDepreciationTime _periods)
    {
        //
        //  This is the default implentation.
        //  Overriding this method offers a way to change to returned value.
        //
        try
        {
            this.setAssetPeriodDate(_depreciationDate, _periods, false);
            return this.calc_StraightLine(_basisForDepreciation, _prevDepAmountThisYear, _prevDepAmountExternal, _periods);
        }
        catch
        {
            //
            //  An error has occurred within this calculation process.
            //  Report which AssetId and BookId the error occurred on.
            //  The actual error caught may provide more detailed information in the infolog.
            //
            throw error(strFmt("@FixedAssets:FA_MessageError_DepreciationAmountCannotBeCalculated", assetBook.AssetId, assetBook.BookId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_SLP_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calculates the "Straight Line Percentage" type period depreciation amount
    ///  for the asset's current transaction.
    /// </summary>
    /// <param name="_basisForDepreciation">
    /// Amount to be taken as the base amount to calculate depreciation.
    /// </param>
    /// <param name="_prevDepAmountThisYear">
    /// Depreciation amount for prev year.
    /// </param>
    /// <param name="_depreciationDate">
    /// The depreciation start date.
    /// </param>
    /// <param name="_periods">
    /// The period for which to calculate depreciation amount.
    /// </param>
    /// <returns>
    /// Returns the amount calculated as SLP type period depreciation.
    /// </returns>
    public AssetAmount calc_SLP_IN(AssetAmount              _basisForDepreciation,
                                   AssetAmount              _prevDepAmountThisYear,
                                   TransDate                _depreciationDate,
                                   AssetDepreciationTime    _periods)
    {
        //  This is the default implementation.
        //  Overriding this method offers a way to change to returned value.
        try
        {
            this.setAssetPeriodDate(_depreciationDate, _periods, true);
            return this.calc_StraightLinePercentage_IN(_basisForDepreciation, _depreciationDate);
        }
        catch
        {
            //  An error has occurred within this calculation process.
            //  Report which AssetId and BookId the error occurred on.
            //  The actual error caught may provide more detailed information in the infolog.
            throw error(strFmt("@FixedAssets:FA_MessageError_DepreciationAmountCannotBeCalculated", assetBook.AssetId, assetBook.BookId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_StraightLine</Name>
				<Source><![CDATA[
    //
    //  This is the base calculation for the Straight Line depreciation methods.
    //
    protected AssetAmount calc_StraightLine(AssetAmount   _basisForDepreciation,
                                            AssetAmount   _prevDepAmountThisYear,
                                            AssetAmount   _prevDepAmountExternal,
                                            AssetDepreciationTime _periods)
    {
        AssetAmount periodAmount;

        switch (depreciationProfile.Method)
        {
            case AssetDepreciationMethod::StraightLineLifeRemaining:
                //
                //  _basisForDepreciation  =
                //      amount to depreciate - total depreciations for all prior years - any extraordinary depreciations.
                //
                //  _prevDepAmountThisYear =
                //      total depreciations for this year.
                //
                //  _prevDepAmountExternal =
                //      difference between the primary and secondary depreciation amounts.
                //
                //  This amount is then divided by the number of remaining periods in the assets lifetime.
                //
                periodAmount =  (_basisForDepreciation -
                                 _prevDepAmountThisYear -
                                 _prevDepAmountExternal)
                                  / _periods;
                break;

            case AssetDepreciationMethod::StraightLine:
                //
                //  _basisForDepreciation  =
                //      amount to depreciate.
                //
                //  This amount is then divided by the assets expected lifetime.
                //
                periodAmount = _basisForDepreciation / assetBook.LifeTime;
                break;

            default:
                throw error(strFmt("@SYS99068", depreciationProfile.Profile));
        }
        return periodAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_StraightLinePercentage_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This is the base calculation for the Straight Line Percentage depreciation method.
    /// </summary>
    /// <param name="_basisForDepreciation">
    /// The base amount for depreciation.
    /// </param>
    /// <param name="_depreciationDate">
    /// The depreciation start date.
    /// </param>
    /// <returns>
    /// The depreciation amount.
    /// </returns>
    protected AssetAmount calc_StraightLinePercentage_IN(AssetAmount    _basisForDepreciation,
                                                         TransDate      _depreciationDate)
    {
        //  _basisForDepreciation  =
        //      amount to depreciate  - any extraordinary depreciations.
        //  This amount is then divided by the number of accrual periods in the year based on the depreciation date.
        return _basisForDepreciation / depreciationInterval.assetDepreciationTime(_depreciationDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCurrencyAmount</Name>
				<Source><![CDATA[
    //
    //  This method calculates the asset's period depreciation amount into the correct currency.
    //
    //  This method assumes that an instance of this class type exists
    //  and that calc_RB() or calc_SL() methods have already been run.
    //
    public AssetAmount calcCurrencyAmount(AssetAmount _amount, AssetDepreciationTime _periods)
    {
        //
        //  The default implementation is to adjust the passed in amount by the _period value
        //  prior to performing the currency calculation. This is done to correct the calculated
        //  amount by the actual period of it's lifetime it was depreciated.
        //
        //  Overriding this method offers a way to change the returned value.
        //
        AssetAmount amount;

        if (assetBook.RecId)
        {
            amount = assetBook.roundDepreciationAmount(
                _amount * _periods,
                isReportingCurrencyDepreciation);
        }
        else
        {
            amount = CurrencyExchangeHelper::amount(_amount * _periods, this.getCurrencyCode());
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDisposalNumberDepreciationPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of depreciation periods used in the final year of the disposal.
    /// </summary>
    /// <param name="_disposalTransDate">
    /// The disposal transaction date.
    /// </param>
    /// <param name="_projectedLastDayOfDepreciation">
    /// The expected last date of depreciation.
    /// </param>
    /// <param name="_isDisposalSameYear">
    /// Indicates whether asset acquisition and disposal are in same year.
    /// </param>
    /// <returns>
    /// The number of periods that is based on a convention rule.
    /// </returns>
    public AssetDepreciationTime calcDisposalNumberDepreciationPeriods(
        TransDate       _disposalTransDate,
        AssetTransDate  _projectedLastDayOfDepreciation,
        boolean         _isDisposalSameYear)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRestPeriod</Name>
				<Source><![CDATA[
    //
    //  This method returns the adjustment to asset's remaining life.
    //
    //  This method assumes that an instance of this class type exists
    //  and that calc_RB() or calc_SL() methods have already been run.
    //
    public AssetDepreciationTime calcRestPeriod(AssetDepreciationTime   _restPeriod,
                                                AssetTransDate          _periodstart,
                                                AssetDepreciationTime   _periods)
    {
        //
        //  The default implentation is to return the passed in value.
        //  Overriding this method offers a way to change to returned value.
        //
        return _restPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcStartDate</Name>
				<Source><![CDATA[
    //
    //  This method calculates the asset's starting depreciation date.
    //
    protected AssetDepreciationStartDate calcStartDate(AssetUsedFromDate _usedFromDate)
    {
        //
        //  Overridding this method offers a way to changed the returned value.
        //  The AssetBook.usedFromDate is considered to be the "placed in service date".
        //
        return _usedFromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDisposalDepreciationAdjRatio</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the portion of the depreciation allowed for a given period based on the date of the disposal.
    /// </summary>
    /// <param name="_disposalTransDate">
    /// The date of the disposal.
    /// </param>
    /// <returns>
    /// The portion of depreciation.
    /// </returns>
    public real calculateDisposalDepreciationAdjRatio(
        TransDate  _disposalTransDate)
    {
        AssetDepreciationTime   numberOfPeriods;
        AssetDepreciationTime   numberOfPeriodsInYear;
        real                    adjustedDepreciation;
        boolean                 isDisposalSameYear;

        this.updateDisposalFirstLastYear(_disposalTransDate);

        isDisposalSameYear =
            (depreciationInterval.findLastDayOfYear(assetBook.UsedFromDate)
                == depreciationInterval.findLastDayOfYear(_disposalTransDate)) ? true : false;

        // If the disposal is done after the asset is fully depreciated, there is no need for the adjustment.
        if (_disposalTransDate > lastDepreciationDate)
        {
            adjustedDepreciation = 1;
        }
        else
        {
            numberOfPeriodsInYear = this.getNumberOfPeriodsInYear(
                    _disposalTransDate,
                    lastDepreciationDate,
                    isDisposalSameYear);

            if (numberOfPeriodsInYear)
            {
                numberOfPeriods = this.calcDisposalNumberDepreciationPeriods(
                    _disposalTransDate,
                    lastDepreciationDate,
                    isDisposalSameYear);

                adjustedDepreciation = numberOfPeriods / numberOfPeriodsInYear;
            }
        }

        return adjustedDepreciation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsFirstYear</Name>
				<Source><![CDATA[
    //
    //  This method checks if the current depreciation transaction date
    //  is in the asset's estimated first year of depreciation.
    //
    protected void checkIsFirstYear(TransDate _depreciationDate)
    {
        boolean  retValue = false;

        switch (depreciationProfile.DepreciationYear)
        {
            case AssetDepreciationYear::Fiscal:
                //
                //  Is the current asset transaction date during the
                //  fiscal year of the assets depreciation start date.
                //
                retValue = _depreciationDate >= depreciationInterval.openingPeriodDate(assetBook.DepreciationStartDate) &&
                           _depreciationDate <= depreciationInterval.closingPeriodDate(assetBook.DepreciationStartDate);
                break;

            case AssetDepreciationYear::Calendar:
                //
                //  Is the current asset transaction date during the
                //  calandar year of the assets depreciation start date.
                //
                retValue = _depreciationDate >= depreciationInterval.openingPeriodDate(assetBook.DepreciationStartDate) &&
                           _depreciationDate <= depreciationInterval.closingPeriodDate(assetBook.DepreciationStartDate);
                break;

            default:
                //  The enumeration is unknown, throw an error;
                throw error(strFmt("@SYS99083", depreciationProfile.Profile));
        }

        //Modifed code to avoid, applying convention rule in case of of other adjustment.
        if (isOtherAdjustment)
        {
            retValue = false;
        }

        isFirstYear = retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsLastYear</Name>
				<Source><![CDATA[
    //
    //  This method checks if the asset's current depreciation transaction date
    //  is in the year of the asset's estimated last depreciation date.
    //
    protected void checkIsLastYear(TransDate                _depreciationDate,
                                   AssetDepreciationTime    _periods,
                                   boolean                  _isRB_Calc = false)
    {
        boolean retValue = false;

        if (lastDepreciationDate == dateNull())
        {
            //  Set the asset's estimated last depreciation date if it is not already set.
            this.setLastDepreciationDate(_depreciationDate, _periods, _isRB_Calc);
        }

        if (! _isRB_Calc)
        {
            switch (depreciationProfile.DepreciationYear)
            {
                case AssetDepreciationYear::Fiscal:
                    if (lastDepreciationDate != maxDate())
                    {
                        if (_depreciationDate >= depreciationInterval.openingPeriodDate(lastDepreciationDate) &&
                            _depreciationDate <= depreciationInterval.closingPeriodDate(lastDepreciationDate))
                        {
                            retValue = true;
                        }
                    }
                    break;

                case AssetDepreciationYear::Calendar:
                    if (_depreciationDate >= depreciationInterval.openingPeriodDate(lastDepreciationDate) &&
                        _depreciationDate <= depreciationInterval.closingPeriodDate(lastDepreciationDate))
                    {
                        retValue = true;
                    }
                    break;

                default:
                    //  The enumeration is unknown, throw an error;
                    throw error(strFmt("@SYS99083", depreciationProfile.Profile));
            }
        }
        //Modifed code to avoid, applying convention rule in case of of other adjustment.
        if (isOtherAdjustment)
        {
            retValue = false;
        }

        islastYear = retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>depreciationPercentage_SL</Name>
				<Source><![CDATA[
    //
    //  This method returns the correct "Straight Line" depreciation
    //  percentage based on the asset's selected "straight line" depreciation method.
    //
    protected Percent depreciationPercentage_SL()
    {
        Percent percent;

        switch (depreciationProfile.Method)
        {
            case AssetDepreciationMethod::StraightLineLifeRemaining:
                if (startingServiceLife)
                {
                    percent =  1 / startingServiceLife;
                }
                break;

            case AssetDepreciationMethod::StraightLine:
                if (assetBook.ServiceLife)
                {
                    percent = 1 / assetBook.ServiceLife;
                }
                break;

            default:
                //  Enumeration is wrong for calculation type, throw an error.
                throw error(strFmt("@SYS99068", depreciationProfile.Profile));
        }

        return percent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDateOfLastDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the date of the last depreciation for a given value model.
    /// </summary>
    /// <param name="_depreciationDate">
    /// The date of the transaction
    /// </param>
    /// <param name="_periods">
    /// The number of remaining depreciation periods.
    /// </param>
    /// <param name="_isRB_Calc">
    /// A Boolean value that indicates whether the deprecation is of reducing balance type; optional.
    /// </param>
    /// <returns>
    /// The date of the last depreciation transaction in the final year of depreciation
    /// </returns>
    public TransDate getDateOfLastDepreciation(
        TransDate    _depreciationDate,
        AssetDepreciationTime _periods,
        boolean      _isRB_Calc = false)
    {
        #DEFINE.monthsInYear(12)

        TransDate               endDate;
        TransDate               startDate;
        AssetDepreciationTime   lifeTimeRest;

        if (_isRB_Calc)
        {
            //
            //  Reducing Balance depreciations cannot have a last year because they are percentage and
            //  not life time.
            //
            endDate = maxDate();
        }
        else
        {
            // The depreciation date provided is the last day of a given period, however,
            // the remaining periods always represent the number as of the last period.
            // The end of depreciation will be calculated as of the first day of the new
            // period and it will be moved forward based on the number of remaining periods.
            endDate = depreciationInterval.startOfPeriod(_depreciationDate);
            lifeTimeRest = _periods;

            switch (depreciationProfile.DepreciationYear)
            {
                case AssetDepreciationYear::Fiscal:
                    startDate = endDate;

                    endDate = this.getFiscalLastDepreciationDate(endDate, lifeTimeRest);

                    //
                    //  The asset's calendar does not have enough periods to cover the asset's
                    //  service life span. Assume an estimated last depreciation date of
                    //  12/31/2154.
                    //
                    if (endDate < startDate)
                    {
                        endDate = maxDate();
                    }
                    break;

                case AssetDepreciationYear::Calendar:
                    //
                    //  Assets using "Calendar" will always have a last depreciation date (up to 12/13/2154)
                    //  because "Calendar" is virtual.
                    //
                    lifeTimeRest = this.calcAssetRemainingLifeTime(lifeTimeRest);
                    boolean isKnownAccrual = this.checkKnownAssetAccrualForDepreciation();

                    if (!isKnownAccrual)
                    {
                        throw error(strFmt("@SYS99070", depreciationProfile.Profile));
                    }
                    //
                    //  Add the number of periods (months) to the
                    //  last depreciation run date.
                    //
                    endDate = dateMthFwd(endDate, real2int(lifeTimeRest));
                    break;

                default:
                    //  The enumeration is unknown, throw an error;
                    throw error(strFmt("@SYS99083", depreciationProfile.Profile));
            }

            if (endDate > dateNull() && endDate < maxDate())
            {
                endDate = this.adjustLastDepreciationDate(endDate, lifeTimeRest);
            }
        }

        return endDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAssetRemainingLifeTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the asset remaining life time.
    /// </summary>
    /// <param name = "_lifeTimeRest">
    /// Life Time Remaining number.
    /// </param>
    /// <returns>
    /// The asset remaining life time.
    /// </returns>
    protected AssetDepreciationTime calcAssetRemainingLifeTime(AssetDepreciationTime _lifeTimeRest)
    {
        AssetDepreciationTime lifeTimeRest = _lifeTimeRest;

        switch (depreciationProfile.Accrual)
        {
            case AssetAccrual::Monthly:
                //
                //  If periods are monthly then no adjustment to the value
                //  is required.
                //
                break;
            //
            //  If periods are not monthly then adjust the value
            //  of the number of periods left by the result of the
            //  number of months in a year divided by the
            //  number of periods in the accrual selected.
            //
            case AssetAccrual::Quarterly:
            case AssetAccrual::HalfYearly:
            case AssetAccrual::Yearly:
                lifeTimeRest = this.adjustLifeTimeRest(_lifeTimeRest
                    * (#monthsInYear / depreciationInterval.numOfPeriodsPerYear()));
                break;

            default:
                break;
        }

        return lifeTimeRest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkKnownAssetAccrualForDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given asset accrual is a known accrual.
    /// </summary>
    /// <returns>
    /// true if the <c>AssetAccrual</c> enumeration value is of known type; otherwise, false.
    /// </returns>
    protected boolean checkKnownAssetAccrualForDepreciation()
    {
        boolean isKnownAccrual = true;

        switch (depreciationProfile.Accrual)
        {
            case AssetAccrual::Monthly:
            case AssetAccrual::Quarterly:
            case AssetAccrual::HalfYearly:
            case AssetAccrual::Yearly:
            case AssetAccrual::Daily:
                break;
            default:
                isKnownAccrual = false;
        }

        return isKnownAccrual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFiscalLastDepreciationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the date of the last depreciation for a given value model that uses fiscal calendar.
    /// </summary>
    /// <param name = "_depreciationDate">The date of the transaction.</param>
    /// <param name = "_lifeTimeRest">The number of remaining depreciation periods.</param>
    /// <returns>The date of the last depreciation transaction in the final year of depreciation.</returns>
    protected TransDate getFiscalLastDepreciationDate(AssetTransDate _depreciationDate, AssetDepreciationTime _lifeTimeRest)
    {
        TransDate returnDate;

        if (depreciationProfile.Accrual == AssetAccrual::Yearly)
        {
            returnDate = depreciationInterval.startDateYearFwd(_depreciationDate, _lifeTimeRest);
        }
        else
        {
            // Note: startDatePeriodFwd requires the number of periods to be an integer.
            returnDate = depreciationInterval.startDatePeriodFwd(_depreciationDate, real2int(_lifeTimeRest));
        }
        return returnDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfPeriodsInYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total number of depreciation periods used in a given year of the disposal.
    /// </summary>
    /// <param name="_disposalTransDate">
    /// The disposal transaction date.
    /// </param>
    /// <param name="_lastDayOfDepreciation">
    /// The last date of recorded depreciation.
    /// </param>
    /// <param name="_disposalInSameYear">
    /// A boolean value indicating if the disposal is done in the same year as acquisition.
    /// </param>
    /// <returns>
    /// The total number of periods used in a given year.
    /// </returns>
    protected AssetDepreciationTime getNumberOfPeriodsInYear(
        AssetTransDate  _disposalTransDate,
        AssetTransDate  _lastDayOfDepreciation,
        boolean         _disposalInSameYear)
    {
        AssetDepreciationTime   numberOfPeriods;
        TransDate               lastDayOfYear;

        lastDayOfYear = depreciationInterval.findLastDayOfYear(_disposalTransDate);

        if (_lastDayOfDepreciation
            && _lastDayOfDepreciation < lastDayOfYear)
        {
            numberOfPeriods = depreciationInterval.periodOfYear(_lastDayOfDepreciation - 1);
        }
        else
        {
            numberOfPeriods = depreciationInterval.periodOfYear(lastDayOfYear);
        }

        if (_disposalInSameYear)
        {
            numberOfPeriods =  numberOfPeriods - depreciationInterval.periodOfYear(assetBook.DepreciationStartDate) + 1;
            if (numberOfPeriods < 0)
            {
                numberOfPeriods = 0;
            }
        }

        return numberOfPeriods;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the currency code for the fixed asset amounts.
    /// </summary>
    /// <returns>
    /// A <c>CurrencyCode</c> value.
    /// </returns>
    protected CurrencyCode getCurrencyCode()
    {
        CurrencyCode currencyCode;

        if (this.parmIsReportingCurrencyDepreciation())
        {
            currencyCode = Ledger::reportingCurrency();
        }
        else
        {
            currencyCode = Ledger::accountingCurrency();
        }
        
        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    //
    //  This method creates a "New" instance of this class and sets the
    //  class's date properties to their initial values.
    //
    public void new()
    {
        isFirstYear             =   false;
        islastYear              =   false;
        assetPeriodDate         =   dateNull();
        lastDepreciationDate    =   dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsOtherAdjustments</Name>
				<Source><![CDATA[
    public boolean parmIsOtherAdjustments(boolean _isOtherAdjustment = isOtherAdjustment)
    {
        isOtherAdjustment = _isOtherAdjustment;

        return isOtherAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPartialMonthCalculation</Name>
				<Source><![CDATA[
    public boolean parmIsPartialMonthCalculation(boolean _isPartialMonthCalculation = isPartialMonthCalculation)
    {
        isPartialMonthCalculation = _isPartialMonthCalculation;

        return isPartialMonthCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsProratedDaysCalculation</Name>
				<Source><![CDATA[
    public boolean parmIsProratedDaysCalculation(boolean _isProratedDaysCalculation = isProratedDaysCalculation)
    {
        isProratedDaysCalculation = _isProratedDaysCalculation;

        return isProratedDaysCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastDepreciationDate</Name>
				<Source><![CDATA[
    public TransDate parmLastDepreciationDate(TransDate _lastDepreciationDate = lastDepreciationDate)
    {
        lastDepreciationDate = _lastDepreciationDate;
        return lastDepreciationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAssetBook</Name>
				<Source><![CDATA[
    //
    //  This method sets the assetBook property.
    //
    private void setAssetBook(AssetBook _assetBook)
    {
        //
        //  This property holds the assetBook table row data
        //  for the asset's current depreciation transaction.
        //
        assetBook = _assetBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAssetPeriodDate</Name>
				<Source><![CDATA[
    //
    //  This method sets the various date properties required for this class.
    //
    protected void setAssetPeriodDate(TransDate _depreciationDate,
                                      AssetDepreciationTime _periods,
                                      boolean   _isRB_Calc = false)
    {
        //
        //  It is run everytime a calculation occurs because the various date properties
        //  might change depending on the asset's current depreciation calculation date.
        //
        this.checkIsFirstYear(_depreciationDate);
        if (isFirstYear)
        {
            assetPeriodDate = assetBook.DepreciationStartDate;
        }
        else
        {
            this.checkIsLastYear(_depreciationDate, _periods, _isRB_Calc);
            if (islastYear)
            {
                assetPeriodDate = lastDepreciationDate;
            }
            else
            {
                assetPeriodDate = _depreciationDate;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDepreciationInterval</Name>
				<Source><![CDATA[
    //
    //  This method sets the depreciationInterval property.
    //
    private void setDepreciationInterval(AssetTableInterval _depreciationInterval)
    {
        //
        //  This property holds the class used to control date handling for the
        //  asset's depreciation transaction.
        //
        depreciationInterval = _depreciationInterval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDepreciationProfile</Name>
				<Source><![CDATA[
    //
    //  This method sets the depreciationProfile property.
    //
    private void setDepreciationProfile(AssetDepreciationProfile _depreciationProfile)
    {
        //
        //  This property holds the assetDepreciationProfile table row
        //  for the asset's current depreciation transaction.
        //
        depreciationProfile =  _depreciationProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLastDepreciationDate</Name>
				<Source><![CDATA[
    //
    //  This method calculates the asset's estimated last depreciation date
    //  based on the asset's remaining service lifefrom the first depreciation
    //  date that is not in the assetâ€™s first year of depreciation.
    //
    private void setLastDepreciationDate(TransDate    _depreciationDate,
                                           AssetDepreciationTime _periods,
                                           boolean      _isRB_Calc = false)
    {
        date                    endDate;

        // Rounding the period remaining to 3 decimal places as some
        // convention runs have the values 3 decimal number.
        // Mid-Quarter ex. 1 of 8 -> 0.125
        endDate = this.getDateOfLastDepreciation(
            _depreciationDate,
            decRound(_periods, 3),
            _isRB_Calc);

        if (endDate == dateNull())
        {
            //  A proper endDate value cannot be calculated, throw an error.
            throw error(strFmt("@SYS99072", funcName()));
        }
        else
        {
            lastDepreciationDate = endDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNumberOfPeriodsInInterval</Name>
				<Source><![CDATA[
    //
    //  This method sets the correct number of periods to take within the context of
    //  the total number of periods for the asset's current transaction.
    //
    protected AssetDepreciationTime setNumberOfPeriodsInInterval(TransDate _depreciationDate)
    {
        AssetDepreciationTime retValue;

        switch (depreciationProfile.DepreciationYear)
        {
            //  depreciation year is "Fiscal"
            case AssetDepreciationYear::Fiscal:
                retValue = 1;
                break;

            //  depreciation year is "Calendar"
            case AssetDepreciationYear::Calendar:
                retValue = this.calcNumberOfPeriodsInInterval(_depreciationDate);
                boolean isKnownAccrual = this.checkKnownAssetAccrualForDepreciation();

                if (!isKnownAccrual)
                {
                    throw error(strFmt("@SYS99070", depreciationProfile.Profile));
                }
                break;

            default:
                //  The enumeration is unknown, throw an error;
                throw error(strFmt("@SYS99083", depreciationProfile.Profile));
        }

        if (retValue > 0)
        {
            return retValue;
        }
        else
        {
            //
            //  A proper asset depreciation time value cannot be calculated, throw an error.
            //  This value must be greater than 1.
            //
            throw error(strFmt("@SYS99073", funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNumberOfPeriodsInInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of periods in a interval.
    /// </summary>
    /// <param name = "_depreciationDate">
    /// The depreciation start date.
    /// </param>
    /// <returns>
    /// The calculated periods in an interval.
    /// </returns>
    protected AssetDepreciationTime calcNumberOfPeriodsInInterval(TransDate _depreciationDate)
    {
        AssetDepreciationTime retValue;

        switch (depreciationProfile.Accrual)
        {
            case AssetAccrual::Yearly:
                retValue = depreciationInterval.numOfPeriodsPerYear();
                break;

            case AssetAccrual::HalfYearly:
            case AssetAccrual::Quarterly:
                if (isFirstYear && mthOfYr(assetPeriodDate) >= mthOfYr(depreciationInterval.startOfPeriod(_depreciationDate)))
                {
                    //
                    //  If the assets starting depreciation date does not encompass the entire
                    //  span of the asset's current transaction's transactional period.
                    //  ex. The starting date is in the second month of a quarterly period;
                    //      therefore: the number of intervals to take for this transaction
                    //      would be 2.
                    //
                    retValue = (mthOfYr(depreciationInterval.endPeriod(assetPeriodDate)) - mthOfYr(assetPeriodDate)) + 1;
                }
                else
                {
                    retValue = (mthOfYr(depreciationInterval.endPeriod(_depreciationDate)) -
                        mthOfYr(depreciationInterval.startOfPeriod(_depreciationDate))) + 1;
                }
                break;

            case AssetAccrual::Monthly:
                retValue = 1;
                break;

            default:
                break;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNumberOfPeriodsLeftInYear</Name>
				<Source><![CDATA[
    //
    //  This method sets the correct number of total periods to take
    //  for the asset's current transaction.
    //
    protected AssetDepreciationTime setNumberOfPeriodsLeftInYear(TransDate _depreciationDate)
    {
        AssetDepreciationTime   retValue;

        switch (depreciationProfile.DepreciationYear)
        {
            //  depreciation year is "Fiscal"
            case AssetDepreciationYear::Fiscal:
                if (depreciationProfile.Accrual == AssetAccrual::Yearly)
                {
                    retValue = 1;
                }
                else
                {
                    if (islastYear)
                    {
                        //
                        //  Number of periods between the depreciation date and the estimated
                        //  last depreciation date.
                        //
                        retValue = depreciationInterval.numOfPeriods(_depreciationDate,
                                            depreciationInterval.startingPeriodDate(assetPeriodDate));
                    }
                    else
                    {
                        //
                        //  Number of periods between the depreciation date and the end of the
                        //  fiscal year for the depreciation date.
                        //
                        retValue = depreciationInterval.numOfPeriodsLeftInYear(_depreciationDate);
                    }
                }
                break;

            //  depreciation year is "Calendar"
            case AssetDepreciationYear::Calendar:
                retValue = this.calcNumberOfPeriods(_depreciationDate);
                boolean isKnownAccrual = this.checkKnownAssetAccrualForDepreciation();

                if (!isKnownAccrual)
                {
                    throw error(strFmt("@SYS99070", depreciationProfile.Profile));
                }
                break;

            default:
                //  The enumeration is unknown, throw an error;
                throw error(strFmt("@SYS99083", depreciationProfile.Profile));
        }

        if (retValue > 0)
        {
            return retValue;
        }
        else
        {
            //
            //  A proper asset depreciation time value cannot be calculated, throw an error;
            //  This value must be greater than 1.
            //
            throw error(strFmt("@SYS99073", funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNumberOfPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculated number of asset accrual periods.
    /// </summary>
    /// <param name = "_depreciationDate">
    /// The depreciation start date.
    /// </param>
    /// <returns>
    /// The calculated asset accrual periods.
    /// </returns>
    protected AssetDepreciationTime calcNumberOfPeriods(TransDate _depreciationDate)
    {
        AssetDepreciationTime retValue;

        switch (depreciationProfile.Accrual)
        {
            case AssetAccrual::Yearly:
                retValue = 1;
                break;

            case AssetAccrual::HalfYearly:
            case AssetAccrual::Quarterly:
            case AssetAccrual::Monthly:
                if (islastYear)
                {
                    //
                    //  Number of periods (months) between the depreciation date and the estimated
                    //  last depreciation date.
                    //
                    retValue = (mthOfYr(assetPeriodDate) -
                                        mthOfYr(depreciationInterval.startOfPeriod(_depreciationDate))) + 1;
                }
                else if (isFirstYear && mthOfYr(assetPeriodDate) >= mthOfYr(depreciationInterval.startOfPeriod(_depreciationDate)))
                {
                    //
                    //  If the assets starting depreciation date does not encompass the entire
                    //  span of the asset's current transaction's transactional period.
                    //  ex. The starting date is in the second month of the 3rd quarter;
                    //      therefore: the number of periods (months) left in the year
                    //      for this transaction would be 5.
                    //
                    retValue = (mthOfYr(DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), assetPeriodDate)) -
                                       mthOfYr(assetPeriodDate)) + 1;
                }
                else
                {
                    //
                    //  Number of periods (months) between the depreciation date and the end of the
                    //  calendar year for the depreciation date.
                    //
                    retValue = (mthOfYr(DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), _depreciationDate)) -
                                        mthOfYr(depreciationInterval.startOfPeriod(_depreciationDate))) + 1;
                }
                break;

            default:
                break;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDisposalFirstLastYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates classes variables indicating if the current depreciation is done in the first or last year of depreciation.
    /// </summary>
    /// <param name="_disposalTransDate">
    /// Disposal transaction date.
    /// </param>
    protected void updateDisposalFirstLastYear(TransDate _disposalTransDate)
    {
        boolean isLastYearDateProjectionNeeded;

        // If reducing balance profile does have Full Depreciation option selected,
        // the last projected date of depreciation needs to be determined.
        isLastYearDateProjectionNeeded = !depreciationProfile.AssetEndDependOnServiceLife
            && AssetDepreciationProfile::isReducingBalanceDepreciationMethod(depreciationProfile.Method);

        // When reducing balance method is used with the straight line method, the projected date of the depreciation will
        // be based on straight line method and custom reducing balance logic is not needed.
        if (isLastYearDateProjectionNeeded
            && assetBook.depreciationAltProfile())
        {
            isLastYearDateProjectionNeeded = false;
        }

        this.checkIsFirstYear(assetBook.LastDepreciationDate != dateNull()
                            ? assetBook.LastDepreciationDate + 1 : assetBook.DepreciationStartDate);
        this.checkIsLastYear(assetBook.LastDepreciationDate != dateNull()
                            ? assetBook.LastDepreciationDate + 1 : assetBook.DepreciationStartDate,
                            assetBook.LifeTimeRest,
                            isLastYearDateProjectionNeeded);

        this.checkIsLastYear(_disposalTransDate, 0, isLastYearDateProjectionNeeded);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDepreciationMethodValidForDepreciationConventions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if depreciation conventions are supported for the specified depreciation method.
    /// </summary>
    /// <param name = "_assetDepreciationMethod">
    /// A <c>AssetDepreciationMethod</c> enumeration value.
    /// </param>
    /// <returns>
    /// true if depreciation conventions are supported for the specified depreciation method; otherwise, false.
    /// </returns>
    protected static boolean isDepreciationMethodValidForDepreciationConventions(AssetDepreciationMethod _assetDepreciationMethod)
    {
        boolean returnValue;

        if (_assetDepreciationMethod == AssetDepreciationMethod::ReducingBalance
            || _assetDepreciationMethod == AssetDepreciationMethod::ReducingBalance125
            || _assetDepreciationMethod == AssetDepreciationMethod::ReducingBalance150
            || _assetDepreciationMethod == AssetDepreciationMethod::ReducingBalance175
            || _assetDepreciationMethod == AssetDepreciationMethod::ReducingBalance200
            || _assetDepreciationMethod == AssetDepreciationMethod::StraightLine
            || _assetDepreciationMethod == AssetDepreciationMethod::StraightLineLifeRemaining
            // <GJP>
            || _assetDepreciationMethod == AssetDepreciationMethod::OldStraightLine_JP
            || _assetDepreciationMethod == AssetDepreciationMethod::OldDecliningBalance_JP
            || _assetDepreciationMethod == AssetDepreciationMethod::NewStraightLine_JP
            || _assetDepreciationMethod == AssetDepreciationMethod::NewDecliningBalance200_JP
            || _assetDepreciationMethod == AssetDepreciationMethod::NewDecliningBalance250_JP
            || _assetDepreciationMethod == AssetDepreciationMethod::EquallyDivided_JP
            || _assetDepreciationMethod == AssetDepreciationMethod::ElectronicDepreciation_JP
            // </GJP>
            // <GCN>
            || _assetDepreciationMethod == AssetDepreciationMethod::DoubleReduceBalance_CN
            || _assetDepreciationMethod == AssetDepreciationMethod::SumYearDigits_CN
            // </GCN>
            // <GIN>
            || _assetDepreciationMethod == AssetDepreciationMethod::StraightLinePercentage_IN
            // </GIN>
        )
        {
            returnValue = true;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepreciationStartDate</Name>
				<Source><![CDATA[
    // This method calculates the depreciation start date for an asset
    // based on its selected Depreciation Convention
    static public AssetDepreciationStartDate calcDepreciationStartDate(AssetBook _assetBook, AssetUsedFromDate _usedFromDate)
    {
        AssetDepreciationStartDate startDate;

        // <GJP>
        #isoCountryRegionCodes
        // </GJP>

        //
        //  Depreciation conventions only support Reducing Balance and Straight Line
        //  depreciation method types.
        //
        if (AssetTableDepConv::isDepreciationMethodValidForDepreciationConventions(_assetBook.depreciationProfile().Method))
        {
            // <GIN>
            if ((_assetBook.depreciationProfile().Method == AssetDepreciationMethod::StraightLinePercentage_IN) && (!AssetParameters::find().DepreciationCompaniesAct_IN))
            {
                return _usedFromDate;
            }
            // </GIN>

            AssetBookTable assetBookTable = AssetBookTable::find(_assetBook.BookId);

            AssetTableDepConv deprConv = SysExtensionAppClassFactory::getClassFromSysAttribute(
                classStr(AssetTableDepConv),
                new AssetTableDepConvAttribute(_assetBook.DepreciationConvention));

            if (deprConv)
            {
                deprConv.setAssetBook(_assetBook);
                deprConv.setDepreciationProfile(_assetBook.depreciationProfile());

                // <GJP>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]))
                {
                    deprConv.setDepreciationInterval(AssetTableInterval::construct(
                        _assetBook.depreciationProfile(),
                        assetBookTable.getFiscalCalendar_JP(_usedFromDate)));
                }
                else
                {
                // </GJP>
                    deprConv.setDepreciationInterval(AssetTableInterval::construct(
                        _assetBook.depreciationProfile(), assetBookTable.getFiscalCalendar()));
                // <GJP>
                }
                // </GJP>

                startDate = deprConv.calcStartDate(_usedFromDate);
                return startDate;
            }
            else
            {
                // The depreciation convention is unknown, throw an error
                throw error(strFmt("@FixedAssets:FA_MessageError_BookHasUnknownDepreciationConvention", _assetBook.AssetId, _assetBook.BookId));
            }
        }
        else
        {
            // The depreciation method is not valid for the depreciation convention, throw an error.
            throw error(strFmt("@FixedAssets:FA_MessageError_DepreciationMethodIsNotValidForDepreciationConvention", _assetBook.AssetId, _assetBook.BookId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHalfYearDepreciationFirstPostDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method determines the starting date of depreciation in which the amount is posted.
    /// </summary>
    /// <param name="assetBook">
    /// An active <c>AssetBook</c> table buffer
    /// </param>
    /// <param name="assetTableInterval">
    /// An instance of <c>AssetTableInterval</c> class
    /// </param>
    /// <returns>
    /// The date from which the depreciation starts.
    /// </returns>
    /// <remarks>
    /// The method is used by Half Year (Start of Year) and Half Year (Next Year) conventions.
    /// </remarks>
    public static TransDate getHalfYearDepreciationFirstPostDate(
        AssetBook assetBook,
        AssetTableInterval assetTableInterval)
    {
        TransDate depreciationStartPostDate;

        depreciationStartPostDate = assetBook.DepreciationStartDate;
        if (assetBook.AcquisitionDate == assetBook.UsedFromDate
            || (assetBook.AcquisitionDate > assetBook.UsedFromDate
            && assetTableInterval.findFirstDayOfPeriod(assetBook.AcquisitionDate)
            >= assetTableInterval.findFirstDayOfPeriod(assetBook.UsedFromDate)))
        {
            depreciationStartPostDate = assetTableInterval.findFirstDayOfPeriod(assetBook.AcquisitionDate);
        }

        return depreciationStartPostDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCalcAssetAmount</Name>
				<Source><![CDATA[
    // This method constructs the correct AssetTableDepConvention class based off
    // the assetBook.depreciationConvention field value.
    public static AssetTableDepConv newCalcAssetAmount(AssetBook                _assetBook,
                                                       AssetTableInterval       _depreciationInterval,
                                                       AssetDepreciationProfile _depreciationProfile)
    {
        AssetTableDepConv deprConv = null;

        deprConv = SysExtensionAppClassFactory::getClassFromSysAttribute(
            classStr(AssetTableDepConv),
            new AssetTableDepConvAttribute(_assetBook.DepreciationConvention));
        
        if (deprConv && _assetBook.DepreciationConvention == AssetDepreciationConvention::None)
        {
            deprConv.parmIsProratedDaysCalculation(AssetParameters::find().IsProratedDepreciation);
        }

        if (deprConv)
        {
            deprConv.setAssetBook(_assetBook);
            deprConv.setDepreciationInterval(_depreciationInterval);
            deprConv.setDepreciationProfile(_depreciationProfile);

            return deprConv;
        }
        else
        {
            // The enumeration is unknown, throw an error
            throw error(strFmt("@FixedAssets:FA_MessageError_BookHasUnknownDepreciationConvention", _assetBook.AssetId, _assetBook.BookId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsReportingCurrencyDepreciation</Name>
				<Source><![CDATA[
    internal boolean parmIsReportingCurrencyDepreciation(boolean _isReportingCurrencyDepreciation = isReportingCurrencyDepreciation)
    {
        isReportingCurrencyDepreciation = _isReportingCurrencyDepreciation;

        return isReportingCurrencyDepreciation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPeriodAmount</Name>
				<Source><![CDATA[
    internal protected Amount getPeriodAmount(
        Amount _netAmountToDepreciate,
        AssetDepreciationTime _numberOfPeriodsInInterval,
        AssetDepreciationTime _numberOfPeriodsLeftInYear)
    {
        return assetBook.roundDepreciationAmount(
            _netAmountToDepreciate * (_numberOfPeriodsInInterval / _numberOfPeriodsLeftInYear),
            this.parmIsReportingCurrencyDepreciation());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>