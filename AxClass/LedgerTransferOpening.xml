<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerTransferOpening</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerTransferOpening</c> class creates closing and opening transactions for general ledger year end processing.
/// </summary>
/// <remarks>
/// Closing transactions are created to bring the balance of nominal accounts to 0.  Opening transactions are created for real accounts to transfer
/// their balance to the opening period of the next fiscal year.
/// </remarks>
public class LedgerTransferOpening extends RunBaseBatch implements BatchRetryable
{
    private static const int HashGenerationBundleSize = 5000;
    private static const int BalanceCalculationBundleSize = 1000;
    private static const str AmountPrecisionLogMessage = 'Accounting currency amount or reporting currency amount for ledger dimension %1 has lost precision.';
    private static const str SumInTotalLogMessage = 'YearEndCloseAccountingCurrencyOutOfBalance.';
    private static const str ReportingCurrencySumInTotalLogMessage = 'YearEndCloseReportingCurrencyOutOfBalance.';

    private readonly boolean isAdvancedAwarenessOptsParmEnabled = LedgerTransSettlementAdvancedParameters::isAwarenessParameterEnabled();
    private readonly boolean isFiscalYearPermanentlyClosedFlightEnabled = LedgerTransferOpeningYearPermanentlyClosedFlight::instance().isEnabled();

    #DimensionDefaultingFieldSetElements
    #ISOCountryRegionCodes
    #OCCRetryCount

    TransDate                   periodStart;
    TransDate                   periodEnd;
    TransDate                   periodNext;
    Counter                     progressCounter;
    Voucher                     voucher;
    UseTransferYearEndAccount_ES useTransferYearEndAccount_ES;

    OpeningMethod               methodOperations;
    OpeningMethod               methodStatus;
    MainAccountNum              transferResult;
    DimensionDefault            profitLossDefaultDimension;
    NoYes                       runReport;
    NoYes                       transferDimensions;
    NoYes                       runPreview;
    boolean                     isPublicSectorYearEndProcessingEnabled;
    boolean                     processClosingForOpening;
    boolean                     processCancelled;
    int                         processSession;
    int                         mainAccountLevelValueDataSourceId;
    int                         mainAccountDimensionAttributeDataSourceId;
    boolean                     delayDimensionSetRebuild = false;

    LedgerTransferOpeningProcessState processState;
    RecId                       startRecId;
    RecId                       endRecId;
    LedgerTransferOpeningType   ledgerTransferOpeningType;
    LedgerParameters            ledgerParameters;

    DialogField                 dialogCalendarId;
    DialogField                 dialogFiscalYearName;
    DialogField                 dialogPeriodEndFrom;
    DialogField                 dialogPeriodEndTo;
    DialogField                 dialogPeriodEndToDate;
    DialogField                 dialogPeriodEndFromDate;
    DialogField                 dialogPeriodStartFrom;
    DialogField                 dialogPeriodStartFromDate;
    DialogField                 dialogSelectFund;
    DialogField                 dialogFromFund;
    DialogField                 dialogToFund;
    DialogField                 dialogRunPreview;

    NoYes                       selectFund;
    FiscalYearName              closingFiscalYearName;
    PeriodName                  balanceFromPeriod;
    PeriodName                  balanceToPeriod;
    TransDate                   closeDateFromPeriod;
    FundNumber                  fromFund;
    FundNumber                  toFund;
    PeriodName                  balanceOpenFromPeriod;
    TransDate                   openDateFromPeriod;
    FiscalCalendarYearRecId     fiscalCalendarYearNameRecId;

    FiscalCalendarPeriod        openingBalanceFiscalCalendarPeriod;
    FiscalCalendarPeriod        closingPostToFiscalCalendarPeriod;
    FiscalCalendarPeriod        closingBalanceFiscalCalendarPeriod;
    QueryBuildDataSource        qbdsMainAccountLevelValue;
    DimensionBalancingValidator dimensionBalancingValidator;

    // Variables used by the queries and processing
    RecId                       mainAccountDimAttrId;
    DimensionAttribute          mainAccountDimAttr;
    RecId                       fallbackAccountStructureId;
    Map                         dimAttrTableBuffers;
    Map                         dimAttrIdToSingleAttrHierarchyId;
    List                        dimAttrRecIds;
    DimensionEnumeration        allDimAttributes;
    DimensionEnumeration        profitLossCloseAllDimensionAttributeSet;
    DimensionAttributeValueSetStorage profitLossDimAttrValueSetStorage;
    DimensionEnumeration        balanceSheetDimensionAttributeSet;
    Map                         dimAttrSetAccountEntryHashSpecifiers;

    // General Tab
    DialogField                 dialogPeriodEnd;
    // <GEERU>
    DialogField                 dialogMethodOperations;
    // </GEERU>
    DialogField                 dialogMethodStatus;
    DialogField                 dialogTransferResult;
    DialogField                 dialogRunReport;
    DialogField                 dialogVoucher;
    DialogField                 dialogUseTransferYearEndAccount_ES;

    // Dimensions Tab
    DialogField                 dialogTransferDimensions;
    DialogField                 dialogProfitLossDimensionEntry;      // DimensionEntryControl dialog field wrapper
    DimensionEntryControl       profitLossDimensionEntryControl;         // Instantiated DEC control
    DimensionDefault            profitLossDefaultDimensions;
    DimensionEnumeration        profitLossCloseDimensionEnumeration;
    DimensionEnumeration        profitLossDisplayedDimensions;
    
    boolean                     createdTransactions;

    boolean                     silent;

    UTCTimestamp                processTimestamp;

    LedgerTransferOpeningSumTmp accountSumPrimo;
    LedgerTransferOpeningSumTmp accountSumUltimo;
    LedgerTransferOpeningSumTmp accountSumUltimoOperations;

    AcknowledgementDate         acknowledgementDate;
    DialogField                 dialogAcknowledgementDate;

    Dialog                      dialog;

    DialogField                 dialogPeriodName;

    FiscalCalendarPeriodRecId   closingFiscalCalendarPeriodRecId;
    FiscalCalendarYearRecId     closingFiscalCalendarYearRecId;
    FiscalCalendarPeriodRecId   openingFiscalCalendarPeriodRecId;
    FiscalCalendarYearRecId     openingFiscalCalendarYearRecId;
    FiscalCalendarRecId         calendarRecId;
    PeriodName                  periodName;

    // <GCN>
    DialogField                 dialogVoucherTypeId_CN;
    DialogField                 dialogVoucher_CN;

    LedgerVoucherTypeId_CN      voucherTypeId_CN;
    LedgerVoucherTypeRefRecId_CN ledgerVoucherTypeRecId_CN;
    Voucher_CN                  voucher_CN;
    // </GCN>

    private Counter             countTransactionsRead;
    private Counter             countOpeningBalancesCreated;

    private guid detailsExecutionId;

    private static const Integer currentVersion = 12;

    #LOCALMACRO.CurrentList
        PeriodEnd,
        MethodOperations,
        MethodStatus,
        TransferResult,
        RunReport,
        periodNext,
        voucher,
        acknowledgementDate,
        transferDimensions,
        profitLossDefaultDimensions,
        profitLossCloseDimensionEnumeration,
        profitLossDisplayedDimensions,
        closingFiscalCalendarPeriodRecId,
        closingFiscalCalendarYearRecId,
        openingFiscalCalendarPeriodRecId,
        openingFiscalCalendarYearRecId,
        // <GCN>
        voucher_CN,
        voucherTypeId_CN,
        ledgerVoucherTypeRecId_CN,
        // </GCN>
        openingFiscalCalendarPeriodRecId,
        processState,
        ledgerTransferOpeningType,
        startRecId,
        endRecId,
        silent,
        processSession,
        processTimestamp,
        useTransferYearEndAccount_ES,
        createdTransactions,
        delayDimensionSetRebuild,
        detailsExecutionId
   #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addAccountSumPrimo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the temporary work table by using an opening transaction.
    /// </summary>
    /// <param name="_generalJournalEntry">
    /// The <c>GeneralJournalEntry</c> record related to the opening transaction.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record related to the opening transaction.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The compound account number to use for posting the balancing transaction.
    /// </param>
    //
    // Search for an existing opening transaction (ClosingType = AccountStatus & Posting = None) in the work table.
    // If one is found, add the summary transaction balance to the record.  If one is not found, add the new
    // transaction to the work table as an opening transaction.
    //
    protected void addAccountSumPrimo(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerDimensionAccount _ledgerDimension)
    {
        LedgerDimensionAccount  currentLedgerDimension;
        LedgerDimensionAccount  offsetLedgerDimension;
        TransactionTxt          transactionTxt = TransactionTxt::construct();

        if (isPublicSectorYearEndProcessingEnabled)
        {
            offsetLedgerDimension = _ledgerDimension;
            transactionTxt.setType(LedgerTransTxt::LedgerOpening);

            if (this.shouldSkipOffsetAccountForRealAccounts_PSN(_generalJournalAccountEntry.LedgerDimension))
            {
                offsetLedgerDimension = 0;
            }
        }
        else
        {
            // In this functions's parameters, the Public Sector version expects an offsetLedgerDimension and SYS version
            // expects a currentLedgerDimension. To keep the logical names clear, the SYS paramter was commented
            // and a generic name _ledgerDimension was selected so that it could be used by both PS and SYS. The variables
            // currentLedgerDimension and offsetLedgerDimension are then populated based on PS or SYS functionality as required.
            currentLedgerDimension = _ledgerDimension;
        }

        try
        {
            ttsBegin;

            if (isPublicSectorYearEndProcessingEnabled
                && (_generalJournalAccountEntry.AccountingCurrencyAmount != 0
                    || _generalJournalAccountEntry.TransactionCurrencyAmount != 0
                    || _generalJournalAccountEntry.Quantity != 0 ) )
            {
                select forupdate firstonly accountSumPrimo
                    where accountSumPrimo.SessionId         == processSession &&
                          accountSumPrimo.UTCTimestamp      == processTimestamp &&
                          accountSumPrimo.LedgerDimension   == _generalJournalAccountEntry.LedgerDimension &&
                          accountSumPrimo.CurrencyCode      == _generalJournalAccountEntry.TransactionCurrencyCode &&
                          accountSumPrimo.OperationsTax     == _generalJournalEntry.PostingLayer &&
                          accountSumPrimo.ClosingType       == LedgerAccountType::AccountStatus &&
                          accountSumPrimo.Posting           == LedgerPostingType::None;

                accountSumPrimo = this.updateLedgerTransferOpeningSumAddAmounts(accountSumPrimo, _generalJournalAccountEntry);

                if (accountSumPrimo)
                {
                    accountSumPrimo.update();
                }
                else
                {
                    accountSumPrimo.SessionId               = processSession;
                    accountSumPrimo.UTCTimestamp            = processTimestamp;
                    accountSumPrimo.CurrencyCode            = _generalJournalAccountEntry.TransactionCurrencyCode;
                    accountSumPrimo.OperationsTax           = _generalJournalEntry.PostingLayer;
                    accountSumPrimo.ClosingType             = LedgerAccountType::AccountStatus;
                    accountSumPrimo.Posting                 = LedgerPostingType::None;
                    accountSumPrimo.TransDate               = periodNext;
                    accountSumPrimo.LedgerDimension         = _generalJournalAccountEntry.LedgerDimension;
                    accountSumPrimo.Voucher                 = voucher;

                    transactionTxt.setDate(periodNext);
                    transactionTxt.setVoucher(voucher);
                    transactionTxt.setFormLetter(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_generalJournalAccountEntry.LedgerDimension));
                    transactionTxt.setLanguage(currentUserLanguage());

                    accountSumPrimo.TransTxt                = transactionTxt.txt();
                    accountSumPrimo.OffsetLedgerDimension   = offsetLedgerDimension;
                    accountSumPrimo.insert();
                }
            }
            else if (!isPublicSectorYearEndProcessingEnabled)
            {
                select forupdate firstonly accountSumPrimo
                   where accountSumPrimo.SessionId        == processSession &&
                        accountSumPrimo.UTCTimestamp      == processTimestamp &&
                        accountSumPrimo.LedgerDimension   == currentLedgerDimension &&
                        accountSumPrimo.CurrencyCode      == _generalJournalAccountEntry.TransactionCurrencyCode &&
                        accountSumPrimo.OperationsTax     == _generalJournalEntry.PostingLayer &&
                        accountSumPrimo.ClosingType       == LedgerAccountType::AccountStatus &&
                        accountSumPrimo.Posting           == LedgerPostingType::None;

                accountSumPrimo = this.updateLedgerTransferOpeningSumAddAmounts(accountSumPrimo, _generalJournalAccountEntry);

                if (accountSumPrimo)
                {
                    accountSumPrimo.update();
                }
                else
                {
                    accountSumPrimo.SessionId           = processSession;
                    accountSumPrimo.UTCTimestamp        = processTimestamp;
                    accountSumPrimo.LedgerDimension     = currentLedgerDimension;
                    accountSumPrimo.CurrencyCode        = _generalJournalAccountEntry.TransactionCurrencyCode;
                    accountSumPrimo.OperationsTax       = _generalJournalEntry.PostingLayer;
                    accountSumPrimo.ClosingType         = LedgerAccountType::AccountStatus;
                    accountSumPrimo.Posting             = LedgerPostingType::None;

                    accountSumPrimo.insert();
                }
            }

            ttsCommit;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAccountSumUltimo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the temporary work table by using a closing transaction.
    /// </summary>
    /// <param name="_generalJournalEntry">
    /// The <c>GeneralJournalEntry</c> record related to the closing transaction.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record related to the closing transaction.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The compound account number to use for posting the balancing transaction.
    /// </param>
    //
    // For closing transactions, profit & loss transactions (profitLossAccount) track 3 records in the work table.
    // Balance sheet transactions (statusAccount) track 1 record for closing.  Search for a matching transaction
    // for each type and if it is found, add the summary transaction balance to the record.  If one is not found,
    // add the new transaction to the work table as its appropriate closing transaction.
    //
    protected void addAccountSumUltimo(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerDimensionAccount _ledgerDimension)
    {
        MainAccount mainAccount;
        LedgerTransferOpeningSumTmp tmpAccountSum;
        TransactionTxt          transactionTxt;
        LedgerDimensionAccount  currentLedgerDimension;
        LedgerDimensionAccount  offsetLedgerDimension;

        try
        {
            ttsBegin;

            if (isPublicSectorYearEndProcessingEnabled)
            {
                offsetLedgerDimension = _ledgerDimension;
                transactionTxt = TransactionTxt::construct();

                transactionTxt.setType(LedgerTransTxt::LedgerClosing);

                select forupdate firstonly accountSumUltimo
                    where accountSumUltimo.SessionId        == processSession
                        && accountSumUltimo.UTCTimestamp    == processTimestamp
                        && accountSumUltimo.LedgerDimension == _generalJournalAccountEntry.LedgerDimension
                        && accountSumUltimo.CurrencyCode    == _generalJournalAccountEntry.TransactionCurrencyCode
                        && accountSumUltimo.OperationsTax   == _generalJournalEntry.PostingLayer
                        && accountSumUltimo.ClosingType     == LedgerAccountType::AccountStatus
                        && accountSumUltimo.Posting         == LedgerPostingType::Closing;

                accountSumUltimo = this.updateLedgerTransferOpeningsumSubtractAmounts(accountSumUltimo, _generalJournalAccountEntry);

                if (accountSumUltimo)
                {
                    accountSumUltimo.update();
                }
                else
                {
                    accountSumUltimo.SessionId = processSession;
                    accountSumUltimo.UTCTimestamp = processTimestamp;
                    accountSumUltimo.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;
                    accountSumUltimo.OperationsTax = _generalJournalEntry.PostingLayer;
                    accountSumUltimo.CurrencyCode = _generalJournalAccountEntry.TransactionCurrencyCode;
                    accountSumUltimo.ClosingType = LedgerAccountType::AccountStatus;
                    accountSumUltimo.Posting = LedgerPostingType::Closing;
                    accountSumUltimo.OffsetLedgerDimension = offsetLedgerDimension;
                    accountSumUltimo.Posting = LedgerPostingType::Closing;
                    accountSumUltimo.Voucher = voucher;

                    transactionTxt.setDate(periodEnd);
                    transactionTxt.setVoucher(voucher);
                    transactionTxt.setFormLetter(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_generalJournalAccountEntry.LedgerDimension));
                    transactionTxt.setLanguage(currentUserLanguage());

                    accountSumUltimo.TransTxt = transactionTxt.txt();
                    accountSumUltimo.TransDate = periodEnd;
                    accountSumUltimo.insert();
                }
            }
            else
            {
                // In this functions's parameters, the Public Sector version expects an offsetLedgerDimension and SYS version
                // expects a currentLedgerDimension. To keep the logical names clear, the SYS paramter was commented
                // and a generic name _ledgerDimension was selected so that it could be used by both PS and SYS. The variables
                // currentLedgerDimension and offsetLedgerDimension are then populated based on PS or SYS functionality as required.
                currentLedgerDimension = _ledgerDimension;
                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_generalJournalAccountEntry.LedgerDimension);

                if ((mainAccount.isProfitAndLossAccount() && methodOperations == OpeningMethod::Reset) ||
                    (mainAccount.isBalanceSheetAccount()&& methodStatus == OpeningMethod::Reset))
                {
                    // Look for a zeroing transaction for the profit and loss (ClosingType = AccountOperations & Posting = Closing).
                    select forupdate firstonly accountSumUltimoOperations
                        where accountSumUltimoOperations.SessionId        == processSession &&
                                accountSumUltimoOperations.UTCTimestamp   == processTimestamp &&
                                accountSumUltimoOperations.LedgerDimension == _generalJournalAccountEntry.LedgerDimension &&
                                accountSumUltimoOperations.CurrencyCode   == _generalJournalAccountEntry.TransactionCurrencyCode &&
                                accountSumUltimoOperations.OperationsTax  == _generalJournalEntry.PostingLayer &&
                                accountSumUltimoOperations.ClosingType    == LedgerAccountType::AccountOperations &&
                                accountSumUltimoOperations.Posting == LedgerPostingType::Closing;

                    accountSumUltimoOperations = this.updateLedgerTransferOpeningsumSubtractAmounts(accountSumUltimoOperations, _generalJournalAccountEntry);

                    if (accountSumUltimoOperations)
                    {
                        accountSumUltimoOperations.update();
                    }
                    else
                    {
                        accountSumUltimoOperations.SessionId       = processSession;
                        accountSumUltimoOperations.UTCTimestamp    = processTimestamp;
                        accountSumUltimoOperations.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;
                        accountSumUltimoOperations.OperationsTax   = _generalJournalEntry.PostingLayer;
                        accountSumUltimoOperations.CurrencyCode    = _generalJournalAccountEntry.TransactionCurrencyCode;
                        accountSumUltimoOperations.ClosingType     = LedgerAccountType::AccountOperations;
                        accountSumUltimoOperations.Posting         = LedgerPostingType::Closing;

                        accountSumUltimoOperations.insert();
                    }

                    if (!LedgerParameters::find().DeleteOpening)
                    {
                        this.adjustUltimoTrans(accountSumUltimoOperations);
                    }

                    tmpAccountSum.data(accountSumUltimoOperations.data());

                    accountSumUltimoOperations.clear();

                    // Look for a transferring transaction for the profit and loss transaction for the designated account
                    // (ClosingType = AccountOperations & Posting = TransferOpeningClosing).
                    select forupdate firstonly accountSumUltimoOperations
                        where accountSumUltimoOperations.SessionId        == processSession &&
                                accountSumUltimoOperations.UTCTimestamp   == processTimestamp &&
                                accountSumUltimoOperations.LedgerDimension == currentLedgerDimension &&
                                accountSumUltimoOperations.CurrencyCode   == tmpAccountSum.CurrencyCode &&
                                accountSumUltimoOperations.OperationsTax  == tmpAccountSum.OperationsTax &&
                                accountSumUltimoOperations.euroTriangulation == tmpAccountSum.euroTriangulation &&
                                accountSumUltimoOperations.ClosingType    == LedgerAccountType::AccountOperations &&
                                accountSumUltimoOperations.Posting        == LedgerPostingType::TransferOpeningClosing;

                    accountSumUltimoOperations.subtract(tmpAccountSum);

                    if (accountSumUltimoOperations)
                    {
                        accountSumUltimoOperations.update();
                    }
                    else
                    {
                        accountSumUltimoOperations.SessionId = processSession;
                        accountSumUltimoOperations.UTCTimestamp    = processTimestamp;
                        accountSumUltimoOperations.LedgerDimension = currentLedgerDimension;
                        accountSumUltimoOperations.OperationsTax   = tmpAccountSum.OperationsTax;
                        accountSumUltimoOperations.CurrencyCode    = tmpAccountSum.CurrencyCode;
                        accountSumUltimoOperations.euroTriangulation = tmpAccountSum.euroTriangulation;
                        accountSumUltimoOperations.ClosingType     = LedgerAccountType::AccountOperations;
                        accountSumUltimoOperations.Posting         = LedgerPostingType::TransferOpeningClosing;

                        accountSumUltimoOperations.insert();
                    }

                    // Look for a zeroing transaction from the transferring transaction for the designated account
                    // (ClosingType = AccountStatus & Posting = TransferOpeningClosing).
                    select forupdate firstonly accountSumUltimo
                        where accountSumUltimo.SessionId        == processSession &&
                                accountSumUltimo.UTCTimestamp   == processTimestamp &&
                                accountSumUltimo.LedgerDimension  == currentLedgerDimension &&
                                accountSumUltimo.CurrencyCode     == tmpAccountSum.CurrencyCode  &&
                                accountSumUltimo.OperationsTax    == tmpAccountSum.OperationsTax &&
                                accountSumUltimo.euroTriangulation == tmpAccountSum.euroTriangulation &&
                                accountSumUltimo.ClosingType      == LedgerAccountType::AccountStatus &&
                                accountSumUltimo.Posting          == LedgerPostingType::TransferOpeningClosing;

                    accountSumUltimo.add(tmpAccountSum);

                    if (accountSumUltimo)
                    {
                        accountSumUltimo.update();
                    }
                    else
                    {
                        accountSumUltimo.SessionId      = processSession;
                        accountSumUltimo.UTCTimestamp   = processTimestamp;
                        accountSumUltimo.LedgerDimension = currentLedgerDimension;
                        accountSumUltimo.OperationsTax  = tmpAccountSum.OperationsTax;
                        accountSumUltimo.CurrencyCode   = tmpAccountSum.CurrencyCode;
                        accountSumUltimo.euroTriangulation = tmpAccountSum.euroTriangulation;
                        accountSumUltimo.ClosingType    = LedgerAccountType::AccountStatus;
                        accountSumUltimo.Posting        = LedgerPostingType::TransferOpeningClosing;

                        accountSumUltimo.insert();
                    }
                }
                else
                {
                    // Look for a zeroing transaction for the balance sheet transaction (ClosingType = AccountStatus, Posting = Closing OR TransferOpeningClosing).
                    // (We need to ensure we update any existing P+L records in summary to a RE earnings account, not create separate records)
                    select forupdate firstonly accountSumUltimo
                        where accountSumUltimo.SessionId        == processSession &&
                                accountSumUltimo.UTCTimestamp   == processTimestamp &&
                                accountSumUltimo.LedgerDimension == _generalJournalAccountEntry.LedgerDimension &&
                                accountSumUltimo.CurrencyCode   == _generalJournalAccountEntry.TransactionCurrencyCode &&
                                accountSumUltimo.OperationsTax  == _generalJournalEntry.PostingLayer &&
                                accountSumUltimo.ClosingType    == LedgerAccountType::AccountStatus &&
                                (accountSumUltimo.Posting       == LedgerPostingType::Closing ||
                                accountSumUltimo.Posting        == LedgerPostingType::TransferOpeningClosing);

                    accountSumUltimo = this.updateLedgerTransferOpeningsumSubtractAmounts(accountSumUltimo, _generalJournalAccountEntry);

                    if (accountSumUltimo)
                    {
                        accountSumUltimo.update();
                    }
                    else
                    {
                        accountSumUltimo.SessionId       = processSession;
                        accountSumUltimo.UTCTimestamp    = processTimestamp;
                        accountSumUltimo.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;
                        accountSumUltimo.OperationsTax   = _generalJournalEntry.PostingLayer;
                        accountSumUltimo.CurrencyCode    = _generalJournalAccountEntry.TransactionCurrencyCode;
                        accountSumUltimo.ClosingType     = LedgerAccountType::AccountStatus;
                        accountSumUltimo.Posting         = LedgerPostingType::Closing;

                        accountSumUltimo.insert();
                    }

                    if (!LedgerParameters::find().DeleteOpening)
                    {
                        this.adjustUltimoTrans(accountSumUltimo);
                    }
                }
            }

            ttsCommit;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPrimoTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts existing work records for transactions in the opening period.
    /// </summary>
    protected void adjustPrimoTrans()
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        DimensionStorageSegment mainAccountStorageSegment;
        LedgerDimensionAccount  ledgerDimension;
       
        while select RecId from generalJournalEntry
            group by generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.TransactionCurrencyCode, generalJournalEntry.PostingLayer
        where generalJournalEntry.AccountingDate == periodNext &&
            generalJournalEntry.FiscalCalendarPeriod == openingFiscalCalendarPeriodRecId &&
            generalJournalEntry.Ledger == Ledger::current()
        join sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount), sum(Quantity) from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
        exists join fiscalCalendarPeriod
            where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                && fiscalCalendarPeriod.Type == FiscalPeriodType::Opening
        {
            // Get a ledger dimension that matches the structure used by YEC
            if (!isPublicSectorYearEndProcessingEnabled)
            {
                mainAccountStorageSegment = this.getMainAccountStorageSegment(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(generalJournalAccountEntry.LedgerDimension));
                ledgerDimension = this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, generalJournalAccountEntry.LedgerDimension);
            }
            else
            {
                ledgerDimension = generalJournalAccountEntry.LedgerDimension;
            }

            try
            {
                ttsBegin;

                select forupdate firstonly accountSumPrimo
                    where accountSumPrimo.SessionId       == processSession &&
                        accountSumPrimo.utcTimestamp      == processTimestamp &&
                        accountSumPrimo.LedgerDimension   == ledgerDimension &&
                        accountSumPrimo.CurrencyCode      == generalJournalAccountEntry.TransactionCurrencyCode &&
                        accountSumPrimo.OperationsTax     == generalJournalEntry.PostingLayer &&
                        accountSumPrimo.ClosingType       == LedgerAccountType::AccountStatus &&
                        accountSumPrimo.Posting           == LedgerPostingType::None;

                if (accountSumPrimo)
                {
                    accountSumPrimo = this.updateLedgerTransferOpeningsumSubtractAmounts(accountSumPrimo, generalJournalAccountEntry);

                    accountSumPrimo.update();
                }

                ttsCommit;
            }
            catch (Exception::UpdateConflict)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustUltimoTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the existing closing transaction for the current work record.
    /// </summary>
    /// <param name="_accountSumUltimo">
    /// A <c>LedgerTransferOpeningSumTmp</c> record.
    /// </param>
    /// <remarks>
    /// Sys method
    /// </remarks>
    protected void adjustUltimoTrans(LedgerTransferOpeningSumTmp _accountSumUltimo)
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerTransferOpeningSumTmp closingTransaction;

        if (isPublicSectorYearEndProcessingEnabled)
        {
            while select PostingLayer from generalJournalEntry
                group by generalJournalEntry.PostingLayer, generalJournalAccountEntry.TransactionCurrencyCode, generalJournalAccountEntry.LedgerDimension
                where generalJournalEntry.AccountingDate == periodEnd
                    && generalJournalEntry.FiscalCalendarPeriod == closingFiscalCalendarPeriodRecId
                    && generalJournalEntry.Ledger == Ledger::current()
                join LedgerDimension, TransactionCurrencyCode, sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount), sum(Quantity) from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                        && generalJournalAccountEntry.PostingType == LedgerPostingType::TransferOpeningClosing
                exists join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing
            {
                try
                {
                    ttsBegin;

                    select firstonly forupdate closingTransaction
                        where closingTransaction.SessionId == processSession
                            && closingTransaction.UTCTimestamp == processTimestamp
                            && closingTransaction.LedgerDimension == generalJournalAccountEntry.LedgerDimension
                            && closingTransaction.CurrencyCode == generalJournalAccountEntry.TransactionCurrencyCode
                            && closingTransaction.OperationsTax == generalJournalEntry.PostingLayer
                            && (closingTransaction.ClosingType == LedgerAccountType::AccountStatus
                            || closingTransaction.ClosingType == LedgerAccountType::AccountOperations)
                            && closingTransaction.Posting == LedgerPostingType::Closing;

                    if (closingTransaction)
                    {
                        closingTransaction = this.updateLedgerTransferOpeningsumSubtractAmounts(closingTransaction, generalJournalAccountEntry);

                        closingTransaction.update();
                    }

                    ttsCommit;
                }
                catch (Exception::UpdateConflict)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
            }
        }
        else
        {
            try
            {
                ttsBegin;

                select firstonly RecId from generalJournalEntry
                    where generalJournalEntry.AccountingDate == periodEnd &&
                        generalJournalEntry.FiscalCalendarPeriod == closingFiscalCalendarPeriodRecId &&
                        generalJournalEntry.PostingLayer == _accountSumUltimo.OperationsTax &&
                        generalJournalEntry.Ledger == Ledger::current()
                join sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount),sum(Quantity)  from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                        generalJournalAccountEntry.LedgerDimension == _accountSumUltimo.LedgerDimension &&
                        generalJournalAccountEntry.TransactionCurrencyCode == _accountSumUltimo.CurrencyCode &&
                        generalJournalAccountEntry.PostingType == LedgerPostingType::TransferOpeningClosing
                exists join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing;

                _accountSumUltimo = this.updateLedgerTransferOpeningsumSubtractAmounts(_accountSumUltimo, generalJournalAccountEntry);

                _accountSumUltimo.update();

                ttsCommit;
            }
            catch (Exception::UpdateConflict)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calendarId_modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the <c>CalendarRecId</c> field when <c>dialogCalendarId</c> field is modified.
    /// </summary>
    /// <param name="_formStringControl">
    /// The control that is bound to the <c>dialogCalendarId</c> field.
    /// </param>
    /// <returns>
    /// true if the <c>dialogCalendarId</c> field can be edited; otherwise, false .
    /// </returns>
    private boolean calendarId_modified(FormStringControl _formStringControl)
    {
        boolean valueWasModified;

        valueWasModified = _formStringControl.modified();

        if (valueWasModified)
        {
            // Cache often used data for improved performance.
            calendarRecId = FiscalCalendar::findByCalendarId(dialogCalendarId.value()).RecId;
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerTransferOpeningSumAddAmounts</Name>
				<Source><![CDATA[
    private LedgerTransferOpeningSumTmp updateLedgerTransferOpeningSumAddAmounts(LedgerTransferOpeningSumTmp _ledgerAccountSumTmp, GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        real currentAccountingCurrencyAmount = _ledgerAccountSumTmp.AccountingCurrencyAmount;
        real currentReportingCurrencyAmount = _ledgerAccountSumTmp.ReportingCurrencyAmount;

        _ledgerAccountSumTmp.addGeneralJournalAccountEntry(_generalJournalAccountEntry);

        if (_ledgerAccountSumTmp.ReportingCurrencyAmount != currentReportingCurrencyAmount + _generalJournalAccountEntry.ReportingCurrencyAmount
            || _ledgerAccountSumTmp.AccountingCurrencyAmount != currentAccountingCurrencyAmount + _generalJournalAccountEntry.AccountingCurrencyAmount)
        {
            this.logInformation(strFmt(AmountPrecisionLogMessage, _ledgerAccountSumTmp.LedgerDimension));
        }

        return _ledgerAccountSumTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerTransferOpeningsumSubtractAmounts</Name>
				<Source><![CDATA[
    private LedgerTransferOpeningSumTmp updateLedgerTransferOpeningsumSubtractAmounts(LedgerTransferOpeningSumTmp _ledgerAccountSumTmp, GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        real currentAccountingCurrencyAmount = _ledgerAccountSumTmp.AccountingCurrencyAmount;
        real currentReportingCurrencyAmount = _ledgerAccountSumTmp.ReportingCurrencyAmount;

        _ledgerAccountSumTmp.subtractGeneralJournalAccountEntry(_generalJournalAccountEntry);

        if (_ledgerAccountSumTmp.ReportingCurrencyAmount != currentReportingCurrencyAmount - _generalJournalAccountEntry.ReportingCurrencyAmount
            || _ledgerAccountSumTmp.AccountingCurrencyAmount != currentAccountingCurrencyAmount - _generalJournalAccountEntry.AccountingCurrencyAmount)
        {
            this.logInformation(strFmt(AmountPrecisionLogMessage, _ledgerAccountSumTmp.LedgerDimension));
        }

        return _ledgerAccountSumTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logInformation</Name>
				<Source><![CDATA[
    private SysInstrumentationLogger logInformation(str _message)
    {
        SysInstrumentationLogger instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(classStr(LedgerTransferOpening));
        instrumentationLogger.logInformation(_message);

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logError</Name>
				<Source><![CDATA[
    private SysInstrumentationLogger logError(str _message)
    {
        SysInstrumentationLogger instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(classStr(LedgerTransferOpening));
        instrumentationLogger.logError(_message);

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipOffsetAccountForRealAccounts_PSN</Name>
				<Source><![CDATA[
    private boolean shouldSkipOffsetAccountForRealAccounts_PSN(LedgerDimensionAccount _ledgerDimension)
    {
        return isPublicSectorYearEndProcessingEnabled 
            && FeatureStateProvider::isFeatureEnabled(LedgerTrnasferOpeningRealAccountsFlight_PSN::instance())
            && MainAccount::findByLedgerDimension(_ledgerDimension).CloseType == AccountCloseType::Real;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the process has batch processing checked and can be run in batch mode.
    /// </summary>
    /// <returns>
    /// true if batch processing is enabled and setup correctly; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method must be in this class because it is called from the <c>dialogRunbase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        boolean validBatchParameters;

        if (isPublicSectorYearEndProcessingEnabled)
        {
            validBatchParameters = !((runPreview) && (this.batchInfo().fieldBatchExecuteValue()));
        }
        else
        {
            return true;
        }

        return validBatchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the configuration of process parameters to indicate whether the combination of parameters is
    /// valid.
    /// </summary>
    /// <exception cref="M:Exception::Warning">
    /// An invalid parameter combination has been detected.
    /// </exception>
    protected void checkParameters()
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;

        if (!ledgerParameters.DeleteOpening)
        {
            select firstonly RecId from generalJournalEntry
                where generalJournalEntry.AccountingDate == periodEnd &&
                    generalJournalEntry.FiscalCalendarPeriod == closingFiscalCalendarPeriodRecId &&
                    generalJournalEntry.Ledger == Ledger::current()
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                    generalJournalAccountEntry.PostingType == LedgerPostingType::TransferOpeningClosing
            exists join fiscalCalendarPeriod
                where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                    && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing;

            if (isPublicSectorYearEndProcessingEnabled)
            {
                if (!ledgerParameters.PeriodClosingPosting)
                {
                    if (generalJournalAccountEntry != null)
                    {
                        throw warning("@SYS67692");
                    }
                }
            }
            else
            {
                if (ledgerParameters.PeriodClosingPosting)
                {
                    /* if the parameter "periodClosingPosting" is set to Yes, then is it not allowed
                       to have opening transactions in the next year without a corresponding ultimo transaction in
                       actual fiscal year.*/

                       if (generalJournalAccountEntry == null)
                    {
                        select firstonly RecId from generalJournalEntry
                            where generalJournalEntry.AccountingDate == periodNext &&
                                generalJournalEntry.FiscalCalendarPeriod == openingFiscalCalendarPeriodRecId &&
                                generalJournalEntry.Ledger == Ledger::current()
                        join RecId from generalJournalAccountEntry
                            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                        exists join fiscalCalendarPeriod
                            where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                                && fiscalCalendarPeriod.Type == FiscalPeriodType::Opening;

                        if (generalJournalAccountEntry != null)
                        {
                            throw warning("@SYS67692");
                        }
                    }
                }
                else
                {
                    /* if the parameter "PeriodClosingPosting" is set to NO, then is it not allowed
                       to have existing ultimo transactions in the same fiscal year.*/

                       if (generalJournalAccountEntry != null)
                    {
                        throw warning("@SYS67692");
                    }
                }
            }

            if (methodStatus == OpeningMethod::Reset)
            {
                throw warning("@SYS67693");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAccountEntryDimensionTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all records from the <c>GeneralJournalAccountEntryDimension</c>, <c>GeneralJournalAccountEntryHash</c>,
    /// <c>GeneralJournalAccountEntryHashLink</c>, and <c>LedgerDimensionTmp</c> tables for the current session.
    /// </summary>
    [SysObsolete('This method is obsolete, call createYearEndCloseCleanupJob in LedgerTransferOpeningCleanupController controller class instead.', false, 22\6\2020)]
    protected void clearAccountEntryDimensionTables()
    {
        GeneralJournalAccountEntryDimension     generalJournalAccountEntryDimension;
        GeneralJournalAccountEntryHash          generalJournalAccountEntryHash;
        GeneralJournalAccountEntryHashLink      generalJournalAccountEntryHashLink;
        LedgerDimensionTmp                      ledgerDimensionTmp;

        delete_from generalJournalAccountEntryDimension
            where generalJournalAccountEntryDimension.CurrentSessionId == processSession
                && generalJournalAccountEntryDimension.UTCTimestamp == processTimestamp;

        delete_from generalJournalAccountEntryHashLink
            where generalJournalAccountEntryHashLink.CurrentSessionId == processSession
                && generalJournalAccountEntryHashLink.CurrentTimestamp == processTimestamp;

        delete_from generalJournalAccountEntryHash
            where generalJournalAccountEntryHash.CurrentSessionId == processSession
                && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp;

        delete_from ledgerDimensionTmp
            where ledgerDimensionTmp.CurrentSessionId == processSession
                && ledgerDimensionTmp.CurrentTimestamp == processTimestamp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearSummaryTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all records from the <c>LedgerTransferOpeningSumTmp</c> table for the current session.
    /// </summary>
    [SysObsolete('This method is obsolete, call createYearEndCloseCleanupJob in LedgerTransferOpeningCleanupController controller class instead.', false, 22\6\2020)]
    protected void clearSummaryTables()
    {
        LedgerTransferOpeningSumTmp    ledgerAccountSumTmp;

        if (!(isPublicSectorYearEndProcessingEnabled && runReport))
        {
            // In Public Sector, we keep the records for the report which handles
            // the deleting of the current process records
            delete_from ledgerAccountSumTmp
                where ledgerAccountSumTmp.SessionId == processSession
                    && ledgerAccountSumTmp.UTCTimestamp == processTimestamp;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAccountEntryHash</Name>
				<Source><![CDATA[
    private void createAccountEntryHash(RecId _unused, RecId _ledgerDimensionId, str _hashMessage)
    {
        GeneralJournalAccountEntryHash      generalJournalAccountEntryHash;
        GeneralJournalAccountEntryHashLink  generalJournalAccountEntryHashLink;
        DimensionHashContainer              hash;
        int                                 line;

        hash = DimensionHash::getHash(_hashMessage);

        select firstonly RecId from generalJournalAccountEntryHash
            where generalJournalAccountEntryHash.CurrentSessionId == processSession
                && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                && generalJournalAccountEntryHash.CombinationHash == hash;

        if (generalJournalAccountEntryHash == null)
        {
            try
            {
                line = Global::infologLine();

                generalJournalAccountEntryHash.CurrentSessionId = processSession;
                generalJournalAccountEntryHash.CurrentTimestamp = processTimestamp;
                generalJournalAccountEntryHash.CombinationHash = hash;
                generalJournalAccountEntryHash.LedgerDimension = _ledgerDimensionId;
                generalJournalAccountEntryHash.insert();
            }
            catch (Exception::DuplicateKeyExceptionNotRecovered)
            {
                // clear the infolog because we recovered from the duplicate
                infolog.clear(line);

                select firstOnly RecId from generalJournalAccountEntryHash
                    where generalJournalAccountEntryHash.CurrentSessionId == processSession
                        && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                        && generalJournalAccountEntryHash.CombinationHash == hash;
            }
            catch (Exception::DuplicateKeyException)
            {
                // clear the infolog because we recovered from the duplicate
                infolog.clear(line);

                select firstOnly RecId from generalJournalAccountEntryHash
                    where generalJournalAccountEntryHash.CurrentSessionId == processSession
                        && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                        && generalJournalAccountEntryHash.CombinationHash == hash;
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
        }

        Debug::assert(generalJournalAccountEntryHash.RecId);

        try
        {
            generalJournalAccountEntryHashLink.CurrentSessionId = processSession;
            generalJournalAccountEntryHashLink.CurrentTimestamp = processTimestamp;
            generalJournalAccountEntryHashLink.LedgerDimension = _ledgerDimensionId;
            generalJournalAccountEntryHashLink.GeneralJournalAccountEntryHash = generalJournalAccountEntryHash.RecId;
            generalJournalAccountEntryHashLink.insert();
        }
        catch (Exception::DuplicateKeyException)
        {
            // clear the infolog because we recovered from the duplicate
            infolog.clear(line);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBalanceCreationBundles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates BalanceCreation bundle tasks.
    /// </summary>
    /// <param name = "_batchHeader">
    /// The <c>BatchHeader</c> instance.
    /// </param>
    /// <param name = "_ledgerTransferOpeningType">
    /// The <c>LedgerTransferOpeningType</c> enumeration value.
    /// </param>
    protected void createBalanceCreationBundles(BatchHeader _batchHeader, LedgerTransferOpeningType _ledgerTransferOpeningType)
    {
        GeneralJournalAccountEntryHash generalJournalAccountEntryHash;
        RecId minRecId;
        RecId maxRecId;

        select minOf(RecId) from generalJournalAccountEntryHash
            where generalJournalAccountEntryHash.CurrentSessionId == processSession
                && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp;
        minRecId = generalJournalAccountEntryHash.RecId;

        select maxOf(RecId) from generalJournalAccountEntryHash
            where generalJournalAccountEntryHash.CurrentSessionId == processSession
                && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp;
        maxRecId = generalJournalAccountEntryHash.RecId;

        this.createBundles(
            _batchHeader,
            LedgerTransferOpeningProcessState::BalanceCreation,
            _ledgerTransferOpeningType,
            LedgerTransferOpening::BalanceCalculationBundleSize,
            minRecId,
            maxRecId);

        if (isAdvancedAwarenessOptsParmEnabled && _ledgerTransferOpeningType == LedgerTransferOpeningType::BalanceSheet)
        {
            this.createBundles(
                _batchHeader,
                LedgerTransferOpeningProcessState::BalanceSheetCreationDetails,
                _ledgerTransferOpeningType,
                LedgerTransferOpening::BalanceCalculationBundleSize,
                minRecId,
                maxRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBundles</Name>
				<Source><![CDATA[
    private void createBundles(
        BatchHeader _batchHeader,
        LedgerTransferOpeningProcessState _processState,
        LedgerTransferOpeningType _ledgerTransferOpeningType,
        int _bundleSizeMax,
        RecId _minRecId,
        RecId _maxRecId,
        LedgerTransferOpening _parentTask = null)
    {
        LedgerTransferOpening bundleTask;
        RecId currentRecId;
        RecId startValue;
        RecId endValue;
        int i;

        if (_minRecId == _maxRecId)
        {
            bundleTask = this.createTask(_processState, _ledgerTransferOpeningType);
            bundleTask.parmStartRecId(_minRecId);
            bundleTask.parmEndRecId(_maxRecId);

            _batchHeader.addRuntimeTask(bundleTask, this.parmCurrentBatch().RecId);

            if (_parentTask != null)
            {
                // Update the parent task to be dependent on the bundle task.
                _batchHeader.addDependency(_parentTask, bundleTask, BatchDependencyStatus::Finished);
            }
        }
        else
        {
            i = 0;
            currentRecId = _minRecId;
            while (currentRecId < _maxRecId)
            {
                i++;

                if (currentRecId != _minRecId)
                {
                    currentRecId++;
                }

                startValue = currentRecId;

                currentRecId += (_bundleSizeMax - 1);

                if (currentRecId > _maxRecId)
                {
                    currentRecId = _maxRecId;
                }

                endValue = currentRecId;

                if (startValue > endValue)
                {
                    // use wrongUseOfFunction because this is most likely an error during development
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                bundleTask = this.createTask(_processState, _ledgerTransferOpeningType, i);
                bundleTask.parmStartRecId(startValue);
                bundleTask.parmEndRecId(endValue);

                _batchHeader.addRuntimeTask(bundleTask, this.parmCurrentBatch().RecId);

                if (_parentTask != null)
                {
                    // Update the parent task to be dependent on the bundle task.
                    _batchHeader.addDependency(_parentTask, bundleTask, BatchDependencyStatus::Finished);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimensionLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>GeneralJournalAccountEntryDimension</c> records for the
    /// specified ledger transfer opening type and account close type.
    /// </summary>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type value.
    /// </param>
    /// <param name="_accountCloseType">
    /// The account close type value; optional.
    /// </param>
    /// <remarks>
    /// The <c>GeneralJournalAccountEntryDimension</c> records created are used to
    /// restrict the <c>GeneralJournalAccountEntry</c> records in the rest of the
    /// processing so all constraints on the <c>GeneralJournalAccountEntry</c>
    /// records need to be included here.
    /// </remarks>
    protected void createDimensionLinks(
        LedgerTransferOpeningType _ledgerTransferOpeningType,
        AccountCloseType _accountCloseType = AccountCloseType::NotApplicable)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalAccountEntryDimension generalJournalAccountEntryDimension;
        GeneralJournalAccountEntryHash generalJournalAccountEntryHash;
        GeneralJournalAccountEntryHashLink generalJournalAccountEntryHashLink;
        GeneralJournalEntry generalJournalEntry;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        LedgerDimensionTmp ledgerDimensionTmp;
        date endDate;

        if (isPublicSectorYearEndProcessingEnabled)
        {
            if (_accountCloseType == AccountCloseType::Nominal)
            {
                endDate = closeDateFromPeriod;
            }
            else
            {
                endDate = openDateFromPeriod;
            }

            insert_recordset generalJournalAccountEntryDimension
                (GeneralJournalAccountEntry, Type, GeneralJournalAccountEntryHash, MainAccount, PostingLayer, CurrentSessionId, UTCTimestamp)
            select RecId, _ledgerTransferOpeningType from generalJournalAccountEntry
                group by generalJournalAccountEntry.RecId,
                    generalJournalAccountEntryHash.RecId,
                    ledgerDimensionTmp.MainAccount,
                    generalJournalEntry.PostingLayer
                where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
            join generalJournalAccountEntryHashLink
                where generalJournalAccountEntryHashLink.CurrentSessionId == processSession
                    && generalJournalAccountEntryHashLink.CurrentTimestamp == processTimestamp
                    && generalJournalAccountEntryHashLink.LedgerDimension == generalJournalAccountEntry.LedgerDimension
            join RecId from generalJournalAccountEntryHash
                where generalJournalAccountEntryHash.CurrentSessionId == processSession
                    && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                    && generalJournalAccountEntryHash.RecId == generalJournalAccountEntryHashLink.GeneralJournalAccountEntryHash
            join MainAccount from ledgerDimensionTmp
                where ledgerDimensionTmp.CurrentSessionId == processSession
                    && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                    && ledgerDimensionTmp.LedgerDimension == generalJournalAccountEntry.LedgerDimension
                    && ledgerDimensionTmp.Type == _ledgerTransferOpeningType
            join PostingLayer, processSession, processTimestamp from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= periodStart
                    && generalJournalEntry.AccountingDate <= endDate
            join fiscalCalendarPeriod
                where generalJournalEntry.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                    && ((fiscalCalendarPeriod.EndDate >= periodStart
                    && fiscalCalendarPeriod.EndDate <= closeDateFromPeriod)
                    && ((fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
                        || (fiscalCalendarPeriod.Type == FiscalPeriodType::Operating)
                        || ((fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
                        && (fiscalCalendarPeriod.Name <= balanceOpenFromPeriod))));
        }
        else
        {
            Debug::assert(_accountCloseType == AccountCloseType::NotApplicable);

            insert_recordset generalJournalAccountEntryDimension
                (GeneralJournalAccountEntry, Type, GeneralJournalAccountEntryHash, MainAccount, PostingLayer, CurrentSessionId, UTCTimestamp)
            select RecId, _ledgerTransferOpeningType from generalJournalAccountEntry
                group by generalJournalAccountEntry.RecId,
                    generalJournalAccountEntryHash.RecId,
                    ledgerDimensionTmp.MainAccount,
                    generalJournalEntry.PostingLayer
                where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
            join generalJournalAccountEntryHashLink
                where generalJournalAccountEntryHashLink.CurrentSessionId == processSession
                    && generalJournalAccountEntryHashLink.CurrentTimestamp == processTimestamp
                    && generalJournalAccountEntryHashLink.LedgerDimension == generalJournalAccountEntry.LedgerDimension
            join RecId from generalJournalAccountEntryHash
                where generalJournalAccountEntryHash.CurrentSessionId == processSession
                    && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                    && generalJournalAccountEntryHash.RecId == generalJournalAccountEntryHashLink.GeneralJournalAccountEntryHash
            join MainAccount from ledgerDimensionTmp
                where ledgerDimensionTmp.CurrentSessionId == processSession
                    && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                    && ledgerDimensionTmp.LedgerDimension == generalJournalAccountEntry.LedgerDimension
                    && ledgerDimensionTmp.Type == _ledgerTransferOpeningType
            join PostingLayer, processSession, processTimestamp from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= periodStart
                    && generalJournalEntry.AccountingDate <= periodEnd;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHashLinkBundles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates HashCreation bundle tasks.
    /// </summary>
    /// <param name = "_batchHeader">
    /// The <c>BatchHeader</c> instance.
    /// </param>
    /// <param name = "_linkCreationTask">
    /// The <c>LedgerTransferOpening</c> class instance.
    /// </param>
    protected void createHashLinkBundles(BatchHeader _batchHeader, LedgerTransferOpening _linkCreationTask)
    {
        LedgerDimensionTmp ledgerDimensionTmp;
        RecId minRecId;
        RecId maxRecId;
        LedgerTransferOpeningType transferOpeningType;

        transferOpeningType = _linkCreationTask.parmLedgerTransferOpeningType();

        select minOf(RecId) from ledgerDimensionTmp
            where ledgerDimensionTmp.CurrentSessionId == processSession
                && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                && ledgerDimensionTmp.Type == transferOpeningType;
        minRecId = ledgerDimensionTmp.RecId;

        select maxOf(RecId) from ledgerDimensionTmp
            where ledgerDimensionTmp.CurrentSessionId == processSession
                && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                && ledgerDimensionTmp.Type == transferOpeningType;
        maxRecId = ledgerDimensionTmp.RecId;

        this.createBundles(
            _batchHeader,
            LedgerTransferOpeningProcessState::HashCreation,
            transferOpeningType,
            LedgerTransferOpening::HashGenerationBundleSize,
            minRecId,
            maxRecId,
            _linkCreationTask);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHashLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>GeneralJournalAccountEntryHash</c> records and
    /// <c>GeneralJournalAccountEntryHashLink</c> records for the specified ledger
    /// transfer opening type.
    /// </summary>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type.
    /// </param>
    /// <remarks>
    /// The <c>createHashLinksForPublicSector</c> method performs this
    /// processing for the public sector cases.
    /// </remarks>
    protected void createHashLinks(LedgerTransferOpeningType _ledgerTransferOpeningType)
    {
        GeneralJournalAccountEntryHash generalJournalAccountEntryHash;
        GeneralJournalAccountEntryHashLink generalJournalAccountEntryHashLink;
        DimensionAttributeLevelValueView dimAttrLevelValueView;
        DimensionAttributeValueCombination dimAttrValueCombination;
        DimensionAttributeSetItem dimAttributeSetItem;
        LedgerDimensionTmp ledgerDimensionTmp;
        DimensionHashContainer hash;
        RecId dimensionAttributeSet;
        RecId hashRecId;
        RecId previousLedgerDimension;
        int line;
        str hashMessage;

        if (_ledgerTransferOpeningType == LedgerTransferOpeningType::ProfitLoss)
        {
            dimensionAttributeSet = profitLossCloseAllDimensionAttributeSet;
        }
        else if (_ledgerTransferOpeningType == LedgerTransferOpeningType::BalanceSheet)
        {
            dimensionAttributeSet = balanceSheetDimensionAttributeSet;
        }
        else
        {
            Debug::assert(false);
        }

        if (dimensionAttributeSet)
        {
            previousLedgerDimension = 0;

            while select LedgerDimension from ledgerDimensionTmp
                group by ledgerDimensionTmp.LedgerDimension,
                    dimAttrValueCombination.RecId,
                    dimAttributeSetItem.DimensionAttribute,
                    dimAttrLevelValueView.AttributeValueRecId
                order by ledgerDimensionTmp.LedgerDimension,
                    dimAttributeSetItem.DimensionAttribute
                where ledgerDimensionTmp.CurrentSessionId == processSession
                    && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                    && ledgerDimensionTmp.Type == _ledgerTransferOpeningType
                    && ledgerDimensionTmp.RecId >= startRecId
                    && ledgerDimensionTmp.RecId <= endRecId
            join RecId from dimAttrValueCombination
                where dimAttrValueCombination.RecId == ledgerDimensionTmp.LedgerDimension
            join DimensionAttribute from dimAttributeSetItem
                where dimAttributeSetItem.DimensionAttributeSet == dimensionAttributeSet &&
                    dimAttributeSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll)
            outer join AttributeValueRecId from dimAttrLevelValueView
                where dimAttrLevelValueView.ValueCombinationRecId == dimAttrValueCombination.RecId &&
                    dimAttrLevelValueView.DimensionAttribute == dimAttributeSetItem.DimensionAttribute
            {
                if (previousLedgerDimension != ledgerDimensionTmp.LedgerDimension)
                {
                    // Store hash for prior account entry
                    if (previousLedgerDimension != 0)
                    {
                        this.createAccountEntryHash(0, previousLedgerDimension, hashMessage);
                    }

                    previousLedgerDimension = ledgerDimensionTmp.LedgerDimension;

                    hashMessage = int642str(dimAttrLevelValueView.AttributeValueRecId);
                }
                else
                {
                    // Add value to hash message
                    hashMessage += '~' + int642str(dimAttrLevelValueView.AttributeValueRecId);
                }
            }

            if (previousLedgerDimension != 0)
            {
                this.createAccountEntryHash(0, previousLedgerDimension, hashMessage);
            }
        }
        else
        {
            // Use the same hash for everything because they are not being restriced
            // and the rest of the processing requires these hash link records
            hash = DimensionHash::getHash(int642str(0));

            select firstonly RecId from generalJournalAccountEntryHash
                where generalJournalAccountEntryHash.CurrentSessionId == processSession
                    && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                    && generalJournalAccountEntryHash.CombinationHash == hash;

            if (generalJournalAccountEntryHash == null)
            {
                try
                {
                    line = Global::infologLine();

                    generalJournalAccountEntryHash.CurrentSessionId = processSession;
                    generalJournalAccountEntryHash.CurrentTimestamp = processTimestamp;
                    generalJournalAccountEntryHash.CombinationHash = hash;
                    generalJournalAccountEntryHash.insert();
                }
                catch (Exception::DuplicateKeyExceptionNotRecovered)
                {
                    // clear the infolog because we recovered from the duplicate
                    infolog.clear(line);

                    select firstOnly RecId from generalJournalAccountEntryHash
                        where generalJournalAccountEntryHash.CurrentSessionId == processSession
                            && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                            && generalJournalAccountEntryHash.CombinationHash == hash;
                }
                catch (Exception::DuplicateKeyException)
                {
                    // clear the infolog because we recovered from the duplicate
                    infolog.clear(line);

                    select firstOnly RecId from generalJournalAccountEntryHash
                        where generalJournalAccountEntryHash.CurrentSessionId == processSession
                            && generalJournalAccountEntryHash.CurrentTimestamp == processTimestamp
                            && generalJournalAccountEntryHash.CombinationHash == hash;
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::Deadlock;
                    }
                    else
                    {
                        retry;
                    }
                }
            }

            hashRecId = generalJournalAccountEntryHash.RecId;

            insert_recordset generalJournalAccountEntryHashLink
                (LedgerDimension, GeneralJournalAccountEntryHash, CurrentSessionId, CurrentTimestamp)
            select LedgerDimension, hashRecId, processSession, processTimestamp from ledgerDimensionTmp
                group by ledgerDimensionTmp.LedgerDimension
                order by ledgerDimensionTmp.LedgerDimension
            where ledgerDimensionTmp.CurrentSessionId == processSession
                && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                && ledgerDimensionTmp.Type == _ledgerTransferOpeningType
                && ledgerDimensionTmp.RecId >= startRecId
                && ledgerDimensionTmp.RecId <= endRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHashLinksForPublicSector</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>GeneralJournalAccountEntryHash</c> records and
    /// <c>GeneralJournalAccountEntryHashLink</c> records for the specified ledger
    /// transfer opening type and account close type.
    /// </summary>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type.
    /// </param>
    /// <param name="_accountCloseType">
    /// The account close type.
    /// </param>
    /// <remarks>
    /// The <c>createHashLinks</c> method performs this processing for the
    /// non-public sector cases.
    /// </remarks>
    protected void createHashLinksForPublicSector(
        LedgerTransferOpeningType _ledgerTransferOpeningType,
        AccountCloseType _accountCloseType)
    {
        DimensionAttributeSetItem dimAttributeSetItem;
        DimensionAttributeValueCombination dimAttrValueCombination;
        DimensionAttributeLevelValueView dimAttrLevelValueView;
        LedgerDimensionTmp ledgerDimensionTmp;
        MainAccount mainAccount;
        RecId previousLedgerDimension;
        str hashMessage;

        previousLedgerDimension = 0;

        while select LedgerDimension from ledgerDimensionTmp
            group by ledgerDimensionTmp.LedgerDimension,
                dimAttrValueCombination.RecId,
                dimAttributeSetItem.DimensionAttribute,
                dimAttrLevelValueView.AttributeValueRecId
            order by ledgerDimensionTmp.LedgerDimension,
                dimAttributeSetItem.DimensionAttribute
            where ledgerDimensionTmp.CurrentSessionId == processSession
                && ledgerDimensionTmp.CurrentTimestamp == processTimestamp
                && ledgerDimensionTmp.Type == _ledgerTransferOpeningType
                && ledgerDimensionTmp.RecId >= startRecId
                && ledgerDimensionTmp.RecId <= endRecId
        join RecId from dimAttrValueCombination
            where dimAttrValueCombination.RecId == ledgerDimensionTmp.LedgerDimension
        join RecId from mainAccount
            where mainAccount.RecId == dimAttrValueCombination.MainAccount &&
                mainAccount.RecId == dimAttrValueCombination.MainAccount
                && mainAccount.CloseType == _accountCloseType
        join DimensionAttribute from dimAttributeSetItem
            where dimAttributeSetItem.DimensionAttributeSet == allDimAttributes
                && dimAttributeSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll)
        outer join AttributeValueRecId from dimAttrLevelValueView
            where dimAttrLevelValueView.ValueCombinationRecId == dimAttrValueCombination.RecId &&
                dimAttrLevelValueView.DimensionAttribute == dimAttributeSetItem.DimensionAttribute
        {
            if (previousLedgerDimension != ledgerDimensionTmp.LedgerDimension)
            {
                // Store hash for prior account entry
                if (previousLedgerDimension != 0)
                {
                    this.createAccountEntryHash(0, previousLedgerDimension, hashMessage);
                }

                previousLedgerDimension = ledgerDimensionTmp.LedgerDimension;

                hashMessage = int642str(dimAttrLevelValueView.AttributeValueRecId);
            }
            else
            {
                // Add value to hash message
                hashMessage += '~' + int642str(dimAttrLevelValueView.AttributeValueRecId);
            }
        }

        if (previousLedgerDimension != 0)
        {
            this.createAccountEntryHash(0, previousLedgerDimension, hashMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>LedgerDimensionTmp</c> records for the specified ledger transfer
    /// opening type.
    /// </summary>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type.
    /// </param>
    /// <remarks>
    /// The <c>createLedgerDimensionsForPublicSector</c> method performs this
    /// processing for the public sector cases.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The ledger transfer opening type is not supported by this method.
    /// </exception>
    protected void createLedgerDimensions(LedgerTransferOpeningType _ledgerTransferOpeningType)
    {
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerDimensionTmp ledgerDimensionTmp;
        MainAccount mainAccount;

        if (_ledgerTransferOpeningType == LedgerTransferOpeningType::ProfitLoss)
        {
            insert_recordset ledgerDimensionTmp (LedgerDimension, Type, MainAccount, CurrentSessionId, CurrentTimestamp)
                select LedgerDimension, _ledgerTransferOpeningType from generalJournalAccountEntry
                    group by generalJournalAccountEntry.LedgerDimension,
                        mainAccount.RecId
                    where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                        generalJournalEntry.Ledger == Ledger::current() &&
                        generalJournalEntry.AccountingDate >= periodStart &&
                        generalJournalEntry.AccountingDate <= periodEnd
                join RecId, processSession, processTimestamp from mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount &&
                        (mainAccount.Type == DimensionLedgerAccountType::ProfitAndLoss ||
                        mainAccount.Type == DimensionLedgerAccountType::Revenue ||
                        mainAccount.Type == DimensionLedgerAccountType::Expense);
        }
        else if (_ledgerTransferOpeningType == LedgerTransferOpeningType::BalanceSheet)
        {
            insert_recordset ledgerDimensionTmp (LedgerDimension, Type, MainAccount, CurrentSessionId, CurrentTimestamp)
                select LedgerDimension, _ledgerTransferOpeningType from generalJournalAccountEntry
                    group by generalJournalAccountEntry.LedgerDimension,
                        mainAccount.RecId
                    where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                        generalJournalEntry.Ledger == Ledger::current() &&
                        generalJournalEntry.AccountingDate >= periodStart &&
                        generalJournalEntry.AccountingDate <= periodEnd
                join RecId, processSession, processTimestamp from mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount &&
                        (mainAccount.Type == DimensionLedgerAccountType::BalanceSheet ||
                        mainAccount.Type == DimensionLedgerAccountType::Asset ||
                        mainAccount.Type == DimensionLedgerAccountType::Liability ||
                        mainAccount.Type == DimensionLedgerAccountType::Equity
                        // <GCN>
                        || mainAccount.Type == DimensionLedgerAccountType::Common_CN
                        // </GCN>
                        );
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimensionsForPublicSector</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>LedgerDimensionTmp</c> records for the specified ledger transfer
    /// opening type and account close type.
    /// </summary>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type.
    /// </param>
    /// <param name="_accountCloseType">
    /// The account close type.
    /// </param>
    /// <remarks>
    /// The <c>createLedgerDimensions</c> method performs this
    /// processing for the non-public sector cases.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The ledger transfer opening type is not supported by this method.
    /// </exception>
    protected void createLedgerDimensionsForPublicSector(
        LedgerTransferOpeningType _ledgerTransferOpeningType,
        AccountCloseType _accountCloseType)
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerDimensionTmp ledgerDimensionTmp;
        MainAccount mainAccount;

        periodStart = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, periodEnd);

        if (_ledgerTransferOpeningType == LedgerTransferOpeningType::PublicSectorNominal)
        {
            insert_recordset ledgerDimensionTmp (LedgerDimension, Type, MainAccount, CurrentSessionId, CurrentTimestamp)
                select LedgerDimension, _ledgerTransferOpeningType from generalJournalAccountEntry
                        group by generalJournalAccountEntry.LedgerDimension, mainAccount.RecId
                    where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                        generalJournalEntry.Ledger == Ledger::current() &&
                        generalJournalEntry.AccountingDate >= periodStart &&
                        generalJournalEntry.AccountingDate <= periodEnd
                join fiscalCalendarPeriod
                    where generalJournalEntry.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                        && ((fiscalCalendarPeriod.EndDate >= periodStart
                        && fiscalCalendarPeriod.EndDate <= closeDateFromPeriod)
                        && ((fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
                            || (fiscalCalendarPeriod.Type == FiscalPeriodType::Operating)
                            || ((fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
                            && (fiscalCalendarPeriod.Name <= balanceFromPeriod))))
                join RecId, processSession, processTimestamp from mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                        && mainAccount.CloseType == _accountCloseType;
        }
        else if (_ledgerTransferOpeningType == LedgerTransferOpeningType::PublicSectorRealDeleteOpening)
        {
            insert_recordset ledgerDimensionTmp (LedgerDimension, Type, MainAccount, CurrentSessionId, CurrentTimestamp)
                select LedgerDimension, _ledgerTransferOpeningType from generalJournalAccountEntry
                        group by generalJournalAccountEntry.LedgerDimension, mainAccount.RecId
                    where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
            join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                    generalJournalEntry.Ledger == Ledger::current() &&
                    generalJournalEntry.AccountingDate >= periodStart &&
                    generalJournalEntry.AccountingDate <= periodEnd
            join fiscalCalendarPeriod
                where generalJournalEntry.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                    && ((fiscalCalendarPeriod.EndDate >= periodStart
                    && fiscalCalendarPeriod.EndDate <= closeDateFromPeriod)
                    && ((fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
                        || (fiscalCalendarPeriod.Type == FiscalPeriodType::Operating)
                        || ((fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
                        && (fiscalCalendarPeriod.Name <= balanceOpenFromPeriod))))
            join RecId, processSession, processTimestamp from mainAccount
                where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                    && mainAccount.CloseType == _accountCloseType;
        }
        else if (_ledgerTransferOpeningType == LedgerTransferOpeningType::PublicSectorRealOther)
        {
            insert_recordset ledgerDimensionTmp (LedgerDimension, Type, MainAccount, CurrentSessionId, CurrentTimestamp)
                select LedgerDimension, _ledgerTransferOpeningType from generalJournalAccountEntry
                        group by generalJournalAccountEntry.LedgerDimension, mainAccount.RecId
                    where generalJournalAccountEntry.PostingType != LedgerPostingType::TransferOpeningClosing
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                        generalJournalEntry.Ledger == Ledger::current() &&
                        generalJournalEntry.AccountingDate >= periodStart &&
                        generalJournalEntry.AccountingDate <= periodEnd
                join fiscalCalendarPeriod
                    where generalJournalEntry.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                        && ((fiscalCalendarPeriod.EndDate >= periodStart
                        && fiscalCalendarPeriod.EndDate <= closeDateFromPeriod)
                        && ((fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
                            || (fiscalCalendarPeriod.Type == FiscalPeriodType::Operating)
                            || ((fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
                            && (fiscalCalendarPeriod.Name <= balanceOpenFromPeriod))))
                join RecId, processSession, processTimestamp from mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                        && mainAccount.CloseType == _accountCloseType;
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>LedgerTransferOpening</c> object for use in a batch task.
    /// </summary>
    /// <param name="_procesState">
    /// The process state.
    /// </param>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type; optional.
    /// </param>
    /// <param name="_sequence">
    /// The sequence; optional.
    /// </param>
    /// <returns>
    /// A <c>LedgerTransferOpening</c> object for use in a batch task.
    /// </returns>
    /// <remarks>
    /// The process state is required and defines the task.
    /// The ledger transfer opening type is required for some process states and optional for others.
    /// The sequence is use when multiple batch tasks are created to run in parallel.
    /// </remarks>
    protected LedgerTransferOpening createTask(
        LedgerTransferOpeningProcessState _procesState,
        LedgerTransferOpeningType _ledgerTransferOpeningType = LedgerTransferOpeningType::None,
        int _sequence = 0)
    {
        LedgerTransferOpening newTask;
        LedgerTransferOpeningProcessState adjustedProcessState;
        str message;

        newTask = isPublicSectorYearEndProcessingEnabled
            ? LedgerTransferOpening_PSN::construct()
            : LedgerTransferOpening::construct();

        newTask.unpack(this.pack());
        newTask.parmProcessState(_procesState);
        newTask.parmLedgerTransferOpeningType(_ledgerTransferOpeningType);
        newTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);

        // adjust the value used for the task description so the numbers are
        // sequential by mapping the public sector values to the corresponding
        // non-public sector values because gaps could look like a failure to a user
        switch (_procesState)
        {
            case LedgerTransferOpeningProcessState::PublicSectorNominal:
                adjustedProcessState = LedgerTransferOpeningProcessState::BalanceSheet;
                break;

            case LedgerTransferOpeningProcessState::PublicSectorReal:
                adjustedProcessState = LedgerTransferOpeningProcessState::ProfitLoss;
                break;

            default:
                adjustedProcessState = _procesState;
                break;
        }

        // Step A.B.C
        // A: LedgerTransferOpeningProcessState
        // B: LedgerTransferOpeningType
        // C: _sequence
        message = strFmt("@SYS121770", enum2int(adjustedProcessState), enum2int(_ledgerTransferOpeningType));
        message = strFmt("@SYS121770", message, _sequence);
        newTask.batchInfo().parmCaption(strFmt("@SYS105740", message));

        return newTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes existing opening transactions and existing system generated closing transactions.
    /// </summary>
    protected void deleteExistingRecords()
    {
        BatchHeader batchHeader;
        boolean isDeleteFlightEnabled = LedgerTransferOpeningDeleteInTrxFlight::instance().isEnabled();

        /* Delete existing opening records */
        if (!silent)
        {
            progress.setText("@SYS67293");
        }

        if (isDeleteFlightEnabled)
        {
            ttsbegin;
        }

        // delete the general journal
        // for the accounting date and opening fiscal calendar period
        // excluding transactions posted from Opening Sheet
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && selectFund == NoYes::Yes)
        {
            GeneralJournalAccountEntry::deleteFundAcctDatePeriodExclPostType(
                fromFund,
                toFund,
                periodNext,
                openingFiscalCalendarPeriodRecId,
                LedgerPostingType::Opening_ES);
        }
        else
        {
            GeneralJournalAccountEntry::deleteForAcctDatePeriodExclPostType(
                periodNext,
                openingFiscalCalendarPeriodRecId,
                LedgerPostingType::Opening_ES);
        }

        if (isDeleteFlightEnabled)
        {
            ttscommit;
        }

        // Delete existing system generated ultimo records.
        if (!silent)
        {
            progress.setText("@SYS67294");
        }

        FiscalCalendarPeriod fiscalCalendarPeriod;

        if (isDeleteFlightEnabled)
        {
            ttsbegin;
        }

        while select RecId from fiscalCalendarPeriod
            where fiscalCalendarPeriod.FiscalCalendar == calendarRecId
                && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing
                && fiscalCalendarPeriod.StartDate == periodEnd
                && fiscalCalendarPeriod.EndDate == periodEnd
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && selectFund == NoYes::Yes)
            {
                GeneralJournalAccountEntry::deleteForFundAcctDatePeriodPostType(
                    fromFund,
                    toFund,
                    periodEnd,
                    fiscalCalendarPeriod.RecId,
                    LedgerPostingType::TransferOpeningClosing);
            }

            // delete the general journal for the
            // accounting date, closing fiscal calendar period and posting type
            else
            {
                GeneralJournalAccountEntry::deleteForAcctDatePeriodPostType(
                    periodEnd,
                    fiscalCalendarPeriod.RecId,
                    LedgerPostingType::TransferOpeningClosing);
            }
        }

        if (isDeleteFlightEnabled)
        {
            ttscommit;
        }

        // Rebuild the balances to reflect the transactions deleted
        if (!delayDimensionSetRebuild && !isPublicSectorYearEndProcessingEnabled)
        {
            DimensionFocusBalanceRebuildDateContract dimensionFocusBalanceRebuildDateContract = new DimensionFocusBalanceRebuildDateContract();
            dimensionFocusBalanceRebuildDateContract.parmLedgerRecId(Ledger::current());
            this.setDatesInRebuildDateContract(dimensionFocusBalanceRebuildDateContract);

            if (Dynamics.AX.Application.FeatureStateProvider::IsFeatureEnabled(GeneralLedgerBalanceFeature::instance()))
            {
                GeneralLedgerBalanceWork::scheduleRebuildBalancesForLedger(
                    Ledger::current(),
                    dimensionFocusBalanceRebuildDateContract.parmFromDate(),
                    dimensionFocusBalanceRebuildDateContract.parmToDate(),
                    LedgerTransferOpening::description());
            }
            else
            {
                batchHeader = BatchHeader::getCurrentBatchHeader();

                if (batchHeader == null)
                {
                    DimensionFocusInitializeBalance::scheduleProcessFullRebuildWithDateContract(dimensionFocusBalanceRebuildDateContract);
                }
                else
                {
                    dimensionFocusBalanceRebuildDateContract.parmParentBatchHeader(batchHeader);
                    dimensionFocusBalanceRebuildDateContract.parmParentBatchTaskId(this.parmCurrentBatch().RecId);

                    DimensionFocusInitializeBalance::processFullRebuildWithDateContract(dimensionFocusBalanceRebuildDateContract);

                    batchHeader.save();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDatesInRebuildDateContract</Name>
				<Source><![CDATA[
    protected void setDatesInRebuildDateContract(DimensionFocusBalanceRebuildDateContract _contract)
    {
        if (calendarRecId && closingFiscalYearName)
        {
            // Use the fiscal year end date of the current fiscal year, where closing transactions would be created
            FiscalCalendarYear fiscalCalendarYear = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName);
            date nextYearOpeningDate = FiscalCalendars::findNextYearStart(calendarRecId, fiscalCalendarYear.EndDate);

            _contract.parmFromDate(fiscalCalendarYear.EndDate);
            _contract.parmToDate(nextYearOpeningDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an instance of a class that contains the methods that are described by the
    /// <c>RunBaseDialogable</c> interface.
    /// </summary>
    /// <returns>
    /// An instance of a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be built by using the <c>Dialog</c> class or by using a class that is created in
    /// the AOT.
    /// </remarks>
    Object dialog()
    {
        if (!isPublicSectorYearEndProcessingEnabled)
        {
            str formName = formStr(LedgerFiscalCloseHistory);

            Args args = new Args();
            args.name(formName);
            args.caller(this);
        
            formRun formRun = ClassFactory::formRunClassOnClient(args);
            formRun.init();
        
            return formRun;
        }
        else
        {
            dialog = super();
            
            this.buildDialog_PSN(dialog);

            return dialog;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the transaction reversal dialog properties.
    /// </summary>
    /// <param name="_dialog">
    /// The <c>Runbase</c> dialog object.
    /// </param>
    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);

        if (isPublicSectorYearEndProcessingEnabled)
        {
            dialogPeriodEndFrom.registerOverrideMethod(methodstr(FormStringControl, lookup), methodstr(LedgerTransferOpening, periodEndFrom_Lookup), this);
            dialogPeriodEndFrom.registerOverrideMethod(methodstr(FormStringControl, modified), methodstr(LedgerTransferOpening, periodEndFrom_Modified), this);

            dialogFiscalYearName.registerOverrideMethod(methodstr(FormStringControl, lookup), methodstr(LedgerTransferOpening, fiscalYearName_Lookup), this);
            dialogFiscalYearName.registerOverrideMethod(methodstr(FormStringControl, modified), methodstr(LedgerTransferOpening, fiscalYearName_Modified), this);

            dialogCalendarId.registerOverrideMethod(methodstr(FormInt64Control, modified), methodstr(LedgerTransferOpening, calendarId_Modified), this);

            dialogRunPreview.registerOverrideMethod(methodstr(FormCheckBoxControl, modified), methodstr(LedgerTransferOpening, runPreview_Modified), this);

            dialogPeriodEndTo.registerOverrideMethod(methodstr(FormStringControl, lookup), methodstr(LedgerTransferOpening, periodEndTo_Lookup), this);
            dialogPeriodEndTo.registerOverrideMethod(methodstr(FormStringControl, modified), methodstr(LedgerTransferOpening, periodEndTo_Modified), this);

            dialogPeriodEndFromDate.registerOverrideMethod(methodstr(FormDateControl, modified), methodstr(LedgerTransferOpening, periodEndFromDate_Modified), this);
            dialogPeriodEndToDate.registerOverrideMethod(methodstr(FormDateControl, modified), methodstr(LedgerTransferOpening, periodEndToDate_Modified), this);

            dialogPeriodStartFromDate.registerOverrideMethod(methodstr(FormDateControl, modified), methodstr(LedgerTransferOpening, periodStartFromDate_Modified), this);

            dialogPeriodStartFrom.registerOverrideMethod(methodstr(FormStringControl, lookup), methodstr(LedgerTransferOpening, periodStartFrom_Lookup), this);
            dialogPeriodStartFrom.registerOverrideMethod(methodstr(FormStringControl, modified), methodstr(LedgerTransferOpening, periodStartFrom_Modified), this);

            dialogFromFund.registerOverrideMethod(methodstr(FormStringControl, lookup), methodstr(LedgerTransferOpening, fromFund_Lookup), this);
            dialogToFund.registerOverrideMethod(methodstr(FormStringControl, lookup), methodstr(LedgerTransferOpening, toFund_Lookup), this);
            dialogSelectFund.registerOverrideMethod(methodstr(FormCheckBoxControl, modified), methodstr(LedgerTransferOpening, selectFund_Modified), this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionIsMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the supplied dimension segment is a main account.
    /// </summary>
    /// <param name="_dimensionStorageSegment">
    /// An instance of the <c>DimensionStorageSegment</c> class.
    /// </param>
    /// <param name="_dimensionAttributeValue">
    /// An instance of the <c>DimensionAttributeValue</c> class.
    /// </param>
    /// <returns>
    /// true if the supplied dimension segment is a main account; false otherwise.
    /// </returns>
    private boolean dimensionIsMainAccount(
                            DimensionStorageSegment  _dimensionStorageSegment,
                            DimensionAttributeValue _dimensionAttributeValue)
    {
        DimensionAttribute  dimensionAttribute;

        select firstonly DimensionAttribute from _dimensionAttributeValue
            where _dimensionAttributeValue.RecId == _dimensionStorageSegment.parmDimensionAttributeValueId()
        join BackingEntityType from dimensionAttribute
            where dimensionAttribute.RecId == _dimensionAttributeValue.DimensionAttribute;

        return (dimensionAttribute.BackingEntityType == tableNum(MainAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayProgress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the process progress with the specified account number.
    /// </summary>
    /// <param name = "_mainAccountId">
    /// A Main account number.
    /// </param>
    void displayProgress(MainAccountNum _mainAccountId)
    {
        this.progressUpdate(strFmt("@SYS24991", _mainAccountId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayProgressForPublicSector</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the progress for Public Sector.
    /// </summary>
    /// <param name="_dimensionDisplayValue">
    /// The account number to be displayed on the progress bar.
    /// </param>
    void displayProgressForPublicSector(DimensionDisplayValue _dimensionDisplayValue)
    {
        this.progressUpdate(strFmt("@SYS24991", _dimensionDisplayValue));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fiscalYearName_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>dialogFiscalYearName</c> lookup based on <c>CalendarRecId</c> value.
    /// </summary>
    /// <param name="_formStringControl">
    /// The control that is bound to the <c>dialogFiscalYearName</c> field.
    /// </param>
    private void fiscalYearName_Lookup(FormStringControl _formStringControl)
    {
        SysTableLookup          fiscalYearLookup;
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildRange         queryBuildFiscalCalendar;

        fiscalYearLookup = SysTableLookup::newParameters(tableNum(FiscalCalendarYear), _formStringControl);

        // Add the fields to be shown in the lookup form
        fiscalYearLookup.addLookupfield(fieldNum(FiscalCalendarYear, Name));
        fiscalYearLookup.addLookupfield(fieldNum(FiscalCalendarYear, StartDate));
        fiscalYearLookup.addLookupfield(fieldNum(FiscalCalendarYear, EndDate));

        // Create the query datasource
        queryBuildDataSource = query.addDataSource(tableNum(FiscalCalendarYear));

        // Restrict to fiscal years for the selected fiscal calendar.
        queryBuildFiscalCalendar = queryBuildDataSource.addRange(fieldNum(FiscalCalendarYear, FiscalCalendar));
        queryBuildFiscalCalendar.value(int642str(calendarRecId));

        // Add the query to the lookup form
        fiscalYearLookup.parmQuery(query);

        // Perform lookup
        fiscalYearLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fiscalYearName_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the <c>fiscalCalendarYearNameRecId</c> field when <c>dialogFiscalYearName</c>
    /// field is modified.
    /// </summary>
    /// <param name="_formStringControl">
    /// The control that is bound to the <c>dialogFiscalYearName</c> field.
    /// </param>
    /// <returns>
    /// true if the <c>dialogFiscalYearName</c> field can be edited; otherwise, false .
    /// </returns>
    private boolean fiscalYearName_Modified(FormStringControl _formStringControl)
    {
        boolean valueWasModified;

        valueWasModified = _formStringControl.modified();

        if (valueWasModified)
        {
            // Cache often used data for improved performance.
            fiscalCalendarYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, dialogFiscalYearName.value()).RecId;
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromFund_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the filtered Fund Number lookup.
    /// </summary>
    /// <param name="_formStringControl">
    /// The control that is bound to the <c>dialogFromFund</c> field.
    /// </param>
    private void fromFund_Lookup(FormStringControl _formStringControl)
    {
        this.performFundLookup(_formStringControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClosingBalancePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>FiscalCalendarPeriod</c> record that is selected for determining the balance of
    /// the closing transactions.
    /// </summary>
    /// <returns>
    /// The <c>FiscalCalendarPeriod</c> record that is selected for determining the balance of the closing
    /// transactions.
    /// </returns>
    protected FiscalCalendarPeriod getClosingBalancePeriod()
    {
        RecId closingFiscalYearNameRecId;

        if (closingBalanceFiscalCalendarPeriod
            && closingBalanceFiscalCalendarPeriod.FiscalCalendarYear == closingFiscalYearNameRecId
            && closingBalanceFiscalCalendarPeriod.Name == balanceFromPeriod
            && closingBalanceFiscalCalendarPeriod.EndDate == closeDateFromPeriod)
        {
            return closingBalanceFiscalCalendarPeriod;
        }

        closingFiscalYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName).RecId;

        select closingBalanceFiscalCalendarPeriod
            where closingBalanceFiscalCalendarPeriod.FiscalCalendarYear == closingFiscalYearNameRecId
                && closingBalanceFiscalCalendarPeriod.Name == balanceFromPeriod
                && closingBalanceFiscalCalendarPeriod.EndDate == closeDateFromPeriod;

        return closingBalanceFiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClosingPostToPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>FiscalCalendarPeriod</c> record that is selected for posting closing transactions.
    /// </summary>
    /// <returns>
    /// The <c>FiscalCalendarPeriod</c> record selected for posting closing transactions.
    /// </returns>
    protected FiscalCalendarPeriod getClosingPostToPeriod()
    {
        RecId closingFiscalYearNameRecId;

        if (closingPostToFiscalCalendarPeriod
            && closingPostToFiscalCalendarPeriod.FiscalCalendarYear == closingFiscalYearNameRecId
            && closingPostToFiscalCalendarPeriod.Name == balanceToPeriod
            && closingPostToFiscalCalendarPeriod.EndDate == periodEnd)
        {
            return closingPostToFiscalCalendarPeriod;
        }

        closingFiscalYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName).RecId;

        select closingPostToFiscalCalendarPeriod
            where closingPostToFiscalCalendarPeriod.FiscalCalendarYear == closingFiscalYearNameRecId
                && closingPostToFiscalCalendarPeriod.Name == balanceToPeriod
                && closingPostToFiscalCalendarPeriod.EndDate == periodEnd;

        return closingPostToFiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionHierarchyFromDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension hierarchy that supports the value of the <c>_dimStorageSegments</c> parameter.
    /// </summary>
    /// <param name="_dimStorageSegments">
    /// The dimension segments that are used to find a dimension hierarchy.
    /// </param>
    /// <param name="_defaultDimensionHierarchy">
    /// The hierarchy to return if it maps to the value of the <c>_dimStorageSegments</c> parameter.
    /// </param>
    /// <returns>
    /// The ID of the dimension hierarchy.
    /// </returns>
    protected RefRecId getDimensionHierarchyFromDimensions(Map _dimStorageSegments, RefRecId _defaultDimensionHierarchy = 0)
    {
        DimensionHierarchy          dimHierarchy;
        RefRecId                    dimAttrId;
        RefRecId                    hierarchRefRecId;
        MapEnumerator               dimensionsEnumerator;
        Query                       query;
        QueryBuildDataSource        queryBuildDataSource;
        QueryBuildDataSource        dimensionAttributeQueryBuildDataSource;
        QueryRun                    queryRun;
        QueryBuildRange             range;
        int                         dataSourceId;
        DimensionHierarchy          firstdimensionHierarchy;

        query = new Query();

        if (_dimStorageSegments)
        {
            dimensionsEnumerator = _dimStorageSegments.getEnumerator();
            queryBuildDataSource = query.addDataSource(tableNum(DimensionHierarchyLevel));
            queryBuildDataSource.addSelectionField(fieldNum(DimensionHierarchyLevel, DimensionHierarchy));
            queryBuildDataSource.addSelectionField(fieldNum(DimensionHierarchyLevel, DimensionAttribute));
            queryBuildDataSource.addGroupByField(fieldNum(DimensionHierarchyLevel, DimensionHierarchy));
            queryBuildDataSource.addGroupByField(fieldNum(DimensionHierarchyLevel, DimensionAttribute));

            queryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(DimensionHierarchy));
            queryBuildDataSource.addSelectionField(fieldNum(DimensionHierarchy, RecId));
            queryBuildDataSource.addGroupByField(fieldNum(DimensionHierarchy, RecId));
            queryBuildDataSource.addLink(fieldNum(DimensionHierarchyLevel, DimensionHierarchy), fieldNum(DimensionHierarchy, RecId));
            queryBuildDataSource.fetchMode(QueryFetchMode::One2One);
            queryBuildDataSource.joinMode(JoinMode::InnerJoin);
            range = queryBuildDataSource.addRange(fieldNum(DimensionHierarchy, IsDraft));
            range.value(SysQuery::value(NoYes::No));
            range = queryBuildDataSource.addRange(fieldNum(DimensionHierarchy, DeletedVersion));
            range.value(SysQuery::value(0));
            range = queryBuildDataSource.addRange(fieldNum(DimensionHierarchy, StructureType));
            range.value(SysQuery::value(DimensionHierarchyType::AccountStructure));
            queryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(DimensionHierarchyLevel));
            queryBuildDataSource.addLink(fieldNum(DimensionHierarchy, RecId), fieldNum(DimensionHierarchyLevel, DimensionHierarchy));
            queryBuildDataSource.fetchMode(QueryFetchMode::One2One);
            queryBuildDataSource.joinMode(JoinMode::InnerJoin);
            queryBuildDataSource.addSelectionField(fieldNum(DimensionHierarchyLevel, Level), SelectionField::Max);
            queryBuildDataSource.addSortField(fieldNum(DimensionHierarchyLevel, Level), SortOrder::Descending);
            dataSourceId = queryBuildDataSource.id();

            queryBuildDataSource = query.dataSourceTable(tableNum(DimensionHierarchyLevel));
            while (dimensionsEnumerator.moveNext())
            {
                dimAttrId = dimensionsEnumerator.currentKey();
                dimensionAttributeQueryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(DimensionHierarchyLevel));
                dimensionAttributeQueryBuildDataSource.addLink(fieldNum(DimensionHierarchyLevel, DimensionHierarchy), fieldNum(DimensionHierarchyLevel, DimensionHierarchy));
                range = dimensionAttributeQueryBuildDataSource.addRange(fieldNum(DimensionHierarchyLevel, DimensionAttribute));
                range.value(SysQuery::value(dimAttrId));
                dimensionAttributeQueryBuildDataSource.fetchMode(QueryFetchMode::One2One);
                dimensionAttributeQueryBuildDataSource.joinMode(JoinMode::ExistsJoin);
            }

            dimensionAttributeQueryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(DimensionHierarchyLevel));
            dimensionAttributeQueryBuildDataSource.addLink(fieldNum(DimensionHierarchyLevel, DimensionHierarchy), fieldNum(DimensionHierarchyLevel, DimensionHierarchy));
            range = dimensionAttributeQueryBuildDataSource.addRange(fieldNum(DimensionHierarchyLevel, DimensionAttribute));
            range.value(SysQuery::value(mainAccountDimAttr.RecId));
            dimensionAttributeQueryBuildDataSource.fetchMode(QueryFetchMode::One2One);
            dimensionAttributeQueryBuildDataSource.joinMode(JoinMode::ExistsJoin);

            queryRun = new QueryRun(query);
            if (queryRun.next())
            {
                firstdimensionHierarchy.data(queryRun.get(tableNum(DimensionHierarchy)));
                if (firstdimensionHierarchy.RecId == _defaultDimensionHierarchy)
                {
                    hierarchRefRecId = _defaultDimensionHierarchy;
                }
                else
                {
                    while (queryRun.next() && !hierarchRefRecId)
                    {
                        dimHierarchy.data(queryRun.get(tableNum(DimensionHierarchy)));
                        if (dimHierarchy.RecId == _defaultDimensionHierarchy)
                        {
                            hierarchRefRecId = _defaultDimensionHierarchy;
                        }
                    }
                }
            }

            if (!hierarchRefRecId)
            {
                hierarchRefRecId = firstdimensionHierarchy.RecId;
            }
        }

        if (!hierarchRefRecId)
        {
            hierarchRefRecId = DimensionHierarchy::getRelationalAccountStructureId();
        }

        return hierarchRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionHierarchyFromLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the dimension hierarchy that is associated to a ledger dimension.
    /// </summary>
    /// <param name="_ledgerDimensionAccount">
    /// The ledger dimension that is used to retrieve the hierarchy.
    /// </param>
    /// <returns>
    /// The ID of the ledger dimension.
    /// </returns>
    protected RefRecId getDimensionHierarchyFromLedgerDimension(LedgerDimensionAccount _ledgerDimensionAccount)
    {
        DimensionAttributeValueGroupCombination dimensionGroupCombination;
        DimensionAttributeValueGroup dimensionGroup;

        select firstonly RecId from dimensionGroupCombination
            where dimensionGroupCombination.DimensionAttributeValueCombination == _ledgerDimensionAccount
            join DimensionHierarchy from dimensionGroup
                where dimensionGroup.RecId == dimensionGroupCombination.DimensionAttributeValueGroup;

        return dimensionGroup.DimensionHierarchy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        methodStatus = dialogMethodStatus.value();

        if (isPublicSectorYearEndProcessingEnabled)
        {
            periodEnd = dialogPeriodEndToDate.value();
            transferResult = dialogTransferResult.value();
            runPreview = dialogRunPreview.value();
            runReport = dialogRunReport.value();
            voucher = dialogVoucher.value();
            periodName = dialogPeriodName.value();
            runReport = dialogRunReport.value();
            voucher = dialogVoucher.value();
            closingFiscalYearName = dialogFiscalYearName.value();
            balanceFromPeriod = dialogPeriodEndFrom.value();
            balanceToPeriod = dialogPeriodEndTo.value();
            closeDateFromPeriod = dialogPeriodEndFromDate.value();
            balanceOpenFromPeriod = dialogPeriodStartFrom.value();
            openDateFromPeriod = dialogPeriodStartFromDate.value();
            selectFund = dialogSelectFund.value();
            fromFund = dialogFromFund.value();
            toFund = dialogToFund.value();
        }
        else
        {
            periodEnd = dialogPeriodEnd.value();
            transferResult = dialogTransferResult.value();
            runReport = dialogRunReport.value();

            // <GCN>
            if (LedgerParameters::isChineseVoucher_CN())
            {
                voucher_CN                = dialogVoucher_CN.value();
                voucherTypeId_CN          = dialogVoucherTypeId_CN.value();
                voucher                   = voucher_CN;

                if (voucherTypeId_CN)
                {
                    ledgerVoucherTypeRecId_CN = LedgerVoucherType_CN::findByNaturalKey(voucherTypeId_CN).RecId;
                }
            }
            else
            {
                // </GCN>
                voucher                      = dialogVoucher.value();
                // <GCN>
            }
            // </GCN>

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                useTransferYearEndAccount_ES = dialogUseTransferYearEndAccount_ES.value();
            }
            else
            {
                useTransferYearEndAccount_ES = false;
            }

            transferDimensions = dialogTransferDimensions.value();
            periodName = dialogPeriodName.value();

            if (profitLossDimensionEntryControl)
            {
                // Only save if the control is instantiated; otherwise assume the values are already provided
                profitLossDefaultDimensions = profitLossDimensionEntryControl.saveAttributeValueSet();
                profitLossCloseDimensionEnumeration = profitLossDimensionEntryControl.saveAttributeSet();
            }
        }

        if (LedgerParameters::find().AcknowledgementDate_IT)
        {
            acknowledgementDate = dialogAcknowledgementDate.value();
        }
        else
        {
            acknowledgementDate = dateNull();
        }

        // <GEERU>
        if (dialogMethodOperations != null)
        {
            methodOperations = dialogMethodOperations.value();
        }
        // </GEERU>

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFundFromAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the fund dimension value from the ledger account.
    /// </summary>
    /// <param name="_ledgerDimensionAccount">
    /// The account from which to retrieve the fund dimension value.
    /// </param>
    /// <returns>
    /// A fund table buffer.
    /// </returns>
    protected LedgerFund getFundFromAccount(LedgerDimensionAccount _ledgerDimensionAccount)
    {
        DimensionAttributeLevelValueView dimensionAttributeLevelValueView;
        DimensionAttribute dimensionAttribute;
        LedgerFund ledgerFund;

        select firstonly RecId from dimensionAttributeLevelValueView where
            dimensionAttributeLevelValueView.ValueCombinationRecId == _ledgerDimensionAccount
            join RecId from dimensionAttribute where
                (dimensionAttribute.BackingEntityType == tableNum(DimAttributeLedgerFund_PSN)
                    && dimensionAttribute.RecId == dimensionAttributeLevelValueView.DimensionAttribute)
            join ledgerFund where
                ledgerFund.FundNumber == dimensionAttributeLevelValueView.DisplayValue;

        return ledgerFund;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a ledger dimension that represents the specified values.
    /// </summary>
    /// <param name="_mainAccountSegment">
    /// The <c>DimensionStorageSegment</c> object that specifies the main account.
    /// </param>
    /// <param name="_dimensionSpecifiers1">
    /// A map that represents the dimension specifiers that are applied first.
    /// </param>
    /// <param name="_dimensionSpecifiers2">
    /// A map represents the dimension specifiers that are applied second.
    /// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    protected LedgerDimensionAccount getLedgerDimension(DimensionStorageSegment _mainAccountSegment, Map _dimensionSpecifiers1, Map _dimensionSpecifiers2 = null)
    {
        #DimensionSpecifier
        #define.StorageField('Storage')
        #define.DimensionAttributesField('DimensionAttributes')

        DimensionStorage                dimStorage;
        ListEnumerator                  dimAttrIdEnumerator;
        MapEnumerator                   specifiersEnumerator;
        DimensionStorageSegment         dimStorageSegment;
        DimensionHierarchy              dimHierarchy;
        LedgerStructure                 ledgerStructure;
        Map                             dimensionSpecifiers;
        Set                             dimensionsInCombination;    // The list of dimension attributes in the account structure and normal rules.
        Set                             remainingDimensions;        // The list of dimension attributes in the original specifiers that were not included in the initial combination formed via the account structure and normal rules.
        Struct                          storageValues;
        container                       dimensionAttributes;
        container                       dimensionSpecifier;
        RecId                           accountStructureId;
        RecId                           dimAttrId;
        RecId                           ruleHierarchyId;
        int                             ruleSegmentIndex;
        int                             segmentCount;
        int                             i;
        LedgerRecId                     ledgerId = Ledger::current();

        // Get account structure
        accountStructureId = DimensionHierarchy::getAccountStructure(MainAccount::findByMainAccountId(_mainAccountSegment.parmDisplayValue()).RecId);
        if (!accountStructureId)
        {
            // Use the account structure if there is only one
            while select RecId from dimHierarchy
                where dimHierarchy.StructureType == DimensionHierarchyType::AccountStructure &&
                    dimHierarchy.IsDraft == false &&
                    dimHierarchy.DeletedVersion == 0 &&
                    dimHierarchy.IsSystemGenerated == false
                exists join ledgerStructure
                    where ledgerStructure.DimensionHierarchy == dimHierarchy.RecId &&
                        ledgerStructure.Ledger == ledgerId
            {
                if (accountStructureId)
                {
                    // Multiple account structure exist: use fallback account structure
                    accountStructureId = 0;
                    break;
                }

                accountStructureId = dimHierarchy.RecId;
            }
        }

        // Get dimensionSpecifiers
        if (_dimensionSpecifiers2 == null)
        {
            // Clone first specifiers because it needs to be modified locally
            dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
            specifiersEnumerator = _dimensionSpecifiers1.getEnumerator();
            while (specifiersEnumerator.moveNext())
            {
                dimensionSpecifiers.insert(specifiersEnumerator.currentKey(), specifiersEnumerator.currentValue());
            }
        }
        else
        {
            dimensionSpecifiers = LedgerDimensionDefaultingEngine::addDimensionSpecifiers(_dimensionSpecifiers1, _dimensionSpecifiers2);
        }

        // Add main account to specifiers
        LedgerDimensionDefaultingEngine::insertDimensionSpecifer(
            dimensionSpecifiers,
            DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount),
            _mainAccountSegment.parmDisplayValue(),
            _mainAccountSegment.parmDimensionAttributeValueId(),
            _mainAccountSegment.parmHashKey(),
            _mainAccountSegment.parmEntityInstance());

        // Get dimStorage
        if (accountStructureId)
        {
            // Build combination (using existing rules)
            storageValues = LedgerDimensionDefaultingEngine::getStorageFromDimensionSpecifiers(accountStructureId, dimensionSpecifiers);
            dimStorage = storageValues.value(#StorageField);
            dimensionAttributes = storageValues.value(#DimensionAttributesField);

            // Get dimensionsInCombination
            segmentCount = conLen(dimensionAttributes);
            dimensionsInCombination = new Set(Types::Int64);
            for (i = 1; i <= segmentCount; i++)
            {
                dimensionsInCombination.add(conPeek(dimensionAttributes, i));
            }

            // Get remainingDimensions
            remainingDimensions = new Set(Types::Int64);
            specifiersEnumerator = dimensionSpecifiers.getEnumerator();
            while (specifiersEnumerator.moveNext())
            {
                dimAttrId = specifiersEnumerator.current();
                if (!dimensionsInCombination.in(dimAttrId))
                {
                    remainingDimensions.add(dimAttrId);
                }
            }

            // Add remaining dimensions to storage
            if (!remainingDimensions.empty())
            {
                ruleSegmentIndex = dimStorage.segmentCount() + 1;
                dimAttrIdEnumerator = dimAttrRecIds.getEnumerator();
                while (dimAttrIdEnumerator.moveNext())
                {
                    dimAttrId = dimAttrIdEnumerator.current();
                    if (remainingDimensions.in(dimAttrId))
                    {
                        ruleHierarchyId = dimAttrIdToSingleAttrHierarchyId.lookup(dimAttrId);
                        dimStorage.addHierarchy(ruleHierarchyId, 1);

                        dimensionSpecifier = dimensionSpecifiers.lookup(dimAttrId);
                        dimStorageSegment = DimensionStorageSegment::construct(
                                conPeek(dimensionSpecifier, #DimensionSpecifier_DisplayValue),
                                conPeek(dimensionSpecifier, #DimensionSpecifier_DimensionAttributeValueId),
                                conPeek(dimensionSpecifier, #DimensionSpecifier_DimensionAttributeValueHashKey));

                        dimStorage.setSegment(ruleSegmentIndex, dimStorageSegment);
                        ruleSegmentIndex++;
                    }
                }
            }
        }
        else
        {
            // Build fallback combination
            dimStorage = DimensionStorage::construct(0);
            dimStorage.addAccountStructure(fallbackAccountStructureId, 1);
            dimStorage.setSegment(1, _mainAccountSegment);

            ruleSegmentIndex = 2;
            dimAttrIdEnumerator = dimAttrRecIds.getEnumerator();
            while (dimAttrIdEnumerator.moveNext())
            {
                dimAttrId = dimAttrIdEnumerator.current();
                if (dimensionSpecifiers.exists(dimAttrId))
                {
                    ruleHierarchyId = dimAttrIdToSingleAttrHierarchyId.lookup(dimAttrId);
                    dimStorage.addHierarchy(ruleHierarchyId, 1);

                    dimensionSpecifier = dimensionSpecifiers.lookup(dimAttrId);
                    dimStorageSegment = DimensionStorageSegment::construct(
                            conPeek(dimensionSpecifier, #DimensionSpecifier_DisplayValue),
                            conPeek(dimensionSpecifier, #DimensionSpecifier_DimensionAttributeValueId),
                            conPeek(dimensionSpecifier, #DimensionSpecifier_DimensionAttributeValueHashKey));

                    dimStorage.setSegment(ruleSegmentIndex, dimStorageSegment);
                    ruleSegmentIndex++;
                }
            }
        }

        return dimStorage.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForMainAcount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves or creates a new ledger dimension based on a main account and dimension segments.
    /// </summary>
    /// <param name="_mainAccountSegment">
    /// The main account segment of the new ledger dimension.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The <c>_ledgerDimension</c> parameter contains the dimensions of the new ledger dimension.
    /// </param>
    /// <param name="_accountStructureId">
    /// The account structure to use for the new ledger dimension.
    /// </param>
    /// <returns>
    /// The ID of the ledger dimension.
    /// </returns>
    private LedgerDimensionAccount getLedgerDimensionForMainAcount(
                                        DimensionStorageSegment _mainAccountSegment,
                                        LedgerDimensionAccount _ledgerDimension
                                        , RefRecId _accountStructureId = 0
                                        )
    {
        Map     dimensionSpecifiers = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerDimension, true);
       
        return this.getLedgerDimension(_mainAccountSegment, dimensionSpecifiers);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForType</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getLedgerDimensionForType(
            LedgerTransferOpeningType   _transactionType,
            RecId                       _dimensionAttributeSet,
            DimensionStorageSegment     _mainAccountStorageSegment,
            Map                         _dimensionSpecifiers,
            Map                         _profitLossSelectedDimensionSpecifiers)
    {
        if (_transactionType == LedgerTransferOpeningType::ProfitLoss)
        {
            if (_dimensionAttributeSet)
            {
                return this.getLedgerDimension(_mainAccountStorageSegment, _dimensionSpecifiers, _profitLossSelectedDimensionSpecifiers);
            }
            else
            {
                return this.getLedgerDimension(_mainAccountStorageSegment, _profitLossSelectedDimensionSpecifiers);
            }
        }
        else if (_transactionType == LedgerTransferOpeningType::BalanceSheet)
        {
            return this.getLedgerDimension(_mainAccountStorageSegment, _dimensionSpecifiers);
        }
        else
        {
            // use wrongUseOfFunction because this is a development error
            throw error(Error::wrongUseOfFunction(funcname()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccountStorageSegment</Name>
				<Source><![CDATA[
    protected DimensionStorageSegment getMainAccountStorageSegment(MainAccountNum _mainAccountId, boolean _createIfNecessary = false)
    {
        DimensionAttributeValue     dimAttrValue;

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU]))
        {
            dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndValue(mainAccountDimAttr, _mainAccountId, false, _createIfNecessary);
        }
        else
        {
            // </GEEU>
            dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndValue(mainAccountDimAttr, _mainAccountId);
            // <GEEU>
        }
        // </GEEU>

        return DimensionStorageSegment::constructFromValue(_mainAccountId, dimAttrValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the offset account for the transaction from journalizing definitions.
    /// </summary>
    /// <param name="_fundClassValueAll">
    /// The fund class for the account for which we are retrieving the offset account.
    /// </param>
    /// <param name="_openCloseTransType">
    /// The type of process, opening or closing, that called the method.
    /// </param>
    /// <param name="_ledgerDimensionAccount">
    /// The compound account number that is being processed.
    /// </param>
    /// <param name="_journalizingDefinitionDebitCredit">
    /// The debit or credit value of the originating transaction.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date of the originating transaction.
    /// </param>
    /// <returns>
    /// The offset account for the transaction.
    /// </returns>
    protected LedgerDimensionAccount getOffsetAccount(
        FundClassValueAll _fundClassValueAll,
        LedgerOpenCloseTransType _openCloseTransType,
        LedgerDimensionAccount _ledgerDimensionAccount,
        JournalizingDefinitionDebitCredit _journalizingDefinitionDebitCredit,
        TransDate _transDate)
    {
        JournalizingDefinitionManagerLedger journalizingDefinitionManagerLedger;
        LedgerPostingType                   ledgerPostingType;
        JournalizingDefinitionId            journalizingDefinitionId;
        List                                journalizingDefinitionEntriesList;
        JournalizingDefinitionEntry         journalizingDefinitionEntry;
        ListEnumerator                      journalizingDefinitionEntriesListEnumerator;
        LedgerDimensionAccount              offsetAccount;
        DimensionStorageSegment             dimensionStorageSegment;
        MainAccount                         mainAccount;
        Map                                 dimensionSpecifiers;

        if (_openCloseTransType == LedgerOpenCloseTransType::Close)
        {
            ledgerPostingType = LedgerPostingType::Closing;
        }
        else
        {
            ledgerPostingType = LedgerPostingType::None;
        }

        journalizingDefinitionManagerLedger = JournalizingDefinitionManager::newJournalizingDefinitionManagerLedger(_fundClassValueAll, _openCloseTransType, ledgerPostingType);
        journalizingDefinitionId = journalizingDefinitionManagerLedger.getDefaultJournalizingDefinition();

        if (!journalizingDefinitionId)
        {
            return checkFailed("@SPS475");  // journalizing definitions are not setup correctly, display  warning
        }

        journalizingDefinitionManagerLedger.parmTransDate(_transDate);
        journalizingDefinitionEntriesList = journalizingDefinitionManagerLedger.getSystemGeneratedEntries(_journalizingDefinitionDebitCredit, _ledgerDimensionAccount);
        journalizingDefinitionEntriesListEnumerator = journalizingDefinitionEntriesList.getEnumerator();

        //  we only support a single entry (offset account) on the posting definition
        if (journalizingDefinitionEntriesListEnumerator.moveNext())
        {
            journalizingDefinitionEntry = journalizingDefinitionEntriesListEnumerator.current();

            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(journalizingDefinitionEntry.parmLedgerDimension());
            dimensionStorageSegment = this.getMainAccountStorageSegment(mainAccount.MainAccountId);

            dimensionSpecifiers = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(journalizingDefinitionEntry.parmLedgerDimension(), true);
            offsetAccount = this.getLedgerDimension(dimensionStorageSegment, dimensionSpecifiers);
        }

        return offsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpeningBalancePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>FiscalCalendarPeriod</c> record selected for determining the balance of the
    /// opening transactions.
    /// </summary>
    /// <returns>
    /// the <c>FiscalCalendarPeriod</c> record selected for determining the balance of the opening
    /// transactions.
    /// </returns>
    protected FiscalCalendarPeriod getOpeningBalancePeriod()
    {
        RecId openingFiscalYearNameRecId;

        if (openingBalanceFiscalCalendarPeriod
            && openingBalanceFiscalCalendarPeriod.FiscalCalendarYear == openingFiscalYearNameRecId
            && openingBalanceFiscalCalendarPeriod.Name == balanceOpenFromPeriod
            && openingBalanceFiscalCalendarPeriod.EndDate == openDateFromPeriod)
        {
            return openingBalanceFiscalCalendarPeriod;
        }

        openingFiscalYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName).RecId;

        select openingBalanceFiscalCalendarPeriod
            where openingBalanceFiscalCalendarPeriod.FiscalCalendarYear == openingFiscalYearNameRecId
                && openingBalanceFiscalCalendarPeriod.Name == balanceOpenFromPeriod
                && openingBalanceFiscalCalendarPeriod.EndDate == openDateFromPeriod;

        return openingBalanceFiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessTimestamp</Name>
				<Source><![CDATA[
    public UTCTimestamp getProcessTimestamp()
    {
        return processTimestamp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the session number of the current process.
    /// </summary>
    /// <returns>
    /// The session number of the current process.
    /// </returns>
    public int getSession()
    {
        return processSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal variables.
    /// </summary>
    /// <remarks>
    /// This method is called when no <c>SysLastValue</c> record can be found when it calls the
    /// <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        if (isPublicSectorYearEndProcessingEnabled)
        {
            methodStatus   = OpeningMethod::ClosingToOpening;
            transferResult = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::YearResult));
        }
        else
        {
            if (!calendarRecId)
            {
                checkFailed("@SYS128634");
            }

            methodStatus   = OpeningMethod::ClosingToOpening;
            transferResult = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::YearResult));

            // Default to transfer balance sheet transaction dimensions
            transferDimensions = NoYes::Yes;

            // Set all Close All checkboxes to checked for profit + loss
            profitLossCloseDimensionEnumeration = allDimAttributes;

            // Override the ledger based dimensions with all dimensions
            profitLossDisplayedDimensions = allDimAttributes;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the primary query.
    /// </summary>
    /// <param name="_transactionType">
    /// The transaction type.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object.
    /// </returns>
    protected Query initQuery(LedgerTransferOpeningType _transactionType)
    {
        Query                               query;
        QueryBuildRange                     range;
        QueryBuildDataSource                qbdsGeneralJournalAccountEntry;
        QueryBuildDataSource                qbdsAccountEntryDimension;
        recId                               dimensionAttributeSet;

        // Get selected dimensions
        if (_transactionType == LedgerTransferOpeningType::ProfitLoss)
        {
            dimensionAttributeSet = profitLossCloseAllDimensionAttributeSet;
        }
        else if (_transactionType == LedgerTransferOpeningType::BalanceSheet)
        {
            dimensionAttributeSet = balanceSheetDimensionAttributeSet;
        }
        else
        {
            // use wrongUseOfFunction because this is a development error
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        query = new Query();

        qbdsGeneralJournalAccountEntry = query.addDataSource(tableNum(GeneralJournalAccountEntry));
        qbdsGeneralJournalAccountEntry.orderMode(OrderMode::GroupBy);

        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, AccountingCurrencyAmount), SelectionField::Sum);
        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyAmount), SelectionField::Sum);
        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, ReportingCurrencyAmount), SelectionField::Sum);
        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, Quantity), SelectionField::Sum);

        qbdsAccountEntryDimension = qbdsGeneralJournalAccountEntry.addDataSource(tableNum(GeneralJournalAccountEntryDimension), 'GeneralJournalAccountEntryDimension');
        qbdsAccountEntryDimension.addLink(fieldNum(GeneralJournalAccountEntry, RecId), fieldNum(GeneralJournalAccountEntryDimension, GeneralJournalAccountEntry), 'GeneralJournalAccountEntry_1');
        qbdsAccountEntryDimension.fetchMode(QueryFetchMode::One2One);
        qbdsAccountEntryDimension.joinMode(JoinMode::InnerJoin);

        if (startRecId != int64Min() || endRecId != int64Max())
        {
            range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, GeneralJournalAccountEntryHash));
            range.value(SysQuery::range(startRecId, endRecId));
        }

        range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, Type));
        range.value(SysQuery::value(enum2int(ledgerTransferOpeningType)));

        range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, CurrentSessionId));
        range.value(SysQuery::value(processSession));

        range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, UTCTimestamp));
        range.value(SysQuery::value(processTimestamp));

        qbdsAccountEntryDimension.addGroupByField(fieldNum(GeneralJournalAccountEntryDimension, MainAccount));
        qbdsAccountEntryDimension.addGroupByField(fieldNum(GeneralJournalAccountEntryDimension, PostingLayer));
        qbdsGeneralJournalAccountEntry.addGroupByField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        qbdsAccountEntryDimension.addGroupByField(fieldNum(GeneralJournalAccountEntryDimension, GeneralJournalAccountEntryHash));

        qbdsAccountEntryDimension.addSortField(fieldNum(GeneralJournalAccountEntryDimension, MainAccount));

        if (isAdvancedAwarenessOptsParmEnabled)
        {
            this.excludeBalanceSheetAccountFromSummary(query, _transactionType);
            this.excludeSettledTransactionsFromBalanceSheet(query, _transactionType);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeBalanceSheetAccountFromSummary</Name>
				<Source><![CDATA[
    private Query excludeBalanceSheetAccountFromSummary(Query _query, LedgerTransferOpeningType _transactionType)
    {
        QueryBuildDataSource gjae = _query.dataSourceTable(tableNum(GeneralJournalAccountEntry));

        if (!gjae || _transactionType != LedgerTransferOpeningType::BalanceSheet)
        {
            return _query;
        }

        QueryBuildDataSource ltsa = gjae.addDataSource(tableNum(LedgerTransSettlementAccount));
        ltsa.addLink(fieldNum(GeneralJournalAccountEntry, MainAccount), fieldNum(LedgerTransSettlementAccount, MainAccount));
        ltsa.addRange(fieldNum(LedgerTransSettlementAccount, KeepDetails)).value(SysQuery::value(NoYes::Yes));
        ltsa.fetchMode(QueryFetchMode::One2One);
        ltsa.joinMode(JoinMode::NoExistsJoin);

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeSettledTransactionsFromBalanceSheet</Name>
				<Source><![CDATA[
    private Query excludeSettledTransactionsFromBalanceSheet(Query _query, LedgerTransferOpeningType _transactionType)
    {
        QueryBuildDataSource gjae = _query.dataSourceTable(tableNum(GeneralJournalAccountEntry));

        if (gjae && _transactionType == LedgerTransferOpeningType::BalanceSheet)
        {
            QueryBuildDataSource lts = gjae.addDataSource(tableNum(LedgerTransSettlement));
            lts.addLink(fieldNum(GeneralJournalAccountEntry, RecId), fieldNum(LedgerTransSettlement, TransRecId));
            lts.fetchMode(QueryFetchMode::One2One);
            lts.joinMode(JoinMode::NoExistsJoin);
        }

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryForPublicSector</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the primary query for public sector.
    /// </summary>
    /// <param name="_accountCloseType">
    /// The account closing type; optional.
    /// </param>
    /// <param name="_ledgerTransferOpeningType">
    /// The ledger transfer opening type; optional.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object.
    /// </returns>
    protected Query initQueryForPublicSector(
        AccountCloseType _accountCloseType = AccountCloseType::NotApplicable,
        LedgerTransferOpeningType _ledgerTransferOpeningType = LedgerTransferOpeningType::None)
    {
        Query                               query;
        QueryBuildDataSource                qbdsGeneralJournalAccountEntry;
        QueryBuildDataSource                qbdsAccountEntryDimension;
        QueryBuildRange                     range;

        query = new Query();

        qbdsGeneralJournalAccountEntry = query.addDataSource(tableNum(GeneralJournalAccountEntry));
        qbdsGeneralJournalAccountEntry.orderMode(OrderMode::GroupBy);

        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, AccountingCurrencyAmount), SelectionField::Sum);
        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyAmount), SelectionField::Sum);
        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, ReportingCurrencyAmount), SelectionField::Sum);
        qbdsGeneralJournalAccountEntry.addSelectionField(fieldNum(GeneralJournalAccountEntry, Quantity), SelectionField::Sum);

        qbdsAccountEntryDimension = qbdsGeneralJournalAccountEntry.addDataSource(tableNum(GeneralJournalAccountEntryDimension), 'GeneralJournalAccountEntryDimension');
        qbdsAccountEntryDimension.addLink(fieldNum(GeneralJournalAccountEntry, RecId), fieldNum(GeneralJournalAccountEntryDimension, GeneralJournalAccountEntry), 'GeneralJournalAccountEntry_1');
        qbdsAccountEntryDimension.fetchMode(QueryFetchMode::One2One);
        qbdsAccountEntryDimension.joinMode(JoinMode::InnerJoin);

        if (startRecId != int64Min() || endRecId != int64Max())
        {
            range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, GeneralJournalAccountEntryHash));
            range.value(SysQuery::range(startRecId, endRecId));
        }

        range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, Type));
        range.value(SysQuery::value(enum2int(_ledgerTransferOpeningType)));

        range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, CurrentSessionId));
        range.value(SysQuery::value(processSession));

        range = SysQuery::findOrCreateRange(qbdsAccountEntryDimension, fieldNum(GeneralJournalAccountEntryDimension, UTCTimestamp));
        range.value(SysQuery::value(processTimestamp));

        qbdsAccountEntryDimension.addGroupByField(fieldNum(GeneralJournalAccountEntryDimension, MainAccount));
        qbdsAccountEntryDimension.addGroupByField(fieldNum(GeneralJournalAccountEntryDimension, PostingLayer));
        qbdsGeneralJournalAccountEntry.addGroupByField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        qbdsAccountEntryDimension.addGroupByField(fieldNum(GeneralJournalAccountEntryDimension, GeneralJournalAccountEntryHash));

        qbdsAccountEntryDimension.addSortField(fieldNum(GeneralJournalAccountEntryDimension, MainAccount));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertClosingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the closing transactions based on the work table.
    /// </summary>
    /// <param name="_generalJournalController">
    /// The controller class object that is used for posting to the ledger.
    /// </param>
    //
    // Create general journal records for all of the closing types of transactions
    // created in the work tables by theaddAccountSumUltimo() method.
    //
    protected void insertClosingTrans(LedgerPostingGeneralJournalController _generalJournalController)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        // <GCN>
        GeneralJournalEntry_W generalJournalEntryW;
        // </GCN>
        // <GBR>
        GeneralJournalAccountEntry_W generalJournalAccountEntryW;
        // </GBR>
        TransactionTxt transactionTxt;

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::LedgerClosing);

        while select accountSumUltimoOperations
                where accountSumUltimoOperations.SessionId      == processSession                           &&
                      accountSumUltimoOperations.UTCTimestamp   == processTimestamp                         &&
                      (accountSumUltimoOperations.ClosingType   == LedgerAccountType::AccountStatus         ||
                       accountSumUltimoOperations.ClosingType   == LedgerAccountType::AccountOperations)    &&
                      (accountSumUltimoOperations.Posting       == LedgerPostingType::Closing               ||
                       accountSumUltimoOperations.Posting       == LedgerPostingType::TransferOpeningClosing)
        {
            if (accountSumUltimoOperations.TransactionCurrencyAmount != 0 ||
                accountSumUltimoOperations.AccountingCurrencyAmount != 0 ||
                accountSumUltimoOperations.ReportingCurrencyAmount != 0 ||
                accountSumUltimoOperations.Quantity != 0)
            {
                generalJournalEntry = null;
                generalJournalEntry.PostingLayer = accountSumUltimoOperations.OperationsTax;
                generalJournalEntry.SubledgerVoucher = voucher;
                generalJournalEntry.SubledgerVoucherDataAreaId = curext();
                generalJournalEntry.AccountingDate = periodEnd;
                generalJournalEntry.Ledger = Ledger::current();
                generalJournalEntry.FiscalCalendarPeriod = closingFiscalCalendarPeriodRecId;
                generalJournalEntry.FiscalCalendarYear = closingFiscalCalendarYearRecId;

                if (acknowledgementDate == dateNull())
                {
                    generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                }
                else
                {
                    generalJournalEntry.AcknowledgementDate = acknowledgementDate;
                }

                // <GCN>
                if (LedgerParameters::isChineseVoucher_CN())
                {
                    generalJournalEntryW.LedgerVoucherType_CN = ledgerVoucherTypeRecId_CN;
                    generalJournalEntryW.Voucher_CN = voucher_CN;
                }
                // </GCN>
                generalJournalAccountEntry.PostingType = LedgerPostingType::TransferOpeningClosing;
                generalJournalAccountEntry.LedgerDimension = accountSumUltimoOperations.LedgerDimension;
                DimensionAttributeValueCombination ledgerAccount = DimensionAttributeValueCombination::find(accountSumUltimoOperations.LedgerDimension);

                generalJournalAccountEntry.MainAccount = ledgerAccount.MainAccount;
                generalJournalAccountEntry.LedgerAccount = ledgerAccount.DisplayValue;
                generalJournalAccountEntry.TransactionCurrencyCode = accountSumUltimoOperations.CurrencyCode;

                transactionTxt.setDate(periodEnd);
                transactionTxt.setVoucher(voucher);
                transactionTxt.setFormLetter(ledgerAccount.MainAccountValue);
                transactionTxt.setLanguage(currentUserLanguage());

                generalJournalAccountEntry.Text = transactionTxt.txt();

                generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumUltimoOperations);

                // <GBR>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR, #isoMX]))
                {
                    if (accountSumUltimoOperations.ClosingType  == LedgerAccountType::AccountOperations)
                    {
                        generalJournalAccountEntryW.IsAccountingClosing_BR = NoYes::Yes;
                    }
                    else
                    {
                        generalJournalAccountEntryW.IsAccountingClosing_BR = NoYes::No;
                    }
                }
                // </GBR>

                _generalJournalController.addForUtility(
                    generalJournalEntry,
                    generalJournalAccountEntry
                    // <GCN>
                    , null
                    , generalJournalEntryW
                    // </GCN>
                    // <GBR>
                    , generalJournalAccountEntryW
                    // </GBR>
                    );
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertClosingTransForPublicSector</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the closing transactions based on the work table.
    /// </summary>
    /// <param name="_postToFiscalCalendarPeriodId">
    /// The record ID of the posting fiscal calendar period.
    /// </param>
    /// <param name="_generalJournalController">
    /// The controller class object that is used for posting to the ledger.
    /// </param>
    protected void insertClosingTransForPublicSector(
        RecId _postToFiscalCalendarPeriodId,
        LedgerPostingGeneralJournalController _generalJournalController)
    {
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;

        while select accountSumUltimo
                where accountSumUltimo.SessionId    == processSession                           &&
                      accountSumUltimo.UTCTimestamp == processTimestamp                         &&
                      (accountSumUltimo.ClosingType == LedgerAccountType::AccountStatus         ||
                      accountSumUltimo.ClosingType  == LedgerAccountType::AccountOperations)    &&
                      accountSumUltimo.Posting      == LedgerPostingType::Closing
        {
            if (accountSumUltimo.TransactionCurrencyAmount != 0 ||
                accountSumUltimo.AccountingCurrencyAmount != 0 ||
                accountSumUltimo.Quantity != 0)
            {
                generalJournalEntry = null;
                generalJournalEntry.PostingLayer = accountSumUltimo.OperationsTax;
                generalJournalEntry.SubledgerVoucher = voucher;
                generalJournalEntry.SubledgerVoucherDataAreaId = curext();
                generalJournalEntry.AccountingDate = periodEnd;
                generalJournalEntry.Ledger = Ledger::current();
                generalJournalEntry.FiscalCalendarPeriod = closingFiscalCalendarPeriodRecId;
                generalJournalEntry.FiscalCalendarYear = closingFiscalCalendarYearRecId;
                generalJournalEntry.RecId = _generalJournalController.getNextTemporaryRecId();

                if (acknowledgementDate == dateNull())
                {
                    generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                }
                else
                {
                    generalJournalEntry.AcknowledgementDate = acknowledgementDate;
                }

                generalJournalAccountEntry.PostingType = LedgerPostingType::TransferOpeningClosing;

                generalJournalAccountEntry.LedgerDimension = accountSumUltimo.LedgerDimension;
                generalJournalAccountEntry.TransactionCurrencyCode = accountSumUltimo.CurrencyCode;
                generalJournalAccountEntry.Text = accountSumUltimo.TransTxt;

                generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumUltimo);

                _generalJournalController.addForUtility(
                    generalJournalEntry,
                    generalJournalAccountEntry,
                    ledgerEntry);

                generalJournalAccountEntry.LedgerDimension = accountSumUltimo.OffsetLedgerDimension;

                generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumUltimo, true);

                _generalJournalController.addForUtility(
                    generalJournalEntry,
                    generalJournalAccountEntry,
                    ledgerEntry);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOnSystemAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes ultimo and primo postings on a system account to help the user to keep the overview.
    /// </summary>
    /// <param name = "_generalJournalController">
    /// The <c>LedgerPostingGeneralJournalController</c> class instance.
    /// </param>
    protected void insertOnSystemAccount(LedgerPostingGeneralJournalController _generalJournalController)
    {
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        GeneralJournalEntry                     generalJournalEntry;
        LedgerDimensionDefaultAccount           periodLedgerDimension;
        TransactionTxt                          transactionTxt;
        DimensionStorageSegment                 mainAccountStorageSegment;
        // <GEEU>
        MainAccount                             mainAccount;
        MainAccount                             mainAccountOpeningAccount;
        // </GEEU>

        RefRecId                                dimensionHierarchy;

        // <GCN>
        GeneralJournalEntry_W generalJournalEntryW;
        LedgerChineseVoucherEnabled_CN  chineseVoucher_CN;
        chineseVoucher_CN = LedgerParameters::isChineseVoucher_CN();
        // </GCN>

        periodLedgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::TransferOpeningClosing);
        if (periodLedgerDimension)
        {
            mainAccountStorageSegment = this.getMainAccountStorageSegment(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(periodLedgerDimension));

            if (isPublicSectorYearEndProcessingEnabled)
            {
                mainAccount = MainAccount::findByMainAccountId(mainAccountStorageSegment.parmDisplayValue());
                dimensionHierarchy = DimensionHierarchy::getAccountStructure(mainAccount.RecId);
            }

            // Look for closing transactions on the designated account for P&L transactions or all balance sheet transactions.
            transactionTxt = TransactionTxt::construct();
            transactionTxt.setType(LedgerTransTxt::LedgerClosing);

            while select accountSumUltimo
                where accountSumUltimo.SessionId      == processSession                             &&
                      accountSumUltimo.UTCTimestamp   == processTimestamp                           &&
                      accountSumUltimo.ClosingType    == LedgerAccountType::AccountStatus           &&
                      (accountSumUltimo.Posting       == LedgerPostingType::TransferOpeningClosing  ||
                       accountSumUltimo.Posting       == LedgerPostingType::Closing)
            {
                if (accountSumUltimo.TransactionCurrencyAmount != 0 ||
                    accountSumUltimo.AccountingCurrencyAmount != 0 ||
                    accountSumUltimo.ReportingCurrencyAmount != 0 ||
                    accountSumUltimo.Quantity != 0)
                {
                    generalJournalEntry = null;
                    generalJournalEntry.SubledgerVoucher = voucher;
                    generalJournalEntry.SubledgerVoucherDataAreaId = curext();
                    generalJournalEntry.AccountingDate = periodEnd;
                    generalJournalEntry.PostingLayer = accountSumUltimo.OperationsTax;
                    generalJournalEntry.FiscalCalendarPeriod = closingFiscalCalendarPeriodRecId;
                    generalJournalEntry.FiscalCalendarYear = closingFiscalCalendarYearRecId;
                    generalJournalEntry.Ledger = Ledger::current();

                    if (acknowledgementDate == dateNull())
                    {
                        generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                    }
                    else
                    {
                        generalJournalEntry.AcknowledgementDate = acknowledgementDate;
                    }

                    // <GCN>
                    if (LedgerParameters::isChineseVoucher_CN())
                    {
                        generalJournalEntryW.LedgerVoucherType_CN = ledgerVoucherTypeRecId_CN;
                        generalJournalEntryW.Voucher_CN = voucher_CN;
                    }
                    // </GCN>

                    if (isPublicSectorYearEndProcessingEnabled)
                    {
                        generalJournalAccountEntry.LedgerDimension =
                            this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, accountSumUltimo.LedgerDimension, dimensionHierarchy);
                    }
                    else
                    {
                        generalJournalAccountEntry.LedgerDimension =
                            this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, accountSumUltimo.LedgerDimension);
                    }

                    generalJournalAccountEntry.TransactionCurrencyCode = accountSumUltimo.CurrencyCode;
                    generalJournalAccountEntry.PostingType = LedgerPostingType::TransferOpeningClosing;

                    transactionTxt.setDate(periodEnd);
                    transactionTxt.setVoucher(voucher);
                    transactionTxt.setFormLetter(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(generalJournalAccountEntry.LedgerDimension));
                    transactionTxt.setLanguage(currentUserLanguage());

                    generalJournalAccountEntry.Text = transactionTxt.txt();

                    generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumUltimo, true);

                    _generalJournalController.addForUtility(
                        generalJournalEntry,
                        generalJournalAccountEntry
                        // <GCN>
                        , null
                        , generalJournalEntryW
                        // </GCN>
                        );
                }
            }

            // Look for opening transactions.
            transactionTxt = TransactionTxt::construct();
            transactionTxt.setType(LedgerTransTxt::LedgerOpening);

            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]) || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
            {
                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(periodLedgerDimension);
                if (mainAccount.OpeningAccount)
                {
                    mainAccountOpeningAccount = MainAccount::find(mainAccount.OpeningAccount);
                    mainAccountStorageSegment = this.getMainAccountStorageSegment(mainAccountOpeningAccount.MainAccountId, true);   // May need to create DAV for opening account as it was only specified by a RecId, not from an existing ledger dimension.
                }
            }
            // </GEEU>

            while select accountSumPrimo
                where accountSumPrimo.SessionId      == processSession                      &&
                      accountSumPrimo.UTCTimestamp   == processTimestamp                    &&
                      (accountSumPrimo.ClosingType   == LedgerAccountType::AccountStatus    &&
                       accountSumPrimo.Posting       == LedgerPostingType::None)
            {
                if (accountSumPrimo.TransactionCurrencyAmount ||
                    accountSumPrimo.AccountingCurrencyAmount ||
                    accountSumPrimo.ReportingCurrencyAmount ||
                    accountSumPrimo.Quantity)
                {
                    generalJournalEntry = null;
                    generalJournalEntry.SubledgerVoucher = voucher;
                    generalJournalEntry.SubledgerVoucherDataAreaId = curext();
                    generalJournalEntry.AccountingDate = periodNext;
                    generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                    generalJournalEntry.PostingLayer = accountSumPrimo.OperationsTax;
                    generalJournalEntry.FiscalCalendarPeriod = openingFiscalCalendarPeriodRecId;
                    generalJournalEntry.FiscalCalendarYear = openingFiscalCalendarYearRecId;
                    generalJournalEntry.Ledger = Ledger::current();

                    if (acknowledgementDate == dateNull())
                    {
                        generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                    }
                    else
                    {
                        generalJournalEntry.AcknowledgementDate = acknowledgementDate;
                    }

                    // <GCN>
                    if (LedgerParameters::isChineseVoucher_CN())
                    {
                        generalJournalEntryW.LedgerVoucherType_CN = ledgerVoucherTypeRecId_CN;
                        generalJournalEntryW.Voucher_CN = voucher_CN;
                    }
                    // </GCN>

                    if (isPublicSectorYearEndProcessingEnabled)
                    {
                        generalJournalAccountEntry.LedgerDimension =
                            this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, accountSumPrimo.LedgerDimension, dimensionHierarchy);
                    }
                    else
                    {
                        generalJournalAccountEntry.LedgerDimension =
                            this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, accountSumPrimo.LedgerDimension);
                    }

                    generalJournalAccountEntry.TransactionCurrencyCode = accountSumPrimo.CurrencyCode;
                    generalJournalAccountEntry.PostingType = LedgerPostingType::TransferOpeningClosing;

                    transactionTxt.setDate(periodNext);
                    transactionTxt.setVoucher(voucher);
                    transactionTxt.setFormLetter(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(generalJournalAccountEntry.LedgerDimension));
                    transactionTxt.setLanguage(currentUserLanguage());

                    generalJournalAccountEntry.Text = transactionTxt.txt();

                    generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumPrimo, true);

                    _generalJournalController.addForUtility(
                        generalJournalEntry,
                        generalJournalAccountEntry
                        // <GCN>
                        , null
                        , generalJournalEntryW
                        // </GCN>
                        );
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOpeningTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the opening transactions based on the work table.
    /// </summary>
    /// <param name="_generalJournalController">
    /// The controller class object that is used for posting to the ledger.
    /// </param>
    protected void insertOpeningTrans(LedgerPostingGeneralJournalController _generalJournalController)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        TransactionTxt transactionTxt;
        AmountMST sumInTotal;
        AmountMSTSecondary reportingCurrencySumInTotal;
        // <GCN>
        GeneralJournalEntry_W generalJournalEntryW;
        boolean     countryRegion_CN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]);
        // </GCN>
        // <GEEU>
        MainAccount             mainAccount;
        MainAccount             mainAccountOpeningAccount;
        LedgerDimensionAccount  ledgerDimension;
        DimensionStorageSegment mainAccountStorageSegment;
        boolean                 countryRegion_CZHU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU]);
        // </GEEU>

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::LedgerOpening);

        sumInTotal = 0;
        reportingCurrencySumInTotal = 0;

        if (isPublicSectorYearEndProcessingEnabled)
        {
            while select forupdate  accountSumPrimo
                  where accountSumPrimo.SessionId      == processSession &&
                        accountSumPrimo.UTCTimestamp   == processTimestamp &&
                        accountSumPrimo.ClosingType    == LedgerAccountType::AccountStatus &&
                        accountSumPrimo.Posting        == LedgerPostingType::None
            {
                if (accountSumPrimo.TransactionCurrencyAmount != 0 ||
                    accountSumPrimo.AccountingCurrencyAmount != 0 ||
                    accountSumPrimo.Quantity != 0)
                {
                    generalJournalEntry.SubledgerVoucher = voucher;
                    generalJournalEntry.SubledgerVoucherDataAreaId = curext();
                    generalJournalEntry.AccountingDate = periodNext;
                    generalJournalEntry.FiscalCalendarPeriod = openingFiscalCalendarPeriodRecId;
                    generalJournalEntry.FiscalCalendarYear = openingFiscalCalendarYearRecId;
                    generalJournalEntry.PostingLayer = accountSumPrimo.OperationsTax;
                    generalJournalEntry.Ledger = Ledger::current();
                    generalJournalEntry.RecId = _generalJournalController.getNextTemporaryRecId();

                    if (acknowledgementDate == dateNull())
                    {
                        generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                    }
                    else
                    {
                        generalJournalEntry.AcknowledgementDate = acknowledgementDate;
                    }

                    generalJournalAccountEntry.PostingType = LedgerPostingType::None;
                    generalJournalAccountEntry.LedgerDimension = accountSumPrimo.LedgerDimension;
                    generalJournalAccountEntry.TransactionCurrencyCode = accountSumPrimo.CurrencyCode;
                    generalJournalAccountEntry.Text = accountSumPrimo.TransTxt;

                    generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumPrimo);

                    _generalJournalController.addForUtility(generalJournalEntry, generalJournalAccountEntry);

                    sumInTotal += generalJournalAccountEntry.AccountingCurrencyAmount;
                    reportingCurrencySumInTotal += generalJournalAccountEntry.ReportingCurrencyAmount;
                    dimensionBalancingValidator.calculateDimensionBalance(generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.AccountingCurrencyAmount);

                    if (this.shouldSkipOffsetAccountForRealAccounts_PSN(accountSumPrimo.LedgerDimension) && accountSumPrimo.OffsetLedgerDimension == 0)
                    {
                        continue;
                    }

                    generalJournalAccountEntry.LedgerDimension = accountSumPrimo.OffsetLedgerDimension;

                    generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumPrimo, true);

                    _generalJournalController.addForUtility(generalJournalEntry, generalJournalAccountEntry);

                    sumInTotal += generalJournalAccountEntry.AccountingCurrencyAmount;
                    reportingCurrencySumInTotal += generalJournalAccountEntry.ReportingCurrencyAmount;
                    dimensionBalancingValidator.calculateDimensionBalance(generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.AccountingCurrencyAmount);
                }
            }
        }
        else
        {
            countOpeningBalancesCreated = 0;
            while select forupdate  accountSumPrimo
                  where accountSumPrimo.SessionId      == processSession &&
                        accountSumPrimo.UTCTimestamp   == processTimestamp &&
                        accountSumPrimo.ClosingType    == LedgerAccountType::AccountStatus &&
                        accountSumPrimo.Posting == LedgerPostingType::None
            {
                if (accountSumPrimo.TransactionCurrencyAmount != 0 ||
                    accountSumPrimo.AccountingCurrencyAmount != 0 ||
                    accountSumPrimo.ReportingCurrencyAmount != 0 ||
                    accountSumPrimo.Quantity != 0)
                {
                    generalJournalEntry = null;
                    generalJournalEntry.SubledgerVoucher = voucher;
                    generalJournalEntry.SubledgerVoucherDataAreaId = curext();
                    generalJournalEntry.AccountingDate = periodNext;
                    generalJournalEntry.FiscalCalendarPeriod = openingFiscalCalendarPeriodRecId;
                    generalJournalEntry.FiscalCalendarYear = openingFiscalCalendarYearRecId;
                    generalJournalEntry.PostingLayer = accountSumPrimo.OperationsTax;
                    generalJournalEntry.Ledger = Ledger::current();

                    if (acknowledgementDate == dateNull())
                    {
                        generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
                    }
                    else
                    {
                        generalJournalEntry.AcknowledgementDate = acknowledgementDate;
                    }

                    // <GCN>
                    if (countryRegion_CN && LedgerParameters::isChineseVoucher_CN())
                    {
                        generalJournalEntryW.LedgerVoucherType_CN = ledgerVoucherTypeRecId_CN;
                        generalJournalEntryW.Voucher_CN = voucher_CN;
                    }
                    // </GCN>

                    DimensionAttributeValueCombination ledgerAccount = DimensionAttributeValueCombination::find(accountSumPrimo.LedgerDimension);

                    // <GEEU>
                    if (countryRegion_CZHU)
                    {
                        ledgerDimension = accountSumPrimo.LedgerDimension;
                        mainAccount = MainAccount::find(ledgerAccount.MainAccount);

                        if ((mainAccount.OpeningAccount) && (mainAccount.OpeningAccount != mainAccount.RecId))
                        {
                            mainAccountOpeningAccount = MainAccount::find(mainAccount.OpeningAccount);
                            mainAccountStorageSegment = this.getMainAccountStorageSegment(mainAccountOpeningAccount.MainAccountId, true);   // May need to create DAV for opening account as it was only specified by a RecId, not from an existing ledger dimension.

                            ledgerDimension = this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, accountSumPrimo.LedgerDimension);
                            ledgerAccount = DimensionAttributeValueCombination::find(ledgerDimension);
                        }

                        generalJournalAccountEntry.LedgerDimension = ledgerDimension;
                    }
                    else
                    {
                        // </GEEU>
                        generalJournalAccountEntry.LedgerDimension = accountSumPrimo.LedgerDimension;
                        // <GEEU>
                    }
                    // </GEEU>

                    generalJournalAccountEntry.MainAccount = ledgerAccount.MainAccount;
                    generalJournalAccountEntry.LedgerAccount = ledgerAccount.DisplayValue;
                    generalJournalAccountEntry.PostingType = LedgerPostingType::None;
                    generalJournalAccountEntry.TransactionCurrencyCode = accountSumPrimo.CurrencyCode;

                    transactionTxt.setDate(periodNext);
                    transactionTxt.setVoucher(voucher);
                    transactionTxt.setFormLetter(ledgerAccount.MainAccountValue);
                    transactionTxt.setLanguage(currentUserLanguage());

                    generalJournalAccountEntry.Text = transactionTxt.txt();

                    generalJournalAccountEntry.initAmountsForLedgerTransferOpeningSumTmp(accountSumPrimo);

                    _generalJournalController.addForUtility(
                        generalJournalEntry,
                        generalJournalAccountEntry
                        // <GCN>
                        , null
                        , generalJournalEntryW
                        // </GCN>
                        );

                    countOpeningBalancesCreated++;
                    sumInTotal += generalJournalAccountEntry.AccountingCurrencyAmount;
                    reportingCurrencySumInTotal += generalJournalAccountEntry.ReportingCurrencyAmount;
                }
            }
        }

        AmountMST summarizedAccountingCurrency = isAdvancedAwarenessOptsParmEnabled
            ? GeneralJournalAccountEntryDetailsTmp::summarizeAccountingCurrencyAmounts(processSession, processTimestamp)
            : 0;

        AmountMST sumInTotalAndDetails = CurrencyExchangeHelper::amount(sumInTotal) + CurrencyExchangeHelper::amount(summarizedAccountingCurrency);

        if (sumInTotalAndDetails)
        {
            this.logInformation(SumInTotalLogMessage);

            // <GEERU>
            if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                // </GEERU>
                throw error(strFmt("@SYS18947", 0.00) + '\n' +
                            strFmt("@SYS18948", sumInTotalAndDetails) + '\n\n' +
                            "@SYS10015");
                // <GEERU>
            }
            // </GEERU>
        }

        AmountMST summarizedReportingCurrency = isAdvancedAwarenessOptsParmEnabled
            ? GeneralJournalAccountEntryDetailsTmp::summarizeReportingCurrencyAmounts(processSession, processTimestamp)
            : 0;

        AmountMST reportingSumInTotalAndDetails = CurrencyExchangeHelper::amount(reportingCurrencySumInTotal) + CurrencyExchangeHelper::amount(summarizedReportingCurrency);

        if (reportingSumInTotalAndDetails)
        {
            this.logInformation(ReportingCurrencySumInTotalLogMessage);

            if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                throw error(strFmt("@GeneralLedger:ReportingCurrencyTotalValidationForYearEndProcessing", 0.00) + '\n' +
                            strFmt("@SYS18948", reportingSumInTotalAndDetails) + '\n\n' +
                            "@SYS10015");
            }
        }
        TransactionLog::create(TransactionLogType::LedgerOpening, strFmt("@SYS25760", periodNext));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainAccountLookupReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a lookup on Main account for the specified form control.
    /// </summary>
    /// <param name = "_formReferenceControl">
    /// A form control.
    /// </param>
    /// <returns>
    /// A <c>MainAccount</c> record.
    /// </returns>
    public Common mainAccountLookupReference(FormReferenceControl _formReferenceControl)
    {
        return MainAccount::lookupReference(_formReferenceControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainAccountResolveReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolves the Main account reference for the specified form control.
    /// </summary>
    /// <param name = "_formReferenceControl">
    /// A form control.
    /// </param>
    /// <returns>
    /// A <c>MainAccount</c> record.
    /// </returns>
    public Common mainAccountResolveReference(FormReferenceControl _formReferenceControl)
    {
        return MainAccount::resolveReference(_formReferenceControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerTransferOpening</c> object.
    /// </summary>
    /// <param name="_isPublicSectorEnabled">Indicates whether public sector is enabled.</param>
    /// <returns>A new instance of the <c>LedgerTransferOpening</c> object.</returns>
    public static LedgerTransferOpening construct(boolean _isPublicSectorEnabled = PublicSectorUtils::isLedgerYearEndClosingEnabled())
    {
        return new LedgerTransferOpening(_isPublicSectorEnabled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerTransferOpening</c> object to reverse all previous transfers for the given fiscal calendar year.
    /// </summary>
    /// <param name="_closedYearRecId">The id of the FiscalCalendarYear to reverse.</param>
    /// <returns>A new instance of the <c>LedgerTransferOpening</c> object.</returns>
    public static LedgerTransferOpening newForReversal(FiscalCalendarYearRecId _closedYearRecId)
    {
        FiscalCalendarYear closedYear = FiscalCalendarYear::find(_closedYearRecId);
        FiscalCalendarPeriod closingPeriod = LedgerFiscalCalendar::findYearEndClosingPeriodByDate(closedYear.FiscalCalendar, closedYear.EndDate);

        LedgerTransferOpening transfer = new LedgerTransferOpening(PublicSectorUtils::isLedgerYearEndClosingEnabled());
        transfer.initParmDefault();

        transfer.parmMethodStatus(OpeningMethod::Reset);
        transfer.parmProcessState(LedgerTransferOpeningProcessState::Delete);
        transfer.parmFiscalYearName(closedYear.Name);

        // It doesn't make sense that these are required to delete year end transactions, but it is less instrusive than changing the validation.
        transfer.parmPeriodname(closingPeriod.Name);
        transfer.parmPeriodEnd(closingPeriod.EndDate);

        return transfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(boolean _isPublicSectorEnabled = PublicSectorUtils::isLedgerYearEndClosingEnabled())
    {
        Map                             singleAttrMaps;
        DimensionAttributeSetStorage    allDimAttrSetStorage;
        DimensionAttribute              dimAttr;

        silent = false;

        // Cache often used data for improved performance.
        calendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        ledgerParameters = LedgerParameters::find();
  
        isPublicSectorYearEndProcessingEnabled = _isPublicSectorEnabled;

        if (isPublicSectorYearEndProcessingEnabled)
        {
            fiscalCalendarYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName).RecId;

            processCancelled = false;

            if (!calendarRecId)
            {
                checkFailed("@SYS128634");
            }
        }

        // Init allDimAttributes (needed by initParmDefault)
        allDimAttrSetStorage = DimensionAttributeSetStorage::newForEnumName(enumstr(LedgerCloseSingleAll));
        
        dimensionBalancingValidator = DimensionBalancingValidator::construct();
  
        while select * from dimAttr
            where dimAttr.Type != DimensionAttributeType::DynamicAccount &&
                dimAttr.Type != DimensionAttributeType::MainAccount
        {
            if (dimAttr.getStatus() == DimensionAttributeStatus::Active)
            {
                allDimAttrSetStorage.addItem(dimAttr.RecId, dimAttr.HashKey, enum2int(LedgerCloseSingleAll::CloseAll));
            }
        }

        allDimAttributes = allDimAttrSetStorage.save();

        // Load attribute info for allDimAttributes
        singleAttrMaps = DimensionHierarchy::getSingleAttributeHierarchies(allDimAttributes);
        dimAttrTableBuffers = singleAttrMaps.lookup(1);
        dimAttrIdToSingleAttrHierarchyId = singleAttrMaps.lookup(2);
        dimAttrRecIds = singleAttrMaps.lookup(3);

        // Initialize class variables used by the query/process methods
        mainAccountDimAttrId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);
        mainAccountDimAttr = DimensionAttribute::find(mainAccountDimAttrId);
        fallbackAccountStructureId = DimensionHierarchy::getRelationalAccountStructureId();

        // Cache the dimension specifiers map for each dimension attribute set and account entry hash.
        dimAttrSetAccountEntryHashSpecifiers = new Map(Types::Container, Types::Class);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [LedgerTransferOpening::currentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcknowledgementDate</Name>
				<Source><![CDATA[
    AcknowledgementDate parmAcknowledgementDate(AcknowledgementDate _acknowledgementDate = acknowledgementDate)
    {
        acknowledgementDate = _acknowledgementDate;
        return acknowledgementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBalanceFromPeriod</Name>
				<Source><![CDATA[
    PeriodName parmBalanceFromPeriod(PeriodName _balanceFromPeriod = balanceFromPeriod)
    {
        balanceFromPeriod = _balanceFromPeriod;

        return balanceFromPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBalanceOpenFromPeriod</Name>
				<Source><![CDATA[
    PeriodName parmBalanceOpenFromPeriod(PeriodName _balanceOpenFromPeriod = balanceOpenFromPeriod)
    {
        balanceOpenFromPeriod = _balanceOpenFromPeriod;

        return balanceOpenFromPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBalanceToPeriod</Name>
				<Source><![CDATA[
    PeriodName parmBalanceToPeriod(PeriodName _balanceToPeriod = balanceToPeriod)
    {
        balanceToPeriod = _balanceToPeriod;

        return balanceToPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCloseDateFromPeriod</Name>
				<Source><![CDATA[
    TransDate parmCloseDateFromPeriod(TransDate _closeDateFromPeriod = closeDateFromPeriod)
    {
        closeDateFromPeriod = _closeDateFromPeriod;

        return closeDateFromPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEndRecId</Name>
				<Source><![CDATA[
    public RecId parmEndRecId(RecId _endRecId = endRecId)
    {
        endRecId = _endRecId;

        return endRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalYearName</Name>
				<Source><![CDATA[
    FiscalYearName parmFiscalYearName(FiscalYearName _closingFiscalYearName = closingFiscalYearName)
    {
        closingFiscalYearName = _closingFiscalYearName;

        return closingFiscalYearName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromFund</Name>
				<Source><![CDATA[
    FundNumber parmFromFund(FundNumber _fromFund = fromFund)
    {
        fromFund = _fromFund;

        return fromFund;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransferOpeningType</Name>
				<Source><![CDATA[
    public LedgerTransferOpeningType parmLedgerTransferOpeningType(LedgerTransferOpeningType _ledgerTransferOpeningType = ledgerTransferOpeningType)
    {
        ledgerTransferOpeningType = _ledgerTransferOpeningType;

        return _ledgerTransferOpeningType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMethodOperations</Name>
				<Source><![CDATA[
    OpeningMethod parmMethodOperations(OpeningMethod _methodOperations = methodOperations)
    {
        methodOperations = _methodOperations;
        return methodOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMethodStatus</Name>
				<Source><![CDATA[
    OpeningMethod parmMethodStatus(OpeningMethod _methodStatus = methodStatus)
    {
        methodStatus = _methodStatus;
        return methodStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpenDateFromPeriod</Name>
				<Source><![CDATA[
    TransDate parmOpenDateFromPeriod(TransDate _openDateFromPeriod = openDateFromPeriod)
    {
        openDateFromPeriod = _openDateFromPeriod;

        return openDateFromPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodEnd</Name>
				<Source><![CDATA[
    TransDate parmPeriodEnd(TransDate _periodEnd = periodEnd)
    {
        periodEnd = _periodEnd;
        return periodEnd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodname</Name>
				<Source><![CDATA[
    PeriodName parmPeriodname(PeriodName _periodName = periodName)
    {
        periodName = _periodName;
        return periodName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodNext</Name>
				<Source><![CDATA[
    TransDate parmPeriodNext(TransDate _periodNext = periodNext)
    {
        periodNext = _periodNext;
        return periodNext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessCancelled</Name>
				<Source><![CDATA[
    boolean parmProcessCancelled(boolean _processCancelled = processCancelled)
    {
        processCancelled = _processCancelled;

        return processCancelled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDelayDimensionSetRebuild</Name>
				<Source><![CDATA[
    boolean parmDelayDimensionSetRebuild(boolean _delayRebuild = delayDimensionSetRebuild)
    {
        delayDimensionSetRebuild = _delayRebuild;

        return delayDimensionSetRebuild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessState</Name>
				<Source><![CDATA[
    public LedgerTransferOpeningProcessState parmProcessState(LedgerTransferOpeningProcessState _processState = processState)
    {
        processState = _processState;

        return processState;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRunPreview</Name>
				<Source><![CDATA[
    public NoYesId parmRunPreview(NoYesId _runPreview = runPreview)
    {
        runPreview = _runPreview;

        return runPreview;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRunReport</Name>
				<Source><![CDATA[
    public NoYesId parmRunReport(NoYesId _runReport = runReport)
    {
        runReport = _runReport;

        return runReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectFund</Name>
				<Source><![CDATA[
    NoYes parmSelectFund(NoYes _selectFund = selectFund)
    {
        selectFund = _selectFund;

        return selectFund;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSilent</Name>
				<Source><![CDATA[
    public boolean parmSilent(boolean _silent = silent)
    {
        silent = _silent;

        return silent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStartRecId</Name>
				<Source><![CDATA[
    public RecId parmStartRecId(RecId _startRecId = startRecId)
    {
        startRecId = _startRecId;

        return startRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToFund</Name>
				<Source><![CDATA[
    FundNumber parmToFund(FundNumber _toFund = toFund)
    {
        toFund = _toFund;

        return toFund;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferDimensions</Name>
				<Source><![CDATA[
    NoYes parmTransferDimensions(NoYes _transferDimensions = transferDimensions)
    {
        transferDimensions = _transferDimensions;
        return transferDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferResultAccount</Name>
				<Source><![CDATA[
    MainAccountNum parmTransferResultAccount(MainAccountNum _transferResult = transferResult)
    {
        transferResult = _transferResult;

        return transferResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseTransferYearEndAccount_ES</Name>
				<Source><![CDATA[
    UseTransferYearEndAccount_ES parmUseTransferYearEndAccount_ES(UseTransferYearEndAccount_ES _useTransferYearEndAccount_ES = useTransferYearEndAccount_ES)
    {
        useTransferYearEndAccount_ES = _useTransferYearEndAccount_ES;
        return useTransferYearEndAccount_ES;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher_CN</Name>
				<Source><![CDATA[
    public Voucher_CN parmVoucher_CN(Voucher_CN _voucher_CN = voucher_CN)
    {
        voucher_CN = _voucher_CN;
        return voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherTypeRecId_CN</Name>
				<Source><![CDATA[
    public LedgerVoucherTypeRefRecId_CN parmLedgerVoucherTypeRecId_CN(LedgerVoucherTypeRefRecId_CN _ledgerVoucherTypeRecId_CN = ledgerVoucherTypeRecId_CN)
    {
        ledgerVoucherTypeRecId_CN = _ledgerVoucherTypeRecId_CN;
        return ledgerVoucherTypeRecId_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performFundLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens a Fund lookup form.
    /// </summary>
    /// <param name="_formStringControl">
    /// The dialog field control.
    /// </param>
    protected void performFundLookup(FormStringControl _formStringControl)
    {
        SysTableLookup          sysTableLookup;
        Query                   query = new Query();
        QueryBuildDataSource    qbdsFundFrom;

        sysTableLookup = SysTableLookup::newParameters(tableNum(LedgerFund), _formStringControl, true);

        // Create the query datasource.
        qbdsFundFrom = query.addDataSource(tableNum (LedgerFund));

        // Add the fields to be shown in the lookup form.
        sysTableLookup.addLookupfield(fieldNum(LedgerFund, FundNumber));
        sysTableLookup.addLookupfield(fieldNum(LedgerFund, FundName));

        // Add the query to the lookup form.
        sysTableLookup.parmQuery(query);

        // Perform lookup.
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndDate_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the end date field.
    /// </summary>
    /// <param name="_formDateControl">
    /// The control for the end date field.
    /// </param>
    /// <returns>
    /// true if the field was modified; otherwise, false.
    /// </returns>
    private boolean periodEndDate_Modified(FormDateControl _formDateControl)
    {
        boolean valueWasModified = _formDateControl.modified();

        if (valueWasModified)
        {
            if (dialogPeriodEnd.value() != dateNull())
            {
                int64 numberOfClosingPeriods = LedgerFiscalCalendar::numberOfClosingPeriods(calendarRecId, dialogPeriodEnd.value());

                if (numberOfClosingPeriods < 1)
                {
                    dialogPeriodName.value(LedgerFiscalCalendar::findPeriodByPeriodCodeDate(calendarRecId, dialogPeriodEnd.value()).Name);
                    dialogPeriodName.allowEdit(false);
                }
                else
                {
                    dialogPeriodName.value(FiscalCalendars::findFirstClosingPeriodNameByDate(calendarRecId, dialogPeriodEnd.value()));
                    dialogPeriodName.allowEdit(numberOfClosingPeriods > 1);
                }
            }
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndFrom_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>dialogPeriodEndFrom</c> lookup based on <c>fiscalCalendarYearNameRecId</c> and <c>PeriodCode</c> value.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogPeriodEndFrom</c> dialog field control.
    /// </param>
    private void periodEndFrom_Lookup(FormStringControl _formStringControl)
    {
        QueryBuildDataSource    dsFiscalCalendarPeriod;
        SysTableLookup  sysTableLookup;
        Query query = new Query();

        _formStringControl.setFocus();
        sysTableLookup = SysTableLookup::newParameters(tableNum(FiscalCalendarPeriod), _formStringControl, false);

        // Create the query datasource.
        dsFiscalCalendarPeriod = query.addDataSource(tableNum(FiscalCalendarPeriod));

        if (dialogPeriodEndFromDate.value() != dateNull())
        {
            dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, EndDate)).value(queryValue(dialogPeriodEndFromDate.value()));
        }

        // Restrict to fiscal periods for the selected fiscal calendar.
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendarYear)).value(queryValue(fiscalCalendarYearNameRecId));
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(strFmt('((%1 == %2) || ((%1 == %3)))',
        fieldStr(FiscalCalendarPeriod, Type), any2int(FiscalPeriodType::Operating), any2int(FiscalPeriodType::Closing)));

        dsFiscalCalendarPeriod.addSortField(fieldNum(FiscalCalendarPeriod, StartDate));

        // Add the fields to be shown in the lookup form.
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Name));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, StartDate));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, EndDate));

        // Add the query to the lookup form.
        sysTableLookup.parmQuery(query);

        // Perform lookup.
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndFrom_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the <c>dialogPeriodEndFromDate</c> field whenever the <c>dialogPeriodEndFrom</c>
    /// field is modified.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogPeriodEndTo</c> dialog field control.
    /// </param>
    /// <returns>
    /// true if the <c>dialogPeriodEndFromDate</c> field can be edited; otherwise, false .
    /// </returns>
    private boolean periodEndFrom_Modified(FormStringControl _formStringControl)
    {
        boolean valueWasModified;

        valueWasModified = _formStringControl.modified();

        if (valueWasModified)
        {
            dialogPeriodEndFromDate.value(FiscalCalendarPeriod::findByCalendarYearPeriod(fiscalCalendarYearNameRecId, dialogPeriodEndFrom.value()).EndDate);
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndFromDate_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the <c>dialogPeriodEndFromDate</c> dialog field.
    /// </summary>
    /// <param name="_formDateControl">
    /// The control that is bound to the <c>dialogPeriodEndFromDate</c> field.
    /// </param>
    /// <returns>
    /// true if the field was modified; otherwise, false.
    /// </returns>
    private boolean periodEndFromDate_Modified(FormDateControl _formDateControl)
    {
        boolean valueWasModified = _formDateControl.modified();

        if (valueWasModified)
        {
            if (dialogPeriodEndFromDate.value() != dateNull())
            {
                int64 numberOfClosingPeriods = LedgerFiscalCalendar::numberOfClosingPeriods(calendarRecId, dialogPeriodEndFromDate.value());
                dialogPeriodEndFrom.value(FiscalCalendars::findFirstClosingPeriodNameByDate(calendarRecId, dialogPeriodEndFromDate.value()));
            }
            else
            {
                dialogPeriodEndFrom.value('');
            }

            if (dialogPeriodEndFromDate.value() != LedgerFiscalCalendar::findPeriodEndDateByDate(calendarRecId, dialogPeriodEndFromDate.value()))
            {
                warning("@SPS468");
            }
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndTo_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>dialogPeriodEndTo</c> lookup based on <c>fiscalCalendarYearNameRecId</c> and <c>PeriodCode</c> value.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogPeriodEndTo</c> dialog field control.
    /// </param>
    private void periodEndTo_Lookup(FormStringControl _formStringControl)
    {
        QueryBuildDataSource    dsFiscalCalendarPeriod;
        SysTableLookup  sysTableLookup;
        Query query = new Query();

        _formStringControl.setFocus();
        sysTableLookup = SysTableLookup::newParameters (tableNum(FiscalCalendarPeriod), _formStringControl, false);

        // Create the query datasource.
        dsFiscalCalendarPeriod          = query.addDataSource(tableNum(FiscalCalendarPeriod));

        if (dialogPeriodEndToDate.value()!= dateNull())
        {
            dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, EndDate)).value(queryValue(dialogPeriodEndToDate.value()));
        }
        // Restrict to fiscal periods for the selected fiscal calendar.
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendarYear)).value(queryValue(fiscalCalendarYearNameRecId));
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(queryValue(FiscalPeriodType::Closing));

        // Add Sort field based on fiscal period start date.
        dsFiscalCalendarPeriod.addSortField(fieldNum(FiscalCalendarPeriod, StartDate));

        // Add the query to the lookup form.
        sysTableLookup.parmQuery(query);

        // Add the fields to be shown in the lookup form.
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Name));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, StartDate));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, EndDate));

        // Perform lookup.
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndTo_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the <c>dialogPeriodEndToDate</c> field whenever the <c>dialogPeriodEndTo</c>
    /// field is modified.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogPeriodEndTo</c> dialog field control.
    /// </param>
    /// <returns>
    /// true if the <c>dialogPeriodEndTo</c> field can be edited; otherwise, false .
    /// </returns>
    private boolean periodEndTo_Modified(FormStringControl _formStringControl)
    {
        boolean valueWasModified;

        valueWasModified = _formStringControl.modified();

        if (valueWasModified)
        {
            dialogPeriodEndToDate.value(FiscalCalendarPeriod::findByCalendarYearPeriod(fiscalCalendarYearNameRecId, dialogPeriodEndTo.value()).EndDate);
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodEndToDate_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the <c>dialogPeriodEndToDate</c> dialog field
    /// </summary>
    /// <param name="_formDateControl">
    /// The <c>dialogPeriodEndToDate</c> dialog field control.
    /// </param>
    /// <returns>
    /// true if the field was modified; otherwise, false.
    /// </returns>
    private boolean periodEndToDate_Modified(FormDateControl _formDateControl)
    {
        boolean valueWasModified = _formDateControl.modified();
        if (valueWasModified)
        {
            if (dialogPeriodEndToDate.value()!= dateNull())
            {
                int64 numberOfClosingPeriods = LedgerFiscalCalendar::numberOfClosingPeriods(calendarRecId, dialogPeriodEndToDate.value());
                if (numberOfClosingPeriods < 1)
                {
                    dialogPeriodName.value(LedgerFiscalCalendar::findPeriodByPeriodCodeDate(calendarRecId,dialogPeriodEndToDate.value()).Name);
                    dialogPeriodName.allowEdit(false);
                }
                else
                {
                    dialogPeriodName.allowEdit(numberOfClosingPeriods > 1);
                    dialogPeriodName.value(FiscalCalendars::findFirstClosingPeriodNameByDate(calendarRecId, dialogPeriodEndToDate.value()));
                }
            }
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodName_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Opens the filtered period name lookup.
    /// </summary>
    /// <param name="_formStringControl">
    ///    The control for the period name lookup of the field.
    /// </param>
    private void periodName_Lookup(FormStringControl _formStringControl)
    {
        FiscalCalendarYearRecId fiscalCalendarYearRecId;
        QueryBuildDataSource    dsFiscalCalendarPeriod;
        SysTableLookup          sysTableLookup;
        Query                   query = new Query();

        sysTableLookup = SysTableLookup::newParameters (tableNum(FiscalCalendarPeriod), _formStringControl);

        if (isPublicSectorYearEndProcessingEnabled)
        {
            fiscalCalendarYearRecId         = FiscalCalendarYear::findYearByCalendarDate(calendarRecId, dialogPeriodEndToDate.value()).RecId;
        }
        else
        {
            fiscalCalendarYearRecId         = FiscalCalendarYear::findYearByCalendarDate(calendarRecId, dialogPeriodEnd.value()).RecId;
        }
        dsFiscalCalendarPeriod          = query.addDataSource(tableNum(FiscalCalendarPeriod));

        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendarYear)).value(queryValue(fiscalCalendarYearRecId));

        if (isPublicSectorYearEndProcessingEnabled)
        {
            dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, StartDate)).value(queryValue(dialogPeriodEndToDate.value()));
        }
        else
        {
            dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, StartDate)).value(queryValue(dialogPeriodEnd.value()));
        }
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(queryValue(FiscalPeriodType::Closing));

        sysTableLookup.parmQuery(query);

        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Name));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, StartDate));
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodStartFrom_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>dialogPeriodStartFrom</c> lookup based on <c>fiscalCalendarYearNameRecId</c> and <c>PeriodCode</c> value.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogPeriodStartFrom</c> dialog field control.
    /// </param>
    private void periodStartFrom_Lookup(FormStringControl _formStringControl)
    {
        QueryBuildDataSource    dsFiscalCalendarPeriod;
        SysTableLookup  sysTableLookup;
        Query query = new Query();

        if (dialogPeriodStartFromDate.value()== dateNull())
        {
            _formStringControl.setFocus();
        }
        sysTableLookup = SysTableLookup::newParameters (tableNum(FiscalCalendarPeriod), _formStringControl, false);

        // Create the query datasource.
        dsFiscalCalendarPeriod = query.addDataSource(tableNum(FiscalCalendarPeriod));

        if (dialogPeriodStartFromDate.value()!= dateNull())
        {
            dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, EndDate)).value(queryValue(dialogPeriodStartFromDate.value()));
        }

        // Restrict to fiscal periods for the selected fiscal calendar.
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendarYear)).value(queryValue(fiscalCalendarYearNameRecId));
        dsFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(strFmt('((%1 == %2) || ((%1 == %3)))',fieldStr(FiscalCalendarPeriod, Type),
        any2int(FiscalPeriodType::Closing), any2int(FiscalPeriodType::Operating)));

        // Add Sort field based on fiscal period start date.
        dsFiscalCalendarPeriod.addSortField(fieldNum(FiscalCalendarPeriod, StartDate));

        // Add the query to the lookup form.
        sysTableLookup.parmQuery(query);

        // Add the fields to be shown in the lookup form.
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Name));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, StartDate));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, EndDate));

        // Perform lookup.
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodStartFrom_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the <c>dialogPeriodStartFromDate</c> field whenever the
    /// <c>dialogPeriodStartFrom</c> field is modified.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogPeriodStartFrom</c> dialog field control.
    /// </param>
    /// <returns>
    /// true if the <c>dialogPeriodStartFromDate</c> field can be edited; otherwise, false .
    /// </returns>
    private boolean periodStartFrom_Modified(FormStringControl _formStringControl)
    {
        boolean valueWasModified;

        valueWasModified = _formStringControl.modified();

        if (valueWasModified)
        {
            dialogPeriodStartFromDate.value(FiscalCalendarPeriod::findByCalendarYearPeriod(fiscalCalendarYearNameRecId, dialogPeriodStartFrom.value()).EndDate);
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodStartFromDate_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the <c>dialogPeriodStartFromDate</c> dialog field.
    /// </summary>
    /// <param name="_formDateControl">
    /// The <c>dialogPeriodStartFromDate</c> dialog field control.
    /// </param>
    /// <returns>
    /// true if the field was modified; otherwise, false.
    /// </returns>
    private boolean periodStartFromDate_Modified(FormDateControl _formDateControl)
    {
        boolean valueWasModified = _formDateControl.modified();
        if (valueWasModified)
        {
            if (dialogPeriodStartFromDate.value()!= dateNull())
            {
                int64 numberOfClosingPeriods = LedgerFiscalCalendar::numberOfClosingPeriods(calendarRecId, dialogPeriodStartFromDate.value());
                if (numberOfClosingPeriods > 1)
                {
                    dialogPeriodStartFrom.allowEdit(true);
                    dialogPeriodStartFrom.value(FiscalCalendars::findFirstClosingPeriodNameByDate(calendarRecId, dialogPeriodStartFromDate.value()));
                }

                dialogPeriodStartFrom.value(FiscalCalendars::findFirstClosingPeriodNameByDate(calendarRecId, dialogPeriodStartFromDate.value()));
            }
            else
            {
                dialogPeriodStartFrom.value('');
            }

            if (dialogPeriodStartFromDate.value() != LedgerFiscalCalendar::findPeriodEndDateByDate(calendarRecId, dialogPeriodStartFromDate.value()))
            {
                warning("@SPS468");
            }
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postZakatValue_SA</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts general ledger journal and Updates Zakat value records.
    /// </summary>
    public void postZakatValue_SA()
    {
        LedgerFiscalClosePostZakatValue_SA ledgerFiscalClosePostZakatValue_SA = LedgerFiscalClosePostZakatValue_SA::newForFiscalClose(
            curExt(),
            FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(), periodEnd));

        ledgerFiscalClosePostZakatValue_SA.postZakatValue_SA();

    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareDimensionStorageSegments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares the dimension storage segments with respect to the provided journalizing definition entry
    /// in accordance with public sector functionality.
    /// </summary>
    /// <param name="dimensionStorageSegments">
    /// A map that represents the dimension specifiers that are applied first.
    /// </param>
    /// <param name="dimensionStorageSegment">
    /// An instance of the <c>DimensionStorageSegment</c> class.
    /// </param>
    /// <param name="mainAccount">
    /// A record of the <c>MainAccount</c> table.
    /// </param>
    /// <param name="journalizingDefinitionEntry">
    /// An instance of the <c>JournalizingDefinitionEntry</c> class.
    /// </param>
    private void prepareDimensionStorageSegments(
                                    Map dimensionStorageSegments,
                                    DimensionStorageSegment     dimensionStorageSegment,
                                    MainAccount                 mainAccount,
                                    JournalizingDefinitionEntry journalizingDefinitionEntry)
    {
        Map             dimensionSpecifiers;
        MapEnumerator   dimensionSpecifiersEnumerator;
        DimensionValue  dimensionAttributeDisplayValue;
        RefRecId        dimensionAttribeValueRecId;
        HashKey         dimensionAttributeValueHash;

        dimensionSpecifiers = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(journalizingDefinitionEntry.parmLedgerDimension());
        dimensionSpecifiersEnumerator = dimensionSpecifiers.getEnumerator();

        while (dimensionSpecifiersEnumerator.moveNext())
        {
            [dimensionAttributeDisplayValue, dimensionAttribeValueRecId, dimensionAttributeValueHash] = dimensionSpecifiersEnumerator.currentValue();

            dimensionStorageSegments.insert(dimensionSpecifiersEnumerator.currentKey(),
                DimensionStorageSegment::construct(dimensionAttributeDisplayValue, dimensionAttribeValueRecId,
                    dimensionAttributeValueHash));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNewClosingRecordsForOpening</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the new closing transactions to find postings that must be processed for the opening
    /// process.
    /// </summary>
    protected void processNewClosingRecordsForOpening()
    {
        FiscalCalendarPeriod            openingBalancePeriod    = this.getOpeningBalancePeriod();
        FiscalCalendarPeriod            closingBalancePeriod    = this.getClosingBalancePeriod();
        FiscalCalendarPeriod            closingPostToPeriod     = this.getClosingPostToPeriod();

        if (!ledgerParameters.PeriodClosingPosting)
        {
            return;
        }

        // if the opening balance from period is less than the closing post to period
        // we will not process the new closing transactions when generating opening transactions
        if ((openingBalancePeriod.EndDate < closingPostToPeriod.EndDate)
            || (openingBalancePeriod.Type != FiscalPeriodType::Closing)
            || ((openingBalancePeriod.EndDate == closingPostToPeriod.EndDate)
            && (openingBalancePeriod.Type == FiscalPeriodType::Closing)
            && (openingBalancePeriod.Name < closingPostToPeriod.Name)))
        {
            return;
        }

        ttsbegin;

        this.updateOpeningTransactionsFromClosingTransactions();

        ttscommit;

        // do not include this is the TTS because it is not necessary and we want to keep the TTS small
        this.insertOpeningTransactionsFromClosingTransactions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOpeningTransactionsFromClosingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates opening transactions from closing transactions.
    /// </summary>
    protected void updateOpeningTransactionsFromClosingTransactions()
    {
        boolean isCurrencyCodeMatched = FeatureStateProvider::isFeatureEnabled(LedgerTransOpeningTransactionsCurrencyMatchFlight::instance());

        LedgerTransferOpeningSumTmp closingTransactions;
        LedgerTransferOpeningSumTmp openingTransactions;

        while select forupdate openingTransactions
                where openingTransactions.SessionId == processSession
                    && openingTransactions.UTCTimestamp == processTimestamp
                    && openingTransactions.ClosingType == LedgerAccountType::AccountStatus
                    && openingTransactions.Posting == LedgerPostingType::None
        {
            if (isCurrencyCodeMatched)
            {
                select sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount),
                        sum(ReportingCurrencyAmount), sum(Quantity), OffsetLedgerDimension from closingTransactions
                            group by OffsetLedgerDimension
                        where closingTransactions.SessionId == processSession
                            && closingTransactions.UTCTimestamp == processTimestamp
                            && (closingTransactions.ClosingType == LedgerAccountType::AccountStatus
                                || closingTransactions.ClosingType == LedgerAccountType::AccountOperations)
                            && closingTransactions.Posting == LedgerPostingType::Closing
                            && closingTransactions.OffsetLedgerDimension == openingTransactions.LedgerDimension
                            && closingTransactions.OperationsTax == openingTransactions.OperationsTax
                            && closingTransactions.CurrencyCode == openingTransactions.CurrencyCode;
            }
            else
            {
                select sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount),
                        sum(ReportingCurrencyAmount), sum(Quantity), OffsetLedgerDimension from closingTransactions
                            group by OffsetLedgerDimension
                        where closingTransactions.SessionId == processSession
                            && closingTransactions.UTCTimestamp == processTimestamp
                            && (closingTransactions.ClosingType == LedgerAccountType::AccountStatus
                                || closingTransactions.ClosingType == LedgerAccountType::AccountOperations)
                            && closingTransactions.Posting == LedgerPostingType::Closing
                            && closingTransactions.OffsetLedgerDimension == openingTransactions.LedgerDimension
                            && closingTransactions.OperationsTax == openingTransactions.OperationsTax;
            }

            openingTransactions.initAmounts(openingTransactions);
            openingTransactions.subtract(closingTransactions);
            openingTransactions.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOpeningTransactionsFromClosingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts opening transactions from closing transactions.
    /// </summary>
    protected void insertOpeningTransactionsFromClosingTransactions()
    {
        LedgerTransferOpeningSumTmp     openingTransactions;
        LedgerDimensionAccount          ledgerDimensionAccountOffset;
        FundClassValueAll               fundClassValueAll;

        RecordInsertList recordInsertList = new RecordInsertList(openingTransactions.TableId);
        TransactionTxt transactionTxt     = TransactionTxt::construct();

        transactionTxt.setType(LedgerTransTxt::LedgerOpening);

        // select the closing transactions where the offset account is a "real" account,
        // and the account was not selected during the opening process.  Opening transactions for these
        // accounts are created
        QueryRun queryRun = new QueryRun(this.getOpeningTransactionsFromClosingTransactions());

        while (queryRun.next())
        {
            LedgerTransferOpeningSumTmp closingTransactions = queryRun.get(tableNum(LedgerTransferOpeningSumTmp));
            LedgerFund ledgerFund = this.getFundFromAccount(closingTransactions.OffsetLedgerDimension);

            if (selectFund && (!ledgerFund || ledgerFund.FundNumber < fromFund || ledgerFund.FundNumber > toFund))
            {
                continue;
            }

            openingTransactions.clear();
            // convert the closing posting into an opening posting
            openingTransactions.Posting = LedgerPostingType::None;

            openingTransactions.initAmounts(closingTransactions, true);

            openingTransactions.LedgerDimension = closingTransactions.OffsetLedgerDimension;
            openingTransactions.SessionId = processSession;
            openingTransactions.UTCTimestamp = processTimestamp;
            openingTransactions.ClosingType = LedgerAccountType::AccountStatus;
            openingTransactions.Posting = LedgerPostingType::None;
            openingTransactions.TransDate = periodNext;
            openingTransactions.OperationsTax = closingTransactions.OperationsTax;
            openingTransactions.Voucher = voucher;

            transactionTxt.setDate(periodNext);
            transactionTxt.setVoucher(voucher);
            transactionTxt.setFormLetter(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(openingTransactions.LedgerDimension));
            transactionTxt.setLanguage(currentUserLanguage());

            openingTransactions.TransTxt = transactionTxt.txt();
            openingTransactions.CurrencyCode = closingTransactions.CurrencyCode;

            fundClassValueAll = enum2int(ledgerFund.FundClass);

            if (this.shouldSkipOffsetAccountForRealAccounts_PSN(openingTransactions.LedgerDimension))
            {
                recordInsertList.add(openingTransactions);
            }
            else
            {
                //
                // The Debit/Credit sign parameter does not matter, we assume a single account to be returned, and whether
                // we are closing or opening will determine the amount of the transaction from the posting definition
                //
                ledgerDimensionAccountOffset = this.getOffsetAccount(fundClassValueAll, LedgerOpenCloseTransType::Open, openingTransactions.LedgerDimension, DebitCredit::Credit, closingTransactions.TransDate);

                if (ledgerDimensionAccountOffset)
                {
                    openingTransactions.OffsetLedgerDimension = ledgerDimensionAccountOffset;
                    recordInsertList.add(openingTransactions);
                }
                else
                {
                    DimensionAttributeValueCombination dimensionAttributeValueCombination = DimensionAttributeValueCombination::find(openingTransactions.LedgerDimension);
                    checkFailed(strFmt("@SPS574", dimensionAttributeValueCombination.DisplayValue));
                }
            }
        }
        recordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpeningTransactionsFromClosingTransactions</Name>
				<Source><![CDATA[
    protected Query getOpeningTransactionsFromClosingTransactions()
    {
        const str closingTransactions = "closingTransactions";
        const str newOpeningTransactions = "newOpeningTransactions";
     
        Query query;

        if (LedgerTransferOpeningTransFromClosingTransCurrencyMatchFlight::instance().isEnabled())
        {
            query = new Query(queryStr(LedgerTransferOpeningTransactionsFromClosingTransactions));
        }
        else
        {
            query = new Query(queryStr(LedgerTransferOpeningTransFromClosingTrans));
        }

        QueryBuildDataSource qbdsclosingTrans, qbdsmainAccountdimensionAttribute, qbdsnewOpeningTrans;
    
        qbdsclosingTrans = query.dataSourceName(closingTransactions);
        qbdsclosingTrans.addSelectionField(fieldNum(LedgerTransferOpeningSumTmp, TransactionCurrencyAmount), SelectionField::Sum);
        qbdsclosingTrans.addSelectionField(fieldNum(LedgerTransferOpeningSumTmp, AccountingCurrencyAmount), SelectionField::Sum);
        qbdsclosingTrans.addSelectionField(fieldNum(LedgerTransferOpeningSumTmp, ReportingCurrencyAmount), SelectionField::Sum);
        qbdsclosingTrans.addSelectionField(fieldNum(LedgerTransferOpeningSumTmp, Quantity), SelectionField::Sum);
        
        qbdsclosingTrans.addRange(fieldNum(LedgerTransferOpeningSumTmp, SessionId)).value(int2Str(processSession));
        qbdsclosingTrans.addRange(fieldNum(LedgerTransferOpeningSumTmp, UTCTimestamp)).value(DateTimeUtil::toStr(processTimestamp));
        qbdsclosingTrans.addRange(fieldNum(LedgerTransferOpeningSumTmp, Posting)).value(enum2str(LedgerPostingType::Closing));
        qbdsclosingTrans.addRange(fieldNum(LedgerTransferOpeningSumTmp, ClosingType)).value(strfmt("%1,%2",enum2str(LedgerAccountType::AccountStatus),enum2str(LedgerAccountType::AccountOperations)));

        qbdsmainAccountdimensionAttribute = query.dataSourceTable(tableNum(DimensionAttribute));
        qbdsmainAccountdimensionAttribute.addRange(fieldNum(DimensionAttribute, BackingEntityType)).value(int2Str(tableNum(DimAttributeMainAccount)));

        qbdsnewOpeningTrans = query.dataSourceName(newOpeningTransactions);
        qbdsnewOpeningTrans.addRange(fieldNum(LedgerTransferOpeningSumTmp, SessionId)).value(int2Str(processSession));
        qbdsnewOpeningTrans.addRange(fieldNum(LedgerTransferOpeningSumTmp, UTCTimestamp)).value(DateTimeUtil::toStr(processTimestamp));
        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processQuery</Name>
				<Source><![CDATA[
    private void processQuery(LedgerTransferOpeningType _transactionType, QueryRun _queryRun, RecId _dimensionAttributeSet, LedgerParameters _ledgerParameters)
    {
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        MainAccount                             mainAccount;
        MainAccount                             openingMainAccount;
        MainAccountNum                          currentAccountId;
        GeneralJournalAccountEntryDimension     generalJournalAccountEntryDimension;
        DimensionAttributeValue                 dimAttrValue;
        DimensionAttributeSetItem               dimAttributeSetItem;
        DimensionAttributeLevelValueView        dimAttrLevelValueView;
        GeneralJournalAccountEntryHash          generalJournalAccountEntryHash;
        boolean                                 isMainCurrentAccountsSame;
        RecId                                   dimAttrValueId;
        RecId                                   mainAccountRecId;
        int                                     i;

        // <GEERU>
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        DimensionStorageSegment                 mainAccountStorageSegment;
        DimensionStorageSegment                 currentAccountStorageSegment;
        Map                                     dimensionSpecifiers;
        Map                                     profitLossSelectedDimensionSpecifiers;
        boolean                                 isPostingAccount;
        container                               dimAttrSetAccountEntryHashSpecifierKey;

        // Initialize dimensionSpecifiers and profitLossSelectedDimensionSpecifiers
        if (_transactionType == LedgerTransferOpeningType::ProfitLoss)
        {
            profitLossSelectedDimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
            for (i = 1; i <= profitLossDimAttrValueSetStorage.elements(); i++)
            {
                dimAttrValueId = profitLossDimAttrValueSetStorage.getValueByIndex(i);

                LedgerDimensionDefaultingEngine::insertDimensionSpecifer(profitLossSelectedDimensionSpecifiers, profitLossDimAttrValueSetStorage.getAttributeByIndex(i), DimensionAttributeValue::getDisplayStringForAttributeValue(dimAttrValueId), dimAttrValueId, profitLossDimAttrValueSetStorage.getHashKeyByIndex(i));
            }

            if (!_dimensionAttributeSet)
            {
                // The dimension values are constant for this case
                dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
            }
        }
        else if (_transactionType == LedgerTransferOpeningType::BalanceSheet)
        {
            dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
        }
        else
        {
            // use wrongUseOfFunction because this is a development error
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        _queryRun.setRecord(generalJournalAccountEntry);

        countTransactionsRead = 0;
        while (_queryRun.next())
        {
            countTransactionsRead++;
            generalJournalAccountEntry = _queryRun.get(tableNum(GeneralJournalAccountEntry)) as GeneralJournalAccountEntry;
            generalJournalAccountEntryDimension = _queryRun.get(tableNum(GeneralJournalAccountEntryDimension)) as GeneralJournalAccountEntryDimension;
            mainAccountRecId = generalJournalAccountEntryDimension.MainAccount;

            // Extract dimension values
            if (_dimensionAttributeSet)
            {
                dimAttrSetAccountEntryHashSpecifierKey = [_dimensionAttributeSet, generalJournalAccountEntryDimension.GeneralJournalAccountEntryHash];

                if (dimAttrSetAccountEntryHashSpecifiers.exists(dimAttrSetAccountEntryHashSpecifierKey))
                {
                    dimensionSpecifiers = dimAttrSetAccountEntryHashSpecifiers.lookup(dimAttrSetAccountEntryHashSpecifierKey);
                }
                else
                {
                    dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
                    while select DimensionAttribute from dimAttributeSetItem
                        group by dimAttributeSetItem.DimensionAttribute, dimAttrLevelValueView.DisplayValue, dimAttrLevelValueView.AttributeValueRecId, dimAttrLevelValueView.AttributeValueHashKey
                            where dimAttributeSetItem.DimensionAttributeSet == _dimensionAttributeSet &&
                                dimAttributeSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll)
                        join RecId from generalJournalAccountEntryHash
                            where generalJournalAccountEntryHash.RecId == generalJournalAccountEntryDimension.GeneralJournalAccountEntryHash
                        outer join DisplayValue, AttributeValueRecId, AttributeValueHashKey, EntityInstance from dimAttrLevelValueView
                            where dimAttrLevelValueView.ValueCombinationRecId == generalJournalAccountEntryHash.LedgerDimension &&
                                dimAttrLevelValueView.DimensionAttribute == dimAttributeSetItem.DimensionAttribute
                    {
                        if (dimAttrLevelValueView.DisplayValue)
                        {
                            LedgerDimensionDefaultingEngine::insertDimensionSpecifer(
                                dimensionSpecifiers,
                                dimAttributeSetItem.DimensionAttribute,
                                dimAttrLevelValueView.DisplayValue,
                                dimAttrLevelValueView.AttributeValueRecId,
                                dimAttrLevelValueView.AttributeValueHashKey,
                                dimAttrLevelValueView.EntityInstance);
                        }
                    }

                    dimAttrSetAccountEntryHashSpecifiers.insert(dimAttrSetAccountEntryHashSpecifierKey, dimensionSpecifiers);
                }
            }

            // Get currentAccount
            if (!mainAccount || mainAccount.RecId != mainAccountRecId)
            {
                mainAccount = MainAccount::find(mainAccountRecId);
                mainAccountStorageSegment = this.getMainAccountStorageSegment(mainAccount.MainAccountId);
                openingMainAccount = null;

                if (!silent)
                {
                    this.displayProgress(mainAccount.MainAccountId);
                }

                //For Spain use transferYearEndAccount as OpeningAccount if useTransferYearEndAccount_ES is true
                if (useTransferYearEndAccount_ES && mainAccount.TransferYearEndAccount_ES)
                {
                    openingMainAccount = MainAccount::find(mainAccount.TransferYearEndAccount_ES);
                    if (openingMainAccount)
                    {
                        isPostingAccount = openingMainAccount.isBalanceSheetAccount() || openingMainAccount.isProfitAndLossAccount();
                        if (!isPostingAccount)
                        {
                            throw error (strFmt("@SYS322193", mainAccount.MainAccountId, openingMainAccount.MainAccountId, openingMainAccount.Type));
                        }
                    }
                }

                // Check to see if the specified openingAccount exist.
                if (!useTransferYearEndAccount_ES && mainAccount.OpeningAccount)
                {
                    openingMainAccount = MainAccount::find(mainAccount.OpeningAccount);
                    if (openingMainAccount)
                    {
                        isPostingAccount = openingMainAccount.isBalanceSheetAccount() || openingMainAccount.isProfitAndLossAccount();
                        if (!isPostingAccount)
                        {
                            throw error (strFmt("@SYS68253", mainAccount.MainAccountId, openingMainAccount.MainAccountId, openingMainAccount.Type));
                        }
                    }
                }

                // Find where to place the opening amount.
                if (_transactionType == LedgerTransferOpeningType::ProfitLoss)
                {
                    // <GEERU>
                    if ((countryRegion_RU
                        && mainAccount.Type == DimensionLedgerAccountType::ProfitAndLoss)
                        || !countryRegion_RU)
                    {
                        // </GEERU>
                        currentAccountId = openingMainAccount ? openingMainAccount.MainAccountId:
                                      methodOperations == OpeningMethod::Reset ? transferResult  : mainAccount.MainAccountId;
                        // <GEERU>
                    }
                    else
                    {
                        currentAccountId = mainAccount.OpeningAccount ? openingMainAccount.MainAccountId : transferResult;
                    }
                    // </GEERU>
                }
                else if (_transactionType == LedgerTransferOpeningType::BalanceSheet)
                {
                    // methodStatus verses methodOperations is the only difference between the two code paths
                    currentAccountId = openingMainAccount ? openingMainAccount.MainAccountId:
                        methodStatus == OpeningMethod::Reset ? transferResult : mainAccount.MainAccountId;
                }

                // Initilize isMainCurrentAccountsSame
                isMainCurrentAccountsSame = (mainAccount.MainAccountId == currentAccountId);
                if (!isMainCurrentAccountsSame)
                {
                    dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(mainAccountDimAttrId, MainAccount::findByMainAccountId(currentAccountId).RecId, false, true);
                    currentAccountStorageSegment = DimensionStorageSegment::constructFromValue(currentAccountId, dimAttrValue);
                }
            }

            this.createPostingTransactions(this.createPostingTransactionParameters(
                generalJournalAccountEntry,
                _transactionType,
                _dimensionAttributeSet,
                mainAccountStorageSegment,
                dimensionSpecifiers,
                profitLossSelectedDimensionSpecifiers,
                isMainCurrentAccountsSame,
                currentAccountStorageSegment,
                generalJournalAccountEntryDimension,
                _ledgerParameters));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPostingTransactionParameters</Name>
				<Source><![CDATA[
    private LedgerTransferOpeningCreatePostingTransactionsParameters createPostingTransactionParameters(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerTransferOpeningType _transactionType,
        RecId _dimensionAttributeSet,
        DimensionStorageSegment _mainAccountStorageSegment,
        Map _dimensionSpecifiers,
        Map _profitLossSelectedDimensionSpecifiers,
        boolean _isMainCurrentAccountsSame,
        DimensionStorageSegment _currentAccountStorageSegment,
        GeneralJournalAccountEntryDimension _generalJournalAccountEntryDimension,
        LedgerParameters _ledgerParameters)
    {
        LedgerTransferOpeningCreatePostingTransactionsParameters parameters = LedgerTransferOpeningCreatePostingTransactionsParameters::construct();

        parameters.generalJournalAccountEntry = _generalJournalAccountEntry;
        parameters.transactionType = _transactionType;
        parameters.dimensionAttributeSet = _dimensionAttributeSet;
        parameters.mainAccountStorageSegment = _mainAccountStorageSegment;
        parameters.dimensionSpecifiers = _dimensionSpecifiers;
        parameters.profitLossSelectedDimensionSpecifiers = _profitLossSelectedDimensionSpecifiers;
        parameters.isMainCurrentAccountsSame = _isMainCurrentAccountsSame;
        parameters.currentAccountStorageSegment = _currentAccountStorageSegment;
        parameters.generalJournalAccountEntryDimension = _generalJournalAccountEntryDimension;
        parameters.ledgerParameters = _ledgerParameters;

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPostingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the posted transactions.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>LedgerTransferOpeningCreatePostingTransactionsParameters</c> instance which contains the parameters used to create posted transactions.
    /// </param>
    [Wrappable(true)]
    protected final void createPostingTransactions(LedgerTransferOpeningCreatePostingTransactionsParameters _parameters)
    {
        LedgerDimensionAccount currentLedgerDimension;
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry = _parameters.generalJournalAccountEntry;

        // **** Create posting transactions ****
        generalJournalAccountEntry.LedgerDimension = this.getLedgerDimensionForType(_parameters.transactionType, _parameters.dimensionAttributeSet, _parameters.mainAccountStorageSegment, _parameters.dimensionSpecifiers, _parameters.profitLossSelectedDimensionSpecifiers);
        
        if (_parameters.isMainCurrentAccountsSame)
        {
            currentLedgerDimension = generalJournalAccountEntry.LedgerDimension;
        }
        else
        {
            currentLedgerDimension = this.getLedgerDimensionForType(_parameters.transactionType, _parameters.dimensionAttributeSet, _parameters.currentAccountStorageSegment, _parameters.dimensionSpecifiers, _parameters.profitLossSelectedDimensionSpecifiers);
        }

        // set the GJE fields needed for the calls below because GJE table is not in the query for performance reasons
        generalJournalEntry.PostingLayer = _parameters.generalJournalAccountEntryDimension.PostingLayer;

        // Calculate ultimo postings.
        if (_parameters.ledgerParameters.PeriodClosingPosting)
        {
            this.addAccountSumUltimo(generalJournalEntry, generalJournalAccountEntry, currentLedgerDimension);
        }

        // Calculate Primo postings.
        this.addAccountSumPrimo(generalJournalEntry, generalJournalAccountEntry, currentLedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processQueryForPublicSector</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the query based on the transaction type.
    /// </summary>
    /// <param name="_queryRun">
    /// The query to process.
    /// </param>
    /// <param name="_ledgerOpenCloseTransType">
    /// The transaction type of the process, either open or close.
    /// </param>
    protected void processQueryForPublicSector(QueryRun _queryRun, LedgerOpenCloseTransType _ledgerOpenCloseTransType)
    {
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        GeneralJournalEntry                     generalJournalEntry;
        LedgerDimensionAccount                  ledgerDimensionAccountOffset;
        TransDate                               transDate;
        boolean                                 validOffsetAccount;
        int                                     dimensionCount;
        DimensionStorageSegment                 mainAccountStorageSegment;
        Map                                     dimStorageSegments;
        MainAccount                             mainAccount;
        DimensionAttributeSetItem               dimAttrSetItem;
        MainAccountRecId                        mainAccountRecId;
        GeneralJournalAccountEntryDimension     generalJournalAccountEntryDimension;
        FundClassValueAll                       fundClassValueAll;
        LedgerFund                              ledgerFund;
        DimensionAttributeLevelValueView        dimAttrLevelValueView;
        GeneralJournalAccountEntryHash          generalJournalAccountEntryHash;
        DimensionAttributeValueCombination      account;
        SysInfologEnumerator                    infologEnumerator;
        int                                     levels;
        Set                                     errorList = new Set(Types::String);
        SetEnumerator                           errorEnum;

        Map                                     dimensionSpecifiers;
        container                               dimAttrSetAccountEntryHashSpecifierKey;
        DimensionAttributeSetItem               dimAttributeSetItem;

        dimStorageSegments = new Map(Types::Int64, Types::Class);
        dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();

        _queryRun.setRecord(generalJournalAccountEntry);

        setPrefix("@PublicSector:LedgerTransferOpening_GenerateClosingTransactionsWarningPS");

        while (_queryRun.next())
        {
            validOffsetAccount = false;

            generalJournalAccountEntry = _queryRun.get(tablenum(GeneralJournalAccountEntry)) as GeneralJournalAccountEntry;
            generalJournalAccountEntryDimension = _queryRun.get(tableNum(GeneralJournalAccountEntryDimension)) as GeneralJournalAccountEntryDimension;

            mainAccountRecId = generalJournalAccountEntryDimension.MainAccount;

            if (mainAccountRecId == 0)
            {
                continue;
            }

            if (allDimAttributes)
            {
                // Extract dimension values
                dimAttrSetAccountEntryHashSpecifierKey = [allDimAttributes, generalJournalAccountEntryDimension.GeneralJournalAccountEntryHash];

                if (dimAttrSetAccountEntryHashSpecifiers.exists(dimAttrSetAccountEntryHashSpecifierKey))
                {
                    dimensionSpecifiers = dimAttrSetAccountEntryHashSpecifiers.lookup(dimAttrSetAccountEntryHashSpecifierKey);
                }
                else
                {
                    dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
                    
                    while select DimensionAttribute from dimAttributeSetItem
                    group by dimAttributeSetItem.DimensionAttribute, dimAttrLevelValueView.DisplayValue, dimAttrLevelValueView.AttributeValueRecId, dimAttrLevelValueView.AttributeValueHashKey
                        where dimAttributeSetItem.DimensionAttributeSet == allDimAttributes &&
                            dimAttributeSetItem.EnumerationValue == NoYes::Yes
                    join RecId from generalJournalAccountEntryHash
                        where generalJournalAccountEntryHash.RecId == generalJournalAccountEntryDimension.GeneralJournalAccountEntryHash
                    outer join DisplayValue, AttributeValueRecId, AttributeValueHashKey from dimAttrLevelValueView
                        where dimAttrLevelValueView.ValueCombinationRecId == generalJournalAccountEntryHash.LedgerDimension &&
                            dimAttrLevelValueView.DimensionAttribute == dimAttributeSetItem.DimensionAttribute
                    {
                        if (dimAttrLevelValueView.DisplayValue)
                        {
                            LedgerDimensionDefaultingEngine::insertDimensionSpecifer(dimensionSpecifiers,
                                dimAttributeSetItem.DimensionAttribute,
                                dimAttrLevelValueView.DisplayValue,
                                dimAttrLevelValueView.AttributeValueRecId,
                                dimAttrLevelValueView.AttributeValueHashKey);
                        }
                    }

                    dimAttrSetAccountEntryHashSpecifiers.insert(dimAttrSetAccountEntryHashSpecifierKey, dimensionSpecifiers);
                }
            }

            mainAccount = MainAccount::find(mainAccountRecId);
            mainAccountStorageSegment = this.getMainAccountStorageSegment(mainAccount.MainAccountId);

            try
            {
                generalJournalAccountEntry.LedgerDimension = this.getLedgerDimension(mainAccountStorageSegment,
            dimensionSpecifiers);
            }
            catch
            {
                levels = xGlobal::infologLine();
                infologEnumerator = SysInfologEnumerator::newData(infolog.export());

                if (!silent)
                {
                    this.displayProgressForPublicSector(mainAccount.MainAccountId);
                }

                errorList.add(account.DisplayValue);
                infologEnumerator.delete(levels-1);
                infolog.clear();
                infolog.import(infologEnumerator.parmData());
                continue;
            }

            ledgerFund = this.getFundFromAccount(generalJournalAccountEntry.LedgerDimension);

            if (selectFund)
            {
                if (!ledgerFund)
                {
                    continue;
                }
                else if ((ledgerFund.FundNumber < fromFund) || (ledgerFund.FundNumber > toFund))
                {
                    continue;
                }
            }

            if (!silent)
            {
                this.displayProgressForPublicSector(mainAccount.MainAccountId);
            }

            transDate = (_ledgerOpenCloseTransType == LedgerOpenCloseTransType::Close) ? periodEnd : periodNext;

            fundClassValueAll = PublicSectorUtils::convertFundClassToFundClassAll(ledgerFund.FundClass);

            if (this.shouldSkipOffsetAccountForRealAccounts_PSN(generalJournalAccountEntry.LedgerDimension))
            {
                generalJournalEntry.PostingLayer = generalJournalAccountEntryDimension.PostingLayer;

                this.addAccountSumPrimo(generalJournalEntry, generalJournalAccountEntry, generalJournalAccountEntry.LedgerDimension);
            }
            else
            {
                //
                // The Debit/Credit sign parameter does not matter, we assume a single account to be returned, and whether
                // we are closing or opening will determine the amount of the transaction from the posting definition
                //
                ledgerDimensionAccountOffset = this.getOffsetAccount(fundClassValueAll, _ledgerOpenCloseTransType, generalJournalAccountEntry.LedgerDimension, DebitCredit::Credit, transDate);

                if (ledgerDimensionAccountOffset)
                {
                    // set the GJE fields needed for the calls below because GJE table is not in the query for performance reasons
                    generalJournalEntry.PostingLayer = generalJournalAccountEntryDimension.PostingLayer;

                    // Add the account and offset account to the temporary work table
                    if (_ledgerOpenCloseTransType == LedgerOpenCloseTransType::Open)
                    {
                        this.addAccountSumPrimo(generalJournalEntry, generalJournalAccountEntry, ledgerDimensionAccountOffset);
                    }
                    else
                    {
                        this.addAccountSumUltimo(generalJournalEntry, generalJournalAccountEntry, ledgerDimensionAccountOffset);
                    }
                }
                else
                {
                    checkFailed(strfmt("@SPS574", LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
                }
            }
        }

        errorEnum = errorList.getEnumerator();
        while (errorEnum.moveNext())
        {
            warning(errorEnum.current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the progress text.
    /// </summary>
    /// <param name = "text">
    /// The progress text.
    /// </param>
    void progressUpdate(str text)
    {
        if (progress != null)
        {
            progress.setText(text);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the operations to create closing and opening transactions.
    /// </summary>
    /// <exception cref="M:Exception::Deadlock">
    /// A transaction deadlock condition exists in the database.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    /// A conflict with another transaction occurred in the database and the transaction was not successful.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    /// A conflict with another transaction occurred in the database.
    /// </exception>
    public void run()
    {
        GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes([
            [#isoCZ, GlobalizationConstants::FeatureReferenceEEU00030],
            [#isoHU, GlobalizationConstants::FeatureReferenceEEU00030] ],
            funcName()
        );

        Counter                                 progressTotal;
        QueryRun                                queryRun;
        LedgerPostingGeneralJournalController   generalJournalController;
        // <GCN>
        GeneralJournalEntry                     generalJournalEntry;
        GeneralJournalEntry_W                   generalJournalEntryW;
        FiscalCalendarPeriod                    fiscalCalendarPeriod;
        // </GCN>
        DimensionAttributeSetItem               dimAttrSetItem;
        BatchHeader                             batchHeader;
        LedgerTransferOpening                   primaryTask;
        LedgerTransferOpening                   deleteTask;
        LedgerTransferOpening                   balanceSheetTask;
        LedgerTransferOpening                   profitLossTask;
        LedgerTransferOpening                   nominalTask;
        LedgerTransferOpening                   realTask;
        LedgerTransferOpening                   linkCreationTask;
        LedgerTransferOpening                   postingTask;
        LedgerTransferOpening                   cleanupTask;
        AccountCloseType                        accountCloseType;
        LedgerOpenCloseTransType                ledgerOpenCloseTransType;

        periodStart = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, periodEnd);

        switch (processState)
        {
            case LedgerTransferOpeningProcessState::TransferOpening:
                batchHeader = BatchHeader::getCurrentBatchHeader();
                if (batchHeader == null)
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                if (this.isInBatch() && this.isBatchAlreadyRunning(this.parmCurrentBatch().BatchJobId))
                {
                    throw error(strFmt("@GeneralLedger:LedgerTransferOpeningExistingBatchError", Ledger::name()));
                }

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    // TASK: delete
                    deleteTask = this.createTask(LedgerTransferOpeningProcessState::Delete);

                    batchHeader.addRuntimeTask(deleteTask, this.parmCurrentBatch().RecId);

                    if (methodOperations == OpeningMethod::Reset
                        && methodStatus == OpeningMethod::Reset)
                    {
                        // stop because only the existing opening balances should be deleted
                        batchHeader.save();

                        this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                        return;
                    }

                    // TASK: balance sheet
                    balanceSheetTask = this.createTask(LedgerTransferOpeningProcessState::BalanceSheet, LedgerTransferOpeningType::BalanceSheet);

                    batchHeader.addRuntimeTask(balanceSheetTask, this.parmCurrentBatch().RecId);

                    if (deleteTask != null)
                    {
                        // the BS task is dependent on the delete task
                        batchHeader.addDependency(balanceSheetTask, deleteTask, BatchDependencyStatus::Finished);
                    }

                    // TASK: profit and loss
                    profitLossTask = this.createTask(LedgerTransferOpeningProcessState::ProfitLoss, LedgerTransferOpeningType::ProfitLoss);

                    batchHeader.addRuntimeTask(profitLossTask, this.parmCurrentBatch().RecId);

                    if (deleteTask != null)
                    {
                        // the PL task is dependent on the delete task
                        batchHeader.addDependency(profitLossTask, deleteTask, BatchDependencyStatus::Finished);
                    }

                    // TASK: post to GL
                    postingTask = this.createTask(LedgerTransferOpeningProcessState::PostToGL);

                    batchHeader.addRuntimeTask(postingTask, this.parmCurrentBatch().RecId);

                    // the post to GL task is dependent on the BS and PL tasks
                    batchHeader.addDependency(postingTask, balanceSheetTask, BatchDependencyStatus::Finished);
                    batchHeader.addDependency(postingTask, profitLossTask, BatchDependencyStatus::Finished);

                    // TASK: Create the task that will manage the cleanup
                    cleanupTask = this.createTask(LedgerTransferOpeningProcessState::Cleanup);

                    batchHeader.addRuntimeTask(cleanupTask, this.parmCurrentBatch().RecId);

                    // the cleanup task is dependent on the posting task, whether it finishes or fails
                    batchHeader.addDependency(cleanupTask, postingTask, BatchDependencyStatus::FinishedOrError);

                    batchHeader.save();

                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::Delete:
                silent = true;

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    this.cleanupTemporaryProcessingTables(SysOperationExecutionMode::Synchronous);
                    this.updateLastRunDate(true);

                    // <GSA>
                    if (ledgerParameters.IsZakatEnabled_SA)
                    {
                        this.postZakatValue_SA();
                    }
                    // </GSA>

                    if (ledgerParameters.DeleteOpening || methodStatus == OpeningMethod::Reset)
                    {
                        if (LedgerTransferOpeningCleanupAwarenessValidationFlight::instance().isEnabled())
                        {
                            if (LedgerTransSettlement::isLedgerSettlementsEnabled())
                            {
                                this.validateBeginningBalanceTransactionsNotSettled();
                            }
                        }
                        else
                        {
                            if (isAdvancedAwarenessOptsParmEnabled)
                            {
                                this.validateBeginningBalanceTransactionsNotSettled();
                            }
                        }

                        this.deleteExistingRecords();

                        LedgerFiscalCloseHistory::updateYearClosedHistoryForReversal(closingFiscalCalendarYearRecId);
					}

                    if (isAdvancedAwarenessOptsParmEnabled)
                    {
                        GeneralJournalAccountEntrySummarized::deleteReversedSummaryReferences();
                    }

                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::BalanceSheet:
                batchHeader = BatchHeader::getCurrentBatchHeader();
                if (batchHeader == null)
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    ttsbegin;

                    if (this.parmTransferDimensions())
                    {
                        balanceSheetDimensionAttributeSet = allDimAttributes;
                    }

                    this.createLedgerDimensions(ledgerTransferOpeningType);

                    linkCreationTask = this.createTask(LedgerTransferOpeningProcessState::LinkCreation, ledgerTransferOpeningType);

                    batchHeader.addRuntimeTask(linkCreationTask, this.parmCurrentBatch().RecId);

                    this.createHashLinkBundles(batchHeader, linkCreationTask);

                    batchHeader.save();

                    ttscommit;

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }
            case LedgerTransferOpeningProcessState::ProfitLoss:
                batchHeader = BatchHeader::getCurrentBatchHeader();
                if (batchHeader == null)
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    ttsbegin;

                    // Get dimension filtering for profit/loss
                    profitLossCloseAllDimensionAttributeSet = profitLossCloseDimensionEnumeration;
                    if (profitLossCloseAllDimensionAttributeSet)
                    {
                        // Check if no dimensions are selected
                        select firstonly RecId from dimAttrSetItem
                            where dimAttrSetItem.DimensionAttributeSet == profitLossCloseAllDimensionAttributeSet &&
                                dimAttrSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll);

                        if (dimAttrSetItem.RecId == 0)
                        {
                            // Clear because there are no dimensions to filter
                            profitLossCloseAllDimensionAttributeSet = 0;
                        }
                    }

                    this.createLedgerDimensions(ledgerTransferOpeningType);

                    linkCreationTask = this.createTask(LedgerTransferOpeningProcessState::LinkCreation, ledgerTransferOpeningType);

                    batchHeader.addRuntimeTask(linkCreationTask, this.parmCurrentBatch().RecId);

                    this.createHashLinkBundles(batchHeader, linkCreationTask);

                    batchHeader.save();

                    ttscommit;

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::PublicSectorNominal:
                batchHeader = BatchHeader::getCurrentBatchHeader();
                if (batchHeader == null)
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    this.createLedgerDimensionsForPublicSector(ledgerTransferOpeningType, AccountCloseType::Nominal);

                    linkCreationTask = this.createTask(LedgerTransferOpeningProcessState::LinkCreation, ledgerTransferOpeningType);

                    batchHeader.addRuntimeTask(linkCreationTask, this.parmCurrentBatch().RecId);

                    this.createHashLinkBundles(batchHeader, linkCreationTask);

                    batchHeader.save();

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::PublicSectorReal:
                batchHeader = BatchHeader::getCurrentBatchHeader();
                if (batchHeader == null)
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    this.createLedgerDimensionsForPublicSector(ledgerTransferOpeningType, AccountCloseType::Real);

                    linkCreationTask = this.createTask(LedgerTransferOpeningProcessState::LinkCreation, ledgerTransferOpeningType);

                    batchHeader.addRuntimeTask(linkCreationTask, this.parmCurrentBatch().RecId);

                    this.createHashLinkBundles(batchHeader, linkCreationTask);

                    batchHeader.save();

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::HashCreation:
                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    if (this.parmTransferDimensions())
                    {
                        balanceSheetDimensionAttributeSet = allDimAttributes;
                    }

                    // Get dimension filtering for profit/loss
                    profitLossCloseAllDimensionAttributeSet = profitLossCloseDimensionEnumeration;
                    if (profitLossCloseAllDimensionAttributeSet)
                    {
                        // Check if no dimensions are selected
                        select firstonly RecId from dimAttrSetItem
                            where dimAttrSetItem.DimensionAttributeSet == profitLossCloseAllDimensionAttributeSet &&
                                dimAttrSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll);

                        if (dimAttrSetItem.RecId == 0)
                        {
                            // Clear because there are no dimensions to filter
                            profitLossCloseAllDimensionAttributeSet = 0;
                        }
                    }

                    this.createHashLinks(ledgerTransferOpeningType);

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addStartStopBundleRecIdCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::BalanceCreation:
                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    if (ledgerTransferOpeningType == LedgerTransferOpeningType::BalanceSheet)
                    {
                        if (this.parmTransferDimensions())
                        {
                            balanceSheetDimensionAttributeSet = allDimAttributes;
                        }

                        queryRun = new QueryRun(this.initQuery(LedgerTransferOpeningType::BalanceSheet));
                        this.processQuery(LedgerTransferOpeningType::BalanceSheet, queryRun, balanceSheetDimensionAttributeSet, ledgerParameters);
                    }
                    else if (ledgerTransferOpeningType == LedgerTransferOpeningType::ProfitLoss)
                    {
                        // Get dimension filtering for profit/loss
                        profitLossCloseAllDimensionAttributeSet = profitLossCloseDimensionEnumeration;
                        if (profitLossCloseAllDimensionAttributeSet)
                        {
                            // Check if no dimensions are selected
                            select firstonly RecId from dimAttrSetItem
                                where dimAttrSetItem.DimensionAttributeSet == profitLossCloseAllDimensionAttributeSet &&
                                    dimAttrSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll);

                            if (dimAttrSetItem.RecId == 0)
                            {
                                // Clear because there are no dimensions to filter
                                profitLossCloseAllDimensionAttributeSet = 0;
                            }
                        }

                        // Initialize class variables used by the query/process methods
                        profitLossDimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(profitLossDefaultDimensions);

                        queryRun = new QueryRun(this.initQuery(LedgerTransferOpeningType::ProfitLoss));
                        this.processQuery(LedgerTransferOpeningType::ProfitLoss, queryRun, profitLossCloseAllDimensionAttributeSet, ledgerParameters);
                    }
                    else
                    {
                        throw error(Error::wrongUseOfFunction(funcName()));
                    }

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addStartStopBundleRecIdCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    activityContext.addCustomProperty('ScaleTransactionsRead', ApplicationCommonInstrumentationMagnitude::log10Magnitude(countTransactionsRead));
                    activityContext.addCustomProperty('ScaleOpeningBalancesCreated', ApplicationCommonInstrumentationMagnitude::log10Magnitude(countOpeningBalancesCreated));

                    return;
                }

            case LedgerTransferOpeningProcessState::BalanceSheetCreationDetails:
                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    ttsbegin;

                    if (isAdvancedAwarenessOptsParmEnabled)
                    {
                        this.insertLedgerTransferOpeningDetailsAndSummarizedAccountEntries();
                    }

                    ttscommit;

                    return;
                }

            case LedgerTransferOpeningProcessState::LinkCreation:
                batchHeader = BatchHeader::getCurrentBatchHeader();
                if (batchHeader == null)
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    ttsbegin;

                    this.createDimensionLinks(ledgerTransferOpeningType);

                    this.createBalanceCreationBundles(batchHeader, ledgerTransferOpeningType);

                    batchHeader.save();

                    ttscommit;

                    this.addLedgerTransferOpeningTypeCustomPropertyToActivityContext(activityContext);
                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::PostToGL:
                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    if (!ledgerParameters.DeleteOpening)
                    {
                        this.adjustPrimoTrans();
                    }

                    generalJournalController = LedgerPostingGeneralJournalController::newForGeneralLedgerCore();

                    if (ledgerParameters.PeriodClosingPosting)
                    {
                        // <GCN>
                        if (LedgerParameters::isChineseVoucher_CN())
                        {
                            voucherTypeId_CN = LedgerVoucherType_CN::find(ledgerVoucherTypeRecId_CN).Id;
                            LedgerFiscalCloseChineseVoucher_CN ledgerFiscalCloseChineseVoucher_CN = LedgerFiscalCloseChineseVoucher_CN::newForFiscalYearClose(
                                voucher_CN,
                                voucherTypeId_CN,
                                FiscalCalendarYear::find(closingFiscalCalendarYearRecId),
                                ledgerParameters);

                            ledgerFiscalCloseChineseVoucher_CN.setChineseVoucherUsedForClosingPeriod();
                        }
                        // </GCN>

                        this.insertClosingTrans(generalJournalController);    //Insert ultimo transactions.
                        this.insertOnSystemAccount(generalJournalController); //Insert ultimo and primo posterings on a system account to keep the overview.
                    }

                    // Update period status if necessary
                    // Once the LedgerTransferOpeningYearPermanentlyClosedFlight flight is deprecated, please remove this block
                    // Closing the year should happen after all the works are completed
                    if (ledgerParameters.YearClosed && !isFiscalYearPermanentlyClosedFlightEnabled)
                    {
                        LedgerFiscalCalendar::updateYearCloseByCalendarLedgerDate(calendarRecId,Ledger::current(),periodEnd);
                    }

                    this.insertOpeningTrans(generalJournalController); //Insert primo transactions.

                    // Flush the cached value of the last opening balances transfer
                    if (LedgerFiscalCloseLastYearEndCloseDateCacheFlight::instance().isEnabled())
                    {
                        LedgerCache::removeValue(LedgerCacheScope::LastClosingDateByLedger, [Ledger::current()]);
                    }
                    else
                    {
                        LedgerCache::clearScope(LedgerCacheScope::LastClosingDateByLedger);
                    }

                    ttsbegin;
                    generalJournalController.transfer();

                    if (isAdvancedAwarenessOptsParmEnabled)
                    {
                        this.insertGeneralJournalAccountEntryDetails(generalJournalController);
                        this.insertGeneralJournalAccountEntryClosingDetails(voucher, closingFiscalCalendarPeriodRecId, processSession, processTimestamp);
                    }

                    LedgerFiscalCloseHistory::createYearClosedHistory(closingFiscalCalendarYearRecId, voucher);

                    if (!silent)
                    {
                        info(strFmt("@SYS67161", periodStart, periodEnd));
                    }

                    // Update period status if necessary
                    // This must be done after all postings are successfully completed.
                    // If the fiscal year gets permanently closed, before succesfully completing the year-end close process,
                    // users will never be able to reopen the fiscal year to re-run the process.
                    // The fiscal year can only get permanently closed, only if the year-end close process is successfully completed.
                    if (ledgerParameters.YearClosed && isFiscalYearPermanentlyClosedFlightEnabled)
                    {
                        LedgerFiscalCalendar::updateYearCloseByCalendarLedgerDate(calendarRecId,Ledger::current(),periodEnd);
                    }

                    ttscommit;

                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }

            case LedgerTransferOpeningProcessState::Cleanup:
                using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                    enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
                {
                    this.cleanupTemporaryProcessingTables(SysOperationExecutionMode::ScheduledBatch);
                    this.updateLastRunDate();

                    this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                    return;
                }
        }

        // capture the values used to support concurrency right here because they
        // have to be the same for each instance in the batch processing and this is
        // the start of the code that is only run for non-batch and to set up a batch
        processSession = sessionId();
        processTimestamp = DateTimeUtil::utcNow();
        detailsExecutionId = newGuid();

        batchHeader = BatchHeader::getCurrentBatchHeader();
        if (batchHeader != null)
        {
            using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerTransferOpening(
                enum2Symbol(enumNum(LedgerTransferOpeningProcessState), processState)))
            {
                primaryTask = this.createTask(LedgerTransferOpeningProcessState::TransferOpening);
                if (this.parmCurrentBatch())
                {
                    batchHeader.addRuntimeTask(primaryTask, this.parmCurrentBatch().RecId);
                }
                else
                {
                    batchHeader.addTask(primaryTask);
                }
                batchHeader.save();

                this.addLedgerTransferOpeningCustomPropertiesToActivityContext(activityContext);

                return;
            }
        }

        try
        {
            if (!silent)
            {
                this.progressInit("@SYS28702", progressTotal, #AviFormLetter);
                progress.setText("@SYS26577");
            }

            // TASK: LedgerTransferOpeningProcessState::Delete
            this.checkParameters();
            this.cleanupTemporaryProcessingTables(SysOperationExecutionMode::Synchronous);
            this.updateLastRunDate(true);

            // <GSA>
            if (ledgerParameters.IsZakatEnabled_SA)
            {
                this.postZakatValue_SA();
            }
            // </GSA
            if (ledgerParameters.DeleteOpening || methodStatus == OpeningMethod::Reset)
            {
                // Delete existing opening and system created ultimo records
                this.deleteExistingRecords();

                if (methodOperations == OpeningMethod::Reset &&
                    methodStatus == OpeningMethod::Reset)
                {
                    // Flush the cached value of the last opening balances transfer
                    if (LedgerFiscalCloseLastYearEndCloseDateCacheFlight::instance().isEnabled())
                    {
                        LedgerCache::removeValue(LedgerCacheScope::LastClosingDateByLedger, [Ledger::current()]);
                    }
                    else
                    {
                        LedgerCache::clearScope(LedgerCacheScope::LastClosingDateByLedger);
                    }

                    // dialog specified that only existing opening balances should be deleted
                    return;
                }
            }

            // use min/max because backward compatible option is to process everything at once
            startRecId = int64Min();
            endRecId = int64Max();

            // TASK: LedgerTransferOpeningProcessState::ProfitLoss
            ledgerTransferOpeningType = LedgerTransferOpeningType::ProfitLoss;

            // Get dimension filtering for profit/loss
            profitLossCloseAllDimensionAttributeSet = profitLossCloseDimensionEnumeration;
            if (profitLossCloseAllDimensionAttributeSet)
            {
                // Check if no dimensions are selected
                select firstonly RecId from dimAttrSetItem
                    where dimAttrSetItem.DimensionAttributeSet == profitLossCloseAllDimensionAttributeSet &&
                        dimAttrSetItem.EnumerationValue == enum2int(LedgerCloseSingleAll::CloseAll);
                if (dimAttrSetItem.RecId == 0)
                {
                    // Clear because there are no dimensions to filter
                    profitLossCloseAllDimensionAttributeSet = 0;
                }
            }

            // Initialize class variables used by the query/process methods
            profitLossDimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(profitLossDefaultDimensions);
            if (this.parmTransferDimensions())
            {
                balanceSheetDimensionAttributeSet = allDimAttributes;
            }

            this.createLedgerDimensions(ledgerTransferOpeningType);
            this.createHashLinks(ledgerTransferOpeningType);
            this.createDimensionLinks(ledgerTransferOpeningType);

            queryRun = new QueryRun(this.initQuery(ledgerTransferOpeningType));
            this.processQuery(ledgerTransferOpeningType, queryRun, profitLossCloseAllDimensionAttributeSet, ledgerParameters);

            // TASK: LedgerTransferOpeningProcessState::BalanceSheet
            ledgerTransferOpeningType = LedgerTransferOpeningType::BalanceSheet;

            this.createLedgerDimensions(ledgerTransferOpeningType);
            this.createHashLinks(ledgerTransferOpeningType);
            this.createDimensionLinks(ledgerTransferOpeningType);

            queryRun = new QueryRun(this.initQuery(ledgerTransferOpeningType));
            this.processQuery(ledgerTransferOpeningType, queryRun, balanceSheetDimensionAttributeSet, ledgerParameters);

            // TASK: LedgerTransferOpeningProcessState::PostToGL
            if (!ledgerParameters.DeleteOpening)
            {
                this.adjustPrimoTrans();
            }

            // Insert the new transactions.
            generalJournalController = LedgerPostingGeneralJournalController::newForGeneralLedgerCore();

            if (ledgerParameters.PeriodClosingPosting)
            {
                // <GCN>
                if (LedgerParameters::isChineseVoucher_CN())
                {
                    voucherTypeId_CN = LedgerVoucherType_CN::find(ledgerVoucherTypeRecId_CN).Id;
                    LedgerFiscalCloseChineseVoucher_CN ledgerFiscalCloseChineseVoucher_CN = LedgerFiscalCloseChineseVoucher_CN::newForFiscalYearClose(
                        voucher_CN,
                        voucherTypeId_CN,
                        FiscalCalendarYear::find(closingFiscalCalendarYearRecId),
                        ledgerParameters);

                    ledgerFiscalCloseChineseVoucher_CN.setChineseVoucherUsedForClosingPeriod();
                }
                // </GCN>

                this.insertClosingTrans(generalJournalController);    //Insert ultimo transactions.
                this.insertOnSystemAccount(generalJournalController); //Insert ultimo and primo posterings on a system account to keep the overview.
            }

            // Update period status if necessary
            if (ledgerParameters.YearClosed && !isFiscalYearPermanentlyClosedFlightEnabled)
            {
                LedgerFiscalCalendar::updateYearCloseByCalendarLedgerDate(calendarRecId,Ledger::current(),periodEnd);
            }

            this.insertOpeningTrans(generalJournalController); //Insert primo transactions.

            generalJournalController.transfer();

            if (!silent)
            {
                createdTransactions = true;
                progress = null;
            }

            // Update period status if necessary
            if (ledgerParameters.YearClosed && isFiscalYearPermanentlyClosedFlightEnabled)
            {
                LedgerFiscalCalendar::updateYearCloseByCalendarLedgerDate(calendarRecId,Ledger::current(),periodEnd);
            }

            // TASK: LedgerTransferOpeningProcessState::CleanUp
            this.cleanupTemporaryProcessingTables(SysOperationExecutionMode::Synchronous);
            this.updateLastRunDate();
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        if (!silent)
        {
            if (createdTransactions)
            {
                info(strFmt("@SYS67161", periodStart, periodEnd));
            }
            else
            {
                info("@SYS28652");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupTemporaryProcessingTables</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void cleanupTemporaryProcessingTables(SysOperationExecutionMode _executionMode)
    {
        LedgerTransferOpeningCleanupController::createYearEndCloseCleanupJob(
                            isPublicSectorYearEndProcessingEnabled,
                            runReport,
                            processSession,
                            processTimestamp,
                            processState,
                            _executionMode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPreview_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the validation of the preview transactions field that has the batch processing field.
    /// </summary>
    /// <param name="_formCheckBoxControl">
    /// The control for the <c>dialogRunPreview</c> field.
    /// </param>
    /// <returns>
    /// true if the field was modified; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The method will only enable one check box to be checked, either the preview transactions or the
    /// batch processing. The preview form cannot be displayed when it runs in batch mode.
    /// </remarks>
    private boolean runPreview_Modified(FormCheckBoxControl _formCheckBoxControl)
    {
        boolean valueWasModified;

        valueWasModified = _formCheckBoxControl.modified();

        if (valueWasModified)
        {
            runPreview = dialogRunPreview.value();
            this.validateBatchProcessing();
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReport</Name>
				<Source><![CDATA[
    private void runReport()
    {
        if (runReport)
        {
            Args a = new Args();
            a.parmObject(this);
            new MenuFunction(menuitemOutputStr(LedgerTransferOpening),MenuItemType::Output).run(a);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The classes that extend the <c>RunBaseBatch</c> class must override the <c>runsImpersonated</c>
    ///    method and return false, if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFund_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables the <c>dialogFromFund</c> and <c>dialogToFund</c> fields whenever the
    /// <c>dialogSelectFund</c> field is modified.
    /// </summary>
    /// <param name="_formCheckBoxControl">
    /// The control for the <c>dialogSelectFund</c> field.
    /// </param>
    /// <returns>
    /// true if the <c>dialogFromFund</c> field can be edited; otherwise, false .
    /// </returns>
    private boolean selectFund_Modified(FormCheckBoxControl _formCheckBoxControl)
    {
        boolean valueWasModified;
        boolean allowEdit;

        valueWasModified = _formCheckBoxControl.modified();

        if (valueWasModified)
        {
            allowEdit = (dialogSelectFund.value() == NoYes::Yes);

            dialogFromFund.allowEdit(allowEdit);
            dialogToFund.allowEdit(allowEdit);

            if (!allowEdit)
            {
                dialogFromFund.value('');
                dialogToFund.value('');
            }
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimensionSegment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a dimension segment according to the supplied dimension segment value and dimension hierarchy.
    /// </summary>
    /// <param name="_segmentToFind">
    /// The <c>DimensionStorageSegment</c> object to set at the specified index.
    /// </param>
    /// <param name="_dimensionHierarchy">
    /// A dimension hierarchy ID.
    /// </param>
    /// <param name="_dimensionAttributeValue">
    /// An instance of the <c>DimensionAttributeValue</c> class.
    /// </param>
    /// <param name="_dimensionStorage">
    /// An instance of the <c>DimensionStorage</c> class.
    /// </param>
    /// <returns>
    /// true if the value of the supplied <c>DimensionStorageSegment</c> object has been set successfully;
    /// otherwise, false.
    /// </returns>
    private boolean setDimensionSegment(DimensionStorageSegment     _segmentToFind,
                                            DimensionHierarchyId    _dimensionHierarchy,
                                            DimensionAttributeValue _dimensionAttributeValue,
                                            DimensionStorage        _dimensionStorage)
    {
        DimensionHierarchyLevel dimensionHierarchyLevel;

        select firstonly DimensionAttribute from _dimensionAttributeValue where
            _dimensionAttributeValue.RecId == _segmentToFind.parmDimensionAttributeValueId()
            join Level from dimensionHierarchyLevel where
                dimensionHierarchyLevel.DimensionAttribute == _dimensionAttributeValue.DimensionAttribute
                && dimensionHierarchyLevel.DimensionHierarchy == _dimensionHierarchy;

        if (dimensionHierarchyLevel.Level)
        {
            _dimensionStorage.setSegment(dimensionHierarchyLevel.Level, _segmentToFind);
        }

        return dimensionHierarchyLevel.Level;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toFund_Lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the filtered Fund Number lookup.
    /// </summary>
    /// <param name="_formStringControl">
    /// The <c>dialogToFund</c> dialog field control.
    /// </param>
    private void toFund_Lookup(FormStringControl _formStringControl)
    {
        this.performFundLookup(_formStringControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean ret = false;
        Version version = RunBase::getVersion(packedClass);

        // <GCN>
        #LOCALMACRO.List7
                PeriodEnd,
                MethodOperations,
                MethodStatus,
                TransferResult,
                RunReport,
                periodNext,
                voucher,
                acknowledgementDate,
                transferDimensions,
                voucher_CN,
                voucherTypeId_CN
        #ENDMACRO

        #LOCALMACRO.List6
                PeriodEnd,
                MethodOperations,
                MethodStatus,
                TransferResult,
                RunReport,
                periodNext,
                voucher,
                acknowledgementDate,
                transferDimensions
        #ENDMACRO
        // </GCN>

        #LOCALMACRO.List5
                PeriodEnd,
                MethodOperations,
                MethodStatus,
                TransferResult,
                RunReport,
                periodNext,
                voucher,
                acknowledgementDate
        #ENDMACRO

        #LOCALMACRO.List4
                PeriodEnd,
                MethodOperations,
                MethodStatus,
                TransferResult,
                RunReport,
                periodNext,
                voucher
        #ENDMACRO

        switch (version)
        {
            case LedgerTransferOpening::currentVersion:
                [version, #CurrentList] = packedClass;
                ret = true;
                break;

            // <GCN>
            case 7:
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]))
                {
                    [version, #List7] = packedClass;
                    ret = true;
                }
                break;

            case 6:
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]))
                {
                    [version, #List6] = packedClass;
                    ret = true;
                }
                break;
            // </GCN>

            case 5:
                [version, #List5] = packedClass;
                ret = true;
                break;

            case 4:
                [version, #List4] = packedClass;
                ret = true;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation that is required before the process is executed.
    /// </summary>
    /// <param name="calledFrom">
    /// The caller object.
    /// </param>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        LedgerJournalTable      ledgerJournalTable;
        LedgerJournalTrans      ledgerJournalTrans;
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        LedgerFiscalCalendarPeriod ledgerPeriod;
        FiscalCalendarYear      fiscalCalendarYear;
        LedgerInterunitDimensionAttribute ledgerInterunitDimensionAttribute;
        boolean                 ok = true;
        date                    testDate;
        DimensionAttributeSetItem dimAttrSetItem;
        RecId                   dimAttrSetRecId;
        MainAccount             mainAccount;
        // <GCN>
        GeneralJournalEntry    generalJournalEntryLocal;
        // </GCN>

        if (isPublicSectorYearEndProcessingEnabled)
        {
            // First, validate the batch processing. If the user cancels, we don't need to
            // do any further validation as the process will not run
            if (!this.validateBatchProcessing())
            {
                return false;
            }

            ok = dimensionBalancingValidator.checkDimensionBalance();
            ok = this.validateVoucher() && ok;

            ok = this.validateFiscalCalendarData() && ok;

            ok = this.validateFundRange() && ok;

            ok = this.validateJournalizingDefinitions() && ok;

            ok = this.validateCanCloseYear() && ok;

            ok = this.validateAcknowledgementDate() && ok;
        }
        else
        {
            if (!periodName)
            {
                ok = checkFailed(strFmt("@SYS116347" , fieldPName(FiscalCalendarPeriod, Name)));
            }
            if (periodEnd != LedgerFiscalCalendar::findFiscalYearEndDateByDate(calendarRecId, periodEnd))
            {
                testDate = LedgerFiscalCalendar::findClosingPeriodEndDateByDate(calendarRecId, periodEnd);
                ok = checkFailed(strFmt("@SYS18942", testDate));
            }
            else
            {
                if (! LedgerFiscalCalendar::existDate(calendarRecId, periodEnd))
                {
                    ok = checkFailed(strFmt("@SYS16631",periodEnd));
                }
            }

            fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(calendarRecId, periodEnd, FiscalPeriodType::Closing, periodName);
            closingFiscalCalendarPeriodRecId = fiscalCalendarPeriod.RecId;
            closingFiscalCalendarYearRecId = fiscalCalendarPeriod.FiscalCalendarYear;

            FiscalCalendarYear sourceFiscalCalendarYear = FiscalCalendarYear::find(closingFiscalCalendarYearRecId);
            if (!this.doTransactionsExistInSourceFiscalYear(sourceFiscalCalendarYear))
            {
                return checkFailed(strFmt("@GeneralLedger:LedgerTransferOpeningNoTransactionInSourceFiscalYearErr", 
                    sourceFiscalCalendarYear.Name,
                    Ledger::name()));
            }

            periodEnd = LedgerFiscalCalendar::findYearEndClosingPeriodByDate(calendarRecId, periodEnd).StartDate;
            fiscalCalendarPeriod = LedgerFiscalCalendar::findNextPeriodByClosingPeriodStartDate(calendarRecId, periodEnd);
            periodNext = fiscalCalendarPeriod.StartDate;
            fiscalCalendarPeriod = LedgerFiscalCalendar::findOpeningPeriodByNextPeriodStartDate(calendarRecId, periodNext);
            if (fiscalCalendarPeriod == null)
            {
                ok = checkFailed(strFmt("@SYS128560",FiscalCalendar::find(calendarRecId).CalendarId));
            }

            openingFiscalCalendarPeriodRecId = fiscalCalendarPeriod.RecId;
            openingFiscalCalendarYearRecId = fiscalCalendarPeriod.FiscalCalendarYear;
           
            this.checkForLedgerFiscalCalendarYear();

            if (LedgerFiscalCalendar::findLedgerYearByCalendarLedgerDate(calendarRecId, Ledger::current(), periodEnd).Status == FiscalYearStatus::Close)
            {
                ok = checkFailed(strFmt("@SYS77929", periodEnd));
            }

            if (voucher)
            {
                boolean shouldBypassVoucherValidation = false;

                if (ledgerParameters.CheckVoucher == ReuseVoucher::NoDuplicate && ledgerParameters.DeleteOpening)
                {
                    GeneralJournalEntry generalJournalEntry;

                    select firstonly SubledgerVoucher from generalJournalEntry
                        where generalJournalEntry.FiscalCalendarPeriod == openingFiscalCalendarPeriodRecId
                            && generalJournalEntry.AccountingDate == periodNext
                            && generalJournalEntry.Ledger == Ledger::current();

                    shouldBypassVoucherValidation = generalJournalEntry.SubledgerVoucher == voucher;
                }

                if (!shouldBypassVoucherValidation)
                {
                    ok = GeneralLedgerExtension::validateReferenceNumber(calendarRecId, ledgerParameters.CheckVoucher, voucher, periodEnd) &&
                        GeneralLedgerExtension::validateReferenceNumber(calendarRecId, ledgerParameters.CheckVoucher, voucher, periodNext) && ok;
                }
            }
            else if (ledgerParameters.OpeningVoucher && !this.isReversal())
            {
                ok = checkFailed("@SYS57812");
            }

            if (this.isReversal())
            {
                info("@GeneralLedger:UndoPreviousCloseWarning");
            }

            if (ledgerParameters.YearClosed)
            {
                /* if the parameter "YearClosed" is set to YES, then the LedgerCloseFiscalYear
                   validation logic will occur.*/
                   fiscalCalendarYear = FiscalCalendars::findPrevYear(calendarRecId, periodEnd);
                if (fiscalCalendarYear != null && fiscalCalendarYear.currentLedgerYearStatus() == FiscalYearStatus::Open)
                {
                    ok = checkFailed(strFmt("@SYS77931", fiscalCalendarYear.EndDate));
                }
                else
                {
                    select firstonly StartDate, EndDate, Type from fiscalCalendarPeriod
                    order by EndDate, Type asc
                    where fiscalCalendarPeriod.EndDate      <= periodEnd
                    join Ledger, FiscalCalendarPeriod, Status from ledgerPeriod
                    where ledgerPeriod.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                       && ledgerPeriod.Ledger               == Ledger::current()
                       && ledgerPeriod.Status               < FiscalPeriodStatus::Closed
                    join  RecId from fiscalCalendarYear
                    where fiscalCalendarYear.RecId                  == fiscalCalendarPeriod.FiscalCalendarYear
                       && fiscalCalendarYear.FiscalCalendar         == calendarRecId
                       && fiscalCalendarYear.StartDate              <= periodEnd
                       && fiscalCalendarYear.EndDate                >= periodEnd;

                    if (fiscalCalendarPeriod != null)
                    {
                        ok = checkFailed(strFmt("@SYS77932", fiscalCalendarPeriod.StartDate, fiscalCalendarPeriod.EndDate, fiscalCalendarPeriod.Type));
                    }
                }

                while select firstonly JournalNum, JournalType from ledgerJournalTable
                    where ledgerJournalTable.Posted == NoYes::No &&
                          ledgerJournalTable.JournalType != LedgerJournalType::Periodic
                    exists join ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                              ledgerJournalTrans.TransDate  <= periodEnd
                {
                    ok = checkFailed(strFmt("@SYS77933", ledgerJournalTable.JournalNum, ledgerJournalTable.JournalType, periodEnd));
                }
            }

            // Perform validations which are not relevant for reversals
            if (!this.isReversal())
            {
                if (ledgerParameters.AcknowledgementDate_IT)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00010, funcName());
                    if (acknowledgementDate < periodEnd)
                    {
                        // Transaction date is before End date.
                        ok = checkFailed("@SYS99279");
                    }
                }

                ok = ok && this.validateInvalidAccountTypes(periodStart, periodEnd);

                // The retained earnings account must be of type Equity or Balance sheet
                select firstonly RecId from mainAccount where
                    mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current() &&
                    mainAccount.MainAccountId == transferResult &&
                    (mainAccount.Type == DimensionLedgerAccountType::Equity ||
                    mainAccount.Type == DimensionLedgerAccountType::BalanceSheet);

                if (!mainAccount)
                {
                    ok = checkFailed("@SYS305175");
                }

                if (LedgerInterunitBalancer::isBalancingEnabled())
                {
                    if (!transferDimensions)
                    {
                        // transferDimensions is required for interunit
                        ok = checkFailed("@SYS4083067");
                    }

                    dimAttrSetRecId = profitLossCloseDimensionEnumeration;

                    select firstonly RecId from dimAttrSetItem
                        where dimAttrSetItem.DimensionAttributeSet == dimAttrSetRecId
                          && dimAttrSetItem.EnumerationValue == 0
                        exists join ledgerInterunitDimensionAttribute
                            where ledgerInterunitDimensionAttribute.DimensionAttribute == dimAttrSetItem.DimensionAttribute
                                && ledgerInterunitDimensionAttribute.Ledger == Ledger::current();

                    if (dimAttrSetItem != null)
                    {
                        // interunit dimensions have to be marked
                        ok = checkFailed("@SYS4083068");
                    }
                }

                // <GCN>
                if (LedgerParameters::isChineseVoucher_CN())
                {
                    voucherTypeId_CN = LedgerVoucherType_CN::find(ledgerVoucherTypeRecId_CN).Id;
                    LedgerFiscalCloseChineseVoucher_CN ledgerFiscalCloseChineseVoucher_CN = LedgerFiscalCloseChineseVoucher_CN::newForFiscalYearClose(
                        voucher_CN,
                        voucherTypeId_CN,
                        FiscalCalendarYear::find(closingFiscalCalendarYearRecId),
                        LedgerParameters::find());

                    ok = ok && ledgerFiscalCloseChineseVoucher_CN.validateChineseVoucher(methodStatus);
                }
                // </GCN>

                if (isAdvancedAwarenessOptsParmEnabled && methodStatus == OpeningMethod::ClosingToOpening)
                {
                    ok = this.validateSettledTransAcrossFiscalYear() && ok;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSettledTransAcrossFiscalYear</Name>
				<Source><![CDATA[
    protected boolean validateSettledTransAcrossFiscalYear()
    {
        boolean ret = true;

        if (FeatureStateProvider::isFeatureEnabled(LedgerSettledTransCrossFiscalYearWarningYECFlight::instance()))
        {
            GeneralJournalEntry gje_OutOfFiscalYear, gje_WithinFiscalYear;
            GeneralJournalAccountEntry gjae_OutOfFiscalYear, gjae_WithinFiscalYear;
            LedgerTransSettlement ledgerTransSettlement, ledgerTransSettlement2;

            TransDate closingFiscalYearStartDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, periodEnd);

            if (FeatureStateProvider::isFeatureEnabled(LedgerSettledTransCrossFiscalYearQueryPerfYECFlight::instance()))
            {
                // Check for any settled transactions that are posted prior to the target fiscal year
                select count(RecId) from gje_OutOfFiscalYear
                    where gje_OutOfFiscalYear.Ledger == Ledger::current()
                        && gje_OutOfFiscalYear.AccountingDate < closingFiscalYearStartDate
                join gjae_OutOfFiscalYear
                    where gjae_OutOfFiscalYear.GeneralJournalEntry == gje_OutOfFiscalYear.RecId
                exists join ledgerTransSettlement
                    where ledgerTransSettlement.TransRecId == gjae_OutOfFiscalYear.RecId
                exists join ledgerTransSettlement2
                    where ledgerTransSettlement.SettleId == ledgerTransSettlement2.SettleId
                    join GeneralJournalEntry, RecId from gjae_WithinFiscalYear
                        where gjae_WithinFiscalYear.RecId == ledgerTransSettlement2.TransRecId
                    join Ledger, AccountingDate, RecId from gje_WithinFiscalYear
                        where gje_WithinFiscalYear.Ledger == Ledger::current()
                            && gje_WithinFiscalYear.RecId == gjae_WithinFiscalYear.GeneralJournalEntry
                            && gje_WithinFiscalYear.AccountingDate >= closingFiscalYearStartDate
                            && gje_WithinFiscalYear.AccountingDate <= periodEnd;

                if (gje_OutOfFiscalYear.RecId > 0)
                {
                    ret = false;
                }
                else
                {
                    // Check for any settled transactions that are posted after the target fiscal year
                    gje_OutOfFiscalYear.clear();
                    select count(RecId) from gje_OutOfFiscalYear
                        where gje_OutOfFiscalYear.Ledger == Ledger::current()
                            && gje_OutOfFiscalYear.AccountingDate > periodEnd
                    join gjae_OutOfFiscalYear
                        where gjae_OutOfFiscalYear.GeneralJournalEntry == gje_OutOfFiscalYear.RecId
                    exists join ledgerTransSettlement
                        where ledgerTransSettlement.TransRecId == gjae_OutOfFiscalYear.RecId
                    exists join ledgerTransSettlement2
                        where ledgerTransSettlement.SettleId == ledgerTransSettlement2.SettleId
                        join GeneralJournalEntry, RecId from gjae_WithinFiscalYear
                            where gjae_WithinFiscalYear.RecId == ledgerTransSettlement2.TransRecId
                        join Ledger, AccountingDate, RecId from gje_WithinFiscalYear
                            where gje_WithinFiscalYear.Ledger == Ledger::current()
                                && gje_WithinFiscalYear.RecId == gjae_WithinFiscalYear.GeneralJournalEntry
                                && gje_WithinFiscalYear.AccountingDate >= closingFiscalYearStartDate
                                && gje_WithinFiscalYear.AccountingDate <= periodEnd;

                    if (gje_OutOfFiscalYear.RecId > 0)
                    {
                        ret = false;
                    }
                }
            }
            else
            {
                // Check for any settled transactions that are posted prior to the target fiscal year
                select firstonly RecId from gje_OutOfFiscalYear
                    where gje_OutOfFiscalYear.Ledger == Ledger::current()
                        && gje_OutOfFiscalYear.AccountingDate < closingFiscalYearStartDate
                join GeneralJournalEntry, RecId from gjae_OutOfFiscalYear
                    where gjae_OutOfFiscalYear.GeneralJournalEntry == gje_OutOfFiscalYear.RecId
                exists join ledgerTransSettlement
                    where ledgerTransSettlement.TransRecId == gjae_OutOfFiscalYear.RecId
                exists join ledgerTransSettlement2
                    where ledgerTransSettlement.SettleId == ledgerTransSettlement2.SettleId
                    join GeneralJournalEntry, RecId from gjae_WithinFiscalYear
                        where gjae_WithinFiscalYear.RecId == ledgerTransSettlement2.TransRecId
                    join Ledger, AccountingDate, RecId from gje_WithinFiscalYear
                        where gje_WithinFiscalYear.Ledger == Ledger::current()
                            && gje_WithinFiscalYear.RecId == gjae_WithinFiscalYear.GeneralJournalEntry
                            && gje_WithinFiscalYear.AccountingDate >= closingFiscalYearStartDate
                            && gje_WithinFiscalYear.AccountingDate <= periodEnd;

                if (gje_OutOfFiscalYear.RecId)
                {
                    ret = false;
                }
                else
                {
                    // Check for any settled transactions that are posted after the target fiscal year
                    gje_OutOfFiscalYear.clear();
                    select firstonly RecId from gje_OutOfFiscalYear
                        where gje_OutOfFiscalYear.Ledger == Ledger::current()
                            && gje_OutOfFiscalYear.AccountingDate > periodEnd
                    join GeneralJournalEntry, RecId from gjae_OutOfFiscalYear
                        where gjae_OutOfFiscalYear.GeneralJournalEntry == gje_OutOfFiscalYear.RecId
                    exists join ledgerTransSettlement
                        where ledgerTransSettlement.TransRecId == gjae_OutOfFiscalYear.RecId
                    exists join ledgerTransSettlement2
                        where ledgerTransSettlement.SettleId == ledgerTransSettlement2.SettleId
                        join GeneralJournalEntry, RecId from gjae_WithinFiscalYear
                            where gjae_WithinFiscalYear.RecId == ledgerTransSettlement2.TransRecId
                        join Ledger, AccountingDate, RecId from gje_WithinFiscalYear
                            where gje_WithinFiscalYear.Ledger == Ledger::current()
                                && gje_WithinFiscalYear.RecId == gjae_WithinFiscalYear.GeneralJournalEntry
                                && gje_WithinFiscalYear.AccountingDate >= closingFiscalYearStartDate
                                && gje_WithinFiscalYear.AccountingDate <= periodEnd;

                    if (gje_OutOfFiscalYear.RecId)
                    {
                        ret = false;
                    }
                }
            }
        }

        if (!ret)
        {
            error("@GeneralLedger:SettledTransCrossFiscalYearWarningForYEC");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAcknowledgementDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation related to the acknowledgement date that is required before the process is
    /// executed.
    /// </summary>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    protected boolean validateAcknowledgementDate()
    {
        boolean ret = true;

        if (ledgerParameters.AcknowledgementDate_IT)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00010, funcName());
            if (acknowledgementDate < periodEnd)
            {
                // Transaction date is before End date.
                ret = checkFailed("@SYS99279");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBatchProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts the user for action when the batch configuration is invalid.
    /// </summary>
    /// <returns>
    /// true if the process can run in batch mode; otherwise, false ;
    /// </returns>
    /// <remarks>
    /// The preview transactions and batch processing fields cannot be checked at the same time. If they
    /// are, this method will prompt the user to change one of the values.
    /// </remarks>
    protected boolean validateBatchProcessing()
    {
        boolean ok = true;

        if (!this.canGoBatch())
        {
            if (Box::okCancel("@SPS576",DialogButton::Cancel) == DialogButton::Ok)
            {
                dialogRunPreview.value(NoYes::No);
                runPreview = NoYes::No;
            }
            else
            {
                this.batchInfo().fieldBatchExecuteValue(false);
                runPreview = NoYes::Yes;
                ok = false;
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanCloseYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation related to closing the fiscal year that is required before the process is
    /// executed.
    /// </summary>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    protected boolean validateCanCloseYear()
    {
        FiscalCalendarYear fiscalCalendarYear;
        boolean ret = true;
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTrans;

        if (!ledgerParameters.YearClosed)
        {
            return true;
        }

        /* if the parameter "YearClosed" is set to YES, then the year closing
           validation logic will occur.*/
        fiscalCalendarYear = FiscalCalendars::findPrevYear(calendarRecId, periodEnd);
        if (fiscalCalendarYear != null && fiscalCalendarYear.currentLedgerYearStatus() == FiscalYearStatus::Open)
        {
            ret = checkFailed(strFmt("@SYS77931", fiscalCalendarYear.EndDate));
        }

        while select firstonly Posted, JournalNum, JournalType, RecId from ledgerJournalTable
            where ledgerJournalTable.Posted == NoYes::No
            exists join JournalNum, TransDate from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                    && ledgerJournalTrans.TransDate <= periodEnd
        {
            ret = checkFailed(strFmt("@SYS77933", ledgerJournalTable.JournalNum, ledgerJournalTable.JournalType, periodEnd));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFiscalCalendarData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation related to fiscal calendar data required before the process is executed.
    /// </summary>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    protected boolean validateFiscalCalendarData()
    {
        boolean ret = true;
        FiscalCalendarPeriod openingFiscalCalendarPeriod;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        FiscalCalendarYear fiscalCalendarYear;
        FiscalCalendarPeriod openingBalancePeriod = this.getOpeningBalancePeriod();
        FiscalCalendarPeriod closingBalancePeriod = this.getClosingBalancePeriod();
        FiscalCalendarPeriod closingPostToPeriod = this.getClosingPostToPeriod();
        TransDate closingPeriodEndDate = LedgerFiscalCalendar::findYearEndClosingPeriodByDate(calendarRecId, periodEnd).EndDate;
        RefRecId closingFiscalYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName).RecId;
        DictEnum periodStatusDictEnum = new DictEnum(enumNum(FiscalPeriodStatus));
        //Gets the localized name of the enum value
        str periodStatusEnumText = periodStatusDictEnum.value2Name(FiscalPeriodStatus::Open);
        FiscalPeriodStatus status = closingPostToPeriod.currentLedgerPeriodStatus();

        select firstOnly StartDate, FiscalCalendarYear from openingFiscalCalendarPeriod order by StartDate
            where openingFiscalCalendarPeriod.StartDate > closingPeriodEndDate
                && openingFiscalCalendarPeriod.Type == FiscalPeriodType::Opening
            join RecId from fiscalCalendarYear
                where fiscalCalendarYear.RecId == openingFiscalCalendarPeriod.FiscalCalendarYear  &&
                    fiscalCalendarYear.FiscalCalendar == calendarRecId;
        periodNext = openingFiscalCalendarPeriod.StartDate;

        if (!LedgerFiscalCalendar::existOpeningPeriodForDate(calendarRecId, periodNext))
        {
            ret = checkFailed(strFmt("@SYS128560",FiscalCalendar::find(calendarRecId).CalendarId));
        }
        openingFiscalCalendarPeriodRecId = openingFiscalCalendarPeriod.RecId;
        openingFiscalCalendarYearRecId = openingFiscalCalendarPeriod.FiscalCalendarYear;

        if (!closingFiscalYearName )
        {
            ret = checkFailed(strFmt("@SYS84753" , fieldPName(FiscalCalendarYear, Name)));
        }
        if (!balanceFromPeriod)
        {
            ret = checkFailed(strFmt("@SYS116347" , "@SPS633"));
        }
        if (!closeDateFromPeriod)
        {
            ret = checkFailed(strFmt("@SYS84753" , fieldPName(FiscalCalendarPeriod, EndDate)));
        }
        if (!balanceToPeriod)
        {
            ret = checkFailed(strFmt("@SYS116347" , "@SPS634"));
        }
        if (!periodEnd)
        {
            ret = checkFailed(strFmt("@SYS84753" , fieldPName(FiscalCalendarPeriod, EndDate)));
        }
        if (!balanceOpenFromPeriod)
        {
            ret = checkFailed(strFmt("@SYS116347" , "@SPS635"));
        }
        if (!openDateFromPeriod)
        {
            ret = checkFailed(strFmt("@SYS84753" , fieldPName(FiscalCalendarPeriod, EndDate)));
        }
        if (!calendarRecId)
        {
            ret = checkFailed("@SPS469");
        }
        if (closingFiscalYearName && !FiscalCalendars::existFiscalYear(calendarRecId, closingFiscalYearName))
        {
            ret = checkFailed("@SPS454");
        }

        fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(calendarRecId, periodEnd, FiscalPeriodType::Closing, periodName);
        closingFiscalCalendarPeriodRecId = fiscalCalendarPeriod.RecId;
        closingFiscalCalendarYearRecId = fiscalCalendarPeriod.FiscalCalendarYear;

        // validate that the user has rights to the closing balance and post to periods
        if (closingBalancePeriod.RecId == 0)
        {
            ret = checkFailed (strFmt("@SPS632", "@SPS633"));
        }
        else if (closingBalancePeriod && !LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Ledger, periodEnd, closingBalancePeriod) || !LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Ledger, periodEnd, closingPostToPeriod))
        {
            ret = checkFailed("@SPS462");
        }

        if (closingPostToPeriod.RecId == 0)
        {
            ret = checkFailed (strFmt("@SPS632", "@SPS634"));
        }

        // validate that the opening balancing period is valid
        if (openingBalancePeriod.RecId == 0)
        {
            ret = checkFailed (strFmt("@SPS632", "@SPS635"));
        }

        // validate that the posting period is a closing period and is open for posting
        if (closingPostToPeriod.Type != FiscalPeriodType::Closing)
        {
            ret = checkFailed(strFmt("@SPS456", FiscalPeriodType::Closing));
        }
        if ((closingPostToPeriod.currentLedgerPeriodStatus() != FiscalPeriodStatus::Open))
        {
            ret = checkFailed(strFmt("@SPS2465","@SPS437", periodStatusEnumText));
        }

        // validate that the closing/opening balances dates and closing posting date are valid for the fiscal year
        if (closeDateFromPeriod && (closingFiscalYearNameRecId != FiscalCalendarYear::findYearByCalendarDate(calendarRecId, closeDateFromPeriod).RecId))
        {
            ret = checkFailed(strFmt("@SPS458", "@SYS15867"+' \''+"@SPS434"+'\''));
        }
        if (periodEnd && (closingFiscalYearNameRecId != FiscalCalendarYear::findYearByCalendarDate(calendarRecId, periodEnd).RecId))
        {
            ret = checkFailed(strFmt("@SPS458", '\''+"@SPS437"+'\''));
        }
        if (openDateFromPeriod && (closingFiscalYearNameRecId != FiscalCalendarYear::findYearByCalendarDate(calendarRecId, openDateFromPeriod).RecId))
        {
            ret = checkFailed(strFmt("@SPS458", "@SYS939"+' \''+"@SPS434"+'\''));
        }

        // validate that the posting period is greater than the balances period
        if (closingPostToPeriod.StartDate  < closingBalancePeriod.StartDate)
        {
            ret = checkFailed("@SPS465");
        }
        else if (closingPostToPeriod.Type == FiscalPeriodType::Closing && closingPostToPeriod.StartDate == closingBalancePeriod.StartDate)
        {
            // Fail cases where the periods are out of order but have the same start date.
            if (closingPostToPeriod.Name  < closingBalancePeriod.Name)
            {
                ret = checkFailed("@SPS465");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFundRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation related to funds that is required before the process is executed.
    /// </summary>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    protected boolean validateFundRange()
    {
        boolean ret = true;

        if (selectFund)
        {
            if ((!LedgerFund::find(fromFund) && fromFund)
                || (!LedgerFund::find(toFund) && toFund))
            {
                ret = checkFailed("@SPS461");
            }
            else if (fromFund && !toFund)
            {
                ret = checkFailed("@SPS459");
            }
            else if (toFund && !fromFund)
            {
                ret = checkFailed("@SPS460");
            }
            else if (fromFund && toFund)
            {
                if ((fromFund == toFund) && (!LedgerFund::find(fromFund)))
                {
                    ret = checkFailed("@SPS461");
                }
                else if (toFund < fromFund)
                {
                    ret = checkFailed("@SPS464");
                }
            }
            else
            {
                ret = checkFailed("@SPS461");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateJournalizingDefinitions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation related to journalizing definitions that is required before the process is
    /// executed.
    /// </summary>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    protected boolean validateJournalizingDefinitions()
    {
        boolean isjournalizingDefinitionLedgerTrans;
        JournalizingDefinitionGeneralLedgerTrans journalizingDefinitionGLTrans;
        boolean ret = true;

        select firstonly RecId from journalizingDefinitionGLTrans
            where journalizingDefinitionGLTrans.LedgerTransType == LedgerOpenCloseTransType::Open;

        if (journalizingDefinitionGLTrans.RecId)
        {
            isjournalizingDefinitionLedgerTrans = true;
        }

        select firstonly RecId from journalizingDefinitionGLTrans
            where journalizingDefinitionGLTrans.LedgerTransType == LedgerOpenCloseTransType::Close;

        if (!isjournalizingDefinitionLedgerTrans || !journalizingDefinitionGLTrans)
        {
            ret = checkFailed("@SPS475");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the validation that is related to the voucher number before the process is executed.
    /// </summary>
    /// <returns>
    /// true if the process parameters are valid; otherwise, false .
    /// </returns>
    protected boolean validateVoucher()
    {
        boolean ret = true;

        if (voucher)
        {
            ret = GeneralLedgerExtension::validateReferenceNumber(calendarRecId, ledgerParameters.CheckVoucher, voucher, periodEnd)
                && GeneralLedgerExtension::validateReferenceNumber(calendarRecId, ledgerParameters.CheckVoucher, voucher, periodNext);
        }
        else if (ledgerParameters.OpeningVoucher)
        {
            ret = checkFailed("@SYS57812");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GeneralLedger:YearEndClose";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        LedgerTransferOpening ledgerTransferOpening;
        LedgerTransferOpening_PSN ledgerTransferOpening_PSN;
        
        if (!PublicSectorUtils::isLedgerYearEndClosingEnabled())
        {
            ledgerTransferOpening = LedgerTransferOpening::construct();
        }
        else
        {
            ledgerTransferOpening_PSN = LedgerTransferOpening_PSN::construct();
            ledgerTransferOpening = ledgerTransferOpening_PSN;
        }
        
        if (PublicSectorUtils::isLedgerYearEndClosingEnabled())
        {
            if (LedgerParameters::find().JournalizingDefinitionEnableValue != NoYes::Yes)
            {
                checkFailed("@SPS476");
            }

            do
            {
                ledgerTransferOpening.parmProcessCancelled(false);

                if (ledgerTransferOpening.prompt())
                {
                    ledgerTransferOpening.runOperation();

                    if (PublicSectorUtils::isLedgerYearEndClosingEnabled())
                    {
                        ledgerTransferOpening_PSN.runPublicSectorYearEndClosingPreview();
                    }

                    if (!ledgerTransferOpening.silent && ledgerTransferOpening.createdTransactions)
                    {
                        ledgerTransferOpening.runReport();
                    }
                }
            }
            while (ledgerTransferOpening.parmProcessCancelled());  //re-prompt if preview was cancelled
        }
        else
        {
            if (ledgerTransferOpening.prompt())
            {
                ledgerTransferOpening.runOperation();

                if (PublicSectorUtils::isLedgerYearEndClosingEnabled())
                {
                    ledgerTransferOpening_PSN.runPublicSectorYearEndClosingPreview();
                }

                if (!ledgerTransferOpening.silent && ledgerTransferOpening.createdTransactions)
                {
                    ledgerTransferOpening.runReport();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProfitLossDefaultDimensions</Name>
				<Source><![CDATA[
    public DimensionDefault parmProfitLossDefaultDimensions(DimensionDefault _profitLossDefaultDimensions = profitLossDefaultDimensions)
    {
        profitLossDefaultDimensions = _profitLossDefaultDimensions;
        return profitLossDefaultDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProfitLossCloseDimensionEnumeration</Name>
				<Source><![CDATA[
    public DimensionEnumeration parmProfitLossCloseDimensionEnumeration(DimensionEnumeration _profitLossCloseDimensionEnumeration = profitLossCloseDimensionEnumeration)
    {
        profitLossCloseDimensionEnumeration = _profitLossCloseDimensionEnumeration;
        return profitLossCloseDimensionEnumeration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDialog_PSN</Name>
				<Source><![CDATA[
    private void buildDialog_PSN(DialogRunbase _baseDialog)
    {
        DialogGroup             dialogGroup;
        DialogGroup             dialogGroupFiscalCalendar;
        DialogGroup             dialogGroupFiscalCalendarYear;
        DialogGroup             dialogGroupPeriodClosing;
        DialogGroup             dialogGroupPeriodOpening;
        DialogGroup             dialogGroupPeriodAndVoucher;
        DialogGroup             dialogGroupVoucher;
        DialogGroup             dialogGroupSelectFund;
        DialogGroup             dialogGroupFund;
        FiscalCalendar          fiscalCalendar;

        // Create the General tab
        dialogGroup = _baseDialog.addGroup("@SYS71496");
        dialogGroup.allowEdit(false);
        dialogGroup.widthMode(1);

        _baseDialog.addFieldValue(enumStr(NoYes), ledgerParameters.DeleteOpening,"@SYS67680","@SYS67681");
        _baseDialog.addFieldValue(extendedTypeStr(LedgerPeriodClosingPosting), ledgerParameters.PeriodClosingPosting);
        _baseDialog.addFieldValue(extendedTypeStr(YearClosed), ledgerParameters.YearClosed);

        _baseDialog.addGroup("@SYS13292");

        dialogGroupFiscalCalendar = _baseDialog.addGroup('');
        dialogGroupFiscalCalendar.frameType(FormFrameType::None);

        // Add a Fiscal calendar Id dialog field.
        fiscalCalendar = FiscalCalendar::find(calendarRecId);
        dialogCalendarId = _baseDialog.addFieldValue(extendedTypeStr(FiscalCalendarID), fiscalCalendar.CalendarId, "@SYS105687", "@SPS432");
        dialogCalendarId.allowEdit(false);

        // Add a Close dialog group.
        dialogGroupFiscalCalendarYear = _baseDialog.addGroup("@SYS15867");

        // Add a Fiscal year name dialog field.
        dialogFiscalYearName = _baseDialog.addFieldValue(extendedTypeStr(FiscalYearName), closingFiscalYearName, "@SYS13292", "@SPS433");
        dialogFiscalYearName.lookupButton(2);
        fiscalCalendarYearNameRecId = FiscalCalendarYear::findByCalendarYearName(calendarRecId, closingFiscalYearName).RecId;

        dialogGroupPeriodClosing  = _baseDialog.addGroup('', dialogGroupFiscalCalendarYear);
        dialogGroupPeriodClosing.frameType(FormFrameType::None);
        dialogGroupPeriodClosing.columns(2);

        // Add a closing Balance through fiscal period dialog field.
        dialogPeriodEndFrom = _baseDialog.addFieldValue(extendedTypeStr(PeriodName), balanceFromPeriod, "@SPS434", "@SPS435");
        dialogPeriodEndFrom.lookupButton(2);

        // Add a closing Post to fiscal period dialog field.
        dialogPeriodEndTo = _baseDialog.addFieldValue(extendedTypeStr(PeriodName), balanceToPeriod, "@SPS437", "@SPS438");
        dialogPeriodEndTo.lookupButton(2);

        // Add a closing Balance through fiscal period's End date dialog field.
        dialogPeriodEndFromDate = _baseDialog.addFieldValue(extendedTypeStr(FiscalPeriodEnd), closeDateFromPeriod, "@SYS22882", "@SPS436");
        dialogPeriodEndFromDate.lookupButton(2);

        // Add a closing Balance Post to fiscal period's End date dialog field.
        dialogPeriodEndToDate = _baseDialog.addFieldValue(extendedTypeStr(PeriodStartClosing), periodEnd, "@SYS22882", "@SPS439");
        dialogPeriodEndToDate.lookupButton(2);

        dialogPeriodName = _baseDialog.addFieldValue(extendedTypeStr(PeriodName), periodName, "@SYS127887", "@SYS128562");
        dialogPeriodName.value(periodName);
        dialogPeriodName.allowEdit(false);
        dialogPeriodName.visible(false);

        // Add a Opening fiscal period group.
        dialogGroupPeriodAndVoucher = _baseDialog.addGroup("@SYS939");
        dialogGroupPeriodOpening = _baseDialog.addGroup('', dialogGroupPeriodAndVoucher);
        dialogGroupPeriodOpening.frameType(FormFrameType::None);
        dialogGroupPeriodOpening.columns(2);

        // Add a Opening Balance through fiscal period dialog field.
        dialogPeriodStartFrom = _baseDialog.addFieldValue(extendedTypeStr(PeriodName), balanceOpenFromPeriod, "@SPS434", "@SPS440");
        dialogPeriodStartFrom.lookupButton(2);

        // Add a Opening Balance through fiscal period End date dialog field.
        dialogPeriodStartFromDate = _baseDialog.addFieldValue(extendedTypeStr(PeriodStartClosing), openDateFromPeriod, "@SYS22882", "@SPS441");
        dialogPeriodStartFromDate.lookupButton(2);

        if (ledgerParameters.AcknowledgementDate_IT)
        {
            dialogAcknowledgementDate = _baseDialog.addFieldValue(extendedTypeStr(AcknowledgementDate), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), "@SYS67");
        }

        // Add a dialog group for alignment Periods with voucher and Balance account dialog fields.
        dialogGroupVoucher = _baseDialog.addGroup('', dialogGroupPeriodAndVoucher);
        dialogGroupVoucher.frameType(FormFrameType::None);
        dialogGroupVoucher.alignChild(true);

        _baseDialog.addGroup("@SYS24137", dialogGroupVoucher).frameType(FormFrameType::None);
        dialogMethodStatus = _baseDialog.addFieldValue(enumStr(OpeningMethod),OpeningMethod::ClosingToOpening,"@SYS10834","@SYS67848");

        dialogTransferResult = _baseDialog.addFieldValue(extendedTypeStr(LedgerAccount),transferResult,"@SYS24136");
        dialogTransferResult.visible(false);

        dialogVoucher = _baseDialog.addFieldValue(extendedTypeStr(Voucher),voucher,"@SYS12336");

        // Printout
        dialogRunReport = _baseDialog.addFieldValue(enumStr(NoYes),runReport,"@SYS67163","@SYS67162");
        dialogRunReport.visible(false);

        // Add a Fund dialog group.
        dialogGroupSelectFund = _baseDialog.addGroup("@SPS105");

        // Add a Select Fund checkbox dialog field.
        dialogSelectFund = _baseDialog.addFieldValue(enumStr(NoYes), selectFund, "@SPS442", "@SPS443");

        dialogGroupFund = _baseDialog.addGroup('', dialogGroupSelectFund);
        dialogGroupFund.frameType(FormFrameType::None);
        dialogGroupFund.columns(2);

        // Add a From funds dialog field.
        dialogFromFund = _baseDialog.addFieldValue(extendedTypeStr(FundNumber), fromFund, "@SPS444", "@SPS445");
        dialogFromFund.lookupButton(2);
        dialogFromFund.allowEdit(selectFund);
        dialogFromFund.value(fromFund);

        // Add a To funds dialog field.
        dialogToFund = _baseDialog.addFieldValue(extendedTypeStr(FundNumber), toFund, "@SPS446", "@SPS447");
        dialogToFund.lookupButton(2);
        dialogToFund.allowEdit(selectFund);
        dialogToFund.value(toFund);

        dialogGroup = _baseDialog.addGroup("@SYS2368");

        dialogRunPreview = _baseDialog.addFieldValue(enumStr(NoYes), runPreview, "@SPS448", "@SPS449");

        dialogRunReport = _baseDialog.addFieldValue(enumStr(NoYes), runReport, "@SYS67163", "@SYS67162");
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLastRunDate</Name>
				<Source><![CDATA[
    private void updateLastRunDate(boolean _reset = false)
    {
        TransDate dateToSet = _reset ? dateNull() : DateTimeUtil::getSystemDate(DateTimeUtil::getCompanyTimeZone());

        Ledger ledgerToUpdate;
        ledgerToUpdate.skipDataMethods(true);
        ledgerToUpdate.skipEvents(true);

        try
        {
            ttsbegin;

            update_recordset ledgerToUpdate setting MostRecentYearEndClose = dateToSet
                where ledgerToUpdate.RecId == Ledger::current();

            if (LedgerFiscalCloseLastYearEndCloseDateCacheFlight::instance().isEnabled())
            {
                LedgerCache::removeValue(LedgerCacheScope::LastClosingDateByLedger, [Ledger::current()]);
            }
            else
            {
                LedgerCache::clearScope(LedgerCacheScope::LastClosingDateByLedger);
            }

            ttscommit;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                this.logError(strFmt('An unhandled sql update conflict error occured during updating the ledger last year-end close date with RecId %1.', Ledger::current()));

                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityContextForLedgerTransferOpening</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext getActivityContextForLedgerTransferOpening(str _activityName)
    {
        str instrumentationNamespace = classStr(LedgerTransferOpening);

        SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(instrumentationNamespace);
        SysInstrumentationActivity activity = SysInstrumentationActivity::construct(_activityName, instrumentationNamespace);

        return logger.activityContextWithCustomProperties(activity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerTransferOpeningCustomPropertiesToActivityContext</Name>
				<Source><![CDATA[
    private void addLedgerTransferOpeningCustomPropertiesToActivityContext(SysInstrumentationActivityContext _activityContext)
    {
        this.addLedgerFiscalCloseCustomPropertiesToActivityContext(_activityContext);
        this.addLedgerParametersCustomPropertiesToActivityContext(_activityContext);
        this.addBatchCustomPropertiesToActivityContext(_activityContext);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addStartStopBundleRecIdCustomPropertyToActivityContext</Name>
				<Source><![CDATA[
    private void addStartStopBundleRecIdCustomPropertyToActivityContext(SysInstrumentationActivityContext _activityContext)
    {
        _activityContext.addCustomProperty('BundleStartRecId', int642Str(startRecId));
        _activityContext.addCustomProperty('BundleEndRecId', int642Str(endRecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerTransferOpeningTypeCustomPropertyToActivityContext</Name>
				<Source><![CDATA[
    private void addLedgerTransferOpeningTypeCustomPropertyToActivityContext(SysInstrumentationActivityContext _activityContext)
    {
        _activityContext.addCustomProperty(enumStr(LedgerTransferOpeningType), enum2Symbol(enumNum(LedgerTransferOpeningType), ledgerTransferOpeningType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerFiscalCloseCustomPropertiesToActivityContext</Name>
				<Source><![CDATA[
    private void addLedgerFiscalCloseCustomPropertiesToActivityContext(SysInstrumentationActivityContext _activityContext)
    {
        _activityContext.addCustomProperty(tableStr(Ledger), int642Str(Ledger::current()));

        _activityContext.addCustomProperty(extendedTypeStr(FiscalPeriodEnd), date2StrXpp(periodEnd));
        _activityContext.addCustomProperty(extendedTypeStr(PeriodName), periodName);
        _activityContext.addCustomProperty(fieldStr(LedgerFiscalCloseLedgerOptions, TransferBalanceSheetDimensions), enum2Symbol(enumNum(NoYes), transferDimensions));
        _activityContext.addCustomProperty(extendedTypeStr(Voucher), voucher);
        _activityContext.addCustomProperty(fieldStr(LedgerFiscalCloseLedgerOptions, ProfitLossCloseDimension), int642Str(profitLossCloseDimensionEnumeration));
        _activityContext.addCustomProperty(fieldStr(LedgerFiscalCloseLedgerOptions, ProfitLossDefaultDimension), int642Str(profitLossDefaultDimensions));
        _activityContext.addCustomProperty(fieldStr(LedgerFiscalCloseLedgerOptions, RetainedEarningsMainAccount), transferResult);
        _activityContext.addCustomProperty(enumStr(OpeningMethod), enum2Symbol(enumNum(OpeningMethod), methodStatus));
        _activityContext.addCustomProperty('DelayDimensionSetRebuild', delayDimensionSetRebuild ? 'true' : 'false');
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerParametersCustomPropertiesToActivityContext</Name>
				<Source><![CDATA[
    private void addLedgerParametersCustomPropertiesToActivityContext(SysInstrumentationActivityContext _activityContext)
    {
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, DeleteOpening), enum2Symbol(enumNum(NoYes), ledgerParameters.DeleteOpening));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, PeriodClosingPosting), enum2Symbol(enumNum(NoYes), ledgerParameters.PeriodClosingPosting));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, YearClosed), enum2Symbol(enumNum(NoYes), ledgerParameters.YearClosed));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, OpeningVoucher), enum2Symbol(enumNum(NoYes), ledgerParameters.OpeningVoucher));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, OpeningWithoutBudget), enum2Symbol(enumNum(NoYes), ledgerParameters.OpeningWithoutBudget));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, LimitedOpenFiscalPeriods), int2Str(ledgerParameters.LimitedOpenFiscalPeriods));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, LedgerYearEndClosingEnabled_PSN), enum2Symbol(enumNum(NoYes), ledgerParameters.LedgerYearEndClosingEnabled_PSN));
        _activityContext.addCustomProperty(fieldStr(LedgerParameters, PurchYearEndEnabled_PSN), enum2Symbol(enumNum(NoYes), ledgerParameters.PurchYearEndEnabled_PSN));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchCustomPropertiesToActivityContext</Name>
				<Source><![CDATA[
    private void addBatchCustomPropertiesToActivityContext(SysInstrumentationActivityContext _activityContext)
    {
        _activityContext.addCustomProperty(fieldStr(Batch, BatchJobId), int642Str(this.parmCurrentBatch().BatchJobId));
        _activityContext.addCustomProperty(fieldStr(Batch, GroupId), this.parmCurrentBatch().GroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInvalidAccountTypes</Name>
				<Source><![CDATA[
    private boolean validateInvalidAccountTypes(AccountingDate _periodStart, AccountingDate _periodEnd)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        MainAccount mainAccount;
        boolean ok = true;

        select firstonly mainAccount from generalJournalAccountEntry
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= _periodStart
                    && generalJournalEntry.AccountingDate <= _periodEnd
            join RecId, MainAccountId, Type from mainAccount
                where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                    && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
                    && (mainAccount.Type != DimensionLedgerAccountType::ProfitAndLoss
                    && mainAccount.Type != DimensionLedgerAccountType::Revenue
                    && mainAccount.Type != DimensionLedgerAccountType::Expense
                    && mainAccount.Type != DimensionLedgerAccountType::BalanceSheet
                    && mainAccount.Type != DimensionLedgerAccountType::Asset
                    && mainAccount.Type != DimensionLedgerAccountType::Liability
                    && mainAccount.Type != DimensionLedgerAccountType::Equity
                    && mainAccount.Type != DimensionLedgerAccountType::Common_CN);

        if (mainAccount.RecId != 0 )
        {
            ok = checkFailed(strFmt("@GeneralLedger:InvalidAccountsTypesInTransaction", mainAccount.MainAccountId, mainAccount.Type));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReversal</Name>
				<Source><![CDATA[
    private boolean  isReversal()
    {
        return methodStatus == OpeningMethod::Reset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerTransferOpeningDetailsAndSummarizedAccountEntries</Name>
				<Source><![CDATA[
    private void insertLedgerTransferOpeningDetailsAndSummarizedAccountEntries()
    {
        LedgerTransferOpeningDetails::buildEntryDetails(
            startRecId,
            endRecId,
            LedgerTransferOpeningType::BalanceSheet,
            processSession,
            processTimeStamp);

        GeneralJournalAccountEntrySummarized::insertSummarizedJournalAccountEntries(
            startRecId,
            endRecId,
            LedgerTransferOpeningType::BalanceSheet,
            processSession,
            processTimestamp,
            detailsExecutionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertGeneralJournalAccountEntryDetails</Name>
				<Source><![CDATA[
    private void insertGeneralJournalAccountEntryDetails(LedgerPostingGeneralJournalController _generalJournalController)
    {
        this.createOrUpdateJournalHeaderData();

        LedgerTransferOpeningDetails::insertDetailsTransactions(
            voucher,
            openingFiscalCalendarPeriodRecId,
            processSession,
            processTimestamp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertGeneralJournalAccountEntryClosingDetails</Name>
				<Source><![CDATA[
    internal void insertGeneralJournalAccountEntryClosingDetails(Voucher _voucher, RefRecId _closingFiscalCalendarPeriodRecId, SessionId _processSession, UTCTimeStamp _processTimeStamp)
    {
        GeneralJournalAccountEntryDetailsTmp entryDetails;

        select firstonly RecId from entryDetails
            where entryDetails.ProcessSessionId == _processSession
                && entryDetails.ProcessUTCTimestamp == _processTimeStamp;
        
        if (!entryDetails.RecId)
        {
            return;
        }

        GeneralJournalEntry journalEntry;
        GeneralJournalAccountEntry accountEntry;
        Map closingTransMap = new Map(Types::Enum, Types::Record);

        while select RecId, PostingLayer from journalEntry
                where journalEntry.SubledgerVoucher == _voucher
                    && journalEntry.SubledgerVoucherDataAreaId == curExt()
                    && journalEntry.FiscalCalendarPeriod == _closingFiscalCalendarPeriodRecId
        {
            DimensionStorageSegment mainAccountStorageSegment;
            LedgerDimensionAccount ledgerDimensionAccount;
            DimensionAttributeValueCombination ledgerAccount;
            MainAccountNum mainAccountId;

            Map emptyDimensionSpecifier = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();

            TransactionTxt transactionTxt = TransactionTxt::construct();
            transactionTxt.setType(LedgerTransTxt::LedgerClosing);
            transactionTxt.setDate(periodEnd);
            transactionTxt.setVoucher(_voucher);
            transactionTxt.setLanguage(currentUserLanguage());

            while select sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount), sum(TransactionCurrencyAmount),
                    MainAccount, LedgerDimension, TransactionCurrencyCode
                    from entryDetails
                    group by MainAccount, LedgerDimension, TransactionCurrencyCode
                        where entryDetails.PostingLayer == journalEntry.PostingLayer
                            && entryDetails.ProcessSessionId == _processSession
                            && entryDetails.ProcessUTCTimestamp == _processTimeStamp
            {
                if (this.parmTransferDimensions())
                {
                    mainAccountStorageSegment = this.getMainAccountStorageSegment(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(entryDetails.LedgerDimension));
                    ledgerDimensionAccount = this.getLedgerDimensionForMainAcount(mainAccountStorageSegment, entryDetails.LedgerDimension);
                }
                else
                {
                    mainAccountId = MainAccount::find(entryDetails.MainAccount).MainAccountId;
                    mainAccountStorageSegment = this.getMainAccountStorageSegment(mainAccountId);
                    ledgerDimensionAccount = this.getLedgerDimension(mainAccountStorageSegment, emptyDimensionSpecifier);
                }

                ledgerAccount = DimensionAttributeValueCombination::find(ledgerDimensionAccount);
                transactionTxt.setFormLetter(ledgerAccount.MainAccountValue);

                accountEntry.clear();

                if (closingTransMap.exists(ledgerDimensionAccount))
                {
                    accountEntry = closingTransMap.lookup(ledgerDimensionAccount);

                    accountEntry.AccountingCurrencyAmount += (0 - entryDetails.AccountingCurrencyAmount);
                    accountEntry.ReportingCurrencyAmount += (0 - entryDetails.ReportingCurrencyAmount);
                    accountEntry.TransactionCurrencyAmount += (0 - entryDetails.TransactionCurrencyAmount);
                    accountEntry.IsCredit = accountEntry.AccountingCurrencyAmount < 0;
                }
                else
                {
                    accountEntry.AccountingCurrencyAmount = 0 - entryDetails.AccountingCurrencyAmount;
                    accountEntry.ReportingCurrencyAmount = 0 - entryDetails.ReportingCurrencyAmount;
                    accountEntry.TransactionCurrencyAmount = 0 - entryDetails.TransactionCurrencyAmount;
                    accountEntry.IsCredit = (0 - entryDetails.AccountingCurrencyAmount) < 0;
                    accountEntry.GeneralJournalEntry = journalEntry.RecId;
                    accountEntry.PostingType = LedgerPostingType::TransferOpeningClosing;
                    accountEntry.LedgerDimension = ledgerDimensionAccount;
                    accountEntry.LedgerAccount = ledgerAccount.DisplayValue;
                    accountEntry.Text = transactionTxt.txt();

                    accountEntry.MainAccount = entryDetails.MainAccount;
                    accountEntry.TransactionCurrencyCode = entryDetails.TransactionCurrencyCode;
                }

                closingTransMap.insert(ledgerDimensionAccount, accountEntry);
            }
        }

        RecordInsertList recordInsertList = new RecordInsertList(tableNum(GeneralJournalAccountEntry), true, true, true);
        SetEnumerator setEnumerator = closingTransMap.valueSet().getEnumerator();

        while (setEnumerator.moveNext())
        {
            recordInsertList.add(setEnumerator.current());
        }

        ttsbegin;
        recordInsertList.insertDatabase();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBeginningBalanceTransactionsNotSettled</Name>
				<Source><![CDATA[
    private void validateBeginningBalanceTransactionsNotSettled()
    {
        NoYes settlementExists = LedgerTransferOpeningDetailsHelper::isAccountEntryDetailsSettled(periodNext, openingFiscalCalendarPeriodRecId);

        settlementExists = settlementExists || LedgerTransferOpeningDetailsHelper::isSummarizedBalanceSettled(periodNext, openingFiscalCalendarPeriodRecId);

        if (settlementExists)
        {
            throw error(strFmt("@GeneralLedger:YearEndCloseSettleValidation", periodNext, prevYr(periodNext)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateJournalHeaderData</Name>
				<Source><![CDATA[
    private void createOrUpdateJournalHeaderData()
    {
        NoYes journalEntryCreated;
        GeneralJournalEntry journalEntry;

        //There may be multiple posting layers creating multiple journals that need correct headers updated for the summarized records table.
        while select PostingLayer, RecId from journalEntry
            where journalEntry.SubledgerVoucher == voucher
                && journalEntry.SubledgerVoucherDataAreaId == curExt()
                && journalEntry.FiscalCalendarPeriod == openingFiscalCalendarPeriodRecId
        {
            GeneralJournalAccountEntrySummarized::updateGeneralJournalEntryByExecutionId(detailsExecutionId, journalEntry.PostingLayer, journalEntry.RecId);
            journalEntryCreated = NoYes::Yes;
        }

        if (!journalEntryCreated)
        {
            LedgerTransferOpeningDetailsHelper::createJournalEntryHeaders(
                voucher,
                periodNext,
                acknowledgementDate,
                openingFiscalCalendarPeriodRecId,
                openingFiscalCalendarYearRecId,
                processSession,
                processTimestamp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForLedgerFiscalCalendarYear</Name>
				<Source><![CDATA[
    private void checkForLedgerFiscalCalendarYear()
    {
        if (LedgerFiscalCalendar::findLedgerYearByCalendarLedgerDate(calendarRecId, Ledger::current(), periodEnd).RecId == 0 
            && closingFiscalCalendarYearRecId != 0)
        {
            str missingLedgerFiscalCalendarYear = 'LedgerFiscalCalendarYear is missing for calendar: %1, and fiscal year: %2, and ledger: %3';

            this.logInformation(strFmt(missingLedgerFiscalCalendarYear, calendarRecId, closingFiscalCalendarYearRecId, Ledger::current()));

            LedgerFiscalCalendar::insertLedgerYearForYear(calendarRecId, closingFiscalCalendarYearRecId, Ledger::current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTransactionsExistInSourceFiscalYear</Name>
				<Source><![CDATA[
    private boolean doTransactionsExistInSourceFiscalYear(FiscalCalendarYear _sourceFisaclYear)
    {
        boolean ret = true;

        if (LedgerTransferOpeningCheckTransFlight::instance().isEnabled())
        {
            TransDate startDateOfTargetYear = _sourceFisaclYear.StartDate;
            TransDate endDateOfTargetYear = _sourceFisaclYear.EndDate;

            GeneralJournalEntry generalJournalEntry;

            select firstonly RecId from generalJournalEntry
                where generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= startDateOfTargetYear
                    && generalJournalEntry.AccountingDate <= endDateOfTargetYear;

            ret = generalJournalEntry.RecId != 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBatchAlreadyRunning</Name>
				<Source><![CDATA[
    private boolean isBatchAlreadyRunning(RefRecId _curBatchJobId)
    {
        boolean ret = false;

        if (LedgerTransferOpeningCheckExistingBatchFlight::instance().isEnabled())
        {
            Batch batch;
            BatchJob batchJob;

            select firstonly RecId from batchJob
                    where batchJob.RecId != _curBatchJobId
                exists join batch
                    where batch.BatchJobId == batchJob.RecId
                        && (batch.Status == BatchStatus::Waiting || batch.Status == BatchStatus::Executing)
                        && batch.Company == curExt()
                        && batch.ClassNumber == classNum(LedgerTransferOpening);

            ret = batchJob.RecId > 0;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>