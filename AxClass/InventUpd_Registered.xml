<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpd_Registered</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventUpd_Registered</c> class sets the status of inventory transactions as registered.
/// </summary>
/// <remarks>
///    See the <c>InventTransWMS_Register::updateInvent</c> method for an example of how this class is
///    used.
/// </remarks>
public class InventUpd_Registered extends InventUpdate implements WHSILocationLoadTrackingContext, WMSILocationLoadTrackingContext
{
    // new parameters
    InventQtyRegistered             registered;
    DateInvent                      dateInvent;

    InventDim                       regInventDimCriteria;
    InventDimParm                   regInventDimParm;

    InventDim                       arrInventDimCriteria;
    InventDimParm                   arrInventDimParm;

    // internal init
    InventDimId                     registerDimId;

    InventQty                       estimated;
    UnitQty                         estimatedUnit;

    // update result
    InventQty                       updRegistered;

    WMSLocationLoadCreateManager    wmsLocationLoadCreateManager;
    WHSLocationLoadChangeTracker    whsLocationLoadChangeTracker;

    PdsCWRegistered                 cwRegistered;
    PdsCWInventQty                  cwEstimated;
    PdsCWInventQty                  cwUpdRegistered;

    PdsUseVendBatchDate             useVendDate;

    InventQty                       inventQtyAdjustment;

    boolean                         adjustWMSLocationLoad;
    boolean                         skipQualityOrderCreation;
    boolean                         skipSumUpTransDistributeCwQtyZero;

    boolean                         alwaysTryAndUseRegisterQty;

    private WHSLoadId                       loadId;
    private WhsLoadLineInventoryReceiptId   receiptId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    protected void initParameters(
        InventDim             _regInventDimCriteria,
        InventDimParm         _regInventDimParm,
        InventDim             _arrInventDimCriteria,
        InventDimParm         _arrInventDimParm,
        InventQtyRegistered   _registered,
        PdsCWRegistered       _cwRegistered = 0,
        DateInvent            _dateInvent = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        boolean               _alwaysTryAndUseRegisterQty = false)

    {
        this.setParmAllowDefault();
        this.parmRegInventDimCriteria(_regInventDimCriteria);
        this.parmRegInventDimParm(_regInventDimParm);
        this.parmArrInventDimCriteria(_arrInventDimCriteria);
        this.parmArrInventDimParm(_arrInventDimParm);
        this.parmRegistered(_registered);
        this.parmDateInvent(_dateInvent);

        this.parmPdsCWRegistered(_cwRegistered);
        this.parmAlwaysTryAndUseRegisterQty(_alwaysTryAndUseRegisterQty);

        this.initUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public WHSLoadId parmLoadId(WHSLoadId _loadId = loadId)
    {
        loadId = _loadId;

        return loadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptId</Name>
				<Source><![CDATA[
    internal WhsLoadLineInventoryReceiptId parmReceiptId(WhsLoadLineInventoryReceiptId _receiptId = receiptId)
    {
        receiptId = _receiptId;

        return receiptId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSLocationLoadChangeTracker</Name>
				<Source><![CDATA[
    public WHSLocationLoadChangeTracker parmWHSLocationLoadChangeTracker(WHSLocationLoadChangeTracker _whsLocationLoadChangeTracker = whsLocationLoadChangeTracker)
    {
        if (prmisDefault(_whsLocationLoadChangeTracker))
        {
            if (!whsLocationLoadChangeTracker)
            {
                whsLocationLoadChangeTracker = WHSLocationLoadChangeTracker::construct();
            }
        }
        else
        {
            whsLocationLoadChangeTracker = _whsLocationLoadChangeTracker;
        }

        return whsLocationLoadChangeTracker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWMSLocationLoadCreateManager</Name>
				<Source><![CDATA[
    public WMSLocationLoadCreateManager parmWMSLocationLoadCreateManager(WMSLocationLoadCreateManager _wmsLocationLoadCreateManager = wmsLocationLoadCreateManager)
    {
        wmsLocationLoadCreateManager = _wmsLocationLoadCreateManager;

        return wmsLocationLoadCreateManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipSumUpTransDistributeCwQtyZero</Name>
				<Source><![CDATA[
    public boolean parmSkipSumUpTransDistributeCwQtyZero(boolean _skipSumUpTransDistributeCwQtyZero = skipSumUpTransDistributeCwQtyZero)
    {
        skipSumUpTransDistributeCwQtyZero = _skipSumUpTransDistributeCwQtyZero;

        return skipSumUpTransDistributeCwQtyZero;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipProductDimensionCheck</Name>
				<Source><![CDATA[
    public boolean canSkipProductDimensionCheck()
    {
        // Do not skip the dimension checks if we expect to create new transactions.
        return !(estimated || cwEstimated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    public boolean check()
    {
        boolean ok = true;

        if (registered && !movement.checkDimPhysical(registered, regInventDimCriteria, false, true))
        {
            ok = false;
        }

        if (!this.checkUpdateMovement(dateInvent))
        {
            ok = false;
        }

        if (!movement.checkCountingLocks(regInventDimCriteria))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateMovement</Name>
				<Source><![CDATA[
    protected boolean checkUpdateMovement(TransDate _transDate)
    {
        boolean ok = true;

        if (!movement.checkUpdateStandard(_transDate))
        {
            ok = false;
        }

        if (!movement.checkUpdateRegistered(this))
        {
            ok = false;
        }

        if (registered > 0 && !movement.checkCountingLocks(regInventDimCriteria))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUseOfNumberGroups</Name>
				<Source><![CDATA[
    protected void checkUseOfNumberGroups()
    {
        InventTable     inventTable;
        InventNumGroup  inventNumGroup;
        InventTransSum  inventTransSum;
        InventDim       inventDimExtra;
        InventDimParm   inventDimParmExtra;
        InventQty       qty;

        if (registered <= 0)
        {
            throw(error(Error::wrongUseOfFunction(funcName())));
        }

        if (regInventDimParm.InventSerialIdFlag && regInventDimCriteria.InventSerialId && !arrInventDimParm.InventSerialIdFlag)
        {   // if serial number is only on inventTrans and not on movement, try to match these
            inventTable = InventTable::find(movement.itemId());
            if (inventTable && inventTable.SerialNumGroupId)
            {
                inventNumGroup = InventNumGroup::find(inventTable.SerialNumGroupId);
                if (inventNumGroup && !inventNumGroup.ManualAllocation && inventNumGroup.OnlyInventTransaction)
                {
                    inventDimExtra.data(arrInventDimCriteria.data());
                    inventDimExtra.InventSerialId = regInventDimCriteria.InventSerialId;
                    inventDimParmExtra.data(arrInventDimParm.data());
                    inventDimParmExtra.InventSerialIdFlag = NoYes::Yes;
                    inventTransSum = InventTransSum::newChildTypeInventDim();
                    qty  = inventTransSum.originArrived(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), inventDimExtra, inventDimParmExtra);
                    qty += inventTransSum.originOrdered(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), inventDimExtra, inventDimParmExtra);
                    if (qty >= registered)
                    {
                        arrInventDimCriteria.InventSerialId =  regInventDimCriteria.InventSerialId;
                        arrInventDimParm.InventSerialIdFlag = NoYes::Yes;
                    }
                }
            }
        }

        if (regInventDimParm.InventBatchIdFlag && regInventDimCriteria.InventBatchId && !arrInventDimParm.InventBatchIdFlag)
        {   // if batch number is only on inventTrans and not on movement, try to match these
            inventTable = InventTable::find(movement.itemId());
            if (inventTable && inventTable.BatchNumGroupId)
            {
                inventNumGroup = InventNumGroup::find(inventTable.BatchNumGroupId);
                if (inventNumGroup && !inventNumGroup.ManualAllocation && inventNumGroup.OnlyInventTransaction)
                {
                    inventDimExtra.data(arrInventDimCriteria.data());
                    inventDimExtra.InventBatchId = regInventDimCriteria.InventBatchId;
                    inventDimParmExtra.data(arrInventDimParm.data());
                    inventDimParmExtra.InventBatchIdFlag = NoYes::Yes;
                    inventTransSum = InventTransSum::newChildTypeInventDim();
                    qty  = inventTransSum.originArrived(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), inventDimExtra, inventDimParmExtra);
                    qty += inventTransSum.originOrdered(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), inventDimExtra, inventDimParmExtra);
                    if (qty >= registered)
                    {
                        arrInventDimCriteria.InventBatchId =  regInventDimCriteria.InventBatchId;
                        arrInventDimParm.InventBatchIdFlag = NoYes::Yes;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    protected void initUpdate()
    {
        estimated       = 0;
        estimatedUnit   = 0;

        cwEstimated     = 0;

        super();

        if (movement.pdsCWItem())
        {
            if (cwRegistered > 0)
            {
                if (movement.transIdSum().pdsCWEstimatedReceipt() < cwRegistered)
                {
                    cwEstimated     = cwRegistered - movement.transIdSum().pdsCWEstimatedReceipt();
                    // Estimate additional quantity based on nominal conversion. The discrepancy between
                    // the actual and the nominal values will be added to adjustment quantity.
                    estimated       = PdsCatchWeight::inventQty(movement.itemId(), cwEstimated);
                    estimatedUnit   = this.calcEstimatedUnit(estimated);
                }

                inventQtyAdjustment = this.pdsCalculateInventoryQuantityAdjustment(
                    movement.itemId(),
                    movement.transIdSum().pdsCWEstimatedReceipt() + cwEstimated,
                    movement.transIdSum().estimatedReceipt() + estimated,
                    cwRegistered,
                    registered);
            }
            else
            {
                inventQtyAdjustment = this.pdsCalculateInventoryQuantityAdjustment(
                    movement.itemId(),
                    movement.transIdSum().pdsCWRegistered(),
                    movement.transIdSum().registered(),
                    -cwRegistered,
                    -registered);

                // We still need to unregister the quantity that will be adjusted afterwards
                registered += inventQtyAdjustment;
            }

            if (registered > 0)
            {
                registerDimId = InventDim::findOrCreate(regInventDimCriteria).InventDimId;
            }
        }
        else
        {
            if (registered > 0)
            {
                if (!this.parmAlwaysTryAndUseRegisterQty() && movement.transIdSum().estimatedReceipt() < registered)
                {
                    estimated       = registered - movement.transIdSum().estimatedReceipt();
                    estimatedUnit   = this.calcEstimatedUnit(estimated);
                }

                registerDimId = InventDim::findOrCreate(regInventDimCriteria).InventDimId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new( InventMovement        _inventMovement)
    {
        adjustWMSLocationLoad = true;

        super(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustWMSLocationLoad</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to adjust the load on a <c>wmsLocation</c> location when a physical transaction
    ///    occurs.
    /// </summary>
    /// <param name="_adjustWMSLocationLoad">
    ///    A Boolean value that determines whether to adjust the load on a <c>wmsLocation</c> location;
    ///    optional.
    /// </param>
    /// <returns>
    ///    true if the load on a <c>wmsLocation</c> location should be adjusted; otherwise, false.
    /// </returns>
    public boolean parmAdjustWMSLocationLoad(boolean _adjustWMSLocationLoad = adjustWMSLocationLoad)
    {
        adjustWMSLocationLoad = _adjustWMSLocationLoad;

        return adjustWMSLocationLoad;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAlwaysTryAndUseRegisterQty</Name>
				<Source><![CDATA[
    public boolean parmAlwaysTryAndUseRegisterQty(boolean _alwaysTryAndUseRegisterQty = alwaysTryAndUseRegisterQty)
    {
        alwaysTryAndUseRegisterQty = _alwaysTryAndUseRegisterQty;

        return alwaysTryAndUseRegisterQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmArrInventDimCriteria</Name>
				<Source><![CDATA[
    public InventDim parmArrInventDimCriteria(InventDim _inventDimCriteria  = arrInventDimCriteria)
    {
        arrInventDimCriteria = _inventDimCriteria;
        return arrInventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmArrInventDimParm</Name>
				<Source><![CDATA[
    protected InventDimParm parmArrInventDimParm(InventDimParm _inventDimParm = arrInventDimParm)
    {
        arrInventDimParm = _inventDimParm;
        return arrInventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateInvent</Name>
				<Source><![CDATA[
    public DateInvent parmDateInvent(DateInvent _dateInvent = dateInvent)
    {
        dateInvent = _dateInvent;
        return dateInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWRegistered</Name>
				<Source><![CDATA[
    public PdsCWInventQty parmPdsCWRegistered(
        PdsCWInventQty _cwRegistered = cwRegistered)
    {
        cwRegistered = _cwRegistered;
        return cwRegistered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRegInventDimCriteria</Name>
				<Source><![CDATA[
    public InventDim parmRegInventDimCriteria(InventDim _inventDimCriteria  = regInventDimCriteria)
    {
        regInventDimCriteria = _inventDimCriteria;
        return regInventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRegInventDimParm</Name>
				<Source><![CDATA[
    protected InventDimParm parmRegInventDimParm(InventDimParm _inventDimParm = regInventDimParm)
    {
        regInventDimParm = _inventDimParm;
        return regInventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRegistered</Name>
				<Source><![CDATA[
    public InventQty parmRegistered(InventQty _registered = registered)
    {
        registered = _registered;
        return registered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipQualityOrderCreation</Name>
				<Source><![CDATA[
    public boolean parmSkipQualityOrderCreation(boolean _skipQualityOrderCreation = skipQualityOrderCreation)
    {
        skipQualityOrderCreation = _skipQualityOrderCreation;

        return skipQualityOrderCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustInventoryQuantity</Name>
				<Source><![CDATA[
    public void pdsAdjustInventoryQuantity(
        InventQty _inventQtyAdjustment,
        InventDimId _inventDimId = movement.inventDimId())
    {
        if (movement.pdsCWItem() && _inventQtyAdjustment)
        {
            RefRecId markingRefInventTransOrigin = movement.markingRefInventTransOrigin();
            if (markingRefInventTransOrigin)
            {
                // Marking for entire lotId exists => additional should also be marked.
                // But before marking we need to adjust inventory quantity for the counterpart!
                InventMovement counterpartMovement = InventMovement::construct(InventTransOrigin::find(markingRefInventTransOrigin));

                // This adjustment should be done only if we have enough inventory quantity with status Ordered
                // for counterpart movement:
                InventQty counterpartOrderedInventQty = counterpartMovement.transIdSum().ordered();
                if (counterpartOrderedInventQty >= _inventQtyAdjustment)
                {
                    counterpartMovement.pdsAdjustInventoryQuantity(-_inventQtyAdjustment);
                    counterpartMovement.pdsUpdateBufferWithAdjustedQuantity();
                }
            }
        }

        super(_inventQtyAdjustment, _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustRegisteredInventoryQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust inventory quantities for CW item based inventory transactions using data provided during registration.
    /// </summary>
    /// <remarks>
    /// First inventory quantities adjusted for marked transactions, and only after, if needed, the preferred transaction gets adjusted.
    /// </remarks>
    private void pdsAdjustRegisteredInventoryQuantities()
    {
        InventTrans         inventTrans;
        InventTrans         inventTransCachedFieldsOnly;
        InventQty           inventQtyToAdjust = registered;
        PdsCWInventQty      cwQtyToAdjust = cwRegistered;
        InventQty           stepInventQtyAdjustment;
        PdsCWInventQty      stepCWInventQtyAdjustment;
        InventQty           totalInventQtyAdjustmet;
        InventQty           recalculatedInventQuantity;
        InventMovement      counterpartMovement;

        boolean             inventQtyRegisteredMore;
        boolean             inventQtyAdjustmetDirectionsIsSet;

        if (movement.pdsCWItem() && inventQtyToAdjust && cwQtyToAdjust && !movement.isTransfer())
        {
            // Combine ordered list of transactions.
            //
            // Inventory quantities should be adjusted for some of these transactions:
            // We'll use for quantity adjustment transactions placed in the list above (and including-)
            // the preferred invent trans.
            this.initInventTransToReceiveList(
                            StatusReceipt::Arrived,
                            StatusReceipt::Ordered,
                            arrInventDimCriteria.InventDimId,
                            arrInventDimCriteria,
                            arrInventDimParm,
                            movement.transChildType(),
                            movement.transChildRefId(),
                            inventQtyToAdjust,
                            true);

            InventTransOriginId inventTransOrigIdFromMovement = movement.inventTransOriginId();
            List inventoryQuantityAdjustmentList = new List (Types::Container);

            // Finding out required decimal precision for inventory quantity calculations:
            UnitOfMeasureDecimalPrecision unitOfMeasureDecimalPrecision = UnitOfMeasure::unitOfMeasureDecimalPrecision(
                                                                                  UnitOfMeasure::unitOfMeasureIdBySymbol(
                                                                                          InventTableModule::find(movement.itemId(), ModuleInventPurchSales::Invent).UnitId));

            while (this.getNextInventTransToReceive(inventTrans))
            {
                if (!cwQtyToAdjust)
                {
                    // DONE...
                    break;
                }
                // Calculate required inventory quantity adjustment for current transaction
                // (validation regarding CW boundaries should already have been made when registration numbers were processed,
                // so we don't need to worry about crossing these boundaries here)
                // N.B.
                // It is assumed that all CW units being registered have the same weight.
                if (cwQtyToAdjust <= inventTrans.PdsCWQty)
                {
                    // Current transaction is larger than needed for quantity adjustment...
                    // It can accommodate the remaining adjustments,
                    // but we still need to calculate stepCWInventQtyAdjustmen and stepInventQtyAdjustment numbers
                    InventQty largeInventTransQtyFraction = decRound((inventTrans.Qty/inventTrans.PdsCWQty) * cwQtyToAdjust, unitOfMeasureDecimalPrecision);
                    PdsCWInventQty largeInventTransCWQtyFraction = cwQtyToAdjust;

                    stepCWInventQtyAdjustment = largeInventTransCWQtyFraction;
                    recalculatedInventQuantity = inventQtyToAdjust;
                    stepInventQtyAdjustment = largeInventTransQtyFraction - recalculatedInventQuantity;
                }
                else
                {
                    // Calculate inventory quantity required for inventory transaction
                    recalculatedInventQuantity = decRound((registered/cwRegistered)*min(cwQtyToAdjust, inventTrans.PdsCWQty), unitOfMeasureDecimalPrecision);
                    stepInventQtyAdjustment = inventTrans.Qty - recalculatedInventQuantity;
                    stepCWInventQtyAdjustment = inventTrans.PdsCWQty;
                }

                if (!inventQtyAdjustmetDirectionsIsSet)
                {
                    inventQtyRegisteredMore = (stepInventQtyAdjustment < 0);
                    inventQtyAdjustmetDirectionsIsSet = true;
                }

                if (stepInventQtyAdjustment && inventTrans.MarkingRefInventTransOrigin)
                {
                    // For marked transactions:
                    // Collect data for doing marking adjustments later:
                    inventoryQuantityAdjustmentList.addEnd([inventTrans.RecId, inventTrans.MarkingRefInventTransOrigin, stepInventQtyAdjustment]);
                }

                // Update values for next step:
                cwQtyToAdjust-= stepCWInventQtyAdjustment;
                inventQtyToAdjust -= (recalculatedInventQuantity);
                totalInventQtyAdjustmet += stepInventQtyAdjustment;

                if (inventTrans.RecId == preferedInventTransRecId)
                {
                    // We shouldn't go below the preferred transaction in the list
                    break;
                }
            }

            if (totalInventQtyAdjustmet)
            {
                ListIterator inventoryQuantityAdjustmentIterator = new ListIterator(inventoryQuantityAdjustmentList);

                // Probably we need to adjust marked quantities here
                // (for scenario when registering inventory quantities less, than anticipated)
                if (!inventQtyRegisteredMore)
                {
                    while (inventoryQuantityAdjustmentIterator.more())
                    {
                        List markingInventoryOriginIdList = new List(Types::Int64);

                        [ inventTransCachedFieldsOnly.RecId
                        , inventTransCachedFieldsOnly.MarkingRefInventTransOrigin
                        , stepInventQtyAdjustment                                   ] = inventoryQuantityAdjustmentIterator.value();

                        do
                        {
                        // As we have created the list with adjustment to only marked transactions,
                        // there is no need to check that MarkingRefInventTransOrigin is set.
                        // Execute postponed marking adjustments (paired operation):
                        InventTransOrigin::deleteMarking( inventTransOrigIdFromMovement
                                                        , inventTransCachedFieldsOnly.MarkingRefInventTransOrigin
                                                        , stepInventQtyAdjustment);
                        InventTransOrigin::deleteMarking( inventTransCachedFieldsOnly.MarkingRefInventTransOrigin
                                                        , inventTransOrigIdFromMovement
                                                        , -stepInventQtyAdjustment);
                            markingInventoryOriginIdList.addStart(inventTransCachedFieldsOnly.MarkingRefInventTransOrigin);

                            // Adjust the related inventory quantity. Eg. PO -mark- TO -mark- SO,
                            // need to adjust the inventory quantity of the SO accordingly.
                            [inventTransCachedFieldsOnly.RecId, inventTransCachedFieldsOnly.MarkingRefInventTransOrigin]
                                = this.traceUpTransferChain(inventTransCachedFieldsOnly.MarkingRefInventTransOrigin);
                        } while (inventTransCachedFieldsOnly.RecId);

                        ListIterator markingInventoryOriginIdIterator = new ListIterator(markingInventoryOriginIdList);
                        while (markingInventoryOriginIdIterator.more())
                        {
                            // Additionally adjust inventory quantity  the counterparts:
                            counterpartMovement = InventMovement::construct(InventTransOrigin::find(markingInventoryOriginIdIterator.value()));
                        counterpartMovement.pdsAdjustInventoryQuantity(stepInventQtyAdjustment);
                        counterpartMovement.pdsUpdateBufferWithAdjustedQuantity();

                            markingInventoryOriginIdIterator.next();
                        }
                        // Move to the next postponed marking adjustment
                        inventoryQuantityAdjustmentIterator.next();
                    }
                }
                // Now we can adjust inventory quantities for the whole movement according to total adjustment calculations:
                movement.pdsAdjustInventoryQuantity(-totalInventQtyAdjustmet);
                movement.pdsUpdateBufferWithAdjustedQuantity();

                // Probably we need to adjust marked quantities here
                // (for scenario when registering inventory quantities larger, than anticipated)
                if (inventQtyRegisteredMore)
                {
                    boolean reReadTransForProjPOFlightEnabled = InventRegisterReReadCWInventTransForProjPOFlight::instance().isEnabled();

                    while (inventoryQuantityAdjustmentIterator.more())
                    {
                        [ inventTransCachedFieldsOnly.RecId
                        , inventTransCachedFieldsOnly.MarkingRefInventTransOrigin
                        , stepInventQtyAdjustment                               ] = inventoryQuantityAdjustmentIterator.value();

                        do
                        {
                        // Update of inventTrans object will be required - select complete record with forUpdate flag:
                        inventTrans = InventTrans::findRecId(inventTransCachedFieldsOnly.RecId, true);

                        // Again, the list of deferred inventory quantity adjustments was created for marked transactions ONLY,
                        // there is no need to check that MarkingRefInventTransOrigin is set.
                        // Execute postponed marking adjustments (increase marked invent quantity):

                        //Adjust inventory quantity for the counterparts
                        counterpartMovement = InventMovement::construct(InventTransOrigin::find(inventTrans.MarkingRefInventTransOrigin));
                        counterpartMovement.pdsAdjustInventoryQuantity(stepInventQtyAdjustment);
                        counterpartMovement.pdsUpdateBufferWithAdjustedQuantity();

                        // Execute postponed marking updates (paired operation):
                        InventTransOrigin::updateMarking( inventTransOrigIdFromMovement
                                                        , inventTrans.MarkingRefInventTransOrigin
                                                        , -stepInventQtyAdjustment);
                        InventTransOrigin::updateMarking( inventTrans.MarkingRefInventTransOrigin
                                                        , inventTransOrigIdFromMovement
                                                        , stepInventQtyAdjustment);
                        // Update reservation:
                        InventMovement movementIssue = InventTrans::findByInventTransOrigin(inventTrans.MarkingRefInventTransOrigin).inventMovement(true);
                        if (movementIssue)
                        {
                            // Reserve the issue according to marking.
                            InventUpd_Reservation::updateReserveRefTransIdOnOrder(movementIssue);
                        }

                        if (inventTrans.ProjId != '' && reReadTransForProjPOFlightEnabled)
                        {
                            InventTrans inventTransLocal = InventTrans::findRecId(inventTrans.RecId);

                            if (inventTransLocal.RecVersion != inventTrans.RecVersion)
                            {
                                inventTrans.reread();
                            }
                        }

                        // Need to sum-up here.
                        inventTrans.updateSumUp();

                            // Adjust the related inventory quantity. E.g. PO -mark- TO -mark- SO,
                            // need to adjust the inventory quantity of the SO accordingly.
                            [inventTransCachedFieldsOnly.RecId, inventTransCachedFieldsOnly.MarkingRefInventTransOrigin]
                                = this.traceUpTransferChain(inventTransCachedFieldsOnly.MarkingRefInventTransOrigin);
                        } while (inventTransCachedFieldsOnly.RecId);

                        // Proceed to the next postponed marking adjustment
                        inventoryQuantityAdjustmentIterator.next();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSetBatchAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the batch attribute value.
    /// </summary>
    /// <param name="_inventBatchId">
    /// The batch ID for the inventory transaction that is being registered.
    /// </param>
    public void pdsSetBatchAttributeValue(InventBatchId _inventBatchId)
    {
        PDSBaseValue            baseValue    = movement.pdsGetBaseValue();
        ItemId                  itemId       = movement.itemId();
        PdsBatchAttribByItem    attribByItem = InventTable::pdsFindBaseAttribute(itemId);

        if (!attribByItem)
        {
            return;
        }

        ttsbegin;

        if (!InventTable::pdsFindBaseAttribute(itemId).pdsCheckAttribCriteria(baseValue))
        {
            // the above call issues error on the infolog when the validation fails
            throw Exception::Error;
        }

        PdsBatchAttributes attribValue = PdsBatchAttributes::find(itemId, _inventBatchId, attribByItem.PdsBatchAttribRelation, true);

        if (attribValue)
        {
            attribValue.PdsBatchAttribValue = baseValue;

            if (!attribValue.PdsBatchAttribId)
            {
                attribValue.PdsBatchAttribId = attribByItem.PdsBatchAttribRelation;
            }

            attribValue.update();
        }
        else
        {
            attribValue.initValue();
            attribValue.ItemId              = itemId;
            attribValue.InventBatchId       = _inventBatchId;
            attribValue.PdsBatchAttribId    = attribByItem.PdsBatchAttribRelation;
            attribValue.PdsBatchAttribValue = baseValue;
            attribValue.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickReleatedIssueTransMore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks related inventory transactions for transfers. Use this when registered > 0
    /// </summary>
    private void pickReleatedIssueTransMore()
    {
        InventMovement relatedMovement = movement.relatedMovement();

        if (!relatedMovement)
        {
            throw error(strFmt("@SYS19306",funcName()));
        }

        InventDimParm inventDimParm = movement.dimParmRelatedUpdate(regInventDimCriteria);
        InventTransSum inventTransSum = InventTransSum::newChildTypeInventDim();

        InventDim inventDimRelated = relatedMovement.inventdim();
        // The from location might not be lp controlled and for that case we do not want to compare against LP since there will be no LPs on that location
        if (inventDimParm.LicensePlateFlag && !inventDimRelated.wmsLocation().whsLocationIsLPControlled())
        {
            inventDimParm.LicensePlateFlag = NoYes::No;
        }

        //construct Inventdim based on what is being registered
        inventDimRelated.copyDimParmDim(relatedMovement.inventDimGroupSetup(),regInventDimCriteria,inventDimParm);
        inventDimRelated = InventDim::findOrCreate(inventDimRelated);

        //We need to examine how many inventTrans we have in order to determine how much that can be picked on a trans basis
        InventQty qtyAllreadyReceivedTrans = inventTransSum.originReceiptInTotal(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), regInventDimCriteria, inventDimParm)
                                              - (inventTransSum.originOrdered(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), regInventDimCriteria, inventDimParm)
                                              + inventTransSum.originArrived(movement.inventTransOriginId(), movement.transChildType(), movement.transChildRefId(), regInventDimCriteria, inventDimParm));

        InventQty qtyReservedPhysicalTrans = inventTransSum.originReservPhysical(relatedMovement.inventTransOriginId(), relatedMovement.transChildType(), relatedMovement.transChildRefId(), inventDimRelated, inventDimParm);

        InventQty qtyReservedOnOrderTrans = inventTransSum.originReservOrdered(relatedMovement.inventTransOriginId(), relatedMovement.transChildType(), relatedMovement.transChildRefId(), inventDimRelated ,inventDimParm);

        InventQty qtyOnOrderTrans = inventTransSum.originOnOrder(relatedMovement.inventTransOriginId(), relatedMovement.transChildType(), relatedMovement.transChildRefId(), inventDimRelated, inventDimParm);

        InventQty qtyCanPickTrans = qtyReservedPhysicalTrans + qtyReservedOnOrderTrans + qtyOnOrderTrans;

        InventQty qtyAllreadyShippedTrans = abs(inventTransSum.originIssueInTotal(relatedMovement.inventTransOriginId(), relatedMovement.transChildType(), relatedMovement.transChildRefId(), inventDimRelated, inventDimParm)
                                             - qtyCanPickTrans);

        PdsCWInventQty cwAllreadyReceivedTrans =
            inventTransSum.pdsCWidReceiptInTotal(
                movement.inventTransOriginId(),
                movement.transChildType(),
                movement.transChildRefId(),
                regInventDimCriteria,
                inventDimParm)
            - (inventTransSum.pdsCWidOrdered(
                    movement.inventTransOriginId(),
                    movement.transChildType(),
                    movement.transChildRefId(),
                    regInventDimCriteria,
                    inventDimParm)
                + inventTransSum.pdsCWidArrived(
                    movement.inventTransOriginId(),
                    movement.transChildType(),
                    movement.transChildRefId(),
                    regInventDimCriteria,
                    inventDimParm));

        PdsCWInventQty cwReservedPhysicalTrans =
            inventTransSum.pdsCWidReservPhysical(
                relatedMovement.inventTransOriginId(),
                relatedMovement.transChildType(),
                relatedMovement.transChildRefId(),
                inventDimRelated,
                inventDimParm);

        PdsCWInventQty cwReservedOnOrderTrans =
            inventTransSum.pdsCWidReservOrdered(
                relatedMovement.inventTransOriginId(),
                relatedMovement.transChildType(),
                relatedMovement.transChildRefId(),
                inventDimRelated,
                inventDimParm);

        PdsCWInventQty cwOnOrderTrans =
            inventTransSum.pdsCWidOnOrder(
                relatedMovement.inventTransOriginId(),
                relatedMovement.transChildType(),
                relatedMovement.transChildRefId(),
                inventDimRelated,
                inventDimParm);

        PdsCWInventQty cwCanPickTrans =
                cwReservedPhysicalTrans
                + cwReservedOnOrderTrans
                + cwOnOrderTrans;

        PdsCWInventQty cwAllreadyShippedTrans =
                abs(inventTransSum.pdsCWidIssueInTotal(
                        relatedMovement.inventTransOriginId(),
                        relatedMovement.transChildType(),
                        relatedMovement.transChildRefId(),
                        inventDimRelated,
                        inventDimParm)
                - cwCanPickTrans);

        if (qtyAllreadyShippedTrans < qtyAllreadyReceivedTrans + registered)
        {
            InventQty       qtyToPick;
            PdsCWInventQty  cwToPick;
            InventQty       qtyAvailableOnHand;
            PdsCWInventQty  cwAvailableOnHand;

            if (qtyAllreadyShippedTrans <= qtyAllreadyReceivedTrans)
            {
                qtyToPick = -registered;
                cwToPick  = -cwRegistered;
            }
            else
            {
                qtyToPick   = -((qtyAllreadyReceivedTrans + registered) - qtyAllreadyShippedTrans);
                cwToPick    = -((cwAllreadyReceivedTrans + cwRegistered) - cwAllreadyShippedTrans);
            }

            if (qtyToPick < qtyReservedPhysicalTrans)
            {
                InventOnHandQty onHandQty = InventOnHandQty::newPhysicalInvent(relatedMovement, inventDimRelated);
                qtyAvailableOnHand  = -onHandQty.availPhysical();
                cwAvailableOnHand   = -onHandQty.pdsCWAvailPhysical();
            }

            qtyToPick = max(qtyAvailableOnHand + qtyReservedPhysicalTrans, max(qtyToPick,qtyCanPickTrans));

            cwToPick =
                max(
                    cwAvailableOnHand + cwReservedPhysicalTrans,
                    max(cwToPick, cwCanPickTrans));

            this.validateRelatedMovementRemainingQuantity(qtyCanPickTrans - qtyToPick, cwCanPickTrans - cwToPick);

            if (qtyToPick)
            {
                InventUpd_Picked inventUpd_Picked = this.initializeInventUpd_Picked(relatedMovement, inventDimRelated, inventDimParm, qtyToPick, cwToPick);
                inventUpd_Picked.updateNow();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRelatedMovementRemainingQuantity</Name>
				<Source><![CDATA[
    private void validateRelatedMovementRemainingQuantity(InventQty _remainingQty, PdsCWInventQty _remainingCWQty)
    {
        if(!PdsCatchWeight::validateInventQty(movement.itemId(), _remainingQty, _remainingCWQty, false))
        {
            PdsCatchWeightItem item = PdsCatchWeightItem::find(movement.itemId());
            warning(strFmt("@SCM:InvalidQuantitiesAtTransitWarehouse", abs(_remainingCWQty * item.PdsCWMin), abs(_remainingCWQty * item.PdsCWMax), item.ItemId));
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventUpd_Picked</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs and initializes an <c>InvendUpd_Picked</c> instance.
    /// </summary>
    /// <param name = "_relatedMovement">
    ///     An <c>InventMovement</c> instance.
    /// </param>
    /// <param name = "_inventDimRelated">
    ///     The related inventory dimension.
    /// </param>
    /// <param name = "_inventDimParm">
    ///     An <c>InventDimParm</c> instance.
    /// </param>
    /// <param name = "_qtyToPick">
    ///     The inventory quantity to pick.
    /// </param>
    /// <param name = "_cwToPick">
    ///     The catch weight quantity to pick.
    /// </param>
    /// <returns>
    ///     The initialized <c>InvendUpd_Picked</c> instance.
    /// </returns>
    protected InventUpd_Picked initializeInventUpd_Picked(
        InventMovement _relatedMovement,
        InventDim _inventDimRelated, 
        InventDimParm _inventDimParm,
        InventQty _qtyToPick,
        PdsCWInventQty _cwToPick)
    {
        InventUpd_Picked inventUpd_Picked = InventUpd_Picked::newParameters(
                                                _relatedMovement, 
                                                _inventDimRelated, 
                                                _inventDimParm, 
                                                _inventDimRelated, 
                                                _inventDimParm, 
                                                _qtyToPick,
                                                '',
                                                _cwToPick);

        inventUpd_Picked.parmKeepExistingDim(true);
        inventUpd_Picked.parmAdjustWMSLocationLoad(this.parmAdjustWMSLocationLoad());

        return inventUpd_Picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow()
    {
        using (var telemetryTask = new InventUpdateInstrumentationTask(this))
        {
			InventBlockingInventStatusSync  inventBlockingInventStatusSync;

			ttsbegin;

			if (registered)
			{
				if (!this.checkUpdateMovement(dateInvent))
				{
					throw error("@SYS18447");
				}

				if (adjustWMSLocationLoad)
				{
					wmsLocationLoadCreateManager = WMSLocationLoadCreateManager::construct();
				}

				if (registered > 0)
				{
					inventBlockingInventStatusSync = InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, registered, cwRegistered, movement.inventdim(), regInventDimCriteria);
					inventBlockingInventStatusSync.preSync();

					if (estimated
						|| cwEstimated
						)
					{
						this.updateEstimated(estimated,estimatedUnit
							, cwEstimated
							);
					}
					this.pdsAdjustRegisteredInventoryQuantities();
					this.updateRegisterMore();
				}
				else
				{
					inventBlockingInventStatusSync = InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, registered, cwRegistered, regInventDimCriteria, movement.inventdim(), true);
					inventBlockingInventStatusSync.preSync();

					this.updateRegisterLess();

					this.pdsAdjustInventoryQuantity(inventQtyAdjustment);
				}

				if (adjustWMSLocationLoad)
				{
					wmsLocationLoadCreateManager.insertRecords();
				}

				inventBlockingInventStatusSync.postSync();

				this.registrationCompleted(this);
			}

			ttscommit;

			if (#PdsBatchAttribEnabled)
			{
				if (registered > 0
				 && movement.mustUpdateBatchAttribValues())
				{
					InventQualityReferenceType::newPdsBatchAttribUpdateBuffer(
						movement.buffer(),
						PdsBatchAttribUpdateType::Registration).pdsBatchAttribSelect();
				}
			}
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registrationCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate method for signaling to subscribers that an inventory registration has been completed
    /// </summary>
    /// <param name = "_inventUpd_Registered">
    /// The object <c>InventUpd_Registered</c> that is triggering the event
    /// </param>
    /// <remarks>
    ///    See the <c>WHSWorkCreateReceiving::InventUpd_Registered_registrationCompleted</c> method for an example
    ///    of how this event can be handled by a subscriber
    /// </remarks>
    delegate void registrationCompleted(InventUpd_Registered _inventUpd_Registered)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRegisterInventTrans</Name>
				<Source><![CDATA[
    protected container updateRegisterInventTrans(
        InventTrans     _inventTrans,
        InventDimId     _registerInventDimId,
        InventQty       _addRegistered,
        PdsCWInventQty  _cwAddRegistered
        )
    {
        PdsCWInventQty cwAddRegistered = _cwAddRegistered;

        #PdsVendBatchPos
        StatusReceipt           origStatusReceipt = _inventTrans.StatusReceipt;

        if (! movement.inventTable().checkRefInventTrans(_inventTrans))
        {
            throw error("@SYS18447");
        }

        InventItemOrderSetupMap inventItemOrderSetupMap = movement.inventItemOrderSetupMap(regInventDimCriteria.InventDimId);

        if (!inventItemOrderSetupMap.checkInventLocationId(regInventDimCriteria.InventLocationId,!movement.canBeOnAllInventLocations()) ||
            !inventItemOrderSetupMap.checkInventSiteId(regInventDimCriteria.InventSiteId,!movement.canBeOnAllInventSites()))
        {
            throw error("@SYS18447");
        }

        if (_inventTrans.Qty > _addRegistered)
        {
            _inventTrans.updateSplit(_addRegistered, _cwAddRegistered);
        }

        _inventTrans.InventDimId       = _registerInventDimId;

        if (_inventTrans.Qty > 0)
        {
            this.updateInventTransReturn(_inventTrans, movement);
        }

        _inventTrans.DateInvent        = dateInvent;

        if (movement.mustClearChildRef())
        {
            _inventTrans.TransChildType   = InventTransChildType::None;
            _inventTrans.TransChildRefId  = '';
        }

        movement.initInventTransReceiptId(_inventTrans, receiptId);
        movement.initInventTransRegisteredLoad(_inventTrans, loadId);
        movement.transIdSum().setInventTransStatus(_inventTrans,StatusReceipt::Registered,StatusIssue::None);

        InventTrans origInventTrans = _inventTrans.orig();

        this.raiseOnHandChangingOnPhysicalStatusUpd(_inventTrans, origInventTrans);

        _addRegistered  -= _inventTrans.Qty;
        cwAddRegistered -= _inventTrans.PdsCWQty;

        this.writeInventTransAutoDim(_inventTrans, origInventTrans, true);

        InventDim inventDim = _inventTrans.inventDim();
        if (! movement.checkDimPhysical(_inventTrans.Qty, inventDim, true, true))
        {
            throw error("@SYS18447");
        }

        if (!this.parmSkipInventTransSumUp())
        {
            _inventTrans.updateSumUp();
        }

        return [_addRegistered, cwAddRegistered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRegisterLessInventTrans</Name>
				<Source><![CDATA[
    private InventTrans updateRegisterLessInventTrans()
    {
        InventTrans inventTrans;

        if (this.parmCustomInventTransListInitialized())
        {
            InventTransReceiveListParameters parameters = InventTransReceiveListParameters::construct();
        
            parameters.fromStatus = StatusReceipt::Registered;
            parameters.toStatus = StatusReceipt::Registered;
            parameters.inventDimId = regInventDimCriteria.InventDimId;
            parameters.inventDimCriteria = regInventDimCriteria;
            parameters.inventDimParm = regInventDimParm;
            parameters.inventTransChildType = movement.transChildType();
            parameters.inventTransChildRefId = movement.transChildRefId();
            parameters.loadId = loadId;

            this.initializeInventTransToReceiveListWithCustomInventTransList(parameters);

            this.getNextInventTransToReceive(inventTrans);
        }
        else
        {
            InventTrans = this.updateRegisterLessQueryInventTrans();
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRegisterLessQueryInventTrans</Name>
				<Source><![CDATA[
    private InventTrans updateRegisterLessQueryInventTrans()
    {
        InventTrans inventTrans;

        if (regInventDimCriteria.InventDimId && regInventDimParm.isAllFlagYes())
        {
            select forupdate inventTrans
            order by InventDimId desc
            where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                && inventTrans.TransChildType        == movement.transChildType()
                && inventTrans.TransChildRefId       == movement.transChildRefId()
                && inventTrans.StatusReceipt         == StatusReceipt::Registered
                && inventTrans.StatusIssue           == StatusIssue::None
                && inventTrans.InventDimId           == regInventDimCriteria.InventDimId
                && (loadId == '' || inventTrans.LoadId == loadId);
        }
        else
        {
            InventDim inventDim;

            select forupdate forceplaceholders inventTrans
            order by InventDimId desc
            where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                && inventTrans.TransChildType        == movement.transChildType()
                && inventTrans.TransChildRefId       == movement.transChildRefId()
                && inventTrans.StatusReceipt         == StatusReceipt::Registered
                && inventTrans.StatusIssue           == StatusIssue::None
                && (loadId == '' || inventTrans.LoadId == loadId)
                #InventDimExistsJoin(InventTrans.inventDimId, inventDim, regInventDimCriteria, regInventDimParm);
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInboundInventTransType</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean isInboundInventTransType(InventTransType _inventTransType)
    {
        return _inventTransType == InventTransType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRegisterLess</Name>
				<Source><![CDATA[
    protected void updateRegisterLess()
    {
        InventQty       addRegistered = -registered;
        PdsCWInventQty  cwAddRegistered = -cwRegistered;

        InventTrans inventTrans = this.updateRegisterLessInventTrans();
        boolean     allowNegativeInventoryForProjectPO = WHSUpdateRegisterLessAlowNegativeForProjectPOFlight::instance().isEnabled();
        InventTable inventTable = movement.inventTable();
        InventDim inventDim = movement.inventdim();

        boolean needMergeInventDim = (!inventDim.inventBatchId
            && inventTable.BatchNumGroupId
            && InventNumGroup::find(inventTable.BatchNumGroupId).OnlyInventTransaction
            && InventUpd_UnregisterBatchNumRemovedFlight::instance().isEnabled())
            || (!inventDim.inventSerialId
                && inventTable.SerialNumGroupId
                && InventNumGroup::find(inventTable.SerialNumGroupId).OnlyInventTransaction
                && InventUpd_UnregisterSerialNumRemovedFlight::instance().isEnabled());

        while (inventTrans)
        {
            InventDim inventDimOrig = InventTrans.inventDim();
            if (!movement.checkCountingLocks(inventDimOrig) || !movement.canInventTransBeUpdatedRegistered(inventTrans))
            {
                throw error("@SYS18447");
            }

            InventQty updateNowQuantity = this.transactionReceiptQuantity(inventTrans, addRegistered);

            if (updateNowQuantity < inventTrans.Qty)
            {
                inventTrans.updateSplit(updateNowQuantity, cwAddRegistered);
            }

            InventOnHandQty inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement,regInventDimCriteria);
            
            boolean allowNegativePhysicalInventory = allowNegativePhysical;

            if (allowNegativePhysicalInventory
                && this.isInboundInventTransType(movement.transType())
                && movement.isItemWHSEnabled()
                && regInventDimCriteria.wmsLocation().whsLocationProfile()
                && movement.inventTable().inventItemType().mustInventBeControlled()
                && (!allowNegativeInventoryForProjectPO || !movement.mustDoAutoLossProfitEstimate()))
            {
                allowNegativePhysicalInventory = regInventDimCriteria.wmsLocation().whsLocationProfile().AllowNegative;
            }

            if (!inventOnHandQty.checkItemDraw(-inventTrans.Qty, allowNegativePhysicalInventory, true, -inventTrans.PdsCWQty))
            {
                throw error("@SYS18447");
            }

            addRegistered   -= inventTrans.Qty;
            updRegistered   -= inventTrans.Qty;
            cwAddRegistered -= inventTrans.PdsCWQty;
            cwUpdRegistered -= inventTrans.PdsCWQty;

            movement.initInventTransReceiptId(inventTrans, '');
            movement.initInventTransRegisteredLoad(inventTrans, '');
            movement.transIdSum().setInventTransStatus(inventTrans,StatusReceipt::Ordered,StatusIssue::None);

            if (movement.isTransfer())
            {
                /*
                // If this is a transfer then dimensions, like serial numbers, might have been transferred from issues->receipts.
                // We cannot determine if some dimensions where assigned during registration, e.g. location, so we need to keep what is on the movement and what could have been transferred.
                // Hence, we create an inventDim where the dimensions from the movement is merged into the inventDim that we used for registration.
                */
                InventDim inventDimMergedExistingWithMovement = movement.mergeTransDimTransferReceipt(inventDimOrig, movement.inventdim());
                inventTrans.inventDimId = InventDim::findOrCreate(inventDimMergedExistingWithMovement).inventDimId;
            }
            else
            {
                if ((inventDimOrig.inventBatchId || inventDimOrig.inventSerialId) && needMergeInventDim)
                {
                    InventDim inventDimMerged = inventDim.data();
                    inventDimMerged.inventBatchId = inventDimOrig.inventBatchId;
                    inventDimMerged.inventSerialId = inventDimOrig.inventSerialId;
                    inventDimMerged = InventDim::findOrCreate(inventDimMerged);
                    inventTrans.InventDimId = inventDimMerged.inventDimId;
                }
                else
                {
                    inventTrans.InventDimId         = movement.inventDimId();
                }
            }

            inventTrans.DateInvent          = dateNull();
            this.raiseOnHandChangingOnPhysicalStatusUpd(inventTrans, inventTrans.orig(), null, inventDimOrig);
            inventTrans.update();

            if (inventTrans.ProjId && inventTrans.inventTransOrigin().ReferenceCategory == InventTransType::Purch)
            {
                PurchLine purchLine = PurchLine::findInventTransId(inventTrans.inventTransOrigin().InventTransId);

                if (!purchLine.InventRefTransId && !purchLine.InventRefId && !purchLine.ItemRefType)
                {
                    InventMovement movementIssue = InventTrans::findByInventTransOrigin(inventTrans.MarkingRefInventTransOrigin).inventMovement(true);

                    if (movementIssue)
                    {
                        using (InventUpdReserveRefProjSourceInventDimContext context = InventUpdReserveRefProjSourceInventDimContext::construct())
                        {
                            context.parmInventDimSource(movement.inventdim().data());

                            // Reserve the issue according to marking.
                            InventUpd_Reservation::updateReserveRefTransId(movementIssue);
                        }
                    }
                }
            }

            inventTrans.updateSumUp();

            if (!addRegistered)
            {
                break;
            }

            this.getNextInventTransToReceive(inventTrans);
        }

        if (addRegistered)
        {
            throw error(strFmt("@SYS15535", addRegistered));
        }

        this.validateCustomInventTransReceiptUpdate(addRegistered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRegisterMore</Name>
				<Source><![CDATA[
    protected void updateRegisterMore()
    {
        RecId           inventTransRecId;
        InventTrans     inventTrans, inventTransAutoNumber;
        InventDimId     registerInventDimIdAutoNumber;
        InventQty       addRegistered  = registered;
        InventQty       registeredSingleTrans;
        InventTransAutoNumberHandler inventTransAutoNumberHandler;

        PdsCWInventQty  cwAddRegistered  = cwRegistered;

        this.checkUseOfNumberGroups();

        if (movement.mustUpdateRelatedTrans())
        {
            this.pickReleatedIssueTransMore();
        }

        this.initInventTransToReceiveList(
                        StatusReceipt::Arrived,
                        StatusReceipt::Ordered,
                        arrInventDimCriteria.InventDimId,
                        arrInventDimCriteria,
                        arrInventDimParm,
                        movement.transChildType(),
                        movement.transChildRefId(),
                        addRegistered,
                        true);

        while (this.getNextInventTransToReceive(inventTrans))
        {
            if (!movement.canInventTransBeUpdatedRegistered(inventTrans))
            {
                throw error("@SYS18447");
            }

            //if the movement is whsEnabled we need to do autonumber assignment as part of the actual registration and not after the trans is updated to registered since it can then have a hole in the dimensions
            if (movement.isItemWHSEnabled())
            {
                inventTransAutoNumberHandler = InventTransAutoNumberHandler::newParameters(movement, inventTrans, this.parmRegInventDimCriteria(), true);
            }

            InventQty updateNowQuantity = this.transactionReceiptQuantity(inventTrans, addRegistered);

            if (inventTransAutoNumberHandler && inventTransAutoNumberHandler.useAutoNumbering())
            {
                movement.parmDateRegistration(this.parmDateInvent());

                if (this.parmCustomInventTransListInitialized() && updateNowQuantity < inventTrans.Qty)
                {
                    inventTrans.updateSplit(updateNowQuantity, cwAddRegistered);
                }

                ListEnumerator le = inventTransAutoNumberHandler.prepareInventTransForAutoNumberingTrackingDimensions(updateNowQuantity, cwAddRegistered).getEnumerator();

                while (le.moveNext())
                {
                    [inventTransRecId, registerInventDimIdAutoNumber] = le.current();
                    inventTransAutoNumber = InventTrans::findRecId(inventTransRecId, true);
                    InventQty autoNumberQty = inventTransAutoNumber.Qty;
                    [registeredSingleTrans, cwAddRegistered] = this.updateRegisterInventTrans(inventTransAutoNumber, registerInventDimIdAutoNumber, min(inventTransAutoNumber.qty,addRegistered), inventTransAutoNumber.PdsCWQty);

                    addRegistered -= (autoNumberQty - registeredSingleTrans);

                    if (!addRegistered)
                    {
                        break;
                    }
                }
            }
            else
            {
                if (this.parmCustomInventTransListInitialized())
                {
                    InventQty splitQty;
                    [splitQty, cwAddRegistered] = this.updateRegisterInventTrans(inventTrans, registerDimId, updateNowQuantity, cwAddRegistered);
                    addRegistered -= updateNowQuantity;
                }
                else
                {
                    [addRegistered, cwAddRegistered] = this.updateRegisterInventTrans(inventTrans, registerDimId, addRegistered, cwAddRegistered);
                }
            }

            if (!addRegistered)
            {
                break;
            }
        }

        if (addRegistered)
        {
            if (!movement.transChildType() && InventTrans::qtyWMSOrder(movement.inventTransOriginId()))
            {
                error(strFmt("@SYS54902",addRegistered,StatusReceipt::Ordered,StatusReceipt::Arrived));
                throw error(strFmt("@SYS54901",InventTrans::qtyWMSOrder(movement.inventTransOriginId())));
            }

            throw error(strFmt("@SYS54902",addRegistered,StatusReceipt::Ordered,StatusReceipt::Arrived));
        }

        this.validateCustomInventTransReceiptUpdate(addRegistered);

        // Create quality orders if needed
        if (!skipQualityOrderCreation)
        {
            InventQualityManagementCreateHandler::createInventoryRegistration(
                movement.inventTransOriginId(),
                inventReceiptForTestRegistrator);
        }

        // execute on-demand (once-per-LOT) for consumers that split lines e.g. per S/N within the same origin
        if (!skipSumUpTransDistributeCwQtyZero)
        {
            movement.pdsSumUpTransDistributeCwQtyZero();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    static public InventUpd_Registered newParameters(
        InventMovement        _movement,
        InventDim             _regInventDimCriteria,
        InventDimParm         _regInventDimParm,
        InventDim             _arrInventDimCriteria,
        InventDimParm         _arrInventDimParm,
        InventQtyRegistered   _registered
        , PdsCWRegistered       _cwRegistered = 0
        , DateInvent            _dateInvent = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        boolean                 _alwaysTryAndUseRegisterQty = false
        )
    {
        InventUpd_Registered inventUpd_Registered = new InventUpd_Registered(_movement);

        inventUpd_Registered.initParameters(_regInventDimCriteria,
                                                _regInventDimParm,
                                                _arrInventDimCriteria,
                                                _arrInventDimParm,
                                                _registered,
                                                _cwRegistered,
                                                _dateInvent,
                                                _alwaysTryAndUseRegisterQty);

        return inventUpd_Registered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceUpTransferChain</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a related transfer receipt <c>InventTrans</c> record.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transactions originator. It is the primary key on the <c>InventTransOrigin</c> table.
    /// </param>
    /// <returns>
    /// A container with the RecId and the MarkingRefInventTransOrigin of the related <c>InventTrans</c> record.
    /// </returns>
    private container traceUpTransferChain(InventTransOriginId _inventTransOriginId)
    {
        InventTransferLine               inventTransferLine;
        InventTrans                      inventTransTransferReceipt;
        InventTransOrigin                inventTransOrigin;
        InventTransOriginTransferReceive inventTransOriginTransferReceive;
        InventTransOriginTransferShip    inventTransOriginTransferShip;

        select firstOnly RecId, MarkingRefInventTransOrigin
            from  inventTransTransferReceipt
                where inventTransTransferReceipt.StatusReceipt == StatusReceipt::Ordered
                   && inventTransTransferReceipt.StatusIssue   == StatusIssue::None
                   && inventTransTransferReceipt.MarkingRefInventTransOrigin
            exists join inventTransOriginTransferReceive
                where inventTransOriginTransferReceive.InventTransOrigin == inventTransTransferReceipt.InventTransOrigin
            exists join inventTransferLine
                where inventTransferLine.TransferId == inventTransOriginTransferReceive.TransferReceiveId
                   && inventTransferLine.LineNum    == inventTransOriginTransferReceive.TransferReceiveLineNum
                   && inventTransferLine.dataAreaId == inventTransOriginTransferReceive.TransferReceiveDataAreaId
            exists join inventTransOriginTransferShip
                where inventTransOriginTransferShip.TransferShipDataAreaId == inventTransferLine.DataAreaId
                   && inventTransOriginTransferShip.TransferShipId         == inventTransferLine.TransferId
                   && inventTransOriginTransferShip.TransferShipLineNum    == inventTransferLine.LineNum
            exists join inventTransOrigin
                where inventTransOrigin.RecId             == _inventTransOriginId
                   && inventTransOrigin.RecId             == inventTransOriginTransferShip.InventTransOrigin
                   && inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderShip;

        return [inventTransTransferReceipt.RecId, inventTransTransferReceipt.MarkingRefInventTransOrigin];
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>