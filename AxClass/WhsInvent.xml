<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsInvent</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsInvent</c> class contains helper methods for inventory transactions.
/// </summary>
public class WhsInvent
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>findBatchWithAvailablePhysicalQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an invent batch ID with physical available quantity.
    /// </summary>
    /// <param name = "_itemId">An item ID to find physical available quantity for.</param>
    /// <param name = "_inventDimCriteria">Inventory Dimensions used as criteria when searching for the available quantity.</param>
    /// <param name = "_batchComparer">A batch comparer.</param>
    /// <returns>A batch id with physical available quantity. If the blank ID is returned no quantity could be found.</returns>
    public static InventBatchId findBatchWithAvailablePhysicalQuantity(
        ItemId _itemId,
        InventDim _inventDimCriteria,
        InventIBatchComparer _batchComparer)
    {
        InventBatchId batchId;
        
        InventBatchChooser inventBatchChooser = InventBatchChooser::newFromBatchComparer(_batchComparer);

        WHSInventBatchOnHandCollectionBuilder batchOnHandCollectionBuilder = WHSInventBatchOnHandCollectionBuilder::newFromCriteria(InventTable::find(_itemId), _inventDimCriteria, inventBatchChooser);

        WHSInventOnHandCollectionEnumerator enumerator = batchOnHandCollectionBuilder.physicalAvailableCollection().getEnumerator();

        if (enumerator.moveNext())
        {
            WHSInventOnHandData onHandData = enumerator.current();

            batchId = onHandData.parmInventDim().inventBatchId;
        }

        return batchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimHierarchyFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the transaction does not have a hole in the item's hierarchy.
    /// </summary>
    /// <param name="_inventTrans">
    /// The transaction being validated.
    /// </param>    
    /// <param name = "_inventTransInventDim">The inventory dimensions of the transaction.</param>
    /// <param name = "_hierarchyListAllDimensions">A reservation hierarchy list that should include all the dimensions that will be checked. It should be sorted from bottom up.</param>
    /// <returns>
    /// true if the transaction is valid, otherwise; false
    /// </returns>
    public boolean checkDimHierarchyFromParameters(
        InventTrans _inventTrans,
        InventDim   _inventTransInventDim,
        List _hierarchyListAllDimensions)
    {
        return WhsInvent::checkDimHierarchyFromInventDim(_inventTransInventDim, _hierarchyListAllDimensions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimHierarchyFromInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean checkDimHierarchyFromInventDim(
        InventDim   _inventDim,
        List        _hierarchyListAllDimensions)
    {
        boolean ret = true;

        ListEnumerator le = _hierarchyListAllDimensions.getEnumerator();
        FieldId dimFieldSet;

        while (le.moveNext())
        {
            WHSReservationHierarchyElementData hierarchyElementData = le.current();
            FieldId dimFieldId = hierarchyElementData.parmDimensionFieldId();

            if (_inventDim.(dimFieldId))
            {
                dimFieldSet = dimFieldId;
            }
            else if (dimFieldSet && !WHSReservationHierarchyInventDimUtil::isFieldAllowedBlankInMiddleOfHierarchy(dimFieldId))
            {
                if (dimFieldId == fieldNum(InventDim, wMSLocationId)
                    && _inventDim.inventLocation().isTransit()
                    && WHSTransitWarehouseDefaultLocationMustBeSpecifiedFlight::instance().isEnabled())
                {
                    ret = checkFailed(strFmt("@WAX:TransitWarehouseDefaultLocationMustBeSpecified",
                        new DictField(tableNum(InventDim), dimFieldId).label(),
                        new DictField(tableNum(InventDim), dimFieldSet).label()));
                    break;
                }
                else
                {
                    ret = checkFailed(strFmt("@WAX439",
                        new DictField(tableNum(InventDim), dimFieldId).label(),
                        new DictField(tableNum(InventDim), dimFieldSet).label()));
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckDimHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a hierarchy check to determine if there are holes in the item's hierarchy is needed for a transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// An <c>InventTrans</c> transaction.
    /// </param>
    /// <param name="_inventTransOrigin">
    /// The transactions origin.
    /// </param>
    /// <returns>
    /// true if the check is must be done, otherwise; false
    /// </returns>
    public boolean mustCheckDimHierarchy(
        InventTrans _inventTrans, 
        InventTransOrigin _inventTransOrigin)
    {
        return !(_inventTrans.StatusReceipt  == StatusReceipt::Ordered
            ||  _inventTrans.StatusReceipt  == StatusReceipt::QuotationReceipt
            ||  _inventTrans.StatusIssue    == StatusIssue::OnOrder
            ||  _inventTrans.StatusIssue    == StatusIssue::QuotationIssue
            ||  !WhsInvent::mustUpdateWHSInventReserve(_inventTransOrigin.ReferenceCategory));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the inventTrans does not have a hole in the item's hierarchy.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventTrans being validated.
    /// </param>
    /// <returns>
    /// true if the inventTrans is valid, otherwise; false
    /// </returns>
    public boolean checkDimHierarchy(InventTrans _inventTrans)
    {
        if (!this.mustCheckDimHierarchy(_inventTrans, _inventTrans.inventTransOrigin()))
        {
            return true;
        }
        
        List hierarchyList = WHSReservationHierarchyProvider::construct().getDimListAllFromInventTable(_inventTrans.inventTable(), WHSReservationHierarchySortOrder::BottomUp);

        return this.checkDimHierarchyFromParameters(_inventTrans, _inventTrans.inventDim(), hierarchyList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateWHSInventReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>WHSInventReserve</c> table must be updated for a given transaction type.
    /// </summary>
    /// <param name = "_transType">The inventory transaction type.</param>
    /// <returns>true if the table must be updated; otherwise, false.</returns>
    public static boolean mustUpdateWHSInventReserve(InventTransType _transType)
    {
        boolean mustUpdateWHSInventReserve = true;

        if (_transType == InventTransType::SummedUp)
        {
            mustUpdateWHSInventReserve = false;
        }

        return mustUpdateWHSInventReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateLicensePlateIsUsedOnNonLPControlledLocation</Name>
				<Source><![CDATA[
    protected boolean mustValidateLicensePlateIsUsedOnNonLPControlledLocation()
    {
        WHSSkipLPControlledCheckForInventoryCleanupContext context = WHSSkipLPControlledCheckForInventoryCleanupContext::current();

        if (!context || !context.parmSkipCheck())
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLocationAndLP</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies location and license plate on the given <c>InventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record to check location and license plate on.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> for the given <c>InventTrans</c> record.
    /// </param>
    /// <param name="_physChange">
    ///    Whether it is a check for a physical change.
    /// </param>
    /// <returns>
    ///    true if validation succeeds, false otherwise.
    /// </returns>
    public boolean checkLocationAndLP(
        InventTrans         _inventTrans,
        InventTransOrigin   _inventTransOrigin,
        boolean             _physChange         = true)
    {
        WMSLocation         wmsLocation;
        boolean             ret = true;
        InventDim           inventDim;

        inventDim = InventDim::find(_inventTrans.InventDimId);

        wmsLocation = WMSLocation::find(inventDim.wmsLocationId, inventDim.InventLocationId);

        // If WHS Work, TransferOrderReceive, or TransferOrderShip with Direction Receipt, skip check user location and License Plate Controlled location check
        // Always check for physical change in inventory
        if (_physChange
            || (_inventTransOrigin.ReferenceCategory != InventTransType::WHSWork
					&& _inventTransOrigin.ReferenceCategory != InventTransType::KanbanJobTransferIssue
                    && _inventTransOrigin.ReferenceCategory != InventTransType::KanbanJobTransferReceipt
                    && _inventTransOrigin.ReferenceCategory != InventTransType::TransferOrderReceive
                    && (_inventTransOrigin.ReferenceCategory != InventTransType::TransferOrderShip
                        || _inventTrans.direction() == InventDirection::Issue)))
        {
            // If user location, error unless it is quarantine work.  
            // If status is being changed during work execution, quarantine work is created once the inventory is on the user and auto executed.
            if (_inventTransOrigin.ReferenceCategory != InventTransType::WHSWork
                && wmsLocation.isUserLocationNotAllowedToAdjust()
                && WHSWorkLine::find(_inventTransOrigin.ReferenceId, 1).WorkType != WHSWorkType::Quarantine
                && !WHSCatchWeightHelper::isTransactionVirtuelWeightAdj(_inventTrans, _inventTransOrigin))
            {
                ret = checkFailed("@WAX465");
            }
            else
            {
                // Check that license plate is set or is not set based on location setting
                if (inventDim.LicensePlateId)
                {
                    if (this.mustValidateLicensePlateIsUsedOnNonLPControlledLocation() &&
                        !wmsLocation.whsLocationIsLPControlled())
                    {
                        ret = wmsLocation.warnIfLicensePlateIsUsedOnNonLPControlledLocation();
                    }
                }
                else
                {
                    if (wmsLocation.whsLocationIsLPControlled())
                    {
                        // For retail store warehouse with WHS enabled need additional check
                        InventLocation warehouseLocation = InventLocation::find(inventDim.InventLocationId);
                        if (warehouseLocation && 
                            warehouseLocation.FSHStore && 
                            warehouseLocation.WHSEnabled && 
                            !RetailEnableStoreLocationAndLicensePlateCheckFlight::instance().isEnabled())
                        {
                            // Feature flag controlling the return order when WHS Enables skip to override default locations.
                            if (!RetailWhsInventFeatureControl::isLegacyReturnLocationUpdateSkipEnabled())
                            {
                                RetailWHSHandler::UpdateInventTransDimId(_inventTrans);
                            }
                        }
                        else if (this.mustValidateLicensePlateIsUsedOnNonLPControlledLocation() &&
                                !this.validateStatusForLPControlledLocation(_inventTrans, _inventTransOrigin))
                        {
                            ret = checkFailed(strFmt("@SCM:LicensePlateMustBeSpecified", wmsLocation.wMSLocationId, wmsLocation.inventLocationId));
                        }
                    }
                }
            }
        }

        // Make sure this License Plate doesn't exist anywhere else in inventory
        if (_physChange && inventDim.LicensePlateId && this.increasesPhysicalInventory(_inventTrans, _inventTrans.orig()))
        {
            if (!this.skipLPLocationValidation(_inventTransOrigin, _inventTrans, inventDim))
            {                
                //only add the final check if the previous checks passed since there is no reason to add the perf overhead if we know we will fail
                if (ret)
                {
                    boolean excludeUserLocations = !this.mustCheckUserLocationForLPValidation(_inventTransOrigin, _inventTrans);
                    InventLocationId inventLocationIdToIgnore = this.inventLocationIdToIgnore(_inventTrans, _inventTransOrigin);

                    WHSLicensePlateOnMultipleLocationFinalOnhandUpdateCheckHandlerAccessor::instanceForCurrentCompany().addCheck(inventDim.LicensePlateId, wmsLocation.wmsLocationId, wmsLocation.InventLocationId, excludeUserLocations, inventLocationIdToIgnore);
                }

                if (ret && WHSParameters::find().TransitWarehouseLicensePlatePolicy == WHSTransitWarehouseLicensePlatePolicy::PreventReuse)
                {
                    ret = WHSLicensePlateIsNotInTransitToOtherWarehouseCheck::validateLicensePlate(inventDim.LicensePlateId, wmsLocation.InventLocationId);
                }
            }
        }                                                                                                             

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canContainerWholeLicensePlateMoveWithoutWork</Name>
				<Source><![CDATA[
    private boolean canContainerWholeLicensePlateMoveWithoutWork(WHSLicensePlateId _licensePlateId)
    {
        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_licensePlateId);
        if (containerTable && containerTable.canContainerWholeLicensePlateMoveWithoutWork())
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLPLocationValidation</Name>
				<Source><![CDATA[
    protected boolean skipLPLocationValidation(InventTransOrigin _inventTransOrigin, InventTrans _inventTrans, InventDim _inventDim)
    {
        if (WHSInventCheckLocationAndLPContext::current() && WHSInventCheckLocationAndLPContext::current().parmSkipLPLocationValidation())
        {
            // No need to perform the expensive check based on the current context.
            return true;
        }


        if (_inventTransOrigin.ReferenceCategory == InventTransType::WHSQuarantine)
        {
            return true;
        }

        if (_inventTransOrigin.ReferenceCategory == InventTransType::WHSWork)
        {
            WHSWorkLine whsWorkLine = WHSWorkLine::findByInventTransIdTo(_inventTransOrigin.InventTransId);
            if (whsWorkLine && whsWorkLine.isWholeLPMovement())
            {
                // No need to perform the expensive check as the whole license plate is being moved
                return true;
            }
        }
        else if (_inventTransOrigin.ReferenceCategory == InventTransType::WHSContainer)
        {
            // If we are closing a container with the same Id as the LP the goods are on
            if (_inventDim.LicensePlateId == _inventTransOrigin.ReferenceId)
            {
                return this.canContainerWholeLicensePlateMoveWithoutWork(_inventDim.LicensePlateId);
            }
        }
        else if (this.isInventTransTypeForOutboundShipment(_inventTransOrigin.ReferenceCategory)) // When Re-opening the container, ReferenceCategory is the original source document
        {
            if (_inventTrans.StatusIssue == StatusIssue::ReservPhysical)
            {
                return this.canContainerWholeLicensePlateMoveWithoutWork(_inventDim.LicensePlateId);
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransTypeForOutboundShipment</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean isInventTransTypeForOutboundShipment(InventTransType _inventTransType)
    {
        return _inventTransType == InventTransType::Sales
            || _inventTransType == InventTransType::TransferOrderShip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocationIdToIgnore</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal InventLocationId inventLocationIdToIgnore(
        InventTrans         _inventTrans,
        InventTransOrigin   _inventTransOrigin)
    {
        // No need to check on hand on the transit warehouse for receipt transactions in the destination warehouse.
        if (_inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive
            && _inventTrans.StatusIssue == StatusIssue::None)
        {
            return InventTransferTable::find(_inventTransOrigin.ReferenceId).InventLocationIdTransit;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStatusForLPControlledLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the inventory transaction record status issue and receipt for license plate controlled location.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record to check location and license plate on.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record to check location and license plate on.
    /// </param>
    /// <returns>true if validation succeeds; otherwise false.</returns>
    private boolean validateStatusForLPControlledLocation(InventTrans _inventTrans, InventTransOrigin _inventTransOrigin = null)
    {
        return _inventTrans.StatusIssue == StatusIssue::OnOrder
        || _inventTrans.StatusReceipt == StatusReceipt::Ordered
        || (_inventTrans.StatusIssue == StatusIssue::ReservPhysical
            && _inventTransOrigin
            && _inventTransOrigin.ReferenceCategory == InventTransType::Blocking
            && fieldNum(InventDim, LicensePlateId) == WHSReservationHierarchyProvider::construct().getDimFieldIdForBottomHierarchyLevel(_inventTrans.inventTable()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckUserLocationForLPValidation</Name>
				<Source><![CDATA[
    private boolean mustCheckUserLocationForLPValidation(
        InventTransOrigin   _inventTransOrigin,
        InventTrans         _inventTrans)
    {
        //we need to allow CW adjustments of weight without CW quantity for scenarios where users are adjusting weight and picking up items.
        if (WHSCatchWeightHelper::isTransactionVirtuelWeightAdj(_inventTrans, _inventTransOrigin))
        {
            return false;
        }
        
        return _inventTransOrigin.ReferenceCategory    != InventTransType::WHSWork
               && _inventTransOrigin.ReferenceCategory != InventTransType::WHSContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultiStatusLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there exists multiple statuses for an item on a single license plate.
    /// </summary>
    /// <param name="_inventTrans">
    /// Inventory transaction that contains item id.
    /// </param>
    /// <param name="_inventTransOrigin">
    /// Inventory transaction originator record.
    /// </param>
    /// <returns>
    /// False if there exists multiple status for an item on a single license plate.
    /// </returns>
    public boolean checkMultiStatusLP(InventTrans _inventTrans, InventTransOrigin _inventTransOrigin)
    {
        if (WHSInventMoveWorkQtyContext::canSkipCheckMultiStatusLP())
        {
            return true;
        }

        return WhsInvent::checkMultiStatusLPForItemInventDim(_inventTrans.ItemId, _inventTrans.inventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultiStatusLPForItemInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean checkMultiStatusLPForItemInventDim(ItemId _itemId, InventDim _inventDimCriteria)
    {
        InventDim           inventDim;
        InventDim           inventDimCriteria = _inventDimCriteria;
        InventSum           inventSum;
        InventSumDelta      inventSumDelta;
        InventDimParm       inventDimParm;
        boolean             ok = true;
        ItemId              itemId = _itemId;

        inventDimParm.initFromInventDim(inventDimCriteria);
        inventDimParm.clearStorageDimensions();

        if (inventDimCriteria.LicensePlateId)
        {
            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                while select ItemId, InventDimId, PhysicalInvent, PdsCWPhysicalInvent, InventStatusId
                    from inventSum
                    where !inventSum.ClosedQty
                        && inventSum.ItemId == itemId
                        && inventSum.PhysicalInvent > 0
                        && #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm)
                        && inventSum.LicensePlateId == inventDimCriteria.LicensePlateId
                        && inventSum.InventStatusId != inventDimCriteria.InventStatusId
                {
                    if (WhsInvent::physicalOnhandExists(inventSum.ItemId, inventSum.InventDimId, inventSum.PhysicalInvent, inventSum.PdsCWPhysicalInvent))
                    {
                        ok = checkFailed(strFmt("@WAX:MultipleStatusesOnSameLicencePlate", inventDimCriteria.LicensePlateId, inventSum.InventStatusId, inventDimCriteria.InventStatusId));
                        break;
                    }
                }
            }
            else
            {
                while select ItemId, InventDimId, PhysicalInvent, PdsCWPhysicalInvent
                    from inventSum
                    where !inventSum.ClosedQty
                        && inventSum.ItemId == itemId
                        && inventSum.PhysicalInvent > 0
                    #InventDimExistsJoin(inventSum.InventDimId, inventDim, inventDimCriteria, inventDimParm)
                        && inventDim.LicensePlateId == inventDimCriteria.LicensePlateId
                        && inventDim.InventStatusId != inventDimCriteria.InventStatusId
                {
                    if (WhsInvent::physicalOnhandExists(inventSum.ItemId, inventSum.InventDimId, inventSum.PhysicalInvent, inventSum.PdsCWPhysicalInvent))
                    {
                        ok = checkFailed(strFmt("@WAX:MultipleStatusesOnSameLicencePlate", inventDimCriteria.LicensePlateId, InventDim::find(inventSum.InventDimId).InventStatusId, inventDimCriteria.InventStatusId));
                        break;
                    }
                }
            }

            if (ok)
            {
                if (InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    // Now need to check for inventSumDelta records that don't have
                    // any corresponding inventSum records
                    while select ItemId, InventDimId, InventStatusId, sum(PhysicalInvent), sum(PdsCWPhysicalInvent)
                        from inventSumDelta
                        group by ItemId, InventDimId, InventStatusId
                            where inventSumDelta.SQLTransactionId   == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                                && inventSumDelta.ItemId            == itemId
                                && #InventDimFieldsFilter(inventSumDelta, inventDimCriteria, InventDimParm)
                                && inventSumDelta.LicensePlateId    == inventDimCriteria.LicensePlateId
                                && inventSumDelta.InventStatusId    != inventDimCriteria.InventStatusId
                    {
                        // Get the total for this inventSumRecord
                        if ((!PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId)) ?
                            (inventSumDelta.PhysicalInvent > 0) :
                            (inventSumDelta.PdsCWPhysicalInvent > 0))
                        {
                            ok = checkFailed(strFmt("@WAX:MultipleStatusesOnSameLicencePlate", inventDimCriteria.LicensePlateId, inventSumDelta.InventStatusId, inventDimCriteria.InventStatusId));
                            break;
                        }
                    }
                }
                else
                {
                    // Now need to check for inventSumDelta records that don't have
                    // any corresponding inventSum records
                    while select ItemId, InventDimId, sum(PhysicalInvent), sum(PdsCWPhysicalInvent)
                        from inventSumDelta
                        group by ItemId, InventDimId
                            where inventSumDelta.SQLTransactionId == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                                && inventSumDelta.ItemId          == itemId
                            #InventDimExistsJoin(inventSumDelta.InventDimId, inventDim, inventDimCriteria, InventDimParm)
                                && inventDim.LicensePlateId == inventDimCriteria.LicensePlateId
                                && inventDim.InventStatusId != inventDimCriteria.InventStatusId
                    {
                        // Get the total for this inventSumRecord
                        if ((!PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId)) ?
                            (inventSumDelta.PhysicalInvent > 0) :
                            (inventSumDelta.PdsCWPhysicalInvent > 0))
                        {
                            ok = checkFailed(strFmt("@WAX:MultipleStatusesOnSameLicencePlate", inventDimCriteria.LicensePlateId, InventDim::find(inventSumDelta.InventDimId).InventStatusId, inventDimCriteria.InventStatusId));
                            break;
                        }
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the inventory status is valid for a given transaction
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record for which to check the status
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record corresponding to <c>InventTrans</c> record
    /// </param>
    /// <returns>
    ///    true if the status is valid for the transaction; otherwise, false.
    /// </returns>
    boolean checkStatus(InventTrans _inventTrans, InventTransOrigin _inventTransOrigin)
    {
        boolean             ret = true;
        InventDim           inventDim = _inventTrans.inventDim();
        boolean             isBlockingStatus = false;

        if (inventDim.InventStatusId != '')
        {
            isBlockingStatus = WHSInventStatus::isBlockingStatus(inventDim.InventStatusId);
        }

        if (isBlockingStatus)
        {
            // Returned packing slips have negative quantity so we flip to positive as validation checks only for > 0
            InventQty inventTransQty 
                = _inventTrans.PackingSlipReturned 
                ? -_inventTrans.Qty 
                : _inventTrans.Qty;
            if (!WHSInvent::transTypeCanHaveBlockingStatus(_inventTransOrigin.ReferenceCategory, inventTransQty))
            {
                ret = checkFailed(strFmt("@WAX4797", _inventTransOrigin.ReferenceCategory));
            }
            if (_inventTrans.ProjId != '')
            {
                ret = checkFailed("@WAX5540");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if warehouse is WHS controlled.
    /// </summary>
    /// <param name="_inventDim">
    /// Dimensions record that contains warehouse info.
    /// </param>
    /// <returns>
    /// True if the warehouse is WHS controlled.
    /// </returns>
    boolean checkWarehouse(InventDim _inventDim)
    {
        boolean     ret = true;

        // Make sure the warehouse is WHS controlled
        if (_inventDim.InventLocationId &&
            !InventLocation::find(_inventDim.InventLocationId).whsEnabled)
        {
            error(strFmt("@WAX457", _inventDim.InventLocationId));
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>increasesPhysicalInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the change in the inventory transaction increases physical on hand.
    /// </summary>
    /// <param name="_inventTrans">
    /// The modified inventory transaction.
    /// </param>
    /// <param name="_origInventTrans">
    /// The original inventory transaction.
    /// </param>
    /// <returns>
    /// true if the change in the inventory transaction increases physical on hand; otherwise, false.
    /// </returns>
    private boolean increasesPhysicalInventory(InventTrans _inventTrans, InventTrans _origInventTrans)
    {
        if (_origInventTrans.StatusReceipt != StatusReceipt::None)
        {
            return !_origInventTrans.isIncludedInPhysicalInventory() && _inventTrans.isIncludedInPhysicalInventory(); // true for receipt increase
        }
        //handle cases where a new inventtrans is a physical status receipt set directly
        else if (!_origInventTrans && _inventTrans.isReceipt())
        {
            return _inventTrans.isIncludedInPhysicalInventory();
        }
        else
        {
            return _origInventTrans.isIncludedInPhysicalInventory() && !_inventTrans.isIncludedInPhysicalInventory(); // true for issue reduction
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDimsForProdPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the dimensions to be above location only when warehouse configuration is set to reserve only warehouse.
    /// </summary>
    /// <param name="_inventDim">
    /// The current inventDim supplied for the prodBom transaction.
    /// </param>
    /// <param name="_itemId">
    /// The item Id of the prodBom transaction.
    /// </param>
    /// <returns>
    /// The inventDim to be used on the prodBom transaction.
    /// </returns>
    public static InventDim adjustDimsForProdPick(
        InventDim   _inventDim,
        ItemId      _itemId)
    {
        InventDim       inventDim;

        buf2Buf(_inventDim, inventDim);

        // If no warehouse, skip, also check parm on warehouse
        if (inventDim.InventLocationId
            && InventLocation::find(inventDim.InventLocationId).ProdReserveOnlyWhse)
        {
            WHSInstrumentationLogger logger = WHSInstrumentationLogger::createLogger(classStr(WhsInvent));
            WHSPoolReserveOnWorkCenterInstrumentationActivities activities = logger.reserveOnWorkCenter();

            using (var updatePackingWorkLineQtyRemainActivityContext = activities.adjustDimsForProdPick())
            {
                if (!WHSProdInputLocationReserveFullDimsContext::isActive())
                {
                    inventDim.clearLocationAndBelowDim(_itemId);
                    inventDim = InventDim::findOrCreate(inventDim);
                }
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowMixedBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether batch mix is valid on a batch controlled location when the newly received item is put to the location.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the newly received inventory item.
    /// </param>
    /// <param name="_batchId">
    /// Batch id of the newly received item.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Id of the location.
    /// </param>
    /// <param name="_checkInventory">
    /// Determines whether to check onhand inventory.
    /// </param>
    /// <param name="_checkWork">
    /// Determines whether to check work lines if there are any put work with different item than the received one.
    /// </param>
    /// <param name="_checkTmpWorkLine">
    /// Determines whether to check temporary work lines that if there are any put work with different item than the received one.
    /// </param>
    /// <returns>
    /// True if the batch mix is valid in the batch controlled location.
    /// </returns>
    public static boolean allowMixedBatch(
        ItemId              _itemId,
        InventBatchId       _batchId,
        InventLocationId    _inventLocationId,
        WMSLocationId       _wmsLocationId,
        boolean             _checkInventory     = true,
        boolean             _checkWork          = true,
        boolean             _checkTmpWorkLine   = true)
    {
        InventDim dimReceipt;
        dimReceipt.InventLocationId = _inventLocationId;
        dimReceipt.wmsLocationId    = _wmsLocationId;
        dimReceipt.InventBatchId    = _batchId;

        var mixCheck = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(_itemId, dimReceipt);
        mixCheck.parmCheckInventory(_checkInventory);
        mixCheck.parmCheckWork(_checkWork);
        mixCheck.parmCheckTmpWorkLine(_checkTmpWorkLine);

        return mixCheck.isBatchMixValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowMixedItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether item mix is valid on a location when the newly received item is put to the location.
    /// </summary>
    /// <param name="_itemId">
    /// Newly received item id.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Location id of the location.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location.
    /// </param>
    /// <param name="_checkInventory">
    /// Determines whether to check onhand inventory on the location.
    /// </param>
    /// <param name="_checkWork">
    /// Determines whether to check work lines if there are any put work with different item than the received one.
    /// </param>
    /// <param name="_whsLocationProfile">
    /// Location profile of the location.
    /// </param>
    /// <returns>
    /// True if the item mix is valid when the newly received item is on the location.
    /// </returns>
    static boolean allowMixedItem(
        ItemId             _itemId,
        WMSLocationId      _wmsLocationId,
        InventLocationId   _inventLocationId,
        boolean            _checkInventory     = true,
        boolean            _checkWork          = true,
        WHSLocationProfile _whsLocationProfile = null)
    {
        InventDim                               dimReceipt;
        WHSLocationMixingConstraintValidator    mixCheck;

        if (!_itemId && (_checkInventory || _checkWork))
        {
            // If item is blank then we can assume it's multi-sku LP being moved
            return false;
        }

        dimReceipt.InventLocationId = _inventLocationId;
        dimReceipt.wmsLocationId = _wmsLocationId;

        mixCheck = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(_itemId, dimReceipt);
        mixCheck.parmCheckInventory(_checkInventory);
        mixCheck.parmCheckWork(_checkWork);

        return mixCheck.isItemMixValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowMixedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the status mix on the location is valid.
    /// </summary>
    /// <param name="_statusId">
    /// Status id of the newly received item.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Id of the location.
    /// </param>
    /// <param name="_whsLocationProfile">
    /// Location profile id of the location.
    /// </param>
    /// <returns>
    /// True if the status mix on the location is valid.
    /// </returns>
    static boolean allowMixedStatus(
        WHSInventStatusId  _statusId,
        InventLocationId   _inventLocationId,
        WMSLocationId      _wmsLocationId,
        WHSLocationProfile _whsLocationProfile = null)
    {
        InventDim                               dimReceipt;
        WHSLocationMixingConstraintValidator    mixCheck;

        dimReceipt.InventLocationId = _inventLocationId;
        dimReceipt.wmsLocationId = _wmsLocationId;
        dimReceipt.InventStatusId = _statusId;

        mixCheck = WHSLocationMixingConstraintValidator::construct();
        mixCheck.parmReceiptInventDim(dimReceipt);

        return mixCheck.isStatusMixValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignSerialMoveWorkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns serial id to from dimension and moves goods based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    public static void assignSerialMoveWorkQty(
        WHSWorkInventTrans _workInventTrans,
        InventDimId        _inventDimIdFrom,
        InventDimId        _inventDimIdTo)
    {
        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workInventTrans.WorkId))
        {
            WHSInventoryTransactionWorkController::construct()
                .moveForInitialPickWithDimTracking(_workInventTrans, InventDim::find(_inventDimIdFrom), InventDim::find(_inventDimIdTo));
            return;
        }

        boolean         combineEqualMoveDimensions = InventTable::find(_workInventTrans.ItemId).isActiveInSalesProcess();
        Map             moveQtyMap = new Map(Types::Container, Types::Real);
        
        ttsbegin;

        InventDim inventDimTracking;
        WHSDimTracking dimTracking;
        List        fieldListDimbelowLicensePlate   = WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(WHSReservationHierarchyProvider::construct().getDimListBelowLicensePlate(InventTable::find(_workInventTrans.ItemId), WHSReservationHierarchySortOrder::TopDown));
        InventDim   inventDimFromFilter             = InventDim::find(_inventDimIdFrom);
        InventDim   inventDimToFilter               = InventDim::find(_inventDimIdTo);

        while select forupdate dimTracking
            where   dimTracking.WorkId              == _workInventTrans.WorkId
                &&  dimTracking.LineNum             == _workInventTrans.LineNum
                &&  dimTracking.InventTransIdParent == _workInventTrans.InventTransIdParent
        join inventDimTracking
            where inventDimTracking.inventDimId == dimTracking.InventDimId
                && inventDimTracking.LicensePlateId == inventDimFromFilter.LicensePlateId
        {
            if (inventDimTracking.InventSerialId)
            {
                InventSerial::ensureExists(inventDimTracking.InventSerialId, _workInventTrans.ItemId);
            }

            // We need to ensure that the from and to dimensions include all dimensions that have been specified as part of the flow/process
            InventDim inventDimFrom, inventDimTo;
            [inventDimFrom, inventDimTo] = WhsInvent::mergeTrackingDimensions(inventDimFromFilter, inventDimToFilter, InventDimTracking, fieldListDimbelowLicensePlate);
            
            if (combineEqualMoveDimensions)
            {
                WhsInvent::aggregateMoveQty(moveQtyMap, inventDimFrom.inventDimId, inventDimTo.InventDimId, dimTracking.Qty);
            }
            else
            {
                WHSInvent::moveWorkQuantities(_workInventTrans, inventDimFrom.inventDimId, inventDimTo.InventDimId, dimTracking.Qty, 0);
            }

            dimTracking.Processed    = NoYes::Yes;
            dimTracking.update();
        }

        WhsInvent::moveAggregatedQty(_workInventTrans, moveQtyMap);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeTrackingDimensions</Name>
				<Source><![CDATA[
    internal static container mergeTrackingDimensions(InventDim _inventDimFrom, InventDim _inventDimTo, InventDim _trackingDim, List _fieldsToMerge)
    {
        InventDim inventDimFrom = _inventDimFrom.data();
        InventSerialId  originalInventSerialId = inventDimFrom.inventSerialId;
        inventDimFrom.initFromInventDim(_trackingDim, _fieldsToMerge);
        inventDimFrom.inventSerialId = originalInventSerialId ? inventDimFrom.inventSerialId : '';
        inventDimFrom = inventDim::findOrCreate(inventDimFrom);

        InventDim inventDimTo = _inventDimTo.data();
        inventDimTo.initFromInventDim(_trackingDim, _fieldsToMerge);
        inventDimTo = InventDim::findOrCreate(inventDimTo);

        return [inventDimFrom, inventDimTo];
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregateMoveQty</Name>
				<Source><![CDATA[
    private static void aggregateMoveQty(Map _moveQtyMap, InventDimId _fromInventDimId, InventDimId _toInventDimId, InventQty _moveQty)
    {
        container   inventDimKey = [_fromInventDimId, _toInventDimId];
        InventQty   movingQty;

        if (_moveQtyMap.exists(inventDimKey))
        {
            movingQty = _moveQtyMap.lookup(inventDimKey);
        }

        movingQty += _moveQty;

        _moveQtyMap.insert(inventDimKey, movingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveAggregatedQty</Name>
				<Source><![CDATA[
    private static void moveAggregatedQty(WHSWorkInventTrans _workInventTrans, Map _moveQtyMap)
    {
        MapEnumerator moveQtyEnumerator = _moveQtyMap.getEnumerator();

        while (moveQtyEnumerator.moveNext())
        {
            container   inventDimKey    = moveQtyEnumerator.currentKey();
            InventDimId fromInventDimId;
            InventDimId toInventDimId;

            [fromInventDimId, toInventDimId] = inventDimKey;

            InventQty   moveQty         = moveQtyEnumerator.currentValue();

            WHSInvent::moveWorkQuantities(_workInventTrans, fromInventDimId, toInventDimId, moveQty, 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger voucher for the inventory movements associated with work.
    /// </summary>
    /// <param name="_workId">
    /// Id of the work.
    /// </param>
    /// <returns>
    /// The voucher for the inventory movements associated with work.
    /// </returns>
    static public LedgerVoucher beginLedger(WHSWorkId _workId)
    {
        LedgerVoucherObject ledgerVoucherObject;
        TransactionTxt      transactionTxt = TransactionTxt::construct();
        NumberSeq           numberSeq;
        WHSInventVoucherId  voucherId;
        LedgerVoucher       ledgerVoucher;

        numberSeq           = NumberSeq::newGetNum(WHSParameters::numRefWHSInventVoucherId());
        voucherId           = numberSeq.num();

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,SysModule::Invent,numberSeq.parmNumberSequenceCode());

        transactionTxt.setType(LedgerTransTxt::InventTransferOrder);
        transactionTxt.setDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        transactionTxt.setVoucher(voucherId);
        transactionTxt.setKey1(_workId);

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherId,
                                                              DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                              SysModule::Invent,
                                                              LedgerTransType::Invent);

        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransTypeHaveWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction type can have WHS work generated.
    /// </summary>
    /// <param name="_inventTransType">
    /// The <c>InventTransType</c> being evaluated.
    /// </param>
    /// <returns>
    /// true if the inventTransType passed in can have work generated; otherwise, false.
    /// </returns>
    public static boolean canInventTransTypeHaveWork(InventTransType _inventTransType)
    {
        boolean ret = false;

        switch (_inventTransType)
        {
            case InventTransType::Sales,
                 InventTransType::Purch,
                 InventTransType::ProdLine,
                 InventTransType::Production,
                 InventTransType::PmfProdCoBy,
                 InventTransType::TransferOrderShip,
                 InventTransType::TransferOrderReceive,
                 InventTransType::KanbanJobPickingList,
                 InventTransType::KanbanJobProcess:
                ret = true;
                break;
            default:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changesPhysInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if change in status will cause change in physical inventory.
    /// </summary>
    /// <param name="_origInventTrans">
    /// The original <c>InventTrans</c> record before the change.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record after the change.
    /// </param>
    /// <returns>
    /// true if the change in status will cause change in physical inventory; otherwise, false.
    /// </returns>
    public static boolean changesPhysInventory(
        InventTrans _origInventTrans,
        InventTrans _inventTrans)
    {
        return _inventTrans.isIncludedInPhysicalInventory() != _origInventTrans.isIncludedInPhysicalInventory();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBatchBlankIssueReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if batch number's blank issue/receipt setup is valid for an advanced warehousing storage dimension group.
    /// </summary>
    /// <param name="_ecoResStorageDimensionGroup">
    /// Id of the <c>EcoResStorageDimensionGroup</c> record to check against.
    /// </param>
    /// <param name="_ecoResTrackingDimensionGroup">
    /// Id of a <c>EcoResTrackingDimensionGroup</c> record to validate.
    /// </param>
    /// <returns>
    /// true if batch number's blank issue/receipt setup is valid; otherwise, false.
    /// </returns>
    public static boolean checkBatchBlankIssueReceipt(
        EcoResStorageDimensionGroupRecId    _ecoResStorageDimensionGroup,
        EcoResTrackingDimensionGroupRecId   _ecoResTrackingDimensionGroup)
    {
        boolean                                 ret = true;

        if (EcoResStorageDimensionGroup::find(_ecoResStorageDimensionGroup).IsWarehouseWHSEnabled)
        {
            EcoResTrackingDimensionGroupFldSetup trackingDimGroupFieldSetup = EcoResTrackingDimensionGroupFldSetup::findByDimensionGroupFieldId(_ecoResTrackingDimensionGroup, fieldNum(InventDim, InventBatchId));

            if (trackingDimGroupFieldSetup.IsAllowBlankIssueEnabled || trackingDimGroupFieldSetup.IsAllowBlankReceiptEnabled)
            {
                ret = checkFailed("@WAX5360");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks changed dimensions. The standard routine cannot be used as it doesn't account for the unique way WHS reserves inventory.
    /// This routine assumes the transaction is in a reserved status.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record to check against.
    /// </param>
    /// <param name="_toInventDim">
    /// The new <c>InventDim</c> record. It must have RecId
    /// </param>
    /// <returns>
    /// true if the change can proceed; otherwise, false;
    /// </returns>
    public static boolean checkDimChange(
        InventTrans _inventTrans,
        InventDim   _toInventDim)
    {
        boolean skipOnHandCheck = false;
        WHSInventCheckDimChangeContext context = WHSInventCheckDimChangeContext::current();

        if (context)
        {
            skipOnHandCheck = context.skipOnHandCheck;
        }
        
        return WHSInventTransDimensionChangeCheck::newCheck(_inventTrans, _toInventDim, skipOnHandCheck).check();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimChangeReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to make sure that on hand does not become negative when
    /// changing dimensions or deleting a receipt transactions.
    /// </summary>
    /// <param name="_inventTrans">
    /// The receipt transaction being modified.
    /// </param>
    /// <param name="_fromInventDim">
    /// The original dimension of the receipt transaction.
    /// </param>
    /// <param name="_transactionDeleted">
    /// A Boolean value specifying whether the transaction is being deleted; optional.
    /// </param>
    /// <returns>
    /// true if the change can proceed; otherwise, false;
    /// </returns>
    /// <remarks>
    /// This method replaces the on hand checks done by InventUpdate.allowChangeDim() for WHS items.
    /// </remarks>
    public static boolean checkDimChangeReceipt(
        InventTrans _inventTrans,
        InventDim   _fromInventDim, // must have RecId
        boolean     _transactionDeleted = false)
    {
        List                                hierarchyList;
        WHSReservationHierarchyElementData  hierarchyElementData;
        ListEnumerator                      le;
        FieldId                             fieldId;
        InventDim                           toInventDim;
        InventDim                           inventDim;
        WHSInventReserve                    inventReserve;
        CreatedTransactionId                ttsId;
        WHSInventReserveDeltaView           deltaView;
        boolean                             ret = true;
        WHSReservationHierarchyLevel        noOnHandCreationDimLevel;

        ttsbegin;

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_inventTrans.ItemId))
        {
            ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
        }

        toInventDim = null;
        // Leave to Dim blank if transaction is being deleted. This way we will check all levels that were originally on the dim.
        if (!_transactionDeleted)
        {
            toInventDim = _inventTrans.inventDim();

            // Check if dimension change would conflict with the marked inventTrans set dimensions
            // We actually need to look at the dimension value set on the origin record of the inventTrans such as salesLine or purchLine
            // The check _inventTrans.InventTransOrigin().originator() is needed in the case when ProdTableType::insert method is calling checkDimChangeReceipt before prodTable is inserted.
            if (_inventTrans.MarkingRefInventTransOrigin && _inventTrans.InventTransOrigin().originator())
            {
                ret = WHSInvent::checkOriginDimChange(_inventTrans, toInventDim);
            }
        }

        if (ret)
        {
            hierarchyList = WHSReservationHierarchyProvider::construct()
                                .getDimListAllFromInventTable(_inventTrans.inventTable(), WHSReservationHierarchySortOrder::BottomUp);

            le = hierarchyList.getEnumerator();

            buf2Buf(_fromInventDim, inventDim);

            //determine the level that the on-hand will be created until but not included.
            noOnHandCreationDimLevel = WHSInventOnHand::topDownNoOnHandCreationDimLevel(_inventTrans.ItemId,_fromInventDim);

            EcoResProductDimGroupSetup productDimGroupSetup = EcoResProductDimGroupSetup::newItemId(_inventTrans.ItemId);
                
            if (!InventDim::isInventDimEqualProductDim(productDimGroupSetup, inventDim, toInventDim))
            {
                toInventDim = null;
            }
        }

        // Check each dimension combination to see if quantity is available
        // when new dim has a field filled and the old dim does not
        while (ret
        &&     le.moveNext())
        {
            hierarchyElementData = le.current();

            fieldId = hierarchyElementData.parmDimensionFieldId();

            // Available inventory is not increased for dimensions on the level of the first hole and below in the hierarchy; therefore we don't need to check availability for these dimension on the receipt transaction.
            //if we got 0 it means that all dimensions are filled and then we need to check all entries.
            if (noOnHandCreationDimLevel == 0
            ||  hierarchyElementData.parmLevel() < noOnHandCreationDimLevel)
            {
                if (_fromInventDim.(fieldId)  &&
                   (_fromInventDim.(fieldId) != toInventDim.(fieldId)))
                {
                    // check just the single row in WHSInventReserve for available qty
                    inventDim = InventDim::findOrCreate(inventDim);

                    inventReserve = WHSInventReserve::find(_inventTrans.ItemId, inventDim.InventDimId);

                    if (ttsId)
                    {
                        // Add Sum Delta in
                        deltaView = WHSInventReserveDeltaView::findByItemDimId(_inventTrans.ItemId, inventDim.InventDimId, ttsId);

                        inventReserve.AvailOrdered      += deltaView.SumOfAvailOrdered;
                        inventReserve.CWAvailOrdered    += deltaView.SumOfCWAvailOrdered;
                    }

                    if (!PdsGlobal::pdsIsCWItem(_inventTrans.ItemId) ? (inventReserve.AvailOrdered < _inventTrans.Qty) : (inventReserve.CWAvailOrdered < _inventTrans.PdsCWQty))
                    {
                        ret = checkFailed(strFmt("@SYS86376", StatusIssue::ReservOrdered, _inventTrans.ItemId));
                        break;
                    }
                }
            }

            inventDim.clearField(fieldId);
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verify inventory dimensions for the <c>InventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The transaction to check dimensions on.
    /// </param>
    /// <param name="_physChange">
    ///    Whether the transaction will be physically changed.
    /// </param>
    /// <returns>
    ///    true if validations succeeded, false otherwise.
    /// </returns>
    static boolean checkDimensions(
        InventTrans _inventTrans,
        boolean     _physChange)
    {
        WHSInvent           invent;
        InventTransOrigin   inventTransOrigin;
        boolean             ret = true;
        boolean             isWhsWork;

        invent = new WHSInvent();

        inventTransOrigin = InventTransOrigin::find(_inventTrans.InventTransOrigin);

        isWhsWork = inventTransOrigin.ReferenceCategory ==  InventTransType::WHSWork;
        if (isWhsWork)
        {
            ret = invent.checkWarehouse(_inventTrans.inventDim());
        }

        ret = ret
              && invent.checkLocationAndLP(_inventTrans, inventTransOrigin, _physChange)
              && (!_physChange || invent.checkMultiStatusLP(_inventTrans, inventTransOrigin))
              && invent.checkStatus(_inventTrans, inventTransOrigin)
              && invent.checkDimHierarchy(_inventTrans);


        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNonPhysicalDims</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which validates non physical dimensions for a WHS enabled item.
    /// </summary>
    /// <param name="_ecoResStorageDimensionGroup">
    /// The storage dimension group to validate against.
    /// </param>
    /// <param name="_ecoResTrackingDimensionGroup">
    /// The tracking dimension group to validate against.
    /// </param>
    /// <returns>
    /// true if physical dimension setup is correct; otherwise false.
    /// </returns>
    public static boolean checkNonPhysicalDims(
        EcoResStorageDimensionGroupRecId    _ecoResStorageDimensionGroup,
        EcoResTrackingDimensionGroupRecId   _ecoResTrackingDimensionGroup)
    {
        boolean                                 ret = true;

        if (EcoResStorageDimensionGroup::find(_ecoResStorageDimensionGroup).IsWarehouseWHSEnabled)
        {
            Query query = WhsInvent::buildNonPhysicalDimsQuery(_ecoResTrackingDimensionGroup);
            QueryRun queryRun = new QueryRun(query);

            if (queryRun.next())
            {
                EcoResTrackingDimensionGroupFldSetup trackingDimGroupFieldSetup = queryRun.get(tableNum(EcoResTrackingDimensionGroupFldSetup));
                if (trackingDimGroupFieldSetup.RecId != 0)
                {
                    ret = checkFailed("@WAX5384");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildNonPhysicalDimsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the <c>Query</c> obejct to validate non physical dimensions for a WHS enabled item.
    /// </summary>
    /// <param name="_ecoResTrackingDimensionGroup">
    /// The tracking dimension group to filter on.
    /// </param>
    /// <returns>
    /// The <c>Query</c> obejct to validate non physical dimensions for a WHS enabled item.
    /// </returns>
    protected static Query buildNonPhysicalDimsQuery(EcoResTrackingDimensionGroupRecId _ecoResTrackingDimensionGroup)
    {
        Query query = new  Query();

        QueryBuildDataSource qbdsTrackingDimGroupFieldSetup = query.addDataSource(tableNum(EcoResTrackingDimensionGroupFldSetup));
        qbdsTrackingDimGroupFieldSetup.firstOnly(true);
        qbdsTrackingDimGroupFieldSetup.addSelectionField(fieldNum(EcoResTrackingDimensionGroupFldSetup, RecId));
        qbdsTrackingDimGroupFieldSetup.addRange(fieldNum(EcoResTrackingDimensionGroupFldSetup, TrackingDimensionGroup)).value(queryValue(_ecoResTrackingDimensionGroup));
        qbdsTrackingDimGroupFieldSetup.addRange(fieldNum(EcoResTrackingDimensionGroupFldSetup, IsPhysicalInventoryEnabled)).value(queryValue(NoYes::No));
        qbdsTrackingDimGroupFieldSetup.addRange(fieldNum(EcoResTrackingDimensionGroupFldSetup, IsActive)).value(queryValue(NoYes::Yes));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOriginDimChange</Name>
				<Source><![CDATA[
    ///<summary>
    /// Checks to see if the origin <c>InventDim</c> will be in conflict with new inventDim
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record to check against
    /// </param>
    /// <param name="_toInventDim">
    /// The new <c>InventDim</c> record
    /// </param>
    /// <returns>
    /// Returns true if the dimension set can be changed successfully; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If <c>InventDim</c> is not found assume dimension conflict
    /// </remarks>
    public static boolean checkOriginDimChange(InventTrans _inventTrans, InventDim _toInventDim)
    {
        InventDim       originInventDim;
        InventDimParm   inventDimParm;
        boolean         ret = true;

        originInventDim = _inventTrans.inventMovement().inventdim();

        if (originInventDim)
        {
            inventDimParm.initFromInventDim(originInventDim);

            if (!InventDim::isInventDimParmEqual(originInventDim, _toInventDim, inventDimParm, false))
            {
                ret = checkFailed("@WAX4795");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WHSInvent construct()
    {
        return new WHSInvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTransStatusChangeRequireInventCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction is changing status issue or status receipt from a status which previously allowed hierarchy holes.
    /// </summary>
    /// <param name="_origInventTrans">
    /// The original inventTrans record.
    /// </param>
    /// <param name="_inventTrans">
    /// The new inventTrans record.
    /// </param>
    /// <returns>
    /// true if the inventTrans has changed status in such a way that requires some inventory checks to be preformed, otherwise; false.
    /// </returns>
    /// <remarks>
    /// If a transaction has dimensions change then we preform all inventory checks.
    /// This method is used to catch the case where dimensions don't change but we still need to preform some inventory checks. Specific, around holes in the hierarchy.
    /// </remarks>
    public static boolean doesTransStatusChangeRequireInventCheck(
        InventTrans _origInventTrans,
        InventTrans _inventTrans)
    {
        boolean ret;

        // If the original transaction was in a status Ordered and has changed return true.
        if (_origInventTrans.direction() == InventDirection::Receipt)
        {
            if (_origInventTrans.StatusReceipt == StatusReceipt::Ordered
            &&  _origInventTrans.StatusReceipt != _inventTrans.StatusReceipt)
            {
                ret = true;
            }
        }

        // If the original transaction was in a status OnOrder and has changed return true.
        if (_origInventTrans.direction() == InventDirection::Issue)
        {
            if (_origInventTrans.StatusIssue    == StatusIssue::OnOrder
            && _origInventTrans.StatusIssue     != _inventTrans.StatusIssue)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillLicensePlateForTransferReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills in license plate Id on the transfer receipt if needed to prevent holes in the hierarchy.
    /// </summary>
    /// <param name="_inventDim">
    /// The current inventDim value of the transfer receipt.
    /// </param>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record of the transaction.
    /// </param>
    /// <returns>
    /// The inventDim without holes in the hierarchy.
    /// </returns>
    /// <remarks>
    /// A scenario where a transfer order is shipped from a non-license plate controlled location
    /// but is received by a warehouse with license plate controlled locations will hit introduce an issue
    /// where the merged dims of the transfer receipt create a hole in the hierarchy if there are dimensions below license plate.
    /// </remarks>
    public static InventDim fillLicensePlateForTransferReceipt(
        InventDim   _inventDim,
        InventTable _inventTable)
    {
        InventDim                           tmpInventDim;
        WHSReservationHierarchyElementData  hierarchyElement;
        ListEnumerator                      le;

        buf2Buf(_inventDim, tmpInventDim);

        // If the receipt dim is for a license plate control location and does not have license plate
        // we must check to see if there is a hole in the hierarchy that needs to be filled.
        if (!tmpInventDim.LicensePlateId
        && tmpInventDim.wmsLocation().whsLocationIsLPControlled())
        {
            le = WHSReservationHierarchyProvider::construct().getDimListBelowLicensePlate(_inventTable, WHSReservationHierarchySortOrder::TopDown).getEnumerator();
            while (le.moveNext())
            {
                hierarchyElement = le.current();
                // If a lower dimension if filled we need to fill in License Plate with the dummy LP.
                if (tmpInventDim.(hierarchyElement.parmDimensionFieldId()))
                {
                    tmpInventDim.LicensePlateId = InventLocation::getTOReceiptLP(tmpInventDim.InventLocationId, tmpInventDim.wmsLocationId);
                    tmpInventDim = InventDim::findOrCreate(tmpInventDim);
                    break;
                }
            }
        }

        return tmpInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCommonFromWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the originator record for an inventory transaction by checking the work transaction type.
    /// </summary>
    /// <param name="_workTransType">
    /// Work transaction type.
    /// </param>
    /// <param name="_inventTransId">
    /// Id of the inventory transaction.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value indicating if the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    /// The <c>InventTransOrigin</c> record that originate the inventory transaction.
    /// </returns>
    public static Common getCommonFromWorkTransType(
        WHSWorkTransType _workTransType,
        InventTransId    _inventTransId, 
        boolean          _forUpdate = false)
    {
        Common              originator;
        InventTransOrigin   inventTransOrigin;

        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTransType);
        
        if (workTransactionType)
        {
            inventTransOrigin = workTransactionType.findInventTransOrigin(_inventTransId);
            if (inventTransOrigin)
            {
                originator = inventTransOrigin.originator(_forUpdate);
            }
        }

        return originator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the default inventory status.
    /// </summary>
    /// <param name="_inventDim">
    ///     Inventory dimensions.
    /// </param>
    /// <param name="_movement">
    ///     Inventory movement; optional.
    /// </param>
    /// <param name="_common">
    ///     Source table record; optional.
    /// </param>
    /// <returns>
    ///     Default inventory status ID.
    /// </returns>
    public static WHSInventStatusId getDefaultStatus(
        InventDim      _inventDim,
        InventMovement _movement = null,
        Common         _common   = null)
    {
        boolean                 salesOrTransfer;
        ItemId                  itemId;      
        ModuleInventCustVend    moduleType;
        AccountNum              accountNumber;
        
        if (_movement)
        {
            switch (_movement.transType())
            {
                case InventTransType::SalesQuotation:
                case InventTransType::Sales:
                    itemId          = _movement.itemId();
                    accountNumber   = _movement.custVendAc();
                    moduleType      = ModuleInventCustVend::Cust;
                    salesOrTransfer = true;
                    break;

                case InventTransType::Purch:
                    itemId          = _movement.itemId();
                    accountNumber   = _movement.custVendAc();
                    moduleType      = ModuleInventCustVend::Vend;
                    break;

                case InventTransType::TransferOrderShip:
                    salesOrTransfer = true;
                    break;

                case InventTransType::Production:
                    itemId          = _movement.itemId();
                    moduleType      = ModuleInventCustVend::Invent;
                    break;

                case InventTransType::PmfProdCoBy:
                    itemId      = _movement.itemId();
                    moduleType  = ModuleInventCustVend::Invent;
                    break;
            }
        }
        else if (_common.TableId) // Common may not have recId if record has not been inserted. Instead check for tableId.
        {
            switch (_common.TableId)
            {
                case tableNum(SalesQuotationLine):                   
                    SalesQuotationLine salesQuotLine = _common;
                    itemId          = salesQuotLine.ItemId;
                    accountNumber   = salesQuotLine.CustAccount;
                    moduleType      = ModuleInventCustVend::Cust;
                    salesOrTransfer = true;
                    
                    break;

                case tableNum(SalesLine):
                    SalesLine salesLine = _common;
                    itemId              = salesLine.ItemId;
                    accountNumber       = salesLine.CustAccount;
                    moduleType          = ModuleInventCustVend::Cust;
                    salesOrTransfer     = true;

                    break;

                case tableNum(PurchLine):
                    PurchLine purchLine = _common;
                    itemId              = purchLine.ItemId;
                    accountNumber       = purchLine.VendAccount;
                    moduleType          = ModuleInventCustVend::Vend;
                    break;

                case tableNum(InventTransferLine):
                    InventTransferLine transferLine = _common;
                    itemId      = transferLine.ItemId;
                    moduleType  = ModuleInventCustVend::Invent;
                    salesOrTransfer = true;
                    break;
            }
        }

        return WHSInvent::getDefaultStatusByParameters(itemId, _inventDim, salesOrTransfer, accountNumber, moduleType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultStatusByParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the default inventory status.
    /// </summary>
    /// <param name="_itemId">
    ///     The item ID.
    /// </param>
    /// <param name="_inventDim">
    ///     Inventory dimensions.
    /// </param>
    /// <param name="_salesOrTransfer">
    ///     A Boolean value indicating whether the status should be searched for sales or transfer transaction; optional.
    /// </param>
    /// <param name="_accountNumber">
    ///     Customer or vendor account number; optional.
    /// </param>
    /// <param name="_moduleType">
    ///     Module type; optional.
    /// </param>
    /// <returns>
    ///     Default inventory status ID.
    /// </returns>
    public static WHSInventStatusId getDefaultStatusByParameters(
        ItemId                  _itemId,
        InventDim               _inventDim       = null,
        boolean                 _salesOrTransfer = false,
        AccountNum              _accountNumber   = '',
        ModuleInventCustVend    _moduleType      = ModuleInventCustVend::Cust)
    {
        WHSInventStatusId   inventStatusId;
        
        if (!WHSInvent::skipDefaultItemStatus(_moduleType, _salesOrTransfer))
        {
            inventStatusId = WHSAccountItemStatusDefault::find(_itemId, _accountNumber, _moduleType).DefaultStatusId;
        }

        if (!inventStatusId && _accountNumber)
        {
            inventStatusId = TradePartyModuleType::newFromPartyModule(_moduleType).defaultInventStatusId(_accountNumber);
        }

        if (!inventStatusId && (!_salesOrTransfer || WHSParameters::find().DefaultStatusOnSOTO))
        {
            if (_inventDim.InventLocationId)
            {
                inventStatusId = InventLocation::find(_inventDim.InventLocationId).DefaultStatusId;
            }

            if (!inventStatusId && _inventDim.InventSiteId)
            {
                inventStatusId = InventSite::find(_inventDim.InventSiteId).DefaultInventStatusId;
            }

            if (!inventStatusId)
            {
                inventStatusId = WHSParameters::find().DefaultStatusId;
            }
        }

        return inventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultTransitReceiveLoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default location for the transit goods that are received.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the item that is received.
    /// </param>
    /// <param name="_inventDim">
    /// Dimensions of the item.
    /// </param>
    /// <returns>
    /// The id of the default location for transit goods.
    /// </returns>
    public static WMSLocationId getDefaultTransitReceiveLoc(
        ItemId    _itemId,
        InventDim _inventDim)
    {
        WMSLocationId   ret;

        if (   _inventDim.InventLocationId
            && EcoResStorageDimGroupSetup::newDimensionGroup(InventTable::find(_itemId).storageDimensionGroup()).getFieldSetup(fieldNum(InventDim, wmsLocationId)).isActive())
        {
            ret = InventLocation::find(_inventDim.InventLocationId).wmsLocationIdDefaultReceipt;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyInWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of the quantity that is reserved for work.
    /// </summary>
    /// <param name="_parentInventTransId">
    /// Id of the inventory transaction that is associated with the work.
    /// </param>
    /// <returns>
    /// The sum of the quantity reserved for work.
    /// </returns>
    public static InventQty getQtyInWork(InventTransId _parentInventTransId)
    {
        return (select sum(Qty) from whsWorkInventTrans
                    where whsWorkInventTrans.InventTransIdParent == _parentInventTransId
                       && whsWorkInventTrans.WorkHasReservation  == NoYes::Yes).Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailableOnHandQtySortedList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the available inventory quantity on each location for the specified item and inventory dimensions, by taking into consideration only the above location dimensions.
    /// </summary>
    /// <param name = "_itemId">The item ID</param>
    /// <param name = "_inventDim">The inventDim record</param>
    /// <param name = "_locationIdToExclude">The location ID to exclude from the on hand calculations</param>
    /// <param name = "_licensePlateIdToExclude">The license plate ID to exclude from the on hand calculations</param>
    /// <param name = "_includeUserLocations">True if the user locations should be included in the calculation; otherwise false</param>
    /// <returns>A record sorted list with the <c>InventSum</c> and <c>InventDim</c> records which have the information about the
    /// available physical inventory quantity on the specific above location dimensions.</returns>
    /// <remarks>
    /// Total available inventory quantity: InventSum.AvailPhysical which is the handling quantity.
    /// </remarks>
    public static RecordSortedList getAvailableOnHandQtySortedList(
                                                            ItemId              _itemId,
                                                            InventDim           _inventDim,
                                                            WMSLocationId       _locationIdToExclude = '',
                                                            WHSLicensePlateId   _licensePlateIdToExclude = '',
                                                            boolean             _includeUserLocations = false)
    {
        RecordSortedList rsl = new RecordSortedList(tableNum(InventSum));
        rsl.sortOrderFromContainer([fieldNum(InventSum, AvailPhysical), fieldNum(InventSum, InventDimId)]);

        if (_licensePlateIdToExclude)
        {
            InventDim inventDimWithLoc = _inventDim.data();
            inventDimWithLoc.wMSLocationId = _locationIdToExclude;
            inventDimWithLoc = InventDim::findOrCreate(inventDimWithLoc);

            InventQty availQtyOnSameLocOtherLPs = WhsInvent::calculateWorkPhysicalAvailQtyOnSameLocOtherLPs(_itemId, inventDimWithLoc, _licensePlateIdToExclude);
            if (availQtyOnSameLocOtherLPs > 0)
            {
                InventSum  tempResult;

                tempResult.InventDimId = inventDimWithLoc.inventDimId;
                tempResult.AvailPhysical = availQtyOnSameLocOtherLPs;
                rsl.ins(tempResult);
            }
        }

        WMSLocationId previousLocationId = '';

        Query query = WhsInvent::getQueryAvailableOnHandQtySortedList(_itemId, _inventDim);

        QueryRun queryRun = new QueryRun(query);
        boolean excludeCurrentLocation = false;

        InventTable inventTable = InventTable::find(_itemId);

        while (queryRun.next())
        {
            InventSum inventSum = queryRun.get(tableNum(InventSum));
            InventDim inventDim = queryRun.get(tableNum(InventDim));

            if (previousLocationId != inventDim.wmsLocationId)
            {
                previousLocationId = inventDim.wmsLocationId;
                WMSLocation location = WMSLocation::find(inventDim.wMSLocationId, inventDim.InventLocationId);
                excludeCurrentLocation = location.whsLocationIsUserLocation() || location.wMSLocationId == _locationIdToExclude;
            }

            if (!excludeCurrentLocation
                && inventSum.PhysicalInvent > 0)
            {
                InventHandlingQty availableQuantity = 0;

                if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabledOnAnyField(inventTable.whsReservationHierarchy()))
                {
                    WHSInventReserveQty inventReserveQty = WHSInventReserveQty::newFromParms(
                        inventTable,
                        inventDim,
                        inventDim.toDimParm());

                    inventReserveQty.parmUpperLevelOfMinimumCalculation(
                        WhsReservationHierarchyProvider::construct().getLocationHierarchyLevel(inventTable));

                    availableQuantity = inventReserveQty.availPhysicalLevel();
                }
                else
                {
                    availableQuantity = whsInventOnHand::getWorkPhysicalAvailHandlingQtyByInventDim(_itemId, inventDim, true);
                }

                if (availableQuantity > 0)
                {
                    inventSum  tempResult;

                    InventDim currentInventDim = inventDim;
                    currentInventDim = inventDim::findOrCreate(currentInventDim);
                    tempResult.InventDimId = currentInventDim.inventDimId;
                    tempResult.AvailPhysical = availableQuantity;
                    rsl.ins(tempResult);
                }
            }
        }

        return rsl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryAvailableOnHandQtySortedList</Name>
				<Source><![CDATA[
    private static Query getQueryAvailableOnHandQtySortedList(ItemId _itemId, InventDim _inventDim)
    {
        Query			query;
        InventDim		inventDim;
        InventDimParm	inventDimParm;
        InventDimParm	inventDimParmGroupBy;

        List locationAndAboveHierarchyList = WHSReservationHierarchyListBuilder::construct().buildPartialHierarchyAbove(
                        InventTable::find(_itemId).whsReservationHierarchy(),
                        WHSReservationHierarchySortOrder::BottomUp,
                        fieldNum(InventDim, WMSLocationId),
                        true);
   
        WhsReservationHierarchyInventDimUtil::initInventDimParmFromHierarchyList(locationAndAboveHierarchyList, inventDimParmGroupBy);

        WHSReservationHierarchyRecId reservationHierarchyRecId = InventTable::find(_itemId).whsReservationHierarchy();

        if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabledOnAnyField(reservationHierarchyRecId))
        {
            inventDim = _inventDim;

            List locationAndBelowHierarchyList = WhsReservationHierarchyProvider::construct().getDimListLocationAndDownFromInventTable(
                InventTable::find(_itemId),
                WHSReservationHierarchySortOrder::BottomUp);

            ListEnumerator locationAndBelowHierarchyListEnumerator = locationAndBelowHierarchyList.getEnumerator();
            while (locationAndBelowHierarchyListEnumerator.moveNext())
            {
                WHSReservationHierarchyElementData reservationHierarchyElementData = locationAndBelowHierarchyListEnumerator.current();

                if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabled(reservationHierarchyRecId, reservationHierarchyElementData.parmDimensionFieldId()))
                {
                    FieldId dimFieldId = reservationHierarchyElementData.parmDimensionFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(dimFieldId);

                    inventDimParmGroupBy.(dimParmFieldId) = NoYes::Yes;
                }
                else
                {
                    inventDim.(reservationHierarchyElementData.parmDimensionFieldId()) = nullValue(inventDim.(reservationHierarchyElementData.parmDimensionFieldId()));
                }
            }
        }
        else
        {
            //above location invent dim
            inventDim = _inventDim;
            inventDim.clearLocationAndBelowDim(_itemId);
            inventDim = InventDim::findOrCreate(inventDim);
        }

        inventDimParm = inventDim.toDimParm();
        inventDimParm.ItemIdFlag = NoYes::Yes;

        inventDimParmGroupBy.setActiveProductDim(EcoResProductDimGroupSetup::newItemId(_itemId));

        query = InventSum::newQuery(null, _itemId, inventDim, inventDimParm, inventDimParmGroupBy);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWorkPhysicalAvailQtyOnSameLocOtherLPs</Name>
				<Source><![CDATA[
    private static InventQty calculateWorkPhysicalAvailQtyOnSameLocOtherLPs(ItemId _itemId, InventDim _inventDimWithLoc, WHSLicensePlateId _lpToExclude)
    {
        InventDimParm inventDimParmGroupByWithLP;
		
		InventDimParm inventDimParmWithLoc = _inventDimWithLoc.toDimParm();
        inventDimParmWithLoc.ItemIdFlag = NoYes::Yes;

        InventTable inventTable = InventTable::find(_itemId);
        WHSReservationHierarchyRecId reservationHierarchyRecId = inventTable.whsReservationHierarchy();

        if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabledOnAnyField(reservationHierarchyRecId))
        {
            List flexibleDimAndAboveHierarchyList = WHSReservationHierarchyListBuilder::construct().buildPartialHierarchyAbove(
                            reservationHierarchyRecId,
                            WHSReservationHierarchySortOrder::BottomUp,
                            WHSReservationHierarchyElementPolicyProvider::singleton().getLowestLevelWithEnabledReservationOnDemandOrder(reservationHierarchyRecId),
                            true);
   
            WhsReservationHierarchyInventDimUtil::initInventDimParmFromHierarchyList(flexibleDimAndAboveHierarchyList, inventDimParmGroupByWithLP);
        }
        else
        {
            List licensePlateAndAboveHierarchyList = WHSReservationHierarchyListBuilder::construct().buildPartialHierarchyAbove(
                            reservationHierarchyRecId,
                            WHSReservationHierarchySortOrder::BottomUp,
                            fieldNum(InventDim, LicensePlateId),
                            true);

            WhsReservationHierarchyInventDimUtil::initInventDimParmFromHierarchyList(licensePlateAndAboveHierarchyList, inventDimParmGroupByWithLP);
        }

        inventDimParmGroupByWithLP.setActiveProductDim(EcoResProductDimGroupSetup::newItemId(_itemId));

        Query inventSumPerLP = InventSum::newQuery(null, _itemId, _inventDimWithLoc, inventDimParmWithLoc, inventDimParmGroupByWithLP);
        QueryRun inventSumPerLPQueryRun = new QueryRun(inventSumPerLP);

        InventHandlingQty availQtyOnSameLocOtherLPs = 0;

        while (inventSumPerLPQueryRun.next())
        {
            InventSum inventSum = inventSumPerLPQueryRun.get(tableNum(InventSum));
            InventDim inventDim = inventSumPerLPQueryRun.get(tableNum(InventDim));

            if (inventDim.LicensePlateId && inventDim.LicensePlateId != _lpToExclude)
            {
                availQtyOnSameLocOtherLPs += whsInventOnHand::getWorkPhysicalAvailHandlingQtyByInventDim(_itemId, inventDim, true);
            }
        }

        return availQtyOnSameLocOtherLPs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyOnLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity of the items on license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// Id of the license plate.
    /// </param>
    /// <param name="_itemId">
    /// Id of the item on license plate.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimension id of the item on license plate.
    /// </param>
    /// <param name="_locationId">
    /// Location of the license plate.
    /// </param>
    /// <returns>
    /// The total quantity of the items on license plate.
    /// </returns>
    public static InventQty getQtyOnLicensePlate(
        WHSLicensePlateId  _licensePlateId,
        ItemId             _itemId,
        InventDimId        _inventDimId,
        WMSLocationId      _locationId)
    {
        InventHandlingQty qty;

        ttsbegin;

        if (WHSLicensePlate::isParentLicensePlate(_licensePlateId))
        {
            WHSLicensePlate childLicensePlate;
            while select childLicensePlate
                where childLicensePlate.LicensePlateParent == _licensePlateId
            {
                qty += WHSInvent::getQtyOnLicensePlate(
                    childLicensePlate.LicensePlateId,
                    _itemId,
                    _inventDimId,
                    _locationId);
            }
        }
        else
        {
            InventDim inventDim = InventDim::find(_inventDimId);
            inventDim.wmsLocationId     = _locationId;
            inventDim.LicensePlateId    = _licensePlateId;
            inventDim = InventDim::findOrCreate(inventDim);

            qty = WHSInventOnHand::getWorkPhysicalInventHandlingQty(_itemId, inventDim.InventDimId);
        }

        ttscommit;

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResPhyPickedDeliveredQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns total quantity of inventory that is at least reserved physical for the inventTrans and inventDim criteria.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventTransId.
    /// </param>
    /// <param name="_inventDimId">
    /// An inventDimId used to filter the transactions.
    /// </param>
    /// <returns>
    /// The total quantity of inventory that is at least reserved physical.
    /// </returns>
    public static InventQty getResPhyPickedDeliveredQty(InventTransId _inventTransId, InventDimId _inventDimId)
    {
        return WhsInvent::calculateCommittedHandlingQty(InventTransOrigin::findByInventTransId(_inventTransId), InventDim::find(_inventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCommittedHandlingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total handling quantity, that is at least reserved physical.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventTransId.
    /// </param>
    /// <param name="_inventDimId">
    /// An inventDimId used to filter the transactions.
    /// </param>
    /// <returns>
    /// The total handling quantity, that is at least reserved physical.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty calculateCommittedHandlingQuantity(InventTransId _inventTransId, InventDimId _inventDimId)
    {
        InventTransOrigin   inventTransOrigin   = InventTransOrigin::findByInventTransId(_inventTransId);

        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), inventTransOrigin.ItemId))
        {
            return WhsInvent::getResPhyPickedDeliveredQty(_inventTransId, _inventDimId);
        }

        return WhsInvent::calculateCommittedHandlingQty(inventTransOrigin, InventDim::find(_inventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCommittedHandlingQty</Name>
				<Source><![CDATA[
    private static InventHandlingQty calculateCommittedHandlingQty(InventTransOrigin _inventTransOrigin, InventDim _inventDimCriteria)
    {
        InventTrans         inventTrans, inventTransPackingSlip;
        InventDim           inventDim;
        InventDimParm       inventDimParm;

        inventDimParm.initFromInventDim(_inventDimCriteria);

        select sum(Qty), sum(PdsCWQty) 
            from inventTrans
            where inventTrans.InventTransOrigin     == _inventTransOrigin.RecId
                &&   (inventTrans.StatusIssue           == StatusIssue::ReservPhysical
                ||     inventTrans.StatusIssue          == StatusIssue::Picked
                ||     inventTrans.StatusIssue          == StatusIssue::Deducted
                ||     inventTrans.StatusIssue          == StatusIssue::Sold)
                &&   inventTrans.StatusReceipt          == StatusReceipt::None
                &&   inventTrans.PackingSlipReturned   == NoYes::No
             #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, inventDimParm); 

        return !PdsGlobal::pdsIsCWItem(_inventTransOrigin.ItemId) ? 
                -inventTrans.Qty : 
                -inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalQtyOnLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total onhand inventory quantity on the license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// Id of the license plate.
    /// </param>
    /// <returns>
    /// The total onhand quantity on the license plate.
    /// </returns>
    public static InventQty getTotalQtyOnLicensePlate(WHSLicensePlateId _licensePlateId)
    {
        if (!_licensePlateId)
        {
            return 0;
        }

        InventSum   inventSum;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            select sum(PhysicalInvent) from inventSum
            where inventSum.LicensePlateId      == _licensePlateId
                && inventSum.ClosedQty          == NoYes::No;
        }
        else
        {
            InventDim   inventDim;

            select forceSelectOrder inventDim
            where inventDim.LicensePlateId      == _licensePlateId
            join sum(PhysicalInvent) from inventSum
            where inventSum.InventDimId         == inventDim.InventDimId
                && inventSum.ClosedQty          == NoYes::No;
        }

        return inventSum.PhysicalInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateHandlingQtyOnLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total onhand handling quantity on a license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// Id of the license plate.
    /// </param>
    /// <returns>
    /// The total onhand handling quantity on the license plate.
    /// </returns>
    public static InventHandlingQty calculateHandlingQtyOnLicensePlate(WHSLicensePlateId _licensePlateId)
    {
        if (!_licensePlateId)
        {
            return 0;
        }

        if (!WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            return WhsInvent::getTotalQtyOnLicensePlate(_licensePlateId);
        }

        InventSum           inventSum;
        InventSum           cwInventSum;
        PdsCatchWeightItem  cwItem;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            select sum(PhysicalInvent) from inventSum
            where inventSum.ClosedQty == NoYes::No
                && inventSum.LicensePlateId  == _licensePlateId
                    notExists join cwItem
                    where cwItem.ItemId == inventSum.ItemId;

            select sum(PdsCWPhysicalInvent) from cwInventSum
            where cwInventSum.ClosedQty == NoYes::No
                && cwInventSum.LicensePlateId  == _licensePlateId
                    exists join cwItem
                    where cwItem.ItemId == cwInventSum.ItemId;
        }
        else
        {
            InventDim           inventDim;

            select sum(PhysicalInvent) from inventSum
            where inventSum.ClosedQty == NoYes::No
                join LicensePlateId from inventDim
                where inventSum.InventDimId     == inventDim.inventDimId
                &&    inventDim.LicensePlateId  == _licensePlateId
                    notExists join cwItem
                    where cwItem.ItemId == inventSum.ItemId;

            select sum(PdsCWPhysicalInvent) from cwInventSum
            where cwInventSum.ClosedQty == NoYes::No
                exists join inventDim
                where inventDim.inventDimId     == cwInventSum.InventDimId
                &&    inventDim.LicensePlateId  == _licensePlateId
                    exists join cwItem
                    where cwItem.ItemId == cwInventSum.ItemId;
        }

        return inventSum.PhysicalInvent + cwInventSum.PdsCWPhysicalInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransTypeWHSMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the movement is a warehousing transaction.
    /// </summary>
    /// <param name="_transType">
    /// The transaction type of the movement.
    /// </param>
    /// <returns>
    /// Returns true if the movement is a warehousing transaction; otherwise, false.
    /// </returns>
    public static boolean isTransTypeWHSMovement(InventTransType _transType)
    {
        boolean ret;

        switch (_transType)
        {
            case InventTransType::WHSWork:
            case InventTransType::WHSContainer:
            case InventTransType::WHSQuarantine:
                ret = true;
                break;
            default:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWHSLockedDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the passed in field id is a required dimension for WHS and cannot have its settings modified
    /// </summary>
    /// <param name="_dimFieldId">
    /// Field ID to verify
    /// </param>
    /// <returns>
    /// true if field id is a required dimension for WHS and cannot have its settings modified; otherwise, false
    /// </returns>
    public static boolean isWHSLockedDimension(FieldId _dimFieldId)
    {
        #InventDimDevelop

        return (_dimFieldId == fieldNum(InventDim, InventSiteId)        ||
                _dimFieldId == fieldNum(InventDim, InventLocationId)    ||
                _dimFieldId == fieldNum(InventDim, wmsLocationId)       ||
                _dimFieldId == fieldNum(InventDim, LicensePlateId)      ||
                _dimFieldId == fieldNum(InventDim, InventStatusId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveWorkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves goods on the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads; optional.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to; optional.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work invent transaction; optional.
    /// </param>
    /// <param name="_updateTransDimBeforeUpdate">
    /// A Boolean that determines if the inventory transactions should be updated with the from and to dimensions before the actual update; optional. This is only applied if the lite process is used
    /// </param>
    /// <param name="_skipInventTransSumUp">
    /// A Boolean used to determine if inventory transactions should be updated; optional. This is only applied if the lite process is used for the update.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the moveWorkQuantities method. Extenders should move their logic to wrap the moveWorkTransactionQuantities method.', false, 30\9\2019)]
    public static void moveWorkQty(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        InventCostOnhandCache   _inventCostOnhandCache = null,
        LedgerVoucher           _ledgerVoucher = null,
        WHSInventMov_Work       _workMovement = null,
        boolean                 _updateTransDimBeforeUpdate = true,
        boolean                 _skipInventTransSumUp = false,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip = null)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workInventTrans.ItemId);

        WHSInvent::moveWorkTransactionQuantities(_workInventTrans, _inventDimIdFrom, _inventDimIdTo, _qty, 0, _inventCostOnhandCache, _ledgerVoucher, _workMovement, _updateTransDimBeforeUpdate, _skipInventTransSumUp, _locationMixingConstraintCheckSkip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveWorkQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves goods on the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads; optional.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to; optional.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work invent transaction; optional.
    /// </param>
    /// <param name="_updateTransDimBeforeUpdate">
    /// A Boolean that determines if the inventory transactions should be updated with the from and to dimensions before the actual update; optional. This is only applied if the lite process is used
    /// </param>
    /// <param name="_skipInventTransSumUp">
    /// A Boolean used to determine if inventory transactions should be updated; optional. This is only applied if the lite process is used for the update.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    [Hookable(false)]
    public static void moveWorkQuantities(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        PdsCWInventQty          _cwQty,
        InventCostOnhandCache   _inventCostOnhandCache = null,
        LedgerVoucher           _ledgerVoucher = null,
        WHSInventMov_Work       _workMovement = null,
        boolean                 _updateTransDimBeforeUpdate = true,
        boolean                 _skipInventTransSumUp = false,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip = null)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _workInventTrans.ItemId, _cwQty))
        {
            WHSInvent::moveWorkQty(_workInventTrans, _inventDimIdFrom, _inventDimIdTo, _qty, _inventCostOnhandCache, _ledgerVoucher, _workMovement, _updateTransDimBeforeUpdate, _skipInventTransSumUp, _locationMixingConstraintCheckSkip);
        }
        else
        {
            WHSInvent::moveWorkTransactionQuantities(_workInventTrans, _inventDimIdFrom, _inventDimIdTo, _qty, _cwQty, _inventCostOnhandCache, _ledgerVoucher, _workMovement, _updateTransDimBeforeUpdate, _skipInventTransSumUp, _locationMixingConstraintCheckSkip);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveWorkTransactionQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves goods on the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads; optional.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to; optional.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work invent transaction; optional.
    /// </param>
    /// <param name="_updateTransDimBeforeUpdate">
    /// A Boolean that determines if the inventory transactions should be updated with the from and to dimensions before the actual update; optional. This is only applied if the lite process is used
    /// </param>
    /// <param name="_skipInventTransSumUp">
    /// A Boolean used to determine if inventory transactions should be updated; optional. This is only applied if the lite process is used for the update.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the pickQuantities method.
    /// </remarks>
    [Wrappable(true)]
    protected static void moveWorkTransactionQuantities(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        PdsCWInventQty          _cwQty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        WHSInventMov_Work       _workMovement,
        boolean                 _updateTransDimBeforeUpdate,
        boolean                 _skipInventTransSumUp,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _workInventTrans.ItemId, _cwQty, _qty);
        
        WHSInventMov_Work workMovement;

        workMovement = _workMovement != null                                                ?
                        _workMovement                                                       :
                        InventMovement::construct(_workInventTrans) as WHSInventMov_Work;

        if (workMovement.canUseLiteProcess())
        {
            if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workInventTrans.WorkId))
            {
                WHSInventoryTransactionWorkController::construct().moveSpecificQty(_workInventTrans, InventDim::find(_inventDimIdFrom), InventDim::find(_inventDimIdTo), _qty, _cwQty, _updateTransDimBeforeUpdate);
            }
            else
            {
                WHSInvent::executeMoveWorkQtyLite(_workInventTrans, _inventDimIdFrom, _inventDimIdTo, _qty, _cwQty, _updateTransDimBeforeUpdate, _skipInventTransSumUp, _locationMixingConstraintCheckSkip);
            }
        }
        else
        {
            if (WarehouseInventoryTransactionStackFinLiteProcessFlight::instance().isEnabled()
                && WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workInventTrans.WorkId))
            {
                WHSInventoryTransactionWorkController::construct().moveSpecificQty(_workInventTrans, InventDim::find(_inventDimIdFrom), InventDim::find(_inventDimIdTo), _qty, _cwQty, _updateTransDimBeforeUpdate);
            }
            else
            {
                WHSInvent::executeMoveWorkQty(_workInventTrans, _inventDimIdFrom, _inventDimIdTo, _qty, _cwQty, _inventCostOnhandCache, _ledgerVoucher, _locationMixingConstraintCheckSkip);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickTargetTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks or unpicks quantity against transactions of movement.
    /// </summary>
    /// <param name="_common">
    /// The common movement buffer record.
    /// </param>
    /// <param name="_toInventDimId">
    /// The inventory dimensions that should be picked.
    /// </param>
    /// <param name="_qty">
    /// The quantity that should be picked.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventDimParm used to determine what dimensions criteria values are used when selecting transactions to pick.
    /// </param>
    /// <param name="_forceDimCriteriaOnTransSelect">
    /// A Boolean that determines if we should force dimensions criteria to be used during transactions selection.
    /// </param>
    /// <param name="_autoReserveOnPickLess">
    /// A <c>UnknownNoYes</c> enumeration value that defines, if inventory transactions should be reserved when un-picking.
    /// </param>
    /// <param name="_skipCheckPickComplete">
    /// A Boolean that determines if we should skip checking if all quantities have been picked.
    /// </param>
    /// <remarks>
    /// A positive _qty should be used to increase picked transactions, a negative _qty should be used to decreased picked transactions.
    /// </remarks>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the pickQuantities method. Extenders should move their logic to wrap the pickMovementQuantities method.', false, 30\9\2019)]
    public static void pickTargetTransaction(
        Common          _common,
        InventDimId     _toInventDimId,
        InventQty       _qty,
        InventDimParm   _inventDimParm                 = null,
        boolean         _forceDimCriteriaOnTransSelect = false,
        UnknownNoYes    _autoReserveOnPickLess         = UnknownNoYes::Unknown,
        boolean         _skipCheckPickComplete         = false)
    {
        InventMovement movement = WHSInvent::getInventMovementForQuantityPicking(_common, _toInventDimId);

        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), movement.itemId());

        WhsInvent::pickMovementQuantities(movement, _toInventDimId, _qty, 0, _inventDimParm, _autoReserveOnPickLess, _skipCheckPickComplete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks or unpicks quantity against transactions of movement.
    /// </summary>
    /// <param name="_common">
    /// The common movement buffer record.
    /// </param>
    /// <param name="_toInventDimId">
    /// The inventory dimensions that should be picked.
    /// </param>
    /// <param name="_qty">
    /// The quantity that should be picked.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity that should be picked.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventDimParm used to determine what dimensions criteria values are used when selecting transactions to pick.
    /// </param>
    /// <param name="_autoReserveOnPickLess">
    /// A <c>UnknownNoYes</c> enumeration value that defines, if inventory transactions should be reserved when un-picking.
    /// </param>
    /// <param name="_skipCheckPickComplete">
    /// A Boolean that determines if we should skip checking if all quantities have been picked.
    /// </param>
    /// <remarks>
    /// A positive quantity should be used to increase picked transactions, a negative quantity should be used to decreased picked transactions.
    /// </remarks>
    [Hookable(false)]
    public static void pickQuantities(
        Common          _common,
        InventDimId     _toInventDimId,
        InventQty       _qty,
        PdsCWInventQty  _cwQty,
        InventDimParm   _inventDimParm                 = null,
        UnknownNoYes    _autoReserveOnPickLess         = UnknownNoYes::Unknown,
        boolean         _skipCheckPickComplete         = false)
    {
        WhsInvent::executePicking(_common, _toInventDimId, _qty, _cwQty, _inventDimParm, _autoReserveOnPickLess, _skipCheckPickComplete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePicking</Name>
				<Source><![CDATA[
    [Wrappable(true), Replaceable(true)]
    internal static void executePicking(
        Common _common,
        InventDimId _toInventDimId,
        InventQty _qty,
        PdsCWInventQty _cwQty,
        InventDimParm _inventDimParm,
        UnknownNoYes _autoReserveOnPickLess,
        boolean _skipCheckPickComplete)
    {
        InventMovement movement = WHSInvent::getInventMovementForQuantityPicking(_common, _toInventDimId);

        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), movement.itemId(), _cwQty))
        {
            WhsInvent::pickTargetTransaction(_common, _toInventDimId, _qty, _inventDimParm, false, _autoReserveOnPickLess, _skipCheckPickComplete);
        }
        else
        {
            WhsInvent::pickMovementQuantities(movement, _toInventDimId, _qty, _cwQty, _inventDimParm, _autoReserveOnPickLess, _skipCheckPickComplete);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventMovementForQuantityPicking</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal static InventMovement getInventMovementForQuantityPicking(Common _common, InventDimId _inventDimId)
    {
        return InventMovement::construct(_common);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMovementQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks or unpicks quantities against transactions of movement.
    /// </summary>
    /// <param name="_movement">
    /// An <c>InventMovement</c> object.
    /// </param>
    /// <param name="_toInventDimId">
    /// The inventory dimensions that should be picked.
    /// </param>
    /// <param name="_qty">
    /// The quantity that should be picked.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity that should be picked.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventDimParm used to determine what dimensions criteria values are used when selecting transactions to pick.
    /// </param>
    /// <param name="_autoReserveOnPickLess">
    /// A <c>UnknownNoYes</c> enumeration value that defines, if inventory transactions should be reserved when un-picking.
    /// </param>
    /// <param name="_skipCheckPickComplete">
    /// A Boolean that determines if we should skip checking if all quantities have been picked.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the pickQuantities method.
    /// </remarks>
    [Wrappable(true)]
    protected static void pickMovementQuantities(
        InventMovement  _movement,
        InventDimId     _toInventDimId,
        InventQty       _qty,
        PdsCWInventQty  _cwQty,
        InventDimParm   _inventDimParm,
        UnknownNoYes    _autoReserveOnPickLess,
        boolean         _skipCheckPickComplete)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _movement.ItemId(), _cwQty, _qty);
        
        InventDimParm           inventDimParmAllActive;
        InventDimParm           inventDimParmInventTransSelect = _inventDimParm;

        _movement.parmSkipCheckPickComplete(_skipCheckPickComplete);

        // Now pick
        InventDim inventDim = InventDim::find(_toInventDimId);
        _movement.inventDimGroupSetup().inventDimParmActive(inventDimParmAllActive);

        // For performance we first check if site or warehouse are set before we check all dimensions
        if (inventDimParmInventTransSelect.InventSiteIdFlag     == NoYes::No
        &&  inventDimParmInventTransSelect.InventLocationIdFlag == NoYes::No
        &&  inventDimParmInventTransSelect.isAllFlagNo())
        {
            inventDimParmInventTransSelect = inventDimParmAllActive;
        }

        if (WhsInvent::mustUsePickIdAllocator(_movement, _qty, _cwQty))
        {
            var inventPickingContext = WhsInventPickingContext::current();
            ListEnumerator pickIdsEnum = inventPickingContext.parmPickIdAllocator().allocatePickIds(_movement, inventDim.inventDimId, _qty);
            while (pickIdsEnum.moveNext())
            {
                WhsLoadLineInventTransPickIdAllocation pickIdAllocation = pickIdsEnum.current();

                InventUpd_Picked picked = InventUpd_Picked::newParameters(_movement, inventDim, inventDimParmAllActive, inventDim, inventDimParmInventTransSelect, -pickIdAllocation.parmAllocatedInventQty(), pickIdAllocation.parmAllocatedPickId(), -0);
                picked.parmAutoReserveOnPickLess(_autoReserveOnPickLess);
                picked.parmSkipOnHandCheckDuringTransPick(true);
                picked.parmSplitWithPessimisticLock(WHSWorkDeferredPutInventTransSplitWithPessimisticLockContext::current() != null);
                picked.updateNow();
            }
        }
        else
        {
            InventUpd_Picked picked = InventUpd_Picked::newParameters(_movement, inventDim, inventDimParmAllActive, inventDim, inventDimParmInventTransSelect, -_qty, '', -_cwQty);
            picked.parmAutoReserveOnPickLess(_autoReserveOnPickLess);
            picked.parmSkipOnHandCheckDuringTransPick(true);
            picked.parmSplitWithPessimisticLock(WHSWorkDeferredPutInventTransSplitWithPessimisticLockContext::current() != null);
            picked.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUsePickIdAllocator</Name>
				<Source><![CDATA[
    private static boolean mustUsePickIdAllocator(
        InventMovement  _movement,
        InventQty       _qty,
        PdsCWInventQty  _cwQty)
    {
        var inventPickingContext = WhsInventPickingContext::current();
        boolean forcePickIdAllocation = inventPickingContext == null ? false : inventPickingContext.parmForcePickIdAllocation();
        boolean mustUsePickIdAllocator = (WHSInventTransPickIdAllocationConfigurationProvider::newFromInventTransType(_movement.transType()).mustUseInventTransPickIdAllocation() || forcePickIdAllocation) && (!_cwQty && _qty > 0);
        boolean canUsePickIdAllocator = (inventPickingContext && inventPickingContext.parmPickIdAllocator());

        if (!canUsePickIdAllocator && mustUsePickIdAllocator)
        {
            throw error(strFmt("@WAX:CalledWithoutContextAndMustUsePickIdAllocator", funcName(), WHSInstrumentationLogger::currentStackTrace(true)));
        }

        if (inventPickingContext && inventPickingContext.parmSkipPickIdAllocation())
        {
            mustUsePickIdAllocator = false;
        }

        return mustUsePickIdAllocator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves an inventory item.
    /// </summary>
    /// <param name="_common">
    /// The inventory item to be reserved.
    /// </param>
    /// <param name="_toInventDimId">
    /// Dimensions of the item after reservation.
    /// </param>
    /// <param name="_qty">
    /// Quantity of the item to be reserved.
    /// </param>
    public static void reserveInventory(
        Common      _common,
        InventDimId _toInventDimId,
        InventQty   _qty)
    {
        InventDim               inventDim;
        InventDimParm           inventDimParm;
        InventDimParm           inventDimParmFixed;
        InventMovement          movement;
        InventUpd_Reservation   reservation;

        movement = InventMovement::construct(_common);
        inventDim = movement.inventdim();
        inventDim = InventDim::find(_toInventDimId);
        movement.inventdim(inventDim);

        inventDimParm.initFromInventDim(inventDim);
        inventDimParmFixed.initFromInventDim(inventDim);

        reservation = InventUpd_Reservation::newParameters(movement,
                                                           inventDim,
                                                           inventDimParm,
                                                           InventDimFixedClass::inventDimParm2InventDimFixed(inventDimParmFixed),
                                                           _qty,
                                                           false);

        reservation.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTypeCanHaveBlockingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given transaction type can have a blocking status.
    /// </summary>
    /// <param name="_transType">
    /// The transaction type of the movement.
    /// </param>
    /// <param name="_inventQty">
    /// The inventory quantity associated with the transaction.
    /// </param>
    /// <returns>
    /// Returns true if the given transaction is allowed to have a blocking status.
    /// </returns>
    public static boolean transTypeCanHaveBlockingStatus(InventTransType _transType, InventQty _inventQty)
    {
        boolean ret;

        switch (_transType)
        {
            case InventTransType::Sales:
                ret = _inventQty > 0 ? true : false;
                break;
            case InventTransType::InventTransfer:
            case InventTransType::KanbanEmptied:
            case InventTransType::KanbanJobPickingList:
            case InventTransType::KanbanJobProcess:
            case InventTransType::KanbanJobTransferIssue:
            case InventTransType::KanbanJobTransferReceipt:
            case InventTransType::KanbanJobWIP:
            case InventTransType::Production:
            case InventTransType::ProdLine:
            case InventTransType::TransferOrderShip:
                ret = false;
                break;
            default:
                ret = true;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTypeOnlyAffectsLocationAndBelow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction type only affects reservations for location level and below in the hierarchy.
    /// </summary>
    /// <param name="_transType">
    /// The <c>InventTransType</c> to be evaluated.
    /// </param>
    /// <returns>
    /// true if the transaction only affects location and below in the hierarchy; otherwise, false.
    /// </returns>
    public static boolean transTypeOnlyAffectsLocationAndBelow(InventTransType _transType)
    {
        return _transType    == InventTransType::WHSWork
               || _transType == InventTransType::WHSContainer
               || _transType == InventTransType::WHSOrderCommittedReservation
               || _transType == InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimensionBeforeMove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates dimensions before inventory movement.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_newInventDim">
    /// New dimensions to be updated to.
    /// </param>
    /// <param name="_movement">
    /// The <c>InventMovement</c> record.
    /// </param>
    /// <param name="_qty">
    /// The specified quantity.
    /// </param>    
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static void updateDimensionBeforeMove(
        InventTrans    _inventTrans,
        InventDim      _newInventDim,
        InventMovement _movement,
        InventQty      _qty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _movement.itemId());

        WhsInvent::updateWorkTransactionDimensionsForQuantitiesBeforeMove(_inventTrans, _newInventDim, _movement, _qty, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkTransactionDimensionsBeforeMove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates dimensions before inventory movement.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_newInventDim">
    /// New dimensions to be updated to.
    /// </param>
    /// <param name="_movement">
    /// The <c>InventMovement</c> record.
    /// </param>
    /// <param name="_qty">
    /// The specified quantity.
    /// </param>
    /// <param name="_cwQty">
    /// The specified catch weight quantity.
    /// </param>
    private static void updateWorkTransactionDimensionsBeforeMove(
        InventTrans    _inventTrans,
        InventDim      _newInventDim,
        InventMovement _movement,
        InventQty      _qty,
        PdsCWInventQty _cwQty)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _movement.itemId(), _cwQty))
        {
            WhsInvent::updateDimensionBeforeMove(_inventTrans, _newInventDim, _movement, _qty);
        }
        else
        {
            WhsInvent::updateWorkTransactionDimensionsForQuantitiesBeforeMove(_inventTrans, _newInventDim, _movement, _qty, _cwQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkTransactionDimensionsForQuantitiesBeforeMove</Name>
				<Source><![CDATA[
    private static void updateWorkTransactionDimensionsForQuantitiesBeforeMove(
        InventTrans    _inventTrans,
        InventDim      _newInventDim,
        InventMovement _movement,
        InventQty      _qty,
        PdsCWInventQty _cwQty)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _movement.ItemId(), _cwQty, _qty);
        
        InventUpdate    inventUpdate;

        if (_movement.inventDimId() != _newInventDim.InventDimId)
        {
            inventUpdate = InventUpdate::newChangeTransDim(_movement);

            if (_qty < 0)
            {
                inventUpdate.updateIssueWorkTransactionDimensions(_inventTrans,
                                                                  _inventTrans.inventDim(),
                                                                  _newInventDim,
                                                                  _qty, 
                                                                  _cwQty);
            }
            else
            {
                inventUpdate.updateTransDimReceipt(_inventTrans,
                                                   _inventTrans.inventDim(),
                                                   _newInventDim,
                                                   _qty,
                                                   false,
                                                   true,
                                                   _cwQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPutLicensePlateOnLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the on hand for the specified license plate exists on a different location.
    /// </summary>
    /// <param name="_licensePlateId">
    /// ID of the license plate.
    /// </param>
    /// <param name="_wmsLocationId">
    /// ID of the warehouse location.
    /// </param>
    /// <param name="_inventLocationId">
    /// ID of the warehouse.
    /// </param>
    /// <param name="_checkUserLocations">
    /// true if user locations should also be checked; otherwise, false.
    /// </param>
    /// <param name="_inventLocationIdToIgnore">
    /// The id of the warehouse that should be ignored during the validation, optional.
    /// </param>
    /// <returns>
    /// true if the license plate does not exist on other locations; otherwise, false.
    /// </returns>
    public static boolean canPutLicensePlateOnLocation(
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        boolean             _checkUserLocations,
        InventLocationId    _inventLocationIdToIgnore = '')
    {
        boolean canPut = !WHSInvent::licensePlateExistsOnOtherLocation(_licensePlateId, _wmsLocationId, _inventLocationId, _checkUserLocations, _inventLocationIdToIgnore);
        
        // Check all nested license plates, if any exist
        if (canPut)
        {
            var nestedLicensePlateIds = WHSLicensePlate::getNestedLicensePlates(_licensePlateId).getEnumerator();

            while (canPut && nestedLicensePlateIds.moveNext())
            {
                WHSLicensePlateId nestedLicensePlate = nestedLicensePlateIds.current();
                
                canPut = WHSInvent::canPutLicensePlateOnLocation(nestedLicensePlate, _wmsLocationId, _inventLocationId, _checkUserLocations, _inventLocationIdToIgnore);
            }
        }

        return canPut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>licensePlateExistsOnOtherLocation</Name>
				<Source><![CDATA[
    private static boolean licensePlateExistsOnOtherLocation(
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        boolean             _checkUserLocations,
        InventLocationId    _inventLocationIdToIgnore = '')
    {
        boolean existsOnOtherLocation = false;

        if (_checkUserLocations)
        {
            existsOnOtherLocation = WhsInvent::licensePlateExistsOnOtherLocationAnyProfile(_licensePlateId, _wmsLocationId, _inventLocationId, _inventLocationIdToIgnore);
        }
        else
        {
            existsOnOtherLocation = WhsInvent::licensePlateExistsOnOtherLocationExcludeUserLocations(_licensePlateId, _wmsLocationId, _inventLocationId, _inventLocationIdToIgnore);
        }

        return existsOnOtherLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>licensePlateExistsOnOtherLocationExcludeUserLocations</Name>
				<Source><![CDATA[
    private static boolean licensePlateExistsOnOtherLocationExcludeUserLocations(
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        InventLocationId    _inventLocationIdToIgnore)
    {
        // Accept any put on user location without checking.
        if (WMSLocation::find(_wmsLocationId, _inventLocationId).whsLocationIsUserLocation())
        {
            return false;
        }

        boolean existsOnOtherLocation = false;

        ttsbegin;

        WHSUserLocType userLocType = WHSParameters::find().UserLocType;

        InventSum   inventSum;
        InventDim   inventDim;
        WMSLocation wmslocation;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            // Check to make sure this license plate doesn't already exist in another location
            while select ItemId, InventDimId, PhysicalInvent, PdsCWPhysicalInvent
                from inventSum
                where inventSum.ClosedQty           == NoYes::No
                    && inventSum.PhysicalInvent      > 0
                    && inventSum.LicensePlateId     == _licensePlateId
                    && (inventSum.InventLocationId  != _inventLocationId
                        || inventSum.wmsLocationId  != _wmsLocationId)
                    && (_inventLocationIdToIgnore == '' || inventSum.InventLocationId != _inventLocationIdToIgnore)
                exists join wmsLocation
                    where wmsLocation.wmsLocationId     == inventSum.wmsLocationId
                        && wmsLocation.InventLocationId == inventSum.InventLocationId
                        && wmsLocation.LocProfileId     != userLocType
            {
                if (WhsInvent::physicalOnhandExists(inventSum.ItemId, inventSum.InventDimId, inventSum.PhysicalInvent, inventSum.PdsCWPhysicalInvent))
                {
                    existsOnOtherLocation = true;
                    break;
                }
            }
        }
        else
        {
            // Check to make sure this license plate doesn't already exist in another location
            while select ItemId, InventDimId, PhysicalInvent, PdsCWPhysicalInvent
                from inventSum
                    where inventSum.ClosedQty       == NoYes::No
                        && inventSum.PhysicalInvent  > 0
                    exists join inventDim
                        where inventDim.InventDimId         == inventSum.InventDimId
                            && inventDim.LicensePlateId     == _licensePlateId
                            && (inventDim.InventLocationId  != _inventLocationId
                                || inventDim.wmsLocationId  != _wmsLocationId)
                            && (_inventLocationIdToIgnore == '' || inventDim.InventLocationId != _inventLocationIdToIgnore)
                    exists join wmsLocation
                        where wmsLocation.wmsLocationId     == inventDim.wmsLocationId
                            && wmsLocation.InventLocationId == inventDim.InventLocationId
                            && wmsLocation.LocProfileId     != userLocType
            {
                if (WhsInvent::physicalOnhandExists(inventSum.ItemId, inventSum.InventDimId, inventSum.PhysicalInvent, inventSum.PdsCWPhysicalInvent))
                {
                    existsOnOtherLocation = true;
                    break;
                }
            }
        }

        if (!existsOnOtherLocation)
        {
            if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
            {
                InventSumDelta inventSumDelta;

                if (InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    // Now need to check for inventSumDelta records that don't have
                    // any corresponding inventSum records
                    while select ItemId, InventDimId, sum(PhysicalInvent), sum(PdsCWPhysicalInvent)
                        from inventSumDelta
                            group by ItemId, InventDimId
                                where inventSumDelta.SQLTransactionID == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                                    && inventSumDelta.LicensePlateId == _licensePlateId
                                    && (inventSumDelta.InventLocationId != _inventLocationId
                                       || inventSumDelta.wmsLocationId != _wmsLocationId)
                                    && (_inventLocationIdToIgnore == '' || inventSumDelta.InventLocationId != _inventLocationIdToIgnore)
                            exists join wmsLocation
                                where wmsLocation.wmsLocationId == inventSumDelta.wmsLocationId
                                    && wmsLocation.InventLocationId  == inventSumDelta.InventLocationId
                                    && wmsLocation.LocProfileId != userLocType
                            notexists join inventSum
                                where inventSum.ItemId == inventSumDelta.ItemId
                                    && inventSum.InventDimId == inventSumDelta.InventDimId
                                    && !inventSum.ClosedQty
                                    && inventSum.PhysicalInvent > 0
                    {
                        // Get the total for this inventSumRecord
                        if ((!PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId)) ?
                            (inventSumDelta.PhysicalInvent > 0) :
                            (inventSumDelta.PdsCWPhysicalInvent > 0))
                        {
                            existsOnOtherLocation = true;
                            break;
                        }
                    }
                }
                else
                {
                    // Now need to check for inventSumDelta records that don't have
                    // any corresponding inventSum records
                    while select ItemId, InventDimId, sum(PhysicalInvent), sum(PdsCWPhysicalInvent)
                        from inventSumDelta
                            group by ItemId, InventDimId
                                where inventSumDelta.SQLTransactionID == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                            exists join inventDim
                                where inventDim.InventDimId == inventSumDelta.InventDimId
                                    && inventDim.LicensePlateId == _licensePlateId
                                    && (inventDim.InventLocationId != _inventLocationId
                                        || inventDim.wmsLocationId != _wmsLocationId)
                                    && (_inventLocationIdToIgnore == '' || inventDim.InventLocationId != _inventLocationIdToIgnore)
                            exists join wmsLocation
                                where wmsLocation.wmsLocationId == inventDim.wmsLocationId
                                    && wmsLocation.InventLocationId  == inventDim.InventLocationId
                                    && wmsLocation.LocProfileId != userLocType
                            notexists join inventSum
                                where inventSum.ItemId == inventSumDelta.ItemId
                                    && inventSum.InventDimId == inventSumDelta.InventDimId
                                    && !inventSum.ClosedQty
                                    && inventSum.PhysicalInvent > 0
                    {
                        // Get the total for this inventSumRecord
                        if ((!PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId)) ?
                            (inventSumDelta.PhysicalInvent > 0) :
                            (inventSumDelta.PdsCWPhysicalInvent > 0))
                        {
                            existsOnOtherLocation = true;
                            break;
                        }
                    }
                }
            }
        }

        ttscommit;

        return existsOnOtherLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>licensePlateExistsOnOtherLocationAnyProfile</Name>
				<Source><![CDATA[
    private static boolean licensePlateExistsOnOtherLocationAnyProfile(
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        InventLocationId    _inventLocationIdToIgnore)
    {
        boolean existsOnOtherLocation = false;

        ttsbegin;

        InventSum   inventSum;
        InventDim   inventDim;
        WMSLocation wmslocation;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            while select ItemId, InventDimId, PhysicalInvent, PdsCWPhysicalInvent
                from inventSum
                where   inventSum.ClosedQty         == NoYes::No
                     && inventSum.PhysicalInvent     > 0
                     && inventSum.LicensePlateId    == _licensePlateId
                     && (inventSum.InventLocationId != _inventLocationId
                        || inventSum.wmsLocationId  != _wmsLocationId)
                     && (_inventLocationIdToIgnore == '' || inventSum.InventLocationId != _inventLocationIdToIgnore)
            {
                if (WhsInvent::physicalOnhandExists(inventSum.ItemId, inventSum.InventDimId, inventSum.PhysicalInvent, inventSum.PdsCWPhysicalInvent))
                {
                    existsOnOtherLocation = true;
                    break;
                }
            }
        }
        else
        {
            while select ItemId, InventDimId, PhysicalInvent, PdsCWPhysicalInvent
                from inventSum
                where   inventSum.ClosedQty         == NoYes::No
                        && inventSum.PhysicalInvent > 0
                exists join inventDim
                    where inventDim.InventDimId == inventSum.InventDimId
                          && inventDim.LicensePlateId == _licensePlateId
                          && (inventDim.InventLocationId != _inventLocationId
                              || inventDim.wmsLocationId != _wmsLocationId)
                          && (_inventLocationIdToIgnore == '' || inventDim.InventLocationId != _inventLocationIdToIgnore)
            {
                if (WhsInvent::physicalOnhandExists(inventSum.ItemId, inventSum.InventDimId, inventSum.PhysicalInvent, inventSum.PdsCWPhysicalInvent))
                {
                    existsOnOtherLocation = true;
                    break;
                }
            }
        }

        if (!existsOnOtherLocation)
        {
            if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
            {
                InventSumDelta inventSumDelta;

                if (InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    // Now need to check for inventSumDelta records that don't have
                    // any corresponding inventSum records
                    while select ItemId, InventDimId, sum(PhysicalInvent), sum(PdsCWPhysicalInvent)
                    from inventSumDelta
                        group by ItemId, InventDimId
                            where inventSumDelta.SQLTransactionID == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                                && inventSumDelta.LicensePlateId == _licensePlateId
                                && (inventSumDelta.InventLocationId != _inventLocationId
                                    || inventSumDelta.wmsLocationId != _wmsLocationId)
                                && (_inventLocationIdToIgnore == '' || inventSumDelta.InventLocationId != _inventLocationIdToIgnore)
                        notexists join inventSum
                            where inventSum.ItemId == inventSumDelta.ItemId
                                && inventSum.InventDimId == inventSumDelta.InventDimId
                                && !inventSum.ClosedQty
                                && inventSum.PhysicalInvent > 0
                    {
                        // Get the total for this inventSumRecord
                        if ((!PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId)) ?
                        (inventSumDelta.PhysicalInvent > 0) :
                        (inventSumDelta.PdsCWPhysicalInvent > 0))
                        {
                            existsOnOtherLocation = true;
                            break;
                        }
                    }
                }
                else
                {
                    // Now need to check for inventSumDelta records that don't have
                    // any corresponding inventSum records
                    while select ItemId, InventDimId, sum(PhysicalInvent), sum(PdsCWPhysicalInvent)
                    from inventSumDelta
                        group by ItemId, InventDimId
                            where inventSumDelta.SQLTransactionID == InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()
                        exists join inventDim
                            where inventDim.InventDimId == inventSumDelta.InventDimId
                                && inventDim.LicensePlateId == _licensePlateId
                                && (inventDim.InventLocationId != _inventLocationId
                                    || inventDim.wmsLocationId != _wmsLocationId)
                                && (_inventLocationIdToIgnore == '' || inventDim.InventLocationId != _inventLocationIdToIgnore)
                        notexists join inventSum
                            where inventSum.ItemId == inventSumDelta.ItemId
                                && inventSum.InventDimId == inventSumDelta.InventDimId
                                && !inventSum.ClosedQty
                                && inventSum.PhysicalInvent > 0
                    {
                        // Get the total for this inventSumRecord
                        if ((!PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId)) ?
                        (inventSumDelta.PhysicalInvent > 0) :
                        (inventSumDelta.PdsCWPhysicalInvent > 0))
                        {
                            existsOnOtherLocation = true;
                            break;
                        }
                    }
                }
            }
        }
            
        ttscommit;

        return existsOnOtherLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalOnhandExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there is physical onhand for given item and dimensions combination taking <c>InventSumDelta</c> into account.
    /// There must be existing <c>InventSum</c> record for the given item and dimensions.
    /// </summary>
    /// <param name = "_itemId">Id of the item to check.</param>
    /// <param name = "_inventDimId">Physical dimensions.</param>
    /// <param name = "_physicalQty">Physical inventory quantity from <c>InventSum</c></param>
    /// <param name = "_physicalCWQty">Physical catch weight quantity from <c>InventSum</c></param>
    /// <returns>true if physical onhand exists; otherwise, false.</returns>
    [Hookable(false)]
    internal static boolean physicalOnhandExists(
        ItemId                  _itemId,
        InventDimId             _inventDimId,
        InventQtyPhysicalOnhand _physicalQty,
        PdsCWPhysicalInvent     _physicalCWQty)
    {
        InventQtyPhysicalOnhand physicalQty     = _physicalQty;
        PdsCWPhysicalInvent     physicalCWQty   = _physicalCWQty;

        // Existing inventSumDelta records may have already moved this LP
        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId))
        {
            InventSumDelta inventSumDelta = InventSumDelta::findSumDeltaDimId(_itemId, _inventDimId);
            physicalQty     += inventSumDelta.PhysicalInvent;
            physicalCWQty   += inventSumDelta.PdsCWPhysicalInvent;
        }

        return (!PdsGlobal::pdsIsCWItem(_itemId)) ? (physicalQty > 0) : (physicalCWQty > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLicensePlateInLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the on hand for the specified license plate exists on a different location.
    /// </summary>
    /// <param name="_licensePlateId">
    /// ID of the license plate.
    /// </param>
    /// <param name="_wmsLocationId">
    /// ID of the warehouse location.
    /// </param>
    /// <param name="_inventLocationId">
    /// ID of the warehouse.
    /// </param>
    /// <param name="_inventLocationIdToIgnore">
    /// The id of the warehouse that should be ignored during the validation, optional.
    /// </param>
    /// <param name="_skipUserLocationCheck">
    /// true if location should be checked even if it is user location; otherwise, false, optional.
    /// By default user locations are not checked as user can pick license plate partially and later put it into different target license plate.
    /// </param>
    /// <returns>
    /// true if the on hand for the specified license plate exists on a different location; otherwise, false.
    /// </returns>
    [SysObsolete('Please use WhsInvent::canPutLicensePlateOnLocation instead', false, 31\03\2018)]
    public static boolean validateLicensePlateInLocation(
        WHSLicensePlateId   _licensePlateId,
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        InventLocationId    _inventLocationIdToIgnore = '',
        boolean             _skipUserLocationCheck = true)
    {
        return WhsInvent::canPutLicensePlateOnLocation(_licensePlateId, _wmsLocationId, _inventLocationId, !_skipUserLocationCheck, _inventLocationIdToIgnore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsIsBlankIssueReceiptAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if dimensions setup for the field should allow configuration to allow blank issue and receipt.
    /// </summary>
    /// <param name="_dimFieldId">
    /// The field Id of the inventDim field being evaluated.
    /// </param>
    /// <returns>
    /// true, if the field can allow blank issue and receipt; otherwise, false.
    /// </returns>
    public static boolean whsIsBlankIssueReceiptAllowed(FieldId _dimFieldId)
    {
        #InventDimDevelop

        switch (_dimFieldId)
        {
            case fieldNum(InventDim, InventSerialId):
            case fieldNum(InventDim, LicensePlateId):
                return true;

            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkQtyToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds goods to the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to.
    /// </param>
    /// <param name="_costAmount">
    /// Cost amount that should be applied.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work invent transaction; optional.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static void addWorkQtyToLocation(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        CostAmount              _costAmount,
        WHSInventMov_Work       _workMovement = null,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip = null)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workInventTrans.ItemId);

        WhsInvent::addWorkInventoryQuantitiesToLocation(_workInventTrans, _inventDimIdTo, _qty, 0, _inventCostOnhandCache, _ledgerVoucher, _costAmount, _workMovement, _locationMixingConstraintCheckSkip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkQuantitiesToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds goods to the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to.
    /// </param>
    /// <param name="_costAmount">
    /// Cost amount that should be applied.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work inventory transaction.
    /// If null then work movement from the work transaction will be used.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    [Hookable(false)]
    internal static void addWorkQuantitiesToLocation(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        PdsCWInventQty          _cwQty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        CostAmount              _costAmount,
        WHSInventMov_Work       _workMovement,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _workInventTrans.ItemId, _cwQty))
        {
            WhsInvent::addWorkQtyToLocation(_workInventTrans, _inventDimIdTo, _qty, _inventCostOnhandCache, _ledgerVoucher, _costAmount, _workMovement, _locationMixingConstraintCheckSkip);
        }
        else
        {
            WhsInvent::addWorkInventoryQuantitiesToLocation(_workInventTrans, _inventDimIdTo, _qty, _cwQty, _inventCostOnhandCache, _ledgerVoucher, _costAmount, _workMovement, _locationMixingConstraintCheckSkip);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkInventoryQuantitiesToLocation</Name>
				<Source><![CDATA[
    private static void addWorkInventoryQuantitiesToLocation(
        WHSWorkInventTrans                   _workInventTrans,
        InventDimId                          _inventDimIdTo,
        InventQty                            _qty,
        PdsCWInventQty                       _cwQty,
        InventCostOnhandCache                _inventCostOnhandCache,
        LedgerVoucher                        _ledgerVoucher,
        CostAmount                           _costAmount,
        WHSInventMov_Work                    _workMovement,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _workInventTrans.ItemId, _cwQty, _qty);
        
        InventUpd_Financial     inventUpdTo;
        WHSInventMov_Work       workMovement;
        WHSInventMov_WorkTo     movementTo;
        InventDim               inventDimTo;
        InventDim               oldToInventDim;
        InventDimParm           inventDimParm;

        inventDimTo = InventDim::find(_inventDimIdTo);
        inventDimParm.initFromInventDim(inventDimTo);
        movementTo = InventMovement::construct(_workInventTrans, InventMovSubType::TransferReceipt) as WHSInventMov_WorkTo;

        // Update location on the To InventDim if needed
        oldToInventDim = movementTo.inventdim();
        if (inventDimTo.wmsLocationId != oldToInventDim.wmsLocationId
            &&  movementTo.remainPhysical() == _qty
            &&  movementTo.pdsCWRemainPhysical() == _cwQty)
        {
            oldToInventDim.wmsLocationId = inventDimTo.wmsLocationId;
            oldToInventDim = InventDim::findOrCreate(oldToInventDim);
            movementTo.setInventDimId(oldToInventDim.InventDimId);
            movementTo.inventdim(oldToInventDim);
            movementTo.buffer().doUpdate();
        }

        workMovement = _workMovement != null    ?
                       _workMovement            :
                       movementTo;

        if (workMovement.canUseLiteProcess())
        {
            WHSInvent::updateFinanciallyLite(_workInventTrans, inventDimTo, _qty, _cwQty, InventMovSubType::TransferReceipt, false, _locationMixingConstraintCheckSkip);
        }
        else
        {
            inventUpdTo = InventUpd_Financial::newFromWorkMovement(movementTo, _ledgerVoucher, _costAmount, _qty, _cwQty, _inventCostOnhandCache);
            inventUpdTo.parmInventDim(inventDimTo);
            inventUpdTo.parmInventDimParm(inventDimParm);
            inventUpdTo.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMoveWorkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes a full financial update of the work.
    /// </summary>
    /// <param name="_workInventTrans">
    /// <c>WHSWorkInventTrans</c> record associated with the work.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// <c>InventDim</c> record containing from dimensions.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// <c>InventDim</c> record containing to dimensions.
    /// </param>
    /// <param name="_qty">
    /// Quantity to be moved.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to be moved.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// Cache for the on-hand cost.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher to use.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    private static void executeMoveWorkQty(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        PdsCWInventQty          _cwQty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip)
    {
        InventUpd_Financial     inventUpdFrom;
        LedgerVoucher           ledgerVoucher;
        boolean                 mustEndLedgerVoucher;

        ttsbegin;

        if (_ledgerVoucher)
        {
            ledgerVoucher = _ledgerVoucher;
        }
        else
        {
            ledgerVoucher = WHSInvent::beginLedger(_workInventTrans.WorkId);
            mustEndLedgerVoucher = true;
        }

        // Remove From Location
        WHSInvent::updateIssueWorkTransactionDimensions(_workInventTrans, _inventDimIdFrom, _qty, _cwQty);
        inventUpdFrom = WHSInvent::removeWorkQuantitiesFromLocation(_workInventTrans, _inventDimIdFrom, _qty, _cwQty, _inventCostOnhandCache, ledgerVoucher, null);

        // Add To Location
        WHSInvent::updateReceiptWorkTransactionDimensions(_workInventTrans, _inventDimIdTo, _qty, _cwQty);
        WHSInvent::addWorkQuantitiesToLocation(_workInventTrans, _inventDimIdTo, _qty, _cwQty, _inventCostOnhandCache, ledgerVoucher, -inventUpdFrom.updCostAmountInvent(), null, null);
    
        if (mustEndLedgerVoucher)
        {
            ledgerVoucher.end();
        }

        // After work transactions have been executed we should check the issue dimension set and make sure weight is within minimum threshold.
        PDSCatchWeightOnHandAdjustment::adjustOnhandWeightWithinThresholds(_workInventTrans.ItemId, _inventDimIdFrom);
      
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMoveWorkQtyLite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes the lite financial update of the work.
    /// </summary>
    /// <param name="_workInventTrans">
    ///     <c>WHSWorkInventTrans</c> record associated with the work.
    /// </param>
    /// <param name="_inventDimIdFrom">
    ///     <c>InventDim</c> record containing from dimensions.
    /// </param>
    /// <param name="_inventDimIdTo">
    ///     <c>InventDim</c> record containing to dimensions.
    /// </param>
    /// <param name="_qty">
    ///     Quantity to be moved.
    /// </param>
    /// <param name="_cwQty">
    ///     Catch weight quantity to be moved.
    /// </param>
    /// <param name="_updateTransDimBeforeUpdate">
    ///   A Boolean that determines if the inventory transactions should be updated with the from and to dimensions before the update; optional.
    /// </param>
    /// <param name="_skipInventTransSumUp">
    ///   A Boolean that determines if the inventory transactions should be summed up as part of the update; optional.
    /// </param>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    private static void executeMoveWorkQtyLite(
        WHSWorkInventTrans  _workInventTrans,
        InventDimId         _inventDimIdFrom,
        InventDimId         _inventDimIdTo,
        InventQty           _qty,
        PdsCWInventQty      _cwQty,
        boolean             _updateTransDimBeforeUpdate,
        boolean             _skipInventTransSumUp,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip)
    {
        InventDim       inventDimFrom;
        InventDim       inventDimTo;
        InventDim       oldInventDimTo;
        InventMovement  movementTo;

        ttsbegin;

        // Update issue transactions
        if (_updateTransDimBeforeUpdate)
        {
            WHSInvent::updateIssueWorkTransactionDimensions(_workInventTrans, _inventDimIdFrom, _qty, _cwQty);
        }

        inventDimFrom = InventDim::find(_inventDimIdFrom);
        WHSInvent::updateFinanciallyLite(_workInventTrans, inventDimFrom, -_qty, -_cwQty, InventMovSubType::None, _skipInventTransSumUp);

        if (_updateTransDimBeforeUpdate)
        {
            // Update receipt transactions
            WHSInvent::updateReceiptWorkTransactionDimensions(_workInventTrans, _inventDimIdTo, _qty, _cwQty);

            // It's possible that the inventDimTo stored in the workInventTrans is different from the desired _inventDimTo.
            // In this case, update the workInventTrans with a correct inventDimTo.
            inventDimTo     = InventDim::find(_inventDimIdTo);
            oldInventDimTo  = InventDim::find(_workInventTrans.InventDimIdTo);
            movementTo      = InventMovement::construct(_workInventTrans, InventMovSubType::TransferReceipt);
            if (oldInventDimTo.wmsLocationId    != inventDimTo.wmsLocationId)
            {
                if ((movementTo.pdsCWItem()
                &&  movementTo.pdsCWRemainPhysical() == _cwQty)
                ||  (!movementTo.pdsCWItem()
                &&  movementTo.remainPhysical() == _qty))
                {
                    oldInventDimTo.wmsLocationId = inventDimTo.wmsLocationId;

                    _workInventTrans.InventDimIdTo = InventDim::findOrCreate(oldInventDimTo).InventDimId;
                    _workInventTrans.doUpdate();
                }
            }
        }

        // We can skip verfication of multi-status on a single LP if license plate, inventory status and product+tracking dimensions are the same.
        // In that case we have already done a check already by WHSInvent::updateFinanciallyLite call above (for an opposite inventory transaction).
        using (WHSInventMoveWorkQtyContext context = WHSInventMoveWorkQtyContext::constructWithSkipCheckMultiStatusLP(WHSInvent::canSkipCheckMultiStatusLP(inventDimFrom, inventDimTo)))
        {
            WHSInvent::updateFinanciallyLite(_workInventTrans, inventDimTo, _qty, _cwQty, InventMovSubType::TransferReceipt, _skipInventTransSumUp, _locationMixingConstraintCheckSkip);
        }

        // After work transactions have been executed we should check the issue dimension set and make sure weight is within minimum threshold.
        WHSTransWeight adjustedWeight = PDSCatchWeightOnHandAdjustment::adjustOnhandWeightWithinThresholds(_workInventTrans.ItemId, inventDimFrom.inventDimId);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipCheckMultiStatusLP</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean canSkipCheckMultiStatusLP(InventDim _inventDimFrom, InventDim _inventDimTo)
    {
        return _inventDimFrom.LicensePlateId == _inventDimTo.LicensePlateId
            && _inventDimFrom.InventStatusId == _inventDimTo.InventStatusId
            && InventDim::isInventDimEqual(_inventDimFrom, _inventDimTo, InventDim::dimProductDimFieldList())
            && InventDim::isInventDimEqual(_inventDimFrom, _inventDimTo, InventDim::dimTrackingDimFieldList());
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeWorkQtyFromLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove goods from Location based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work invent transaction; optional.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>InventUpd_Financial</c> class that was used when work quantity was moved.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static InventUpd_Financial removeWorkQtyFromLocation(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventQty               _qty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        WHSInventMov_Work       _workMovement = null)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workInventTrans.ItemId);

        return WhsInvent::removeWorkTransactionQuantitiesFromLocation(_workInventTrans, _inventDimIdFrom, _qty, 0, _inventCostOnhandCache, _ledgerVoucher, _workMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeWorkQuantitiesFromLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove goods from Location based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    /// <param name="_inventCostOnhandCache">
    /// An instance of the onhand cache to avoid excessive reads.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An existing ledger voucher that financial data should be added to.
    /// </param>
    /// <param name="_workMovement">
    /// A work movement created for the work inventory transaction. 
    /// If null then work movement from the work transaction will be used. 
    /// </param>
    /// <returns>
    /// Returns an instance of <c>InventUpd_Financial</c> class that was used when work quantity was moved.
    /// </returns>
    [Hookable(false)]
    internal static InventUpd_Financial removeWorkQuantitiesFromLocation(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventQty               _qty,
        PdsCWInventQty          _cwQty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        WHSInventMov_Work       _workMovement)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _workInventTrans.ItemId, _cwQty))
        {
            return WhsInvent::removeWorkQtyFromLocation(_workInventTrans, _inventDimIdFrom, _qty, _inventCostOnhandCache, _ledgerVoucher, _workMovement);
        }

        return WhsInvent::removeWorkTransactionQuantitiesFromLocation(_workInventTrans, _inventDimIdFrom, _qty, _cwQty, _inventCostOnhandCache, _ledgerVoucher, _workMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeWorkTransactionQuantitiesFromLocation</Name>
				<Source><![CDATA[
    private static InventUpd_Financial removeWorkTransactionQuantitiesFromLocation(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventQty               _qty,
        PdsCWInventQty          _cwQty,
        InventCostOnhandCache   _inventCostOnhandCache,
        LedgerVoucher           _ledgerVoucher,
        WHSInventMov_Work       _workMovement)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _workInventTrans.ItemId, _cwQty, _qty);
        
        InventUpd_Financial     inventUpdFrom;
        InventMovement          movementFrom;
        InventDim               inventDimFrom;
        InventDimParm           inventDimParm;
        WHSInventMov_Work       workMovement;

        // Remove From Location
        inventDimFrom = InventDim::find(_inventDimIdFrom);
        inventDimParm.initFromInventDim(inventDimFrom);
        movementFrom = InventMovement::construct(_workInventTrans);

        workMovement = _workMovement != null                                           ?
                       _workMovement                                                   :
                       InventMovement::construct(_workInventTrans) as WHSInventMov_Work;

        if (workMovement.canUseLiteProcess())
        {
            inventUpdFrom = WHSInvent::updateFinanciallyLite(_workInventTrans, inventDimFrom, -_qty, -_cwQty);
        }
        else
        {
            inventUpdFrom = InventUpd_Financial::newFromWorkMovement(movementFrom, _ledgerVoucher, 0, -_qty, -_cwQty, _inventCostOnhandCache);
            inventUpdFrom.parmInventDim(inventDimFrom);
            inventUpdFrom.parmInventDimParm(inventDimParm);
            inventUpdFrom.updateNow();
        }

        return inventUpdFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimensionsOnIssueTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update dimensions before removing goods from Location based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Extenders should move their logic to wrap the updateIssueWorkTransactionDimensionsForQuantities method.', false, 30\9\2019)]
    public static void updateDimensionsOnIssueTrans(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventQty               _qty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workInventTrans.ItemId);

        WhsInvent::updateIssueWorkTransactionDimensionsForQuantities(_workInventTrans, _inventDimIdFrom, _qty, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIssueWorkTransactionDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update dimensions before removing goods from Location based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    [Hookable(false)]
    internal static void updateIssueWorkTransactionDimensions(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventQty               _qty,
        PDSCWInventQty          _cwQty)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _workInventTrans.ItemId, _cwQty))
        {
            WhsInvent::updateDimensionsOnIssueTrans(_workInventTrans, _inventDimIdFrom, _qty);
        }
        else
        {
            WhsInvent::updateIssueWorkTransactionDimensionsForQuantities(_workInventTrans, _inventDimIdFrom, _qty, _cwQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIssueWorkTransactionDimensionsForQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update dimensions before removing goods from Location based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdFrom">
    /// The dimension to move from.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the updateIssueWorkTransactionDimensions method.
    /// </remarks>
    [Wrappable(true)]
    protected static void updateIssueWorkTransactionDimensionsForQuantities(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdFrom,
        InventQty               _qty,
        PDSCWInventQty          _cwQty)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _workInventTrans.ItemId, _cwQty, _qty);
        
        InventMovement          movementFrom;
        InventDim               inventDimFrom;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;

        InventQty               qtyLeft     = _qty;
        PdsCWInventQty          cwQtyLeft   = _cwQty;
    
        inventDimFrom = InventDim::find(_inventDimIdFrom);
        movementFrom = InventMovement::construct(_workInventTrans);

        while select forupdate inventTrans
            join  inventTransOrigin
            where inventTrans.InventTransOrigin     == inventTransOrigin.RecId              &&
                    inventTransOrigin.InventTransId == _workInventTrans.InventTransIdFrom   &&
                    inventTrans.InventDimId         == _workInventTrans.InventDimIdFrom     &&
                    inventTrans.StatusIssue         == StatusIssue::ReservPhysical
        {
            WHSInvent::updateWorkTransactionDimensionsBeforeMove(inventTrans, inventDimFrom, movementFrom, -qtyLeft, -cwQtyLeft);
            
            qtyLeft     += inventTrans.Qty;
            cwQtyLeft   += inventTrans.PdsCWQty;

            if (qtyLeft == 0 && cwQtyLeft   == 0)
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimensionsOnReceiptTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates dimensions before adding goods to the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Extenders should move their logic to wrap the updateReceiptWorkTransactionDimensionsForQuantities method.', false, 30\9\2019)]
    public static void updateDimensionsOnReceiptTrans(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdTo,
        InventQty               _qty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _workInventTrans.ItemId);
        
        WhsInvent::updateReceiptWorkTransactionDimensionsForQuantities(_workInventTrans, _inventDimIdTo, _qty, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReceiptWorkTransactionDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates dimensions before adding goods to the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    [Hookable(false)]
    internal static void updateReceiptWorkTransactionDimensions(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        PDSCWInventQty          _cwQty)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _workInventTrans.ItemId, _cwQty))
        {
            WhsInvent::updateDimensionsOnReceiptTrans(_workInventTrans, _inventDimIdTo, _qty);
        }
        else
        {
            WhsInvent::updateReceiptWorkTransactionDimensionsForQuantities(_workInventTrans, _inventDimIdTo, _qty, _cwQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReceiptWorkTransactionDimensionsForQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates dimensions before adding goods to the inventory based on a work transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The work transaction containing the move details.
    /// </param>
    /// <param name="_inventDimIdTo">
    /// The dimension to move to.
    /// </param>
    /// <param name="_qty">
    /// The quantity to move.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to move.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the updateReceiptWorkTransactionDimensions method.
    /// </remarks>
    [Wrappable(true)]
    protected static void updateReceiptWorkTransactionDimensionsForQuantities(
        WHSWorkInventTrans      _workInventTrans,
        InventDimId             _inventDimIdTo,
        InventQty               _qty,
        PDSCWInventQty          _cwQty)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _workInventTrans.ItemId, _cwQty, _qty);
        
        InventMovement          movementTo;
        InventDim               inventDimTo;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        InventQty               qtyLeft     = _qty;
        PdsCWInventQty          cwQtyLeft   = _cwQty;
    
        InventQty		registerQty;
        PdsCWInventQty	registerCWQty;

        inventDimTo = InventDim::find(_inventDimIdTo);
        movementTo = InventMovement::construct(_workInventTrans, InventMovSubType::TransferReceipt);

        while select forupdate inventTrans
            join  inventTransOrigin
            where inventTrans.InventTransOrigin     == inventTransOrigin.RecId          &&
                    inventTransOrigin.InventTransId == _workInventTrans.InventTransIdTo &&
                    inventTrans.InventDimId         == _workInventTrans.InventDimIdTo   &&
                    inventTrans.StatusReceipt       == StatusReceipt::Ordered
        {
            registerQty	  = min(qtyLeft, inventTrans.Qty);
            registerCWQty = min(cwQtyLeft, inventTrans.PdsCWQty);

            WHSInvent::updateWorkTransactionDimensionsBeforeMove(inventTrans, inventDimTo, movementTo, registerQty, registerCWQty);

            qtyLeft -= registerQty;
            cwQtyLeft -= registerCWQty;            

            if (qtyLeft == 0 && cwQtyLeft == 0)
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinanciallyLite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes a lite financial update on the specified work invent transaction.
    /// </summary>
    /// <param name="_workInventTrans">
    /// <c>WHSWorkInventTrans</c> record to update.
    /// </param>
    /// <param name="_inventDim">
    /// <c>InventDim</c> to use for update.
    /// </param>
    /// <param name="_qty">
    /// Inventory quantity to update.
    /// </param>
    /// <param name="_cwQty">
    /// Catch weight quantity to update.
    /// </param>
    /// <param name="_inventMovSubType">
    /// Movement subtype; optional.
    /// </param>
    /// <param name="_skipInventTransSumUp">
    /// A Boolean used to determine if inventory transactions should be updated; optional.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>InventUpd_FinancialLite</c> class that was used when work quantity was moved.
    /// </returns>
    /// <param name="_locationMixingConstraintCheckSkip">
    /// The <c>WHSLocationMixingConstraintCheckSkip</c> object determines if skip the location mixing constraint check.
    /// </param>
    private static InventUpd_Financial updateFinanciallyLite(
        WHSWorkInventTrans  _workInventTrans,
        InventDim           _inventDim,
        InventQty           _qty,
        PdsCWInventQty      _cwQty,
        InventMovSubType    _inventMovSubType = InventMovSubType::None,
        boolean             _skipInventTransSumUp = false,
        WHSLocationMixingConstraintCheckSkip _locationMixingConstraintCheckSkip = null)
    {
        WHSInventMov_Work       workMovement;
        InventUpd_FinancialLite financial;

        workMovement = InventMovement::construct(_workInventTrans, _inventMovSubType) as WHSInventMov_Work;

        financial = InventUpd_FinancialLite::newFromWorkMovement(workMovement, _qty, _cwQty);
        financial.parmInventDim(_inventDim);
        financial.parmInventDimParm(_inventDim.toDimParm());
        financial.parmSkipInventTransSumUp(_skipInventTransSumUp);
        financial.parmWhsLocationMixingConstraintCheckSkip(_locationMixingConstraintCheckSkip);

        financial.updateNow();

        return financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCatchWeightReserveQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default catch weight quantity to reserve.
    /// </summary>
    /// <param name = "_itemId">Item to find default reserve quantity.</param>
    /// <param name = "_handlingQty">Quantity used to find minimum catch weight quantity.</param>
    /// <returns>The minimum handling weight for the item if designated as a catch weight item; otherwise, zero.</returns>
    [Hookable(false)]
    internal static WHSHandlingWeight defaultCatchWeightReserveQuantity(ItemId _itemId, InventHandlingQty _handlingQty)
    {
        return PdsGlobal::pdsIsCWItem(_itemId) ? PdsCatchWeight::minInventQty(_itemId, _handlingQty) : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOpenMarkedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity that is marked and has not been satisfied for the inventTrans and inventDim criteria.
    /// </summary>
    /// <param name="_inventTransId">
    /// The invent transaction ID.
    /// </param>
    /// <param name="_inventDimId">
    /// An inventDimId used to filter the transactions.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The inventTransOriginId that the transactions are marked against if we only want to calculate qty for a specific marking.
    /// </param>
    /// <returns>
    /// The quantity that is marked and has not been satisfied.
    /// </returns>
    [Hookable(false)]
    internal final static InventQtyMarked calculateOpenMarkedQuantity(
        InventTransId               _inventTransId,
        InventDimId                 _inventDimId,
        InventTransOriginIdMarked   _markingRefInventTransOrigin = 0)
    {
        InventTransOriginId inventTransOriginId = InventTransOrigin::findByInventTransId(_inventTransId).RecId;
        InventTrans         inventTrans;
        InventQtyMarked     qtyMark;
    
        while select sum(Qty), sum(QtySettled) from inventTrans
            group by MarkingRefInventTransOrigin
            where inventTrans.InventTransOrigin == inventTransOriginId
            &&    inventTrans.inventDimId       == _inventDimId
            &&    (inventTrans.StatusReceipt    == StatusReceipt::Ordered 
                || inventTrans.StatusIssue      >= StatusIssue::ReservOrdered)
            &&    ((inventTrans.MarkingRefInventTransOrigin 
                &&  inventTrans.MarkingRefInventTransOrigin != inventTransOriginId) 
                || _markingRefInventTransOrigin)
            &&    (inventTrans.MarkingRefInventTransOrigin  == _markingRefInventTransOrigin 
                || !_markingRefInventTransOrigin)
            &&    inventTrans.PackingSlipReturned           == NoYes::No
        {
            if (inventTrans.Qty < 0)
            {
                qtyMark -= -inventTrans.openQty();
            }
            else
            {
                qtyMark += inventTrans.openQty();
            }
        }
    
        return qtyMark; // sign as _inventTransId
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSerialNumberOptional</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if serial number is optional for the item.
    /// </summary>
    /// <param name = "_itemId">Item ID to check.</param>
    /// <returns>true if serial is optional; otherwise, false.</returns>
    [Hookable(false)]
    internal static boolean isSerialNumberOptional(ItemId _itemId)
    {
        InventTable  inventTable = InventTable::find(_itemId);
        EcoResTrackingDimensionGroupFldSetup trackingDimGroupFieldSetup = EcoResTrackingDimensionGroupFldSetup::findByDimensionGroupFieldId(inventTable.trackingDimensionGroup(), fieldNum(InventDim, InventSerialId));
             
        return inventTable.isItemSerialNumberActivated()
            && trackingDimGroupFieldSetup.IsAllowBlankIssueEnabled
            && trackingDimGroupFieldSetup.IsAllowBlankReceiptEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipDefaultItemStatus</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean skipDefaultItemStatus(
        ModuleInventCustVend    _moduleType,
        boolean                 _salesOrTransfer)
    {
        return _salesOrTransfer && _moduleType == ModuleInventCustVend::Invent &&
            WHSParameters::find().SkipDefaultItemStatus == WHSSkipDefaultItemStatus::TransferOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNegativePhysicalInventoryAllowed</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean isNegativePhysicalInventoryAllowed(ItemId _itemId, WMSLocationId _locationId, InventLocationId _warehouseId)
    {
        return WMSLocation::find(_locationId, _warehouseId).whsLocationProfile().AllowNegative
                && (InventLocation::find(_warehouseId).RetailInventNegPhysical == NoYes::Yes
                    || InventTable::find(_itemId).whsAllowPhysNeg());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>