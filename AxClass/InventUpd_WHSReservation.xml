<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpd_WHSReservation</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventUpd_WHSReservation</c> class is used for reservation of items that are enabled for warehouse management processes.
/// </summary>
public class InventUpd_WHSReservation extends InventUpd_Reservation
{
    protected List                              reservationHierarchyLevelStrategyList;
    protected WHSInventReserveQueryBuilder      whsInventReserveQueryBuilderSpecified;
    protected WHSInventReserveDeltaQueryBuilder whsInventReserveDeltaQueryBuilderSpecified;
    private WHSReservationHierarchyLevel        batchLevel;
    private List                                reservationHierarchyAllDimensionsList;
    private InventBatchConsumptionValidator     inventBatchConsumptionValidator;
    private CustAccount                         batchValidationCustId;
    private date                                batchValidationDate;  
    private boolean                             batchValidationSetupDone;
    private boolean                             throwOnPartialReserve;

    protected boolean                           noExactMatch;
    protected InventTrans                       inventTrans;
    protected InventTransOrigin                 inventTransOrigin;
    protected InventQty                         catchWeightQtyLeftToReserve;
    protected InventQty                         maxOrderedReserved;
    protected InventQty                         qtyLeftToReserve;
    protected InventQty                         maxPhysicalReserved;
    protected InventDim                         inventDimInventoryCriteria;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmThrowOnPartialReserve</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmThrowOnPartialReserve(boolean _throwOnPartialReserve = throwOnPartialReserve)
    {
        throwOnPartialReserve = _throwOnPartialReserve;
        return throwOnPartialReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipOnHandCheck</Name>
				<Source><![CDATA[
    private boolean skipOnHandCheck()
    {
        return (this.reservationParameters && this.reservationParameters.SkipOnHandCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchConsumptionValidateAll</Name>
				<Source><![CDATA[
    private boolean batchConsumptionValidateAll(InventDim _inventDimOnHandCriteria)
    {
        if (!batchValidationSetupDone)
        {
            batchValidationCustId = movement.custVendAc();

            if (movement.needsShelfLifeCheck())
            {
                batchValidationDate = movement.getExpiryCheckDate();
            }

            if (batchValidationDate == dateNull())
            {
                batchValidationDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            }

            batchValidationSetupDone = true;
        }
        
        return this.inventBatchConsumptionValidator().validateAll(_inventDimOnHandCriteria.InventBatchId, movement, _inventDimOnHandCriteria, batchValidationCustId, batchValidationDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchConsumptionValidator</Name>
				<Source><![CDATA[
    private InventBatchConsumptionValidator inventBatchConsumptionValidator()
    {
        if (!inventBatchConsumptionValidator)
        {
            inventBatchConsumptionValidator = InventBatchConsumptionValidator::newFromInventTable(movement.inventTable());
        }

        return inventBatchConsumptionValidator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(InventMovement _inventMovement)
    {
        if (!_inventMovement.isItemWHSEnabled())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        super(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueInventTransUpdateReserveMoveLoop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the loop for updating transactions to reserved based on found on-hand should continue.        
    /// </summary>
    /// <param name = "_qtyLeftToReserve">The quantity that remains to be reserved.</param>
    /// <param name = "_maxPhysicalReserved">The maximum physical quantity that can be reserved.</param>
    /// <param name = "_maxOrderedReserved">The maximum ordered quantity that can be reserved.</param>
    /// <param name = "_reservationHierarchyLevelStrategy">The reservationHierarchyLevelStrategy that is used for the reservation.</param>
    /// <returns>true if the loop should continue; otherwise, false.</returns>
    protected boolean continueInventTransUpdateReserveMoveLoop(
        InventHandlingQty                       _qtyLeftToReserve,
        InventHandlingQty                       _maxPhysicalReserved,
        InventHandlingQty                       _maxOrderedReserved,
        WHSReservationHierarchyLevelStrategy    _reservationHierarchyLevelStrategy)
    {
        boolean continueInventTransUpdateReserveMoveLoop = false;

        if (_qtyLeftToReserve
            && ((_maxPhysicalReserved < 0 && !_reservationHierarchyLevelStrategy.onlyReserveOrderedAvailable())
            || (_maxOrderedReserved  < 0 && allowReserveOrdered && !_reservationHierarchyLevelStrategy.onlyReservePhysicalAvailable())))
        {
            continueInventTransUpdateReserveMoveLoop = true;
        }
       
        return continueInventTransUpdateReserveMoveLoop;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectInventTransForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects the inventtrans that should be updated.
    /// </summary>
    protected void selectInventTransForUpdate()
    {
        InventDim inventDim;
        
        inventTrans = null;
        
        if (inventDimCriteria.InventDimId)
        {
            if (!noExactMatch)
            {
                select firstonly forupdate inventTrans
                    join inventTransOrigin
                        where inventTrans.InventTransOrigin         == inventTransOrigin.RecId
                        &&        inventTransOrigin.InventTransId   == movement.transId()
                        &&        inventTrans.TransChildType        == movement.transChildType()
                        &&        inventTrans.TransChildRefId       == movement.transChildRefId()
                        &&        inventTrans.StatusReceipt         == StatusReceipt::None
                        &&        inventTrans.StatusIssue           == StatusIssue::OnOrder
                        &&        inventTrans.InventDimId           == inventDimCriteria.InventDimId;
            }

            if (!inventTrans.RecId)
            {
                noExactMatch = true;
                select firstonly forupdate inventTrans
                    join inventTransOrigin
                        where inventTrans.InventTransOrigin         == inventTransOrigin.RecId
                        &&        inventTransOrigin.InventTransId   == movement.transId()
                        &&        inventTrans.TransChildType        == movement.transChildType()
                        &&        inventTrans.TransChildRefId       == movement.transChildRefId()
                        &&        inventTrans.StatusReceipt         == StatusReceipt::None
                        &&        inventTrans.StatusIssue           == StatusIssue::OnOrder
                     #InventDimExistsJoin(inventTrans.inventDimId, inventDim, inventDimCriteria, inventDimParm);
            }
        }
        else
        {
            select firstonly forupdate inventTrans
                join inventTransOrigin
                    where inventTrans.InventTransOrigin         == inventTransOrigin.RecId
                    &&        inventTransOrigin.InventTransId   == movement.transId()
                    &&        inventTrans.TransChildType        == movement.transChildType()
                    &&        inventTrans.TransChildRefId       == movement.transChildRefId()
                    &&        inventTrans.StatusReceipt         == StatusReceipt::None
                    &&        inventTrans.StatusIssue           == StatusIssue::OnOrder;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSplitInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory transaction can be split.
    /// </summary>
    /// <param name = "_maxQtyForReservation">The maximum quantity that can be reserved.</param>
    /// <returns>true if the inventory transaction can be split; otherwise, false.</returns>
    protected boolean canSplitInventTrans(InventQty _maxQtyForReservation)
    {
        return _maxQtyForReservation > inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransAndAdjustVariables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventtrans in scope and adjust quantity variables.
    /// </summary>
    /// <param name = "_statusIssue">The status issue.</param>
    /// <param name = "_inventDim">The inventory dimension for the transaction to update.</param>
    /// <param name = "_maxQtyForReservation">The maximum quantity that can be reserved.</param>
    /// <param name = "_reserveCatchWeightOnly">Determines if only catch weights should be reserved.</param>
    protected void updateInventTransAndAdjustVariables(
            StatusIssue _statusIssue,
            InventDim   _inventDim,
            InventQty   _maxQtyForReservation,
            boolean     _reserveCatchWeightOnly
        )
    {
        InventQty   maxWeightCanReserve;
        InventQty   inventQtyAdjustment;

        //if consumers of the API provided an inventDimCriteria without inventDimId we need to ensure the one used for transaction update has a inventDimId.
        InventDim inventDimTransUpdate = (_inventDim.inventDimId ? _inventDim : InventDim::findOrCreate(_inventDim));
            
        if (movement.pdsCWItem())
        {
            if (!_reserveCatchWeightOnly
                && !cwForceActual
                // Force to use actual CW qty to reserve when validating quality order
                && !InventBlockingRelatedTransactionInfoSingleton::instance().isValidatingQualityOrder())
            {
                // By default the system will reserve items at the min weight.
                maxWeightCanReserve = WhsInvent::defaultCatchWeightReserveQuantity(movement.itemId(), _maxQtyForReservation);
            }
            else
            {
                maxWeightCanReserve = catchWeightQtyLeftToReserve;
            }
        }

        // Split if unable to reserve the full amount physically
        if (!movement.pdsCWItem())
        {
            if (this.canSplitInventTrans(_maxQtyForReservation))
            {
                inventTrans.updateSplit(_maxQtyForReservation);
            }
        }
        else
        {
            if (_maxQtyForReservation   > inventTrans.PdsCWQty
                    ||  maxWeightCanReserve > inventTrans.Qty)
            {
                InventQty qtyForReservation = _reserveCatchWeightOnly ? 0 : _maxQtyForReservation;

                inventQtyAdjustment = this.pdsCalculateInventoryQuantityAdjustment(
                                                            movement.itemId(),
                                                            inventTrans.PdsCWQty,
                                                            inventTrans.Qty,
                                                            qtyForReservation,
                                                            maxWeightCanReserve);

                // In case the caller to this method expects to split the inventTrans with the exact weight (cwForceActual = true) and the calculations ends up with the quantity and weight
                // which falls outside the acceptable min/max range or illegal split, we ensure that the transaction is split with an acceptance weight. In most of these cases system will
                // end up throwing an valid error message saying the Qty/weight is unable to on hand.
                if (maxWeightCanReserve == inventTrans.Qty
                        || (qtyForReservation && !PdsCatchWeight::validateInventQty(inventTrans.ItemId, maxWeightCanReserve, qtyForReservation, false)))
                {
                    inventTrans.updateSplit(
                                        max(maxWeightCanReserve, inventTrans.Qty - PdsCatchWeight::minInventQty(
                                            inventTrans.ItemId,
                                            inventTrans.PdsCWQty - qtyForReservation)),
                                        qtyForReservation);
                }
                else
                {
                    inventTrans.updateSplit(maxWeightCanReserve, qtyForReservation);
                }
            }
        }
            
        movement.transIdSum().setInventTransStatus(inventTrans, StatusReceipt::None, _statusIssue);

        if (inventDimTransUpdate.InventBatchId)
        {
            inventDimInventoryCriteria = this.updateBatchCriteriaSameBatch(inventDimTransUpdate.InventBatchId);
        }

        InventDimId inventDimIdOrigTrans = inventTrans.inventDimId;
            
        inventTrans.InventDimFixed  = inventDimFixed;
        inventTrans.InventDimId     = inventDimTransUpdate.InventDimId;
        //make sure to sync receipt transactions if this is a transfer issue
        InventUpdate::updateTransDimTransferReceipt(movement, inventTrans, inventDimTransUpdate);
        inventTrans.update();

        // Remove amount reserved from reserved buckets and quantity
        if (!movement.pdsCWItem())
        {
            maxOrderedReserved      -= inventTrans.Qty;
            qtyLeftToReserve        -= inventTrans.Qty;

            if (_statusIssue == StatusIssue::ReservPhysical)
            {
                maxPhysicalReserved     -= inventTrans.Qty;
            }
        }
        else
        {
            maxOrderedReserved      -= inventTrans.PdsCWQty;
            qtyLeftToReserve        -= inventTrans.PdsCWQty;

            if (_statusIssue == StatusIssue::ReservPhysical)
            {
                maxPhysicalReserved     -= inventTrans.PdsCWQty;
            }

            catchWeightQtyLeftToReserve -= inventTrans.Qty;
            catchWeightQtyLeftToReserve += inventQtyAdjustment;
            catchWeightQtyLeftToReserve = min(0, catchWeightQtyLeftToReserve);
        }

        inventTrans.updateSumUp();

        // Scenarios where the buffer is not inserted are not supported in general so inventory updates are expected to handle adjustments.
        if (movement.pdsCWItem() && movement.buffer().RecId)
        {
            // Adjust the movement's quantity
            this.pdsAdjustInventoryQuantity(inventQtyAdjustment, inventDimIdOrigTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReservePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if reserve physical is possible.
    /// </summary>
    /// <param name = "_whsReservationHierarchyLevelStrategy">The reservation strategy.</param>
    /// <returns>true if reserve physical is possible; otherwise, false.</returns>
    protected boolean canReservePhysical(WHSReservationHierarchyLevelStrategy _whsReservationHierarchyLevelStrategy)
    {
        return maxPhysicalReserved < 0 && !_whsReservationHierarchyLevelStrategy.onlyReserveOrderedAvailable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReserveOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if reserve ordered is possible.
    /// </summary>
    /// <param name = "_whsReservationHierarchyLevelStrategy">The reservation strategy.</param>
    /// <returns>true if reserve ordered is possible; otherwise, false.</returns>
    protected boolean canReserveOrdered(WHSReservationHierarchyLevelStrategy _whsReservationHierarchyLevelStrategy)
    {
        return maxOrderedReserved < 0 && allowReserveOrdered && !_whsReservationHierarchyLevelStrategy.onlyReservePhysicalAvailable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveMore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves inventory for warehouse management enabled items.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Not enough inventory to reserve quantity.
    /// </exception>    
    protected void updateReserveMore()
    {
        boolean             mustIncludeReserveDelta;
        boolean             batchLevelStrategyHasRan;
        boolean             shouldShowOrderCommittedLocWarning;
        WHSReservationHierarchyLevelStrategy    whsReservationHierarchyLevelStrategy;
        InventDim                               inventDimOnHandCriteria;
        WHSInventOnHandData                     whsInventOnHandData;

        WHSInstrumentationLogger instrumentationLogger = WHSInstrumentationLogger::createDisabledByDefaultLogger(classId2Name(classIdGet(this)), WHSInstrumentationWHSReservationToggle::instance());
        WHSReservationInstrumentationActivities instrumentationActivities = instrumentationLogger.reservationActivities();

        boolean isOrderCommitedReservationCouldNotBeReCreated = WHSOrderCommitedReservationCouldNotBeReCreatedFlight::instance().isEnabled();
        boolean isUnShipQtyOrderCommitedReservationCommitBalanceContextExist = WHSUnShipQtyOrderCommitedReservationCommitBalanceContext::isActive();

        using (var activityContext = instrumentationActivities.updateReserveMore())
        {
            inventTrans.clear();
            inventTransOrigin.clear();
            inventDimInventoryCriteria.clear();

            maxOrderedReserved = 0;
            qtyLeftToReserve = 0;
            maxPhysicalReserved = 0;

            noExactMatch = false;

            using (var cache = movement.constructRecordViewCache())
            {
                if (!movement.pdsCWItem())
                {
                    qtyLeftToReserve = reservation;
                    catchWeightQtyLeftToReserve = 0;
                }
                else
                {
                    qtyLeftToReserve = cwReservation;
                    catchWeightQtyLeftToReserve = reservation;
                }

                boolean firstInventTransUpdateAttempt = true;
                reservationFailed = false;
                this.selectInventTransForUpdate();

                if (inventTrans.RecId != 0)
                {
                    CreatedTransactionId ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
                    boolean transTypeOnlyAffectsLocationAndBelow = WHSInvent::transTypeOnlyAffectsLocationAndBelow(inventTransOrigin.ReferenceCategory);

                    // If inventory dimension criteria has been set for reserving to, use that instead of inventory dimension criteria used to match transaction records
                    List reservationStrategyList = this.reservationStrategyList(this.determineInventDimOnHandCriteria());
                    ListEnumerator reservationStrategyListEnumerator = reservationStrategyList.getEnumerator();

                    instrumentationActivities.logReservationStrategyList(
                        reservationStrategyList,
                        movement);
                
                    int reservationStrategyLoopIndex;

                    boolean findOrCreateInventDimIfNegativePhysicalAllowed = WHSInventUpdateReserveMoreNegativePhysicalFindOrCreateInventDimFlight::instance().isEnabled();

                    //loop over the list of strategies
                    while (qtyLeftToReserve < 0
                        && reservationStrategyListEnumerator.moveNext())
                    {
                        boolean continueOnHandLoop = true;
                        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = null;
                        whsReservationHierarchyLevelStrategy = reservationStrategyListEnumerator.current();
                        boolean strategyMustDetermineMissingDimensions = whsReservationHierarchyLevelStrategy.mustDetermineMissingDimensions();
                        //if the strategy determines that there is no need to specify dimensions further we should just use the direct reservation on dimensions passed in
                        if (strategyMustDetermineMissingDimensions)
                        {
                            //this needs to be set here since earlier iterations may have created deltas
                            mustIncludeReserveDelta   = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().mustAddInventSumDeltaOnhand(movement.itemId());
                            // Same batch reservation functionality should update the inventDim criteria if any batch has already been set on a transaction of the movement.
                            inventDimInventoryCriteria = this.updateBatchCriteriaSameBatch();
                            InventDimParm inventDimParmCriteria;
                            inventDimParmCriteria.initFromInventDim(inventDimInventoryCriteria);
                            whsInventOnHandCollectionEnumerator = this.createOnHandCollectionEnumerator(inventDimInventoryCriteria,
                                                                                                        inventDimParmCriteria,
                                                                                                        whsReservationHierarchyLevelStrategy.getReservationHierarchyLevel(),
                                                                                                        ttsId,
                                                                                                        !whsReservationHierarchyLevelStrategy.onlyReservePhysicalAvailable(),
                                                                                                        !whsReservationHierarchyLevelStrategy.onlyReserveOrderedAvailable(),
                                                                                                        mustIncludeReserveDelta);
                        }

                        //looping to determine on hand
                        while (continueOnHandLoop)
                        {
                            // If there is need to deduce some dimensions...
                            if (whsInventOnHandCollectionEnumerator)
                            {
                                // ...get the whsInventOnHandData to work on
                                if (whsInventOnHandCollectionEnumerator.moveNext())
                                {
                                    whsInventOnHandData = whsInventOnHandCollectionEnumerator.current();
                                }
                                // ...or indicate that nothing more is to be done in this loop
                                else
                                {
                                    maxPhysicalReserved = 0;
                                    maxOrderedReserved = 0;
                                    whsInventOnHandData = null;
                                    continueOnHandLoop = false;
                                }
                            }

                            if (continueOnHandLoop)
                            {
                                boolean checkReservationHierarchyHole;

                                if (whsInventOnHandData)
                                {
                                    inventDimOnHandCriteria.data(whsInventOnHandData.parmInventDim());
                                    // We rely on the fact that we can actually reserve on the on-hand dimension
                                    // so we can skip the reservation hierarchy hole check
                                    checkReservationHierarchyHole = false;
                                }
                                else
                                {
                                    // If inventory dimension criteria has been set for reserving to, use that instead of inventory dimension criteria used to match transaction records
                                    inventDimOnHandCriteria.data(this.determineInventDimOnHandCriteria());
                                    checkReservationHierarchyHole = true;
                                }

                                if (!inventDimOnHandCriteria.inventDimId)
                                {
                                    inventDimOnHandCriteria = InventDim::findOrCreate(inventDimOnHandCriteria);
                                }

                                InventUpd_WHSReservationMaxReservedParameters parm = InventUpd_WHSReservationMaxReservedParameters::construct();
                                parm.strategyMustDetermineMissingDimensions        = strategyMustDetermineMissingDimensions;
                                parm.qtyLeftToReserve                              = (movement.pdsCWItem()) ?  0  : qtyLeftToReserve;
                                parm.parmHandlingQtyLeftToReserve(qtyLeftToReserve);
                                parm.ttsId                                         = ttsId;
                                parm.transTypeOnlyAffectsLocationAndBelow          = transTypeOnlyAffectsLocationAndBelow;
                                parm.checkReservationHierarchyHole                 = checkReservationHierarchyHole;
                                parm.inventDimInventoryCriteria                    = inventDimInventoryCriteria;
                                parm.inventDimOnHandCriteria                       = inventDimOnHandCriteria;
                                parm.batchLevelStrategyHasRan                      = batchLevelStrategyHasRan;
                                parm.mustIncludeReserveDelta                       = mustIncludeReserveDelta;

                                [maxPhysicalReserved, maxOrderedReserved] = this.calculateMaxReservedValues(parm);
                            }

                            // If we allow negative then just take full quantity on the dimensions and don't look for on-hand
                            if (allowNegativePhysical)
                            {
                                //case where we used a strategy to determine on-hand but found nothing. Then we take reservation on the criteria passed in.
                                if (!inventDimOnHandCriteria.InventDimId)
                                {
                                    // If inventory dimension criteria has been set for reserving to, use that instead of inventory dimension criteria used to match transaction records
                                    if (findOrCreateInventDimIfNegativePhysicalAllowed)
                                    {
                                        inventDimOnHandCriteria = InventDim::findOrCreate(this.retrieveInventDimCriteriaForAllowNegativeReservation());
                                    }
                                    else
                                    {
                                        inventDimOnHandCriteria = InventDim::findDim(this.retrieveInventDimCriteriaForAllowNegativeReservation());
                                    }
                                }
                                // We can only bail out here if we have all the necessary dimensions specified already and batch is allowed to be reserved.
                                // Otherwise we will try the next reservation strategy
                                if (WhsReservationHierarchyInventDimUtil::checkDimHierarchyForBlanks(movement.inventTable(), inventDimOnHandCriteria, false) &&
                                    (!inventDimOnHandCriteria.InventBatchId ||
                                     this.batchConsumptionValidateAll(inventDimOnHandCriteria)))
                                {
                                    maxPhysicalReserved = qtyLeftToReserve;
                                    maxOrderedReserved  = 0;
                                    continueOnHandLoop  = false;
                                }
                            }

                            if (maxPhysicalReserved
                                &&  movement.transType() == InventTransType::WHSOrderCommittedReservation)
                            {
                                WMSLocation wmsLocation = WMSLocation::find(inventDimOnHandCriteria.wMSLocationId, inventDimOnHandCriteria.InventLocationId);

                                if (   wmsLocation.whsLocationIsUserLocation()
                                    || wmsLocation.isPackingLocation()
                                    || wmsLocation.isSortingLocation() 
                                    || wmsLocation.isStagingLocation())
                                {
                                    maxPhysicalReserved = 0;
                                    shouldShowOrderCommittedLocWarning = true;

                                    WHSInstrumentationLogger::createLogger('WHSOrderCommittedReserve').logInformation(strFmt('WHSOrderCommittedReserve. Location (RecId: %1) is skipped for the order committed reservation transaction type', wmsLocation.RecId));
                                }
                            }

                            //find the transactions to update
                            if (!firstInventTransUpdateAttempt //for the very first iteration we still have the inventtrans from the first select so to avoid an extra select we detect that situation
                                && this.continueInventTransUpdateReserveMoveLoop(qtyLeftToReserve, maxPhysicalReserved, maxOrderedReserved, whsReservationHierarchyLevelStrategy))
                            {
                                this.selectInventTransForUpdate();
                            }
                            firstInventTransUpdateAttempt = false;
                            int onhandLoopIndex;

                            while (inventTrans.RecId != 0
                                   && this.continueInventTransUpdateReserveMoveLoop(qtyLeftToReserve, maxPhysicalReserved, maxOrderedReserved, whsReservationHierarchyLevelStrategy))
                            {
                                qtyLeftToReserve = this.recalculateHandlingQtyLeftToReserve(qtyLeftToReserve, inventTrans, inventDimOnHandCriteria, maxPhysicalReserved, noExactMatch);
                                if (qtyLeftToReserve >= 0)
                                {
                                    break;
                                }

                                const boolean reserveWeightOnly = false;

                                boolean updateInventTransReservePhysical;
                                boolean updateInventTransReserveOrdered;
                                InventQty maxCanReservePhysical;
                                InventQty maxCanReserveOrdered;

                                // Physical Reservation First
                                if (this.canReservePhysical(whsReservationHierarchyLevelStrategy))
                                {
                                    maxCanReservePhysical = max(qtyLeftToReserve, maxPhysicalReserved);
                                    this.updateInventTransAndAdjustVariables(StatusIssue::ReservPhysical, inventDimOnHandCriteria, maxCanReservePhysical, reserveWeightOnly);
                                    
                                    updateInventTransReservePhysical = true;
                                }
                                else if (this.canReserveOrdered(whsReservationHierarchyLevelStrategy))
                                {
                                    maxCanReserveOrdered = max(qtyLeftToReserve, maxOrderedReserved);
                                    this.updateInventTransAndAdjustVariables(StatusIssue::ReservOrdered, inventDimOnHandCriteria, maxCanReserveOrdered, reserveWeightOnly);

                                    updateInventTransReserveOrdered = true;
                                }

                                onhandLoopIndex++;

                                instrumentationActivities.logOnHand(
                                    onhandLoopIndex,
                                    inventDimOnHandCriteria,
                                    inventTrans,
                                    updateInventTransReservePhysical,
                                    updateInventTransReserveOrdered,
                                    maxCanReservePhysical,
                                    maxCanReserveOrdered,
                                    reserveWeightOnly);

                                //no need to do another select if we are done
                                if (this.continueInventTransUpdateReserveMoveLoop(qtyLeftToReserve, maxPhysicalReserved, maxOrderedReserved, whsReservationHierarchyLevelStrategy))
                                {
                                    // Get next inventtrans
                                    this.selectInventTransForUpdate();
                                }
                            }

                            //full quantity was reserved or there are no more matching transactions
                            //or if we don't use the on-hand collection enumerator approach we should stop looping if there is no more on-hand since we select based on specific dimensions.
                            if (qtyLeftToReserve >= 0
                            ||  inventTrans.RecId == 0
                            ||  !whsInventOnHandCollectionEnumerator)
                            {
                                continueOnHandLoop = false;
                            }
                        }

                        // We must know if the batch level strategy has run because we can make certain assumptions for strategies run after this strategy.
                        if (whsReservationHierarchyLevelStrategy is WHSReservationLevelStrategyBatchLvl
                            || whsReservationHierarchyLevelStrategy is WHSReservationLevelStrategyBatchOwnerLevel)
                        {
                            batchLevelStrategyHasRan = true;
                        }

                        reservationStrategyLoopIndex++;

                        instrumentationActivities.logReservationStrategy(
                            reservationStrategyLoopIndex,
                            whsReservationHierarchyLevelStrategy,
                            inventDimInventoryCriteria,
                            inventTrans,
                            qtyLeftToReserve,
                            catchWeightQtyLeftToReserve,
                            maxOrderedReserved,
                            maxPhysicalReserved,
                            mustIncludeReserveDelta,
                            batchLevelStrategyHasRan,
                            strategyMustDetermineMissingDimensions,
                            transTypeOnlyAffectsLocationAndBelow,
                            ttsId);
                    }
                    //reservation type loop

                    if (!qtyLeftToReserve && catchWeightQtyLeftToReserve)
                    {
                        // Make sure there is a transaction to reserve against and it's not just bad weight value passed in.
                        this.selectInventTransForUpdate();
                        if (inventTrans)
                        {
                            const boolean reserveWeightOnly = true;
                            // Currently only known scenario to hit this is when picking inventory specified weight that is greater than the transaction weight.
                            // In this scenario the transaction weight is increased and reserved but no CW qty is reserved.
                            this.updateInventTransAndAdjustVariables(StatusIssue::ReservPhysical, inventDimCriteria,  inventTrans.PdsCWQty, reserveWeightOnly);
                        }
                    }
                }

                if (qtyLeftToReserve && !this.parmAllowReserveReduction())
                {
                    if (shouldShowOrderCommittedLocWarning)
                    {
                        warning(strFmt("@WAX:OrderCommittedReservationIsNotAllowedForExcludedLocations"));
                    }

                    var inventDimCriteriaPrefix = inventDimCriteria.preFix();

                    if (isOrderCommitedReservationCouldNotBeReCreated && isUnShipQtyOrderCommitedReservationCommitBalanceContextExist
                        && movement.transType() == InventTransType::WHSOrderCommittedReservation)
                    {
                        warning(strFmt("@WAX:OrderCommittedReservationCannotBeReestablishedWarning", movement.itemId(), inventDimCriteriaPrefix));
                    }
                    else
                    {
                        setPrefix("@SYS70390");
            
                        setPrefix(inventDimCriteriaPrefix);
            
                        str insufficientOnHandMessage = this.insufficientOnHandMessage();
               
                        reservationFailed = true;
                    
                        if (this.parmThrowOnInsufficientOnHand())
                        {
                            throw error(insufficientOnHandMessage);
                        }

                        if (this.parmThrowOnPartialReserve() &&
                            qtyLeftToReserve != (movement.pdsCWItem() ? cwReservation : reservation))
                        {
                            throw error(insufficientOnHandMessage);
                        }

                        warning(insufficientOnHandMessage);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insufficientOnHandMessage</Name>
				<Source><![CDATA[
    private str insufficientOnHandMessage()
    {
        str insufficientOnHandMessage;

        if (movement.pdsCWItem())
        {
            insufficientOnHandMessage = strFmt("@WAX3104", movement.itemId(), -cwReservation, -(cwReservation + abs(qtyLeftToReserve)));
        }
        else
        {
            insufficientOnHandMessage = strFmt("@WAX3104", movement.itemId(), -reservation, -(reservation + abs(qtyLeftToReserve)));
        }

        return insufficientOnHandMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveInventDimCriteriaForAllowNegativeReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory dimension criteria to be used for negative quantity reservation.
    /// </summary>
    /// <returns>An inventory dimension record.</returns>
    protected InventDim retrieveInventDimCriteriaForAllowNegativeReservation()
    {
        InventDim inventDim = this.determineInventDimOnHandCriteria();

        // For lines which owner controlled and do not have an owner we want to autopopulate it
        if (!inventDim.InventOwnerId_RU && movement.inventTable().isItemOwnerIdActivated())
        {
            inventDim.setInventoryOwner(movement.inventTable(), this.getInventoryOwnerId());
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryOwnerId</Name>
				<Source><![CDATA[
    private InventOwnerId getInventoryOwnerId()
    {
        return InventOwner_RU::findOrCreateCurrentLegalEntity().InventOwnerId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateHandlingQtyLeftToReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the handling quantity left to reserve.
    /// </summary>
    /// <param name = "_handlingQtyLeftToReserve">The handling quantity left to reserve.</param>
    /// <param name = "_inventTrans">An <c>InventTrans</c> record.</param>
    /// <param name = "_inventDimOnHandCriteria">An <c>InventDim</c> record.</param>
    /// <param name = "_maxPhysicalReserved">The maximum physical reserved quantity.</param>
    /// <param name = "_noExactMatch">A boolean value indicating if there is no exact matching <c>InventTrans</c> record.</param>
    /// <returns>The handling quantity left to reserve.</returns>
    protected InventHandlingQty recalculateHandlingQtyLeftToReserve(
        InventHandlingQty   _handlingQtyLeftToReserve,
        InventTrans         _inventTrans,
        InventDim           _inventDimOnHandCriteria,
        InventQty           _maxPhysicalReserved,
        boolean             _noExactMatch)
    {
        if (!movement.pdsCWItem())
        {
            return this.recalculateQtyLeftToReserve(_handlingQtyLeftToReserve, _inventTrans, _inventDimOnHandCriteria, _maxPhysicalReserved, _noExactMatch);
        }
        
        return _handlingQtyLeftToReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateCWQtyLeftToReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the quantity left to reserve for updating whs reserve more.
    /// </summary>
    /// <param name = "_qtyLeftToReserve">The quantity left to reserve.</param>
    /// <param name = "_inventTrans">An <c>InventTrans</c> record.</param>
    /// <param name = "_inventDimOnHandCriteria">An <c>InventDim</c> record.</param>
    /// <param name = "_maxPhysicalReserved">The maximum physical reserved quantity.</param>
    /// <param name = "_noExactMatch">A boolean value indicating if there is no exact matching <c>InventTrans</c> record.</param>
    /// <returns>The quantity left to reserve.</returns>
    protected InventQty recalculateCWQtyLeftToReserve(
        PDSCWInventQty  _qtyLeftToReserve,
        InventTrans     _inventTrans,
        InventDim       _inventDimOnHandCriteria,
        PDSCWInventQty  _maxPhysicalReserved,
        boolean         _noExactMatch)
    {
        return _qtyLeftToReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMaxReservedValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the maximum values for the physical and the ordered reservations.
    /// </summary>
    /// <param name = "_parm">An instance of the <c>InventUpd_WHSReservationMaxReservedParameters</c>.</param>
    /// <returns>The container with the maximum values for physical and ordered reservations.</returns>
    protected container calculateMaxReservedValues(InventUpd_WHSReservationMaxReservedParameters _parm)
    {
        InventQty localMaxPhysicalReserved;
        InventQty localMaxOrderedReserved;

        if (!_parm.inventDimOnHandCriteria.InventBatchId
            || this.batchConsumptionValidateAll(_parm.inventDimOnHandCriteria))
        {
            //if we did not determine any dimensions we can skip the on-hand check and rely on the final on-hand check since callers may know that the items are there.
            if (!_parm.strategyMustDetermineMissingDimensions && this.skipOnHandCheck())
            {
                localMaxPhysicalReserved = _parm.parmHandlingQtyLeftToReserve();
                localMaxOrderedReserved = localMaxPhysicalReserved;
            }
            else
            {
                //we need to take into account that others may have reservations on levels above what we are looking at which may impact the availability
                [localMaxPhysicalReserved,localMaxOrderedReserved] = whsInventOnHand::getReserveAvailHandlingQtyIncludeDelta(movement.itemId(),
                                                                                                                   _parm.inventDimOnHandCriteria,
                                                                                                                   _parm.ttsId,
                                                                                                                   _parm.transTypeOnlyAffectsLocationAndBelow,
                                                                                                                   _parm.checkReservationHierarchyHole);

                localMaxPhysicalReserved = -localMaxPhysicalReserved;
                localMaxOrderedReserved  = -localMaxOrderedReserved;
            }
            // Additional check is needed for same batch validation to make sure there is enough quantity available
            if (_parm.inventDimOnHandCriteria.InventBatchId
                && !this.inventBatchConsumptionValidator().validateSameBatchAvailHandlingQty(movement,
                                                                                             _parm.inventDimInventoryCriteria, 
                                                                                             _parm.inventDimOnHandCriteria, 
                                                                                             _parm.ttsId, 
                                                                                             _parm.transTypeOnlyAffectsLocationAndBelow, 
                                                                                             allowReserveOrdered, 
                                                                                             localMaxPhysicalReserved,
                                                                                             localMaxOrderedReserved))
            {
                localMaxPhysicalReserved = 0;
                localMaxOrderedReserved  = 0;
            }
        }
        // Batch validation failed
        else
        {
            localMaxPhysicalReserved = 0;
            localMaxOrderedReserved  = 0;
        }

        // If batch level strategy has ran then we need to subtract out availability created by ordered transaction with batch specified
        // because we already have evaluated these batches for reservation and determined they are not suitable for reservation.
        if (_parm.batchLevelStrategyHasRan
            && localMaxOrderedReserved) // If we have already set localMaxOrderedReserved to zero because the batch is invalid then we don't need to go into this step.
        {
            // Nothing can be physical reserved.
            localMaxPhysicalReserved = 0;
            // We must remove availability coming from transaction with batch specified.
            localMaxOrderedReserved += whsInventOnHand::getAvailOrderedHandlingQuantityForLevel(
                                                            movement.itemId(),
                                                            _parm.inventDimOnHandCriteria,
                                                            this.inventBatchLevel(),
                                                            _parm.mustIncludeReserveDelta);
        }

        return [localMaxPhysicalReserved, localMaxOrderedReserved];
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a new instance of the <c>InventUpd_WHSReservation</c> class.
    /// </summary>
    /// <param name = "_movement">The movement that the class should be constructed with.</param>
    /// <returns>A new instance of the <c>InventUpd_WHSReservation</c> class.</returns>
    public static InventUpd_WHSReservation construct(
        InventMovement _movement)
    {
        return new InventUpd_WHSReservation(_movement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservationHierarchyAllDimensionsList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list containing all inventory dimensions in the current item's reservation hierarchy.
    /// </summary>
    /// <returns>
    /// A <c>List</c> containing the inventory dimensions in the hierarchy.
    /// </returns>
    private List reservationHierarchyAllDimensionsList()
    {
        if (reservationHierarchyAllDimensionsList == null)
        {
            reservationHierarchyAllDimensionsList = WHSReservationHierarchyProvider::construct().getDimListAllFromInventTable(movement.inventTable(), WHSReservationHierarchySortOrder::BottomUp);
        }

        return reservationHierarchyAllDimensionsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservationStrategyList</Name>
				<Source><![CDATA[
    private List reservationStrategyList(InventDim _inventDimCriteria)
    {
        return (reservationHierarchyLevelStrategyList ? reservationHierarchyLevelStrategyList : movement.reservationHierarchyLevelStrategyList(_inventDimCriteria));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newOnHandEnumeratorFromInventReserveAndDeltaQueryBuilders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an on-hand enumerator based on the query builders.
    /// </summary>
    /// <param name = "_inventReserveQueryBuilder">The query builder for <c>WHSInventReserve</c> sums.</param>
    /// <param name = "_inventReserveDeltaQueryBuilder">The query builder for <c>WHSInventReserveDelta</c> sums.</param>
    /// <returns>An on-hand enumerator based on the query builders.</returns>
    private WHSInventOnHandCollectionEnumerator newOnHandEnumeratorFromInventReserveAndDeltaQueryBuilders(
        WHSInventReserveQueryBuilder        _inventReserveQueryBuilder,
        WHSInventReserveDeltaQueryBuilder   _inventReserveDeltaQueryBuilder)
    {
        return WHSInvReserveAndDeltaQueryCollection::newFromQueries(_inventReserveQueryBuilder.buildOnHandQuery(),
                                                                    _inventReserveQueryBuilder.sumTableId(),
                                                                    _inventReserveDeltaQueryBuilder.buildOnHandQuery(),
                                                                    _inventReserveDeltaQueryBuilder.sumTableId()).getEnumerator() as WHSInventOnHandCollectionEnumerator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newOnHandEnumeratorFromInventReserveQueryBuilder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an on-hand enumerator based on the query builder.
    /// </summary>
    /// <param name = "_inventReserveQueryBuilder">The query builder for <c>WHSInventReserve</c> sums.</param>
    /// <returns>An on-hand enumerator based on the query builders</returns>
    private WHSInventOnHandCollectionEnumerator newOnHandEnumeratorFromInventReserveQueryBuilder(WHSInventReserveQueryBuilder _inventReserveQueryBuilder)
    {
        return WHSInventReserveQueryCollection::newFromQuery(_inventReserveQueryBuilder.buildOnHandQuery(), _inventReserveQueryBuilder.sumTableId()).getEnumerator() as WHSInventOnHandCollectionEnumerator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOnHandCollectionEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the on-hand collection enumerator that will be used to enumerate the on-hand.
    /// </summary>
    /// <param name = "_inventDimOnHandCriteria">The <c>InventDim</c> dimension criteria used to filter the on-hand.</param>
    /// <param name = "_inventDimParmCriteria">The <c>InventDimParm</c> dimension criteria parameters used to filter the on-hand.</param>
    /// <param name = "_reservationHierarchyLevelOnhand">The level where the on-hand should be searched for.</param>
    /// <param name = "_ttsId">The current transaction Id.</param>
    /// <param name = "_includeOrdered">A boolean that determine if ordered quantities should be considered.</param>
    /// <param name = "_includePhysical">A boolean that determines if physical quantities should be considered.</param>
    /// <param name = "_mustIncludeDelta">A boolean that determines if delta records should be included.</param>
    /// <returns>An on-hand collection enumerator that will be used to enumerate the on-hand.</returns>
    protected WHSInventOnHandCollectionEnumerator createOnHandCollectionEnumerator(
        InventDim                       _inventDimOnHandCriteria,
        InventDimParm                   _inventDimParmCriteria,
        WHSReservationHierarchyLevel    _reservationHierarchyLevelOnhand,
        CreatedTransactionId            _ttsId,
        boolean                         _includeOrdered,
        boolean                         _includePhysical,
        boolean                         _mustIncludeDelta)
    {
        WHSInventOnHandCollectionEnumerator inventOnHandCollectionEnumerator;
     
        using (var context = WHSInventReserveExpiredBatchContext::instance())
        {
            context.setBatchReservationPolicy(movement.inventBatchReservationPolicy());

            //if these were injected we need to use default enumerator creation
            if (whsInventReserveQueryBuilderSpecified)
            {
                if (whsInventReserveDeltaQueryBuilderSpecified)
                {
                    inventOnHandCollectionEnumerator = this.newOnHandEnumeratorFromInventReserveAndDeltaQueryBuilders(whsInventReserveQueryBuilderSpecified, whsInventReserveDeltaQueryBuilderSpecified);
                }
                else
                {
                    inventOnHandCollectionEnumerator = this.newOnHandEnumeratorFromInventReserveQueryBuilder(whsInventReserveQueryBuilderSpecified);
                }
            }
            else
            {
                WHSReservationOnHandCollectionEnumeratorBuilderParameters parameters = WHSReservationOnHandCollectionEnumeratorBuilderParameters::newFromParameters(movement,
                                                                                                                                                                    _inventDimOnHandCriteria,
                                                                                                                                                                    _inventDimParmCriteria,
                                                                                                                                                                    _reservationHierarchyLevelOnhand,
                                                                                                                                                                    _ttsId,
                                                                                                                                                                    _includeOrdered,
                                                                                                                                                                    _includePhysical,
                                                                                                                                                                    _mustIncludeDelta,
                                                                                                                                                                    this.parmOnlyReserveOnWHSEnabledWarehouses());
                inventOnHandCollectionEnumerator = this.newReservationOnHandCollectionEnumeratorBuilderFromParameters(parameters).buildOnHandEnumerator();
            }
        
            return inventOnHandCollectionEnumerator;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReservationOnHandCollectionEnumeratorBuilderFromParameters</Name>
				<Source><![CDATA[
    private WHSReservationOnHandCollectionEnumeratorBuilder newReservationOnHandCollectionEnumeratorBuilderFromParameters(WHSReservationOnHandCollectionEnumeratorBuilderParameters _parameters)
    {
        return WHSReservationOnHandCollectionEnumeratorBuilder::newFromParameters(_parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventReserveQueryCollectionFromQueryBuilder</Name>
				<Source><![CDATA[
    private WHSInventReserveQueryCollection newInventReserveQueryCollectionFromQueryBuilder(WHSInventReserveQueryBuilder _inventReserveQueryBuilder)
    {
        return WHSInventReserveQueryCollection::newFromQuery(_inventReserveQueryBuilder.buildOnHandQuery(), _inventReserveQueryBuilder.sumTableId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInvReserveAndDeltaQueryCollectionFromQueryBuilders</Name>
				<Source><![CDATA[
    private WHSInvReserveAndDeltaQueryCollection newInvReserveAndDeltaQueryCollectionFromQueryBuilders(
        WHSInventReserveQueryBuilder _inventReserveQueryBuilder,
        WHSInventReserveDeltaQueryBuilder _inventReserveDeltaQueryBuilder)
    {
        return WHSInvReserveAndDeltaQueryCollection::newFromQueries(_inventReserveQueryBuilder.buildOnHandQuery(),
                                                                    _inventReserveQueryBuilder.sumTableId(),
                                                                    _inventReserveDeltaQueryBuilder.buildOnHandQuery(),
                                                                    _inventReserveDeltaQueryBuilder.sumTableId());
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the level of batch number in the reservation hierarchy of the current item.
    /// </summary>
    /// <returns>
    /// A <c>WHSReservationHierarchyLevel</c> value.
    /// </returns>
    private WHSReservationHierarchyLevel inventBatchLevel()
    {
        if (!batchLevel)
        {
            batchLevel = WHSReservationHierarchyInventDimUtil::getInventDimFieldLevel(this.reservationHierarchyAllDimensionsList(), fieldNum(InventDim, InventBatchId));
        }

        return batchLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSInventReserveDeltaQueryBuilder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setter for <c>whsInventReserveDeltaQueryBuilderSpecified</c> property of a class.
    /// </summary>
    /// <param name="_whsInventReserveDeltaQueryBuilderSpecified">
    /// New value for <c>whsInventReserveDeltaQueryBuilderSpecified</c> property of a class.
    /// </param>
    public void setWHSInventReserveDeltaQueryBuilder(WHSInventReserveDeltaQueryBuilder _whsInventReserveDeltaQueryBuilderSpecified)
    {
        whsInventReserveDeltaQueryBuilderSpecified = _whsInventReserveDeltaQueryBuilderSpecified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSInventReserveQueryBuilder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setter for <c>whsInventReserveQueryBuilderSpecified</c> property of a class.
    /// </summary>
    /// <param name="_whsInventReserveQueryBuilderSpecified">
    /// New value for <c>whsInventReserveQueryBuilderSpecified</c> property of a class.
    /// </param>
    public void setWHSInventReserveQueryBuilder(WHSInventReserveQueryBuilder _whsInventReserveQueryBuilderSpecified)
    {
        whsInventReserveQueryBuilderSpecified = _whsInventReserveQueryBuilderSpecified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSReservationHierarchyStrategyList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setter for <c>whsReservationHierarchyLevelStrategyList</c> property of the class.
    /// </summary>
    /// <param name="_whsReservationHierarchyLevelStrategyList">
    /// New value for <c>whsReservationHierarchyLevelStrategyList</c> property of the class.
    /// </param>
    public void setWHSReservationHierarchyStrategyList(List _whsReservationHierarchyLevelStrategyList)
    {
        reservationHierarchyLevelStrategyList = _whsReservationHierarchyLevelStrategyList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyLeftToReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets quantity still left to reserve after the reservation execution.
    /// </summary>
    /// <returns>Quantity still left to reserve after the reservation execution.</returns>
    [Hookable(false)]
    internal InventQty getQtyLeftToReserve()
    {
        return qtyLeftToReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustInventDimReservationCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the inventory dimensions used for reservation criteria to be adjusted before the reservation takes place.
    /// </summary>
    /// <param name = "_inventDimCriteria">The <c>InventDim</c> inventory dimensions used as criteria.</param>
    /// <param name = "_inventDimParm">The <c>InventDimParm used for the criterias.</c></param>
    /// <returns></returns>
    protected InventDim adjustInventDimReservationCriteria(InventDim _inventDimCriteria, InventDimParm _inventDimParm)
    {
        return movement.adjustInventDimReservationCriteria(_inventDimCriteria, _inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservationImpl</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void updateReservationImpl()
    {
        if (reservation < 0)
        {
            WHSOrderCommittedReservationFacade::beforeMovementUpdateReserveMore(this);
        }

        super();

        if (reservation < 0)
        {
            WHSOrderCommittedReservationFacade::afterMovementUpdateReserveMore(this);
        }
        else
        {
            WHSOrderCommittedReservationFacade::afterMovementUpdateReserveLess(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParmAllowDefault</Name>
				<Source><![CDATA[
    protected void setParmAllowDefault()
    {
        super();

        if (movement is InventMov_WHSOrderCommittedReservation)
        {
            this.parmAllowReserveOrdered(false);
            this.parmAllowNegativePhysical(false);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>