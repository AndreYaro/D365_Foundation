<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FormButtonManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>FormButtonManager</c> class handles the enabled and visible properties changes for groups of
/// controls on a form that is based on a button specific rule set.
/// </summary>
/// <remarks>
/// Controls are grouped together so that the refreshing of enabled and visible properties. Each
/// control depends on one or more rules. Each group, control, or rule can be refreshed independently.
/// </remarks>
// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
class FormButtonManager
{
    ButtonStateProvider     ruleImplementer;
    SysDictClass            sysDictClassRuleImplementer;

    Map                     mapRules;
    Map                     mapButtonGroups;
    Set                     setEvaluatedButtons;
    Object                  currentGroup;
    FormDataSource          multiselectDatasource;
    boolean                 recordsMultiselected;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkButtonRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Evaluates the rule values by calling the appropriate method on the <c>ruleImplementer</c>.
    /// </summary>
    /// <param name="_ruleFunctionName">
    ///    The rule method to be called to obtain the rule evaluation result.
    /// </param>
    /// <returns>
    ///    true if the evaluation result is true; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the method that is represented by the <paramref name="_ruleFunctionName" /> parameter is not
    ///    implemented on the rule class or the specified rule class is invalid, the method returns false
    /// </remarks>
    public boolean checkButtonRule(str _ruleFunctionName)
    {
        boolean         result = false;
        ;

        if (!sysDictClassRuleImplementer)
        {
            sysDictClassRuleImplementer = new SysDictClass(classidget(ruleImplementer));
        }

        // check if the rule implementer class instance is correct
        if (sysDictClassRuleImplementer)
        {
            if (sysDictClassRuleImplementer.hasObjectMethod(_ruleFunctionName))
            {
                result = sysDictClassRuleImplementer.callObject(_ruleFunctionName, ruleImplementer);
            }
            else
            {
                // throw error in case rule does not exist
                throw error(strfmt("@SYS118035", _ruleFunctionName, classId2Name(classidget(ruleImplementer))));
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultiselect</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether a multi-selection has been made on the main data source.
    /// </summary>
    private void checkMultiselect()
    {
        Common record;
        ;

        recordsMultiselected = false;

        if (multiselectDatasource)
        {
            multiselectDatasource.getFirst(1);

            record = multiselectDatasource.getNext();
            if (record.RecId != 0)
            {
                recordsMultiselected = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultiselectAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the current control allows <c>multiselect</c>.
    /// </summary>
    /// <param name="_formControl">
    ///    Control to check.
    /// </param>
    /// <returns>
    ///    true if the control allows multi-select; otherwise, false.
    /// </returns>
    private boolean checkMultiselectAllowed(Object _formControl)
    {
        MenuFunction menuFunction;
        FormFunctionButtonControl menuButton;

        int multiselect = _formControl.multiSelect();

        if (multiselect == 0) // Auto
        {
            if (_formControl.handle() == classnum('FormFunctionButtonControl'))
            {
                menuButton = _formControl;
                menuFunction = new MenuFunction(menuButton.menuItemName(),menuButton.menuItemType());
                return menuFunction.multiSelect();
            }
        }

        return (multiselect == 1); // Yes
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cached rule evaluation results.
    /// </summary>
    /// <remarks>
    ///    When the next refresh action is performed, the rules that are relevant to the refresh will
    ///    reevaluated.
    /// </remarks>
    public void clearCache()
    {
        MapEnumerator           mapRulesEnumerator;
        FormButtonManagerRule   formButtonManagerRule;
        ;

        // notify the ruleimplementer to clear the cache for whatever advanced caching it is
        // doing
        ruleImplementer.clearCache();

        // clear the cache for all rules here
        mapRulesEnumerator = mapRules.getEnumerator();
        while (mapRulesEnumerator && mapRulesEnumerator.moveNext())
        {
            formButtonManagerRule = mapRulesEnumerator.currentValue();
            formButtonManagerRule.parmRuleCached(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEvaluatedButtonsSet</Name>
				<Source><![CDATA[
        protected void initEvaluatedButtonsSet(boolean _initEvaluatedButtons = true)
    {
        ;
        if (_initEvaluatedButtons)
        {
            setEvaluatedButtons = new Set(Types::Int64);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
        protected void new()
    {
        ;
        mapButtonGroups = new Map(Types::Int64, Types::Class);
        mapRules = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMultiselectDatasource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>multiselectDatasource</c> variable.
    /// </summary>
    /// <param name="_multiselectDatasource">
    ///    The new value.
    /// </param>
    public void parmMultiselectDatasource(FormDataSource _multiselectDatasource)
    {
        multiselectDatasource = _multiselectDatasource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRuleImplementer</Name>
				<Source><![CDATA[
        public ButtonStateProvider parmRuleImplementer(ButtonStateProvider _ruleImplementer = ruleImplementer)
    {
        ;
        ruleImplementer = _ruleImplementer;
        return ruleImplementer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refresh</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes all buttons registered with the FormButtonManager
    /// </summary>
    /// <param name="_clearCache">
    /// A boolean value that specifies whether the rule values cache should be clear and the rules reevaluated.
    /// </param>
    /// <param name="_internalCall">
    /// Set to true when the method is called by formButtonManager internally; otherwise false.
    /// </param>
    /// <remarks>
    /// The method is equivalent to triggering a refresh for all the registered groups
    /// </remarks>
    public void refresh(boolean     _clearCache = true,
                        boolean     _internalCall = false)
    {
        MapEnumerator mapButtonGroupsEnumerator;
        ;

        this.initEvaluatedButtonsSet(!_internalCall);

        if (!ruleImplementer)
        {
            return;
        }

        if (_clearCache)
        {
            this.clearCache();
            _clearCache = false;
        }

        this.checkMultiselect();

        mapButtonGroupsEnumerator = mapButtonGroups.getEnumerator();

        while (mapButtonGroupsEnumerator && mapButtonGroupsEnumerator.moveNext())
        {
            this.refreshGroupById (mapButtonGroupsEnumerator.currentKey(), _clearCache, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes a specific button registered in a specific group.
    /// </summary>
    /// <param name="_formButtonGroupControl">
    /// An Object (usually a FormButtonGroupControl) specifying the group to look into for the button to be refreshed.
    /// </param>
    /// <param name="_formButtonControl">
    /// An object (usually FormButtonControl) specifying which button to refresh
    /// </param>
    /// <param name="_clearCache">
    /// A boolean value specifying whether the rule values cache should be clear and the rules reevaluated.
    /// </param>
    /// <param name="_internalCall">
    /// Set to true when the method is called by formButtonManager internally; otherwise false.
    /// </param>
    public void refreshButton(Object    _formButtonGroupControl,
                              Object    _formButtonControl,
                              boolean   _clearCache = true,
                              boolean   _internalCall = false)
    {
        ;
        this.initEvaluatedButtonsSet(!_internalCall);

        this.refreshButtonById(_formButtonGroupControl.id(), _formButtonControl.id(), _clearCache, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshButtonById</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes a specific button registered in a specific group.
    /// </summary>
    /// <param name="_formButtonGroupControlId">
    /// A <c>FormButtonGroupControl</c> object ID specifies the group to look into for the button to be
    /// refreshed.
    /// </param>
    /// <param name="_formButtonControlId">
    /// A <c>FormButtonControl</c> object ID that indicates which button to refresh.
    /// </param>
    /// <param name="_clearCache">
    /// A Boolean value that specifies whether the rule values cache should be clear and the rules
    /// reevaluated.
    /// </param>
    /// <param name="_internalCall">
    /// A Boolean value that indicates whether the method is called by the <c>FormButtonManager</c> class.
    /// </param>
    /// <remarks>
    /// The lookup is performed by ID instead of by reference.
    /// </remarks>
    public void refreshButtonById(int64     _formButtonGroupControlId,
                                  int64     _formButtonControlId,
                                  boolean   _clearCache = true,
                                  boolean   _internalCall = false)
    {
        Map                             mapButtons;
        SetEnumerator                   setRulesEnumerator;
        Set                             setRules;
        boolean                         isVisible;
        boolean                         isEnabled;
        boolean                         isAllowEdit;
        boolean                         markVisible;
        boolean                         markEnabled;
        boolean                         markAllowEdit;
        FormButtonManagerRule           formButtonManagerRule;
        FormButtonManagerControl        formButtonManagerControl;
        FormButtonManagerControlRule    formButtonManagerControlRule;
        boolean                         controlAllowMultiselect;

        str             pmfLabelValue;
        str             pmfHelpTextValue;
        str             pmfCaptionValue;
        str             pmfTextValue;
        boolean         pmfMarkLabel;
        boolean         pmfMarkHelpText;
        boolean         pmfMarkCaption;
        boolean         pmfMarkText;
        SysDictClass    pmfSysDictClass;
        #Properties

        if (!mapButtonGroups.exists(_formButtonGroupControlId))
        {
            return;
        }

        this.initEvaluatedButtonsSet(!_internalCall);

        mapButtons = mapButtonGroups.lookup(_formButtonGroupControlId);

        if (!mapButtons ||
            !mapButtons.exists(_formButtonControlId))
        {
            return;
        }

        if (_clearCache)
        {
            this.clearCache();
        }

        formButtonManagerControl = mapButtons.lookup(_formButtonControlId);

        if (!formButtonManagerControl)
        {
            return;
        }

        markVisible     = false;
        markEnabled     = false;
        markAllowEdit   = false;

        pmfMarkLabel = false;
        pmfMarkHelpText = false;
        pmfMarkCaption = false;
        pmfMarkText = false;
        pmfSysDictClass = new SysDictClass(
            classidget(formButtonManagerControl.parmObject()));

        controlAllowMultiselect = recordsMultiselected && this.checkMultiselectAllowed(formButtonManagerControl.parmObject());

        setRules = formButtonManagerControl.parmSetRules();

        if (!setEvaluatedButtons)
        {
            throw error("@SYS121679");
        }

        if (!setEvaluatedButtons.in(_formButtonControlId))
        {
            isVisible   = true;
            isEnabled   = true;
            isAllowEdit = true;

            setEvaluatedButtons.add(_formButtonControlId);
        }
        else
        {
            isVisible   = formButtonManagerControl.parmObject().visible();
            isEnabled   = formButtonManagerControl.parmObject().enabled();
            isAllowEdit = formButtonManagerControl.parmObject().allowEdit();
        }

        if (!setRules)
        {
            return;
        }

        setRulesEnumerator = setRules.getEnumerator();

        while (setRulesEnumerator && setRulesEnumerator.moveNext())
        {
            // get the rule name
            formButtonManagerControlRule = setRulesEnumerator.current();

            if  (formButtonManagerControlRule &&
                mapRules.exists(formButtonManagerControlRule.parmRuleName()))
            {
                formButtonManagerRule = mapRules.lookup(formButtonManagerControlRule.parmRuleName());

                if (formButtonManagerRule)
                {
                    // check if the rule is cached
                    if (!formButtonManagerRule.parmRuleCached())
                    {
                        // invoke the evaluation of this rule
                        ruleImplementer.determineButtonStates(formButtonManagerControlRule.parmRuleName());
                        this.setRuleValue(formButtonManagerControlRule.parmRuleName(), this.checkButtonRule(formButtonManagerControlRule.parmRuleName()));
                    }

                    switch (formButtonManagerControlRule.parmRuleEffectType())
                    {
                        case ButtonRuleEffectType::Visible:
                            isVisible = formButtonManagerRule.parmRuleValue() && isVisible;
                            markVisible = true;
                            break;

                        case ButtonRuleEffectType::Enabled:
                            isEnabled = (controlAllowMultiselect || (formButtonManagerRule.parmRuleValue() && isEnabled));
                            markEnabled = true;
                            break;

                        case ButtonRuleEffectType::AllowEdit:
                            isAllowEdit = formButtonManagerRule.parmRuleValue() && isAllowEdit;
                            markAllowEdit = true;
                            break;

                        case ButtonRuleEffectType::Label:
                            pmfLabelValue
                                = formButtonManagerControlRule
                                    .parmPmfRuleValueLabel();
                            pmfMarkLabel = formButtonManagerRule.parmRuleValue();
                            break;
                        case ButtonRuleEffectType::HelpText:
                            pmfHelpTextValue
                                = formButtonManagerControlRule
                                    .parmPmfRuleValueHelpText();
                            pmfMarkHelpText
                                = formButtonManagerRule.parmRuleValue();
                            break;
                        case ButtonRuleEffectType::Caption:
                            pmfCaptionValue
                                = formButtonManagerControlRule
                                    .parmPmfRuleValueCaption();
                            pmfMarkCaption
                                = formButtonManagerRule.parmRuleValue();
                            break;
                        case ButtonRuleEffectType::Text:
                            pmfTextValue
                                = formButtonManagerControlRule
                                    .parmPmfRuleValueText();
                            pmfMarkText = formButtonManagerRule.parmRuleValue();
                            break;

                        default:
                            break;
                    }
                }
            }
        }

        if (_formButtonControlId)
        {
            if (markVisible && formButtonManagerControl.parmObject().visible() != isVisible)
            {
                formButtonManagerControl.parmObject().visible(isVisible);
            }
            if (markEnabled && formButtonManagerControl.parmObject().enabled() != isEnabled)
            {
                formButtonManagerControl.parmObject().enabled(isEnabled);
            }
            if (markAllowEdit && formButtonManagerControl.parmObject().allowEdit() != isAllowEdit)
            {
                formButtonManagerControl.parmObject().allowEdit(isAllowEdit);
            }

            if (pmfMarkLabel
                && pmfSysDictClass.hasObjectMethod(#PropertyLabel))
            {
                formButtonManagerControl.parmObject().label(pmfLabelValue);
            }
            if (pmfMarkHelpText
                && pmfSysDictClass.hasObjectMethod(#PropertyHelpText))
            {
                formButtonManagerControl.parmObject().helpText(pmfHelpTextValue);
            }
            if (pmfMarkCaption
                && pmfSysDictClass.hasObjectMethod(#PropertyCaption))
            {
                formButtonManagerControl.parmObject().caption(pmfCaptionValue);
            }
            if (pmfMarkText
                && pmfSysDictClass.hasObjectMethod(#PropertyText))
            {
                formButtonManagerControl.parmObject().text(pmfTextValue);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCurrentGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the group marked as current.
    /// </summary>
    /// <param name="_clearCache">
    /// A boolean value specifying whether the rule values cache should be clear and the rules reevaluated.
    /// </param>
    /// <param name="_internalCall">
    /// Set to true when the method is called by formButtonManager internally; otherwise false.
    /// </param>
    /// <remarks>
    /// The current group can be switched by calls to switchGroup.
    /// </remarks>
    public void refreshCurrentGroup(boolean     _clearCache = true,
                                    boolean     _internalCall = false)
    {
        ;
        this.initEvaluatedButtonsSet(!_internalCall);

        if (currentGroup)
        {
            this.refreshGroup(currentGroup, _clearCache, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes all controls in a group.
    /// </summary>
    /// <param name="_formGroupControl">
    /// A FormControl specifying the group to refresh.
    /// </param>
    /// <param name="_clearCache">
    /// A boolean value specifying whether the rule values cache should be clear and the rules reevaluated.
    /// </param>
    /// <param name="_internalCall">
    /// Set to true when the method is called by formButtonManager internally; otherwise false.
    /// </param>
    public void refreshGroup(FormControl    _formGroupControl,
                              boolean       _clearCache = true,
                              boolean       _internalCall = false)
    {
        ;
        this.initEvaluatedButtonsSet(!_internalCall);

        this.checkMultiselect();

        this.refreshGroupById(_formGroupControl.id(), _clearCache, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshGroupById</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes a group by id.
    /// </summary>
    /// <param name="_formGroupControlId">
    /// A FormControl id specifying the group to refresh.
    /// </param>
    /// <param name="_clearCache">
    /// A boolean value specifying whether the rule values cache should be clear and the rules reevaluated.
    /// </param>
    /// <param name="_internalCall">
    /// Set to true when the method is called by formButtonManager internally; otherwise false.
    /// </param>
    public void refreshGroupById(int64      _formGroupControlId,
                                 boolean    _clearCache = true,
                                 boolean    _internalCall = false)
    {
        Map                 mapButtons;
        MapEnumerator       mapButtonsEnumerator;
        ;

        this.initEvaluatedButtonsSet(!_internalCall);

        // clear the cache if needed
        if (_clearCache)
        {
            this.clearCache();
        }

        // check if the group is registered in the FormButtonManager
        if (mapButtonGroups.exists(_formGroupControlId))
        {
            mapButtons = mapButtonGroups.lookup(_formGroupControlId);
        }

        if (mapButtons)
        {
            mapButtonsEnumerator = mapButtons.getEnumerator();

            // enumerate through all buttons and refresh each one
            while (mapButtonsEnumerator && mapButtonsEnumerator.moveNext())
            {
                this.refreshButtonById(_formGroupControlId, mapButtonsEnumerator.currentKey(), _clearCache, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes all buttons that depend on one rule
    /// </summary>
    /// <param name="_ruleFunctionName">
    /// A string parameter specifying the rule to be refreshed. The rule should exist on the ruleImplementer instance that must be previously set.
    /// </param>
    /// <param name="_internalCall">
    /// Set to true when the method is called by formButtonManager internally; otherwise false.
    /// </param>
    public void refreshRule(str     _ruleFunctionName,
                            boolean _internalCall = false)
    {
        MapEnumerator               mapGroupsEnumerator;
        MapEnumerator               mapButtonsEnumerator;
        Map                         mapButtons;
        Set                         setRules;
        FormButtonManagerRule       formButtonManagerRule;
        FormButtonManagerControl    formButtonManagerControl;
        ;

        this.initEvaluatedButtonsSet(!_internalCall);

        // check if the rule is registered
        if (mapRules.exists(_ruleFunctionName))
        {
            formButtonManagerRule = mapRules.lookup(_ruleFunctionName);

            ruleImplementer.determineButtonStates(_ruleFunctionName);
            this.checkButtonRule(_ruleFunctionName);

            if (formButtonManagerRule)
            {
                // check each group, each button
                mapGroupsEnumerator = mapButtonGroups.getEnumerator();

                while (mapGroupsEnumerator && mapGroupsEnumerator.moveNext())
                {
                    mapButtons = mapGroupsEnumerator.currentValue();

                    if (mapButtons)
                    {
                        mapButtonsEnumerator = mapButtons.getEnumerator();

                        // iterate through all buttons in the group
                        while (mapButtonsEnumerator && mapButtonsEnumerator.moveNext())
                        {
                            formButtonManagerControl = mapButtonsEnumerator.currentValue();

                            if (formButtonManagerControl)
                            {
                                // check if the passed rule is relevant for this button
                                setRules = formButtonManagerControl.parmSetRules();

                                if (setRules && setRules.in(_ruleFunctionName))
                                {
                                    this.refreshButtonById (mapGroupsEnumerator.currentKey(), mapButtonsEnumerator.currentKey(), true, true);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerButton</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Registers a button in a group in the <c>FormButtonManager</c>.
    /// </summary>
    /// <param name="_formButtonGroupControl">
    ///    A <c>FormControl</c> (usually <c>FormButtonGroupControl</c>) that identifies to which group the
    ///    button will belong.
    /// </param>
    /// <param name="_formButtonControl">
    ///    A <c>FormControl</c> (usually <c>FormButtonControl</c>) that specifies the button to register.
    /// </param>
    /// <remarks>
    ///    If the group was not previously registered, this is done automatically.
    /// </remarks>
    public void registerButton(FormControl _formButtonGroupControl, FormControl _formButtonControl)
    {
        Map                         mapButtons;
        FormButtonManagerControl    formButtonManagerControl;
        ;

        if (!mapButtonGroups.exists(_formButtonGroupControl.id()))
        {
            this.registerGroup(_formButtonGroupControl);
        }

        if (mapButtonGroups.exists(_formButtonGroupControl.id()))
        {
            mapButtons = mapButtonGroups.lookup(_formButtonGroupControl.id());
        }

        if (mapButtons)
        {
            formButtonManagerControl = FormButtonManagerControl::newObjectId(_formButtonControl, _formButtonControl.id());

            mapButtons.insert(_formButtonControl.id(), formButtonManagerControl);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerButtonRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers a rule that will be used for a button.
    /// </summary>
    /// <param name="_formButtonGroupControl">
    /// A <c>FormControl</c> object that specifies the group to which the button belongs.
    /// </param>
    /// <param name="_formButtonControl">
    /// A <c>FormControl</c> object that specifies the button for which the rule is registered.
    /// </param>
    /// <param name="_ruleFunctionName">
    /// A string that identifies the rule method name that will be used to evaluate the rule that is
    /// registered for the specified button.
    /// </param>
    /// <param name="_buttonRuleEffect">
    /// A <c>ButtonRuleEffectType</c> enumeration value that indicates whether the rule result will control
    /// the enabled or the visible property of the button; optional.
    /// </param>
    /// <param name="_pmfRuleValueStr">
    /// The value to set for the rule
    /// </param>
    /// <returns>
    /// true if the registration of the rule was successful; otherwise false.
    /// </returns>
    /// <remarks>
    /// If the group that is identified by the <paramref name="_formButtonGroupControl" /> parameter was
    /// not previously registered in the <c>FormButtonManager</c> object, it is registered automatically.
    /// If the control that is identified by the <paramref name="_formButtonControl" /> parameter was not
    /// previously registered in the <c>FormButtonManager</c> object, it is registered automatically.
    /// </remarks>
    public boolean registerButtonRule(FormControl _formButtonGroupControl,
                                      FormControl _formButtonControl,
                                      str _ruleFunctionName,
                                      ButtonRuleEffectType _buttonRuleEffect = ButtonRuleEffectType::Enabled
                                      , str _pmfRuleValueStr = ""
                                      )
    {
        FormButtonManagerRule           formButtonManagerRule;
        FormButtonManagerControlRule    formButtonManagerControlRule;
        Set                             setRules;
        SetEnumerator                   setEnumerator;
        Map                             mapButtons;
        FormButtonManagerControl        formButtonManagerControl;
        boolean                         result = false;
        boolean                         ruleFound = false;
        ;

        if (!_formButtonControl)
        {
            return checkFailed("@SYS114774");
        }

        formButtonManagerRule = new FormButtonManagerRule();

        if (!formButtonManagerRule)
        {
            return checkFailed("@SYS114773");
        }

        // check if the group exists
        if (!mapButtonGroups.exists(_formButtonGroupControl.id()))
        {
            this.registerGroup(_formButtonGroupControl);
        }
        mapButtons = mapButtonGroups.lookup (_formButtonGroupControl.id());

        if (mapButtons)
        {
            // check if it is a new rule
            if (!mapRules.exists(_ruleFunctionName))
            {
                formButtonManagerRule.parmRuleValue(false);
                formButtonManagerRule.parmRuleCached(false);

                // add rule to rules list
                mapRules.insert(_ruleFunctionName, formButtonManagerRule);
            }

            if (!mapButtons.exists(_formButtonControl.id()))
            {
                this.registerButton(_formButtonGroupControl, _formButtonControl);
            }

            formButtonManagerControl = mapButtons.lookup(_formButtonControl.id());

            if (formButtonManagerControl)
            {
                setRules = formButtonManagerControl.parmSetRules();

                if (setRules)
                {
                    setEnumerator = setRules.getEnumerator();

                    while (setEnumerator && setEnumerator.moveNext())
                    {
                        formButtonManagerControlRule = setEnumerator.current();

                        if (formButtonManagerControlRule.parmRuleEffectType() == _buttonRuleEffect &&
                            formButtonManagerControlRule.parmRuleName() == _ruleFunctionName)
                        {
                            ruleFound = true;
                            break;
                        }
                    }

                    if (!ruleFound)
                    {
                        formButtonManagerControlRule = FormButtonManagerControlRule::newRule(_ruleFunctionName, _buttonRuleEffect);

                        switch (_buttonRuleEffect)
                        {
                            case ButtonRuleEffectType::Label:
                                formButtonManagerControlRule.parmPmfRuleValueLabel(
                                    _pmfRuleValueStr);
                                break;
                            case ButtonRuleEffectType::HelpText:
                                formButtonManagerControlRule
                                    .parmPmfRuleValueHelpText(
                                        _pmfRuleValueStr);
                                break;
                            case ButtonRuleEffectType::Caption:
                                formButtonManagerControlRule
                                    .parmPmfRuleValueCaption(
                                        _pmfRuleValueStr);
                                break;
                            case ButtonRuleEffectType::Text:
                                formButtonManagerControlRule
                                    .parmPmfRuleValueText(
                                        _pmfRuleValueStr);
                                break;
                        }

                        // have to add the rule to the ruleset for the button
                        setRules.add(formButtonManagerControlRule);
                    }

                    result = true;
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerButtonRuleOnGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Registers a rule on a complete group.
    /// </summary>
    /// <param name="_groupControl">
    ///    A <c>FormControl</c> that identifies the group that will have the rule registered for all its
    ///    buttons.
    /// </param>
    /// <param name="_ruleFunction">
    ///    A string that identifies the rule in which to be registered for the whole group.
    /// </param>
    /// <param name="_buttonRuleEffect">
    ///    A <c>ButtonRuleEffectType</c> enumeration value that specifies whether the rule affects the enabled
    ///    or the visible property; optional.
    /// </param>
    /// <param name="recursive">
    ///    A Boolean value that indicates whether to recurse into the subgroups in <paramref
    ///    name="_groupControl" />; optional.
    /// </param>
    /// <returns>
    ///    true if registration of the rule was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    All buttons in the group will have the rule affecting their properties.
    /// </remarks>
    public boolean registerButtonRuleOnGroup(FormControl _groupControl, str _ruleFunction, ButtonRuleEffectType _buttonRuleEffect = ButtonRuleEffectType::Enabled, boolean recursive = true)
    {
        FormControl         formControl;
        int                 frameOptionButton;
        int                 controlCount;
        int                 i;
        boolean             skipGroup;
        classId             classId;
        SysDictClass        dictClass;
        ;

        classId = classidget(_groupControl);
        dictClass = new SysDictClass(classId);

        if (!dictClass)
        {
            // Could not create class handler
            return checkFailed("@SYS114772");
        }

        if ((!dictClass.hasObjectMethod(identifierstr(controlCount))) ||
            (!dictClass.hasObjectMethod(identifierstr(controlNum))))
        {
            // This is not a container
            return false;
        }

        // If the container has a control itself, register it (like a radio button or checkbox in a group)
        if (dictClass.hasObjectMethod(identifierstr(frameOptionButton)))
        {
            frameOptionButton = dictClass.callObject(identifierstr(frameOptionButton), _groupControl);
            if (frameOptionButton)
            {
                this.registerButtonRule(_groupControl, _groupControl, _ruleFunction, _buttonRuleEffect);
            }
        }

        controlCount = dictClass.callObject(identifierstr(controlCount), _groupControl);

        for (i = 1; i <= controlCount;i++)
        {
            formControl = dictClass.callObject(identifierstr(controlNum), _groupControl, i);
            skipGroup = false;

            if (recursive)
            {
                // Call recursive
                skipGroup = this.registerButtonRuleOnGroup(formControl, _ruleFunction, _buttonRuleEffect, recursive);
            }

            if (!skipGroup)
            {
                this.registerButtonRule(_groupControl, formControl, _ruleFunction, _buttonRuleEffect);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a group to the group list that is stored in the <c>FormButtonManager</c> class.
    /// </summary>
    /// <param name="_formGroupControl">
    ///    A <c>FormControl</c> (usually a <c>FormButtonGroupControl</c>) that identifies the group to be
    ///    registered.
    /// </param>
    /// <remarks>
    ///    If the group that is being registered is the first group that is registered in the
    ///    <c>FormButtonManager</c>, this group is also set to be the current group.
    /// </remarks>
    public void registerGroup(FormControl _formGroupControl)
    {
        ;
        if (!mapButtonGroups.exists(_formGroupControl.id()))
        {
            mapButtonGroups.insert(_formGroupControl.id(), new Map(Types::Int64, Types::Class));
        }

        if (mapButtonGroups.elements() == 1)
        {
            this.switchToGroup(_formGroupControl);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDatasources</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Passes the data sources that will be used for rule evaluation.
    /// </summary>
    /// <param name="datasources1">
    ///    A Common table buffer that belongs to the first data source instance.
    /// </param>
    /// <param name="datasources2">
    ///    A Common table buffer that belongs to the second data source instance; optional.
    /// </param>
    /// <param name="datasources3">
    ///    A Common table buffer that belongs to the third data source instance; optional.
    /// </param>
    /// <param name="datasources4">
    ///    A Common table buffer that belongs to the fourth data source instance; optional.
    /// </param>
    /// <param name="datasources5">
    ///    A Common table buffer that belongs to the fifth data source instance; optional.
    /// </param>
    /// <remarks>
    ///    The rules perform evaluation on a table buffer that is obtained from a data source.This method
    ///    allows for the user to set up several data sources that are that will be used by the rule
    ///    implementer helper class during rule evaluation.
    /// </remarks>
    public void setDatasources(Common datasources1, Common datasources2 = null, Common datasources3 = null, Common datasources4 = null, Common datasources5 = null)
    {
        if (ruleImplementer)
        {
            ruleImplementer.setDatasources(datasources1, datasources2, datasources3, datasources4, datasources5);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRuleValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the value for a specific rule.
    /// </summary>
    /// <param name="_ruleFunctionName">
    ///    A string that identifies the rule for which to set the rule evaluation result value.
    /// </param>
    /// <param name="_ruleValue">
    ///    A Boolean value that indicates the result of the rule evaluation.
    /// </param>
    /// <remarks>
    ///    The method is only used internally by the <c>FormButtonManager</c> class.
    /// </remarks>
    private void setRuleValue(str _ruleFunctionName, boolean _ruleValue)
    {
        FormButtonManagerRule   formButtonManagerRule;
        ;
        if (mapRules.exists(_ruleFunctionName))
        {
            formButtonManagerRule = mapRules.lookup(_ruleFunctionName);

            if (formButtonManagerRule)
            {
                formButtonManagerRule.parmRuleValue(_ruleValue);
                formButtonManagerRule.parmRuleCached(true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>switchToGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Switches the current group.
    /// </summary>
    /// <param name="_currentGroup">
    ///    A <c>FormControl</c> (usually a <c>FormButtonGroupControl</c>) that specifies the new current group.
    /// </param>
    /// <remarks>
    ///    The current group is used by the <c>refreshCurrentGroup</c> method in order to easily refresh the
    ///    current group.
    /// </remarks>
    public void switchToGroup(FormControl _currentGroup)
    {
        ;
        currentGroup = _currentGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unregisterButton</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes a button from a specified group.
    /// </summary>
    /// <param name="_formGroupControl">
    ///    A <c>FormControl</c> (usually a <c>FormButtonGroupControl</c>) that identifies the group from which
    ///    the button is to be removed.
    /// </param>
    /// <param name="_formButtonControl">
    ///    A <c>FormControl</c> (usually a <c>FormButtonControl</c>) that identifies the button to unregister.
    /// </param>
    public void unregisterButton(FormControl _formGroupControl, FormControl _formButtonControl)
    {
        Map             mapButtons;
        ;

        if (mapButtonGroups.exists(_formGroupControl.id()))
        {
            mapButtons = mapButtonGroups.lookup(_formGroupControl.id());
        }

        if (mapButtons)
        {
            if (mapButtons.exists(_formButtonControl.id()))
            {
                mapButtons.remove(_formButtonControl.id());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unregisterButtonRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes a rule from the rule list that is associated with a certain registered button.
    /// </summary>
    /// <param name="_formGroupControl">
    ///    A <c>FormControl</c> (usually a <c>FormButtonGroupControl</c>) that identifies the group in which
    ///    the button is registered.
    /// </param>
    /// <param name="_formButtonControl">
    ///    A <c>FormControl</c> (usually a <c>FormButtonControl</c>) that identifies the button from whose
    ///    rule list to remove the rule.
    /// </param>
    /// <param name="_ruleFunctionName">
    ///    A string that specifies the rule to be removed from the button.
    /// </param>
    /// <param name="_buttonRuleEffect">
    ///    A <c>ButtonRuleEffectType</c> enumeration value that specifies whether the rule should be removed
    ///    if it affects the enabled property or the visible property of the button; optional.
    /// </param>
    /// <remarks>
    ///    The <paramref name="_formGroupControl" />,<paramref name=" _formButtonControl" />, <paramref
    ///    name="_ruleFunctionName" />, and <paramref name="_buttonRuleEffect" /> parameters can be considered
    ///    a unique key that specifies which rule to remove.
    /// </remarks>
    public void unregisterButtonRule(FormControl _formGroupControl,
                                     FormControl _formButtonControl,
                                     str _ruleFunctionName,
                                     ButtonRuleEffectType _buttonRuleEffect = ButtonRuleEffectType::Enabled)
    {
        Map                             mapButtons;
        Set                             setRules;
        FormButtonManagerControl        formButtonManagerControl;
        FormButtonManagerControlRule    formButtonManagerControlRule;
        SetEnumerator                   setEnumerator;
        boolean                         moreElements;
        ;

        if (mapButtonGroups.exists(_formGroupControl.id()))
        {
            mapButtons = mapButtonGroups.lookup(_formGroupControl.id());
        }

        if (mapButtons)
        {
            if (mapButtons.exists(_formButtonControl.id()))
            {
                formButtonManagerControl = mapButtons.lookup(_formButtonControl.id());

                if (formButtonManagerControl)
                {
                    setRules = formButtonManagerControl.parmSetRules();

                    setEnumerator = setRules.getEnumerator();
                    moreElements  = setEnumerator.moveNext();

                    while (setEnumerator && moreElements)
                    {
                        formButtonManagerControlRule = setEnumerator.current();

                        moreElements  = setEnumerator.moveNext();

                        if (formButtonManagerControlRule.parmRuleName() == _ruleFunctionName)
                        {
                            setRules.remove(formButtonManagerControlRule);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unregisterGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes a group and the buttons that are registered in the group from the <c>FormButtonManager</c>
    ///    class.
    /// </summary>
    /// <param name="_formGroupControl">
    ///    A <c>FormControl</c> (usually a <c>FormButtonGroupControl</c>) that identifies the group to be
    ///    unregistered.
    /// </param>
    public void unregisterGroup(FormControl _formGroupControl)
    {
        ;
        if (mapButtonGroups.exists(_formGroupControl.id()))
        {
            mapButtonGroups.remove(_formGroupControl.id());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a <see cref="T:FormButtonManager" /> instance.
    /// </summary>
    /// <returns>
    ///    A new <see cref="T:FormButtonManager" /> instance.
    /// </returns>
    public static FormButtonManager construct()
    {
        FormButtonManager   formButtonManager;
        ;

        formButtonManager = new FormButtonManager();

        return formButtonManager;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>