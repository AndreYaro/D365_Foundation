<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VendOutPaym_NACHA</Name>
	<SourceCode>
		<Declaration><![CDATA[
class VendOutPaym_NACHA extends VendOutPaym
{
    #define.FileFormatLen(3)

    Counter             recCount;               // Count of All Records in this EFT - needed when computing the Block Count in the Control Record
    Counter             numTransactions;        // Number of Transaction Records

    AmountCur           totalDebitAmount;
    AmountCur           totalCreditAmount;

    real                routingHash;            // Hash value used to verify data against alteration
    str #FileFormatLen  fileFormat;             // "CCD", "CTX" or "PPD"
    int                 sequenceNumber;         // Used to generate the Trace Number on the payment records
    int                 numberOfBlockLines;

    BankAccountTable    bankAccountTable;

    DialogField         dialogEffectiveEntryDate;
    date                effectiveEntDate;

    #ISOCountryRegionCodes
    #define.HashEntryMaximum(10000000000)
    #define.DebugNACHA(False)
    #define.NACHARecLen(94)
    #define.NACHABlockSize(940)

    #DEFINE.SysLastValuesCurrentVersion(1)
    #LOCALMACRO.SysLastValuesList
        effectiveEntDate
    #ENDMACRO

    #DEFINE.CurrentVersion(5)
    #LOCALMACRO.CurrentList
        effectiveEntDate,
        recCount,
        numTransactions,
        totalDebitAmount,
        totalCreditAmount,
        routingHash,
        fileFormat,
        sequenceNumber
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmNumberOfBlockLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// The number of filler block lines.
    /// </summary>
    /// <returns>
    /// The number of filler block lines.
    /// </returns>
    public int parmNumberOfBlockLines()
    {
        return numberOfBlockLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addACHControlFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help verify the data.
    /// </summary>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    ///    <c>VendOutPaym_NACHA</c> class declaration to a value of true.
    /// </remarks>
    protected void addACHControlFieldPositions()
    {
        #define.ACHCRecord          ('ABBBBBBCCCCCCDDDDDDDDEEEEEEEEEEFFFFFFFFFFFFGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH - ACH CONTROL RECORD')
        #define.ACHCReserved        ('                                                       HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH - Reserved = <BLANK>')
        #define.ACHCCreditAmount    ('                                           GGGGGGGGGGGG - Total Credit Amount')
        #define.ACHCDebitAmount     ('                               FFFFFFFFFFFF - Total Debit Amount')
        #define.ACHCEntryHash       ('                     EEEEEEEEEE - Entry Hash')
        #define.ACHCAddendaCount    ('             DDDDDDDD - Entry/Addenda Count')
        #define.ACHCBlockCount      ('       CCCCCC - Block Count')
        #define.ACHCBatchCount      (' BBBBBB - Batch Count = "000001"')
        #define.ACHCRecordTypeCode  ('A - Record Type Code = "9"')
        #define.ACHC

        file.write(#ACHCRecord);
        file.write(#ACHCReserved);
        file.write(#ACHCCreditAmount);
        file.write(#ACHCDebitAmount);
        file.write(#ACHCEntryHash);
        file.write(#ACHCAddendaCount);
        file.write(#ACHCBlockCount);
        file.write(#ACHCBatchCount);
        file.write(#ACHCRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addACHHeaderFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help verify the data.
    /// </summary>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    ///    <c>VendOutPaym_NACHA</c> class declaration to a value of true.
    /// </remarks>
    protected void addACHHeaderFieldPositions()
    {
        #define.ACHHRecord          ('ABBCCCCCCCCCCDDDDDDDDDDEEEEEEFFFFGHHHIIJKKKKKKKKKKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMM - ACH HEADER RECORD')
        #define.ACHHRefCode         ('                                                                                      MMMMMMMM - Reference Code = <BLANK>')
        #define.ACHHOriginName      ('                                                               LLLLLLLLLLLLLLLLLLLLLLL - Immediate Origin Name')
        #define.ACHHDestinationName ('                                        KKKKKKKKKKKKKKKKKKKKKKK - Immediate Destination Name')
        #define.ACHHFormatCode      ('                                       J - Format Code = "1"')
        #define.ACHHBlockingFactor  ('                                     II - Blocking Factor = "10"')
        #define.ACHHRecordSize      ('                                  HHH - Record Size = "094"')
        #define.ACHHFileIDModifier  ('                                 G - File ID Modifier = "A"')
        #define.ACHHFileCreationTime('                             FFFF - File Creation Time [HHMM]')
        #define.ACHHFileCreationDate('                       EEEEEE - File Creation Date [YYMMDD]')
        #define.ACHHImmediateOrigin ('             DDDDDDDDDD - Immediate Origin')
        #define.ACHHImmediateDest   ('   CCCCCCCCCC - Immediate Destination')
        #define.ACHHPriorityCode    (' BB - Priority Code = "01"')
        #define.ACHHRecordTypeCode  ('A - Record Type Code = "1"')

        file.write(#ACHHRecord);
        file.write(#ACHHRefCode);
        file.write(#ACHHOriginName);
        file.write(#ACHHDestinationName);
        file.write(#ACHHFormatCode);
        file.write(#ACHHBlockingFactor);
        file.write(#ACHHRecordSize);
        file.write(#ACHHFileIDModifier);
        file.write(#ACHHFileCreationTime);
        file.write(#ACHHFileCreationDate);
        file.write(#ACHHImmediateOrigin);
        file.write(#ACHHImmediateDest);
        file.write(#ACHHPriorityCode);
        file.write(#ACHHRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAlignment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes alignment markers to the output file to help verify the accuracy of the data.
    /// </summary>
    /// <param name="lenLine">
    ///    The length of the line to write to the output file; always 94 for NACHA.
    /// </param>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    ///    <c>VendOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    protected void addAlignment(int lenLine)
    {
        #define.BaseTen(10)
        #define.align1('         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5')
        #define.align2('1234567890')

        str     align1;
        str     align2;
        int     multi;

        multi = (lenLine div #BaseTen) + 1;
        align1 = subStr(#align1, 1, lenLine);
        align2 = subStr(strRep(#align2, multi), 1, lenLine);

        file.write(align1);
        file.write(align2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchControlFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help verify the data.
    /// </summary>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    ///    <c>VendOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    protected void addBatchControlFieldPositions()
    {
        #define.BATCRecord          ('ABBBCCCCCCDDDDDDDDDDEEEEEEEEEEEEFFFFFFFFFFFFGGGGGGGGGGHHHHHHHHHHHHHHHHHHHIIIIIIJJJJJJJJKKKKKKK - BATCH CONTROL RECORD')
        #define.BATCBatchNumber     ('                                                                                       KKKKKKK - Batch Number = "0000001"')
        #define.BATCOriginatingDFI  ('                                                                               JJJJJJJJ - Originating DFI Identification [TTTTAAAA]')
        #define.BATCReserved        ('                                                                         IIIIII - Reserved = <BLANK>')
        #define.BATCAuthentication  ('                                                      HHHHHHHHHHHHHHHHHHH - Message Authentication Code = <BLANK>')
        #define.BATCCompanyID       ('                                            GGGGGGGGGG - Company Identification')
        #define.BATCCreditAmount    ('                                FFFFFFFFFFFF - Total Credit Amount')
        #define.BATCDebitAmount     ('                    EEEEEEEEEEEE - Total Debit Amount')
        #define.BATCEntryHash       ('          DDDDDDDDDD - Entry Hash')
        #define.BATCAddendaCount    ('    CCCCCC - Entry/Addenda Count')
        #define.BATCServiceClassCode(' BBB - Service Class Code = "220" for Credits ["225" for Debits]')
        #define.BATCRecordTypeCode  ('A - Record Type Code = "8"')

        file.write(#BATCRecord);
        file.write(#BATCBatchNumber);
        file.write(#BATCOriginatingDFI);
        file.write(#BATCReserved);
        file.write(#BATCAuthentication);
        file.write(#BATCCompanyID);
        file.write(#BATCCreditAmount);
        file.write(#BATCDebitAmount);
        file.write(#BATCEntryHash);
        file.write(#BATCAddendaCount);
        file.write(#BATCServiceClassCode);
        file.write(#BATCRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchHeaderFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This is a debug method that writes field alignment information to the output file to help verify
    ///    the data.
    /// </summary>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the 'DebugNACHA' macro in the
    ///    VendOutPaym_NACHA class declaration to true.
    /// </remarks>
    protected void addBatchHeaderFieldPositions()
    {
        #define.BATHRecord          ('ABBBCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEFFFGGGGGGGGGGHHHHHHIIIIIIJJJKLLLLLLLLMMMMMMM - BATCH HEADER RECORD')
        #define.BATHBatchNumber     ('                                                                                       MMMMMMM - Batch Number = "0000001"')
        #define.BATHOriginatingDFI  ('                                                                               LLLLLLLL - Orifinating DFI Identification')
        #define.BATHOriginStatusCode('                                                                              K - Originator Status Code = "1"')
        #define.BATHSettlementDate  ('                                                                           JJJ - Settlement Date [Julian] - ACH Operator Inserted')
        #define.BATHEffectiveDate   ('                                                                     IIIIII - Effective Entry Date [YYMMDD]')
        #define.BATHDescriptiveDate ('                                                               HHHHHH - Company Descriptive Date [MMDDYY]')
        #define.BATHEntryDescription('                                                     GGGGGGGGGG - Company Entry Description = "PAYABLES"')
        #define.BATHEntryClassCode  ('                                                  FFF - Standard Entry Class Code [CCD/PPD/CTX]')
        #define.BATHCompanyID       ('                                        EEEEEEEEEE - Company Identification')
        #define.BATHDiscData        ('                    DDDDDDDDDDDDDDDDDDDD - Company Discretionary Date')
        #define.BATHCompanyName     ('    CCCCCCCCCCCCCCCC - Company Name')
        #define.BATHServiceClassCode(' BBB - Service Class Code = "220" for Credits, "225" for Debits')
        #define.BATHRecordTypeCode  ('A - Record Type Code = "5"')

        file.write(#BATHRecord);
        file.write(#BATHBatchNumber);
        file.write(#BATHOriginatingDFI);
        file.write(#BATHOriginStatusCode);
        file.write(#BATHSettlementDate);
        file.write(#BATHEffectiveDate);
        file.write(#BATHDescriptiveDate);
        file.write(#BATHEntryDescription);
        file.write(#BATHEntryClassCode);
        file.write(#BATHCompanyID);
        file.write(#BATHDiscData);
        file.write(#BATHCompanyName);
        file.write(#BATHServiceClassCode);
        file.write(#BATHRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDetailRecord</Name>
				<Source><![CDATA[
    // This method should be called whenever a detail record is added to the NACHA EFt
    public void addDetailRecord(str 3 formatType, str bankRoutingNumber, AmountCur debitAmount, AmountCur creditAmount)
    {
        real        hash;
        #define.RoutingNumLen(9)
        #define.RoutingNumWOCheckDigitLen(8)

        recCount ++;
        totalDebitAmount += debitAmount;
        totalCreditAmount += creditAmount;
        numTransactions ++;

        if (numTransactions == 1)
        {
            fileFormat = formatType;
            file.writeExp(this.createBatchHeaderRecord());

            if (#DebugNACHA)
            {
                this.addBatchHeaderFieldPositions();
            }
        }

        // The routingHash is the sum of the bank routing numbers (first 8 digits) of each detail record.
        if (strLen(bankRoutingNumber) >= #RoutingNumLen)
        // Do not include the Check Digit from the Routing Number in the Hash Calculation
        {
            hash = str2num(subStr(bankRoutingNumber,1, #RoutingNumWOCheckDigitLen));
        }
        else
        {
            hash = str2num(bankRoutingNumber);
        }

        routingHash += hash;

        // If the value exceeds 9999999999, then the number is decremented by 10000000000
        if (routingHash >= #HashEntryMaximum)
        {
            routingHash -= #HashEntryMaximum;
        }

        if (#DebugNACHA)
        {
            this.addAlignment(#NACHARecLen);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGeneratePaymentLinesSort</Name>
				<Source><![CDATA[
    protected void addGeneratePaymentLinesSort(QueryRun _queryRun)
    {
        _queryRun.query().dataSourceTable(tablenum(LedgerJournalTrans)).addSortField(fieldnum(LedgerJournalTrans, RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addHeaderControlRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prints alignment markers and increments the record count when a header record (Control or Batch) is added to the output file, if the debug flag has been set.
    /// </summary>
    public void addHeaderControlRecord()
    {
        if (#DebugNACHA)
        {
            this.addAlignment(#NACHARecLen);
        }

        recCount ++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>close</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the batch control record, the ACH control record and, if it is specified, prints the control
    ///    report and payment advice.
    /// </summary>
    public void close()
    {
        file.writeExp(this.createBatchControlRecord());

        if (#DebugNACHA)
        {
            this.addBatchControlFieldPositions();
        }

        file.writeExp(this.createACH_ControlRecord());

        if (#DebugNACHA)
        {
            this.addACHControlFieldPositions();
        }

        this.createFillerRecordsToBlockTheFile();

        setPrefix(strFmt("@SYS73667", filename));                   // File name:
        info(strFmt("@SYS73668", numTransactions));                 // Number of transactions:
        info(strFmt("@SYS73670", totalCreditAmount, CompanyInfoHelper::standardCurrency()));

        if (printControlReport)
        {
            this.printControlReport();
        }

        if (printPaymAdvice)
        {
            this.printPaymAdvice();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFillerRecordsToBlockTheFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create filler lines to block the file.
    /// </summary>
    protected void createFillerRecordsToBlockTheFile()
    {
        numberOfBlockLines = CustVendOutPaymNACHA::createFillerRecordsToBlockTheFile(file, bankAccountTable, recCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>codepage</Name>
				<Source><![CDATA[
    protected int codepage()
    {
        #Localcodepage

        return #cp_1252;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createACH_ControlRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the ACH control record to the EFT output file.
    /// </summary>
    /// <returns>
    ///    A <c>container</c> that contains the ACH control record.
    /// </returns>
    //
    //  Entry Hash is calucated as follows:
    //      It is the sum of the values of the "Receiving DFI's" of the Detail Records (CCD, CTX, PPD)
    //      NOTE: Do NOT include the Check Digit from the Receiving DFI -- it is only the first 8 digits of the Routing Number.
    //
    protected container createACH_ControlRecord()
    {
        container   controlACH                  =   conNull();

        #define.recTypeCode('9')
        #define.batchCount('000001')
        #define.zero('0')
        #define.spc(' ')
        #define.NumTrxLength(8)
        #define.RoutingHashLength(10)
        #define.AmountLength(12)
        #define.BlockCountLength(6)

        str 1       recordTypeCode              = #recTypeCode;         // 01 - 01
        str 6       batchCount                  = #batchCount;          // 02 - 07      Will always be '000001' until we add support for payments for multiple companies
        str 6       blockCount                  = strRep(#zero, 6);     // 08 - 13
        str 8       entryAddendaCount           = strRep(#zero, 8);     // 14 - 21
        str 10      entryHash                   = strRep(#zero, 10);    // 22 - 31      Sum of the values of the "Receiving DFI's" of the Detail Records (First 8 digits of Routing Number only - Do NOT include the Check Digit)
        str 12      debitTotal                  = strRep(#zero, 12);    // 32 - 43
        str 12      creditTotal                 = strRep(#zero, 12);    // 44 - 55
        str 39      reserved                    = strRep(#spc, 39);     // 56 - 94

        this.addHeaderControlRecord();

        // A block is 940 characters... determine how many blocks exist in this EFT:
        if (((recCount * #NACHARecLen) mod #NACHABlockSize) != 0)
        {
            blockCount = num2Str0(((recCount * #NACHARecLen) div #NACHABlockSize) + 1, #BlockCountLength, 0, 0, 0);
        }
        else
        {
            blockCount = num2Str0(((recCount * #NACHARecLen) div #NACHABlockSize), #BlockCountLength, 0, 0, 0);
        }

        entryAddendaCount = num2Str0(numTransactions, #NumTrxLength);
        entryHash = num2Str0(routingHash, #RoutingHashLength);

        debitTotal = this.num2StrNACHA(totalDebitAmount, #AmountLength);
        creditTotal = this.num2StrNACHA(totalCreditAmount, #AmountLength);

        controlACH = conIns(controlACH, 1, recordTypeCode + batchCount + blockCount + entryAddendaCount +
                              entryHash + debitTotal + creditTotal + reserved);

        return controlACH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createACH_HeaderRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the ACH Header record to the EFT output file.
    /// </summary>
    /// <returns>
    ///    A container that contains the ACH Header record.
    /// </returns>
    protected container createACH_HeaderRecord()
    {
        container   headerACH                   =   conNull();

        #define.recTypeCode('1')
        #define.PriortyCode('01')
        #define.zero('0')
        #define.spc(' ')
        #define.formatCode('1')
        #define.bFactor('10')
        #define.recSize('094')
        #define.IdMod('A')
        #define.DateSeqYMD(321)
        #define.DateDay(2)
        #define.DateMonth(2)
        #define.DateYear(2)
        #define.DestBankNameLen(23)
        #define.OrigNameLen(23)
                                                                            // Offset           Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;           // 01 - 01          1
        str 2       priorityCode                =   #PriortyCode;           // 02 - 03          01
        str 10      immediateDestination        =   strRep(#zero, 10);      // 04 - 13                          bankAccount.RegistraionNum
        str 10      immediateOrigin             =   strRep(#zero, 10);      // 14 - 23                          bankAccount.CompanyPaymId
        str 6       fileCreationDate            =   strRep(#zero, 6);       // 24 - 29                          System Date
        str 4       fileCreationTime            =   strRep(#zero, 4);       // 30 - 33                          System Time (HHMM)
        str 1       fileIdModifier              =   #IdMod;                 // 34 - 34          a
        str 3       recordSize                  =   #recSize;               // 35 - 37          094
        str 2       blockingFactor              =   #bFactor;               // 38 - 39          10
        str 1       formatCode                  =   #formatCode;            // 40 - 40          1
        str 23      immediateDestinationName    =   strRep(#spc, 23);       // 41 - 63                          bankAccount.DestinationName - new field on Bank Accounts Form (aka Clearing Bank)
        str 23      immediateOriginName         =   strRep(#spc, 23);       // 64 - 86                          bankAccount.Name ==> custVendPaym.sendersBankName
        str 8       referenceCode               =   strRep(#spc, 8);        // 87 - 94          <BLANK>

        UtcDateTime creationDateTimeInUserTimeZone = DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), DateTimeUtil::getUserPreferredTimeZone());
        date creationDate = DateTimeUtil::date(creationDateTimeInUserTimeZone);
        TimeOfDay creationTime = DateTimeUtil::time(creationDateTimeInUserTimeZone);

        fileCreationDate = date2str(creationDate, #DateSeqYMD, #DateDay, 0, #DateMonth, 0, #DateYear,DateFlags::None); // YYMMDd
        fileCreationTime = this.time2StrHM_NA(creationTime); // HHMm

        bankAccountTable = BankAccountTable::find(this.parmBankAccountID());

        immediateDestination = #spc + this.getBankRoutingNumber(BankUSRoutingNumberFormat::WithCheckDigit);

        if (strLen(bankAccountTable.CompanyPaymId) <= 9)
        {
            // US Standard is for this to be 9 digits, preceeded by a space...
            immediateOrigin = #spc + bankAccountTable.CompanyPaymId;
        }
        else
        {
            // Bank of America uses the 9 digit standard, plus an ID, so all 10 digits must be provided
            immediateOrigin = bankAccountTable.CompanyPaymId;
        }

        immediateDestinationName = strLFix(bankAccountTable.BankDestinationName, #DestBankNameLen, #spc);
        immediateOriginName = strLFix(bankAccountTable.Name, #OrigNameLen, #spc);

        headerACH = conIns(headerACH, 1, recordTypeCode + priorityCode + immediateDestination + immediateOrigin +
                             fileCreationDate + fileCreationTime + fileIdModifier + recordSize + blockingFactor +
                             formatCode + immediateDestinationName + immediateOriginName + referenceCode);

        this.addHeaderControlRecord();
        return headerACH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchControlRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Batch Control record to the EFT output file.
    /// </summary>
    /// <returns>
    ///    A container that contains the Batch Control record.
    /// </returns>
    //
    //  Entry Hash is calucated as follows:
    //      It is the sum of the values of the "Receiving DFI's" of the Detail Records (CCD, CTX, PPD)
    //      NOTE: Do NOT include the Check Digit from the Receiving DFI -- it is only the first 8 digits of the Routing Number.
    //
    protected container createBatchControlRecord()
    {
        container   controlBatch                =   conNull();

        #define.recTypeCode('8')
        #define.classCode('220')
        #define.zero('0')
        #define.spc(' ')
        #define.batchNum('0000001')
        #define.NumTrxLen(6)
        #define.RoutingHashLen(10)
        #define.AmountLen(12)
        #define.CompPaymIdLen(10)
                                                                            // Offset           Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;           // 01 - 01          8
        str 3       serviceClassCode            =   #classCode;             // 02 - 04          220             220 when generated from Accounts Payable -> Means "Credits Only"
        str 6       entryAddendaCount           =   strRep(#zero, 6);       // 05 - 10                          Number of Detail Records
        str 10      entryHash                   =   strRep(#zero, 10);      // 11 - 20                          Sum of the values of the "Receiving DFI's" of the Detail Records (First 8 digits of Routing Number only - Do NOT include the Check Digit)
        str 12      totalDebitAmt               =   strRep(#zero, 12);      // 21 - 32                          Total of Debit entries
        str 12      totalCreditAmt              =   strRep(#zero, 12);      // 33 - 44                          Total of Credit entries
        str 10      companyId                   =   strRep(#zero, 10);      // 45 - 54                          bankAccount.CompanyId
        str 19      messageAuthenticationCode   =   strRep(#spc, 19);       // 55 - 73          <BLANK>
        str 6       reserved                    =   strRep(#spc, 6);        // 74 - 79          <BLANK>
        str 8       originatingDFI_Id           =   strRep(#zero, 8);       // 80 - 87                          bankAccount.RoutingNumber
        str 7       batchNumber                 =   #batchNum;              // 88 - 94          0000001

        entryAddendaCount = num2Str0(numTransactions, #NumTrxLen);
        entryHash = num2Str0(routingHash, #RoutingHashLen);
        totalDebitAmt = this.num2StrNACHA(totalDebitAmount, #AmountLen);
        totalCreditAmt = this.num2StrNACHA(totalCreditAmount, #AmountLen);

        companyId = subStr(bankAccountTable.CompanyPaymId + strRep(#spc, #CompPaymIdLen), 1, #CompPaymIdLen);

        originatingDFI_Id = this.getBankRoutingNumber(BankUSRoutingNumberFormat::WithoutCheckDigit);

        controlBatch = conIns(controlBatch, 1, recordTypeCode + serviceClassCode + entryAddendaCount + entryHash + totalDebitAmt + totalCreditAmt +
               companyId + messageAuthenticationCode + reserved + originatingDFI_Id + batchNumber);

        this.addHeaderControlRecord();
        return controlBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchHeaderRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Batch Header record to the Electronic Funds Transfer (EFT) output file.
    /// </summary>
    /// <returns>
    ///    A container that contains the Batch Header record.
    /// </returns>
    protected container createBatchHeaderRecord()
    {
        container   headerBatch                 =   conNull();

        #define.recTypeCode('5')
        #define.classCode('220')
        #define.one('1')
        #define.zero('0')
        #define.spc(' ')
        #define.discData('AX EFT DEPOSIT      ')
        #define.EntDesc('PAYABLES  ')
        #define.batchNum('0000001')
        #define.DateSeqMDY(213)
        #define.DateSeqYMD(321)
        #define.DateDay(2)
        #define.DateMonth(2)
        #define.DateYear(2)
        #define.CompStatementNameLen(16)
        #define.CompPaymIDLen(10)
                                                                            // Offset           Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;           // 01 - 01          5
        str 3       serviceClassCode            =   #classCode;             // 02 - 04          220             220 when generated from Accounts Payable -> Means "Credits Only"
        str 16      companyName                 =   strRep(#spc, 16);       // 05 - 20                          bankAccount.CompanyStatementName *NEW FIELD*
        str 20      companyDiscretionaryData    =   #discData;              // 21 - 40
        str 10      companyId                   =   strRep(#spc, 10);       // 41 - 50                          custVendPaym.SendersBanksIdentificationOfSender ~ bankAccount.CompanyId
        str 3       standardEntryClassCode      =   strRep(#spc, 3);        // 51 - 53                          CCD, CTX or PPD, depending on the payment.
        str 10      companyEntryDescription     =   #EntDesc;               // 54 - 63          PAYABLEs
        str 6       companyDescriptiveDate      =   strRep(#zero, 6);       // 64 - 69                          System Date
        str 6       effectiveEntryDate          =   strRep(#spc, 6);        // 70 - 75                          Default to System Date, but user will receive prompt to change
        str 3       settlementDate              =   strRep(#spc, 3);        // 76 - 78          BLANK           Julian Date inserted by ACH Operator
        str 1       originatorStatusCode        =   #one;                   // 79 - 79          1
        str 8       originationDFI_Id           =   strRep(#spc, 8);        // 80 - 87                          bankAccount.RoutingNumber
        str 7       batchNumber                 =   #batchNum;              // 88 - 94          0000001

        companyName = strLFix(bankAccountTable.BankCompanyStatementName, #CompStatementNameLen, #spc);
        companyId = strLFix(bankAccountTable.CompanyPaymId, #CompPaymIDLen, #spc);
        standardEntryClassCode = fileFormat;

        companyDescriptiveDate = date2str(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), #DateSeqMDY, #DateDay, 0, #DateMonth, 0, #DateYear, DateFlags::None);      // MMDDYy
        if (effectiveEntDate != dateNull())
        {
            effectiveEntryDate =  date2str(effectiveEntDate, #DateSeqYMD, #DateDay, 0, #DateMonth, 0, #DateYear, DateFlags::None);         // YYMMDd
        }

        originationDFI_Id = this.getBankRoutingNumber(BankUSRoutingNumberFormat::WithoutCheckDigit);

        headerBatch = conIns(headerBatch, 1, recordTypeCode + serviceClassCode + companyName + companyDiscretionaryData + companyId +
               standardEntryClassCode + companyEntryDescription + companyDescriptiveDate + effectiveEntryDate + settlementDate +
               originatorStatusCode + originationDFI_Id + batchNumber);

        this.addHeaderControlRecord();
        return headerBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendOutPaymRecordRootClassId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the class ID of the corresponding parent of the <c>CustVendOutPaymRecord</c> class.
    /// </summary>
    /// <returns>
    /// The class ID.
    /// </returns>
    /// <remarks>
    /// The class must be inherited from the <c>CustVendOutPaymRecord</c> class.
    /// </remarks>
    public classId custVendOutPaymRecordRootClassId()
    {
        return classNum(VendOutPaymRecord_NACHA);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    /// in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase  dialog = super();

        this.dialogAddFileName(dialog);

        dialogEffectiveEntryDate = dialog.addFieldValue(extendedTypeStr(DueDate), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), "@SYS8280");

        this.dialogAddPrintDocument(PaymDocumentType::ControlReport, dialog, true);
        this.dialogAddPrintDocument(PaymDocumentType::PaymAdvice, dialog, true, true, true);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankRoutingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the bank account routing number (registration number) in whatever format is requested.
    /// </summary>
    /// <param name="_format">
    ///    The format in which the routing number should be returned.
    /// </param>
    /// <returns>
    ///    The routing number in specified format.
    /// </returns>
    /// <remarks>
    ///    The format can be any of the following formats:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>With check digit (returns nine digits)</description>
    ///       </item>
    ///       <item>
    ///          <description>Without check digit (returns eight digits)</description>
    ///       </item>
    ///       <item>
    ///          <description>Check digit only (returns one digit)</description>
    ///       </item>
    ///       <item>
    ///          <description>Federal Reserve routing number (returns four digits)</description>
    ///       </item>
    ///       <item>
    ///          <description>ABA Institution Identifier (returns four digits)</description>
    ///       </item>
    ///    </list>
    ///     In the United States, the routing number must contain nine digits. The first four digits consist
    ///    of the Federal Reserve routing number; the next four digits are the ABA Institution Identifier
    ///    number; and the ninth digit is a check digit.
    /// </remarks>
    //  Return the Bank Routing (aka Registration) Number in the specified format:
    //
    //  The United States Bank Routing Number is made up as follows:
    //
    //                  TTTTAAAAc
    //
    //      T = Federal Reserve Routing Number
    //      A = ABA Institution Identifier
    //      C = Check Digit
    //
    //  US Routing Numbers are usually expressed as this entire number WITH the Check Digit
    //  The ACH Origin (Routing Number) contains a leading space, followed by the full Routing Number w/ Check Digit
    //
    public str getBankRoutingNumber(BankUSRoutingNumberFormat _format)
    {
        #define.ACHRoutingNumLen(10)
        #define.RoutingNumWOCheckDigitLen(8)
        #define.RoutingNumLen(9)
        #define.FedResLen(4)
        #define.ABAOffset(5)
        #define.ABALen(4)
        #define.ACHOffset(2)

        str         bankRoutingNumber;
        str         retRoutingNumber;

        bankRoutingNumber = bankAccountTable.RegistrationNum;

        if (strLen(bankRoutingNumber) == #RoutingNumWOCheckDigitLen)
        // If the Routing Number is stored without the Check Digit...
        {
            if (_format == BankUSRoutingNumberFormat::CheckDigitOnly || _format == BankUSRoutingNumberFormat::WithCheckDigit)
            {
                // And if they are requesting a format that includes the Check Digit, add it:
                bankRoutingNumber = bankRoutingNumber + num2str(Bank_US::calcRoutingNumberCheckDigit(bankRoutingNumber), 1, 0, 0, 0);
            }
        }

        if (strLen(bankRoutingNumber) == #ACHRoutingNumLen)
        {
            // If the Routing Number is stored in the ACH Format, remove the leading space
            bankRoutingNumber = subStr(bankRoutingNumber, #ACHOffset, #RoutingNumLen);
        }

        switch (_format)
        {
            case BankUSRoutingNumberFormat::WithCheckDigit:
                retRoutingNumber = bankRoutingNumber;
                break;

            case BankUSRoutingNumberFormat::WithoutCheckDigit:
                return subStr(bankRoutingNumber, 1, #RoutingNumWOCheckDigitLen);

            case BankUSRoutingNumberFormat::CheckDigitOnly:
                retRoutingNumber = subStr(bankRoutingNumber, #RoutingNumLen, 1);
                break;

            case BankUSRoutingNumberFormat::FederalReserveRoutingNumber:
                retRoutingNumber = subStr(bankRoutingNumber, 1, #FedResLen);
                break;

            case BankUSRoutingNumberFormat::ABA_InstitutionIdentifier:
                retRoutingNumber = subStr(bankRoutingNumber, #ABAOffset, #ABALen);
                break;
        }

        return retRoutingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        super();
        effectiveEntDate = dialogEffectiveEntryDate.value();
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextSequenceNumber</Name>
				<Source><![CDATA[
    public int getNextSequenceNumber()
    {
        sequenceNumber++;
        return sequenceNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCodeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for the NACHA transaction code.
    /// </summary>
    /// <param name = "_vendBankAccount">The vendor bank account.</param>
    /// <param name = "_eventHandlerResult">An <c>EventHandlerResult</c> where the transaction code can be returned.</param>
    static delegate void getTransactionCodeDelegate(VendBankAccount _vendBankAccount, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the transaction code used in the output file.
    /// </summary>
    /// <param name="_vendBankAccount">
    ///    The bank account type: either <c>BankAccountType::CheckingAccount</c> or
    ///    <c>BankAccountType::SavingsAccount</c>.
    /// </param>
    /// <returns>
    ///    If the bank account is neither <c>BankAccountType::CheckingAccount</c> nor
    ///    <c>BankAccountType::SavingsAccount</c>, the transaction code uses the code for checking
    ///    accounts.The transaction code of Accounts Payable Checking is 22.The transaction code of Accounts
    ///    Payable Savings is 32.
    /// </returns>
    // Return the approprite NACHA Transaction Code based on the Bank Account Type
    //
    // Transaction Codes:
    //
    // Module               Bank Account Type   Transaction Code Value
    // -------------------- ------------------- ----------------------
    // Accounts Payable     Checking            22
    // Accounts Payable     Savings             32
    // Accounts Receivable  Checking            27
    // Accounts Receivable  Savings             37
    //
    public int getTransactionCode(VendBankAccount _vendBankAccount)
    {
        #define.APChecking(22)
        #define.APSavings(32)

        int     transactionCode = #APChecking;           // Default to Checking Account

        switch (_vendBankAccount.BankAccountType)
        {
            case BankAccountType::CheckingAccount:
                transactionCode = #APChecking;
                break;

            case BankAccountType::SavingsAccount:
                transactionCode = #APSavings;
                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                VendOutPaym_NACHA::getTransactionCodeDelegate(_vendBankAccount, result);
                if (result.hasResult())
                {
                    transactionCode = result.result();
                }
                break;
        }

        return transactionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public boolean init()
    {
        boolean ret;

        ret = super();
        this.setEffectiveDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interfaceName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the format that is displayed in the user interface.
    /// </summary>
    /// <returns>
    /// The name of the format that is displayed in the user interface.
    /// </returns>
    /// <remarks>
    /// This method must return the name of the format that is displayed in the user interface. Formats
    /// without an interface name cannot be used in electronic banking as export formats. They can serve as
    /// parents for other formats.
    /// </remarks>
    public PaymInterfaceName interfaceName()
    {
        return 'NACHA (US)';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebug</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the DebugNACHA flag has been set. Currently, used to determine when to print
    ///    alignment and field position descriptions to the output file.
    /// </summary>
    /// <returns>
    ///    true if the DebugNACHA flag has been set; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    DebugNACHA should be used for testing only.
    /// </remarks>
    public boolean isDebug()
    {
        return #DebugNACHA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExportFormatNACHA</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the export format against the method of payment.
    /// </summary>
    /// <param name="_paymMode">
    ///    The unique ID for the method of payment.
    /// </param>
    /// <returns>
    ///    true if export format is NACHA (US); otherwise, false.
    /// </returns>
    protected boolean isExportFormatNACHA(VendPaymMode _paymMode)
    {
        VendPaymModeTable vendPaymModeTable = VendPaymModeTable::find(_paymMode);
        boolean ret = vendPaymModeTable.ClassId == classNum(VendOutPaym_NACHA);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>num2StrNACHA</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a currency value to the format '$$$$$$cc' where '$' represents a dollar value, and 'c'
    ///    represents the cents value, without a decimal.
    /// </summary>
    /// <param name="value">
    ///    The currency value.
    /// </param>
    /// <param name="lgth">
    ///    The length of the string to return. The string returned will be padded with leading '0' characters
    ///    if the length of the currency value is less than <paramref name="lgth" />.
    /// </param>
    /// <returns>
    ///    A string in the format '$$$$$$cc' where '$' represents a dollar value, and 'c' represents the cents
    ///    value, without a decimal.
    /// </returns>
    /// <remarks>
    ///    This is the required format for currency values in the NACHA file format specification.
    /// </remarks>
    // Convert a currency value to a string with the format $$$$$$cc
    public TempStr num2StrNACHA(real value, int  lgth)
    {
        str 100         curTxt;
        str             dollars;
        str             cents;

        #define.zero('0')
        #define.NumDecimals(2)
        #define.DecimalLen(3)

        // Decimal Separator must be either 1 (point) or 2 (comma) -- no option for NO decimal separator...
        curTxt = num2str(abs(value), 0, #NumDecimals, 1, 0);

        dollars = subStr(curTxt, 1, strLen(curTxt) - #DecimalLen);
        cents = subStr(curTxt, strLen(curTxt) - 1, #NumDecimals);
        curTxt = dollars + cents;

        return strRep(#zero, lgth - strLen(curTxt)) + curTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>open</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the media and creates the header of the media.
    /// </summary>
    /// <remarks>
    /// For example, creates a start record for a file.
    /// </remarks>
    public void open()
    {
        sequenceNumber = 0;

        // Open file for text-output
        file = CustVendOutPaym::newFile(this.codepage());

        if (!file || file.status() != IO_Status::Ok)
        {
            // Error opening the file
            throw error(strFmt("@SYS73665", filename));
        }

        file.writeExp(this.createACH_HeaderRecord());
        if (#DebugNACHA)
        {
            this.addACHHeaderFieldPositions();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList] + [super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the data required for <c>SysLastValues</c>.
    /// </summary>
    /// <returns>
    /// A container storing the data to be persisted by <c>SysLastValues</c>.
    /// </returns>
    /// <remarks>
    /// The pack and unpack pattern does not have provisions for supporting different serialization and
    /// <c>SysLastValues</c> pack lists. This separate packing mechanism has been implemented for
    /// <c>SysLastValues</c> and is first defined on the class from which the RunBase or RunBaseBatch
    /// classes inherit. Derivative classes also implement this method so that the whole object can be
    /// packed for <c>SysLastValues</c>.
    /// </remarks>
    public container packSysLastValues()
    {
        return [#SysLastValuesCurrentVersion, #SysLastValuesList, custVendPaymPrinterSettings.getAllPrinterSettingsPacked(), super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPaymAdvice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prints the Payment Advice report upon completion of generating the payment.
    /// </summary>
    /// <remarks>
    ///    The option to print the Payment Advice report is a check box in the dialog box when the user
    ///    selects to Generate Payments.
    /// </remarks>
    public void printPaymAdvice()
    {
        Args args = new Args();

        if (BankPaymAdviceReportV2FeatureExposure::isEnabled())
        {
            BankPaymAdviceDefaultParameters defaultParameters = BankPaymAdviceDefaultParameters::newForPaymAdvicePrintRun(
                this.getPaymRecords(),
                new SrsPrintDestinationSettings(this.getPrinterSettings(PaymDocumentType::PaymAdvice)),
                printPaymAdvicePrintMgmt);

            args.parmObject(defaultParameters);

            new MenuFunction(menuitemOutputStr(BankPaymAdviceVendV2), MenuItemType::Output).run(args);
        }
        else
        {
            args.caller(this);
            args.parmObject(this.getPaymRecords());
            args.parmEnumType(enumNum(NoYes));
            args.parmEnum(printPaymAdvicePrintMgmt);

            new MenuFunction(menuitemOutputStr(BankPaymAdviceVend), MenuItemType::Output).run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEffectiveDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the effective date of the transaction.
    /// </summary>
    /// <param name="effEntDate">
    ///    The effective date to set.
    /// </param>
    /// <remarks>
    ///    This method should be called whenever a detail record is added to the NACHA EFT.
    /// </remarks>
    // This method should be called whenever a detail record is added to the NACHA EFt
    public void setEffectiveDate(date effEntDate)
    {
        effectiveEntDate = effEntDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEffectiveEntryDate</Name>
				<Source><![CDATA[
    internal EffectiveDate parmEffectiveEntryDate(EffectiveDate _effectiveDate = effectiveEntDate)
    {
        effectiveEntDate = _effectiveDate;

        return effectiveEntDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>time2StrHM_NA</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a time to a string with the format of HHMM, where HH represents hours and MM represents
    ///    minutes, without a divider.
    /// </summary>
    /// <param name="_time">
    ///    The time in seconds.
    /// </param>
    /// <returns>
    ///    A string with the format of HHMM, where HH represents hours and MM represents minutes.
    /// </returns>
    /// <remarks>
    ///    This is the required format for time in the NACHA file format specification.
    /// </remarks>
    // Convert a Time to a string with the format "HHMM"
    public TempStr time2StrHM_NA(int _time)
    {
        #define.SecondsPerHour(3600)
        #define.SecondsPerMinute(60)
        #define.HourLen(2)
        #define.MinuteLen(2)

        return num2Str0(_time div #SecondsPerHour, #HourLen, 0, 0, 0) + num2Str0(_time mod #SecondsPerHour div #SecondsPerMinute, #MinuteLen, 0, 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container   base;
        boolean     ret;

        #LOCALMACRO.CurrentListV3
            fileName,
            printControlReport,
            effectiveEntDate
        #ENDMACRO
        #define.V3(3)

        #LOCALMACRO.CurrentListV4
            effectiveEntDate
        #ENDMACRO

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList, base] = _packedClass;
                ret = super(base);
                break;

            case 4 :
                [version, #CurrentListV4, base] = _packedClass;
                ret = super(base);
                break;

            case #V3 :
                [version, #CurrentListV3] = _packedClass;
                ret = true;
                break;

            default :
                ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the data required for <c>SysLastValues</c>.
    /// </summary>
    /// <param name="_packedValues">
    /// The values stored by the <c>SysLastValues</c> framework that are to be unpacked.
    /// </param>
    /// <remarks>
    /// The pack and unpack pattern does not have provisions for supporting different serialization and
    /// <c>SysLastValues</c> pack lists. This separate packing mechanism has been implemented for
    /// <c>SysLastValues</c> and is first defined on the class from which the RunBase or RunBaseBatch
    /// classes inherit.Derivative classes also implement this method so that a whole object can be
    /// unpacked for <c>SysLastValues</c>.
    /// </remarks>
    public void unpackSysLastValues(container _packedValues)
    {
        container baseClassPackedValues;
        container packedPrinterSettings;
        Version   version = RunBase::getVersion(_packedValues);

        switch (version)
        {
            case #SysLastValuesCurrentVersion:
                [version, #SysLastValuesList, packedPrinterSettings, baseClassPackedValues] = _packedValues;
                super(baseClassPackedValues);
                break;
        }
        if (packedPrinterSettings)
        {
            // Recreate the object from the packed values.
            custVendPaymPrinterSettings = CustVendPaymPrinterSettings::newForPackedPrinterSettings(packedPrinterSettings);
        }
        else
        {
            custVendPaymPrinterSettings = new CustVendPaymPrinterSettings();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the state of the internal variables.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called.
    /// </param>
    /// <returns>
    /// true if the internal variables are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method must validate the state of the internal variables. It is called before closing the
    /// dialog, and must be called in the <c>run</c> method.It must only contain code that adds warnings to
    /// the Infolog.A throw is not enabled within this method.The method returns errors using the
    /// <c>Global::CheckFailed</c> method.Export formats that are designed to handle only one method of
    /// payment per payment media must call the <c>checkUniquePaymMode</c> method.The default value of the
    /// <paramref name="_calledFrom" /> parameter is null.
    /// </remarks>
    public boolean validate(Object _calledFrom = null)
    {
        boolean ok = true;
        Bank    bank;

        bankAccountTable = BankAccountTable::find(accountId);
        if (!bankAccountTable)
        {
            ok = checkFailed(strFmt("@SYS26720", accountId));
        }

        else
        {
            ok = BankAccountTable::checkIsActive(bankAccountTable.AccountID);

            // Create a Bank validation object based on the bank's location
            bank = Bank::construct(SysCountryRegionCode::locationCountryInfo(bankAccountTable.Location));

            // Can only validate the routing number if the bank exists...
            ok = ok && bank.checkBankRegNum(bankAccountTable.RegistrationNum, bankAccountTable.BankCodeType);

            if (ok)
            {
                if (!bankAccountTable.BankCompanyStatementName)
                {
                    // The company statement name has not been setup for the bank account '%1'.
                    ok = checkFailed(strFmt("@SYS98118", bankAccountTable.AccountID));
                }

                if (!bankAccountTable.CompanyPaymId)
                {
                    // The company ID for electronic payment must be defined for the bank account %1.
                    ok = checkFailed(strFmt("@SYS72611", bankAccountTable.AccountID));
                }
            }
        }

        if (ok && (!filename))
        {
            ok = checkFailed("@SYS18624");
        }

        if (ok && file != null)
        {
            ok = file.Status() == IO_Status::Ok;
        }

        if (ok && !this.validatePrenote())
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePrenote</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates pre-notes for the transaction record.
    /// </summary>
    /// <returns>
    ///    true if validates,; otherwise, false.
    /// </returns>
    public boolean validatePrenote()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        boolean ret = true;

        if (this.isBankPrenote())
        {
            while select JournalNum, LedgerDimension, CustVendBankAccountId, PaymMode, AccountType, Company from ledgerJournalTrans where
            ledgerJournalTrans.JournalNum == ledgerJournalId
            {
                if (this.isElectronicPayment(ledgerJournalTrans.PaymMode))
                {
                    if (!this.isPrenoteApproved(accountId,ledgerJournalTrans.parmAccount()))
                    {
                        ret = checkFailed("@SYS128521");
                    }
                }
                else if (this.isExportFormatNACHA(ledgerJournalTrans.PaymMode))
                {
                    if (!this.isPrenoteApproved(accountId,ledgerJournalTrans.parmAccount()))
                    {
                        ret = (Box::okCancel(strFmt("@SYS128482",enum2str(this.getPaymentType(ledgerJournalTrans.PaymMode)),enum2str(PaymentType::ElectronicPayment)),DialogButton::Ok) == DialogButton::Ok);
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the description of the class.
    /// </summary>
    /// <returns>
    ///    The description of the class.
    /// </returns>
    public static ClassDescription description()
    {
        return new VendOutPaym_NACHA().interfaceName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>