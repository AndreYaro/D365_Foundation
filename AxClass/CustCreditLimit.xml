<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustCreditLimit</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustCreditLimit</c> class manages the credit limit excess calculation.
/// </summary>
public class CustCreditLimit
{
    boolean warning;

    boolean balanceInvoicedCalculated;
    boolean balanceDeliveredCalculated;
    boolean balanceNotInvoicedCalculated;
    boolean balanceEstimateCalculated;
    boolean balanceTotalsCalculated;
    boolean balanceInvoicedReportingCalculated;

    AmountMST addAmountMst; // part of current order
    AmountMST balanceInvoiced;
    AmountMST balanceDelivered;
    AmountMST balanceNotInvoiced;
    AmountMST balanceEstimate;
    AmountMST balanceTotals;
    AmountMSTSecondary balanceInvoicedReporting;

    ExchRate exchangeRate;
    CurrencyCode currency;
    CurrencyCode stdCurrency;

    CustParameters custParameters;
    CustTable custTable;

    TypeOfCreditmaxCheck typeOfCreditmaxCheck;

    SalesTotals salesTotals;
    SalesQuotationTotals salesQuotationTotals;
    // Variable to determine if the message should be displayed
    boolean displayMessage;
    str errorMessage;
    ParmId parmId;
    SalesId excludeSalesId;
    AmountMST balanceAdditional; // part of balance
    AmountMST mcrBalanceCredit;
    boolean checkAgreementLimit;
    AmountMST agreementCreditLimitMax;
    AgreementHeaderExtRecId_RU agreementHeaderExtRecId;
    TableId tableId;
    RecId recId;
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addAgreementCondition_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the agreement range.
    /// </summary>
    /// <param name="_ds">
    ///     Datasource where range will be applied to.
    /// </param>
    protected void addAgreementCondition_RU(QueryBuildDataSource _ds)
    {
        if (checkAgreementLimit)
        {
            Debug::assert(_ds.table() == tableNum(SalesTable_RU));
            _ds.addRange(fieldNum(SalesTable_RU, AgreementHeaderExt_RU)).value(queryValue(agreementHeaderExtRecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds an amount that was not previously specified to the value of the current sales order.
    /// </summary>
    /// <param name="_amountMST">
    ///    The amount to be added to the calculation; optional. This amount must be specified in the standard
    ///    currency.
    /// </param>
    /// <returns>
    ///    The amount to be added to the calculation.
    /// </returns>
    /// <remarks>
    ///    This is a set/get method; leave the parameter list blank for get.
    /// </remarks>
    AmountMST addAmountMST(AmountMST _amountMST = addAmountMst)
    {
        addAmountMst = _amountMST;
        return addAmountMst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementCheckInit_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes internal variables associated with agreement used in credit limit excess calculation.
    /// </summary>
    /// <param name="_agreementHeaderExtRecId">
    ///     Record ID of the agreement.
    /// </param>
    /// <param name="_tableId">
    ///     The table ID involved in settlement.
    /// </param>
    /// <param name="_recId">
    ///     The record ID involved in settlement.
    /// </param>
    public void agreementCheckInit_RU(AgreementHeaderExtRecId_RU _agreementHeaderExtRecId,
                                      tableId _tableId,
                                      recId _recId)
    {
        if (custParameters.AgreementCreditLine_RU)
        {
            checkAgreementLimit = true;
            if (_agreementHeaderExtRecId)
            {
                agreementCreditLimitMax = SalesAgreementHeaderExt_RU::find(_agreementHeaderExtRecId).CreditMax;
                agreementHeaderExtRecId = _agreementHeaderExtRecId;
                tableId = _tableId;
                recId = _recId;
            }
            else
            {
                agreementCreditLimitMax = custTable.CreditMax - SalesAgreementHeaderExt_RU::creditLimitPerCustAccount(custTable.AccountNum);
            }
        }
        else
        {
            agreementCreditLimitMax = this.getCurrentCreditMax();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>advanceInvAmts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets advance invoice transaction amounts.
    /// </summary>
    /// <returns>
    /// Returns common and reversal type transactions.
    /// </returns>
    private container advanceInvAmts()
    {
        CzCustAdvanceInvoiceTable advanceInvoice;

        select sum(InvoiceAmount) from advanceInvoice
            where advanceInvoice.OrderAccount == custTable.AccountNum
                && advanceInvoice.Type == AdvanceInvoiceType_W::Reversal;

        AmountMST reverseAdvanceInvoiceAmt = advanceInvoice.InvoiceAmount;

        select sum(InvoiceAmount) from advanceInvoice
            where advanceInvoice.OrderAccount == custTable.AccountNum
                && advanceInvoice.Type == AdvanceInvoiceType_W::Common;

        AmountMST advanceInvoiceAmt = advanceInvoice.InvoiceAmount;

        return [reverseAdvanceInvoiceAmt,advanceInvoiceAmt];
    }

]]></Source>
			</Method>
			<Method>
				<Name>balance</Name>
				<Source><![CDATA[
    container balance()
    {
        AmountMST balance;
        AmountMST orderBalance;

        if (custTable.MandatoryCreditLimit && typeOfCreditmaxCheck == TypeOfCreditmaxCheck::None)
        {
            typeOfCreditmaxCheck = TypeOfCreditmaxCheck::Balance;
        }

        if (typeOfCreditmaxCheck != TypeOfCreditmaxCheck::None)
        {
            orderBalance = this.addAmountMST() + this.balanceTotals();
            if (isConfigurationkeyEnabled(configurationKeyNum(Retail)) &&
                RetailParameters::isRetailInUse() // if retail functionality is used within the current LE
                )
            {
                balance = this.rboTransactionBalance();
            }

            if (this.canAmountAddedToBalanceBasedOnTypeOfCreditmaxCheck())
            {
                balance += this.amountAddedToBalanceBasedOnTypeOfCreditmaxCheck();
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoPL]) &&  this.shouldCheckCreditAvailable())
            {
                AmountMST reverseAdvanceInvoiceAmt;
                AmountMST advanceInvoiceAmt;

                [reverseAdvanceInvoiceAmt, advanceInvoiceAmt] = this.advanceInvAmts();
                balance += -(reverseAdvanceInvoiceAmt + advanceInvoiceAmt);
            }
        }

        return [balance, orderBalance];
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountAddedToBalanceBasedOnTypeOfCreditmaxCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the amount that needs to be added to the customer balance based on the <c>TypeOfCreditmaxCheck</c> setting.
    /// </summary>
    /// <returns>The amount that needs to be added to the customer balance.</returns>
    protected AmountMST amountAddedToBalanceBasedOnTypeOfCreditmaxCheck()
    {
        AmountMST amountToAdd;

        switch (this.typeOfCreditMaxCheck())
        {
            case TypeOfCreditmaxCheck::Balance :
                amountToAdd = this.balanceInvoiced();
                break;

            case TypeOfCreditmaxCheck::BalanceDelivered :
                amountToAdd = this.balanceInvoiced() + this.balanceDelivered();
                break;

            case TypeOfCreditmaxCheck::BalanceAll :
                amountToAdd = this.balanceInvoiced() + this.balanceNotInvoiced();
                break;
        }

        return amountToAdd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceAdditional</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a previously unspecified value to the Open balance amount.
    /// </summary>
    /// <param name="_balanceAdditional">
    ///    The amount to be added to the calculation; optional. This amount must be specified in the standard currency.
    /// </param>
    /// <returns>
    ///    The value to add to the Open balance amount.
    /// </returns>
    /// <remarks>
    ///    This is a Get/Set method; leave the parameter list blank for Get.
    /// </remarks>
    AmountMST balanceAdditional(AmountMST _balanceAdditional = balanceAdditional)
    {
        balanceAdditional = _balanceAdditional;
        return balanceAdditional;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceDelivered</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the amount of an outstanding packing slip that has not yet been invoiced.
    /// </summary>
    /// <param name="_balanceDelivered">
    ///    An open sales order amount; optional.
    /// </param>
    /// <returns>
    ///    The amount of an outstanding packing slip that has not yet been invoiced.
    /// </returns>
    /// <remarks>
    ///    If possible, the method will use the stored sales totals in the SalesTable.Estimate field. If that
    ///    field does not store the correct amount (specified by the CustParameters.CreditMaxCheck field, the
    ///    total will be calculated by calculating all the applicable sales orders individually. That takes a
    ///    much longer time than using the SalesTable.Estimate field.
    /// </remarks>
    AmountMST balanceDelivered(AmountMST _balanceDelivered = balanceDelivered)
    {
        if (!prmisDefault(_balanceDelivered))
        {
            balanceDelivered = _balanceDelivered;
            balanceDeliveredCalculated = true;
        }
        else
        {
            if (!balanceDeliveredCalculated)
            {
                balanceDelivered = this.calcBalanceDelivered();
                balanceDeliveredCalculated = true;
            }
        }

        return balanceDelivered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBalanceDelivered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of an outstanding packing slip that has not yet been invoiced.
    /// </summary>
    /// <returns>
    /// The amount of an outstanding packing slip that has not yet been invoiced.
    /// </returns>
    protected AmountMST calcBalanceDelivered()
    {
        AmountMST balanceDeliveredCalc;

        if (this.typeOfCreditMaxCheck() == TypeOfCreditmaxCheck::BalanceDelivered
            && this.useEstimated())
        {
            balanceDeliveredCalc = this.balanceEstimate();
        }
        else
        {
            balanceDeliveredCalc = this.calculateBalance(SalesUpdate::PackingSlip);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // Adjust the amount based on payments.
            balanceDeliveredCalc -= this.MCRBalanceCreditCard();
        }

        return balanceDeliveredCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total estimated amount for the specific invoice account.
    /// </summary>
    /// <param name="_balanceEstimate">
    ///    The estimated amount; optional.
    /// </param>
    /// <returns>
    ///    The total estimated amount for the specific invoice account.
    /// </returns>
    /// <remarks>
    ///    Depending on the <c>CustParameters.CreditMaxCheck</c> parameter, the value that is returned is
    ///    either the total amount delivered (packing slip updated) or all of the sales orders. Invoiced
    ///    amounts are not part of the returned values regardless of the parameter.After the field is
    ///    calculated, a flag will be set making sure the value is not calculated every time that the method
    ///    is called.
    /// </remarks>
    AmountMST balanceEstimate(AmountMST _balanceEstimate = balanceEstimate)
    {
        if (!prmisdefault(_balanceEstimate))
        {
            balanceEstimate = _balanceEstimate;
            balanceEstimateCalculated = true;
        }
        else
        {
            balanceEstimate = this.calculateBalanceEstimate();
        }

        return balanceEstimate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total amount in the standard currency that is currently open (posted) on the customer.
    /// </summary>
    /// <param name="_balanceInvoiced">
    ///    The specified open amount; optional.
    /// </param>
    /// <returns>
    ///    The total amount in the standard currency that is currently open (posted) on the customer.
    /// </returns>
    AmountMST balanceInvoiced(AmountMST _balanceInvoiced = balanceInvoiced)
    {
        if (!prmisDefault(_balanceInvoiced))
        {
            balanceInvoiced = _balanceInvoiced;
            balanceInvoicedCalculated = true;
        }
        else
        {
            if (!balanceInvoicedCalculated)
            {
                // <GEERU>
                balanceInvoiced = checkAgreementLimit ? custTable.openBalanceMSTPerAgreement_RU(AgreementHeaderExt_RU::find(agreementHeaderExtRecId).AgreementId) :
                                                        custTable.openBalanceMST();
                // </GEERU>
                balanceInvoicedCalculated = true;
            }
        }

        return balanceInvoiced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceInvoicedReporting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total amount in the reporting currency that is currently open (posted) on the customer.
    /// </summary>
    /// <param name="_balanceInvoicedReporting">
    ///    The specified open amount in reporting currency; optional.
    /// </param>
    /// <returns>
    ///    The total amount in the reporting currency that is currently open (posted) on the customer.
    /// </returns>
    public AmountMSTSecondary balanceInvoicedReporting(AmountMSTSecondary _balanceInvoicedReporting = balanceInvoicedReporting)
    {
        if (!prmisDefault(_balanceInvoicedReporting))
        {
            balanceInvoicedReporting = _balanceInvoicedReporting;
            balanceInvoicedReportingCalculated = true;
        }
        else
        {
            if (!balanceInvoicedReportingCalculated)
            {
                balanceInvoicedReporting =  custTable.openBalanceMSTSecondary();
                balanceInvoicedReportingCalculated = true;
            }
        }

        return balanceInvoicedReporting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceMarked_RU</Name>
				<Source><![CDATA[
    public AmountMST balanceMarked_RU()
    {
        AmountMST balanceMarked;
        SpecTrans specTrans;
        CustTrans custTrans;
        CustVendSettle custVendSettle;
        SettleDatePrinc currentDatePrinciple;
        TransDate settleDate;
        Query query;
        QueryBuildDataSource qbds;
        QueryRun qr;
        RefRecId agreementClassificationId;
        RecId dimAttrRecId = AgreementHeaderExt_RU::getAgreementDimensionAttribute();

        if (!dimAttrRecId)
        {
            return 0;
        }

        custVendSettle = CustVendSettle::construct(SysModule::Cust);
        currentDatePrinciple = CustVendSettle::construct(SysModule::Cust).datePrinciple();

        agreementClassificationId = AgreementHeaderExt_RU::agreementHeader(agreementHeaderExtRecId).AgreementClassification;

        query = new Query();
        qbds = query.addDataSource(tableNum(specTrans));
        qbds.addRange(fieldNum(specTrans, SpecTableId)).value(queryValue(TableId));
        qbds.addRange(fieldNum(specTrans, SpecRecId)).value(queryValue(recId));
        qbds.addSelectionField(fieldNum(specTrans, Balance01));

        qbds = qbds.addDataSource(tableNum(custTransOpen));
        qbds.addLink(fieldNum(specTrans, RefTableId), fieldnum(custTransOpen, TableId));
        qbds.addLink(fieldNum(specTrans, RefRecId), fieldnum(custTransOpen, RecId));
        qbds.addRange(fieldNum(custTransOpen, AmountCur)).value('..0');
        qbds.addSelectionField(fieldNum(custTransOpen, TableId));

        qbds = qbds.addDataSource(tableNum(custTrans));
        qbds.addLink(fieldNum(custTransOpen, RefRecId), fieldnum(CustTrans, RecId));
        qbds.addSelectionField(fieldNum(custTrans, CurrencyCode));
        qbds.addSelectionField(fieldNum(custTrans, TransDate));

        DimensionAttribute dimAttribute = DimensionAttribute::find(dimAttrRecId);
        DimensionProvider dimProvider = new DimensionProvider();
        dimProvider.addDataSourceToQuery(
            query,
            qbds.name(),
            fieldStr(custTrans, DefaultDimension),
            DimensionComponent::DimensionAttribute,
            dimAttribute.Name);

        qr = new QueryRun(query);
        while (qr.next())
        {
            str dimValue = dimProvider.getDimensionValueFromQueryRun(
                qr,
                qbds.name(),
                fieldStr(custTrans, DefaultDimension),
                DimensionComponent::DimensionAttribute,
                dimAttribute.Name);

            if (dimValue && SalesAgreementHeader::findAgreementId(dimValue).AgreementClassification != agreementClassificationId)
            {
                continue;
            }

            specTrans = qr.get(tableNum(specTrans));
            custTrans = qr.get(tableNum(custTrans));

            switch (currentDatePrinciple)
            {
                case SettleDatePrinc::DaysDate:
                    settleDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    break;
                case SettleDatePrinc::SelectDate:
                    settleDate = custVendSettle.saveDate();
                    break;
                case SettleDatePrinc::DateOfPayment:
                    settleDate = custTrans.TransDate;
                    break;
            }

            balanceMarked += CurrencyExchangeHelper::amountCur2MST(specTrans.Balance01, custTrans.CurrencyCode, 0, settleDate);
        }

        return -balanceMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceNotInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the amount of open sales orders including the delivered (packing slip updated) amounts.
    /// </summary>
    /// <param name="_balanceNotInvoiced">
    ///    An open sales order amount; optional.
    /// </param>
    /// <returns>
    ///    The amount of open sales orders including delivered (packing slip updated) amounts.
    /// </returns>
    /// <remarks>
    ///    If possible, the method will use the stored sales totals in the SalesTable.Estimate field. If that
    ///    field does not store the correct amount (as specified by the CustParameters.CreditMaxCheck field),
    ///    the total will be calculated by calculating all the applicable sales orders individually. That
    ///    takes a much longer time than using the SalesTable.Estimate field.
    /// </remarks>
    AmountMST balanceNotInvoiced(AmountMST _balanceNotInvoiced = balanceNotInvoiced)
    {
        if (!prmisDefault(_balanceNotInvoiced))
        {
            balanceNotInvoiced = _balanceNotInvoiced;
            balanceNotInvoicedCalculated = true;
        }
        else
        {
            if (!balanceNotInvoicedCalculated)
            {
                balanceNotInvoiced = this.calcBalanceNotInvoiced();
                balanceNotInvoicedCalculated = true;
            }
        }

        return balanceNotInvoiced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBalanceNotInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of open sales orders including the delivered (packing slip updated) amounts.
    /// </summary>
    /// <returns>
    /// The amount of open sales orders including delivered (packing slip updated) amounts.
    /// </returns>
    protected AmountMST calcBalanceNotInvoiced()
    {
        AmountMST balanceNotInvoicedCalc;

        if (this.typeOfCreditMaxCheck() == TypeOfCreditmaxCheck::BalanceAll
            && this.useEstimated())
        {
            balanceNotInvoicedCalc = this.balanceEstimate();
        }
        else
        {
            balanceNotInvoicedCalc = this.calculateBalance(SalesUpdate::All);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // Adjust the amount based on payments.
            balanceNotInvoicedCalc -= this.MCRBalanceCreditCard();
        }

        return balanceNotInvoicedCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the balance of the <c>SalesTotals</c> class, if any is specified.
    /// </summary>
    /// <returns>
    ///    The balance of the <c>SalesTotals</c> class.
    /// </returns>
    AmountMST balanceTotals()
    {
        if (!balanceTotalsCalculated && salesTotals)
        {
            using (var taxIntegrationSkipUpdateContext = TaxIntegrationSkipUpdateContext::getInstance())
            {
                if (!TaxIntegrationConstructWithSourceRecordFlight::instance().isEnabled())
                {
                    taxIntegrationSkipUpdateContext.parmSkipUpdate(true);
                }

                balanceTotals = CurrencyExchangeHelper::mstAmount(salesTotals.totalAmount(), salesTotals.currencyCode(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), UnknownNoYes::Unknown, salesTotals.exchRate());
                balanceTotalsCalculated = true; //totals itself has this mechanism build-in, but this makes the methods of the class consistent
            }
        }
        return balanceTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCreditAvailable</Name>
				<Source><![CDATA[
    AmountMST calcCreditAvailable()
    {
        AmountMST creditAvailable;
        AmountMST balance;
        AmountMST orderBalance;

        if (this.shouldCheckCreditAvailable())
        {
            [balance, orderBalance] = this.balance();

            creditAvailable = this.getCurrentCreditMax() - (balance + orderBalance);
        }

        return creditAvailable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// The total sales order amount.
    /// </summary>
    /// <param name="_salesTotals">The class instance of <c>SalesTotals</c>.</param>
    /// <param name="_salesTable">The record of <c>SalesTable</c> buffer.</param>
    /// <returns>
    /// returns the sales order total amount.
    /// </returns>
    protected AmountCur getSalesTotalAmount(SalesTotals _salesTotals, SalesTable _salesTable)
    {
        AmountCur totalAmount = _salesTotals.totalAmount();

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBalance</Name>
				<Source><![CDATA[
    [Replaceable]
    protected AmountMST calculateBalance(SalesUpdate _salesUpdate)
    {
        AmountMST balance;

        var queryRun = new QueryRun(this.initQuery());
        while (queryRun.next())
        {
            if (queryRun.changed(tablenum(SalesTable)))
            {
                SalesTable localSalesTable = queryRun.get(tablenum(SalesTable));
                SalesTotals localSalesTotals = SalesTotals::construct(localSalesTable, _salesUpdate);
                balance += CurrencyExchangeHelper::mstAmount(this.getSalesTotalAmount(localSalesTotals, localSalesTable), localSalesTable.CurrencyCode);
            }
        }

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBalanceEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a total estimated amount for the specific invoice account.
    /// </summary>
    /// <returns>
    /// A total estimated amount for the specific invoice account.
    /// </returns>
    [Replaceable]
    protected AmountMST calculateBalanceEstimate()
    {
        AmountMST balance;

        var queryRun = new QueryRun(this.initQuery());
        queryRun.query().dataSourceTable(tablenum(SalesTable)).fields().addField(fieldnum(SalesTable, Estimate), SelectionField::Sum);

        while (queryRun.next())
        {
            if (queryRun.changed(tablenum(SalesTable)))
            {
                SalesTable localSalesTable = queryRun.get(tablenum(SalesTable));
                balance += localSalesTable.Estimate;
            }
        }

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the actual credit limit excess check.
    /// </summary>
    /// <returns>
    ///    false if the credit limit is exceeded; otherwise, true.
    /// </returns>
    /// <remarks>
    ///    The method returns false if the credit limit is exceeded, regardless of the warning flag. It is up
    ///    to the caller to determine the consequences of an exceeded credit.
    /// </remarks>
    public boolean check()
    {
        boolean ret = true;
        AmountMST balance;
        AmountMST orderBalance;

        if (this.shouldCheckCreditAvailable())
        {
            [balance, orderBalance] = this.balance();

            // The value mcrBalanceCredit is used in the credit limit work benches.
            mcrBalanceCredit = balance + orderBalance;

            ret = this.checkGivenBalances(balance, orderBalance);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkGivenBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the actual credit limit excess check, based on given balance information.
    /// </summary>
    /// <param name = "_balance">The current balance.</param>
    /// <param name = "_orderBalance">The balance of the order.</param>
    /// <returns>
    ///    The method returns false if the credit limit is exceeded, regardless of the warning flag. It is up
    ///    to the caller to determine the consequences of an exceeded credit.
    /// </returns>
    protected boolean checkGivenBalances(AmountMST _balance, AmountMST _orderBalance)
    {
        boolean ret = true;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && checkAgreementLimit)
        {
            if (_balance + _orderBalance > agreementCreditLimitMax + this.balanceMarked_RU())
            {
                ret = this.showErrorMsg(_balance, _orderBalance);
            }
        }
        else
        {
            // </GEERU>
            if (_balance + _orderBalance > this.getCurrentCreditMax() && _orderBalance > 0)
            {
                ret = this.showErrorMsg(_balance, _orderBalance);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currency</Name>
				<Source><![CDATA[
    CurrencyCode currency(CurrencyCode _currency = currency)
    {
        currency = _currency;
        return currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custParameters</Name>
				<Source><![CDATA[
    CustParameters custParameters()
    {
        return custParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTable</Name>
				<Source><![CDATA[
    CustTable custTable()
    {
        return custTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchangeRate</Name>
				<Source><![CDATA[
    ExchRate exchangeRate(ExchRate _exchangeRate = exchangeRate)
    {
        exchangeRate = _exchangeRate;
        return exchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates balance tat will be used against the credit limit when the credit check is done.
    /// </summary>
    /// <returns>
    /// A balance calculated based on the type of credit check performed.
    /// </returns>
    public AmountMST getBalance()
    {
        AmountMST balance;

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)) &&
            RetailParameters::isRetailInUse() // if retail functionality is used within the current LE
            )
        {
            balance = this.rboTransactionBalance();

            // Set typeOfCreditmaxCheck as balance to display customer balance in UI, either RetailUseCreditLimitTypeConfigForCustomerBalance (flighting logic) 
            // or RetailUseCreditLimitTypeConfigForCustomerBalanceFeature (feature)is disabled.
            if (!RetailUseCreditLimitTypeConfigForCustomerBalance::instance().isEnabled() ||
                !FeatureStateProvider::isFeatureEnabled(RetailUseCreditLimitTypeConfigForCustomerBalanceFeature::instance()))
            {
                typeOfCreditmaxCheck = TypeOfCreditmaxCheck::Balance;
            }

        }

        balance += this.amountAddedToBalanceBasedOnTypeOfCreditmaxCheck();
        
        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the variables of the class.
    /// </summary>
    /// <remarks>
    ///    When the class is instantiated, the <c>new</c> method will automatically be run all the way from
    ///    the instantiated class up to the parent class. This may not be convenient, as the child class may
    ///    not want to have the parent class initialization run. The <c>init</c> method is only called one
    ///    time.
    /// </remarks>
    public void init()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    protected Query initQuery(SalesId _excludeSalesId = '')
    {
        Query query = new Query();
        QueryBuildDataSource qbdsSalesTable = query.addDataSource(tableNum(SalesTable));
        qbdsSalesTable.addRange(fieldNum(SalesTable, InvoiceAccount)).value(queryValue(custTable.AccountNum));
        qbdsSalesTable.addRange(fieldNum(SalesTable, SalesStatus)).value(SalesQueryRangeUtil::salesStatusCanBeInvoiced());

        if (!RetailIncludeOnHoldOrdersDuringCreditLimitCalculationToggle::instance().isEnabled())
        {
            if (RetailMCRChannelTable::mcrEnableOrderCompletionFindByUser())
            {
                qbdsSalesTable.addRange(fieldNum(SalesTable, MCROrderStopped)).value(queryValue(NoYes::No));
            }
        }

        qbdsSalesTable.addRange(fieldNum(SalesTable,SalesType)).value(queryRangeConcat(queryRangeConcat(queryValue(SalesType::Subscription), SalesType::Sales), SalesType::ReturnItem));

        if (_excludeSalesId)
        {
            //if called for SalesTable/SalesLine/SalesParmTable buffers for BalanceAll/BalanceDelivered current order must be excluded as totalAmount is already a part of orderBalance, other types should have excludeSalesId criteria blank
            qbdsSalesTable.addRange(fieldNum(SalesTable, SalesId)).value(SysQuery::valueNot(_excludeSalesId));
        }

        #ISOCountryRegionCodes
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            QueryBuildDataSource ds = SalesTable_RU::addToQuery(qbdsSalesTable);
            this.addAgreementCondition_RU(ds);
        }

        //For BalanceDelivered additionally consider only orders that have delivered quantity
        if (typeOfCreditmaxCheck == TypeOfCreditmaxCheck::BalanceDelivered)
        {
            QueryBuildDataSource qbdsSalesLine = qbdsSalesTable.addDataSource(tableNum(SalesLine));
            qbdsSalesLine.relations(true);
            qbdsSalesLine.joinMode(JoinMode::ExistsJoin);
            qbdsSalesLine.addRange(fieldNum(SalesLine, RemainSalesFinancial)).value(SysQuery::valueNot(0));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStdCurrency</Name>
				<Source><![CDATA[
    private boolean isStdCurrency()
    {
        return (currency == stdCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrBalanceCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the full on-credit balance.
    /// </summary>
    /// <returns>
    /// The full on-credit balance.
    /// </returns>
    AmountMST mcrBalanceCredit()
    {
        return mcrBalanceCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrBalanceCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the unposted, non-prepay credit card balance.
    /// </summary>
    /// <returns>
    /// The unposted, non-prepay credit card balance.
    /// </returns>
    AmountMST mcrBalanceCreditCard()
    {
        AmountMST balanceCreditCard;
        SalesTable localSalesTable;
        SalesLine localSalesLine;
        MCRCustPaymTable mcrCustPaymTable;

        if (this.typeOfCreditMaxCheck() == TypeOfCreditmaxCheck::BalanceDelivered)
        {
            select sum(Amount), sum(PostedAmount) from mcrCustPaymTable
                where mcrCustPaymTable.RefTableId == tableNum(SalesTable)
                    && mcrCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard
                    && mcrCustPaymTable.IsPrepay == NoYes::No
                exists join localSalesTable
                where mcrCustPaymTable.RefRecId == localSalesTable.RecId
                    && localSalesTable.InvoiceAccount == custTable.AccountNum
                    && (localSalesTable.SalesStatus == SalesStatus::None
                    || localSalesTable.SalesStatus == SalesStatus::Backorder
                    || localSalesTable.SalesStatus == SalesStatus::Delivered)
                    && (localSalesTable.SalesType == SalesType::Subscription
                        || localSalesTable.SalesType == SalesType::Sales
                        || localSalesTable.SalesType == SalesType::ReturnItem)
                    && localSalesTable.SalesId != excludeSalesId
                    && localSalesTable.MCROrderStopped == NoYes::No
                exists join localSalesLine
                where localSalesLine.SalesId == localSalesTable.SalesId
                    && localSalesLine.RemainSalesFinancial != 0;

            balanceCreditCard = mcrCustPaymTable.Amount - mcrCustPaymTable.PostedAmount;
        }
        else
        {
            select sum(Amount), sum(PostedAmount) from mcrCustPaymTable
                where mcrCustPaymTable.RefTableId == tableNum(SalesTable)
                    && mcrCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard
                    && mcrCustPaymTable.IsPrepay == NoYes::No
                exists join localSalesTable
                where mcrCustPaymTable.RefRecId == localSalesTable.RecId
                    && localSalesTable.InvoiceAccount == custTable.AccountNum
                    && (localSalesTable.SalesStatus == SalesStatus::None
                    || localSalesTable.SalesStatus == SalesStatus::Backorder
                    || localSalesTable.SalesStatus == SalesStatus::Delivered)
                    && (localSalesTable.SalesType == SalesType::Subscription
                        || localSalesTable.SalesType == SalesType::Sales
                        || localSalesTable.SalesType == SalesType::ReturnItem)
                    && localSalesTable.SalesId != excludeSalesId
                    && localSalesTable.MCROrderStopped == NoYes::No;

            balanceCreditCard = mcrCustPaymTable.Amount - mcrCustPaymTable.PostedAmount;
        }

        return balanceCreditCard;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDisplayMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether or not the error message should be displayed directly from here.
    /// </summary>
    /// <param name="_displayMessage">
    /// A <c>Boolean</c> indicating whether or not to display the error message.
    /// </param>
    /// <returns>
    /// true of the error message should be displayed; otherwise, false.
    /// </returns>
    boolean mcrDisplayMessage(boolean _displayMessage = displayMessage)
    {
        displayMessage = _displayMessage;
        return displayMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetErrorMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the error message.
    /// </summary>
    /// <returns>
    /// stored error message.
    /// </returns>
    str mcrGetErrorMessage()
    {
        return errorMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(CustTable _custTable)
    {
        custTable = _custTable;
        custParameters = CustParameters::find();

        // Set defaults
        typeOfCreditmaxCheck = custParameters.CreditMaxCheck;
        warning = custParameters.CreditLineError == CreditLineErrorType::Warning;
        currency = CompanyInfoHelper::standardCurrency();
        exchangeRate = ExchangeRateHelper::exchRate(currency);
        stdCurrency = currency;

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            //Set the display message variable to true
            displayMessage = true;
        }

        this.init();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckAgreementLimit_RU</Name>
				<Source><![CDATA[
    public boolean parmCheckAgreementLimit_RU(boolean _checkAgreementLimit = checkAgreementLimit)
    {
        checkAgreementLimit = _checkAgreementLimit;
        return checkAgreementLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the error message.
    /// </summary>
    /// <param name = "_errorMessage">The error message.</param>
    /// <returns>The error message value.</returns>
    public str parmErrorMessage(str _errorMessage = errorMessage)
    {
        errorMessage = _errorMessage;
        return errorMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rboTransactionBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the transaction balance.
    /// </summary>
    /// <returns>
    /// The transaction balance amount.
    /// </returns>
    public AmountMST rboTransactionBalance()
    {
        //Subtract the payed (deposit) amount sum from the sales amount sum
        return (this.retailCustomerAccountSalesAmount() - this.retailCustomerAccountPaidDepositAmount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailCustomerAccountPaidDepositAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the customer account paid deposit.
    /// </summary>
    /// <returns>
    /// The customer account paid deposit amount.
    /// </returns>
    public AmountMST retailCustomerAccountPaidDepositAmount()
    {
        RetailTransactionPaymentTrans                   retailTransactionPaymentTrans;
        RetailTransactionTable                          retailTransactionTable;
        RetailTransactionCustomerAccountDepositTrans    retailTransactionCustomerAccountDepositTrans;

        // calculating amount of customer account deposit
        select sum(amountTendered) from retailTransactionPaymentTrans
            where   (
                    retailTransactionPaymentTrans.transactionStatus == RetailEntryStatus::None
                ||  retailTransactionPaymentTrans.transactionStatus == RetailEntryStatus::Concluded
                ||  retailTransactionPaymentTrans.transactionStatus == RetailEntryStatus::OnHold
                )
            exists join retailTransactionTable
                where   retailTransactionTable.store         == retailTransactionPaymentTrans.store
                    &&  retailTransactionTable.terminal      == retailTransactionPaymentTrans.terminal
                    &&  retailTransactionTable.transactionId == retailTransactionPaymentTrans.transactionId
                    &&  retailTransactionTable.entryStatus   == RetailEntryStatus::None
                    &&  retailTransactionTable.type          == RetailTransactionType::Payment
            exists join retailTransactionCustomerAccountDepositTrans
                where   retailTransactionCustomerAccountDepositTrans.store               == retailTransactionTable.store
                    &&  retailTransactionCustomerAccountDepositTrans.terminal            == retailTransactionTable.terminal
                    &&  retailTransactionCustomerAccountDepositTrans.transactionId       == retailTransactionTable.transactionId
                    &&  retailTransactionCustomerAccountDepositTrans.transactionStatus   == RetailEntryStatus::None
                    &&  retailTransactionCustomerAccountDepositTrans.custAccount         == custTable.AccountNum;

        return retailTransactionPaymentTrans.amountTendered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailCustomerAccountSalesAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the customer account sales.
    /// </summary>
    /// <returns>
    /// The customer account paid sales amount.
    /// </returns>
    public AmountMST retailCustomerAccountSalesAmount()
    {
        RetailTransactionTable                          retailTransactionTable;
        RetailTransactionPaymentTrans                   retailTransactionPaymentTrans;
        RetailStoreTenderTypeTable                      retailStoreTenderTypeTable;
        RetailStoreTable                                retailStoreTable;

        // calculate amount tender using customer account
        select sum(amountTendered) from retailTransactionPaymentTrans
            where   (
                    retailTransactionPaymentTrans.transactionStatus == RetailEntryStatus::None
                ||  retailTransactionPaymentTrans.transactionStatus == RetailEntryStatus::Concluded
                ||  retailTransactionPaymentTrans.transactionStatus == RetailEntryStatus::OnHold
                )
                &&  retailTransactionPaymentTrans.cardOrAccount == custTable.AccountNum
            exists join retailTransactionTable
                where   retailTransactionTable.store            == retailTransactionPaymentTrans.store
                    &&  retailTransactionTable.terminal         == retailTransactionPaymentTrans.terminal
                    &&  retailTransactionTable.transactionId    == retailTransactionPaymentTrans.transactionId
                    &&  retailTransactionTable.entryStatus      == RetailEntryStatus::None
                    &&  retailTransactionTable.type             == RetailTransactionType::Sales
            exists join retailStoreTenderTypeTable
                where   retailStoreTenderTypeTable.tenderTypeId  == retailTransactionPaymentTrans.tenderType
                    &&  retailStoreTenderTypeTable.function      == RetailTenderFunction::Customer
            exists join retailStoreTable
                where   retailStoreTable.RecId       == retailStoreTenderTypeTable.Channel
                    &&  retailStoreTable.StoreNumber == retailTransactionPaymentTrans.store;

        return retailTransactionPaymentTrans.amountTendered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets an instance of <c>SalesTotals</c> used to calculate the total of the current sales
    ///    order.
    /// </summary>
    /// <param name="_salesTotals">
    ///    The sales totals; optional.
    /// </param>
    /// <returns>
    ///    An instance of <c>SalesTotals</c> used to calculate the total of the current sales order.
    /// </returns>
    /// <remarks>
    ///    Instances of <c>CustCreditLimit_SalesTable</c> initialize <c>SalesTotals</c> in the <c>init</c>
    ///    method.
    /// </remarks>
    SalesTotals salesTotals(SalesTotals _salesTotals = salesTotals)
    {
        if (!prmisdefault(_salesTotals))
        {
            // we'll use the currency code and the exchange rate from the SalesTotals
            currency = _salesTotals.currencyCode();
            exchangeRate = _salesTotals.exchRate(); // it may be a fixed exch.rate
        }

        salesTotals = _salesTotals;
        return salesTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckCreditAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to check the available credit for the customer.
    /// </summary>
    /// <returns>
    ///    true if available credit should be checked; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the customer has a credit limit, and the <c>typeOfCreditMaxCheck</c> property is not set to the
    ///    <c>TypeOfCreditmaxCheck::None</c> enumeration value or the customer has specified the mandatory
    ///    credit limit check, the credit limit will be checked.
    /// </remarks>
    public boolean shouldCheckCreditAvailable()
    {
        return typeOfCreditmaxCheck != typeOfCreditmaxCheck::None && this.getCurrentCreditMax() || custTable.MandatoryCreditLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setShouldDisplayMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the infolog message should be displayed to the end user.
    /// </summary>
    protected void setShouldDisplayMessage()
    {
        if (!isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // Always display the message if Call Center is disabled.
            displayMessage = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the new error message after being appended to the existing error message.
    /// </summary>
    /// <param name = "_message">The current message.</param>
    /// <param name = "_amount">The current amount.</param>
    /// <returns>The new error message after being appended to the existing error message.</returns>
    protected str currentMessage(str _message, AmountMST _amount)
    {
        str errMsg;

        if (currency != stdCurrency)
        {
            errMsg = strFmt(_message + ': %1 %3 (%2 %4) \n', currency, stdCurrency, (_amount / (exchangeRate / 100)), _amount);
        }
        else
        {
            errMsg = strFmt(_message + ': %1 \n', _amount);
        }

        return errMsg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showErrorMsg</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows the error or warning message.
    /// </summary>
    /// <param name="_balanceInvoiced">
    ///    The open balance.
    /// </param>
    /// <param name="_balanceCurrentOrder">
    ///    The total of the current order.
    /// </param>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    This method will always return false.
    /// </remarks>
    protected boolean showErrorMsg(AmountMST _balanceInvoiced, AmountMST _balanceCurrentOrder)
    {
        errorMessage = "@SYS79485" + ' \n';

        errorMessage += this.currentMessage("@SYS79458", _balanceInvoiced);
        errorMessage += this.currentMessage("@SYS79459", _balanceCurrentOrder);
        errorMessage += this.currentMessage("@SYS79460", (_balanceInvoiced + _balanceCurrentOrder));

        // <GEERU>
        errorMessage += this.currentMessage("@SYS1532", (checkAgreementLimit ? agreementCreditLimitMax : this.getCurrentCreditMax()));
        errorMessage += this.currentMessage("@SYS79461", ((_balanceInvoiced + _balanceCurrentOrder) - (checkAgreementLimit ? agreementCreditLimitMax : this.getCurrentCreditMax())));
        // </GEERU>

        if (!this.isStdCurrency())
            errorMessage += strFmt("@SYS79462", exchangeRate);

        this.setShouldDisplayMessage();

        // Display the message if requested.
        if (displayMessage)
        {
            if (warning)
            {
                return checkFailed(errorMessage);
            }
            else
            {
                error(errorMessage);
                return false;
            }
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentCreditMax</Name>
				<Source><![CDATA[
    [Hookable(true)]
    protected CustCreditMaxMST getCurrentCreditMax()
    {
        return custTable.CreditMax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>typeOfCreditMaxCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the type of credit max check.
    /// </summary>
    /// <param name="_typeOfCreditmaxCheck">
    ///    The type of credit max check; optional.
    /// </param>
    /// <returns>
    ///    The type of credit max check.
    /// </returns>
    /// <remarks>
    ///    If the <c>TypeOfCreditMax</c> check differs from that of <c>CustParameters.CheckCreditMax</c>, the
    ///    calculation of the total open balance will calculate each applicable sales order one by one. If it
    ///    is the same (as in most occurrences), it uses the stored total of each sales order if available. This method
    ///    uses the specified <c>CustParameter</c>, but it is changed according to that of
    ///    <c>SalesParmUpdate</c> if the class is an instance of <c>CustCreditLimit_SalesParmTable</c>.
    /// </remarks>
    TypeOfCreditmaxCheck typeOfCreditMaxCheck(TypeOfCreditmaxCheck _typeOfCreditmaxCheck = typeOfCreditmaxCheck)
    {
        typeOfCreditmaxCheck = _typeOfCreditmaxCheck;
        return typeOfCreditmaxCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the estimated total field for sales orders for the current customer
    /// has been calculated.
    /// </summary>
    /// <returns>
    /// true if SalesTable.Estimated field can be used for totals calculations; otherwise, false.
    /// </returns>
    public boolean useEstimated()
    {
        return (custParameters.CreditMaxCheck == typeOfCreditmaxCheck && custTable.shouldEstimateBeCalculated());
    }

]]></Source>
			</Method>
			<Method>
				<Name>warning</Name>
				<Source><![CDATA[
    boolean warning(boolean _warning = warning)
    {
        warning = _warning;
        return warning;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for constructing <c>CustCreditLimit</c> instances.
    /// </summary>
    /// <param name = "_buffer">The buffer to create the instance from.</param>
    /// <param name = "_salesTotals">Sales totals for the credit check.</param>
    /// <param name = "_eventHandlerResult">An <c>EventHandlerResult</c> where the created class can be returned.</param>
    static delegate void constructDelegate(Common _buffer, SalesTotals _salesTotals, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustCreditLimit construct(Common _buffer, SalesTotals _salesTotals = null)
    {
        switch (_buffer.TableId)
        {
            case tablenum(CustTable):
                return new CustCreditLimit(_buffer);

            case tablenum(SalesTable):
                return new CustCreditLimit_SalesTable(_buffer, _salesTotals);

            case tablenum(SalesParmTable):
                return new CustCreditLimit_SalesParmTable(_buffer, _salesTotals);

            case tablenum(CustInvoiceTable):
                return new CustCreditLimit_CustInvoiceTable(_buffer);

            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                CustCreditLimit::constructDelegate(_buffer, _salesTotals, result);
                if (result.hasResult())
                {
                    return result.result() as CustCreditLimit;
                }
                break;
        }

        throw error(Error::missingRecord(classstr(CustCreditLimit)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides an entry point for the <c>CustCreditLimit</c> class when it is called from a menu item.
    /// </summary>
    /// <param name="_args">
    ///    The arguments for the <c>CustCreditLimit</c> class.
    /// </param>
    /// <remarks>
    ///    Use the
    ///    <c>
    ///       main
    ///    </c>
    ///     class design pattern whenever a class is called from a menu item. Do not call the
    ///    <c>
    ///       main
    ///    </c>
    ///     method explicitly from the code; call it implicitly from a menu item.Typically, you would:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             Instantiate the class by calling the static <c>construct</c> method.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Call the <c>prompt</c> method to create a dialog box.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Call the <c>run</c> method, if the user clicks OK in the dialog box.
    ///          </description>
    ///       </item>
    ///    </list>
    /// </remarks>
    static void main(Args _args)
    {
        CustCreditLimit custCreditLimit = CustCreditLimit::construct(_args.record());
        if (custCreditLimit.check())
            info("@SYS54430");
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckCreditLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// check that credit limit validation is needed for a sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record to be checked.
    /// </param>
    /// <param name="_creditMaxCheck">
    /// The credit limit check parameter set by a user.
    /// </param>
    /// <returns>
    /// True if the credit limit check should run, otherwise, false.
    /// </returns>
    public static boolean mustCheckCreditLimit(SalesTable _salesTable, CustCreditMaxCheck _creditMaxCheck)
    {
        return ((_creditMaxCheck
            || _salesTable.custTable_CustAccount().MandatoryCreditLimit)
            && !_salesTable.creditCardBypassCreditLimit()
            && !MCRCustPaymTable::salesTableByPassCreditLimit(_salesTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAmountAddedToBalanceBasedOnTypeOfCreditmaxCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not adding to balance based on type of credit max check and order balance is allowed.
    /// </summary>
    /// <returns>
    /// true if the mandatory credit limit is there for the customer record or credit limit otherwise, false.
    /// </returns>
    protected boolean canAmountAddedToBalanceBasedOnTypeOfCreditmaxCheck()
    {
        return (this.getCurrentCreditMax() || custTable.MandatoryCreditLimit);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>