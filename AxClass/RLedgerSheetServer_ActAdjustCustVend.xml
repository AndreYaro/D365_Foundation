<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>rLedgerSheetServer_ActAdjustCustVend</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class rLedgerSheetServer_ActAdjustCustVend  extends  RLedgerSheetServer
{
    CurrencyTypeBrief_RU            currencyTypeBrief;
    CustVendTable                   custVendTable;

    NoYes                           byAgreement;
    NoYes                           showDocument;
    NoYes                           deleteZeroInvoiceBalance;

    Struct                          covenanteeBegPeriodBalance;

    TransDate                       dtEndPrevPer;

    RHolderData_ActAdjustCustVend   holderData;

    int                             signInvoice;
    int                             signPayment;

    int                             lastPaymentNumCurrent;
    int                             lastPaymentNumPrevious;

    Map                             mapPaymentNumCurrent;
    Map                             mapPaymentNumPrevious;

    int                             iCntDocInPeriod;
    int                             posCustVendAC;
    int                             posAgreementHeaderExtRecId;
    int                             posActAdjustCVPartitionType;
    int                             posInvoiceId;
    int                             posINum;

    Set                             setCalculatedAgreementBegPerBalance;

    int                             iNumExchAdjInvoice;

    protected const int numCustVendTransDS = 1;
    protected const str emptyString = "\"\"";
    protected const int agreementNumValue = 0;
    protected const int invoiceNumValue = 1;
    protected const int paymentNumValue = 0;
    protected const str defaultDimensionFieldName = "DefaultDimension";
    protected const str transDateFieldName = "TransDate";
    protected const str currencyCodeFieldName = "CurrencyCode";
    protected const str accountNumFieldName = "AccountNum";
    protected const str fieldRecIdName = "RecID";

    /// <summary>
    /// Builds a new key based on _conKey parameter.
    /// </summary>
    /// <param name="_conKey">
    /// Container which represents agreement key.
    /// </param>
    /// <returns>
    /// New key as container.
    /// </returns>
    /// <remarks>
    /// New key represents node for tree which holds the begin balance data. Significant value of new key is number of agreement.
    /// </remarks>

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>agreementTitleKeyToBegBalanceKey</Name>
				<Source><![CDATA[
    public container agreementTitleKeyToBegBalanceKey(container _conKey)
    {
        container conRet;

        conRet = conpoke(_conKey, posActAdjustCVPartitionType, int2str(RActAdjustCVPartitionType::Agreement));
        conRet = conpoke(conRet, posInvoiceId, emptyString);
        conRet = conpoke(conRet, posINum, int2str(agreementNumValue));

        return conRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementTitleKeyToPartitionKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a new key based on _conKey parameter for specific partition type. New key reperesents agreement title which could be assotiated with partition type.
    /// </summary>
    /// <param name="_conKey">
    /// Key which represents  branc of data holder tree.
    /// </param>
    /// <param name="_actAdjustCVPartitionType">
    /// Type of partition.
    /// </param>
    /// <returns>
    /// New key as container.
    /// </returns>
    /// <remarks>
    /// This method builds new key to aggregate data based on partition type.
    /// </remarks>

    public container agreementTitleKeyToPartitionKey(container _conKey, RActAdjustCVPartitionType _actAdjustCVPartitionType)
    {
        container   conRet;
        TempStr     sSumKeyField = holderData.getSumKeyField();
        int         cx;

        conRet = conpoke(_conKey, posActAdjustCVPartitionType, int2str(_actAdjustCVPartitionType));

        for (cx = conlen(conRet); cx > posActAdjustCVPartitionType; cx--)
        {
            conRet = conpoke(conRet, cx, sSumKeyField);
        }

        return conRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bindedTransactions</Name>
				<Source><![CDATA[
        protected RecordSortedList bindedTransactions(CustVendTrans  _originalTrans)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAgreementBalanceBegPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates balance on begin period based on concrete agreement and stores in holder data as segment tree.
    /// </summary>
    /// <param name="_agreementHeaderExtRecId">
    /// Reference to record in <c>AgreementHeaderExt_RU</c> table.
    /// </param>

    protected void calcAgreementBalanceBegPeriod(AgreementHeaderExtRecId_RU _agreementHeaderExtRecId)
    {
        Struct              struct;
        container           conKey, conAgreementKey = connull();
        str                 sz;

        if (! setCalculatedAgreementBegPerBalance.in(_agreementHeaderExtRecId))
        {
            conKey = this.createKey(RActAdjustCVPartitionType::Agreement,
                                    emptyString,
                                    AgreementNumValue,
                                    _agreementHeaderExtRecId);

            if (fromDate != dateNull())
                sz = strfmt("@GLS110513", fromDate);
            else
                sz = "@GLS104704";

            struct = this.calcBalanceBegPeriod(sz, _agreementHeaderExtRecId);

            holderData.insert(conKey, struct);

            setCalculatedAgreementBegPerBalance.add(_agreementHeaderExtRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBalanceBegPeriod</Name>
				<Source><![CDATA[
        protected Struct calcBalanceBegPeriod(str _txt = emptyString, AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
    {
        CustVendTrans           custVendTrans = custVendTable.transBuffer();
        CustVendTrans           originalTrans = custVendTable.transBuffer();
        CustVendTrans           loopTrans     = custVendTable.transBuffer();

        Query                   q;
        QueryRun                qr;

        RActAdjustCVType        actAdjustCVType;

        Amount                  amountInvoice = 0, amountPayment = 0;
        Amount                  amount, amountSettled, amountExchAdjustment;

        Struct                  struct;
        Set                     set;

        RecordSortedList        rsl;
        boolean                 loop;

        void calc()
        {
            [amount, amountSettled, amountExchAdjustment] = this.calcDocument(custVendTrans, dtEndPrevPer);
            amount -= amountSettled;
            amount += amountExchAdjustment;
            amount += this.calcUnrealizedExchAdj(custVendTrans, dtEndPrevPer);

            switch (actAdjustCVType)
            {
                case RActAdjustCVType::Invoice    :
                case RActAdjustCVType::CreditNote :
                    amountInvoice += signInvoice * amount;
                    break;

                case RActAdjustCVType::Payment    :
                case RActAdjustCVType::Repayment  :

                    amountPayment += signPayment * amount;
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcname()));
            }
        }

        void calcOriginalTrans()
        {
            if (!set.in(originalTrans.RecId))
            {
                set.add(originalTrans.RecId);

                if (originalTrans.TransDate <= dtEndPrevPer)
                {
                    rsl  = this.bindedTransactions(originalTrans);

                    if (rsl)
                    {
                        loop = rsl.first(loopTrans);

                        while (loop)
                        {
                            custVendTrans = loopTrans;
                            calc();

                            loop = rsl.next(loopTrans);
                        }
                    }
                }
            }
        }

        set = new Set(typeName2Type(extendedTypeStr(recId)));

        q = this.createQuery(dateNull(), dtEndPrevPer, _agreementHeaderExtRecId);
        qr = new QueryRun(q);

        while (qr.next())
        {
            custVendTrans = qr.getNo(numCustVendTransDS);

            if (this.determinePeriod(custVendTrans) != RActAdjustCVPeriod::Previous)
                continue;

            actAdjustCVType = this.getDocumentType(custVendTrans);

            if (actAdjustCVType == RActAdjustCVType::Ignore)
            {
                continue;
            }

            if (actAdjustCVType == RActAdjustCVType::Payment)
            {
                originalTrans = this.findRootPayment(custVendTrans);

                if (custVendTrans.RecId != originalTrans.RecId)
                    calcOriginalTrans();
                else if ((! originalTrans.Correct) && this.bindedTransactions(originalTrans))
                {
                    calcOriginalTrans();
                }
                else
                    calc();
            }
            else
                calc();
        }

        struct = this.createStructBalance(dateNull(), _txt, amountInvoice, amountPayment);

        return struct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDocument</Name>
				<Source><![CDATA[
protected container calcDocument(CustVendTrans  _custVendTrans, TransDate  _transDate)
    {
        CustVendSettlement  custVendSettlement = custVendTable.settlementBuffer();

        select sum(SettleAmountMST), sum(ExchAdjustment), sum(SettleAmountCur)
            from custVendSettlement
            where (custVendSettlement.TransRecId      == _custVendTrans.RecId) && (custVendSettlement.TransDate       <= _transDate) && (custVendSettlement.SettleAmountMST != 0);

        if (currencyTypeBrief == CurrencyTypeBrief_RU::Standard)
        {
            return [_custVendTrans.AmountMST, custVendSettlement.SettleAmountMST, custVendSettlement.ExchAdjustment];
        }
        else
        {
            return [_custVendTrans.AmountCur, custVendSettlement.SettleAmountCur, 0];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPaymSettlementOtherCurrency</Name>
				<Source><![CDATA[
        private container calcPaymSettlementOtherCurrency(CustVendTrans _custVendTrans, CurrencyCode _currencyCode)
    {
        CustVendSettlement  custVendSettlement = custVendTable.settlementBuffer();
        CustVendTrans       custVendTrans      = custVendTable.transBuffer();

        Amount              settlementOtherCurrency = 0, settlementRepaymentOtherCurrency = 0;

        Map                 map;
        CurrencyCode        currentCurrencyCode;
        RActAdjustCVType    actAdjustCVType;

        map                = new Map(typeName2Type(extendedTypeStr(recId)), Types::Container);
        custVendSettlement = this.createCursorCustVendSettlement(_custVendTrans);

        while (this.moveNextSettlement(custVendSettlement))
        {
            if (map.exists(custVendSettlement.OffsetRecId))
                [currentCurrencyCode, actAdjustCVType] = map.lookup(custVendSettlement.OffsetRecId);
            else
            {
                custVendTrans       = this.findCustVendTrans(custVendSettlement.OffsetRecId);
                actAdjustCVType     = this.getDocumentType(custVendTrans);
                currentCurrencyCode = custVendTrans.CurrencyCode;

                map.insert(custVendSettlement.OffsetRecId, [currentCurrencyCode, actAdjustCVType]);
            }

            if (currentCurrencyCode != _currencyCode)
            {
                settlementOtherCurrency += custVendSettlement.SettleAmountCur;

                if (actAdjustCVType == RActAdjustCVType::Repayment)
                    settlementRepaymentOtherCurrency += custVendSettlement.SettleAmountCur;
            }
        }

        return [settlementOtherCurrency, settlementRepaymentOtherCurrency];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnrealizedExchAdj</Name>
				<Source><![CDATA[
        protected AmountMST calcUnrealizedExchAdj(CustVendTrans _custVendTrans, TransDate _transDate)
    {
        CustVendTrans exchCustVendTrans = CustVendTransStatic::newTrans(_custVendTrans).custVendTrans();

        if (currencyTypeBrief == CurrencyTypeBrief_RU::Standard)
        {
            select sum(AmountMST) from  exchCustVendTrans
                where exchCustVendTrans.OffsetRecId == _custVendTrans.RecId          &&
                      exchCustVendTrans.TransType == LedgerTransType::ExchAdjustment &&
                      exchCustVendTrans.TransDate <= _transDate                      &&
                      exchCustVendTrans.ExchAdjustmentUnrealized;
        }
        return exchCustVendTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectData</Name>
				<Source><![CDATA[
        private void collectData()
    {
        CustVendTrans       custVendTrans      = custVendTable.transBuffer();

        RActAdjustCVPartitionType  invoicePartitionType;
        RActAdjustCVPartitionType  paymentPartitionType;

        Query               query;
        QueryRun            qr;
        tableId             tableId;

        Set                 set;
        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;

        void initNewAgreement()
        {
            lastPaymentNumCurrent  = 0;
            lastPaymentNumPrevious = 0;

            mapPaymentNumCurrent   = new Map(typeName2Type(extendedTypeStr(recId)), Types::Integer);
            mapPaymentNumPrevious  = new Map(typeName2Type(extendedTypeStr(recId)), Types::Integer);
        }

        initNewAgreement();

        tableId          = custVendTrans.TableId;
        set              = new Set(Types::Int64);
        query            = this.createQuery(dateNull(), toDate, 0, byAgreement);
        qr               = new QueryRun(query);

        iCntDocInPeriod = SysQuery::countTotal(qr);

        qr.reset();

        while (qr.next())
        {
            custVendTrans = qr.get(tableId);

            if (byAgreement)
            {
                agreementHeaderExtRecId = this.pickOutAgreement(custVendTrans);

                if (!set.in(agreementHeaderExtRecId))
                {
                    this.calcAgreementBalanceBegPeriod(agreementHeaderExtRecId);

                    set.add(agreementHeaderExtRecId);

                    initNewAgreement();
                }
            }

            switch (this.determinePeriod(custVendTrans))
            {
                case RActAdjustCVPeriod::Current :

                    invoicePartitionType = RActAdjustCVPartitionType::InvoiceCurrent;
                    paymentPartitionType = RActAdjustCVPartitionType::PaymentCurrent;
                    break;

                case RActAdjustCVPeriod::Previous :

                    invoicePartitionType = RActAdjustCVPartitionType::InvoicePrevious;
                    paymentPartitionType = RActAdjustCVPartitionType::PaymentPrevious;
                    break;

                default :
                    continue;
            }

            this.processingCustVendTrans(custVendTrans, invoicePartitionType, paymentPartitionType);
        }

        initNewAgreement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCursorCustVendSettlement</Name>
				<Source><![CDATA[
        private CustVendSettlement  createCursorCustVendSettlement(CustVendTrans   _custVendTrans)
    {
        CustVendSettlement  custVendSettlement = custVendTable.settlementBuffer();

        select  nofetch custVendSettlement
            where   (custVendSettlement.TransRecId        == _custVendTrans.RecId)  &&
                    (custVendSettlement.TransDate         >= fromDate)              &&
                    (custVendSettlement.TransDate         <= toDate)                &&
                    (custVendSettlement.OffsetRecId       != 0)                     &&
                    ((custVendSettlement.CanBeReversed    == NoYes::Yes)            ||
                     (custVendSettlement.ReversedRecId_RU != 0));

        return   custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKey</Name>
				<Source><![CDATA[
        protected container createKey(RActAdjustCVPartitionType  _actAdjustCVPartitionType,
                                  TempStr                    _invoiceId,
                                  int                        _iNum,
                                  AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
    {
        container       con = connull();
        str             sz;

        CustVendTrans   custVendTrans;

        sz  = custVendTable.AccountNum;
        con += sz;

        if (byAgreement && (!_agreementHeaderExtRecId))
        {
            custVendTrans            = custVendTable.transBuffer();
            _agreementHeaderExtRecId = this.pickOutAgreement(custVendTrans);
        }

        if (byAgreement)
        {
            sz  =  int642str(_agreementHeaderExtRecId);
            con += sz;
        }

        sz  =  int2str(_actAdjustCVPartitionType);
        con += sz;

        sz  =  (_invoiceId) ? _invoiceId : emptyString;
        con += sz;

        sz  =  int2str(_iNum);
        con += sz;

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKeyForPayment</Name>
				<Source><![CDATA[
        protected container createKeyForPayment(RecID                      _origRecID,
                                            CustVendTrans              _custVendTrans,
                                            RActAdjustCVPartitionType  _actAdjustCVPartitionType,
                                            TempStr                    _invoiceId,
                                            int                        _iNum,
                                            RActAdjustCVPaymType       _paymType,
                                            AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
    {
        return this.createKey(_actAdjustCVPartitionType, _invoiceId, _iNum, _agreementHeaderExtRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuery</Name>
				<Source><![CDATA[
        protected Query createQuery(TransDate       _fromDate,
                                TransDate       _toDate,
                                AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0,
                                boolean         _bSortedByAgreement = false)
    {
        Query                   q;

        QueryBuildDataSource    ds;
        QueryBuildRange         range;

        CustVendTrans           custVendTrans = custVendTable.transBuffer();
        RecId                   dimAttrRecId  = AgreementHeaderExt_RU::getAgreementDimensionAttribute();

        q   = new Query();
        ds  = q.addDataSource(custVendTrans.TableId);
        ds.orderMode(OrderMode::OrderBy);

        if (_bSortedByAgreement && dimAttrRecId)
        {
            SysQuery::addOrderByDimensionAttribute(q,
                ds.name(),
                defaultDimensionFieldName,
                DimensionComponent::DimensionAttribute,
                SortOrder::Ascending,
                DimensionAttribute::find(dimAttrRecId).Name);
        }

        ds.addSortField(fieldname2id(custVendTrans.TableId, transDateFieldName));

        range = ds.addRange(fieldname2id(custVendTrans.TableId, accountNumFieldName));
        range.value(custVendTable.AccountNum);

        range = ds.addRange(fieldname2id(custVendTrans.TableId, transDateFieldName));
        range.value(queryRange(_fromDate, _toDate));

        if (_agreementHeaderExtRecId && dimAttrRecId)
        {
            SysQuery::addDimensionAttributeRange(q,
                ds.name(),
                defaultDimensionFieldName,
                DimensionComponent::DimensionAttribute,
                AgreementHeaderExt_RU::find(_agreementHeaderExtRecId).AgreementId,
                DimensionAttribute::find(dimAttrRecId).Name);
        }

        if (currencyTypeBrief == CurrencyTypeBrief_RU::Currency)
        {
            range = ds.addRange(fieldname2id(custVendTrans.TableId, currencyCodeFieldName));
            range.value(currencyCode);
        }

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createStructBalance</Name>
				<Source><![CDATA[
        abstract protected Struct createStructBalance(TransDate  _transDate, str _txt, Amount  _amountInvoice, Amount _amountPayment)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createStructInvoice</Name>
				<Source><![CDATA[
        abstract protected Struct createStructInvoice(TransDate     _transDate,
                                                  str           _txt,
                                                  Amount        _amountOfDoc,
                                                  Amount        _amount,
                                                  Amount        _amountTurnover,
                                                  RecID         _recID = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createStructPayment</Name>
				<Source><![CDATA[
        abstract protected Struct createStructPayment(TransDate _transDate, str  _txt, Amount _amountOfDoc, Amount _amount, Amount _amountTurnover, RecID _recID = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentPaymentNum</Name>
				<Source><![CDATA[
        protected int currentPaymentNum(CustVendTrans _custVendTrans, RActAdjustCVPartitionType  _partitionType)
    {
        Map         map;
        int         paymentNum;

        switch (_partitionType)
        {
            case RActAdjustCVPartitionType::PaymentCurrent  :
                map = mapPaymentNumCurrent;
                break;

            case RActAdjustCVPartitionType::PaymentPrevious :
                map = mapPaymentNumPrevious;
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcname()));
        }

        if (map.exists(_custVendTrans.RecId))
            paymentNum = map.lookup(_custVendTrans.RecId);
        else
        {
            if (_partitionType == RActAdjustCVPartitionType::PaymentCurrent)
            {
                lastPaymentNumCurrent++;
                paymentNum = lastPaymentNumCurrent;
            }
            else
            {
                lastPaymentNumPrevious++;
                paymentNum = lastPaymentNumPrevious;
            }

            map.insert(_custVendTrans.RecId, paymentNum);
        }

        return paymentNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateToStrForKey</Name>
				<Source><![CDATA[
    protected TempStr dateToStrForKey(date _dt)
    {
        return date2str(_dt, value321, value2, value2, value2, value2, value4, DateFlags::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePeriod</Name>
				<Source><![CDATA[
        protected  RActAdjustCVPeriod  determinePeriod(CustVendTrans _custVendTrans)
    {
        CustVendSettlement   custVendSettlement = custVendTable.settlementBuffer();
        RActAdjustCVPeriod   actAdjustCVPeriod  = RActAdjustCVPeriod::None;

        if (_custVendTrans.TransDate >= fromDate)
        {
            actAdjustCVPeriod = RActAdjustCVPeriod::Current;
        }
        else
        {
            if (_custVendTrans.Closed == dateNull())
            {
                actAdjustCVPeriod = RActAdjustCVPeriod::Previous;
            }
            else
            {
                select firstonly RecId
                    from custVendSettlement
                    where custVendSettlement.TransRecId    == _custVendTrans.RecId &&
                          custVendSettlement.TransDate     >= fromDate             &&
                          custVendSettlement.CanBeReversed == NoYes::Yes;

                if (custVendSettlement.RecId)
                    actAdjustCVPeriod = RActAdjustCVPeriod::Previous;
            }
        }

        return actAdjustCVPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsDocumentInfo</Name>
				<Source><![CDATA[
        protected boolean existsDocumentInfo(CustVendTrans  _custVendTrans)
    {
        return (_custVendTrans.DocumentNum || _custVendTrans.DocumentDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTrans</Name>
				<Source><![CDATA[
        abstract protected CustVendTrans findCustVendTrans(RecID  _recID)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRootPayment</Name>
				<Source><![CDATA[
        protected CustVendTrans findRootPayment(CustVendTrans  _custVendTrans)
    {
        return _custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementHeaderExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets agreement header based on reference.
    /// </summary>
    /// <param name="_agreementHeaderExtRecId">
    /// Reference to agreement header record.
    /// </param>
    /// <returns>
    /// Agreement header buffer.
    /// </returns>
    /// <remarks>
    /// Abstarct method to be implemented for particular type of agreement.
    /// </remarks>

    abstract public AgreementHeaderExt_RU getAgreementHeaderExt(AgreementHeaderExtRecId_RU _agreementHeaderExtRecId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCovenanteeBegPeriodBalance</Name>
				<Source><![CDATA[
        public Struct getCovenanteeBegPeriodBalance()
    {
        str         tempStr;

        if (! covenanteeBegPeriodBalance)
        {
            if (fromDate != dateNull())
                tempStr = strfmt("@GLS110513", fromDate);
            else
                tempStr = "@GLS104704";

            covenanteeBegPeriodBalance = this.calcBalanceBegPeriod(tempStr);
        }

        return covenanteeBegPeriodBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultNumValue</Name>
				<Source><![CDATA[
        public container getDefaultNumValue()
    {
        return [invoiceNumValue, paymentNumValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentDescription</Name>
				<Source><![CDATA[
        protected TempStr getDocumentDescription(CustVendTrans  _custVendTrans)
    {
        RActAdjustCVType    actAdjustCVType;
        TempStr             szDescription, sz, txt = "";

        actAdjustCVType = this.getDocumentType(_custVendTrans);

        switch (actAdjustCVType)
        {
            case RActAdjustCVType::Invoice  :

                if (this.existsDocumentInfo(_custVendTrans))
                    szDescription = strfmt("@GLS110598", _custVendTrans.DocumentNum, _custVendTrans.DocumentDate);
                else
                    szDescription = strfmt("@GLS110599", _custVendTrans.Invoice);

                break;

            case RActAdjustCVType::CreditNote :

                if (this.existsDocumentInfo(_custVendTrans))
                    szDescription = strfmt("@GLS110600", _custVendTrans.DocumentNum, _custVendTrans.DocumentDate);
                else
                    szDescription = strfmt("@GLS110601", _custVendTrans.Invoice);

                break;

            case RActAdjustCVType::Payment :

                if (this.existsDocumentInfo(_custVendTrans))
                    szDescription = strfmt("@GLS107210", _custVendTrans.DocumentNum, _custVendTrans.DocumentDate);
                else
                    szDescription = strfmt("@GLS110602", _custVendTrans.Voucher);

                break;

            case RActAdjustCVType::Repayment :

                if (this.existsDocumentInfo(_custVendTrans))
                    szDescription = strfmt("@GLS110603", _custVendTrans.DocumentNum, _custVendTrans.DocumentDate);
                else
                    szDescription = strfmt("@GLS110604", _custVendTrans.Voucher);

                break;

            default :
                szDescription = "";
        }

        sz = strLRTrim(_custVendTrans.Txt);

        if (sz)
        {
            if ((substr(sz, 1, 1) == '(') && (substr(sz, strlen(sz), 1) == ')'))
                txt = strfmt("@GLS110612", sz);
            else
                txt = strfmt("@GLS110613", sz);

            szDescription += txt;
        }

        return szDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentType</Name>
				<Source><![CDATA[
        protected RActAdjustCVType getDocumentType(CustVendTrans _custVendTrans)
    {
        RActAdjustCVType            type = RActAdjustCVType::Ignore;

        if (_custVendTrans.TransType == LedgerTransType::ExchAdjustment       ||
           _custVendTrans.TransType == LedgerTransType::AdvanceAdjustment_RU ||
           _custVendTrans.TransType == LedgerTransType::Interest)
        {
            return  RActAdjustCVType::Ignore;
        }

        if (_custVendTrans.Invoice)
        {
            if (sign(-_custVendTrans.AmountMST) == sign(signInvoice))
                type = RActAdjustCVType::CreditNote;
            else
                type = RActAdjustCVType::Invoice;
        }
        else
        {
            if (this.takeIntoPayment(_custVendTrans))
            {
                if (sign(_custVendTrans.AmountMST) == sign(signInvoice))
                    type = RActAdjustCVType::Repayment;
                else
                    type = RActAdjustCVType::Payment;
            }
        }

        return type;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHolderData</Name>
				<Source><![CDATA[
        public RHolderData  getHolderData()
    {
        return holderData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHolderDataContainer</Name>
				<Source><![CDATA[
        public container getHolderDataContainer()
    {
        return RHolderData::packRHolderData(holderData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceId</Name>
				<Source><![CDATA[
        protected TempStr getInvoiceId(CustVendTrans _custVendTrans)
    {
        return strfmt("@GLS110611", this.dateToStrForKey(_custVendTrans.TransDate), _custVendTrans.Invoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceIdForPayment</Name>
				<Source><![CDATA[
        protected TempStr getInvoiceIdForPayment(CustVendTrans _custVendTrans, RActAdjustCVPartitionType  _partitionType)
    {
        int   curentPaymNum;

        curentPaymNum = this.currentPaymentNum(_custVendTrans, _partitionType);

        return strRFix(int2str(curentPaymNum), strlen(int2str(iCntDocInPeriod)), '0');
    }

]]></Source>
			</Method>
			<Method>
				<Name>getKeyMask</Name>
				<Source><![CDATA[
        public container  getKeyMask()
    {
        return [posCustVendAC, posAgreementHeaderExtRecId, posActAdjustCVPartitionType, posInvoiceId, posINum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAccounts</Name>
				<Source><![CDATA[
        protected void initAccounts()
    {

        super();

        setCalculatedAgreementBegPerBalance = new Set(Types::Int64);

        this.initHolderData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTable</Name>
				<Source><![CDATA[
        abstract protected CustVendTable initCustVendTable(CustVendAC  _custVendAC)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initHolderData</Name>
				<Source><![CDATA[
    private  void initHolderData()
    {
        container con;
        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;

        if (byAgreement)
        {
            agreementHeaderExtRecId = this.pickOutAgreement(custVendTable.transBuffer());
        }

        con = this.createKey(RActAdjustCVPartitionType::InvoiceCurrent, emptyString, 0, agreementHeaderExtRecId);

        posCustVendAC               = 1;
        posAgreementHeaderExtRecId  = (byAgreement) ? (posCustVendAC + 1) : -1;
        posActAdjustCVPartitionType = conlen(con) - value2;
        posInvoiceId                = conlen(con) - 1;
        posINum                     = conlen(con);

        holderData = new RHolderData_ActAdjustCustVend(conlen(con));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    public void initParameters(QueryRun _queryRun, container _con)
    {
        CustVendAC      custVendAC;
        int             len;

        len = conlen(_con);

        super(_queryRun, _con);

        currencyTypeBrief        = conpeek(_con, len - value4);
        byAgreement              = conpeek(_con, len - value3);
        showDocument             = conpeek(_con, len - value2);
        deleteZeroInvoiceBalance = conpeek(_con, len - 1);
        custVendAC               = conpeek(_con, len);

        custVendTable            = this.initCustVendTable(custVendAC);
        dtEndPrevPer             = fromDate - 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
        protected void initValue()
    {

        signInvoice     = 1;
        signPayment     = 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceKey</Name>
				<Source><![CDATA[
        public boolean isInvoiceKey(container _conKey)
    {
        TempStr                     szINum;
        RActAdjustCVPartitionType   actAdjustCVPartitionType;

        szINum                   = conpeek(_conKey, posINum);
        actAdjustCVPartitionType = conpeek(_conKey, posActAdjustCVPartitionType);

        return ((szINum                   == int2str(invoiceNumValue))                     &&
               ((actAdjustCVPartitionType == RActAdjustCVPartitionType::InvoiceCurrent)     ||
                (actAdjustCVPartitionType == RActAdjustCVPartitionType::InvoicePrevious)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyMapNum</Name>
				<Source><![CDATA[
        private container keyMapNum(CustVendTrans _custVendTrans, CustVendSettlement  _custVendSettlement)
    {
        return [int642str(_custVendTrans.RecId), int2str(_custVendSettlement.ReverseTrans_RU)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveNextSettlement</Name>
				<Source><![CDATA[
        private CustVendSettlement moveNextSettlement(CustVendSettlement _custVendSettlement)
    {
        CustVendSettlement  settlementReverse = custVendTable.settlementBuffer();
        boolean             loop = true;

        while (loop)
        {
            next  _custVendSettlement;

            if (!_custVendSettlement)
                break;

            if (_custVendSettlement.ReversedRecId_RU)
            {
                select firstonly TransDate from settlementReverse
                    where settlementReverse.RecId == _custVendSettlement.ReversedRecId_RU;

                if ((_custVendSettlement.ReverseTrans_RU == NoYes::No) && (settlementReverse.TransDate <= toDate))
                    continue;
                else if ((settlementReverse.TransDate >= fromDate) && (settlementReverse.TransDate <= toDate))
                    continue;
            }

            loop = false;
        }

        return _custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickOutAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets reference to agreement header table assotiated with customer or vendor transaction.
    /// </summary>
    /// <param name="_custVendTrans">
    /// Customer or vendor transaction.
    /// </param>
    /// <returns>
    /// Reference to particular agreement header table.
    /// </returns>

    protected AgreementHeaderExtRecId_RU pickOutAgreement(CustVendTrans _custVendTrans)
    {
        return AgreementHeaderExt_RU::findByDefaultDimension(_custVendTrans.DefaultDimension).recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingCustVendSettlement</Name>
				<Source><![CDATA[
        private int processingCustVendSettlement(RCalcExtraCustVendTransaction   _calcExtraTransaction,
                                             CustVendTrans                   _firstCustVendTrans,
                                             CustVendTrans                   _secondCustVendTrans,
                                             str                             _documentDescription,
                                             TempStr                         _invoiceId,
                                             RActAdjustCVPartitionType       _partitionType,
                                             int                             _iNum,
                                             AgreementHeaderExtRecId_RU      _agreementHeaderExtRecId)
    {
        Amount                          amount, amountTurnover;
        TempStr                         sz;
        Struct                          structValue;
        int                             sign, cx = 0;
        container                       conKey;

        void insData()
        {
            sz = strfmt("@SYS70938", enum2Value(_calcExtraTransaction.currentPostingLogType()), _documentDescription);

            switch (_partitionType)
            {
                case RActAdjustCVPartitionType::InvoiceCurrent  :
                case RActAdjustCVPartitionType::InvoicePrevious :

                     structValue = this.createStructInvoice(_calcExtraTransaction.currentTransDate(),
                                                            sz,
                                                            _calcExtraTransaction.currentAmount(),
                                                            amount,
                                                            amountTurnover,
                                                            _calcExtraTransaction.currentRecID());

                     break;

                case RActAdjustCVPartitionType::PaymentCurrent  :
                case RActAdjustCVPartitionType::PaymentPrevious :

                    structValue = this.createStructPayment(_calcExtraTransaction.currentTransDate(),
                                                           sz,
                                                           _calcExtraTransaction.currentAmount(),
                                                           amount,
                                                           amountTurnover,
                                                           _calcExtraTransaction.currentRecID());
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcname()));
            }

            if (_calcExtraTransaction.currentVoucher() != "")
                structValue = RHolderData_ActAdjustCustVend::insertVoucher(structValue, _calcExtraTransaction.currentVoucher());

            cx++;
            conKey = this.createKey(_partitionType, _invoiceId, _iNum + cx, _agreementHeaderExtRecId);

            holderData.insert(conKey, structValue);
        }

        void process()
        {
            while (_calcExtraTransaction.moveNext())
            {
                amount = sign * _calcExtraTransaction.currentAmount();

                switch (_calcExtraTransaction.currentPostingLogType())
                {
                    case CustVendTransPostingLogType_RU::ExchAdjustment :
                    case CustVendTransPostingLogType_RU::ExchAmountDiff :
                    case CustVendTransPostingLogType_RU::AdvanceAdjustment :

                        amountTurnover = amount;
                        break;

                    default :
                        amountTurnover = 0;
                }

                insData();
            }
        }

        if ((_partitionType == RActAdjustCVPartitionType::InvoiceCurrent) || (_partitionType == RActAdjustCVPartitionType::InvoicePrevious))
            sign = signInvoice;
        else
            sign = signPayment;

        _calcExtraTransaction.reset(_firstCustVendTrans.RecId, _secondCustVendTrans.RecId);
        process();

        _calcExtraTransaction.reset(_secondCustVendTrans.RecId, _firstCustVendTrans.RecId);
        process();

        return cx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingCustVendTrans</Name>
				<Source><![CDATA[
        private void processingCustVendTrans(CustVendTrans                _custVendTrans,
                                         RActAdjustCVPartitionType    _invoicePartitionType,
                                         RActAdjustCVPartitionType    _paymentPartitionType)
    {
        RActAdjustCVType    actAdjustCVType;

        actAdjustCVType = this.getDocumentType(_custVendTrans);

        if (actAdjustCVType == RActAdjustCVType::Ignore)
            return;

        switch (actAdjustCVType)
        {
            case RActAdjustCVType::Invoice    :
            case RActAdjustCVType::CreditNote :
                this.processingInvoice(_custVendTrans, _invoicePartitionType, actAdjustCVType);
                break;

            case RActAdjustCVType::Payment   :
            case RActAdjustCVType::Repayment :
                this.processingPayment(_custVendTrans, _paymentPartitionType, actAdjustCVType);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcname()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingInvoice</Name>
				<Source><![CDATA[
        private void processingInvoice(CustVendTrans               _custVendTrans,
                                   RActAdjustCVPartitionType   _invoicePartitionType,
                                   RActAdjustCVType            _actAdjustCVType)
    {
        Amount              amountDocument, amountSettled, amountTurnover;
        Amount              settledPayment, settledRepayment, amountExchAdjustment;
        AmountMST           unrealizedAmount;

        container           conKey;
        Struct              structValue;
        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;
        str                 sz;

        CustVendTrans       cvTransPayment = custVendTable.transBuffer();
        CustVendSettlement  settlement     = custVendTable.settlementBuffer();

        TransDate           dt;

        if (byAgreement)
        {
            agreementHeaderExtRecId = this.pickOutAgreement(_custVendTrans);
        }
        sz = this.getDocumentDescription(_custVendTrans);

        if (_actAdjustCVType == RActAdjustCVType::Invoice)
            dt = dtEndPrevPer;
        else
            dt = toDate;

        this.processingUnrealizedAdjustment(_custVendTrans, _invoicePartitionType, agreementHeaderExtRecId);
        unrealizedAmount = this.calcUnrealizedExchAdj(_custVendTrans, dt);

        [settledPayment, settledRepayment] = this.processingPaymentsForInvoice(_custVendTrans, _invoicePartitionType, agreementHeaderExtRecId);

        [amountDocument, amountSettled, amountExchAdjustment] = this.calcDocument(_custVendTrans, dt);

        if ((_invoicePartitionType == RActAdjustCVPartitionType::InvoiceCurrent) &&
           ((currencyTypeBrief    == CurrencyTypeBrief_RU::Standard)            ||
            (currencyCode         == _custVendTrans.CurrencyCode)))
        {
            amountTurnover = amountDocument;
        }
        else
        {
            amountTurnover = 0;
        }

        amountSettled  =  amountDocument - amountSettled + amountExchAdjustment + unrealizedAmount;

        if (_actAdjustCVType == RActAdjustCVType::CreditNote)
            amountSettled += settledRepayment;

        structValue    = this.createStructInvoice(_custVendTrans.TransDate,
                                                  sz,
                                                  amountDocument,
                                                  signInvoice * amountSettled,
                                                  signInvoice * amountTurnover,
                                                  _custVendTrans.RecId);

        conKey = this.createKey(_invoicePartitionType,
                                this.getInvoiceId(_custVendTrans),
                                invoiceNumValue,
                                agreementHeaderExtRecId);

        holderData.insert(conKey, structValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingPayment</Name>
				<Source><![CDATA[
        private void processingPayment(CustVendTrans              _custVendTrans,
                                   RActAdjustCVPartitionType  _paymentPartitionType,
                                   RActAdjustCVType           _actAdjustCVType)
    {
        CustVendTrans   originalTrans;

        Amount          amountOriginalDocument, amountDocument, amountSettled, amountTurnover, amountRemainder;
        Amount          amountRepayment, amountExchAdjustment, amountTurnoverRepayment;
        Amount          repaymentAdjustment, settlementOtherCurrency;
        str             documentDescription;
        TempStr         invoiceIdForPayment;
        Struct          struct;

        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;

        container       conKey;
        int             curentPaymNum, iNum = 0;
        AmountMST       unrealizedAmount;

        [amountDocument, amountSettled, amountExchAdjustment] = this.calcDocument(_custVendTrans, toDate);

        if (byAgreement)
        {
            agreementHeaderExtRecId = this.pickOutAgreement(_custVendTrans);
        }

        unrealizedAmount = this.calcUnrealizedExchAdj(_custVendTrans, toDate);

        originalTrans = this.findRootPayment(_custVendTrans);

        if ((_paymentPartitionType == RActAdjustCVPartitionType::PaymentCurrent) && (originalTrans.TransDate < fromDate))
        {
            this.processingPayment(_custVendTrans, RActAdjustCVPartitionType::PaymentPrevious, _actAdjustCVType);
            return;
        }

        curentPaymNum       = this.currentPaymentNum(originalTrans, _paymentPartitionType);
        invoiceIdForPayment = this.getInvoiceIdForPayment(originalTrans, _paymentPartitionType);

        conKey              = this.createKeyForPayment(originalTrans.RecId,
                                                       _custVendTrans,
                                                       _paymentPartitionType,
                                                       invoiceIdForPayment,
                                                       paymentNumValue,
                                                       RActAdjustCVPaymType::Payment,
                                                       agreementHeaderExtRecId);

        if (_custVendTrans.RecId == originalTrans.RecId)
            amountOriginalDocument = amountDocument;
        else
            amountOriginalDocument = (currencyTypeBrief == CurrencyTypeBrief_RU::Standard) ? originalTrans.AmountMST : originalTrans.AmountCur;

        documentDescription = this.getDocumentDescription(originalTrans);
        amountRemainder     = amountDocument - amountSettled + amountExchAdjustment + unrealizedAmount;

        amountTurnover = 0;

        if (currencyTypeBrief == CurrencyTypeBrief_RU::Currency)
        {
            settlementOtherCurrency = this.processingSettlementOtherCurrForPaym(originalTrans,
                                                                                _custVendTrans,
                                                                                _paymentPartitionType,
                                                                                _actAdjustCVType,
                                                                                paymentNumValue,
                                                                                agreementHeaderExtRecId);
            amountRemainder += settlementOtherCurrency;
            iNum            =  (settlementOtherCurrency == 0) ? 0 : 1;
        }

        if (_paymentPartitionType == RActAdjustCVPartitionType::PaymentCurrent)
            amountTurnover = amountRemainder;

        if (_actAdjustCVType == RActAdjustCVType::Payment)
        {
            [curentPaymNum,
             amountRepayment,
             repaymentAdjustment,
             amountTurnoverRepayment] = this.processingRepaymentForPayment(originalTrans, _custVendTrans,  _paymentPartitionType, paymentNumValue + iNum, agreementHeaderExtRecId);

            amountRemainder += amountRepayment - repaymentAdjustment;

            if (_paymentPartitionType == RActAdjustCVPartitionType::PaymentCurrent)
                amountTurnover += amountTurnoverRepayment - repaymentAdjustment;
        }

        struct = this.createStructPayment(originalTrans.TransDate,
                                          documentDescription,
                                          amountOriginalDocument,
                                          signPayment * amountRemainder,
                                          signPayment * amountTurnover,
                                          originalTrans.RecId);

        holderData.insert(conKey, struct);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingPaymentsForInvoice</Name>
				<Source><![CDATA[
        private container processingPaymentsForInvoice(CustVendTrans                _custVendTrans,
                                                   RActAdjustCVPartitionType    _partitionType,
                                                   AgreementHeaderExtRecId_RU   _agreementHeaderExtRecId)
    {
        RCalcExtraCustVendTransaction   calcExtraTransaction;
        RecordSortedList                rslSettlement;

        CustVendTrans       originalTrans;
        CustVendTrans       cvPayment    = custVendTable.transBuffer();
        CustVendSettlement  settlement   = custVendTable.settlementBuffer();

        RActAdjustCVType    actAdjustCVType;

        int                 iNum, lastNum, iTmp;

        Amount              amount, amountDocument, amountSettled, amountTurnover;
        Amount              settledPayment = 0, settledRepayment = 0;

        Set                 setAdjustment;
        Set                 setCashDiscAndPennyDiff;
        Set                 setOutExtraTrans;

        container           conKey, conTmp;
        Struct              structValue;
        str                 documentDescription;

        Map                 mapNum;
        Map                 mapDocType;
        boolean             loop;
        TempStr             szInvoiceIdForPayment;

        calcExtraTransaction = new RCalcExtraCustVendTransaction(_custVendTrans, fromDate, toDate, currencyTypeBrief);

        mapDocType    = new Map(Types::Integer, Types::Enum);

        rslSettlement = new RecordSortedList(settlement.TableId);
        rslSettlement.sortOrder(fieldname2id(settlement.TableId, fieldRecIdName));

        settlement = this.createCursorCustVendSettlement(_custVendTrans);

        while (this.moveNextSettlement(settlement))
        {
            cvPayment       = this.findCustVendTrans(settlement.OffsetRecId);
            actAdjustCVType = this.getDocumentType(cvPayment);

            if ((actAdjustCVType == RActAdjustCVType::Payment)   ||
               (actAdjustCVType == RActAdjustCVType::Repayment) ||
               (actAdjustCVType == RActAdjustCVType::CreditNote))
            {
                rslSettlement.ins(settlement);
                calcExtraTransaction.addCustVendTrans(cvPayment);

                if (!mapDocType.exists(cvPayment.RecId))
                    mapDocType.insert(cvPayment.RecId, actAdjustCVType);
            }
        }

        calcExtraTransaction.run();

        setCashDiscAndPennyDiff = new Set(typeName2Type(extendedTypeStr(recId)));
        setAdjustment           = new Set(typeName2Type(extendedTypeStr(recId)));
        setOutExtraTrans        = new Set(typeName2Type(extendedTypeStr(recId)));
        mapNum                  = new Map(Types::Container, Types::Integer);

        iNum                    = invoiceNumValue + iNumExchAdjInvoice;
        lastNum                 = iNum;

        loop = rslSettlement.first(settlement);

        while (loop)
        {
            cvPayment         = this.findCustVendTrans(settlement.OffsetRecId);
            actAdjustCVType   = mapDocType.lookup(cvPayment.RecId);

            originalTrans     = this.findRootPayment(cvPayment);

            documentDescription = this.getDocumentDescription(originalTrans);

            if (currencyTypeBrief == CurrencyTypeBrief_RU::Standard)
            {
                amountDocument = originalTrans.AmountMST;
                amountSettled  = settlement.SettleAmountMST;

                if (!setAdjustment.in(cvPayment.RecId))
                {
                    setAdjustment.add(cvPayment.RecId);

                    amountSettled += calcExtraTransaction.amountByRecID(cvPayment.RecId, _custVendTrans.RecId, CustVendTransPostingLogType_RU::ExchAdjustment) +
                                     calcExtraTransaction.amountByRecID(cvPayment.RecId, _custVendTrans.RecId, CustVendTransPostingLogType_RU::ExchAmountDiff);
                }
            }
            else
            {
                amountDocument = originalTrans.AmountCur;
                amountSettled  = settlement.SettleAmountCur;
            }

            if (!setCashDiscAndPennyDiff.in(cvPayment.RecId))
            {
                setCashDiscAndPennyDiff.add(cvPayment.RecId);

                amountSettled += calcExtraTransaction.amountByRecID(_custVendTrans.RecId, cvPayment.RecId, CustVendTransPostingLogType_RU::CashDisc)        +
                                 calcExtraTransaction.amountByRecID(cvPayment.RecId, _custVendTrans.RecId, CustVendTransPostingLogType_RU::CashDisc)        +
                                 calcExtraTransaction.amountByRecID(_custVendTrans.RecId, cvPayment.RecId, CustVendTransPostingLogType_RU::PennyDifference) +
                                 calcExtraTransaction.amountByRecID(cvPayment.RecId, _custVendTrans.RecId, CustVendTransPostingLogType_RU::PennyDifference);
            }

            if (actAdjustCVType == RActAdjustCVType::CreditNote)
            {
                structValue = this.createStructInvoice(originalTrans.TransDate,
                                                       documentDescription,
                                                       amountDocument,
                                                       -signInvoice * amountSettled,
                                                       0,
                                                       originalTrans.RecId);
            }
            else
            {
                amount         = amountSettled;
                amountTurnover = 0;

                if ((originalTrans.TransDate     >= fromDate)                       &&
                   (originalTrans.TransDate     <= toDate)                         &&
                   ((currencyTypeBrief          == CurrencyTypeBrief_RU::Standard) ||
                    (originalTrans.CurrencyCode == currencyCode)))
                {
                        amountTurnover = amount;
                }

                if (actAdjustCVType == RActAdjustCVType::Payment)
                    settledPayment   = amount;
                else
                    settledRepayment = amount;

                if (settlement.ReverseTrans_RU)
                {
                    documentDescription = strfmt("@GLS110605", documentDescription);

                    structValue         = this.createStructInvoice(originalTrans.TransDate,
                                                                   documentDescription,
                                                                   amountDocument,
                                                                   signPayment * amount,
                                                                   signPayment * amountTurnover,
                                                                   originalTrans.RecId);
                }
                else
                {
                    structValue = this.createStructPayment(originalTrans.TransDate,
                                                           documentDescription,
                                                           amountDocument,
                                                           signInvoice * amount,
                                                           signInvoice * amountTurnover,
                                                           originalTrans.RecId);
                }
            }

            if ((currencyTypeBrief != CurrencyTypeBrief_RU::Standard) && (currencyCode != originalTrans.CurrencyCode))
                structValue = RHolderData_ActAdjustCustVend::insertCurrencyCode(structValue, originalTrans.CurrencyCode);

            conTmp = this.keyMapNum(originalTrans, settlement);

            if (mapNum.exists(conTmp))
                iNum = mapNum.lookup(conTmp);
            else
            {
                lastNum++;
                iNum = lastNum;
                mapNum.insert(conTmp, iNum);
            }

            szInvoiceIdForPayment = this.getInvoiceId(_custVendTrans);

            conKey                = this.createKeyForPayment(originalTrans.RecId,
                                                             cvPayment,
                                                             _partitionType,
                                                             szInvoiceIdForPayment,
                                                             iNum,
                                                             (settlement.ReverseTrans_RU) ? RActAdjustCVPaymType::ReversePayment : RActAdjustCVPaymType::Payment,
                                                             _agreementHeaderExtRecId);

            holderData.insert(conKey, structValue);

            if (!setOutExtraTrans.in(cvPayment.RecId))
            {
                setOutExtraTrans.add(cvPayment.RecId);

                iTmp = this.processingCustVendSettlement(calcExtraTransaction,
                                                         _custVendTrans,
                                                         cvPayment,
                                                         documentDescription,
                                                         szInvoiceIdForPayment,
                                                         _partitionType,
                                                         iNum,
                                                         _agreementHeaderExtRecId);

                lastNum += iTmp;
            }

            loop = rslSettlement.next(settlement);
        }

        return [settledPayment, settledRepayment];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingRepaymentForPayment</Name>
				<Source><![CDATA[
        private container processingRepaymentForPayment(CustVendTrans              _origPayment,
                                                    CustVendTrans              _currentPayment,
                                                    RActAdjustCVPartitionType  _paymentPartitionType,
                                                    int                        _iNum,
                                                    AgreementHeaderExtRecId_RU _agreementHeaderExtRecId)
    {
        RCalcExtraCustVendTransaction   calcExtraTransaction;
        RecordSortedList                rslSettlement;

        CustVendTrans       cvRepayment  = custVendTable.transBuffer();
        CustVendSettlement  settlement   = custVendTable.settlementBuffer();

        RActAdjustCVType    actAdjustCVType;
        container           conKey, conTmp;
        Struct              structValue;

        Amount              amountAdjustment = 0, amountAdjustmentSymmetrical = 0;

        Amount              amountOfDoc, amountSettled, amountTurnover, amountTurnoverSum = 0;
        Amount              amount = 0;
        AmountMST           unrealizedAmount;

        int                 iTmp, iNum, lastNum = _iNum;
        Map                 mapNum;

        str                 documentDescription;
        TempStr             invoiceIdForPayment;
        boolean             loop;

        Set                 setCashDiscAndPennyDiff;
        Set                 setOutExtraTrans;
        Set                 setAdjustment;

        calcExtraTransaction = new RCalcExtraCustVendTransaction(_currentPayment, fromDate, toDate, currencyTypeBrief);

        rslSettlement = new RecordSortedList(settlement.TableId);
        rslSettlement.sortOrder(fieldname2id(settlement.TableId, fieldRecIdName));

        settlement = this.createCursorCustVendSettlement(_currentPayment);

        unrealizedAmount = this.calcUnrealizedExchAdj(_currentPayment, toDate);

        while (this.moveNextSettlement(settlement))
        {
            cvRepayment     = this.findCustVendTrans(settlement.OffsetRecId);
            actAdjustCVType = this.getDocumentType(cvRepayment);

            if (actAdjustCVType == RActAdjustCVType::Repayment)
            {
                rslSettlement.ins(settlement);
                calcExtraTransaction.addCustVendTrans(cvRepayment);
            }
        }

        calcExtraTransaction.run();

        setCashDiscAndPennyDiff = new Set(typeName2Type(extendedTypeStr(recId)));
        setOutExtraTrans        = new Set(typeName2Type(extendedTypeStr(recId)));
        setAdjustment           = new Set(typeName2Type(extendedTypeStr(recId)));
        mapNum                  = new Map(Types::Container, Types::Integer);

        loop = rslSettlement.first(settlement);

        while (loop)
        {
            cvRepayment         = this.findCustVendTrans(settlement.OffsetRecId);
            actAdjustCVType     = this.getDocumentType(cvRepayment);
            documentDescription = this.getDocumentDescription(cvRepayment);

            if (currencyTypeBrief == CurrencyTypeBrief_RU::Standard)
            {
                amountOfDoc   = cvRepayment.AmountMST;
                amountSettled = settlement.SettleAmountMST;

                if (!setAdjustment.in(cvRepayment.RecId))
                {
                    setAdjustment.add(cvRepayment.RecId);

                    amountSettled += calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::ExchAdjustment)    +
                                     calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::AdvanceAdjustment) +
                                     calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::ExchAmountDiff)    +
                                     unrealizedAmount;
                }
            }
            else
            {
                amountOfDoc   = cvRepayment.AmountCur;
                amountSettled = settlement.SettleAmountCur;
            }

            if ((cvRepayment.TransDate >= fromDate)                       &&
               (cvRepayment.TransDate <= toDate)                         &&
               ((currencyTypeBrief    == CurrencyTypeBrief_RU::Standard) ||
                (currencyCode         == cvRepayment.CurrencyCode)))
            {
                amountTurnover = amountSettled;
            }
            else
                amountTurnover = 0;

            if (!setCashDiscAndPennyDiff.in(cvRepayment.RecId))
            {
                setCashDiscAndPennyDiff.add(cvRepayment.RecId);

                amountSettled += calcExtraTransaction.amountByRecID(_currentPayment.RecId, cvRepayment.RecId, CustVendTransPostingLogType_RU::CashDisc)        +
                                 calcExtraTransaction.amountByRecID(_currentPayment.RecId, cvRepayment.RecId, CustVendTransPostingLogType_RU::PennyDifference) +
                                 calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::PennyDifference);
            }

            amount += amountSettled;

            if (settlement.ReverseTrans_RU)
                documentDescription = strfmt("@GLS110605", documentDescription);

            amountTurnoverSum += amountTurnover;
            structValue       =  this.createStructPayment(cvRepayment.TransDate, documentDescription, amountOfDoc, -signPayment * amountSettled, -signPayment * amountTurnover, cvRepayment.RecId);

            if ((currencyTypeBrief == CurrencyTypeBrief_RU::Currency) && (cvRepayment.CurrencyCode != currencyCode))
                structValue = RHolderData_ActAdjustCustVend::insertCurrencyCode(structValue, cvRepayment.CurrencyCode);

            conTmp = this.keyMapNum(cvRepayment, settlement);

            if (mapNum.exists(conTmp))
                iNum = mapNum.lookup(conTmp);
            else
            {
                lastNum++;
                iNum = lastNum;
                mapNum.insert(conTmp, iNum);
            }

            invoiceIdForPayment = this.getInvoiceIdForPayment(_origPayment, _paymentPartitionType);

            conKey = this.createKey(_paymentPartitionType,
                                    invoiceIdForPayment,
                                    iNum,
                                    _agreementHeaderExtRecId);

            holderData.insert(conKey, structValue);

            if (! setOutExtraTrans.in(cvRepayment.RecId))
            {
                setOutExtraTrans.add(cvRepayment.RecId);

                iTmp = this.processingCustVendSettlement(calcExtraTransaction,
                                                         _currentPayment,
                                                         cvRepayment,
                                                         documentDescription,
                                                         invoiceIdForPayment,
                                                         _paymentPartitionType,
                                                         iNum,
                                                         _agreementHeaderExtRecId);

                lastNum += iTmp;

                amountAdjustment            = calcExtraTransaction.amountByRecID(_currentPayment.RecId, cvRepayment.RecId, CustVendTransPostingLogType_RU::ExchAdjustment)    +
                                              calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::AdvanceAdjustment) +
                                              calcExtraTransaction.amountByRecID(_currentPayment.RecId, cvRepayment.RecId, CustVendTransPostingLogType_RU::ExchAmountDiff)    +
                                              unrealizedAmount;

                amountAdjustmentSymmetrical = calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::ExchAdjustment)    +
                                              calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::AdvanceAdjustment) +
                                              calcExtraTransaction.amountByRecID(cvRepayment.RecId, _currentPayment.RecId, CustVendTransPostingLogType_RU::ExchAmountDiff);
            }

            loop = rslSettlement.next(settlement);
        }

        return [lastNum, amount, amountAdjustment + amountAdjustmentSymmetrical, amountTurnoverSum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingSettlementOtherCurrForPaym</Name>
				<Source><![CDATA[
        private Amount processingSettlementOtherCurrForPaym(CustVendTrans              _origPayment,
                                                        CustVendTrans              _currentPayment,
                                                        RActAdjustCVPartitionType  _paymentPartitionType,
                                                        RActAdjustCVType           _actAdjustCVType,
                                                        int                        _iNum,
                                                        AgreementHeaderExtRecId_RU _agreementHeaderExtRecId)
    {
        Struct      struct;
        Amount      amount, amountSettlement, amountSettlementRepayment;
        container   conKey;
        int         iNum = _iNum;

        [amountSettlement, amountSettlementRepayment] = this.calcPaymSettlementOtherCurrency(_currentPayment, _currentPayment.CurrencyCode);

        switch (_actAdjustCVType)
        {
            case RActAdjustCVType::Payment   :
                amount = amountSettlement - amountSettlementRepayment;
                break;

            case RActAdjustCVType::Repayment :
                amount = amountSettlement;
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcname()));
        }

        if (amount != 0)
        {
            iNum++;

            struct = this.createStructInvoice(dateNull(), "@GLS110616", 0, - signInvoice * amount, 0);
            struct = RHolderData_ActAdjustCustVend::insertCurrencyCode(struct, "");

            conKey = this.createKeyForPayment(_origPayment.RecId,
                                              _currentPayment,
                                              _paymentPartitionType,
                                              this.getInvoiceIdForPayment(_origPayment, _paymentPartitionType),
                                              iNum,
                                              RActAdjustCVPaymType::OtherCurrency,
                                              _agreementHeaderExtRecId);

            holderData.insert(conKey, struct);
        }

        return  amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingUnrealizedAdjustment</Name>
				<Source><![CDATA[
        private AmountMST processingUnrealizedAdjustment(CustVendTrans              _custVendTrans,
                                                     RActAdjustCVPartitionType  _partitionType,
                                                     AgreementHeaderExtRecId_RU _agreementHeaderExtRecId)
    {
        CustVendTrans              exchCustVendTrans = CustVendTransStatic::newTrans(_custVendTrans).custVendTrans();
        container                  conKey;
        Struct                     structValue;
        str                        sz;
        int                        iNum;

        if (currencyTypeBrief == CurrencyTypeBrief_RU::Standard)
        {
            iNumExchAdjInvoice = 0;

            select sum(AmountMST), maxof(TransDate) from exchCustVendTrans
                where exchCustVendTrans.OffsetRecId == _custVendTrans.RecId          &&
                      exchCustVendTrans.TransType == LedgerTransType::ExchAdjustment &&
                      exchCustVendTrans.TransDate >= fromDate                        &&
                      exchCustVendTrans.TransDate <= toDate                          &&
                      exchCustVendTrans.ExchAdjustmentUnrealized;
            if (exchCustVendTrans.AmountMST)
            {
                sz = strfmt("@SYS70938", enum2Value(CustVendTransPostingLogType_RU::UnrealisedExchAdj), _custVendTrans.Voucher);

                if (signInvoice * exchCustVendTrans.AmountMST > 0)
                {
                     structValue = this.createStructInvoice(exchCustVendTrans.TransDate,
                                                            sz,
                                                            signInvoice * exchCustVendTrans.AmountMST,
                                                            signInvoice * exchCustVendTrans.AmountMST,
                                                            signInvoice * exchCustVendTrans.AmountMST,
                                                            _custVendTrans.RecId);
                }
                else
                {
                     structValue = this.createStructPayment(exchCustVendTrans.TransDate,
                                                            sz,
                                                            signPayment * exchCustVendTrans.AmountMST,
                                                            signPayment * exchCustVendTrans.AmountMST,
                                                            signPayment * exchCustVendTrans.AmountMST,
                                                            _custVendTrans.RecId);
                }

                iNumExchAdjInvoice ++;
                iNum = invoiceNumValue + iNumExchAdjInvoice;
                conKey = this.createKey(_partitionType, this.getInvoiceId(_custVendTrans), iNum, _agreementHeaderExtRecId);

                holderData.insert(conKey, structValue);
            }
        }

        return exchCustVendTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
        public void run(Query _query = null)
    {
        this.initAccounts();

        this.getCovenanteeBegPeriodBalance();

        this.collectData();

        setCalculatedAgreementBegPerBalance = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>takeIntoPayment</Name>
				<Source><![CDATA[
        protected boolean takeIntoPayment(CustVendTrans _custVendTrans)
    {
        boolean              bRet       = false;
        CustVendSettlement   settlement = custVendTable.settlementBuffer();

        if (_custVendTrans.remainAmountMST() != 0)
             bRet = true;
        else
        {
            select firstonly settlement
                where   settlement.TransRecId    == _custVendTrans.RecId &&
                        settlement.CanBeReversed == NoYes::Yes;

            if (settlement)
                bRet = true;
        }

        return bRet;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>