<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AxInternalBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Provides the framework that is used in the <c>AxBC</c> table classes.
/// </summary>
/// <remarks>
///  This framework is deprecated.
/// </remarks>
// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
abstract class AxInternalBase
{
    boolean             currentRecordIsSet;
    Map                 fieldTouched;
    Set                 fieldModified;
    InternalExternal    inputstatus;
    boolean             validateInput;
    boolean             defaulting;
    boolean             continueOnError;
    Map                 tableCache;
    Map                 classCache;
    int                 cacheIdx;
    AxBCRunState        runState;
    Set                 setMethodsCalled;
    AxInternalBase      axOrig;
    AxInternalBase      parentAxBc ;
    XMLDocDirection     docDirection ;
    boolean             useMapPolicy ;
    Set                 mandatoryFieldsExemptions ;
    Map                 dictFieldMap;
    Map                 dictClassMap;
    AxMapPolicy         mapPolicy;
    str                 dataSourceName;
    recId               curRecId;
    recVersion          curRecVersion;
    str                 documentHash;
    AxdRecordAction     recordAction;
    boolean             isProcessed;
    str                 axbcTypeId;
    Map                 axbcArraySizeMap;

    #define.axBCPrefix('Ax')

    // CahceOwner macro defines a string describing the owner of the cached data.
    #localmacro.CacheOwner
    classstr(AxInternalBase)
        #endmacro


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>axOrig</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the original object.
    /// </summary>
    /// <returns>
    /// The original object.
    /// </returns>
    public AxInternalBase axOrig()
    {
        if (!axOrig)
        {
            axOrig = AxInternalBase::construct(AxdUtil::getRecordOrig(this.currentRecord()));
        }

        return axOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a value is valid with regard to a number sequence table.
    /// </summary>
    /// <param name="_numberSequenceTable">
    ///    A number sequence table in which the value should be checked for validity.
    /// </param>
    /// <param name="_fieldId">
    ///    The field ID in the table that uses the number sequence table. It is used in error messages if a
    ///    check fails.
    /// </param>
    /// <param name="_num">
    ///    The value to check for validity in the <c>NumberSequenceTable</c> table.
    /// </param>
    /// <remarks>
    ///    The <c>checkNumber</c> method is created for checking whether the value supplied to a field that
    ///    relates to a number sequence follows the field's number sequence.
    /// </remarks>
    protected void checkNumber(NumberSequenceTable _numberSequenceTable,
        fieldId             _fieldId,
            Num                 _num)
    {
        Integer     numStripped;
        DictField   dictField;
        boolean     ret     = true;

        if (this.validateInput())
        {
            if (_numberSequenceTable.numAllowEdit())
            {
                if (_numberSequenceTable.AllowChangeDown || _numberSequenceTable.AllowChangeUp)
                {
                    if (_numberSequenceTable.Format && !NumberSeq::numCheckFormat(_num,_numberSequenceTable))
                    {
                        dictField = this.sysDictFieldFind(_fieldId);
                        ret = false;
                        error(strFmt("@SYS98198",dictField.label() ? dictField.label() : "@SYS13864"));
                    }

                    if (!_numberSequenceTable.Format && _num != int2str(str2int(_num)))
                    {
                        dictField = this.sysDictFieldFind(_fieldId);
                        ret = false;
                        error(strFmt("@SYS70843",dictField.label() ? dictField.label() : "@SYS13864"));
                    }

                    if (ret)
                    {
                        numStripped  = NumberSeq::numRemoveFormat(_num,_numberSequenceTable.Format);

                        if (numStripped <= 0)
                        {
                            dictField = this.sysDictFieldFind(_fieldId);
                            ret = false;
                            error(strFmt("@SYS70843",dictField.label() ? dictField.label() : "@SYS13864"));
                        }

                        if (numStripped < _numberSequenceTable.Lowest)
                        {
                            ret = false;
                            error(strFmt("@SYS70863",_numberSequenceTable.Lowest));
                        }

                        if (numStripped > _numberSequenceTable.Highest)
                        {
                            ret = false;
                            error(strFmt("@SYS70849",_numberSequenceTable.Highest));
                        }
                    }
                }
            }
            else
            {
                dictField = this.sysDictFieldFind(_fieldId);
                error(strFmt("@SYS96663",_numberSequenceTable.NumberSequence,dictField.label()));
                ret = false;
            }

            if (!ret && !continueOnError)
            {
                throw error("@SYS23020");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>classCacheDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete an object from the cache.
    /// </summary>
    /// <param name="_cacheIdx">
    /// The index of the target object.
    /// </param>
    protected void classCacheDelete(int _cacheIdx)
    {
        classCache.remove(_cacheIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>classCacheExist</Name>
				<Source><![CDATA[
    protected boolean classCacheExist(int _cacheIdx)
    {
        return classCache.exists(_cacheIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>classCacheInsert</Name>
				<Source><![CDATA[
    protected void classCacheInsert(int _cacheIdx, Object _cacheClass)
    {
        classCache.insert(_cacheIdx, _cacheClass);
    }

]]></Source>
			</Method>
			<Method>
				<Name>classCacheLookup</Name>
				<Source><![CDATA[
    protected Object classCacheLookup(int _cacheIdx)
    {
        return classCache.lookup(_cacheIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearField</Name>
				<Source><![CDATA[
    public void clearField(fieldId _fieldId,boolean _markAsTouched)
    {
        Common              common;
        int                 arraySize;
        int                 arrayIndex;

        arraySize = this.getFieldArraySize(_fieldId);
        if (arraySize > 1 && fieldExt2Idx(_fieldId) == 0)
        {
            for (arrayIndex = 1;
            arrayIndex <= arraySize;
            arrayIndex++)
            {
                this.clearField(fieldId2Ext(_fieldId, arrayIndex), _markAsTouched);
            }
        }
        else
        {
            switch (_fieldId)
            {
                case fieldNum(Common,RecId):
                    this.parmRecId(0);
                    break;
                case fieldNum(Common,RecVersion):
                    this.parmRecVersion(0);
                    break;
                default:
                    common = this.currentRecord();
                    common.(_fieldId) = Global::nullValue(common.(_fieldId));
            }
            if (_markAsTouched)
            {
                this.setFieldAsTouched(_fieldId);
            }
            else
            {
                fieldTouched.remove(_fieldId);
                fieldModified.remove(_fieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueOnError</Name>
				<Source><![CDATA[
    public boolean continueOnError(boolean _continueOnError = continueOnError)
    {
        continueOnError = _continueOnError;

        return continueOnError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateRelatedRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is for updating or creating records that relates to the data in the AxBC class.
    /// </summary>
    /// <remarks>
    ///    This is an internal method for the AxBC framework that must be overridden in the individual AxBC
    ///    class if there wants to be performed any code in the AxBC class after defaulting and before
    ///    validation is performed.An example on how to do this can be seen in the <c>AXSalesLine</c> class.
    /// </remarks>
    protected void createOrUpdateRelatedRecords()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the current record in the AxBC table.
    /// </summary>
    /// <param name="_common">
    /// Instance of the common object for the class.
    /// </param>
    /// <returns>
    /// The instance of the common object for the class.
    /// </returns>
    public Common currentRecord(Common _common = null)
    {
        if (!prmisDefault(_common))
        {
            currentRecordIsSet = true;
        }

        return _common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doModify</Name>
				<Source><![CDATA[
    public void doModify()
    {
        runState = AxBCRunState::Modify;

        this.initRecord();

        this.inputStatus(InternalExternal::Internal);

        if (defaulting)
        {
            this.setTableFields();

            this.setDimensionEntitySpecifiers();
        }

        this.createOrUpdateRelatedRecords();

        this.validateFields();

        this.resetInternalValues();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves or updates a record.
    /// </summary>
    /// <remarks>
    ///    This method does the actual work regarding inserting and updating a record.This method performs the
    ///    following tasks:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             Executes the <c>initValue</c> method on the <c>currentRecord</c> table.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Defaults the fields on the <c>currentRecord</c> table.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Validates the fields on the <c>currentRecord</c> table if <c>validateInput</c> is set to true.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Executes the <c>validateInput</c> method on the <c>currentRecord</c> table.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Executes the write method on the <c>currentRecord</c> table.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>Resets the internal values that are used by the class.</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    public void doSave()
    {
        ttsbegin;

        runState        = AxBCRunState::Save;
        fieldModified   = new Set(Types::Integer);

        this.initRecord();

        this.inputStatus(InternalExternal::Internal);

        if (defaulting)
        {
            this.setTableFields();

            this.setDimensionEntitySpecifiers();
        }

        this.createOrUpdateRelatedRecords();

        this.validateFields();

        this.validateWrite();

        this.write();

        this.resetInternalValues();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an empty record for the table that the AxBC class relates to.
    /// </summary>
    /// <returns>
    /// An empty record from the table that the AxBC class relates to.
    /// </returns>
    /// <remarks>
    /// In order to obtain a cleared record that is used when you initialize before inserting new records,
    /// the abstract <c>emptyRecord</c> method on the <c>AxInternalBase</c> class must be implemented.The
    /// overriding methods must follow the following template: (Code Example Removed)
    /// </remarks>
    abstract protected Common emptyRecord()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>end</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Throws an error if an inventDim section was missing in an XML string.
    /// </summary>
    /// <remarks>
    ///    The <c>end</c> method is used for processing incoming documents and is run before popping an AxBC
    ///    object off the stack. The method is needed because AxBC classes have <c>AxInventDim</c> as a child.
    ///    Therefore it must throw an error if no inventory dimension section has been encountered in the
    ///    XML.The method is intended for internal use only and should not be called through the interface.
    /// </remarks>
    public void end()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for a field in the table that relates to the AxBC table class, depending on
    /// the field ID.
    /// </summary>
    /// <param name="_fieldId">
    /// The ID for the field you want to set or get the value for in the AxBC table class.
    /// </param>
    /// <param name="_value">
    /// The value for the field you want set.
    /// </param>
    /// <returns>
    /// Value for the field based on the field ID.
    /// </returns>
    /// <remarks>
    /// The <c>fieldId</c> method can be used instead of the parameter methods.
    /// </remarks>
    public anytype fieldId(fieldId _fieldId, anytype _value = '')
    {
        if (!prmisDefault(_value))
        {
            this.setField(_fieldId, _value);
        }

        return this.currentRecord().(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldArraySize</Name>
				<Source><![CDATA[
    private int getFieldArraySize(fieldId _fieldId)
    {
        SysDictField            sysDictField;
        int                     arraySize;

        sysDictField = this.sysDictFieldFind(_fieldId);
        arraySize = sysDictField.arraySize();

        return arraySize;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMandatoryFieldExemptions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the list of fields that the AxBC class has specified as not mandatory in the <see
    ///    cref="M:AxInternalBase.initMandatoryFieldsExemptionList" />.
    /// </summary>
    /// <returns>
    ///    The set of field names of the fields for which are specified as not mandatory.
    /// </returns>
    /// <remarks>
    ///    The <c>getMandatoryFieldExcemptions</c> method only returns the list from <see
    ///    cref="M:AxInternalBase.initMandatoryFieldsExemptionList" />, not a list of all fields that are not
    ///    mandatory. The list is used to make exceptions to the list of mandatory fields derived from the
    ///    data model, that is if a field is mandatory in the data model but part of the returned list it is
    ///    not considered mandatory at the AxBC class level.
    /// </remarks>
    public Set getMandatoryFieldExemptions()
    {
        if (!mandatoryFieldsExemptions)
        {
            this.initMandatoryFieldsExemptionList() ;
        }

        return mandatoryFieldsExemptions ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModifiedFields</Name>
				<Source><![CDATA[
    public Set  getModifiedFields()
    {
        Set set;

        set = Set::create(fieldModified.pack());
        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes internal values of the current AxBC class.
    /// </summary>
    protected void init()
    {
        currentRecordIsSet      = false;
        this.resetInternalValues();

        fieldModified           = new Set(Types::Integer);
        dictFieldMap            = new Map(Types::Integer, Types::Class);
        useMapPolicy            = true;
        defaulting              = true;
        recordAction            = AxdRecordAction::None;
        isProcessed             = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMandatoryFieldsExemptionList</Name>
				<Source><![CDATA[
    protected void initMandatoryFieldsExemptionList()
    {
        mandatoryFieldsExemptions = new Set(Types::String) ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callInitRecord</Name>
				<Source><![CDATA[
    public void callInitRecord()
    {
        this.initRecord();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecord</Name>
				<Source><![CDATA[
    protected void initRecord()
    {
        Common localCommon;

        if (!currentRecordIsSet && !this.currentRecord().RecId && defaulting)
        {
            localCommon = this.emptyRecord();
            localCommon.initValue();
            this.moveTableFields(localCommon);
            this.currentRecord(localCommon);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>callInputStatus</Name>
				<Source><![CDATA[
    public int callInputStatus(InternalExternal _inputStatus = inputStatus)
    {
        return this.inputstatus(_inputStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inputStatus</Name>
				<Source><![CDATA[
    protected int inputStatus(InternalExternal _inputStatus = inputStatus)
    {
        inputStatus = _inputStatus;

        return inputStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFieldModified</Name>
				<Source><![CDATA[
    public boolean isFieldModified(fieldId _fieldId)
    {
        int arrayIndex, arraySize;

        arraySize = this.getFieldArraySize(_fieldId);
        if (arraySize > 1 && fieldExt2Idx(_fieldId) == 0)
        {
            for (arrayIndex = 1;
            arrayIndex <= arraySize;
            arrayIndex++)
            {
                if (this.isFieldModified(fieldId2Ext(_fieldId, arrayIndex)))
                {
                    return true;
                }
            }
        }
        else
        {
            if (fieldModified.in(_fieldId))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFieldSet</Name>
				<Source><![CDATA[
    public boolean isFieldSet(fieldId _fieldId)
    {
        int arrayIndex, arraySize;

        arraySize = this.getFieldArraySize(_fieldId);
        if (arraySize > 1 && fieldExt2Idx(_fieldId) == 0)
        {
            for (arrayIndex = 1;
            arrayIndex <= arraySize;
            arrayIndex++)
            {
                if (this.isFieldSet(fieldId2Ext(_fieldId, arrayIndex)))
                {
                    return true;
                }
            }
        }
        else
        {
            if (fieldTouched.exists(_fieldId))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFieldSetExternally</Name>
				<Source><![CDATA[
    protected boolean isFieldSetExternally(fieldId _fieldId)
    {
        int arrayIndex, arraySize;

        arraySize = this.getFieldArraySize(_fieldId);
        if (arraySize > 1 && fieldExt2Idx(_fieldId) == 0)
        {
            for (arrayIndex = 1;
            arrayIndex <= arraySize;
            arrayIndex++)
            {
                if (this.isFieldSetExternally(fieldId2Ext(_fieldId, arrayIndex)))
                {
                    return true;
                }
            }
        }
        else
        {
            if (fieldTouched.exists(_fieldId))
            {
                if (fieldTouched.lookup(_fieldId) == 1)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMethodExecuted</Name>
				<Source><![CDATA[
    protected boolean isMethodExecuted(str _methodName, fieldId _fieldId = 0)
    {
        if (setMethodsCalled.in(_methodName))
        {
            return true;
        }

        setMethodsCalled.add(_methodName);

        if (_fieldId)
        {
            if (this.isFieldSet(_fieldId))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetMethodsCalledFromModify</Name>
				<Source><![CDATA[
    public boolean isSetMethodsCalledFromModify()
    {
        return runState == AxBCRunState::Modify;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetMethodsCalledFromSave</Name>
				<Source><![CDATA[
    public boolean isSetMethodsCalledFromSave()
    {
        return !this.isSetMethodsCalledFromModify();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetMethodsCalledFromUpdate</Name>
				<Source><![CDATA[
    public boolean isSetMethodsCalledFromUpdate()
    {
        return this.isSetMethodsCalledFromSave()&&this.currentRecord().RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapPolicy</Name>
				<Source><![CDATA[
    public AxMapPolicy mapPolicy (AxMapPolicy _mapPolicy = mapPolicy)
    {
        mapPolicy = _mapPolicy ;
        return mapPolicy ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modify</Name>
				<Source><![CDATA[
    public void modify()
    {
        this.doModify();
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTableFields</Name>
				<Source><![CDATA[
    private void moveTableFields(Common _common)
    {
        Common          currentRecord = this.currentRecord();
        MapIterator     fieldTouchedIterator;
        SetEnumerator   fieldModifiedEnumerator;
        fieldId         fieldId;

        void moveField(fieldId _fieldId)
        {
            switch (_fieldId)
            {
                case fieldNum(Common,RecId),fieldNum(Common,RecVersion):
                    break;
                default:
                    _common.(_fieldId) = currentRecord.(_fieldId);
                    break;
            }
        }

        fieldTouchedIterator = new MapIterator(fieldTouched);

        fieldTouchedIterator.begin();

        while (fieldTouchedIterator.more())
        {
            fieldId = fieldTouchedIterator.domainValue();
            moveField(fieldId);
            fieldTouchedIterator.next();
        }

        fieldModifiedEnumerator = fieldModified.getEnumerator();
        while (fieldModifiedEnumerator.moveNext())
        {
            fieldId = fieldModifiedEnumerator.current();

            if (!fieldTouched.exists(fieldId))
            {
                moveField(fieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        this.init();
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextCacheIdx</Name>
				<Source><![CDATA[
    protected int nextCacheIdx()
    {
        cacheIdx++;
        return cacheIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentAxBC</Name>
				<Source><![CDATA[
    AxInternalBase  parentAxBC(AxInternalBase _parentAxBC = parentAxBC)
    {
        parentAxBC = _parentAxBC ;
        return parentAxBC ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecId</Name>
				<Source><![CDATA[
    recId parmRecId(recId _recId = curRecId)
    {
        //The recId is a special field that cannot be written.
        //In order to read recId in inbound XML a parm method has been added. The read value
        //will be stored in the class, not in the table buffer, for later retrieval.
        fieldId     fieldId = fieldNum(Common,RecId);

        if (!prmisDefault(_recId))
        {
            if (fieldTouched.exists(fieldId))
            {
                if (this.inputStatus() == InternalExternal::Internal && fieldTouched.lookup(fieldId) == InternalExternal::External)
                {
                    return _recId;
                }
            }
            curRecId = _recId;
            this.setFieldAsTouched(fieldId);
        }
        if (curRecId)
        {
            return curRecId;
        }
        else
        {
            return this.currentRecord().RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecVersion</Name>
				<Source><![CDATA[
    recVersion parmRecVersion(recVersion _recVersion = curRecVersion)
    {
        //The recId is a special field that cannot be written.
        //In order to read recId in inbound XML a parm method has been added. The read value
        //will be stored in the class, not in the table buffer, for later retrieval.
        fieldId     fieldId = fieldNum(Common,RecVersion);

        if (!prmisDefault(_recVersion))
        {
            if (fieldTouched.exists(fieldId))
            {
                if (this.inputStatus() == InternalExternal::Internal && fieldTouched.lookup(fieldId) == InternalExternal::External)
                {
                    return _recVersion;
                }
            }
            curRecVersion = _recVersion;
            this.setFieldAsTouched(fieldId);
        }
        if (curRecVersion)
        {
            return curRecVersion;
        }
        else
        {
            return AxdUtil::getRootRecord(this.currentRecord()).RecVersion;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconstruct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets internal values of the current AxBC class and assigns a new table buffer.
    /// </summary>
    /// <param name="_common">
    ///    The table buffer to be assigned to the current AxBC class.
    /// </param>
    public void reconstruct(Common _common)
    {
        // Reset internal values
        this.init();

        // Set the current record
        if (_common)
        {
            // Use the record provided by the caller
            this.currentRecord(_common);
        }
        else
        {
            // Use an empty record
            this.currentRecord(this.emptyRecord());
            currentRecordIsSet = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetInternalValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Re-initializes the internal values of the current AxBC class.
    /// </summary>
    public void resetInternalValues()
    {
        fieldTouched            = new Map(Types::Integer, Types::Enum);
        tableCache              = new Map(Types::Integer, Types::Record);
        classCache              = new Map(Types::Integer, Types::Class);
        setMethodsCalled        = new Set(Types::String);
        axOrig                  = null;
        curRecId                = 0;
        curRecVersion           = 0;
        documentHash            = '';

        this.inputStatus(InternalExternal::External);
    }

]]></Source>
			</Method>
			<Method>
				<Name>save</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts or updates the current record for the AxBC class.
    /// </summary>
    /// <remarks>
    ///    The <c>save</c> instance method on the AxBC class should be executed after having assigned new
    ///    values to fields.The actual work regarding saving and updating a record is performed in the
    ///    <c>doSave</c> method, which this method is calling.
    /// </remarks>
    public void save()
    {
        this.doSave();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrentRecordFromExternal</Name>
				<Source><![CDATA[
    public void setCurrentRecordFromExternal(Common _common = null)
    {
        this.currentRecord(_common);
        this.resetInternalValues();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimensionEntitySpecifiers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the financial dimension entity specifiers for the record.
    /// </summary>
    /// <remarks>
    ///    This method is called after the <c>setTableFields</c> method. Therefore, all the fields that are
    ///    entity specifiers are set. Needs to be overwritten in the classes that have <c>DefaultDimension</c>
    ///    field.
    /// </remarks>
    protected void setDimensionEntitySpecifiers()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Assigns a value to a field in the <c>currentRecord</c> that is assigned to the AxBC class.
    /// </summary>
    /// <param name="_fieldId">
    ///    The field ID for the field you want to assign a value to.
    /// </param>
    /// <param name="_anytype">
    ///    The value that you want to assign to the field.
    /// </param>
    /// <remarks>
    ///    This method is intended for use by the <c>fieldName</c> and <c>parmFieldName</c> methods in the
    ///    AxBC class.The <c>setField</c> method on an <c>AxInternalBase</c> object checks whether the field
    ///    has already been set to a specific value. If the field has not been set to a value, this method
    ///    assigns the specified value to the field. It also updates the list of fields that have assigned
    ///    values assigned to them. If the field has already been set to a value, this method does not assign
    ///    the value to the field.An actual implementation can be viewed in the declaration of the
    ///    <c>parmCustGroup</c> method on the <c>AxSalesTable</c> class.
    /// </remarks>
    protected void setField(fieldId _fieldId, anytype _anytype)
    {
        Common currentRecord = this.currentRecord();

        if (fieldTouched.exists(_fieldId))
        {
            if (this.inputStatus() == InternalExternal::Internal && fieldTouched.lookup(_fieldId) == InternalExternal::External)
            {
                return ;
            }
        }

        currentRecord.(_fieldId) = _anyType;
        this.setFieldAsTouched(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldAsModified</Name>
				<Source><![CDATA[
    public void setFieldAsModified(fieldId _fieldId)
    {
        int arrayIndex, arraySize;

        arraySize = this.getFieldArraySize(_fieldId);
        if (arraySize > 1 && fieldExt2Idx(_fieldId) == 0)
        {
            for (arrayIndex = 1;
            arrayIndex <= arraySize;
            arrayIndex++)
            {
                this.setFieldAsModified(fieldId2Ext(_fieldId, arrayIndex));
            }
        }
        else
        {
            fieldModified.add(_fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldAsTouched</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets a field as touched.
    /// </summary>
    /// <param name="_fieldId">
    ///    The field ID for the field that is to be marked as touched.
    /// </param>
    /// <remarks>
    ///    This instance method can be used by a consumer to use the defaulting logic in the AxBC class after
    ///    a value has been assigned to a table field.The method takes a field ID as a parameter, and when it
    ///    is executed, it marks that the field has already been assigned a value. Executing <c>modify</c> or
    ///    <c>save</c> will thereafter resolve the intra-table field relations, and default, any other fields
    ///    that depend on the field, which is set as touched.
    /// </remarks>
    public void setFieldAsTouched(fieldId _fieldId)
    {
        int arrayIndex, arraySize;

        arraySize = this.getFieldArraySize(_fieldId);
        if (arraySize > 1 && fieldExt2Idx(_fieldId) == 0)
        {
            for (arrayIndex = 1;
            arrayIndex <= arraySize;
            arrayIndex++)
            {
                this.setFieldAsTouched(fieldId2Ext(_fieldId, arrayIndex));
            }
        }
        else
        {
            fieldTouched.insert(_fieldId, this.inputStatus());
            fieldModified.add(_fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParmMethodAsNotMandatory</Name>
				<Source><![CDATA[
    void setParmMethodAsNotMandatory(str fieldName)
    {
        SysDictClass    dc = new SysDictClass(classIdGet(this)) ;

        if (!dc)
        {
            throw(error(strFmt("@SYS4973",classIdGet(this)))) ;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTableFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Ensures that all default methods are called before inserting or updating a record.
    /// </summary>
    /// <remarks>
    ///    In order to make sure that all defaulting methods are called before inserting or updating a record,
    ///    the <c>setTableFields</c> method on the <c>AxInternalBase</c> class must be overridden in the AxBC
    ///    class.The method should include a call to all defaulting methods, that is, setFieldName
    ///    methods.Code the defaulting business logic in the different setFieldName methods. That way, you do
    ///    not have to put the setFieldName methods in a specific order in this method.
    /// </remarks>
    protected void setTableFields()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictFieldFind</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>SysDictField</c> class for a field in the table that relates to the AxBC class.
    /// </summary>
    /// <param name="_fieldId">
    ///    Field ID for a field in the table that relates to the AxBC class.
    /// </param>
    /// <returns>
    ///    The <c>SysDictField</c> class for the field ID in the parameter.
    /// </returns>
    /// <remarks>
    ///    The <c>sysDictFieldFind</c> method uses a map to hold the <c>SysDictField</c> classes so that the
    ///    instantiated <c>SysDictField</c> classes can be reused instead of instantiating a
    ///    <c>SysDictField</c> class every time that you must use one.
    /// </remarks>
    protected SysDictField sysDictFieldFind(fieldId _fieldId)
    {
        SysDictField    sysDictField;

        if (dictFieldMap.exists(_fieldId))
        {
            sysDictField = dictFieldMap.lookup(_fieldId);
        }
        else
        {
            sysDictField = new SysDictField(this.emptyRecord().TableId, _fieldId);
            dictFieldMap.insert(_fieldId,sysDictField);
        }
        return sysDictField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableCacheExist</Name>
				<Source><![CDATA[
    protected boolean tableCacheExist(int _cacheIdx)
    {
        return tableCache.exists(_cacheIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableCacheInsert</Name>
				<Source><![CDATA[
    protected void tableCacheInsert(int _cacheIdx, Common _cacheRecord)
    {
        tableCache.insert(_cacheIdx, _cacheRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableCacheLookup</Name>
				<Source><![CDATA[
    protected Common tableCacheLookup(int _cacheIdx)
    {
        return tableCache.lookup(_cacheIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>validateField</c> method for the current record and logs an error for validation
    ///    failures.
    /// </summary>
    /// <param name="_field">
    ///    The field identifier that corresponds to the field being validated.
    /// </param>
    /// <remarks>
    ///    An error will be thrown when the <c>continueOnError</c> parameter is set to false for endpoint.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    Creation has been canceled.
    /// </exception>
    protected void validateField(fieldId _field)
    {
        if (!this.currentRecord().validateField(_field))
        {
            if (continueOnError)
            {
                error("@SYS98197");
            }
            else
            {
                throw error("@SYS23020");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>callValidateFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calls the <c>validateFields</c> method on the current instance.
    /// </summary>
    public void callValidateFields()
    {
        this.validateFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFields</Name>
				<Source><![CDATA[
    protected void validateFields()
    {
        fieldId         fieldId;
        Common          currentRecord;
        SysDictField    dictField;
        fieldId         parentFieldId;
        int             array;
        int             tableId;
        int             arraySize;
        MapEnumerator   fieldEnumerator;
        Set             validatedArrays;

        void setContext(tableId _tableId, fieldId _fieldId)
        {
            str fieldName;

            fieldName = fieldId2name(_tableId, _fieldId);
            setPrefix(fieldName);
        }

        if (this.validateInput())
        {
            currentRecord = this.currentRecord();
            fieldEnumerator = fieldTouched.getEnumerator();
            tableId = currentRecord.TableId;
            validatedArrays = new Set(Types::Integer);
            while (fieldEnumerator.moveNext())
            {
                fieldId = fieldEnumerator.currentKey();
                parentFieldId = fieldExt2Id(fieldId);
                if (fieldId != parentFieldId)
                {
                    //This is an array element. If one array element is set we validate all array elements
                    //Check to see if we've already validated this array
                    if (!validatedArrays.in(parentFieldId))
                    {
                        setContext(tableId, parentFieldId);

                        dictField = new SysDictField(tableId, parentFieldId);
                        arraySize = dictField.arraySize();
                        for (array=1;
                        array <= arraySize;
                        array++)
                        {
                            dictField = new SysDictField(tableId, parentFieldId, array);
                            this.validateField(dictField.id());
                        }
                        validatedArrays.add(parentFieldId);
                    }
                }
                else
                {
                    setContext(tableId, fieldId);
                    this.validateField(fieldId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInboundString</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the string length for an incoming string.
    /// </summary>
    /// <param name="_string">
    ///    The string that the length is to be validated for.
    /// </param>
    /// <param name="_dictField">
    ///    The <c>DictField</c> class for the field that the string relates to.
    /// </param>
    /// <param name="_xmlMapExternalCode">
    ///    The policy for how the string length is validated.
    /// </param>
    /// <remarks>
    ///    The <c>validateInboundString</c> method is used in parm&lt;FieldName&gt; methods that contain code
    ///    for performing value mapping.The <c>validateInboundString</c> method is created because
    ///    parm&lt;FieldName&gt; methods that are using value mapping use "str" as parameter type and
    ///    therefore do not have an extended data type to define the maximum length for the passed parameter.
    /// </remarks>
    //This method validates the string length for an inbound string
    protected void validateInboundString(str _string, DictField _dictField, XMLMapExternalCode _xmlMapExternalCode = XMLMapExternalCode::NotSpecified)
    {
        DictField   dictFieldExtCode;
        boolean     ret;

        if (validateInput)
        {
            if (this.valueMappingInbound())
            {
                if (_xmlMapExternalCode != XMLMapExternalCode::ExternalCode)
                {
                    ret = strLen(_string) > _dictField.stringLen();
                }
            }
            else
            {
                ret = strLen(_string) > _dictField.stringLen();
            }

            if (ret)
            {
                error(strFmt("@SYS88485",_dictField.name()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInput</Name>
				<Source><![CDATA[
    public boolean validateInput(boolean _validateInput = validateInput)
    {
        validateInput = _validateInput;
        return validateInput;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callValidateWrite</Name>
				<Source><![CDATA[
    public void callValidateWrite()
    {
        this.validateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    protected void validateWrite()
    {
        if (this.validateInput())
        {
            if (!this.doValidateWrite())
            {
                if (continueOnError)
                {
                    error("@SYS98197");
                }
                else
                {
                    throw error("@SYS23020");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>valueMapDependingFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs incoming value mapping of fields where the value mapping for a field depends on another
    ///    field, such as the Item, state, and county fields.
    /// </summary>
    /// <remarks>
    ///    This method is used in the save method. Therefore the incoming value mapping is performed before
    ///    the defaulting of fields.
    /// </remarks>
    protected void valueMapDependingFields ()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>valueMappingInbound</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the AxBC class can use value-mapping incoming.
    /// </summary>
    /// <returns>
    ///    true if the AxBC class can use value-mapping incoming; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The use of value mapping depends on the map policy, the <c>XMLDocDirection</c> that is passed to
    ///    the AxBC class, and the <c>useMapPolicy</c> variable.
    /// </remarks>
    protected boolean valueMappingInbound()
    {
        boolean res ;

        res =  mapPolicy &&
            useMapPolicy == true &&
                this.xmlDocDirection() == XMLDocDirection::Inbound ;

        return res ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>valueMappingOutbound</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the AxBC class can use value mapping outgoing.
    /// </summary>
    /// <returns>
    ///    true if the AxBC class can use value mapping outgoing; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The use of value mapping depends on the map policy, the <c>XMLDocDirection</c> that is passed to
    ///    the AxBC class, and the <c>useMapPolicy</c> variable.
    /// </remarks>
    protected boolean valueMappingOutbound()
    {
        boolean res ;
        res = mapPolicy &&
            docDirection == XMLDocDirection::Outbound &&
                useMapPolicy == true;

        return res ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callWrite</Name>
				<Source><![CDATA[
    public void callWrite()
    {
        this.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>write</Name>
				<Source><![CDATA[
    protected void write()
    {
        this.currentRecord().write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>xmlDocDirection</Name>
				<Source><![CDATA[
    public XMLDocDirection xmlDocDirection(XMLDocDirection _xmlDocDirection = docDirection )
    {
        docDirection = _xmlDocDirection ;
        return docDirection ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs the AxBC class that relates to the specified table instance.
    /// </summary>
    /// <param name="_common">
    ///    The table instance that defines which AxBC class to construct.
    /// </param>
    /// <returns>
    ///    The constructed AxBC object that corresponds to the table in the <paramref name="_common" />
    ///    parameter. If the table instance in the <paramref name="_common" /> parameter relates to a record
    ///    in the database, the record will be embedded in the AxBC object.
    /// </returns>
    /// <remarks>
    ///    The construct method for the <c>AxInternalBase</c> class is generic. Therefore, it creates an AxBC
    ///    class that corresponds to the table record in the <paramref name="_common" /> parameter.If a
    ///    corresponding AxBC class does not exist for the table ID that is passed in the <paramref
    ///    name="_common" /> parameter, this method returns a <c>null</c> object.
    /// </remarks>
    static AxInternalBase construct(Common _common)
    {
        AxInternalBase  newClassInstance;
        classId         classId;
        tableId         tableId;
        SysDictClass    sysDictClass;

        tableId = tableName2id(_common.getInstanceRelationType());
        if (tableId == 0)
        {
            tableId = _common.TableId;
        }

        classId = AxInternalBase::tableId2AxBCClassId(tableId);

        sysDictClass = new SysDictClass(classId);
        if (sysDictClass && !sysDictClass.isAbstract())
            newClassInstance = classfactory.createClass(classId) ;

        if (newClassInstance != null)
        {
            newClassInstance.reconstruct(_common);
        }
        return newClassInstance ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableId2AxBCClassId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the ID of the AxBC class that corresponds a particular table.
    /// </summary>
    /// <param name="_tableId">
    ///    The ID of the table for which to get the class ID of the that corresponds AxBC class.
    /// </param>
    /// <returns>
    ///    The ID of the AxBC class that corresponds to the particular table.
    /// </returns>
    /// <remarks>
    ///    The <c>tableId2AxBCClassId</c> method retrieves the ID of the AxBC class that corresponds to a
    ///    table ID specified as input. This is performed by adding a prefix of Ax to the table name.
    /// </remarks>
    public static classId tableId2AxBCClassId(tableId _tableId)
    {
        return className2Id( #AXBCPrefix  + tableId2name(_tableId)) ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClassNumAxInternalBaseSubscriber</Name>
				<Source><![CDATA[
    [SubscribesTo(classstr(SysDictMethod), delegatestr(SysDictMethod, getClassNumAxInternalBase))]
    static void getClassNumAxInternalBaseSubscriber(EventHandlerResult eventHandlerResult)
    {
        eventHandlerResult.result(classNum(AxInternalBase));
    }

]]></Source>
			</Method>
			<Method>
				<Name>doValidateWrite</Name>
				<Source><![CDATA[
    protected boolean doValidateWrite()
    {
        return this.currentRecord().validateWrite();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>