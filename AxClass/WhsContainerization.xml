<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSContainerization</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsContainerization</c> class is used to run containerization of containers or work lines.
/// </summary>
public class WhsContainerization
{
    #WHSStatusUpdateFrequency
    #WHSLineNumSplit

    WHSWaveId                   parmWaveId;
    WHSWorkBuildId              workCreateId;
    WHSWaveTemplateLine         waveTemplateLine;
    WHSContainerBuildId         containerBuildId;
    WHSWaveExecutionID          waveExecutionId;
    WHSContainerizationTable    containerizationTable;
    container                   itemValues;
    container                   orderValues;
    container                   conValues;
    WHSWeightUOM                weightUOM;
    WHSTmpWorkLine              curTmpWorkLine;
    WHSWaveProgressLog          createWaveProgressLog;
    Map                         containerVolumeCache;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addContainerToParentContainer</Name>
				<Source><![CDATA[
    private void addContainerToParentContainer(
        WHSContainerTable _container,
        WHSContainerTable _parentContainer)
    {
        _container.ParentContainerId = _parentContainer.ContainerId;
        _container.ContainerLevel++;
        _container.update();
        this.increaseChildContainerLevel(_container);
        //we need to clear the volume cache since the volume of the parent depends on the childrens volume
        this.clearContainersVolumeFromCache(_parentContainer.ContainerId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseChildContainerLevel</Name>
				<Source><![CDATA[
    private void increaseChildContainerLevel(WHSContainerTable _container)
    {
        WHSContainerTable childContainer;

        while select forupdate childContainer
            where childContainer.ParentContainerId == _container.ContainerId
        {
            childContainer.ContainerLevel++;
            childContainer.update();
            this.increaseChildContainerLevel(childContainer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerVolume</Name>
				<Source><![CDATA[
    private Volume containerVolume(WHSContainerTable _containerTable)
    {
        if (!_containerTable)
        {
            return 0;
        }
        
        if (containerVolumeCache.exists(_containerTable.ContainerId))
        {
            return containerVolumeCache.lookup(_containerTable.ContainerId);
        }
    
        Volume containerVolume = _containerTable.calculateVolume();

        containerVolumeCache.insert(_containerTable.ContainerId, containerVolume);

        return containerVolume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearContainersVolumeFromCache</Name>
				<Source><![CDATA[
    private void clearContainersVolumeFromCache(WHSContainerId _containerId)
    {
        containerVolumeCache.remove(_containerId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowMixContainerQuery</Name>
				<Source><![CDATA[
    private boolean checkAllowMixContainerQuery(WHSContainerTable _parentContainer, WHSContainerTable _curContainer)
    {
        if (containerizationTable.ContainerizationQueryType != WHSContainerizationQueryType::Container)
        {
            // method should've not been called when ContainerizationQueryType different than container.
            throw error(error::wrongUseOfFunction(funcName()));
        }

        boolean ret = containerizationTable.RecId == _parentContainer.ContainerizationTable;

        if (ret)
        {
            this.initOldValuesForCheckAllowMix(_parentContainer.ContainerId);

            // Compare the current record values with the old values.
            Query query = new Query(queryStr(WHSContainerizationContainer));
            SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(WHSContainerTable)), fieldNum(WHSContainerTable, RecId)).value(SysQuery::value(_curContainer.RecId));
            ret = this.checkMixQuery(query, conValues);
        }

        if (!ret)
        {
            this.clearOldValues();

            WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                      _parentContainer.ContainerId,
                                                                      waveExecutionId,
                                                                      strFmt("@WAX3835", _parentContainer.ContainerId),
                                                                      false,
                                                                      null,
                                                                      _curContainer,
                                                                      parmWaveId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowMixTmpWorkQuery</Name>
				<Source><![CDATA[
    private boolean checkAllowMixTmpWorkQuery(WHSContainerTable _curContainer, WHSTmpWorkLine _curTmpWorkLine)
    {
        if (containerizationTable.ContainerizationQueryType == WHSContainerizationQueryType::Container)
        {
            // method should've not been called when ContainerizationQueryType is container.
            throw error(error::wrongUseOfFunction(funcName()));
        }

        boolean ret = containerizationTable.RecId == _curContainer.ContainerizationTable;

        if (ret)
        {
            this.initOldValuesForCheckAllowMix(_curContainer.ContainerId);

            // Compare the current record values with the old values.
            Query query = new Query(queryStr(WHSMixingLogicItemQuery));
            SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(WHSTmpWorkLine)), fieldNum(WHSTmpWorkLine, RecId)).value(SysQuery::value(_curTmpWorkLine.RecId));
            ret = this.checkMixQuery(query, itemValues);

            if (ret)
            {
                query = this.createContainerizationOrderValueQuery();
                SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(WHSTmpWorkLine)), fieldNum(WHSTmpWorkLine, RecId)).value(SysQuery::value(_curTmpWorkLine.RecId));
                ret = this.checkMixQuery(query, orderValues);
            }
        }

        if (!ret)
        {
            this.clearOldValues();

            WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                      _curContainer.ContainerId,
                                                                      waveExecutionId,
                                                                      strFmt("@WAX3835", _curContainer.ContainerId),
                                                                      false,
                                                                      _curTmpWorkLine,
                                                                      _curContainer,
                                                                      parmWaveId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOldValuesForCheckAllowMix</Name>
				<Source><![CDATA[
    private void initOldValuesForCheckAllowMix(WHSContainerId _containerId)
    {
        if (containerizationTable.ContainerizationQueryType == WHSContainerizationQueryType::Container)
        {
            if (conValues == conNull())
            {
                Query query = new Query(queryStr(WHSContainerizationContainer));
                SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(WHSContainerTable)), fieldNum(WHSContainerTable, ParentContainerId)).value(SysQuery::value(_containerId));
                this.populateOldValues(query);
            }
        }
        else
        {
            if (itemValues == conNull())
            {
                Query query = new Query(queryStr(WHSMixingLogicItemQuery));
                SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(WHSTmpWorkLine)), fieldNum(WHSTmpWorkLine, ContainerId)).value(SysQuery::value(_containerId));
                this.populateOldValues(query);
            }

            if (orderValues == conNull())
            {
                Query query = this.createContainerizationOrderValueQuery();
                SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(WHSTmpWorkLine)), fieldNum(WHSTmpWorkLine, ContainerId)).value(SysQuery::value(_containerId));
                this.populateOldValues(query);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContainerizationOrderValueQuery</Name>
				<Source><![CDATA[
    private Query createContainerizationOrderValueQuery()
    {
        if (containerizationTable.ContainerizationQueryType == WHSContainerizationQueryType::SalesAllocation)
        {
            return new Query(queryStr(WHSMixingLogicSOQuery));
        }
        
        return new Query(queryStr(WHSMixingLogicTOQuery));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkContainerVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the container can be packed into the parent container without exceeding physical dimensions and volumentrics of the container.
    /// </summary>
    /// <param name="_containerGroupLine">
    /// The container group representing the container type of the potential parent container and utilization precentage.
    /// </param>
    /// <param name="_containerTable">
    /// The container to be packed.
    /// </param>
    /// <param name="_curWeight">
    /// The current weight of the parent container.
    /// </param>
    /// <param name="_curVolume">
    /// The current filled volume of the parent container.
    /// </param>
    /// <param name="_checkPhysDims">
    /// A Boolean that determines if physical dimensions (length, depth, height) need to be validated; optional.
    /// </param>
    /// <returns>
    /// Returns a container with 3 Boolean values representing: do physical dimensions fit, does volume fit, and does weight fit, respectively.
    /// </returns>
    public container checkContainerVolumetrics(
        WHSContainerGroupLine   _containerGroupLine,
        WHSContainerTable       _containerTable,
        Weight                  _curWeight,
        Volume                  _curVolume,
        boolean                 _checkPhysDims = true)
    {
        boolean             physDimFit;
        boolean             volumeFit;
        boolean             weightFit;
        WHSContainerType    innerContainerType;
        WHSContainerType    parentContainerType;
        Weight              totalWeight;
        Volume              totalVolume;
        WHSContainerLine    containerLine;

        innerContainerType = WHSContainerType::find(_containerTable.ContainerTypeCode);
        // If the container type doesn't exist then we assume that this is a full case or other UOM of an item and we need to grab dims from the item.
        if (!innerContainerType.RecId)
        {
            containerLine = _containerTable.getFirstContainerLine();

            [physDimFit, volumeFit, weightFit] = this.validateVolumetricsOfContainer(_containerTable, _containerGroupLine, containerLine.itemKey(), containerLine.Qty, containerLine.UnitId, _curWeight, _curVolume, false, _checkPhysDims);
        }
        else
        {
            parentContainerType = WHSContainerType::find(_containerGroupLine.ContainerTypeCode);

            if (_checkPhysDims)
            {
                physDimFit = WHSContainerization::checkPhysDims(innerContainerType.Length,
                                                                innerContainerType.Width,
                                                                innerContainerType.Height,
                                                                parentContainerType.Length,
                                                                parentContainerType.Width,
                                                                parentContainerType.Height,
                                                                true);
            }

            if (physDimFit || !_checkPhysDims)
            {
                totalWeight = _containerTable.calculateWeight() + _curWeight;
                totalVolume = innerContainerType.calcContainerVolume() + _curVolume;

                volumeFit = totalVolume <= (parentContainerType.MaxVolume * (_containerGroupLine.FillPercentage / 100));
                weightFit = totalWeight <= (parentContainerType.MaxWeight * (_containerGroupLine.FillPercentage / 100));
            }
        }

        return [physDimFit, volumeFit, weightFit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetricsOfEmptyContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates item volumemetrics when adding to an empty container.
    /// </summary>
    /// <param name="_containerTable">
    /// Current container
    /// </param>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemKey">
    /// An <c>InventItemKey</c> object identiyfing the item to validate volumetrics for.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity of the item
    /// </param>
    /// <param name="_physicalUnitSymbol">
    /// Physial unit of measure of the handling quantity.
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    [Hookable(false)]
    final public container validateVolumetricsOfEmptyContainer(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol)
    {
        return this.validateVolumetricsOfContainer(_containerTable, _containerGroupLine, _itemKey, _handlingQty, _physicalUnitSymbol, 0.0, 0.0, false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetricsAddingToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates item volumemetrics when adding item to a container.
    /// </summary>
    /// <param name="_containerTable">
    /// Current container
    /// </param>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemKey">
    /// An <c>InventItemKey</c> object identiyfing the item to validate volumetrics for.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity of the item
    /// </param>
    /// <param name="_physicalUnitSymbol">
    /// Physial unit of measure of the handling quantity.
    /// </param>
    /// <param name="_checkLengths">
    /// Boolean determining whether physical length dimensions should be checked.
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    [Hookable(false)]
    final public container validateVolumetricsAddingToContainer(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol,
        boolean                 _checkLengths)
    {
        return this.validateVolumetricsOfContainer(_containerTable, _containerGroupLine, _itemKey, _handlingQty, _physicalUnitSymbol, _containerTable.Weight, this.containerVolume(_containerTable), _containerTable.isItemAlreadyIncluded(_itemKey, _physicalUnitSymbol), _checkLengths);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetricsOfContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates item volumemetrics for a container.
    /// </summary>
    /// <param name="_containerTable">
    /// Current container
    /// </param>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemKey">
    /// An <c>InventItemKey</c> object identiyfing the item to validate volumetrics for.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity of the item
    /// </param>
    /// <param name="_physicalUnitSymbol">
    /// Physial unit of measure of the handling quantity.
    /// </param>
    /// <param name="_currentWeight">
    /// Current weight of the container.
    /// </param>
    /// <param name="_currentVolume">
    /// Current volume of the container.
    /// </param>
    /// <param name="_itemIsAlreadyContained">
    /// Boolean describing whether is item is already added to the container.
    /// </param>
    /// <param name="_checkLengths">
    /// Boolean determining whether physical length dimensions should be checked.
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    private container validateVolumetricsOfContainer(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol,
        Weight                  _currentWeight,
        Volume                  _currentVolume,
        boolean                 _itemIsAlreadyContained,
        boolean                 _checkLengths)
    {
        return this.validateContainerVolumetricsInContainer(_containerTable, _containerGroupLine, _itemKey, _handlingQty, _physicalUnitSymbol, _currentWeight, _currentVolume, _itemIsAlreadyContained, _checkLengths);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemVolumetricsForContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check item volumetrics for a container.
    /// </summary>
    /// <param name="_containerTable">
    /// Current container
    /// </param>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemId">
    /// Id of the item to check
    /// </param>
    /// <param name="_qty">
    /// Quantity of the item
    /// </param>
    /// <param name="_uom">
    /// Unit of measure of the item
    /// </param>
    /// <param name="_curWeight">
    /// Current weight
    /// </param>
    /// <param name="_curVolume">
    /// Current volume
    /// </param>
    /// <param name="_checkPhysDims">
    /// true if physical dimensions should be checked; otherwise, false
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    [SysObsolete('Method is obsoleted to support package dimensions. Callers should redict their calls to the validateVolumetricsAddingToContainer or validateVolumetricsOfEmptyContainer. Extenders should wrap the validateContainerVolumetrics method.', false, 19\12\2019)]
    public container checkItemVolumetricsForContainer(WHSContainerTable _containerTable, WHSContainerGroupLine _containerGroupLine, ItemId _itemId, Qty _qty, UnitOfMeasureSymbol _uom,  Weight _curWeight = 0, Volume _curVolume = 0, boolean _checkPhysDims = true)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerVolumetricsInContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates volumetrics for items in a container.
    /// </summary>
    /// <param name="_containerTable">
    /// A container to validate volumetrics for.
    /// </param>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemKey">
    /// An <c>InventItemKey</c> object identiyfing the item to validate volumetrics for.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity of the item
    /// </param>
    /// <param name="_physicalUnitSymbol">
    /// Physial unit of measure of the handling quantity.
    /// </param>
    /// <param name="_currentWeight">
    /// Current weight of the container.
    /// </param>
    /// <param name="_currentVolume">
    /// Current volume of the container.
    /// </param>
    /// <param name="_itemIsAlreadyContained">
    /// Boolean describing whether is item is already added to the container.
    /// </param>
    /// <param name="_checkLengths">
    /// Boolean determining whether physical length dimensions should be checked.
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    private container validateContainerVolumetricsInContainer(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol,
        Weight                  _currentWeight,
        Volume                  _currentVolume,
        boolean                 _itemIsAlreadyContained,
        boolean                 _checkLengths)
    {
        return this.validateVolumetrics(_containerTable, _containerGroupLine, _itemKey, _handlingQty, _physicalUnitSymbol, _currentWeight, _currentVolume, _itemIsAlreadyContained, _checkLengths);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEmptyContainerVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates item volumetrics for an empty container.
    /// </summary>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemKey">
    /// An <c>InventItemKey</c> object identiyfing the item to validate volumetrics for.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity of the item
    /// </param>
    /// <param name="_physicalUnitSymbol">
    /// Physial unit of measure of the handling quantity.
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    private container validateEmptyContainerVolumetrics(
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol)
    {
        WHSContainerTable emptyContainerTable;

        return this.validateVolumetrics(emptyContainerTable, _containerGroupLine, _itemKey, _handlingQty, _physicalUnitSymbol, 0.0, 0.0, false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates item volumetrics
    /// </summary>
    /// <param name="_containerTable">
    /// A container to validate volumetrics for.
    /// </param>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemKey">
    /// An <c>InventItemKey</c> object identiyfing the item to validate volumetrics for.
    /// </param>
    /// <param name="_handlingQty">
    /// Handling quantity of the item
    /// </param>
    /// <param name="_physicalUnitSymbol">
    /// Physial unit of measure of the handling quantity.
    /// </param>
    /// <param name="_currentWeight">
    /// Current weight of the container.
    /// </param>
    /// <param name="_currentVolume">
    /// Current volume of the container.
    /// </param>
    /// <param name="_itemIsAlreadyContained">
    /// Boolean describing whether is item is already added to the container.
    /// </param>
    /// <param name="_checkLengths">
    /// Boolean determining whether physical length dimensions should be checked.
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    private container validateVolumetrics(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol,
        Weight                  _currentWeight,
        Volume                  _currentVolume,
        boolean                 _itemIsAlreadyContained,
        boolean                 _checkLengths)
    {
        return this.validateContainerVolumetrics(_containerTable, _containerGroupLine, _itemKey, _handlingQty, _physicalUnitSymbol, _currentWeight, _currentVolume, _itemIsAlreadyContained, _checkLengths);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check item volume metric
    /// </summary>
    /// <param name="_containerGroupLine">
    /// Current container group line of the container
    /// </param>
    /// <param name="_itemId">
    /// Id of the item to check
    /// </param>
    /// <param name="_qty">
    /// Quantity of the item
    /// </param>
    /// <param name="_uom">
    /// Unit of measure of the item
    /// </param>
    /// <param name="_curWeight">
    /// Current weight
    /// </param>
    /// <param name="_curVolume">
    /// Current volume
    /// </param>
    /// <param name="_checkPhysDims">
    /// true if physical dimensions should be checked; otherwise, false
    /// </param>
    /// <returns>
    /// Returns a container with three booleans
    /// Value one is if physical dims fit, value two is if volume fits and  value three is if weight fits.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute,
    SysObsolete('Method is obsoleted to support package dimensions. Callers should redict their calls to the validateVolumetricsAddingToContainer or validateVolumetricsOfEmptyContainer. Extenders should wrap the validateContainerVolumetrics method.', false, 19\12\2019)]
    public container checkItemVolumetrics(WHSContainerGroupLine _containerGroupLine, ItemId _itemId, Qty _qty, UnitOfMeasureSymbol _uom,  Weight _curWeight = 0, Volume _curVolume = 0, boolean _checkPhysDims = true)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerVolumetrics</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    final protected container validateContainerVolumetrics(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine,
        InventItemKey           _itemKey,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _physicalUnitSymbol,
        Weight                  _currentWeight,
        Volume                  _currentVolume,
        boolean                 _itemIsAlreadyContained,
        boolean                 _checkLengths)
    {
        boolean             lengthFit;
        boolean             volumeFit;
        boolean             weightFit;
        WHSContainerType    containerType = WHSContainerType::find(_containerGroupLine.ContainerTypeCode);;
        InventHandlingQty   handlingQty = _handlingQty;
        InventParameters    inventParameters = InventParameters::find();

        Weight              totalWeight = (_currentWeight ? _currentWeight - containerType.TareWeight : 0.0);
        Volume              totalVolume = _currentVolume;

        if (handlingQty > 1.0)
        {
            EcoResIPhysicalDimensions nestedPackingDimensions = EcoResPhysicalProductDimensions::retrieveNestedPackingDimensions(_itemKey.productKey(), _physicalUnitSymbol);

            if (nestedPackingDimensions)
            {
                nestedPackingDimensions = EcoResUnitConvertedPhysicalDimensions::createInstance(nestedPackingDimensions, inventParameters.massUnitSymbol, inventParameters.lengthUnitSymbol, inventParameters.VolumeUnitSymbol);

                InventHandlingQty nestingHandlingQty = _itemIsAlreadyContained ? handlingQty : (handlingQty - 1.0);

                totalVolume += nestingHandlingQty * nestedPackingDimensions.parmVolume();
                totalWeight += nestingHandlingQty * nestedPackingDimensions.parmWeight();

                handlingQty -= nestingHandlingQty;
            }
        }

        EcoResIPhysicalDimensions packingDimensions = EcoResPhysicalProductDimensions::retrievePackingDimensions(_itemKey.productKey(), _physicalUnitSymbol);

        if (packingDimensions)
        {
            packingDimensions = EcoResUnitConvertedPhysicalDimensions::createInstance(packingDimensions, inventParameters.massUnitSymbol, inventParameters.lengthUnitSymbol, inventParameters.VolumeUnitSymbol);

            if (packingDimensions)
            {
                totalVolume += handlingQty * packingDimensions.parmVolume();
                totalWeight += handlingQty * packingDimensions.parmWeight();
            }
        }

        if (_checkLengths)
        {
            if (packingDimensions)
            {
                lengthFit = WHSContainerization::checkPhysDims(packingDimensions.parmDepth(),
                                                               packingDimensions.parmWidth(),
                                                               packingDimensions.parmHeight(),
                                                               containerType.Length,
                                                               containerType.Width,
                                                               containerType.Height,
                                                               true);
            }
            else
            {
                lengthFit = true;
            }
        }

        if (lengthFit || !_checkLengths)
        {
            volumeFit = totalVolume <= (containerType.MaxVolume * (_containerGroupLine.FillPercentage/100));
            weightFit = totalWeight <= (containerType.MaxWeight * (_containerGroupLine.FillPercentage/100));
        }

        return [lengthFit, volumeFit, weightFit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMixQuery</Name>
				<Source><![CDATA[
    private boolean checkMixQuery(Query q, container _oldValues)
    {
        WHSContainerizationBreak    conBreak;
        QueryRun                    qr;
        Common                      table;
        anytype                     field;
        int                         i = 1;
        boolean                     ret = true;

        qr = new QueryRun(q);

        if (qr.next())
        {
            while select GroupTableId, GroupFieldId from conBreak
                where conBreak.RefRecId == containerizationTable.RecId
            {
                if (qr.query().dataSourceTable(conBreak.GroupTableId))
                {
                    table = qr.get(conBreak.GroupTableId);
                    field = table.(conBreak.GroupFieldId);

                    if (typeOf(field) != typeOf(conPeek(_oldValues, i )) || field != conPeek(_oldValues, i))
                    {
                        ret = false;
                        break;
                    }
                    else
                    {
                        ret = true;
                    }
                    ++i;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearOldValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears all old values.
    /// </summary>
    private void clearOldValues()
    {
        // Clear all old values
        itemValues = conNull();
        orderValues = conNull();
        conValues = conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Containerizes either containers or allocation lines depending on the query type.
    /// </summary>
    public void containerize()
    {
        // Determine if we are packing allocation lines or containers
        select firstonly ContainerizationQueryType from containerizationTable
            where containerizationTable.WaveStepCode == waveTemplateLine.WaveStepCode;

        if (containerizationTable.ContainerizationQueryType == WHSContainerizationQueryType::Container)
        {
            // Loop over containers
            this.containerizeContainers();
        }
        else
        {
            // Loop over allocation lines
            this.containerizeTmpWorkLines();
        }

        // Down size containers
        this.downsizeContainers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerizeContainers</Name>
				<Source><![CDATA[
    protected void containerizeContainers()
    {
        int                         executedSteps;
        int                         totalSteps;
        WHSContainerTable           curContainerTable;
        WHSContainerTable           parentContainerTable;
        WHSContainerGroupLine       containerGroupLine;
        QueryRun                    qr;
        QueryBuildDataSource        qbds;

        while select containerizationTable
            order by containerizationTable.SeqNum asc
            where containerizationTable.WaveStepCode == waveTemplateLine.WaveStepCode
        {
            qr = new QueryRun(containerizationTable.ContainerizationQuery);

            // Make sure query passes for container record
            qbds = qr.query().dataSourceTable(tableNum(WHSContainerTable));
            SysQuery::findOrCreateRange(qbds, fieldNum(WHSContainerTable, WaveExecutionID)).value(waveExecutionId);
            SysQuery::findOrCreateRange(qbds, fieldNum(WHSContainerTable, ParentContainerId)).value(SysQuery::valueEmptyString());

            totalSteps = SysQuery::countLoops(qr);
            executedSteps = 0;

            // Make sure we don't hit new parent containers in the loop by comparing executed steps to the total steps.
            while (qr.next() && executedSteps < totalSteps)
            {
                // Increment executed Steps
                executedSteps++;

                // LOG: Container Build Template Succeeded
                WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                          '',
                                                                          waveExecutionId,
                                                                          strFmt("@WAX3760", containerizationTable.ContainerizationName),
                                                                          false,
                                                                          null,
                                                                          curContainerTable,
                                                                          parmWaveId);

                curContainerTable = qr.get(tableNum(WHSContainerTable));
                // Must reselect record to keep it up to date
                curContainerTable = WHSContainerTable::find(curContainerTable.ShipmentId, curContainerTable.ContainerId);

                while select containerGroupLine
                    order by containerGroupLine.SeqNum asc
                    where containerGroupLine.ContainerGroupId    == containerizationTable.ContainerGroupID
                {
                    // If current container has been fully processed, break out of loop.
                    if (curContainerTable.ParentContainerId)
                    {
                        break;
                    }

                    // Evaluate existing container
                    if (containerizationTable.ContainerPackingStrategy == WHSContainerPackingStrategy::CurrentContainer)
                    {
                        curContainerTable = this.packContainer(curContainerTable, containerGroupLine, parentContainerTable);
                        parentContainerTable = WHSContainerTable::find(curContainerTable.ShipmentId, curContainerTable.ParentContainerId);
                    }
                    else
                    {
                        this.clearOldValues();
                        // Loop over all parent containers.
                        while select parentContainerTable
                            where parentContainerTable.ContainerGroupId    == containerGroupLine.ContainerGroupId  &&
                                  parentContainerTable.ContainerBuildId    == containerBuildId                        &&
                                  parentContainerTable.ShipmentId          == curContainerTable.ShipmentId
                        {
                            curContainerTable = this.packContainer(curContainerTable, containerGroupLine, parentContainerTable, false);
                        }

                        // If it can't fit in any existing contaners try an empty container.
                        if (!curContainerTable.ParentContainerId)
                        {
                            curContainerTable = this.packContainer(curContainerTable, containerGroupLine, null, true);
                        }

                        parentContainerTable = WHSContainerTable::find(curContainerTable.ShipmentId, curContainerTable.ParentContainerId);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerizeTmpWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Containerizes allocation lines for temporary work lines.
    /// </summary>
    protected void containerizeTmpWorkLines()
    {
        WHSContainerTable       containerTable;
        
        ttsbegin;

        // Loop over container build templates that match the waveStepCode.
        while select containerizationTable
            order by containerizationTable.SeqNum asc
            where containerizationTable.WaveStepCode == waveTemplateLine.WaveStepCode
        {
            QueryRun qr = new QueryRun(containerizationTable.ContainerizationQuery);

            // Only loop over tmpWorkLines that are for this work created id and have not been assigned a container already.
            QueryBuildDataSource qbds = qr.query().dataSourceTable(tableNum(WHSTmpWorkLine));
                                                                                                                                                                
            // Sort by shipment id to prevent creating unnecessary packages.
            qbds.addSortField(fieldNum(WHSTmpWorkLine, ShipmentId));

            SysQuery::findOrCreateRange(qbds, fieldNum(WHSTmpWorkLine, WorkCreateId)).value(SysQuery::value(workCreateId));
            SysQuery::findOrCreateRange(qbds, fieldNum(WHSTmpWorkLine, ContainerId)).value(SysQuery::valueEmptyString());

            while (qr.next())
            {
                curTmpWorkLine = WHSTmpWorkLine::findByRecId(qr.get(tableNum(WHSTmpWorkLine)).RecId);

                // LOG: Container Build Template Succeeded
                WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                          '',
                                                                          waveExecutionId,
                                                                          strFmt("@WAX3760", containerizationTable.ContainerizationName),
                                                                          false,
                                                                          curTmpWorkLine);

                // Pack by UOM
                if (containerizationTable.PackByUnitOfMeasure == NoYes::Yes)
                {
                    this.packByUOM();
                }
                else // Normal Packing Logic
                {
                    this.packByVolumetrics(containerTable);
                }

                if (!curTmpWorkLine.ContainerId)
                {
                    // LOG: Line failed to pack
                    WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                              '',
                                                                              waveExecutionId,
                                                                              strFmt("@WAX3771",
                                                                                     curTmpWorkLine.DirectiveQty,
                                                                                     curTmpWorkLine.DirectiveUOM,
                                                                                     curTmpWorkLine.ItemId),
                                                                              true,
                                                                              curTmpWorkLine);
                    // LOG in wave exeuction history
                    WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId,
                                                                  waveExecutionId,
                                                                  strFmt("@WAX3771", curTmpWorkLine.DirectiveQty, curTmpWorkLine.DirectiveUOM, curTmpWorkLine.ItemId),
                                                                  true,
                                                                  curTmpWorkLine);

                    // Put this error in info log
                    warning(strFmt("@WAX3771", curTmpWorkLine.DirectiveQty, curTmpWorkLine.DirectiveUOM, curTmpWorkLine.ItemId));

                    // Pack line in error container
                    this.packErrorContainer(containerizationTable.ContainerGroupID);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packByVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pack container using volumetrics.
    /// </summary>
    /// <param name="_containerTable">The container record use as part of the packing process.</param>
    protected void packByVolumetrics(WHSContainerTable _containerTable)
    {
        WHSContainerGroupLine containerGroupLine;
        WHSContainerTable     currentContainerTable = _containerTable;
        
        while select containerGroupLine
            order by containerGroupLine.SeqNum asc
            where containerGroupLine.ContainerGroupId == containerizationTable.ContainerGroupID
        {
            // If current TmpWorkLine has been fully processed, break out of loop.
            if (curTmpWorkLine.ContainerId)
            {
                break;
            }

            // Evaluate existing container
            if (containerizationTable.ContainerPackingStrategy == WHSContainerPackingStrategy::CurrentContainer)
            {
                curTmpWorkLine = this.packTmpWorkLine(containerGroupLine, containerizationTable.AllowSplitPicks, currentContainerTable);
                currentContainerTable = WHSContainerTable::find(curTmpWorkLine.ShipmentId, curTmpWorkLine.ContainerId);
            }
            else
            {
                this.clearOldValues();
                // Loop over all containers too see if we can fit the full qty in it.
                while select currentContainerTable
                    where currentContainerTable.ContainerGroupId  == containerGroupLine.ContainerGroupId  &&
                          currentContainerTable.ContainerTypeCode == containerGroupLine.ContainerTypeCode &&
                          currentContainerTable.ContainerBuildId  == containerBuildId                     &&
                          currentContainerTable.ShipmentId        == curTmpWorkLine.ShipmentId
                {
                    curTmpWorkLine = this.packTmpWorkLine(containerGroupLine, false, currentContainerTable, false);
                    if (curTmpWorkLine.ContainerId)
                    {
                        break;
                    }
                }

                this.clearOldValues();
                if (containerizationTable.AllowSplitPicks)
                {
                    // Loop over all containers to see if we can fit a split qty in it.
                    while select currentContainerTable
                        where currentContainerTable.ContainerGroupId  == containerGroupLine.ContainerGroupId  &&
                              currentContainerTable.ContainerTypeCode == containerGroupLine.ContainerTypeCode &&
                              currentContainerTable.ContainerBuildId  == containerBuildId                     &&
                              currentContainerTable.ShipmentId        == curTmpWorkLine.ShipmentId
                    {
                        curTmpWorkLine = this.packTmpWorkLine(containerGroupLine, containerizationTable.AllowSplitPicks, currentContainerTable, false);
                        if (curTmpWorkLine.ContainerId)
                        {
                            break;
                        }
                    }
                }

                // If it can't fit in any existing contaners try an empty container.
                if (!curTmpWorkLine.ContainerId)
                {
                    curTmpWorkLine = this.packTmpWorkLine(containerGroupLine, containerizationTable.AllowSplitPicks);
                }

                currentContainerTable = WHSContainerTable::find(curTmpWorkLine.ShipmentId, curTmpWorkLine.ContainerId);
            }
        }

        _containerTable.data(currentContainerTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContainerLineForTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create or updates a container line based on the tmpWorkLine passed in.
    /// </summary>
    /// <param name="_tmpWorkLine">
    /// The tmpWorkLine the containerLine will be initialized form.
    /// </param>
    protected void createContainerLineForTmpWorkLine(WHSTmpWorkLine _tmpWorkLine)
    {
        WHSContainerLine    containerLine;

        containerLine.initFromTmpWorkLine(_tmpWorkLine);
        if (WHSContainerLine::exist(containerLine.ShipmentId, containerLine.ContainerId, containerLine.InventDimId, containerLine.LoadLine, containerLine.UnitId))
        {
            containerLine = WHSContainerLine::find(containerLine.ShipmentId, containerLine.ContainerId, containerLine.InventDimId, containerLine.LoadLine, containerLine.UnitId, true);
            containerLine.Qty += _tmpWorkLine.DirectiveQty;
        }
        containerLine.write();

        //we need to clear the volume cache since we added line
        this.clearContainersVolumeFromCache(containerLine.ContainerId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new container.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment Id of the new container.
    /// </param>
    /// <param name="_containerGroupLine">
    /// The container Group Line the container will be based on.
    /// </param>
    /// <returns>
    /// A new <c>WHSContainerTable</c> record.
    /// </returns>
    protected WHSContainerTable initializeContainer(
        WHSShipmentId           _shipmentId,
        WHSContainerGroupLine   _containerGroupLine)
    {
        WHSContainerTable containerTable;

        containerTable.ContainerId = WHSContainerTable::generateContainerId();

        containerTable.ShipmentId = _shipmentId;
        containerTable.ContainerTypeCode = _containerGroupLine.ContainerTypeCode;
        containerTable.ContainerGroupId = _containerGroupLine.ContainerGroupId;
        containerTable.ContainerBuildId = containerBuildId;
        containerTable.WaveExecutionID = waveExecutionId;
        containerTable.WeightUOM = weightUOM;
        containerTable.ContainerizationTable = containerizationTable.RecId;
        containerTable.setContainerTableNum();

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new container.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment Id of the new container.
    /// </param>
    /// <param name="_containerGroupLine">
    /// The container Group Line the container will be based on.
    /// </param>
    /// <returns>
    /// A new <c>WHSContainerTable</c> record.
    /// </returns>
    private WHSContainerTable createNewContainer(
        WHSShipmentId           _shipmentId,
        WHSContainerGroupLine   _containerGroupLine)
    {
        WHSContainerTable containerTable = this.initializeContainer(_shipmentId, _containerGroupLine);
        containerTable.insert();

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>downsizeContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Downsizes containers to next container type in the sequence defined in container groups.
    /// </summary>
    void downsizeContainers()
    {
        WHSContainerTable       containerTable;
        WHSContainerGroupLine   containerGroupLine;
        WHSContainerGroupLine   curContainerGroupLine;
        WHSContainerType        containerType;
        WHSContainerTypeCode    downSizeType;
        WHSLength               maxLength;
        WHSWidth                maxWidth;
        WHSHeight               maxHeight;
        Volume                  totalVolume;
        Weight                  totalWeight;

        while select forupdate containerTable
            where containerTable.ContainerBuildId == containerBuildId
        {
            downSizeType = '';

            // Select current container group line of the container.
            curContainerGroupLine = WHSContainerGroupLine::find(containerTable.ContainerGroupId, containerTable.ContainerTypeCode);
            // Get max phys dims from items in the container
            [maxLength, maxWidth, maxHeight] = this.getMaxDims(containerTable);
            totalVolume = containerTable.calculateVolume(); //don't use caching since the change of ContainerTypeCode can impact the volume
            totalWeight = containerTable.Weight - (WHSContainerType::exist(containerTable.ContainerTypeCode) ? WHSContainerType::find(containerTable.ContainerTypeCode).TareWeight : 0);

            while select containerGroupLine
                join Length, Width, Height, MaxVolume, MaxWeight, ContainerTypeCode from containerType
                order by containerGroupLine.SeqNum asc
                where containerType.ContainerTypeCode        == containerGroupLine.ContainerTypeCode      &&
                      containerGroupLine.ContainerGroupId    == curContainerGroupLine.ContainerGroupId    &&
                      containerGroupLine.SeqNum              >  curContainerGroupLine.SeqNum
            {
                if (WHSContainerization::checkPhysDims(maxLength, maxWidth, maxHeight, containerType.Length, containerType.Width, containerType.Height, true) 
                    && (containerType.MaxVolume * containerGroupLine.FillPercentage / 100) >= totalVolume    
                    && (containerType.MaxWeight * containerGroupLine.FillPercentage / 100) >= totalWeight      
                    && this.canDownSizeContainerTableBasedOnGroupLine(containerTable, containerGroupLine, containerType))
                {
                    downSizeType = containerType.ContainerTypeCode;
                }
                else
                {
                    break;
                }
            }
            if (downSizeType)
            {
                containerTable.ContainerTypeCode = downSizeType;
                containerTable.update();
                // LOG: Container downsized.
                WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                          containerTable.ContainerId,
                                                                          waveExecutionId,
                                                                          strFmt("@WAX3767", containerTable.ContainerId, containerTable.ContainerTypeCode),
                                                                          false,
                                                                          null,
                                                                          containerTable,
                                                                          parmWaveId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDownSizeContainerTableBasedOnGroupLine</Name>
				<Source><![CDATA[
    protected boolean canDownSizeContainerTableBasedOnGroupLine(
        WHSContainerTable       _containerTable, 
        WHSContainerGroupLine   _containerGroupLine, 
        WHSContainerType        _containerType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxDims</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get max physical dimensions from items in the container
    /// </summary>
    /// <param name="_containerTable">
    /// The container to evaluate
    /// </param>
    /// <returns>
    /// Returns a container with max length, max width, max height.
    /// </returns>
    container getMaxDims(WHSContainerTable _containerTable)
    {
        WHSContainerLine        containerLine;
        WHSLength               maxLength;
        WHSWidth                maxWidth;
        WHSHeight               maxHeight;
        WHSPhysDimUOM           physDim;

        while select ItemId, UnitId from containerLine
            where containerLine.ContainerId == _containerTable.ContainerId
        {
            physDim = WHSPhysDimUOM::getPhysDimUOMByItem(containerLine.ItemId, containerLine.UnitId);
            maxLength = physDim.Depth    > maxLength ? physDim.Depth  : maxLength;
            maxWidth = physDim.Width     > maxWidth  ? physDim.Width  : maxWidth;
            maxHeight = physDim.Height   > maxHeight ? physDim.Height : maxHeight;
        }

        return [maxLength, maxWidth, maxHeight];
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        UnitOfMeasureSystemUnit sysUOM;
        UnitOfMeasure           uom;

        select firstonly Symbol from uom
            join UnitOfMeasure, UnitOfMeasureClass from sysUOM
            where uom.RecId                 == sysUOM.UnitOfMeasure &&
                  sysUOM.UnitOfMeasureClass == UnitOfMeasureClass::Mass;

        containerBuildId = NumberSeq::newGetNum(WHSParameters::numRefWHSContainerBuildId()).num();
        weightUOM = uom.Symbol;

        createWaveProgressLog = WHSParameters::find().WaveProgressLog;

        this.initContainerVolumeCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initContainerVolumeCache</Name>
				<Source><![CDATA[
    private void initContainerVolumeCache()
    {
        containerVolumeCache = new Map(Types::String, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packByUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs containers based on UOM
    /// </summary>
    public void packByUOM()
    {
        WHSTmpWorkLine          tmpTmpWorkLine;
        Qty                     runningQty;
        WHSContainerTypeCode    containerType;

        WHSContainerizationHistory::createContainerizationHistory(containerBuildId, '', waveExecutionId, strFmt("@WAX3777", curTmpWorkLine.DirectiveUOM), false, curTmpWorkLine);

        for (runningQty = curTmpWorkLine.DirectiveQty; runningQty >= 1; runningQty--)
        {
            // Sets curTmpWorkLine to the new split tmpWorkLine
            if (tmpTmpWorkLine)
            {
                curTmpWorkLine = tmpTmpWorkLine;
            }

            containerType = this.findContainerTypeCode(curTmpWorkLine);
                           

            // Create container
            WHSContainerTable containerTable = this.initializePackContainerTable(
                    curTmpWorkLine,
                    containerType);
            containerTable.setContainerTableNum();
            containerTable.insert();

            // Split tmpWorkLine
            tmpTmpWorkLine = this.splitTmpWorkLine(curTmpWorkLine, 1, curTmpWorkLine.DirectiveQty - 1, curTmpWorkLine.LineNum + #splitTmpWorkLine);

            //Reselect tmpWorkLine so buffer is current and assign containerId
            curTmpWorkLine = WHSTmpWorkLine::findByRecId(curTmpWorkLine.RecId, true);
            curTmpWorkLine.ContainerId = containerTable.ContainerId;
            curTmpWorkLine.HighestContainerId = containerTable.ContainerId;
            curTmpWorkLine.update();

            WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                        containerTable.ContainerId,
                                                                        waveExecutionId,
                                                                        strFmt("@WAX3761",
                                                                                curTmpWorkLine.ItemId,
                                                                                curTmpWorkLine.DirectiveQty,
                                                                                curTmpWorkLine.DirectiveUOM,
                                                                                containerTable.ContainerId,
                                                                                containerTable.ContainerTypeCode),
                                                                        false,
                                                                        curTmpWorkLine);
            // Create/Update containerLine
            this.createContainerLineForTmpWorkLine(curTmpWorkLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findContainerTypeCode</Name>
				<Source><![CDATA[
    private WHSContainerTypeCode findContainerTypeCode(WHSTmpWorkLine _curTmpWorkLine)
    {
        WHSUOMSeqGroupLine      uomLine;
        WHSInventTable          whsInventTable;

        select firstonly DefaultContainerTypeCode from uomLine
            where uomLine.UnitId                ==  _curTmpWorkLine.DirectiveUOM
        exists join whsInventTable
            where whsInventTable.UOMSeqGroupId  ==  uomLine.UOMSeqGroupId
               && whsInventTable.ItemId         ==  _curTmpWorkLine.ItemId;

        return uomLine.DefaultContainerTypeCode ? uomLine.DefaultContainerTypeCode : _curTmpWorkLine.DirectiveUOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePackContainerTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes container for packing.
    /// </summary>
    /// <param name = "_tmpWorkLine">The temporary work transaction record.</param>
    /// <param name = "_containerTypeCode">The container type.</param>
    /// <returns>A new initialized contaniner record.</returns>
    protected WHSContainerTable initializePackContainerTable(
        WHSTmpWorkLine          _tmpWorkLine,
        WHSContainerTypeCode    _containerTypeCode)
    {
        WHSContainerTable containerTable;
        containerTable.ContainerId = WHSContainerTable::generateContainerId();
        containerTable.ShipmentId = _tmpWorkLine.ShipmentId;
        containerTable.ContainerTypeCode = _containerTypeCode;
        containerTable.ContainerBuildId = containerBuildId;
        containerTable.WaveExecutionID = waveExecutionId;
        containerTable.WeightUOM = weightUOM;

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packContainer</Name>
				<Source><![CDATA[
    protected WHSContainerTable packContainer(WHSContainerTable     _containerTable,
                                            WHSContainerGroupLine _containerGroupLine,
                                            WHSContainerTable     _parentContainerTable = null,
                                            boolean               _allowCreateNew = true)
    {
        WHSContainerTable   curContainerTable = _containerTable;
        WHSContainerTable   parentContainerTable = _parentContainerTable;
        WHSTmpWorkLine      tmpWorkLine;
        boolean             volumeFit;
        boolean             weightFit;
        boolean             physDimFit;
        boolean             skipConEval;
        boolean             noPack;
        Volume              curVolume;

        ttsbegin;

        curContainerTable.selectForUpdate(true);

        // While the container hasn't been nested and we haven't exhausted all possibilities with current containerGroupLine, keep looping.
        while (!curContainerTable.ParentContainerId && !noPack)
        {
            if (parentContainerTable.ContainerTypeCode     == _containerGroupLine.ContainerTypeCode &&
                parentContainerTable.ContainerGroupId      == _containerGroupLine.ContainerGroupId  &&
                parentContainerTable.ShipmentId            == curContainerTable.ShipmentId          &&
                !skipConEval                                                                              &&
                this.checkAllowMixContainerQuery(parentContainerTable, curContainerTable))
            {
                // Check if we can pack in the current container.
                [physDimFit, volumeFit, weightFit] = this.checkContainerVolumetrics(_containerGroupLine,
                                                                                    curContainerTable,
                                                                                    parentContainerTable.Weight,
                                                                                    this.containerVolume(parentContainerTable));

                // If container Fits
                if (physDimFit)
                {
                    if (volumeFit && weightFit)
                    {
                        this.addContainerToParentUpdateTmpWorkLine(curContainerTable, parentContainerTable, _containerGroupLine);
                    }
                    else
                    {
                        // LOG: Volume or weight failed
                        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                  parentContainerTable.ContainerId,
                                                                                  waveExecutionId,
                                                                                  strFmt("@WAX3787",
                                                                                         curContainerTable.ContainerId,
                                                                                         parentContainerTable.ContainerId,
                                                                                         _containerGroupLine.ContainerTypeCode,
                                                                                         !volumeFit ? "@TRX377" : "@TRX374"),
                                                                                  true,
                                                                                  null,
                                                                                  curContainerTable,
                                                                                  parmWaveId);

                        skipConEval = true; // We don't want to evaluate this container because we know we can't fit this line in it.
                        this.clearOldValues();
                    }
                }
                else
                {
                    WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                              parentContainerTable.ContainerId,
                                                                              waveExecutionId,
                                                                              strFmt("@WAX3785",
                                                                                     curContainerTable.ContainerId,
                                                                                     _containerGroupLine.ContainerTypeCode),
                                                                              true,
                                                                              null,
                                                                              curContainerTable,
                                                                              parmWaveId);

                    // Physical dimension don't fit
                    noPack = true;
                    this.clearOldValues();
                }
            }
            else if (_allowCreateNew)
            {
                // Reset variable so new container volumetrics can be evaluated.
                skipConEval = false;

                // Check if we can pack in a fresh container.
                [physDimFit, volumeFit, weightFit] = this.checkContainerVolumetrics(_containerGroupLine, curContainerTable, 0, 0);

                // If container Fits
                if (physDimFit)
                {
                    if (volumeFit && weightFit)
                    {
                        // Create container
                        parentContainerTable = this.createNewContainer(curContainerTable.ShipmentId, _containerGroupLine);

                        this.addContainerToParentUpdateTmpWorkLine(curContainerTable, parentContainerTable, _containerGroupLine);
                    }
                    else
                    {
                        // LOG: Volume or weight failed
                        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                  parentContainerTable.ContainerId,
                                                                                  waveExecutionId,
                                                                                  strFmt("@WAX3787",
                                                                                         curContainerTable.ContainerId,
                                                                                         parentContainerTable.ContainerId,
                                                                                         _containerGroupLine.ContainerTypeCode,
                                                                                         !volumeFit ? "@TRX377" : "@TRX374"),
                                                                                  true,
                                                                                  null,
                                                                                  curContainerTable,
                                                                                  parmWaveId);
                        // Volume or weight exceed the limit
                        noPack = true;
                        this.clearOldValues();
                    }
                }
                else
                {
                    // LOG: Phys Dims didn't fit
                    WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                              parentContainerTable.ContainerId,
                                                                              waveExecutionId,
                                                                              strFmt("@WAX3785",
                                                                                     curContainerTable.ContainerId,
                                                                                     _containerGroupLine.ContainerTypeCode),
                                                                              true,
                                                                              null,
                                                                              curContainerTable,
                                                                              parmWaveId);

                    // Physical dimension don't fit
                    noPack = true;
                    this.clearOldValues();
                }
            }
            else
            {
                // Not allow to creat new container
                noPack = true;
                this.clearOldValues();
            }
        }

        ttscommit;

        return curContainerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packErrorContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a container with errors for inventory that failed containerizations.
    /// </summary>
    /// <param name="_containerGroupId">
    /// The container Group Id of the containerization template that failed to pack the tmpWorkLine.
    /// </param>
    protected void packErrorContainer(WHSContainerGroupId _containerGroupId)
    {
        WHSContainerTable       containerTable;
        WHSTmpWorkLine          tmpWorkLine;
        WHSContainerTypeCode    containerTypeCode;
        WHSContainerGroupLine   containerGroupLine;

        ttsbegin;

        // Select first
        select firstonly ContainerTypeCode from containerGroupLine
            order by SeqNum
            where containerGroupLine.ContainerGroupId == _containerGroupId;

        containerTypeCode = containerGroupLine.ContainerTypeCode;

        select firstonly containerTable
            where containerTable.ShipmentId         == curTmpWorkLine.ShipmentId
            &&    containerTable.ContainerTypeCode  == containerTypeCode
            &&    containerTable.ErrorContainer     == NoYes::Yes;

        if (!containerTable.RecId)
        {
            // Create error container
            containerTable = this.initializePackContainerTable(
                curTmpWorkLine,
                containerTypeCode);
            containerTable.ErrorContainer = NoYes::Yes;
            containerTable.insert();
        }

        tmpWorkLine = WHSTmpWorkLine::findByRecId(curTmpWorkLine.RecId, true);
        tmpWorkLine.ContainerId = containerTable.ContainerId;
        tmpWorkLine.update();

        // Create/Update containerLine
        this.createContainerLineForTmpWorkLine(tmpWorkLine);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSplitTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits and packs tmpWorkLines into a container.
    /// </summary>
    /// <param name="_containerGroupLine">
    /// The container group line being processed.
    /// </param>
    /// <param name="_curContainerTable">
    /// The current container being packed into; optional
    /// </param>
    /// <returns>
    /// The tmpWorkLine that was packed if any.
    /// </returns>
    protected WHSTmpWorkLine packSplitTmpWorkLine(
        WHSContainerGroupLine   _containerGroupLine,
        WHSContainerTable       _curContainerTable = null)
    {
        WHSContainerTable       containerTable = _curContainerTable;
        WHSTmpWorkLine          tmpTmpWorkLine;
        WHSTmpWorkLine          packedTmpWorkLine;
        Qty                     splitQty;
        boolean                 physDimFit;
        boolean                 volumeFit;
        boolean                 weightFit;

        ttsbegin;

        for (splitQty = curTmpWorkLine.DirectiveQty - 1; splitQty >=1; splitQty--)
        {
            [physDimFit, volumeFit, weightFit] = this.validateVolumetricsAddingToContainer(
                                                                           containerTable,
                                                                           _containerGroupLine,
                                                                           curTmpWorkLine.itemKey(),
                                                                           splitQty,
                                                                           curTmpWorkLine.DirectiveUOM,
                                                                           false);

            if (volumeFit && weightFit)
            {
                // LOG: Line split
                WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                          containerTable.ContainerId,
                                                                          waveExecutionId,
                                                                          strFmt("@WAX3763", curTmpWorkLine.ItemId),
                                                                          false,
                                                                          curTmpWorkLine);

                // Split tmpWorkLine
                tmpTmpWorkLine = this.splitTmpWorkLine(curTmpWorkLine, splitQty, curTmpWorkLine.DirectiveQty - splitQty, curTmpWorkLine.LineNum + #splitTmpWorkLine);

                // Create continer if we aren't packing into an existing one
                if (containerTable.RecId == 0)
                {
                    containerTable = this.createNewContainer(curTmpWorkLine.ShipmentId, _containerGroupLine);
                }

                // Reselect tmpWorkLine so buffer is current after splitting.
                curTmpWorkLine = WHSTmpWorkLine::findByRecId(curTmpWorkLine.RecId, true);
                this.setTmpWorkLineContainerId(containerTable.ContainerId);
                packedTmpWorkLine = WHSTmpWorkLine::findByRecId(curTmpWorkLine.RecId);

                WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                    containerTable.ContainerId,
                                                                    waveExecutionId,
                                                                    strFmt("@WAX3761",
                                                                    curTmpWorkLine.ItemId,
                                                                    curTmpWorkLine.DirectiveQty,
                                                                    curTmpWorkLine.DirectiveUOM,
                                                                    containerTable.ContainerId,
                                                                    _containerGroupLine.ContainerTypeCode),
                                                                    false,
                                                                    curTmpWorkLine);

                // Create/Update containerLine
                this.createContainerLineForTmpWorkLine(curTmpWorkLine);

                // Assign new tmpWorkLine to curTmpWorkLine being processed.
                curTmpWorkLine = tmpTmpWorkLine;
                break;
            }
        }

        ttscommit;

        return packedTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs current temp work line into current container.
    /// </summary>
    /// <param name="_containerGroupLine">
    /// The container group line that container belongs to.
    /// </param>
    /// <param name="_allowSplit">
    /// Determines whether the work can be split when it doesn't fit to current container.
    /// </param>
    /// <param name="_containerTable">
    /// The current container.
    /// </param>
    /// <param name="_allowCreateNew">
    /// Determines whether it is allowed to create new container or not.
    /// </param>
    /// <returns>
    /// The current temp work line with a container assigned.
    /// </returns>
    protected WHSTmpWorkLine packTmpWorkLine(
        WHSContainerGroupLine _containerGroupLine,
        WHSAllowSplit         _allowSplit,
        WHSContainerTable     _containerTable = null,
        boolean               _allowCreateNew = true)
    {
        WHSContainerTable   containerTable = _containerTable;
        boolean             noPack;
        boolean             skipConEval;
        boolean             physDimFit;
        boolean             volumeFit;
        boolean             weightFit;
        WHSTmpWorkLine      packedSplitTmpWorkLine;

        ttsbegin;

        curTmpWorkLine = WHSTmpWorkLine::findByRecId(curTmpWorkLine.RecId, true);

        // While there is still qty to be packed and we haven't exhausted all possibilities with current containerGroupLine, keep looping.
        while (!curTmpWorkLine.ContainerId && !noPack)
        {
            if (!skipConEval && this.validateTmpWorkLineContainer(containerTable, _containerGroupLine))
            {
                // Check if we can pack in the current container.
                [physDimFit, volumeFit, weightFit] = this.validateVolumetricsAddingToContainer(
                                                                                containerTable,
                                                                                _containerGroupLine,
                                                                                curTmpWorkLine.itemKey(),
                                                                                curTmpWorkLine.DirectiveQty,
                                                                                curTmpWorkLine.DirectiveUOM,
                                                                                true);

                if (physDimFit)
                {
                    if (volumeFit && weightFit)
                    {
                        if (this.checkAllowMixTmpWorkQuery(containerTable, curTmpWorkLine))
                        {
                            this.setTmpWorkLineContainerId(containerTable.ContainerId);

                            WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                      containerTable.ContainerId,
                                                                                      waveExecutionId,
                                                                                      strFmt("@WAX3761",
                                                                                             curTmpWorkLine.ItemId,
                                                                                             curTmpWorkLine.DirectiveQty,
                                                                                             curTmpWorkLine.DirectiveUOM,
                                                                                             containerTable.ContainerId,
                                                                                             _containerGroupLine.ContainerTypeCode),
                                                                                      false,
                                                                                      curTmpWorkLine);

                            this.createContainerLineForTmpWorkLine(curTmpWorkLine);
                        }
                        else
                        {
                            skipConEval = true; // We don't want to evaluate this container because we know we can't fit this line in it due to mix check.
                        }
                    }
                    else if (_allowSplit)
                    {
                        if (this.checkAllowMixTmpWorkQuery(containerTable, curTmpWorkLine))
                        {
                            // LOG: Volume or weight failed
                            WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                      containerTable.ContainerId,
                                                                                      waveExecutionId,
                                                                                      strFmt("@WAX3762",
                                                                                             curTmpWorkLine.ItemId,
                                                                                             containerTable.ContainerId,
                                                                                             _containerGroupLine.ContainerTypeCode,
                                                                                             !volumeFit ? "@TRX377" : "@TRX374"),
                                                                                      true,
                                                                                      curTmpWorkLine);
                            packedSplitTmpWorkLine = this.packSplitTmpWorkLine(_containerGroupLine, containerTable);
                            containerTable = WHSContainerTable::findByRecId(containerTable.RecId);
                        }
                        //weight and volume failed so we should not validate this again
                        skipConEval = true;
                    }
                    else // Don't allow split pick
                    {
                        // LOG: Volome or weight failed
                        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                  containerTable.ContainerId,
                                                                                  waveExecutionId,
                                                                                  strFmt("@WAX3762",
                                                                                         curTmpWorkLine.ItemId,
                                                                                         containerTable.ContainerId,
                                                                                         _containerGroupLine.ContainerTypeCode,
                                                                                         !volumeFit ? "@TRX377" : "@TRX374"),
                                                                                  true,
                                                                                  curTmpWorkLine);

                        skipConEval = true; // We don't want to evaluate this container because we know we can't fit this line in it.
                        this.clearOldValues();
                    }
                }
                else
                {
                    // Physical dimension don't fit
                    noPack = true;
                    this.clearOldValues();
                }
            }
            else if (_allowCreateNew)
            {
                // Reset variable so new container volumetrics can be evaluated.
                skipConEval = false;

                // Check if we can pack in a fresh container.
                [physDimFit, volumeFit, weightFit] = this.validateEmptyContainerVolumetrics(_containerGroupLine,
                                                                                            curTmpWorkLine.itemKey(),
                                                                                            curTmpWorkLine.DirectiveQty,
                                                                                            curTmpWorkLine.DirectiveUOM);
                // Item fits in container.
                if (physDimFit)
                {
                    if (volumeFit && weightFit)
                    {
                        if (containerizationTable.ContainerPackingStrategy == WHSContainerPackingStrategy::CurrentContainer)
                        {
                            this.clearOldValues();
                        }

                        // Create container
                        containerTable = this.createNewContainer(curTmpWorkLine.ShipmentId, _containerGroupLine);

                        this.setTmpWorkLineContainerId(containerTable.ContainerId);

                        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                  containerTable.ContainerId,
                                                                                  waveExecutionId,
                                                                                  strFmt("@WAX3761",
                                                                                         curTmpWorkLine.ItemId,
                                                                                         curTmpWorkLine.DirectiveQty,
                                                                                         curTmpWorkLine.DirectiveUOM,
                                                                                         containerTable.ContainerId,
                                                                                         _containerGroupLine.ContainerTypeCode),
                                                                                  false,
                                                                                  curTmpWorkLine);

                        // Create/Update containerLine
                        this.createContainerLineForTmpWorkLine(curTmpWorkLine);
                    }
                    else if (_allowSplit)
                    {
                        // LOG: Could not fit because of volume or weight
                        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                  containerTable.ContainerId,
                                                                                  waveExecutionId,
                                                                                  strFmt("@WAX3766",
                                                                                         curTmpWorkLine.ItemId,
                                                                                         _containerGroupLine.ContainerTypeCode,
                                                                                         !volumeFit ? "@TRX377" : "@TRX374"),
                                                                                  true,
                                                                                  curTmpWorkLine);

                        packedSplitTmpWorkLine = this.packSplitTmpWorkLine(_containerGroupLine);
                        // If we were unable to split the tmpWorkLine and pack it log error.
                        if (packedSplitTmpWorkLine.RecId == 0)
                        {
                            WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                        containerTable.ContainerId,
                                                                                        waveExecutionId,
                                                                                        strFmt("@WAX3764", _containerGroupLine.ContainerTypeCode),
                                                                                        true,
                                                                                        curTmpWorkLine);

                            noPack = true;
                        }
                        else // Was able to pack a split tmpWorkline
                        {
                            containerTable = WHSContainerTable::findByContainerId(packedSplitTmpWorkLine.ContainerId);
                            skipConEval = true; // We don't want to evaluate this container because we know it is full for this tmpWorkLine.
                        }
                    }
                    else
                    {
                        // LOG: Volume or weight failed
                        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                                  containerTable.ContainerId,
                                                                                  waveExecutionId,
                                                                                  strFmt("@WAX3766",
                                                                                         curTmpWorkLine.ItemId,
                                                                                         _containerGroupLine.ContainerTypeCode,
                                                                                         !volumeFit ? "@TRX377" : "@TRX374"),
                                                                                  true,
                                                                                  curTmpWorkLine);

                        // It can't fit because of volume weight, and we aren't allowed.
                        noPack = true;
                    }
                }
                else
                {
                    WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                              containerTable.ContainerId,
                                                                              waveExecutionId,
                                                                              strFmt("@WAX3765",
                                                                                     curTmpWorkLine.ItemId,
                                                                                     _containerGroupLine.ContainerTypeCode),
                                                                              true,
                                                                              curTmpWorkLine);

                    // Physical dimension don't fit
                    noPack = true;
                }
            }
            else
            {
                // Not allow to create new container
                noPack = true;
                this.clearOldValues();
            }
        }

        ttscommit;

        return curTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTmpWorkLineContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the container settings.
    /// </summary>
    /// <param name = "_containerTable">The containers record.</param>
    /// <param name = "_containerGroupLine">The container group detail record.</param>
    /// <returns>true if the validation succeeds; otherwise, false.</returns>
    [Replaceable]
    protected boolean validateTmpWorkLineContainer(
        WHSContainerTable       _containerTable,
        WHSContainerGroupLine   _containerGroupLine)
    {
        return _containerTable.ContainerTypeCode == _containerGroupLine.ContainerTypeCode
            && _containerTable.ContainerGroupId  == _containerGroupLine.ContainerGroupId
            && _containerTable.ShipmentId        == curTmpWorkLine.ShipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContainerBuildId</Name>
				<Source><![CDATA[
    public WHSContainerBuildId parmContainerBuildId(WHSContainerBuildId _containerBuildId = containerBuildId)
    {
        containerBuildId = _containerBuildId;

        return containerBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmWaveId</Name>
				<Source><![CDATA[
    public WHSWaveId parmParmWaveId(WHSWaveId _waveId = parmWaveId)
    {
        parmWaveId = _waveId;

        return parmWaveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWaveExecutionId</Name>
				<Source><![CDATA[
    public WHSWaveExecutionID parmWaveExecutionId(WHSWaveExecutionID _waveExecutionId = waveExecutionId)
    {
        waveExecutionId = _waveExecutionId;

        return waveExecutionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWaveTemplateLine</Name>
				<Source><![CDATA[
    public WHSWaveTemplateLine parmWaveTemplateLine(WHSWaveTemplateLine _waveTemplateLine = waveTemplateLine)
    {
        waveTemplateLine = _waveTemplateLine;

        return waveTemplateLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkCreateId</Name>
				<Source><![CDATA[
    public WHSWorkCreateId parmWorkCreateId(WHSWorkCreateId _workCreateId = workCreateId)
    {
        workCreateId = _workCreateId;

        return workCreateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateOldValues</Name>
				<Source><![CDATA[
    private void populateOldValues(Query q)
    {
        WHSContainerizationBreak    conBreak;
        QueryRun                    qr;
        Common                      table;
        anytype                     field;
        int                         i = 1;
        str                         name;

        qr = new QueryRun(q);

        // Populate values for all fields we are breaking on.
        if (qr.next())
        {
            while select GroupTableId, GroupFieldId from conBreak
                where conBreak.RefRecId == containerizationTable.RecId
            {
                if (qr.query().dataSourceTable(conBreak.GroupTableId))
                {
                    name = qr.query().name();
                    table = qr.get(conBreak.GroupTableId);
                    field = table.(conBreak.GroupFieldId);

                    if (name == queryStr(WHSMixingLogicSOQuery) ||
                        name == queryStr(WHSMixingLogicTOQuery))
                    {
                        orderValues = conPoke(orderValues, i, field);
                    }
                    else if (name == queryStr(WHSMixingLogicItemQuery))
                    {
                        itemValues = conPoke(itemValues, i, field);
                    }
                    else if (name == queryStr(WHSContainerizationContainer))
                    {
                        conValues = conPoke(conValues, i, field);
                    }

                    ++i;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpWorkLineContainerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the container Id on the current tmpWorkLine.
    /// </summary>
    /// <param name="_containerId">
    /// The container Id to be set on the tmpWorkLine.
    /// </param>
    private void setTmpWorkLineContainerId(WHSContainerId   _containerId)
    {
        ttsbegin;

        if (curTmpWorkLine)
        {
            curTmpWorkLine.ContainerId = _containerId;
            curTmpWorkLine.HighestContainerId = _containerId;
            curTmpWorkLine.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits a <c>WHSTmpWorkLine</c> record by the quantity specified.
    /// </summary>
    /// <param name="_tmpWorkLine">
    /// The <c>WHSTmpWorkLine</c> record to split.
    /// </param>
    /// <param name="_maxQty">
    /// The quantity that will remain on the existing tmpWorkLine.
    /// </param>
    /// <param name="_remainingQty">
    /// The quantity that will be split off to a new tmpWorkLine.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the new split off tmpWorkLine.
    /// </param>
    /// <returns>
    /// The split off tmpWorkLine.
    /// </returns>
    /// <remarks>
    /// Both quantities passed in should be in the directive UOM.
    /// </remarks>
    protected WHSTmpWorkLine splitTmpWorkLine(
        WHSTmpWorkLine  _tmpWorkLine,
        WHSDirectiveQty _maxQty,
        WHSDirectiveQty _remainingQty,
        LineNum         _lineNum)
    {
        ttsbegin;
        
        WHSTmpWorkLine locTmpWorkLine = WHSTmpWorkLine::findByRecId(_tmpWorkLine.RecId, true);

        locTmpWorkLine.InventQty = WHSCatchWeightHelper::convertInventQuantity(_tmpWorkLine.ItemId,
                                                                          locTmpWorkLine.DirectiveUOM,
                                                                          _maxQty,
                                                                          _tmpWorkLine.InventDimId);
        
        UnitOfMeasureSymbol inventUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_tmpWorkLine.ItemId);

        if (locTmpWorkLine.DirectiveUOM == locTmpWorkLine.HighestUnitId)
        {
            locTmpWorkLine.HighestQty = _maxQty;
        }
        else
        {
            [locTmpWorkLine.HighestQty,
                locTmpWorkLine.HighestUnitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(locTmpWorkLine.ItemId, locTmpWorkLine.InventQty, inventUnitId, locTmpWorkLine.InventDimId);
        }

        locTmpWorkLine.setPackQtyCompare();
        locTmpWorkLine.DirectiveQty = _maxQty;

        locTmpWorkLine.write();
        
        WHSTmpWorkLine newTmpWorkLine;

        if (_remainingQty)
        {
            buf2Buf(locTmpWorkLine, newTmpWorkLine);

            newTmpWorkLine.LineNum          = _lineNum;
            newTmpWorkLine.InventQty        = WHSCatchWeightHelper::convertInventQuantity(_tmpWorkLine.ItemId,
                                                                                     locTmpWorkLine.DirectiveUOM,
                                                                                     _remainingQty,
                                                                                     _tmpWorkLine.InventDimId);

            newTmpWorkLine.DirectiveQty     = _remainingQty;

            newTmpWorkLine.setPackQtyCompare();

            if (newTmpWorkLine.DirectiveUOM == newTmpWorkLine.HighestUnitId)
            {
                newTmpWorkLine.HighestQty = _remainingQty;
            }
            else
            {
                [newTmpWorkLine.HighestQty,
                    newTmpWorkLine.HighestUnitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(newTmpWorkLine.ItemId, newTmpWorkLine.InventQty, inventUnitId, newTmpWorkLine.InventDimId);
            }

            newTmpWorkLine.insert();
        }

        ttscommit;

        return newTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addContainerToParentUpdateTmpWorkLine</Name>
				<Source><![CDATA[
    private void addContainerToParentUpdateTmpWorkLine(WHSContainerTable _container, WHSContainerTable _parentContainer, WHSContainerGroupLine _containerGroupLine)
    {
        this.addContainerToParentContainer(_container, _parentContainer);

        // Update container level and parent container ID for TmpWorkLine
        this.updateTmpWorkLineContainerLevelParentContainerId(_container);

        // Update the Highest Container Id field on all tmpWorkLines that are the child of the current container
        this.updateTmpWorkLineHighestContainer(_container.ContainerId, _container.ParentContainerId);

        WHSContainerizationHistory::createContainerizationHistory(containerBuildId,
                                                                  _parentContainer.ContainerId,
                                                                  waveExecutionId,
                                                                  strFmt("@WAX3786",
                                                                         _container.ContainerId,
                                                                         _parentContainer.ContainerId,
                                                                         _containerGroupLine.ContainerTypeCode),
                                                                  false,
                                                                  null,
                                                                  _container,
                                                                  parmWaveId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpWorkLineContainerLevelParentContainerId</Name>
				<Source><![CDATA[
    private void updateTmpWorkLineContainerLevelParentContainerId(WHSContainerTable _container)
    {
        WHSTmpWorkLine  tmpWorkLine;

        ttsbegin;

        select firstonly forupdate tmpWorkLine
            where tmpWorkLine.WaveId       == parmWaveId
                && tmpWorkLine.ContainerId == _container.ContainerId
                && tmpWorkLine.ShipmentId  == _container.ShipmentId;
        if (tmpWorkLine.RecId)
        {
            tmpWorkLine.ContainerLevel = _container.ContainerLevel;
            tmpWorkLine.HighestContainerId =  _container.ParentContainerId;
            tmpWorkLine.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpWorkLineHighestContainer</Name>
				<Source><![CDATA[
    private void updateTmpWorkLineHighestContainer(WHSContainerId _oldHighestContainerId, WHSHighestContainerId _highestContainerId)
    {
        WHSTmpWorkLine  tmpWorkLine;

        ttsbegin;

        while select forupdate tmpWorkLine
            where tmpWorkLine.WorkCreateId       == workCreateId &&
                  tmpWorkLine.HighestContainerId == _oldHighestContainerId
        {
            tmpWorkLine.HighestContainerId = _highestContainerId;
            tmpWorkLine.ContainerLevel++;
            tmpWorkLine.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curLicensePlatePackType</Name>
				<Source><![CDATA[
    private WHSLicensePlatePackType curLicensePlatePackType()
    {
        UnitOfMeasureSymbol unitId;
        ItemId              itemId;

        if (curTmpWorkLine)
        {
            itemId = curTmpWorkLine.ItemId;
            unitId = curTmpWorkLine.DirectiveUOM;
        }
        
        if (itemId && unitId)
        {
            WHSUOMSeqGroupId    seqGroupId;
            WHSUOMSeqGroupLine  seqGroupLine;
            WHSLicensePlateId   licensePlateId;

            seqGroupId = WHSInventTable::find(itemId).uomSeqGroupId;

            select firstonly LicensePlatePackType from seqGroupLine
                where seqGroupLine.uomSeqGroupId    == seqGroupId   &&
                      seqGroupLine.UnitId           == unitId;

            return seqGroupLine.LicensePlatePackType;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPhysDims</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks physical dimensions are within the maximum range.
    /// </summary>
    /// <param name="_itemLength">
    /// Item length.
    /// </param>
    /// <param name="_itemWidth">
    /// Item width.
    /// </param>
    /// <param name="_itemHeight">
    /// Item height.
    /// </param>
    /// <param name="_maxLength">
    /// Maximum item length.
    /// </param>
    /// <param name="_maxWidth">
    /// Maximum item width.
    /// </param>
    /// <param name="_maxHeight">
    /// Maximum item height.
    /// </param>
    /// <param name="_allowFlipLW">
    /// True if it allows to flip length and width.
    /// </param>
    /// <returns>
    /// True if the dimensions are within the range.
    /// </returns>
    public static boolean checkPhysDims(WHSLength    _itemLength,
                                        WHSWidth     _itemWidth,
                                        WHSHeight    _itemHeight,
                                        WHSLength    _maxLength,
                                        WHSWidth     _maxWidth,
                                        WHSHeight    _maxHeight,
                                        boolean      _allowFlipLW = false)
    {
        boolean ret;

        if (_maxLength  >= _itemLength  &&
            _maxWidth   >= _itemWidth   &&
            _maxHeight  >= _itemHeight)
        {
            ret = true;
        }
        else if (_allowFlipLW)
        {
            if (_maxLength  >= _itemWidth   &&
                _maxWidth   >= _itemLength  &&
                _maxHeight  >= _itemHeight)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>