<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqTransPoMarkFirm</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ReqTransPoMarkFirm extends ReqTransPoMark implements BatchRetryable
{
    #ISOCountryRegionCodes
    #define.mapKeyReqPoDeleted(1)
    #define.mapKeyReqTransDeleted(2)
    #define.mapKeyReqTransMark(3)

    ProdPurch                       prodPurch;
    Map                             mapKey2TransferId; // THIS MAP IS NOT USED ANYMORE (but kept in class declaration for backwards compatibility)
    Map                             mapKey2JournalId; // THIS MAP IS NOT USED ANYMORE (but kept in class declaration for backwards compatibility)
    Map                             mapPurchBuyerGroupId; // THIS MAP IS NOT USED ANYMORE (but kept in class declaration for backwards compatibility)

    ReqRefType                      refType;
    PurchId                         callerPurchId;

    container                       conReqTransFirm;

    private ReqPOCollectPerPlanningPriority         collectPerPlanningPriority;
    private ReqPOCollectPerPlanningPriorityTransfer collectPerPlanningPriorityTransfer;

    ReqPOCollectPerVendor                       collectPerVendor;
    ReqPOCollectPerBuyer                        collectPerBuyer;
    ReqPOCollectPerPurchAgreement               collectPerPurchAgreement;
    ReqPOSearchPurchAgreement                   searchPurchAgreement;
    ReqPoCollectPerPeriod                       collectPerPeriodPurch;

    ReqPoCollectPerPeriod                       collectPerPeriodJournal;

    NoYes                           abortIfErrors;
    private NoYes                   startMultiThreadedRun;
    private ReqProcessNumThreads    maxChildThreads;
    ReqMarkUpdate                   reqMarkUpdate;
    boolean                         isAutoFirm;
    private boolean                 bypassParallelFirmingFlag;
    private boolean                 isPurchLineRefProjSalesFlightEnabled;
    private boolean                 mustSkipTTS;
    boolean                         isSortingByLevelNeeded;
    boolean                         hasErrors;
    boolean							ignoreUnhandledUpdateConflicts;
    ReqNumOfTrans					firmedOrderCount;

    #DEFINE.CurrentVersion(17)
    #LOCALMACRO.CurrentList
        collectPerVendor,
        collectPerBuyer,
        collectPerPeriodPurch,
        collectPerPeriodJournal,
        callerPurchId,
        reqMarkUpdate,
        abortIfErrors,
        collectPerPurchAgreement,
        searchPurchAgreement,
        refType
    #ENDMACRO

    DialogField                 dialogAbortIfErrors;
    DialogField                 dialogUseMultiThread;
    DialogField                 dialogMaxChildThreads;
    DialogField                 dialogMarkUpdate;

    DialogField                 dialogCollectPerPlanningPriority;
    DialogField                 dialogCollectPerPlanningPriorityTransfer;
    DialogField                 dialogCollectPerVendor;
    DialogField                 dialogCollectPerBuyer;
    DialogField                 dialogCollectPerPeriodPurch;
    DialogField                 dialogCollectPerPeriodJournal;
    DialogField                 dialogCollectPerPurchAgreement;

    Integer                     logPoint;

    ReqTrans                    reqTransThrow;

    ReqParameters               reqParameters;

    Set                         phantomRouteExpanded;
    Map                         phantomDerivedData;

    RecordSortedList            m_oPurchToCrossDock;
    ProdId                      prodId;
    PmfConsOrdId                consOrdId;
    boolean                     pmfCoCreateDynamicPlan;
    boolean                     isKanbanRuleAutoPlanningDeferred;

    private boolean             isPartOfBiggerRun; // indicates that the run is done as a part of a bigger run
    private boolean             isStartedFromUI;
    private boolean             isPartOfMultithreadedRun;
    private boolean             mustUpdateCallerForm;

    private ReqTransPoMarkFirmProcessedOrdersData processedOrdersData;

    private ReqFirmingRunId firmingRunId; // currently firmingRunId is only set and needed when running multi-threaded
    private ProdParameters prodParameters;
    
    private boolean isTransfersGroupingEnabled;
    private boolean mustRunTransfersPostProcessing;
    private PurchInstrumentationLogger instrumentationLogger;
    private readonly boolean reqTransPoMarkFirmInventJournalTableRecordCheckFlightIsEnabled;

    boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>autoApprovePurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Auto approves all firmed purchase orders.
    /// </summary>
    [SysObsolete('Only firmed Planned purchase orders (as opposed to subcontract purchase orders) should be auto-approved. For that purpose use autoApproveFirmedPlannedPurchaseOrders() instead', false, 31\01\2016)]
    protected void autoApprovePurchTable()
    {
        PurchTable              purchTable;
        PurchId                 purchId;
        VersioningPurchaseOrder versioningPurchaseOrder;
        Map                     map;
        MapEnumerator           me;

        if (prodPurch)
        {
            map = prodPurch.mapKey2PurchId(); // prodPurch.mapKey2PurchId(); MAP IS NOT USED ANYMORE

            if (   map
                && map.elements())
            {
                ttsbegin;
                me = map.getEnumerator();
                while (me.moveNext())
                {
                    purchId = me.currentValue();
                    purchTable = PurchTable::find(purchId, true);

                    if (   purchTable
                        && purchTable.ChangeRequestRequired)
                    {
                        versioningPurchaseOrder = VersioningPurchaseOrder::newPurchaseOrder(purchTable);

                        if (versioningPurchaseOrder.getDocumentState() == VersioningDocumentState::Draft)
                        {
                            // Versioning: approve change request
                            purchTable.autoApproveChangeRequest();
                        }
                    }
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCallerForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes caller form data source, so that changes done by this class are reflected in the caller form.
    /// </summary>
    private void refreshCallerForm()
    {
        if (callerDataSourceRecord)
        {
            FormDataSource dataSource = FormDataUtil::getFormDataSource(callerDataSourceRecord);
            FormDataSource parentDataSource = formGetParentDatasource(dataSource);
            
            if (firmedOrderCount != 0)
            {
                if (parentDataSource)
                {
                    parentDataSource.research(true);
                }
                else if (dataSource)
                {
                    dataSource.research(true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoApproveFirmedPlannedPurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Auto approves firmed planned purchase orders.
    /// </summary>
    private void autoApproveFirmedPlannedPurchaseOrders()
    {
        ttsbegin;

        var purchIdsToAutoApprove = processedOrdersData.getPurchaseOrdersToAutoApprove();
        var enumerator = purchIdsToAutoApprove.getEnumerator();
        while (enumerator.moveNext())
        {
            PurchTable purchOrder = PurchTable::find(enumerator.current(), true);
            this.autoApprovePurchaseOrder(purchOrder);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoApprovePurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Auto-approves the specified purchase order.
    /// </summary>
    /// <param name = "_purchOrder">The purchase order header to auto-approve.</param>
    protected void autoApprovePurchaseOrder(PurchTable _purchOrder)
    {
        if (_purchOrder.RecId && _purchOrder.ChangeRequestRequired && _purchOrder.DocumentState == VersioningDocumentState::Draft)
        {
            // aligned with ReqTransPoMarkFirm/insertMovement
            var shouldSkipInventSumLogTTS = isAutoFirm || ReqPlanManager::allowSkipTTS();
            using (var scope = new InventSumLogTTSSkippingScope(shouldSkipInventSumLogTTS))
            {
                _purchOrder.autoApproveChangeRequest();
            }

            PurchLine purchaseLine;
            while select purchaseLine
                where purchaseLine.PurchId == _purchOrder.PurchId
            {
                var plannedOrder = ReqPO::find(ReqPlan::findReqPlanId(purchaseLine.ReqPlanIdSched).findActiveVersion().RecId,
                                                        purchaseLine.ReqPOId, true);

                if (isPurchLineRefProjSalesFlightEnabled)
                {
                    ReqTrans reqTrans = plannedOrder.reqTrans(true);
                    SalesLine salesLine = ReqTransPoMarkFirm::findSalesLineForPurchTrans(reqTrans, plannedOrder, this.reqMarkUpdate, this);

                    this.updatePurchLine(reqTrans, plannedOrder, purchaseLine, salesLine);
                }
                else
                {
                    this.updatePurchLine(plannedOrder.reqTrans(true), plannedOrder, purchaseLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeFirmed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if a planned order can be firmed.
    /// </summary>
    /// <param name="_reqTrans">
    ///    The net requirement.
    /// </param>
    /// <param name="_reqPO">
    ///    The planned order.
    /// </param>
    /// <returns>
    ///    true if the planned order can be firmed; otherwise, false.
    /// </returns>
    protected boolean canBeFirmed(
        ReqTrans _reqTrans,
        ReqPO    _reqPO)
    {
        boolean result = true;

        if (_reqPO.RecId)
        {
            if (!_reqPO.canBeFirmed())
            {
                result = checkFailed(strFmt("@SYS344610", _reqPO.RefId, fieldPName(ReqPO, IsDerivedDirectly)));
            }
        }
        else
        {
            if (!_reqTrans.canBeFirmed())
            {
                result = checkFailed(strFmt("@SYS344611", _reqTrans.RefId, fieldPName(ReqTrans, IsDerivedDirectly)));
            }
        }

        result = result && ReqRequisitionsHelper::requisitionLineStatusAllowsFirming(_reqTrans);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    protected void create(ReqTrans _reqTransMark)
    {
        using (var instrumentation = ReqInstrumentationSegmentFactory::create(ReqInstrumentationActivities::FirmingOrder, _reqTransMark.RecId))
        {
            ReqTrans reqTransFirmedOriginal = _reqTransMark.data();

            setPrefix(#prefixField(_reqTransMark,refId));
            setPrefix(#prefixField(_reqTransMark,ItemId));

            if (!phantomDerivedData.exists(_reqTransMark.RecId))
            {
                ReqTrans reqTrans;

                select firstonly forupdate reqTrans
                where reqTrans.PlanVersion  == _reqTransMark.PlanVersion &&
                      reqTrans.RefType      == _reqTransMark.RefType     &&
                      reqTrans.RefId        == _reqTransMark.RefId;

                if (!reqTrans.RecId)
                {
                    throw error(strFmt("@SYS24774", _reqTransMark.RefId));
                }

                ReqPO reqPO = reqTrans.reqPo(true);
                if (this.canBeFirmed(reqTrans, reqPO))
                {
                    if (!reqPO.RecId)
                    {
                        reqPO.insertFromReqTrans(reqTrans);
                    }

                    this.initMustSkipTTS(reqTrans);

                    switch (reqTrans.RefType)
                    {
                        case ReqRefType::ItemPlannedOrder :
                            if (this.isVendorApproved(reqTrans, reqPO))
                            {
                                this.createPurchLine(reqTrans, reqPO);
                                this.insertIntoMapsAfterFirming(reqTrans, reqPO);
                            }
                            break;

                        case ReqRefType::PmfPlannedProdBatch :
                        case ReqRefType::BOMPlannedOrder :
                            if (this.isVendorApproved(reqTrans, reqPO))
                            {
                                prodId = this.createProdTable(reqTrans, reqPO).ProdId;
                                this.insertIntoMapsAfterFirming(reqTrans, reqPO);
                            }
                            break;

                        case ReqRefType::TransferPlannedOrder :
                            this.createInventTransfer(reqTrans, reqPO);
                            break;

                        case ReqRefType::PlannedKanban:
                            this.createKanban(reqPO);
                            break;

                        default:
                            this.createDefault(reqTrans);
                    }
                }
            }

            this.created(reqTransFirmedOriginal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMustSkipTTS</Name>
				<Source><![CDATA[
    /// <summary>
    /// When automatic update of the dynamic plan from static is enabled and 
    /// the planned order has been generated by master planning (ReqTrans.ReqProcessId not empty) 
    /// then the firming logic in updateDynamicPlanData will automatically synchronize ReqTrans records
    /// for this planned order between the current plan and the dynamic plan.
    /// Hence, we must disable InventSumLogTTS. Otherwise, the firmed order will appear in ReqTrans twice. 
    /// When the planned order was created manually then InventSumLogTTS must be enabled to account for the new firmed order in the dynamic plan.
    /// </summary>
    /// <param name = "_reqTrans">The ReqTrans of the planned order.</param>
    private void initMustSkipTTS(ReqTrans _reqTrans)
    {
        boolean autoUpdateDynamicPlan = reqParameters.autoUpdateDynamicPlan(ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId);
        boolean isActivePlanVersionForDynamicPlan = _reqTrans.PlanVersion == ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;

        this.parmIsMustSkipTTS((_reqTrans.ReqProcessId && autoUpdateDynamicPlan) || isActivePlanVersionForDynamicPlan);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoMapsAfterFirming</Name>
				<Source><![CDATA[
    private void insertIntoMapsAfterFirming(ReqTrans _reqTrans, ReqPO _reqPO)
    {
        mapReqTransDeleted.insert(_reqTrans.RecId, _reqTrans);
        mapReqPoDeleted.insert(_reqPO.RecId, _reqPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorApproved</Name>
				<Source><![CDATA[
    private boolean isVendorApproved(ReqTrans _reqTrans, ReqPO _reqPO)
    {
        boolean isVendorApproved = true;

        if (this.mustCheckApprovedVendorList(_reqTrans, _reqPO))
        {
            isVendorApproved = this.pdsCheckApprovedVendorList(_reqTrans, _reqPO);
        }

        return isVendorApproved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>created</Name>
				<Source><![CDATA[
    /// <summary>
    /// This event is raised upon successful completion of the create method.
    /// </summary>
    /// <param name = "reqTransFirmedOriginal">The state of the firmed <c>ReqTrans</c> record before the firming process stated.</param>
    delegate void created(ReqTrans reqTransFirmedOriginal)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckApprovedVendorList</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the approved vendor list should be checked for the the given <c>ReqTrans</c> and <c>ReqPO</c> records.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     The <c>ReqTrans</c> record to check the approved vendor list for.
    /// </param>
    /// <param name = "_reqPO">
    ///     The <c>ReqPO</c> record to check the approved vendor list for.
    /// </param>
    /// <returns>
    ///     true if <c>ProdTable</c> record should be created for this instance; otherwise, false.
    /// </returns>
    protected boolean mustCheckApprovedVendorList(ReqTrans _reqTrans, ReqPO _reqPO)
    {
        return #PdsApprovedVendorListEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBOMRouteFromPhantom</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to create BOM and route from phantom reqTrans.
    /// </summary>
    /// <param name="_reqTrans">
    ///     Requirement transaction.
    /// </param>
    /// <param name="_prodTable">
    ///    The production order for which to create bom and route records.
    /// </param>
    /// <param name="_lineNumOffset">
    ///     The offset from which the bom line number should be generated.
    /// </param>
    /// <param name="_oprNumOffset">
    ///    The offset from which the operation number should be generated.
    /// </param>
    /// <param name="_phantomProdRoute">
    ///    The production operation where the phantom lines should be inserted.
    /// </param>
    /// <returns>
    ///    A container that has the first and the last operation numbers inserted.
    /// </returns>
    private container createBOMRouteFromPhantom(ReqTrans    _reqTrans,
                                                    ProdTable   _prodTable,
                                                    LineNum     _lineNumOffset,
                                                    OprNum      _oprNumOffset,
                                                    ProdRoute   _phantomProdRoute)
    {
        ProdBOM phantomProdBOM = this.createPhantomProdBOM(_reqTrans, _prodTable);
            
        ProdUpdCostEstimation prodUpdCostEstimation = ProdUpdCostEstimation::construct();
        prodUpdCostEstimation.parmPhantomRouteExpanded(phantomRouteExpanded);

        return prodUpdCostEstimation.expandBOMRoute(_prodTable, _lineNumOffset, _oprNumOffset, _phantomProdRoute, phantomProdBOM);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPhantomProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a production BOM from a phantom requirement transaction.
    /// </summary>
    /// <param name = "_reqTrans">The requirement transaction.</param>
    /// <param name = "_prodTable">The production order for which to create the BOM record.</param>
    /// <returns>The created production BOM.</returns>
    protected ProdBOM createPhantomProdBOM(ReqTrans _reqTrans, ProdTable _prodTable)
    {
        ProdBOM phantomProdBOM;

        BOMId bomId = _reqTrans.inventTable().bomId(_prodTable.BOMDate, _reqTrans.Qty, _reqTrans.inventDim());
        phantomProdBOM.initFromProdTable(_prodTable);
        phantomProdBOM.initFromInventTable(_reqTrans.inventTable());
        if (_reqTrans.BOMRefRecId)
        {
            phantomProdBOM.initFromBOM(BOM::findRecId(_reqTrans.BOMRefRecId));
        }
        phantomProdBOM.ItemBomId    = bomId;
        phantomProdBOM.ProdLineType = _reqTrans.bomType;

        return phantomProdBOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBOMRoute</Name>
				<Source><![CDATA[
    public void createBOMRoute(
        ReqTrans _reqTrans,
        ReqPO    _reqPO)
    {
        boolean                 doExplosion;
        boolean                 doScheduling;
        WrkCtrScheduler_Req     scheduleReq;
        WrkCtrParmSchedule      parmSchedule;
        ReqCalcExplodePo        reqCalcExplodePo;
        ReqPlanData             reqPlanData;

        reqPlanData = ReqPlanData::newReqPlanVersion(_reqPO.PlanVersion);

        if (!_reqPO.isRouteCreated() && _reqPO.ItemRouteId)
        {
            _reqTrans.createRoute(reqPlanData);

            _reqPO.setRouteCreated();
            _reqPO.doUpdate();

            doScheduling    = true;
            doExplosion     = true;
        }

        if (!_reqPO.isBOMCreated() && _reqPO.ItemBomId)
        {
            ReqBOMCreate::newReqTrans(_reqTrans, _reqPO, reqPlanData).createBOM();

            _reqPO.setBOMCreated();
            _reqPO.doUpdate();

            doExplosion = true;
        }

        if (doScheduling)
        {
            scheduleReq = WrkCtrScheduler_Req::newCheckLockingTTSLevel(false);
            parmSchedule = WrkCtrParmSchedule::newReqTransCoverage(
                    _reqTrans,
                    _reqPO,
                    reqPlanData,
                    true,
                    false);
            scheduleReq.addWrkCtrParmSchedule(parmSchedule);
            scheduleReq.run();

            scheduleReq.dispose();
        }

        if (doExplosion && this.canRunExplosion())
        {
            reqCalcExplodePo = ReqCalcExplode::newReqTrans(_reqTrans, null);

            reqCalcExplodePo.disableAutoFirm(true);
            reqCalcExplodePo.runOperation();

            reqCalcExplodePo.refreshUpdatedReqTrans(_reqTrans);
            reqCalcExplodePo.refreshUpdatedReqPo(_reqPO);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunExplosion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if explosion logic can run during firming of planned order.
    /// </summary>
    /// <returns>True if explosion logic can run; otherwise, false.</returns>
    [Wrappable(true)]
    internal boolean canRunExplosion()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCrossDockingJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantity for distribution for every <c>PurchTable</c> record in list.
    /// </summary>
    void createCrossDockingJournals()
    {
        PurchTable tPurchTable;
        boolean bRec = m_oPurchToCrossDock.first(tPurchTable);

        ttsbegin;
        while (bRec)
        {
            RetailReplenishment::crossDockFromPlannedOrder(tPurchTable);
            bRec = m_oPurchToCrossDock.next(tPurchTable);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reference data for the net requirements.
    /// </summary>
    /// <param name = "_reqTrans">The net requirements to create reference data for.</param>
    [Replaceable]
    protected void createDefault(ReqTrans _reqTrans)
    {
        throw error(strFmt("@SYS69833", _reqTrans.RefType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipWorkflowSubmissionAndApproval</Name>
				<Source><![CDATA[
    [Replaceable] 
    protected boolean shouldSkipWorkflowSubmissionAndApproval()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates either an <c>InventTransferLine</c> or <c>InventTransferJournal</c> record.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> record.
    /// </param>
    /// <param name="_reqPO">
    ///    A <c>ReqPO</c> record.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The default order settings for the item do not exist.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The receiving warehouse is on hold for transactions.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The From and To warehouses are incorrectly specified.
    /// </exception>
    protected void createInventTransfer(
        ReqTrans _reqTrans,
        ReqPO    _reqPO)
    {
        InventItemInventSetup   inventItemInventSetup;

        InventDim               fromInventDim   = _reqPO.fromInventDimWithDefaultLocation();
        InventDim               toInventDim     = _reqPO.inventDimAndDefault();

        // Validate setup
        inventItemInventSetup = InventItemInventSetup::find(_reqTrans.ItemId, toInventDim.InventDimId);
        if (!inventItemInventSetup.RecId)
        {
            throw error(strFmt("@SYS5700", _reqTrans.ItemId, InventItemOrderSetupType::Invent));
        }

        if (inventItemInventSetup.isStopped())
        {
            throw error(strFmt("@SYS13295", _reqTrans.ItemId, InventItemOrderSetupType::Invent));
        }

        if (!ReqTransFormPO::validateFromInventLocationId(fromInventDim.InventLocationId,toInventDim.InventLocationId,_reqPO))
        {
            throw Exception::Error;
        }

        // Begin > skip of logging to InventSumLogTTS because reqTrans is updated directly in updateFirmedReqTrans
        using (var scope = new InventSumLogTTSSkippingScope(this.mustSkipTTS()))
        {
            // Firm line to a transfer order or journal depending on the setup
            if (_reqPO.mustCreateTransferJournal())
            {
                this.createInventTransferJournal(_reqTrans, _reqPO, fromInventDim, toInventDim);
            }
            else
            {
                this.createInventTransferLine(_reqTrans, _reqPO, fromInventDim.InventLocationId, toInventDim.InventLocationId);
            }
        }

        // Auto reserve settled issues and receipts
        this.updateInventReference(_reqTrans);
        this.updateInventReference(_reqTrans.selectDerived());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransferJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the invent transfer journal record.
    /// </summary>
    /// <param name="_inventJournalTrans">
    ///    The inventory journal line record.
    /// </param>
    /// <param name="_reqTrans">
    ///    The net requirement of the planned order.
    /// </param>
    /// <param name="_reqPO">
    ///    The planned order to use.
    /// </param>
    /// <param name="_fromInventDim">
    ///    The dimension to transfer from.
    /// </param>
    /// <param name="_toInventDim">
    ///    The dimension to transfer to.
    /// </param>
    /// <param name = "_inventJournalTable">
    ///    The inventory journal record.
    /// </param>
    protected void initializeInventTransferJournal(
        InventJournalTrans  _inventJournalTrans,
        ReqTrans            _reqTrans,
        ReqPO               _reqPO,
        InventDim           _fromInventDim,
        InventDim           _toInventDim,
        InventJournalTable  _inventJournalTable)
    {
        // Create InventJournalTrans for the item
        _inventJournalTrans.clear();
        _inventJournalTrans.initValue();
        _inventJournalTrans.initFromInventJournalTable(_inventJournalTable);
        _inventJournalTrans.Qty              = -_reqPO.Qty;
        _inventJournalTrans.setInventDimId(_fromInventDim.InventDimId);
        _inventJournalTrans.ToInventDimId    = _toInventDim.InventDimId;
        _inventJournalTrans.initFromInventTable(InventTable::find(_reqTrans.ItemId), false, false);
        
        // Line Num is represented in sql database as type Numeric(32,16) - we are taking value modulo 10^16, so that even when RecIds reach too big values (which should not happen under normal circumstances) our logic still works - note that line number must be only unique within the same header
        _inventJournalTrans.LineNum = mustRunTransfersPostProcessing? any2Real(_reqPO.RecId mod 10000000000000) : (InventJournalTrans::lastLineNum(_inventJournalTable.JournalId) + 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransferJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the status of the planned order to firm and inserts it into a transfer journal line.
    /// </summary>
    /// <param name="_reqTrans">
    ///    The net requirement of the planned order.
    /// </param>
    /// <param name="_reqPO">
    ///    The planned order to use.
    /// </param>
    /// <param name="_fromInventDim">
    ///    The dimension to transfer from.
    /// </param>
    /// <param name="_toInventDim">
    ///    The dimension to transfer to.
    /// </param>
    protected void createInventTransferJournal(
        ReqTrans  _reqTrans,
        ReqPO     _reqPO,
        InventDim _fromInventDim,
        InventDim _toInventDim)
    {
        var groupingKey = this.reqTransTransferIdKey(_reqTrans, _reqPO);
        
        var journalId = this.findOrCreateInventJournalTable(groupingKey);

        var inventJournalTable  = InventJournalTable::find(journalId, true);
        var journalTableData    = JournalTableData::newTable(inventJournalTable);

        InventJournalTrans  inventJournalTrans;
        JournalTransData    journalTransData = journalTableData.journalStatic().newJournalTransData(inventJournalTrans, journalTableData);

        this.initializeInventTransferJournal(inventJournalTrans, _reqTrans, _reqPO, _fromInventDim, _toInventDim, inventJournalTable);

        if (inventJournalTable.VoucherDraw == JournalVoucherDraw::Entering)
        {
            journalTransData.initVoucher('', false);
        }

        journalTransData.insert();
        journalTableData.journalTable().update();

        // Save the journal id in a map for later use in case of grouping
        if (isTransfersGroupingEnabled)
        {
            processedOrdersData.addTransferJournal(inventJournalTable.JournalId, groupingKey);
        }

        // Create firm log
        this.createReqTransFirmLog(_reqTrans, InventTransType::InventTransfer, inventJournalTrans.JournalId, inventJournalTrans.InventTransId);

        // Update the old reqTrans as transfer journal
        this.updateFirmedReqTrans(_reqTrans,
                                  _reqPO,
                                  ReqRefType::InventTransfer,
                                  inventJournalTrans.JournalId,
                                  InventTransOriginJournalTransReceipt::findInventTransOriginId(inventJournalTrans.DataAreaId, inventJournalTrans.JournalId, inventJournalTrans.LineNum),
                                  InventTransOriginJournalTrans::findInventTransOriginId(inventJournalTrans.DataAreaId, inventJournalTrans.JournalId, inventJournalTrans.LineNum));
        ReqRequisitionsHelper::updateRequisitionLinesFromFirmedReqTrans(_reqTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateInventJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates a new inventory journal based on firmed orders grouping key.
    /// </summary>
    /// <param name = "_groupingKey">The firmed orders grouping key.</param>
    /// <returns>The Id of either found or newly created inventory journal.</returns>
    protected InventJournalId findOrCreateInventJournalTable(ReqPlannedOrderGroupingKey _groupingKey)
    {
        if (isTransfersGroupingEnabled
            && processedOrdersData.checkForTransferJournalWithGroupingKey(_groupingKey))
        {
            return processedOrdersData.getTransferJournalWithGroupingKey(_groupingKey);
        }

        InventJournalId journalId;
        if (isTransfersGroupingEnabled) // if grouping is not used threads can create headers independently
        {
            var groupFirmingParameters = this.groupFirmingParameters(InventTransType::InventTransfer, _groupingKey);
            journalId = groupFirmingParameters.FirmedOrderReferenceId;

            if (reqTransPoMarkFirmInventJournalTableRecordCheckFlightIsEnabled && journalId && !InventJournalTable::find(journalId))
            {
                journalId = null;
            }

            if (!journalId)
            {
                // with the way the method groupFirmingParameters is implemented this place should never be reached by more than one thread at the same time
                journalId = this.createInventJournalTable();

                groupFirmingParameters = ReqPlannedOrderGroupFirmingParameters::find(firmingRunId, InventTransType::InventTransfer, _groupingKey, true);
                groupFirmingParameters.FirmedOrderReferenceId = journalId;
                groupFirmingParameters.update();
            }
        }
        else
        {
            journalId = this.createInventJournalTable();
        }

        return journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new inventory journal record for a transfer order.
    /// </summary>
    /// <returns>The Id of the created inventory journal.</returns>
    protected InventJournalId createInventJournalTable()
    {
        InventJournalTable inventJournalTable;
        var journalTableData = JournalTableData::newTable(inventJournalTable);

        inventJournalTable.JournalId      = journalTableData.nextJournalId();
        inventJournalTable.JournalType    = InventJournalType::Transfer;
        this.initJournalTableFromJournalName(inventJournalTable, journalTableData);

        inventJournalTable.insert();

        return inventJournalTable.JournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalTableFromJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the <c>InventJournalTable</c> by inventory journal name.
    /// </summary>
    /// <param name = "_inventJournalTable">
    ///    The record to be initialized.
    /// </param>
    /// <param name = "_journalTableData">
    ///    The record contains invent journal table data.
    /// </param>
    public void initJournalTableFromJournalName(InventJournalTable _inventJournalTable, JournalTableData _journalTableData)
    {
        _inventJournalTable.JournalNameId = _journalTableData.journalStatic().standardJournalNameId(enum2int(_inventJournalTable.JournalType));
        _inventJournalTable.initFromInventJournalName(InventJournalName::find(_inventJournalTable.JournalNameId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new <c>InventTransferLine</c> record.
    /// </summary>
    /// <param name = "_reqPO">
    ///    A <c>ReqPO</c> record.
    /// </param>
    /// <param name = "_inventTransferTable">
    ///    A <c>InventTransferTable</c> record.
    /// </param>
    /// <returns>
    ///     A new <c>InventTransferLine</c> record.
    /// </returns>
    protected InventTransferLine initInventTransferLine(
        ReqPO               _reqPO,
        InventTransferTable _inventTransferTable
        )
    {
        InventTransferLine inventTransferLine;
        inventTransferLine.initValue();
        inventTransferLine.initFromReqPo(_reqPO);
        inventTransferLine.initFromInventTransferTable(_inventTransferTable, true);
        inventTransferLine.initDimensionsDefault(inventTransferLine.createInventDimTo(inventTransferLine.InventDimId));
        inventTransferLine.setDeliveryDateControlType();

        // Line Num is represented in sql database as type Numeric(32,16) - we are taking value modulo 10^16, so that even when RecIds reach too big values (which should not happen under normal circumstances) our logic still works - note that line number must be only unique within the same header
        inventTransferLine.LineNum = mustRunTransfersPostProcessing ? any2Real(_reqPO.RecId mod 10000000000000000) : (InventTransferLine::lastLineNum(inventTransferLine.TransferId) + 1.0);

        return inventTransferLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an <c>InventTransferLine</c> record.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> record.
    /// </param>
    /// <param name="_reqPO">
    ///    A <c>ReqPO</c> record.
    /// </param>
    /// <param name="_fromInventLocationId">
    ///    The ID of the warehouse to transfer from.
    /// </param>
    /// <param name="_toInventLocationId">
    ///    The ID of the warehouse to transfer to.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    A transfer order could not be created.
    /// </exception>
    protected void createInventTransferLine(
        ReqTrans         _reqTrans,
        ReqPO            _reqPO,
        InventLocationId _fromInventLocationId,
        InventLocationId _toInventLocationId)
    {
        InventTransferTable     inventTransferTable;
        InventTransferLine      inventTransferLine;
        // GIN>
        InventTransferLine_IN   inventtransferLineIN;
        // </GIN>

        if (!_reqPO.validateTransferOrder(_fromInventLocationId, _toInventLocationId))
        {
            throw Exception::Error;
        }

        // init
        var transferId = this.findOrCreateInventTransferTable(_reqTrans, _reqPO, _fromInventLocationId, _toInventLocationId);

        inventTransferTable = InventTransferTable::find(transferId, true);
        if (! inventTransferTable.RecId)
        {
            throw error(strFmt("@SYS78750", transferId));
        }

        inventTransferLine = this.initInventTransferLine(_reqPO, inventTransferTable);

        this.insertMovement(inventTransferLine);

        if (!mustRunTransfersPostProcessing && inventTransferLine.ShipDate < inventTransferTable.ShipDate)
        {
            inventTransferTable.ShipDate = inventTransferLine.ShipDate;
            inventTransferTable.update();
        }

        if (!mustRunTransfersPostProcessing && inventTransferLine.ReceiveDate > inventTransferTable.ReceiveDate)
        {
            inventTransferTable.ReceiveDate = inventTransferLine.ReceiveDate;
            inventTransferTable.update();
        }

        // <GIN>
        if (countryRegion_IN)
        {
            inventtransferLineIN = InventTransferLine_IN::findByinventTransferLine(inventTransferLine.RecId);

            if (inventtransferLineIN.RecId == 0)
            {
                inventtransferLineIN.InventTransferLine = inventTransferLine.RecId;
                inventtransferLineIN.insert();
            }

            boolean enabledStockTransferPriceDefaultingInMasterPlanningFeature_IN = StockTransferPriceDefaultingInMasterPlanningFeature_IN::isEnabled();

            if ((enabledStockTransferPriceDefaultingInMasterPlanningFeature_IN && inventTransferTable.TransferType_IN == TransferType_IN::StockTransfer) || 
                inventTransferTable.StockTransferCostPriceHandlingImprovement_IN)
            {
                inventtransferLineIN.selectForUpdate(true);
                if (enabledStockTransferPriceDefaultingInMasterPlanningFeature_IN)
                {
                    inventtransferLineIN.PriceType = ReqParameters::find().PriceType_IN;
                    inventTransferLineIN.vatPriceType = inventtransferLineIN.PriceType;
                }
                inventTransferLineIN.recalculateStockTransferValue(inventTransferLine, inventTransferLine.inventDim());
                inventTransferLineIN.update();
            }
        }
        // </GIN>
        // <GTE>
        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(inventTransferLine);
        }
        // <GTE>
        // create firm log
        this.createReqTransFirmLog(_reqTrans, InventTransType::TransferOrderReceive, inventTransferTable.TransferId, inventTransferLine.InventTransIdReceive);

        // Save the transfer id in a map for later use in case of grouping
        if (isTransfersGroupingEnabled)
        {
            var groupingKey = this.reqTransTransferIdKey(_reqTrans, _reqPO);
            processedOrdersData.addTransferOrder(transferId, groupingKey);
        }

        // Update reqTrans as transfer order
        this.updateFirmedReqTrans(_reqTrans,
                                  _reqPO,
                                  ReqRefType::TransferOrderReceive,
                                  inventTransferLine.TransferId,
                                  InventTransOriginTransferReceive::findInventTransOriginId(inventTransferLine.DataAreaId, inventTransferLine.TransferId, inventTransferLine.LineNum),
                                  InventTransOriginTransferShip::findInventTransOriginId(inventTransferLine.DataAreaId, inventTransferLine.TransferId, inventTransferLine.LineNum));
        ReqRequisitionsHelper::updateRequisitionLinesFromFirmedReqTrans(_reqTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransferTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a record of type <c>InventTransferTable</c>.
    /// </summary>
    /// <param name = "_reqPO">
    ///     A record of type <c>ReqPO</c>.
    /// </param>
    /// <param name = "_fromInventLocationId">
    ///     The Id of the warehouse to transfer from.
    /// </param>
    /// <param name = "_toInventLocationId">
    ///     The Id of the warehouse to transfer to.
    /// </param>
    /// <returns>
    ///     A new <c>InventTransferTable</c> record.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     The transfer order could not be created.
    /// </exception>
    protected InventTransferTable initInventTransferTable(
        ReqPO            _reqPO,
        InventLocationId _fromInventLocationId,
        InventLocationId _toInventLocationId)
    {
        InventTransferTable inventTransferTable;
        inventTransferTable.initValue();
        inventTransferTable.TransferId                  = InventTransferTable::numberSeq().num();
        inventTransferTable.InventLocationIdTo          = _toInventLocationId;
        inventTransferTable.InventLocationIdFrom        = _fromInventLocationId;
        inventTransferTable.DlvModeId                   = CustVendTransportPointLine::defaultDeliveryMode(inventTransferTable.InventLocationIdFrom, '', '', '', '', inventTransferTable.InventLocationIdTo);
        
        if (inventTransferTable.DlvModeId)
        {
            inventTransferTable.Transport = DlvMode::find(inventTransferTable.DlvModeId).Transport;
        }

        inventTransferTable.InventLocationIdTransit     = InventLocation::find(inventTransferTable.InventLocationIdFrom).InventLocationIdTransit;
        inventTransferTable.initFromAddress();
        inventTransferTable.initToAddress();
        // <GEERU>
        inventTransferTable.initInventProfile_RU();
        inventTransferTable.initInventProfileTo_RU();
        // </GEERU>

        inventTransferTable.initFromReqPo(_reqPO);

        if (!inventTransferTable.validateWrite())
        {
            throw error("@SYS18447");
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            inventTransferTable.packInventTransferTableFiscalInfo_BR(
                    inventTransferTable.inventTransferTableFiscalInfo_BR());
        }
        // </GBR>

        if (countryRegion_IN)
        {
            if (StockTransferPriceDefaultingInMasterPlanningFeature_IN::isEnabled())
            {
                inventTransferTable.TransferType_IN = reqParameters.TransferType_IN;

                if (inventTransferTable.TransferType_IN == TransferType_IN::StockTransfer &&
                    StockTransferCostPriceHandlingImprovementFeatureExposure_IN::isEnabled())
                {
                    inventTransferTable.PriceType_IN = reqParameters.PriceType_IN;
                }
            } 
        }

        return inventTransferTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateInventTransferTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds or creates a record of type <c>InventTransferTable</c>.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     A record of type <c>ReqTrans</c>.
    /// </param>
    /// <param name = "_reqPO">
    ///     A record of type <c>ReqPO</c>.
    /// </param>
    /// <param name = "_fromInventLocationId">
    ///     The Id of the warehouse to transfer from.
    /// </param>
    /// <param name = "_toInventLocationId">
    ///     The Id of the warehouse to transfer to.
    /// </param>
    /// <returns>
    ///     A string that holds the transfer order ID.
    /// </returns>
    /// <exception cref = "Exception::Error">
    ///     The transfer order could not be created.
    /// </exception>
    protected InventTransferId findOrCreateInventTransferTable(
        ReqTrans         _reqTrans,
        ReqPO            _reqPO,
        InventLocationId _fromInventLocationId,
        InventLocationId _toInventLocationId)
    {
        InventTransferId transferId = this.findInventTransferTable(_reqTrans, _reqPO);
        if (!transferId)
        {
            if (isPartOfBiggerRun && isTransfersGroupingEnabled) // if grouping is not used threads can create headers independently
            {
                var groupingKey = this.reqTransTransferIdKey(_reqTrans, _reqPO);

                var groupFirmingParameters = this.groupFirmingParameters(InventTransType::TransferOrderReceive, groupingKey);
                transferId = groupFirmingParameters.FirmedOrderReferenceId;

                if (!transferId)
                {
                    // with the way the method groupFirmingParameters is implemented this place should never be reached by more than one thread at the same time
                    transferId = this.createInventTransferTable(_reqTrans, _reqPO, _fromInventLocationId, _toInventLocationId);

                    ttsbegin;
                    groupFirmingParameters = ReqPlannedOrderGroupFirmingParameters::find(firmingRunId, InventTransType::TransferOrderReceive, groupingKey, true);
                    groupFirmingParameters.FirmedOrderReferenceId = transferId;
                    groupFirmingParameters.update();
                    ttscommit;
                }
            }
            else
            {
                transferId = this.createInventTransferTable(_reqTrans, _reqPO, _fromInventLocationId, _toInventLocationId);
            }

        }

        return transferId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventTransferTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds a record of type <c>InventTransferTable</c>.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     A record of type <c>ReqTrans</c>.
    /// </param>
    /// <param name = "_reqPO">
    ///     A record of type <c>ReqPO</c>.
    /// </param>
    /// <returns>
    ///     A string that holds the transfer order ID, if found.
    /// </returns>
    /// <exception cref = "Exception::Error">
    ///     The transfer order could not be created.
    /// </exception>
    protected InventTransferId findInventTransferTable(
        ReqTrans         _reqTrans,
        ReqPO            _reqPO)
    {
        InventTransferId transferId;

        if (_reqPO.TransferId)
        {
            return _reqPO.TransferId;
        }

        if (isTransfersGroupingEnabled)
        {
            var groupingKey = this.reqTransTransferIdKey(_reqTrans, _reqPO);

            if (processedOrdersData.checkForTransferOrderWithGroupingKey(groupingKey))
            {
                transferId = processedOrdersData.getTransferOrderWithGroupingKey(groupingKey);
            }
        }

        return transferId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransferTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a record of type <c>InventTransferTable</c>.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     A record of type <c>ReqTrans</c>.
    /// </param>
    /// <param name = "_reqPO">
    ///     A record of type <c>ReqPO</c>.
    /// </param>
    /// <param name = "_fromInventLocationId">
    ///     The Id of the warehouse to transfer from.
    /// </param>
    /// <param name = "_toInventLocationId">
    ///     The Id of the warehouse to transfer to.
    /// </param>
    /// <returns>
    ///     A string that holds the transfer order ID.
    /// </returns>
    /// <exception cref = "Exception::Error">
    ///     The transfer order could not be created.
    /// </exception>
    protected InventTransferId createInventTransferTable(
        ReqTrans         _reqTrans,
        ReqPO            _reqPO,
        InventLocationId _fromInventLocationId,
        InventLocationId _toInventLocationId)
    {
        InventTransferTable inventTransferTable = this.initInventTransferTable(_reqPO, _fromInventLocationId, _toInventLocationId);

        inventTransferTable.insert();

        return inventTransferTable.TransferId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates one or more kanbans by firming a planned kanban.
    /// </summary>
    /// <param name="_reqPO">
    ///    A <c>ReqPO</c> record that represents a planned order.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    A kanban rule could not be found.
    /// </exception>
    protected void createKanban(ReqPO _reqPO)
    {
        KanbanRule              kanbanRule;
        LeanRuleData            leanRuleData;
        ReqTransPOFirmKanban    reqTransPOFirmKanban;

        leanRuleData = _reqPO.reqSetupDim().leanRuleData(_reqPO.reqDateTime(), _reqPO.RefType, _reqPO.Qty, LeanReplenishmentStrategy::Scheduled);

        if (leanRuleData)
        {
            kanbanRule = leanRuleData.parmKanbanRule();
        }

        if (!kanbanRule)
        {
            throw error(strFmt("@SYS329675", _reqPO.RefType, LeanReplenishmentStrategy::Scheduled));
        }

        if (kanbanRule.ReplenishmentStrategy != LeanReplenishmentStrategy::Scheduled)
        {
            throw error(strFmt("@SYS327499", kanbanRule.ReplenishmentStrategy));
        }

        reqTransPOFirmKanban = ReqTransPOFirmKanban::newParameters(_reqPO, kanbanRule);
        reqTransPOFirmKanban.parmIsAutoFirm(isAutoFirm);
        reqTransPOFirmKanban.parmIsMustSkipTTS(this.parmIsMustSkipTTS());
        reqTransPOFirmKanban.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdBOM</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPErrorMethodDeleteFromNotUsed', 'The business logic pertaining to the deletion of ReqTransBOM records cannot be summarized to a delete_from statement.')]
    protected container createProdBOM(
        ReqTrans    _reqTrans,
        ProdTable   _prodTable,
        LineNum     _lineNumOffset,
        OprNum      _oprNumOffset,
        OprNum      _oprNumFirst,
        OprNum      _oprNumNext,
        OprNum      _oprNumPhantom,
        BOM         _phantomBOM,
        Factor      _phantomUnitFactor  = 1)
    {
        LineNum lineNumNext = _lineNumOffset;
        OprNum oprNumNext  = _oprNumNext;

        BOMCopyToProd copyToProd = BOMCopyToProd::newProdTableType(_prodTable);

        ReqTrans reqTransBOM;

        if (ReqCreateProdBomOrderedByBomLineNumWhenPoFirmingFlight::instance().isEnabled())
        {
            BOM bom;

            while select forupdate reqTransBOM
                index hint RefIdx
                order by bom.LineNum, bom.RecId, reqTransBOM.RecId
                where reqTransBOM.PlanVersion == _reqTrans.PlanVersion
                    && (reqTransBOM.RefType == ReqRefType::BOMLine
                        || reqTransBOM.RefType  == ReqRefType::PmfFormulaLine)
                    && reqTransBOM.RefId == _reqTrans.RefId
                outer join RecId, LineNum from bom
                    where bom.RecId == reqTransBOM.BomRefRecId
            {
                [lineNumNext,oprNumNext] = this.createProdBOMFromBOMReqTrans(
                    reqTransBOM,
                    _reqTrans,
                    _prodTable,
                    lineNumNext,
                    _oprNumOffset,
                    _oprNumFirst,
                    oprNumNext,
                    _oprNumPhantom,
                    _phantomBOM,
                    copyToProd,
                    _phantomUnitFactor);
            }
        }
        else
        {
            while select forupdate reqTransBOM
                index hint RefIdx
                order by RecId
                where reqTransBOM.PlanVersion   == _reqTrans.PlanVersion
                    && (    reqTransBOM.RefType     ==  ReqRefType::BOMLine
                        ||  reqTransBOM.RefType     ==  ReqRefType::PmfFormulaLine )
                    && reqTransBOM.RefId        == _reqTrans.RefId
            {
                [lineNumNext,oprNumNext] = this.createProdBOMFromBOMReqTrans(
                reqTransBOM,
                _reqTrans,
                _prodTable,
                lineNumNext,
                _oprNumOffset,
                _oprNumFirst,
                oprNumNext,
                _oprNumPhantom,
                _phantomBOM,
                copyToProd,
                _phantomUnitFactor);
            }
        }

        if (#PDSPotencyEnabled)
        {
            this.pdsCreateProdCompensationPrinciples(_prodTable);
        }

        return [lineNumNext,oprNumNext];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdBOMFromBOMReqTrans</Name>
				<Source><![CDATA[
    private container createProdBOMFromBOMReqTrans(
        ReqTrans _reqTransBOM,         
        ReqTrans _reqTrans,
        ProdTable _prodTable,
        LineNum _lineNumNext,
        OprNum _oprNumOffset,
        OprNum _oprNumFirst,
        OprNum _oprNumNext,
        OprNum _oprNumPhantom,
        BOM _phantomBOM,
        BOMCopyToProd _copyToProd,
        Factor _phantomUnitFactor  = 1)
    {
        ReqTrans reqTransDerived;
        reqTransDerived.selectForUpdate(true);

        LineNum lineNumNext = _lineNumNext;
        OprNum  oprNumNext  = _oprNumNext;

        setPrefix(#PreFixField(_reqTransBOM,ItemId));

        InventTable inventTable = InventTable::find(_reqTransBOM.ItemId);
        if (!inventTable.RecId)
        {
            throw error(strFmt(InventTable::txtNotExist(),_reqTransBOM.ItemId));
        }

        if (!InventTableModule::find(_reqTransBOM.ItemId,ModuleInventPurchSales::Invent).RecId)
        {
            throw error(strFmt("@SYS5700",_reqTransBOM.ItemId,ModuleInventPurchSales::Invent));
        }

        BOM bom = _reqTransBOM.refBOM();
        if (this.requiredBOMIsMissing(bom, _reqTransBOM, _reqTrans, _prodTable, _phantomBOM))
        {
            throw error("@SYS25492");
        }

        if (_phantomBOM.RecId)
        {
            bom.BOMMap::initializePhantomBOMMap(_phantomBOM, _phantomUnitFactor, _prodTable);
        }

        if (   _reqTransBOM.bomType == BOMType::Phantom
                && _reqTransBOM.IsDerivedDirectly
                && inventTable.ItemType == ItemType::Item)
        {
            if (!bom.BOMMap::itemBOMId(_prodTable.bomDate, _reqTransBOM.Qty, _reqTransBOM.inventDim()))
            {
                throw error(strFmt("@SYS112833", _prodTable.ItemId, _reqTransBOM.ItemId, _reqTransBOM.inventDim().InventSiteId));
            }

            OprNumBOM oprNumBOM = this.initializePhantomBOMOperationNumber(bom, _prodTable, _oprNumOffset, _oprNumFirst, _oprNumNext, _oprNumPhantom, _phantomBOM);

            // expand phantom
            ProdRoute phantomProdRoute;
            reqTransDerived = _reqTransBOM.reqTransDirectlyDerived(true);
            if (reqTransDerived.RecId)
            {
                if (reqTransDerived.RefType == ReqRefType::BOMPlannedOrder
                        ||  reqTransDerived.RefType == ReqRefType::PmfPlannedProdBatch)
                {
                    ReqPO reqPoDerived = reqTransDerived.reqPo(true);
                    if (reqPoDerived.RecId)
                    {
                        phantomDerivedData.insert(reqTransDerived.RecId, [reqTransDerived, reqPoDerived]);

                        this.createBOMRoute(reqTransDerived,reqPoDerived); // Make sure that BOM/Route has been created

                        // adjust production start date

                        if (reqPoDerived.SchedFromDate <  _prodTable.SchedStart ||
                           (reqPoDerived.SchedFromDate == _prodTable.SchedStart && reqPoDerived.ReqTimeOrder < _prodTable.SchedFromTime))
                        {
                            _prodTable.reread();
                            _prodTable.SchedStart       = reqPoDerived.SchedFromDate;
                            _prodTable.SchedFromTime    = reqPoDerived.ReqTimeOrder;
                            _prodTable.doUpdate();
                        }

                        OprNumBOM oprNumBOMLocal;
                        if (bom.OprNum)
                        {
                            oprNumBOMLocal = bom.OprNum + _oprNumOffset;
                        }
                        else
                        {
                            RouteId phantomRouteId;
                            if (bom.ItemRouteId)
                            {
                                phantomRouteId = bom.ItemRouteId;
                            }
                            else
                            {
                                phantomRouteId = _phantomBOM.inventTable().routeId(_prodTable.BOMDate, _prodTable.QtySched, InventDim::find(_phantomBOM.InventDimId));
                            }

                            oprNumBOMLocal = Route::findFirst(phantomRouteId).OprNum + _oprNumOffset;
                        }

                        phantomProdRoute = ProdRoute::findPhantomBOMFirst(_prodTable.ProdId, _oprNumPhantom, oprNumBOMLocal, _oprNumFirst, phantomProdRoute);
                        [lineNumNext, oprNumNext] = this.expandBOMRoute(reqTransDerived, _prodTable, lineNumNext, oprNumNext, phantomProdRoute, bom);
                    }
                }

                ReqTrans reqTransCopy = this.findReqTransDynamic(_reqTransBOM);
                if (reqTransCopy.RecId)
                {
                    reqTransCopy.delete();
                }
            }
            else
            {
                phantomProdRoute = ProdRoute::findPhantomBOMFirst(_prodTable.ProdId, _oprNumPhantom, oprNumBOM + _oprNumOffset, _oprNumFirst, phantomProdRoute);
                [lineNumNext, oprNumNext] = this.createBOMRouteFromPhantom(_reqTransBOM, _prodTable, lineNumNext, oprNumNext, phantomProdRoute);
            }

            _reqTransBOM.delete();
        }
        else
        {
            lineNumNext++;

            // Init and create prodBOm
            ProdBOM prodBOM = this.initializeProductionBOM(_reqTransBOM, _prodTable, bom, _oprNumOffset, _oprNumFirst, _oprNumNext, _oprNumPhantom, _phantomBOM);
           
            prodBOM.LineNum = lineNumNext;

            using (ReqTransPoMarkFirmCreateProdBOMContext context = new ReqTransPoMarkFirmCreateProdBOMContext())
            {
                context.parmSkipDerivedDirectlyProdBOMReservation(ReqFirmingWithBatchNumDimPrimaryStockingFlagFlight::instance().isEnabled() && _reqTransBOM.IsDerivedDirectly);
                this.insertMovement(prodBOM);
            }
            _copyToProd.copySteps(bom, prodBOM);

            // Create directly derived production or purchase order
            if (_reqTransBOM.IsDerivedDirectly)
            {
                this.createDerivedOrder(_reqTransBOM, prodBOM);
            }

            // Update reqTrans as production line

            this.updateFirmedReqTransBOM(_reqTransBOM,prodBOM);

            // Auto mark issue

            if (!prodBOM.InventRefTransId)
            {
                this.updateInventReference(_reqTransBOM);
            }

            if (_reqTransBOM.Qty < 0)
            {
                if (prodBOM.Reservation == ProdReservation::Estimation
                     || prodBOM.Reservation == ProdReservation::Scheduling)
                {
                    InventMovement::construct(prodBOM).updateReservation();
                }
            }
        }

        return [lineNumNext,oprNumNext];
    }

]]></Source>
			</Method>
			<Method>
				<Name>requiredBOMIsMissing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the required BOM is missing
    /// </summary>
    /// <param name = "_bom"> The BOM record of the ReqTrans to be updated . </param>
    /// <param name = "_reqTransBOM"> The set of ReqTrans to be updated related to the current production order. </param>
    /// <param name = "_reqTrans"> The ReqTrans of the production order. </param>
    /// <param name = "_prodTable"> The ProdTable record created for the corresponding ReqTrans. </param>
    /// <param name = "_phantomBOM"> The phantomUnitFactor. </param>
    /// <returns> True if the required BOM is missing. </returns>
    protected boolean requiredBOMIsMissing(
        BOM         _bom,
        ReqTrans    _reqTransBOM,
        ReqTrans    _reqTrans,
        ProdTable   _prodTable,
        BOM         _phantomBOM)
    {
        return !_bom.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePhantomBOMOperationNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the bill of materials line operation number.
    /// </summary>
    /// <param name = "_bom">The bill of material lines record.</param>
    /// <param name = "_prodTable">The production order record.</param>
    /// <param name = "_oprNumOffset">The operation number off set.</param>
    /// <param name = "_oprNumFirst">The first operation number.</param>
    /// <param name = "_oprNumNext">The next operation number.</param>
    /// <param name = "_oprNumPhantom">The phantom operation number.</param>
    /// <param name = "_phantomBOM">The phantom bill of material lines record.</param>
    /// <returns>The initialized bill of materials line operation number.</returns>
    protected OprNumBOM initializePhantomBOMOperationNumber(
        BOM         _bom,
        ProdTable   _prodTable,
        OprNum      _oprNumOffset,
        OprNum      _oprNumFirst,
        OprNum      _oprNumNext,
        OprNum      _oprNumPhantom,
        BOMMap      _phantomBOM)
    {
        return _bom.OprNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProductionBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production bill of materials record.
    /// </summary>
    /// <param name = "_reqTransBOM">The net requirements.</param>
    /// <param name = "_prodTable">A production order.</param>
    /// <param name = "_bom">A bill of materials record.</param>
    /// <param name = "_oprNumOffset">The operation number off set.</param>
    /// <param name = "_oprNumFirst">The first operation number.</param>
    /// <param name = "_oprNumNext">The next operation number.</param>
    /// <param name = "_oprNumPhantom">The phantom operation number.</param>
    /// <param name = "_phantomBOM">The phantom bill of material lines record.</param>
    /// <returns>An initialized production bill of materials record.</returns>
    protected ProdBOM initializeProductionBOM(
        ReqTrans    _reqTransBOM,
        ProdTable   _prodTable,
        Bom         _bom,
        OprNum      _oprNumOffset,
        OprNum      _oprNumFirst,
        OprNum      _oprNumNext,
        OprNum      _oprNumPhantom,
        BOMMap      _phantomBOM)
    {
        ProdBOM prodBOM;

        prodBOM.clear();
        prodBOM.InventTransId           = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
        prodBOM.initFromProdTable(_prodTable);
        prodBOM.initFromBOM(_bom);

        if (prodBOM.OprNum)
        {
            prodBOM.OprNum             += _oprNumOffset;

            if (!ProdRoute::exist(_prodTable.ProdId, prodBOM.OprNum, RouteOprPriority::Primary))
            {
                prodBOM.OprNum          = _oprNumFirst;
            }
        }
        else
        {
            prodBOM.OprNum              = _oprNumFirst;
        }

        prodBOM.initFromReqTrans(_reqTransBOM);
        InventTable inventTable = InventTable::find(_reqTransBOM.ItemId);
        prodBOM.DefaultDimension        = prodBOM.mergeDimension(_prodTable.DefaultDimension, inventTable.DefaultDimension);

        InventDim inventDimProdBOM = prodBOM.BOMMap::inventDimFinal(_prodTable.ItemId, _prodTable.inventDim(), _prodTable.RouteId);

        // Set WMSLocation from the scheduled resource.
        if (prodBOM.WrkCtrConsumption)
        {
            WrkCtrTable scheduledResource                   = prodBOM.getResourceForStorageDimensions();
            InventLocationId scheduledResourceWarehouseId   = scheduledResource.inputWarehouseId(prodBOM.RawMaterialDate);
            if (scheduledResourceWarehouseId)
            {
                inventDimProdBOM.InventLocationId = scheduledResourceWarehouseId;
            }

            if (!inventDimProdBOM.inventLocation().WHSEnabled || !WHSInventTable::exist(prodBOM.ItemId))
            {
                WMSLocationId scheduledResourceWmsLocationId = scheduledResource.inputWMSLocation(prodBOM.RawMaterialDate).wMSLocationId;
                if (scheduledResourceWmsLocationId)
                {
                    inventDimProdBOM.wmsLocationId = scheduledResourceWmsLocationId;
                }
            }
        }

        prodBOM.setInventDimId(InventDim::findOrCreate(inventDimProdBOM).InventDimId);

        if (_prodTable.isProjMethodConsumed())
        {
            ProjInventJournalTransMapForm::construct(prodBOM).initProdBOM();
        }

        return prodBOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdBOMFromProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production bill of materials record from the production order.
    /// </summary>
    /// <param name = "_prodBOM">A production bill of materials record to initialize.</param>
    /// <param name = "_prodTable">A production order.</param>
    protected void initializeProdBOMFromProdTable(ProdBOM _prodBOM, ProdTable _prodTable)
    {
        _prodBOM.InventRefType       = InventRefType::Production;
        _prodBOM.InventRefId         = _prodTable.ProdId;
        _prodBOM.InventRefTransId    = _prodTable.InventTransId;
        _prodBOM.setInventDimId(_prodTable.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDerivedOrder</Name>
				<Source><![CDATA[
    protected void createDerivedOrder(ReqTrans _reqTransBOM, ProdBOM _prodBOM)
    {
        ReqTrans reqTransDerived = _reqTransBOM.reqTransDirectlyDerived(true);

        switch (reqTransDerived.RefType)
        {
            case ReqRefType::PmfPlannedProdBatch:
            case ReqRefType::BOMPlannedOrder :
                ProdTable prodTableDerived  = this.createProdTable(reqTransDerived, reqTransDerived.reqPo(true), _prodBOM);
                _prodBOM.reread();
                this.initializeProdBOMFromProdTable(_prodBOM, prodTableDerived);
                _prodBOM.update();
                break;

            case ReqRefType::ItemPlannedOrder :
                if(this.mustCreateDerivedPurch(reqTransDerived, _prodBOM))
                {
                    PurchLine purchLineDerived   = this.createPurchLine(reqTransDerived, reqTransDerived.reqPo(true), _prodBOM);
                    _prodBOM.reread();
                    this.initializeProdBOMFromPurchLine(_prodBOM, purchLineDerived);
                    _prodBOM.update();

                    if (_prodBOM.InventRefTransId)
                    {
                        InventUpd_Reservation::updateReserveRefTransId(InventMovement::construct(_prodBOM));
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustcreateDerivedPurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the reqTransDerived should be created
    /// </summary>
    /// <param name = "_reqTransDerived">The reqTransDerived to be created</param>
    /// <param name = "_prodBOM">A production bill of materials record to initialize.</param>
    /// <returns> Returns true if the reqTransDerived should be created. </returns>
    protected boolean mustcreateDerivedPurch(ReqTrans _reqTransDerived, ProdBOM  _prodBOM)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdBOMFromPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production bill of materials record from the purchase order line.
    /// </summary>
    /// <param name = "_prodBOM">A production bill of materials record to initialize.</param>
    /// <param name = "_purchLine">A purchase order line.</param>
    protected void initializeProdBOMFromPurchLine(ProdBOM _prodBOM, PurchLine _purchLine)
    {
        _prodBOM.InventRefType       = InventRefType::Purch;
        _prodBOM.InventRefId         = _purchLine.PurchId;
        _prodBOM.InventRefTransId    = _purchLine.InventTransId;
        _prodBOM.setInventDimId(_purchLine.InventDimId);
        _prodBOM.VendId              = _purchLine.VendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdRoute</Name>
				<Source><![CDATA[
    protected container createProdRoute(
            ReqTrans    _reqTrans,
            ProdTable   _prodTable,
            OprNum      _oprNumOffset,
            ProdRoute   _phantomProdRoute,
            BOM         _phantomBOM,
            Factor      _phantomUnitFactor  = 1)
    {
        ProdRoute               prodRoute;
        ReqRoute                reqRoute;

        RouteOpr                routeOpr;

        BOMCalcData             bomCalcData         = BOMCalcData::newProdTable(_prodTable.QtySched,_prodTable);
        ProdJobTypeSearch       prodJobTypeSearch   = new ProdJobTypeSearch();
        ProdJobType             prodJobType;

        ProdRouteOverlapCalc    prodRouteOverlapCalc;

        OprNum                  oprNumLast          = _oprNumOffset;
        OprNum                  oprNumFirst;
        Level                   levelFirst;

        while select reqRoute
            order by OprNum,OprPriority
            where reqRoute.PlanVersion == _reqTrans.PlanVersion
               && reqRoute.RefId       == _reqTrans.RefId
        {
            setPrefix(#PreFixField(ReqRoute,OprNum));

            routeOpr = reqRoute.refRouteOpr();
            prodRoute = this.insertProdRoute(_prodTable,
                                             _oprNumOffset,
                                             _phantomBOM,
                                             reqRoute,
                                             _phantomProdRoute,
                                             _phantomUnitFactor);

            this.updateProdRouteProj(_prodTable, prodRoute);
            Docu::copy(routeOpr, prodRoute);
            WrkCtrActivityRequirementSet::copyRequirements(routeOpr.activity(), prodRoute.activity());

            if (prodJobTypeSearch.first())
            {
                do
                {
                    prodJobType = prodJobTypeSearch.prodJobType();
                    prodJobType.setCalcConsumptionProdRoute(prodRoute,bomCalcData);
                }
                while (prodJobTypeSearch.next());
            }

            prodRoute.doUpdate();

            if (   prodRoute.Level   >  levelFirst
                || (prodRoute.Level  == levelFirst
                &&  prodRoute.OprNum <  oprNumFirst))
            {
                oprNumFirst = prodRoute.OprNum;
                levelFirst  = prodRoute.Level;
            }

            oprNumLast  = prodRoute.OprNum;

            if (_oprNumOffset && phantomRouteExpanded)
            {
                phantomRouteExpanded.add(_prodTable.ProdId);
            }
        }

        // Calculate and update OverlapQty field (overlap job's time has already been calculated during the master scheduling)
        while select forupdate prodRoute
            index hint NumOprNumIdx
            where prodRoute.ProdId      == _prodTable.ProdId
               && prodRoute.OprPriority == RouteOprPriority::Primary
               && prodRoute.TransferBatch
        {
            prodRouteOverlapCalc = ProdRouteOverlapCalc::newProdRouteBOMData(
                    prodRoute,
                    bomCalcData,
                    true,      // update ProdRoute
                false,     // show the calculated overlap qty
                false);     // inform when the overlap qty is changed
            prodRouteOverlapCalc.run();
        }

        return [oprNumFirst,oprNumLast];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ProdRoute</c> buffer.
    /// </summary>
    /// <param name = "_prodTable">The instance of <c>ProdTable</c> table.</param>
    /// <param name = "_oprNumOffset">The operation number <c>OprNum</c>.</param>
    /// <param name = "_phantomBOM">The <c>BOM</c> record.</param>
    /// <param name = "_reqRoute">The <c>ReqRoute</c> record.</param>
    /// <param name = "_phantomProdRoute">The <c>ProdRoute</c> record.</param>
    /// <param name = "_phantomUnitFactor">The <c>Factor</c> factor.</param>
    /// <returns>Initialized <c>ProdRoute</c> buffer.</returns>
    protected ProdRoute initializeProdRoute(
        ProdTable _prodTable,
        OprNum    _oprNumOffset,
        BOM       _phantomBOM,
        ReqRoute  _reqRoute,
        ProdRoute _phantomProdRoute,
        Factor    _phantomUnitFactor)
    {
        ProdRoute prodRoute;
        prodRoute.initFromProdTable(_prodTable);
        prodRoute.initFromReqRouteRouteOpr(_reqRoute,_reqRoute.refRouteOpr());
        prodRoute.initFromPhantom(_phantomBOM,_phantomProdRoute,_reqRoute.OprNum,_reqRoute.OprNumNext,_reqRoute.Level,_oprNumOffset,_phantomUnitFactor);

        this.initializeProdRouteShopFloorControl(prodRoute);
        
        return prodRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the <c>ProdRoute</c> buffer.
    /// </summary>
    /// <param name = "_prodTable">The instance of <c>ProdTable</c> table.</param>
    /// <param name = "_oprNumOffset">The operation number <c>OprNum</c>.</param>
    /// <param name = "_phantomBOM">The <c>BOM</c> record.</param>
    /// <param name = "_reqRoute">The <c>ReqRoute</c> record.</param>
    /// <param name = "_phantomProdRoute">The <c>ProdRoute</c> record.</param>
    /// <param name = "_phantomUnitFactor">The <c>Factor</c> factor.</param>
    /// <returns>Inserted <c>ProdRoute</c> buffer.</returns>
    protected ProdRoute insertProdRoute(
        ProdTable _prodTable,
        OprNum    _oprNumOffset,
        BOM       _phantomBOM,
        ReqRoute  _reqRoute,
        ProdRoute _phantomProdRoute,
        Factor    _phantomUnitFactor)
    {
        ProdRoute prodRoute = this.initializeProdRoute(_prodTable, _oprNumOffset, _phantomBOM, _reqRoute, _phantomProdRoute, _phantomUnitFactor);
        prodRoute.insertWithoutJobCreation();
        
        return prodRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProdRouteProj</Name>
				<Source><![CDATA[
    private void updateProdRouteProj(ProdTable _prodTable, ProdRoute _prodRoute)
    {
        ProdRouteProj prodRouteProj;

        if (_prodTable.isProjMethodConsumed())
        {
            this.insertProdRouteProjDependingOnCalcType(ItemCalcType::Setup, prodRouteProj, _prodRoute);
            this.insertProdRouteProjDependingOnCalcType(ItemCalcType::Process, prodRouteProj, _prodRoute);
            this.insertProdRouteProjDependingOnCalcType(ItemCalcType::Qty, prodRouteProj, _prodRoute);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProdRouteProjDependingOnCalcType</Name>
				<Source><![CDATA[
    private void insertProdRouteProjDependingOnCalcType(ItemCalcType _calcType, ProdRouteProj _prodRouteProj, ProdRoute _prodRoute)
    {
        _prodRouteProj.clear();
        _prodRouteProj.ProdId = _prodRoute.ProdId;
        _prodRouteProj.OprNum = _prodRoute.OprNum;
        _prodRouteProj.OprPriority = _prodRoute.OprPriority;
        _prodRouteProj.CalcType = _calcType;
        ProjJournalTransMapForm::construct(_prodRouteProj, _prodRoute).initProdRouteProj(_prodRouteProj.CalcType);
        _prodRouteProj.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdRouteShopFloorControl</Name>
				<Source><![CDATA[
    private void initializeProdRouteShopFloorControl(ProdRoute _prodRoute)
    {
        // Shop Floor Control begin
        if (isConfigurationkeyEnabled(configurationKeyNum(Jmgjob)))
        {
            if (_prodRoute.JobPayType == JmgJobPayTypeEnum::Empty)
            {
                _prodRoute.JobPayType    = JmgJobPayTypeEnum::Hours;
            }
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Route)
            {
                _prodRoute.JobIdSetup    = NumberSeq::newGetNum(JmgParameters::numRefIpcActivityId()).num();
                _prodRoute.JobIdProcess  = NumberSeq::newGetNum(JmgParameters::numRefIpcActivityId()).num();
            }
        }
        // Shop Floor Control end
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdRouteJob</Name>
				<Source><![CDATA[
    protected void createProdRouteJob(
        ReqTrans    _reqTrans,
        ProdTable   _prodTable,
        OprNum      _oprNumOffset)
    {
        ProdRouteJob        prodRouteJob;
        ReqRouteJob         reqRouteJob;

        RecordInsertList    recordInsertList;

        WrkCtrCapRes        wrkCtrCapRes;

        wrkCtrCapRes.skipDataMethods(true);

        while select reqRouteJob
            where reqRouteJob.PlanVersion == _reqTrans.PlanVersion
               && reqRouteJob.ReqPOId     == _reqTrans.RefId
        {
            prodRouteJob.clear();
            prodRouteJob.initFromProdTable(_prodTable);
            prodRouteJob.initFromReqRouteJob(reqRouteJob);
            prodRouteJob.OprNum += _oprNumOffset;

            if (!recordInsertList)
            {
                recordInsertList = new RecordInsertList(tableNum(ProdRouteJob),true);
            }

            prodRouteJob.insertUsingInsertList(recordInsertList);

            update_recordset wrkCtrCapRes
                setting PlanVersion             = 0,
                        RefType                 = WrkCtrCapRefType::Production,
                        RefId                   = _prodTable.ProdId,
                        OprNum                  = wrkCtrCapRes.OprNum +_oprNumOffset,
                        JobId                   = prodRouteJob.JobId
                where wrkCtrCapRes.PlanVersion  == _reqTrans.PlanVersion
                   && wrkCtrCapRes.RefType      == WrkCtrCapRefType::PlannedOrder
                   && wrkCtrCapRes.RefId        == _reqTrans.RefId
                   && wrkCtrCapRes.OprNum       == reqRouteJob.OprNum
                   && wrkCtrCapRes.JobId        == strFmt('%1',reqRouteJob.RecId);
        }
        if (recordInsertList)
        {
            recordInsertList.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new production order record from the given parameters.
    /// </summary>
    /// <param name = "_reqTrans">A net requirements record.</param>
    /// <param name = "_reqPO">A planned order record.</param>
    /// <param name = "_prodBOMParent">A production bill of materials record that is the parent.</param>
    /// <returns>An initialized production order record.</returns>
    protected ProdTable initializeProdTable(
        ReqTrans    _reqTrans,
        ReqPO       _reqPO,
        ProdBOM     _prodBOMParent)
    {
        ProdTable prodTable;

        prodTable.initValue();

        InventTable inventTable = InventTable::find(_reqTrans.ItemId);
        prodTable.initFromInventTable(inventTable, _reqPO.inventDim());
        prodTable.initFromReqPo(_reqPO);

        // Delivery date

        prodTable.ProdType = ProdType::Standard;

        if (_prodBOMParent.InventDimId)
        {
            // Set inventory dimensions from the issue (_prodBOMParent), which could be extended and different from the _reqPO
            prodTable.setInventDimId(_prodBOMParent.InventDimId);
        }

        prodTable.setInventStorageDim(InventDim::find(prodTable.InventDimId), inventTable);

        var prodType = _prodBOMParent.type().prodType();

        if (_prodBOMParent)
        {
            prodTable.InventRefType     = InventRefType::ProdLine;
            prodTable.InventRefId       = _prodBOMParent.ProdId;
            prodTable.InventRefTransId  = _prodBOMParent.InventTransId;
            prodTable.ProdType          = prodType;
        }

        if (inventTable.isFormulaAllowed())
        {
            if (ProdTableType::isInhouseProduction(prodType))
            {
                prodTable.ProdType      = ProdType::Process;
            }
            else
            {
                prodTable.ProdType      = prodType;
            }

            if (!_reqTrans.IsDerivedDirectly)
            {
                prodTable.PmfConsOrdId  = consOrdId;
            }
        }

        prodTable.ProdStatus            = ProdStatus::Scheduled;
        prodTable.SchedDate             = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        prodTable.LatestSchedDate       = _reqTrans.ReqDate;
        prodTable.LatestSchedTime       = _reqTrans.ReqTime;
        prodTable.LatestSchedDirection  = SchedDirection::Backward;

        prodTable.bomId     = _reqTrans.ItemBomId;
        prodTable.RouteId   = _reqTrans.ItemRouteId;

        if (! _reqPO.checkCreatedOrder(prodTable, prodTable.InventDimId))
        {
            throw error("@SYS18447");
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) &&
            _reqTrans.CovQty &&
            reqMarkUpdate != ReqMarkUpdate::No &&
            ProjParameters::find().ProjSetSubProdToConsumed &&
            this.settledReqTransCount(_reqPO) == 1) //No grouping of planned orders
        {
            ReqTrans            reqTrans;
            ProdTable           prodTableParent;
            ReqTransCov         reqTransCov;
            ReqTrans            reqTransSettled;
            InventTransOrigin   inventTransOrigin;
            ProdBOM             prodBOM;

            select firstonly RecId from reqTrans
                where reqTrans.RefType == _reqPO.RefType &&
                    reqTrans.RefId == _reqPO.RefId &&
                    reqTrans.PlanVersion == _reqPO.PlanVersion
                join RecId from reqTransCov
                    where reqTransCov.ReceiptRecId == reqTrans.RecId
                join RecId from reqTransSettled
                    where reqTransSettled.RecId == reqTransCov.IssueRecId &&
                        reqTransSettled.RefType == ReqRefType::ProdLine
                join RecId from inventTransOrigin
                    where inventTransOrigin.RecId == reqTransSettled.InventTransOrigin
                join RecId from prodBOM
                    where prodBOM.InventTransId == inventTransOrigin.InventTransId &&
                          prodBOM.QtyInventCalc == _reqPO.Qty//planned order not split
                join RecId, ProjId, ActivityNumber, ProjPostingType, DefaultDimension from prodTableParent
                    where prodTableParent.ProdId == reqTransSettled.RefId &&
                        prodTableParent.ProjId &&
                        prodTableParent.ProjPostingType == ProjProdPostingType::ConsumedMethod;

            if (ProjProjectFieldsInitializeOnProdOrderFlight::instance().isEnabled() &&
                !prodTableParent && _prodBOMParent.ProdId && 
                _prodBOMParent.prodTable().ProjPostingType == ProjProdPostingType::ConsumedMethod)
            {
                prodTableParent = ProdTable::find(_prodBOMParent.ProdId);
            }
            if (prodTableParent)
            {
                prodTable.ProjId = prodTableParent.ProjId;
                prodTable.ActivityNumber = prodTableParent.ActivityNumber;
                prodTable.ProjPostingType = prodTableParent.ProjPostingType;
                prodTable.DefaultDimension = prodTable.copyDimension(prodTableParent.DefaultDimension);
            }
        }

        int settledReqTransCountForReqPO = ReqTransPoMarkFirm::settledReqTransCountForReqPO(_reqPO);
        if (ProjProjectFieldsInitializeOnProdOrderFlight::instance().isEnabled() &&
            isConfigurationkeyEnabled(configurationKeyNum(Project)) &&
            _reqTrans.CovQty &&
            reqMarkUpdate != ReqMarkUpdate::No &&
            (settledReqTransCountForReqPO == 1 || // No grouping of planned orders
            (settledReqTransCountForReqPO > 1 &&
            settledReqTransCountForReqPO == ReqTransPoMarkFirm::salesLinesCountForReqPOWithEqualProject(_reqPO))))
        {
            SalesLine salesLine = ReqPo::findAnySalesLineForReqPO(_reqPO);
 
            if (salesLine.ProjId)
            {
                prodTable.ProjId = salesLine.ProjId;
                prodTable.ActivityNumber = salesLine.ActivityNumber;
                prodTable.ProjCategoryId = salesLine.ProjCategoryId;
                prodTable.ProjLinkedToOrder = NoYes::Yes;
                prodTable.DefaultDimension = prodTable.mergeDimension(salesLine.DefaultDimension);
                if (salesLine.salesTable().SalesType == SalesType::ItemReq)
                {
                    prodTable.ProjPostingType = ProjParameters::prodPostingType();
                }
                else
                {
                    prodTable.ProjPostingType = ProjProdPostingType::FinishedItemMethod;
                }
            }
        }
        
        return prodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdTable</Name>
				<Source><![CDATA[
    protected ProdTable createProdTable(
        ReqTrans    _reqTrans,
        ReqPO       _reqPO,
        ProdBOM     _prodBOMParent   = null)
    {
        if (!phantomRouteExpanded)
        {
            phantomRouteExpanded = new Set(Types::String);
        }

        this.createBOMRoute(_reqTrans, _reqPO);

        // Create prodTable

        InventTable inventTable = InventTable::find(_reqTrans.ItemId);
        if (!inventTable.RecId)
        {
            throw error(strFmt(InventTable::txtNotExist(), _reqTrans.ItemId));
        }

        if (!inventTable.inventItemType().canBeProduced())
        {
            throw error(strFmt("@SYS78161", inventTable.ItemType));
        }

        InventItemInventSetup inventItemInventSetup   = InventItemInventSetup::find(_reqTrans.ItemId, _reqTrans.inventDim().InventDimId);
        if (!inventItemInventSetup.RecId)
        {
            throw error(strFmt("@SYS5700", _reqTrans.ItemId, InventItemOrderSetupType::Invent));
        }

        if (inventItemInventSetup.isStopped())
        {
            throw error(strFmt("@SYS13295", _reqTrans.ItemId, InventItemOrderSetupType::Invent));
        }

        if (!_reqPO.SchedFromDate || !_reqPO.SchedToDate)
        {
            throw error("@SYS309802");
        }

        ProdTable prodTable = this.initializeProdTable(_reqTrans, _reqPO, _prodBOMParent);

        this.insertMovement(prodTable);

        if (prodTable.isProjMethodConsumed() && !prodTable.validateWrite())
        {
            throw error("@SYS21628");
        }

        if (#PmfEnabled)
        {
            if (inventTable.isFormulaAllowed())
            {
                BOMVersion bomVersion  = this.findApprovedBOMVersion(prodTable, _reqPO);

                prodTable.PmfYieldPct = bomVersion.PmfYieldPct;

                if (prodTable.inventTable().PmfProductType == PmfProductType::MainItem)
                {
                    prodTable.RemainInventPhysical      = 0;
                    prodTable.PdsCWRemainInventPhysical = 0;
                }

                prodTable.initBOMVersion();
            }

            if (ReqPoFirmSetYeildFromPlannedOrderFlight::instance().isEnabled() && _ReqPO.RefType == ReqRefType::PmfPlannedProdBatch)
            {
                prodTable.PmfYieldPct = _reqPO.PmfYieldPct;
            }

            prodTable.doUpdate();
        }

        // create firm log

        this.createReqTransFirmLog(_reqTrans, InventTransType::Production, prodTable.ProdId, prodTable.InventTransId);

        // Create prodBOM, ProdRoute, ProdRouteJob and wrkCtrCapRes

        this.expandBOMRoute(_reqTrans, prodTable, 0, 0, null, null);

        _reqTrans.reread();
        _reqPO.reread();
        prodTable.reread();

        if (   !prodTable.RouteJobs
            && ReqPlanData::newReqPlanVersion(_reqPO.PlanVersion).covSchedMethod() == ProdSchedMethod::JobScheduling)
        {
            if (ProdRouteJob::exists(prodTable.ProdId))
            {
                prodTable.SchedStatus    = ProdSchedStatus::JobScheduled;
                prodTable.RouteJobs      = NoYes::Yes;
                prodTable.doUpdate();
            }
        }

        // Renumber production route
        if (phantomRouteExpanded.in(prodTable.ProdId))
        {
            ProdRoute::updateReNumberOprNum(prodTable.ProdId);
        }

        // Auto update status

        prodTable.autoUpdate(ReqGroup::find(ReqGroup::defaultId(_reqPO.ItemId, _reqPO.CovInventDimId)).AutoProdStatus);

        // Update reqTrans as production
        RefRecId extraPlanVersion;

        if (_reqTrans.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            if (ReqParameters::find().autoUpdateDynamicPlan(ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId))
            {
                // Also adjust the references in the dynamic plan
                extraPlanVersion = ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;
            }
            else
            {
                // Only adjust records in the current plan
                extraPlanVersion = _reqTrans.PlanVersion;
            }

            ReqTrans        coByReqTrans;
            PmfProdCoBy     coBy;
            InventDim       inventDim;
            InventDimParm   inventDimParm;
            
            inventDimParm.setAllProductDimensions();

            while select forupdate coByReqTrans
                where (coByReqTrans.PlanVersion == _reqTrans.PlanVersion
                       || coByReqTrans.PlanVersion == extraPlanVersion)
                    && coByReqTrans.RefId       == _reqTrans.RefId
                    && coByReqTrans.RefType     == ReqRefType::PmfCoProduct
            {
                // The case when the formula contains 2 co-product lines with the same item 
                // number and the same set of product dimensions is not currently supported.

                InventDim inventDimCriteria = InventDim::find(coByReqTrans.CovInventDimId);

                select forceselectorder forcenestedloop firstonly InventTransId
                    from coBy
                    where coBy.ProdId  == prodTable.ProdId
                       && coBy.ItemId  == coByReqTrans.ItemId
                       #inventDimExistsJoin(coBy.InventDimId, inventDim, inventDimCriteria, inventDimParm);

                this.pmfCoUpdateFirmedReqTrans(coByReqTrans, coBy.InventTransId, prodTable.ProdId);

                if (!coBy.InventRefTransId)
                {
                    this.updateInventReference(coByReqTrans);
                }
            }
        }

        this.updateFirmedReqTrans(_reqTrans, _reqPO, ReqRefType::Production, prodTable.ProdId, InventTransOriginProdTable::findInventTransOriginId(prodTable.DataAreaId, prodTable.ProdId));
        ReqRequisitionsHelper::updateRequisitionLinesFromFirmedReqTrans(_reqTrans);

        // Auto reserve settled issues
        if (! prodTable.InventRefTransId)
        {
            this.updateInventReference(_reqTrans);
        }

        // Run price calculation
        prodTable.reread();
        if (prodTable.prodParametersDim().SpecifyCalc && (prodTable.CollectRefLevel == 0 || prodTable.isItemBOMLineType()))
        {
            ProdUpdBOMCalc::newProdTable(prodTable, prodParameters.ProfitSet, prodTable.DlvDate).run();
            
            if (prodTable.ProjId)
            {
                if (!ProjProjectFieldsInitializeOnProdOrderFlight::instance().isEnabled() && 
                    ProjProjectFieldsUpdateOnProdBOMFlight::instance().isEnabled())
                {
                    this.updateProjectParamInProdBom(prodTable.ProdId);
                }  

                ProdUpdCostEstimation prodUpdCostEstimation = new ProdUpdCostEstimation();
                prodUpdCostEstimation.projCostControlUpdate(prodTable);
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(prodTable.InventRefTransId);
            
            InventTrans inventTrans = InventTrans::findByInventTransOrigin(inventTransOrigin.RecId);

            if (inventTrans.ProjId)
            {
                ProjTable projTable = ProjTable::find(inventTrans.ProjId);
                prodTable.ProjId = projTable.ProjId;
                prodTable.DefaultDimension = prodTable.mergeDimension(projTable.DefaultDimension);
                prodTable.doUpdate();

                if (prodTable.ReqPOId)
                {
                    this.updateBomRouteDimension(prodTable.ProdId, projTable.DefaultDimension);
                }

            }
        }
        return prodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findApprovedBOMVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an approved BOM version record.
    /// </summary>
    /// <param name = "_prodTable">The production order record with header information.</param>
    /// <param name = "_reqPO">The planned order record for purchase, production or transfer.</param>
    /// <returns>A BOM version record.</returns>
    protected BOMVersion findApprovedBOMVersion(ProdTable _prodTable, ReqPO _reqPO)
    {
        return BOMVersion::selectBomVersionWithPriority(_prodTable.ItemId, 
                                                            _prodTable.BOMDate, 
                                                            _prodTable.QtySched, 
                                                            _prodTable.inventDim(), 
                                                            true, 
                                                            true, 
                                                            true, 
                                                            false, 
                                                            true, 
                                                            _prodTable.BOMId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesLineForPurchTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a sales line corresponding to the given planned order if Project configuration key is on and marking is used.
    /// </summary>
    /// <param name = "_reqTrans">A <c>ReqTrans</c> record connected to the the planned order</param>
    /// <param name = "_reqPO">A planned order.</param>
    /// <param name = "_reqMarkUpdate">Parameter indicating what marking is used.</param>
    /// <param name = "_reqTransPoMarkFirm"> Instance of <c>ReqTransPoMarkFirm</c> class.</param>
    /// <returns>The <c>SalesLine</c> record corresponding to the given planned order.</returns>
    internal static SalesLine findSalesLineForPurchTrans(
        ReqTrans            _reqTrans,
        ReqPO               _reqPO,
        ReqMarkUpdate       _reqMarkUpdate,
        ReqTransPoMarkFirm  _reqTransPoMarkFirm)
    {
        SalesLine salesLine;
        
        if (_reqTransPoMarkFirm.mustDerivePurchProjectIdFromSalesProjectId(_reqTrans, _reqPO, _reqMarkUpdate))
        {
            salesLine = ReqPo::findAnySalesLineForReqPO(_reqPO);
        }

        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDerivePurchProjectIdFromSalesProjectId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether project configuration key is on and marking is used corresponding to the given planned order.
    /// </summary>
    /// <param name = "_reqTrans">A <c>ReqTrans</c> record connected to the the planned order</param>
    /// <param name = "_reqPO">A planned order.</param>
    /// <param name = "_reqMarkUpdate">Parameter indicating what marking is used.</param>
    /// <returns>
    /// true if project configuration key is on and marking is used corresponding to the given planned order; otherwise, false
    /// </returns>
    /// <remarks>
    /// This method is extracted as an extensibility point and the customization code may need to rely on the current instance of the <c>ReqTransPoMarkFirm</c> class
    /// </remarks>
    protected boolean mustDerivePurchProjectIdFromSalesProjectId(ReqTrans            _reqTrans,
                                                                ReqPO               _reqPO,
                                                                ReqMarkUpdate       _reqMarkUpdate)
    {
        int settledReqTransCountForReqPO = ReqTransPoMarkFirm::settledReqTransCountForReqPO(_reqPO);
  
        return(isConfigurationkeyEnabled(configurationKeyNum(Project))
                && _reqTrans.CovQty
                && _reqMarkUpdate != ReqMarkUpdate::No
                && (settledReqTransCountForReqPO == 1 // No grouping of planned orders
                    || (settledReqTransCountForReqPO > 1
                        && settledReqTransCountForReqPO == ReqTransPoMarkFirm::salesLinesCountForReqPOWithEqualProject(_reqPO))));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>PurchLine</c> record.
    /// </summary>
    /// <param name = "_reqTrans">The <c>ReqTrans</c> record.</param>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <param name = "_prodBOMParent">The parent <c>ProdBOM</c> record.</param>
    /// <returns>The created <c>PurchLine</c> record.</returns>
    protected PurchLine createPurchLine(
            ReqTrans    _reqTrans,
            ReqPO       _reqPO,
            ProdBOM     _prodBOMParent   = null)
    {
        SalesLine salesLine = ReqTransPoMarkFirm::findSalesLineForPurchTrans(_reqTrans, _reqPO, reqMarkUpdate, this);
        Purchline purchLine;
        purchLine.ProjId = salesLine.ProjId;

        if (purchLine.ProjId)
        {
            purchLine.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(salesLine.DefaultDimension, purchLine.DefaultDimension);
        }

        List warningReportList;
        AgreementLine localAgreementLine;
        PurchAgreementId agreementId;

        if (searchPurchAgreement)
        {
            warningReportList  = new List(Types::String);
            localAgreementLine = ReqPo::findAgreementLineForAutoMatchFromReqPO(_reqPO, true, warningReportList, purchLine.ProjId);
            agreementId        = localAgreementLine ? localAgreementLine.getPurchAgreementId() : '';
        }

        PurchId purchId = this.createPurchTable(_reqTrans, _reqPO, agreementId, salesLine.ProjId, salesLine.SalesId);
        this.throwIfMissingPurchId(purchId);
        
        PurchTable purchTable = PurchTable::find(purchId, true);
        InventTable inventTable = InventTable::find(_reqTrans.ItemId);
        using (var activityContext = instrumentationLogger.purchOrderLineCreationActivities().createPurchLineFromPlannedOrder())
        {
            this.initPurchLine(_reqPo, _reqTrans, _prodBOMParent, purchId, purchLine, salesLine, inventTable, purchTable);

            if (isPartOfMultithreadedRun && !_reqPO.PurchId) // Planned orders with PurchId specified are bundled together so the standard line numbering logic can be safely used.
            {
                purchLine.LineNumber = ReqTransPoMarkFirmPurchaseLineNumberSequence::getNextNumber(purchLine.PurchId, firmingRunId);
            }

            this.insertMovement(purchLine);
        }
        // the insert movement movement, can update the purchTable buffer, so we have to re-read to avoid update conflicts
        purchTable.reread();
        
        // If run as a part of a bigger run post processing will be done in a separate step
        if (!isPartOfBiggerRun)
        {
            this.updatePurchTableDeliveryDate(purchTable, purchLine);
        }

        // Need to report warning here because no agreement line was found due to maximum limits exceeded by the order
        this.showAgreementLineWarningsIfExists(warningReportList, localAgreementLine, purchTable, purchLine);

        // Create firm log
        this.createReqTransFirmLog(_reqTrans, InventTransType::Purch, purchLine.PurchId, purchLine.InventTransId);

        var groupingKey = this.purchaseOrderGroupingKey(_reqTrans, _reqPO, agreementId, salesLine.ProjId, salesLine.SalesId);
        processedOrdersData.addPurchaseOrder(purchId, groupingKey);

        this.syncDeliveryDateToPlannedOrder(_reqPO, _reqTrans, purchLine);

        // Auto approval is performed later in the firming process => defer marking until inventory transaction is estimated
        // For directly derived req, marking is set top -> down => marking is set when subcontracted purchase is approved
        if (!purchTable.ChangeRequestRequired || _reqTrans.IsDerivedDirectly)
        {
            this.updatePurchLine(_reqTrans, _reqPO, purchLine, salesLine);
        }

        this.initPurchLineFromAgreementLine(localAgreementLine, purchLine);

        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchTableFromSite</Name>
				<Source><![CDATA[
    private void updatePurchTableFromSite(PurchTable _purchTable)
    {
        InventSiteId siteId = _purchTable.InventSiteId;
        if (siteId)
        {
            _purchTable.modifiedInventSiteFromParent();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoCreateForICSO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Automatically creates the intercompany chain for the newly created from the firm purchase order intercompany sales order
    /// if the sales order is set for InterCompanyAutoCreateOrders = true.
    /// </summary>
    private void autoCreateForICSO()
    {
        Set purchIdsToAutoApprove = processedOrdersData.getPurchaseOrdersToAutoApprove();
        SetEnumerator purchIdsEnum = purchIdsToAutoApprove.getEnumerator();

        while (purchIdsEnum.moveNext())
        {
            PurchId purchId = purchIdsEnum.current();
            PurchTable purchTable = PurchTable::find(purchId);

            if (purchTable.InterCompanyOrder
                && purchTable.InterCompanyCompanyId
                && TradeInterCompany::checkDataAreaAccess(purchTable.InterCompanyCompanyId, false))
            {
                changecompany(purchTable.InterCompanyCompanyId)
                {
                    new SalesTableForm(purchTable.interCompanySalesTable()).interCompanyAutoCreateOrders();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseOrderGroupingKey</Name>
				<Source><![CDATA[
    private ReqPlannedOrderGroupingKey purchaseOrderGroupingKey(
        ReqTrans    _reqTrans,
        ReqPO       _reqPO,
        PurchAgreementId _agreementId,
        ProjId  _projId = '',
        SalesId _salesId = '')
    {
        PurchId purchId = callerPurchId ? callerPurchId : (_reqPO.PurchId ? _reqPO.PurchId : '');

        if (purchId)
        {
            return '#PurchId:' + purchId;
        }
        
        this.createProdPurch(_reqTrans);

        return prodPurch.reqTransPurchIdKey(_reqTrans, _reqPO, _agreementId, _projId, _salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwIfInvalidOrderCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws error if the order created is not consistent with the planned order.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record being created.</param>
    /// <param name = "_inventTable">The related <c>InventTable</c> record.</param>
    protected void throwIfInvalidOrderCreated(ReqPO _reqPO, PurchLine _purchLine, InventTable _inventTable)
    {
        if (!_reqPO.checkCreatedOrder(_purchLine, _purchLine.InventDimId, InventDimGroupSetup::newInventTable(_inventTable)))
        {
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwIfInvalidPurchLineCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws error if the <c>PurchLine</c> record has invalid field values.
    /// </summary>
    /// <param name = "_purchId">The related <c>PurchId</c> value.</param>
    /// <param name = "_itemId">The related <c>ItemId</c> value.</param>
    /// <param name = "_purcheTable">The related <c>PurchTable</c> record.</param>
    /// <param name = "_inventTable">The related <c>InventTable</c> record.</param>
    /// <param name = "_inventItemInventSetup">An <c>InventItemInventSetup</c> instance.</param>
    /// <param name = "_inventItemPurchSetup">An <c>InventItemPurchSetup</c> instance.</param>
    protected void throwIfInvalidPurchLineCreated(PurchId _purchId, ItemId _itemId, PurchTable _purcheTable, InventTable _inventTable, InventItemInventSetup _inventItemInventSetup = null, InventItemPurchSetup _inventItemPurchSetup = null)
    {
        boolean checkItemOrderSetup = (_inventItemInventSetup != null && _inventItemPurchSetup != null);

        if (!ProdPurch::checkCreatePurchLine(_purchId,
                                            _itemId,
                                            _purcheTable,
                                            _inventTable,
                                            _inventItemInventSetup,
                                            _inventItemPurchSetup,
                                            checkItemOrderSetup))
        {
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwIfMissingPurchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws error if the <c>PurchId</c> is missing a value.
    /// </summary>
    /// <param name = "_purchId">The <c>PurchId</c> value.</param>
    protected void throwIfMissingPurchId(PurchId _purchId)
    {
        if (!_purchId)
        {
            throw error("@SYS70020");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settledReqTransCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the count of the settled <c>ReqTrans</c> records.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <returns>The count of the settled <c>ReqTrans</c> records.</returns>
    protected int settledReqTransCount(ReqPO _reqPO)
    {
        return ReqTransPoMarkFirm::settledReqTransCountForReqPO(_reqPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settledReqTransCountForReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the count of the settled <c>ReqTrans</c> records.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <returns>The count of the settled <c>ReqTrans</c> records.</returns>
    internal static int settledReqTransCountForReqPO(ReqPO _reqPO)
    {
        ReqTrans    reqTransSettled;
        ReqTransCov reqTransCov;
        ReqTrans    reqTrans;
        
        select count(RecId) from reqTransSettled
            exists join reqTransCov
                where reqTransCov.IssueRecId == reqTransSettled.RecId
            exists join reqTrans
                where reqTrans.RecId == reqTransCov.ReceiptRecId
                    && reqTrans.RefType == _reqPO.RefType
                    && reqTrans.RefId == _reqPO.RefId
                    && reqTrans.PlanVersion == _reqPO.PlanVersion;

        return reqTransSettled.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLinesCountForReqPOWithEqualProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the count of the settled sales <c>ReqTrans</c> records grouped by the project.
    /// </summary>
    /// <param name = "_reqPo">The <c>ReqPO</c> planned order record.</param>
    /// <returns>The count of the settled <c>ReqTrans</c> records.</returns>
    internal static int salesLinesCountForReqPOWithEqualProject(ReqPO _reqPo)
    {
        InventTransOrigin inventTransOrigin;
        ReqTrans    reqTransSettled;
        ReqTransCov reqTransCov;
        ReqTrans    reqTrans;
        SalesLine   salesLine;

        select count(RecId) from reqTransSettled
            group by salesLine.ProjId
            join TableId from reqTransCov
                where reqTransCov.IssueRecId == reqTransSettled.RecId
                    && reqTransSettled.RefType == ReqRefType::Sales
            join TableId from reqTrans
                where reqTrans.RecId == reqTransCov.ReceiptRecId
                    && reqTrans.RefType == _reqPO.RefType
                    && reqTrans.RefId == _reqPO.RefId
                    && reqTrans.PlanVersion == _reqPO.PlanVersion
            join TableId from inventTransOrigin
                where inventTransOrigin.RecId == reqTransSettled.InventTransOrigin
            join ProjId from salesLine
                where salesLine.InventTransId == inventTransOrigin.InventTransId
                    && salesLine.ProjId;
        
        return reqTransSettled.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesLineForReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>SalesLine</c> related to the <c>ReqPO</c> with settled <c>ReqTrans</c>
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <returns>The found <c>SalesLine</c> record.</returns>
    protected SalesLine findSalesLineForReqPO(ReqPO _reqPO)
    {
        return ReqPo::findAnySalesLineForReqPO(_reqPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showAgreementLineWarningsIfExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows warnings from the warning report <c>List</c> instance, if warnings exist and no <c>AgreementLine</c> was found.
    /// </summary>
    /// <param name = "_warningReportList">A <c>List</c> instance containing warnings.</param>
    /// <param name = "_agreementLine">The related <c>AgreementLine</c> record to initialize from.</param>
    /// <param name = "_purchTable">The related <c>PurchTable</c> record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to initialize.</param>
    protected void showAgreementLineWarningsIfExists(List _warningReportList, AgreementLine _agreementLine, PurchTable _purchTable, PurchLine _purchLine)
    {
        if (_warningReportList && !_warningReportList.empty() && !_agreementLine.RecId)
        {
            ListEnumerator warningReportListEnumerator = _warningReportList.getEnumerator();

            while (warningReportListEnumerator.moveNext())
            {
                warning(strFmt("@SCM:PurchLineCreatedNotLinkedToAgreement", _purchTable.PurchId, _purchLine.LineNumber, warningReportListEnumerator.current()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchLineFromAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchLine</c> record based on the provided <c>AgreementLine</c>. If this initialization fails, reverts to original values.
    /// </summary>
    /// <param name = "_agreementLine">The related <c>AgreementLine</c> record to initialize from.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to initialize.</param>
    protected void initPurchLineFromAgreementLine(AgreementLine _agreementLine, PurchLine _purchLine)
    {
        if (searchPurchAgreement
            && _agreementLine
            && _purchLine.RecId)
        {
            PurchLine purchLineBackup;
            purchLineBackup.data(_purchLine);

            ttsbegin;
            _purchLine.data(PurchLine::findRecId(_purchLine.RecId, true));
            _purchLine.initFromAgreementLine(_agreementLine);

            if (_purchLine.isAgreementLinkValid(false))
            {
                _purchLine.update();
            }
            else
            {
                _purchLine.data(purchLineBackup);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDeliveryDateToPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Syncs the <c>ReqPo</c> record with the provided <c>PurchLine</c> record.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record to synch.</param>
    /// <param name = "_reqTrans">The <c>ReqTrans</c> record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to synch with.</param>
    protected void syncDeliveryDateToPlannedOrder(ReqPo _reqPO, ReqTrans _reqTrans, PurchLine _purchLine)
    {
        if (_reqPO.ReqDateDlv != _purchLine.DeliveryDate)
        {
            _reqPO.ReqDateDlv = _purchLine.DeliveryDate;
            _reqPO.update();

            // Clear the action data as it is invalid after date change
            _reqTrans.reread();
            _reqTrans.ActionDays = 0;
            _reqTrans.setAction();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchLine</c> record and inserts the movements to the necessary tables.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <param name = "_reqTrans">The <c>ReqTrans</c> record.</param>
    /// <param name = "_prodBOMParent">The parent <c>ProdBOM</c> record.</param>
    /// <param name = "_purchId">The related <c>PurchId</c> value.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to be initialized.</param>
    /// <param name = "_salesLine">The related <c>SalesLine</c> record.</param>
    /// <param name = "_inventTable">The related <c>InventTable</c> record.</param>
    /// <param name = "_purchTable">The related <c>PurchTable</c> record.</param>
    protected void initPurchLine(ReqPo _reqPO,
                                 ReqTrans _reqTrans,
                                 ProdBOM _prodBOMParent,
                                 PurchId _purchId,
                                 PurchLine _purchLine,
                                 SalesLine _salesLine,
                                 InventTable _inventTable,
                                 PurchTable _purchTable)
    {
        this.throwIfInvalidPurchLineCreated(_purchId, _reqTrans.ItemId, _purchTable, _inventTable);

        this.initPurchLineFromPurchInventReqPO(_reqPO, _purchLine, _inventTable, _purchTable);

        _purchLine.ActivityNumber = _salesLine.ActivityNumber;
        _purchLine.ProjCategoryId = _salesLine.ProjCategoryId ? _salesLine.ProjCategoryId : _purchLine.ProjCategoryId;
        _purchLine.ProjLinePropertyId = _salesLine.ProjLinePropertyId ? _salesLine.ProjLinePropertyId : _purchLine.ProjLinePropertyId;

        this.setInventDim(_prodBOMParent, _purchLine, _inventTable, _purchTable);

        InventDim inventDim = _purchLine.inventDim();

        this.throwIfInvalidPurchLineCreated(_purchId, _reqTrans.ItemId, _purchTable, _inventTable, InventItemInventSetup::find(_purchLine.ItemId, _purchLine.InventDimId), InventItemPurchSetup::find(_purchLine.ItemId,  _purchLine.InventDimId));

        this.updatePurchLineBasedOnServiceCategory(_reqTrans, _purchTable, _purchLine, inventDim);

        if (_prodBOMParent)
        {
            this.initializePurchLineFromProdBOM(_purchLine, _prodBOMParent);
        }
        else if (_salesLine)
        {
            this.initializePurchLineFromSalesLine(_purchLine, _salesLine);
        }

        _purchLine.initFromVendTable(_purchLine.vendTable_OrderAccount());

        this.setDeliveryDateAndPriceDisc(_reqPO, _purchLine, inventDim);

        this.throwIfInvalidOrderCreated(_reqPO, _purchLine, _inventTable);

        _purchLine.initVariantId(inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchTableDeliveryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>PurchTable</c> record's delivery date based on the <c>PurchLine</c> record's delivery date.
    /// </summary>
    /// <param name = "_purchTable">The <c>PurchTable</c> record to be updated.</param>
    /// <param name = "_purchLine">The related <c>PurchLine</c> record.</param>
    protected void updatePurchTableDeliveryDate(PurchTable _purchTable, PurchLine _purchLine)
    {
        if (_purchTable.DeliveryDate > _purchLine.DeliveryDate)
        {
            _purchTable.DeliveryDate = _purchLine.DeliveryDate;
            _purchTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchLineFromPurchInventReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the purch line from the related <c>PurchTable</c>, <c>InventTable</c>, and <c>ReqPo</c> records.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to be initialized.</param>
    /// <param name = "_inventTable">The related <c>InventTable</c> record.</param>
    /// <param name = "_purchTable">The related <c>PurchTable</c> record.</param>
    protected void initPurchLineFromPurchInventReqPO(ReqPo _reqPO, PurchLine _purchLine, InventTable _inventTable, PurchTable _purchTable)
    {
        _purchLine.PurchaseType = _purchTable.PurchaseType;

        PurchLineType purchLineType = _purchLine.type(_purchTable);

        purchLineType.initValue();
        
        purchLineType.initFromPurchTable(_purchTable);

        const boolean searchPrice = false;
        const boolean setAddressFromInventDim = false;
        const boolean initDateFields = false;
        purchLineType.initFromInventTable(_inventTable, searchPrice, setAddressFromInventDim, initDateFields);

        _purchLine.initFromReqPO(_reqPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the related <c>InventDim</c> record for the <c>PurchLine</c> record based on the <c>ProdBOM</c> parent record.
    /// Additionally, sets the storage fields for the <c>InventDim</c> record related to the <c>PurchLine</c> record.
    /// </summary>
    /// <param name = "_prodBOMParent">The parent <c>ProdBOM</c> record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to be set.</param>
    /// <param name = "_inventTable">The related <c>InventTable</c> record.</param>
    /// <param name = "_purchTable">The related <c>PurchTable</c> record.</param>
    protected void setInventDim(ProdBOM _prodBOMParent, PurchLine _purchLine, InventTable _inventTable, PurchTable _purchTable)
    {
        if (_prodBOMParent.InventDimId)
        {
            // Set inventory dimensions from the issue (_prodBOMParent), which could be extended and different from the _reqPO
            _purchLine.setInventDimId(_prodBOMParent.InventDimId);
        }

        ProdPurch::setInventStorageDim(_purchLine,
                                       _purchLine.inventDim(),
                                       _inventTable,
                                       InventItemOrderSetupType::Purch,
                                       _purchTable.InventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchLineBasedOnServiceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>PurchLine</c> record if Retail is enabled and there exists a <c>ServiceCategory</c> relation on the <c>PurchTable</c>.
    /// </summary>
    /// <param name = "_reqTrans">The <c>ReqTrans</c> record.</param>
    /// <param name = "_purchTable">The related <c>PurchTable</c> record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> to be updated.</param>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    protected void updatePurchLineBasedOnServiceCategory(ReqTrans _reqTrans, PurchTable _purchTable, PurchLine _purchLine, InventDim _inventDim)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Retail))
            && _purchTable.ServiceCategory)
        {
            RetailServiceCategory tServiceCategory = RetailServiceCategory::find(_purchTable.ServiceCategory);
            if (tServiceCategory.CrossDockingWarehouse)
            {
                InventLocationId inventLocationId = InventDim::find(_reqTrans.CovInventDimId).InventLocationId;

                // No xdocking if XdocWarehouse is the same as the original
                // Set address of location as delivery address in purch
                if (tServiceCategory.CrossDockingWarehouse != inventLocationId)
                {
                    _inventDim.InventLocationId = tServiceCategory.CrossDockingWarehouse;
                    _inventDim.InventDimId = InventDim::findOrCreate(_inventDim).InventDimId;

                    _purchLine.InventDimId = _inventDim.InventDimId;

                    // If run as a part of a bigger run post processing will be done in a separate step
                    if (isPartOfBiggerRun)
                    {
                        processedOrdersData.markPurchaseOrderForUpdatingAddressFromInventLocationId(_purchTable.PurchId, tServiceCategory.CrossDockingWarehouse);
                        processedOrdersData.markPurchaseOrderForSettingReplenishmentLocation(_purchTable.PurchId, inventLocationId);
                        processedOrdersData.markPurchaseOrderForCrossDocking(_purchTable.PurchId);
                    }
                    else
                    {
                        _purchTable.setAddressFromInventLocationId(tServiceCategory.CrossDockingWarehouse);
                        _purchTable.update();

                        // Set location from planned purch order
                        _purchTable.ReplenishmentLocation = inventLocationId;
                        _purchTable.update();
                        m_oPurchToCrossDock.ins(_purchTable);
                    }
                }
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeliveryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the DeliveryDate for a <c>PurchLine</c> record.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to be set.</param>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    protected void setDeliveryDate(ReqPO _reqPO, PurchLine _purchLine, InventDim _inventDim)
    {
        _purchLine.DeliveryDate = _reqPO.ReqDateDlv;

        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            _purchLine.calculateRequestedShipAndReceiptDate(dateNull(), _purchLine.DeliveryDate, SchedDirection::Backward);
            _purchLine.SkipShipReceiptDateCalculation = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeliveryDateAndPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the DeliveryDate and PriceDisc for a <c>PurchLine</c> record.
    /// </summary>
    /// <param name = "_reqPO">The <c>ReqPO</c> planned order record.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record to be set.</param>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    protected void setDeliveryDateAndPriceDisc(ReqPO _reqPO, PurchLine _purchLine, InventDim _inventDim)
    {
        this.setDeliveryDate(_reqPO, _purchLine, _inventDim);
        _purchLine.setPriceDisc(_inventDim, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdPurch</Name>
				<Source><![CDATA[
    protected void createProdPurch(ReqTrans _reqTrans)
    {
        if (!prodPurch)
        {
            prodPurch = ProdPurch::newReq(collectPerVendor, collectPerBuyer, collectPerPeriodPurch, collectPerPurchAgreement);
        }

        boolean isPlanningPriorityFeatureEnabled = 
            ReqPriorityBasedPlanningFeature::instance().isEnabled();

        if (_reqTrans.IsDerivedDirectly)
        {
            prodPurch.parmCollectPerVendor(prodParameters.ProdAutoPurchCollectPerVendor);
            prodPurch.parmCollectPerBuyer(prodParameters.ProdAutoPurchCollectPerBuyer);
            prodPurch.parmCollectPerPurchAgreement(prodParameters.ProdAutoPurchCollectPerPurchAgreement);
            prodPurch.parmCollectPerPeriodPurch(ReqPoCollectPerPeriod::No);
            prodPurch.parmSearchPurchAgreement(prodParameters.ProdAutoPurchSearchPurchAgreement);
        }
        else
        {
            prodPurch.parmCollectPerVendor(collectPerVendor);
            prodPurch.parmCollectPerBuyer(collectPerBuyer);
            prodPurch.parmCollectPerPeriodPurch(collectPerPeriodPurch);
            prodPurch.parmCollectPerPurchAgreement(collectPerPurchAgreement);

            if (isPlanningPriorityFeatureEnabled)
            {
                prodPurch.parmCollectPerPlanningPriority(collectPerPlanningPriority);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchTable</Name>
				<Source><![CDATA[
    protected PurchId createPurchTable(
        ReqTrans            _reqTrans,
        ReqPO               _reqPO,
        PurchAgreementId    _agreementId,
        ProjId              _projId = '',
        SalesId             _salesId = '')
    {
        this.createProdPurch(_reqTrans);
        
        if (callerPurchId)
        {
            if (!PurchTable::find(callerPurchId).canAutoUpdatePurchOrder())
            {
                throw error(strFmt("@SYS300246", callerPurchId));
            }
            return callerPurchId;
        }

        if (_reqPO.PurchId)
        {
            if (!PurchTable::find(_reqPO.PurchId).canAutoUpdatePurchOrder())
            {
                throw error(strFmt("@SYS300246", _reqPO.PurchId));
            }

            this.insertGroupFirmingParametersWhenPurchIdSpecified(this.purchaseOrderGroupingKey(_reqTrans, _reqPO, _agreementId, _projId, _salesId), _reqPO.PurchId);

            return _reqPO.PurchId;
        }

        if (! _reqPO.VendId)
        {
            throw error("@SYS23532");
        }

        var groupingKey = this.purchaseOrderGroupingKey(_reqTrans, _reqPO, _agreementId, _projId, _salesId);
    
        if (this.mustGetPurchaseOrderWithGroupingKey(_reqPO, groupingKey))
        {
            // The retrieved purchId has been checked by the \Data Dictionary\Tables\PurchTable\Methods\canAutoUpdatePurchOrder method
            // when created in the first place.
            return processedOrdersData.getPurchaseOrderWithGroupingKey(groupingKey);
        }
        
        PurchId purchId;

        if (isPartOfBiggerRun)
        {
            purchId = this.getPurchIdMultiThread(groupingKey, _reqPO, _agreementId, _projId, _salesId);
        }
        else
        {
            purchId = this.getPurchIdSingleThread(_reqPO, _agreementId, _projId, _salesId);
        }

        this.processPurchaseOrder(purchId, _reqTrans);

        return purchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGetPurchaseOrderWithGroupingKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the purchase orders must be retrieved based on the grouping key.
    /// </summary>
    /// <param name = "_reqPO">
    ///     The planned order record.
    /// </param>
    /// <param name = "_groupingKey">
    ///     The grouping key based on which the purchase orders must be retrieved.
    /// </param>
    /// <returns>
    ///     true if the purchase orders must be retrieved based on the grouping key; otherwise, false.
    /// </returns>
    protected boolean mustGetPurchaseOrderWithGroupingKey(ReqPO _reqPO, ReqPlannedOrderGroupingKey _groupingKey)
    {
        return processedOrdersData.checkForPurchaseOrderWithGroupingKey(_groupingKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the purchase order.
    /// </summary>
    /// <param name = "_purchId">Purchase order it.</param>
    /// <param name = "_reqTrans">The <c>ReqTrans</c> record.</param>
    protected void processPurchaseOrder(PurchId _purchId, ReqTrans _reqTrans)
    {
        // If purchase order is derived (subcontract purchase order) only submit to workflow
        if (_reqTrans.IsDerivedDirectly)
        {
            processedOrdersData.markPurchaseOrderForSubmittingToWorflow(_purchId);
        }
        else
        {
            // If purchase order is a firmed Planned purchase order do auto-approve to ensure planning engine doesn't create new planned orders while PO is in Draft
            processedOrdersData.markPurchaseOrderForAutoApproval(_purchId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertGroupFirmingParametersWhenPurchIdSpecified</Name>
				<Source><![CDATA[
    private void insertGroupFirmingParametersWhenPurchIdSpecified(
        ReqPlannedOrderGroupingKey _groupingKey,
        PurchId _purchId)
    {
        var groupFirmingParameters = this.groupFirmingParameters(InventTransType::Purch, _groupingKey);
        PurchId purchId = groupFirmingParameters.FirmedOrderReferenceId;

        if (!purchId)
        {
            // with the way the method groupFirmingParameters is implemented this place should never be reached by more than one thread at the same time

            groupFirmingParameters = ReqPlannedOrderGroupFirmingParameters::find(firmingRunId, InventTransType::Purch, _groupingKey, true);
            groupFirmingParameters.FirmedOrderReferenceId = _purchId;
            groupFirmingParameters.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchIdSingleThread</Name>
				<Source><![CDATA[
    private PurchId getPurchIdSingleThread(
        ReqPO                _reqPO,
        PurchAgreementId     _agreementId,
        ProjId               _projId = '',
        SalesId              _salesId = '')
    {
        var purchId = this.insertPurchTable(_reqPO.VendId, PurchaseType::Purch, _reqPO.ReqDateDlv, _agreementId, true, _projId, _salesId);

        var purchTable = PurchTable::find(purchId, true);

        this.initializePurchTableFromReqPO(purchTable, _reqPO);

        return purchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePurchTableFromReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the purchase order from the planned order.
    /// </summary>
    /// <param name = "_purchTable">
    ///     The purchase order.
    /// </param>
    /// <param name = "_reqPO">
    ///     The planned order.
    /// </param>
    protected void initializePurchTableFromReqPO(PurchTable _purchTable, ReqPO _reqPO)
    {
        // We are not updating buyer group on the header from reqPOs if it's initialized from the vendor
        if (_purchTable.ItemBuyerGroupId == '')
        {
            this.setPurchBuyerGroupId(_purchTable.PurchId, _reqPO);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchIdMultiThread</Name>
				<Source><![CDATA[
    private PurchId getPurchIdMultiThread(
        ReqPlannedOrderGroupingKey _groupingKey,
        ReqPO                _reqPO,
        PurchAgreementId     _agreementId,
        ProjId               _projId = '',
        SalesId              _salesId = '')
    {
        var groupFirmingParameters = this.groupFirmingParameters(InventTransType::Purch, _groupingKey);
        PurchId purchId = groupFirmingParameters.FirmedOrderReferenceId;

        if (!purchId)
        {
            // with the way the method groupFirmingParameters is implemented this place should never be reached by more than one thread at the same time
            purchId = this.insertPurchTable(_reqPO.VendId, PurchaseType::Purch, _reqPO.ReqDateDlv, _agreementId, true, _projId, _salesId);

            var purchTable = PurchTable::find(purchId, true);

            groupFirmingParameters = ReqPlannedOrderGroupFirmingParameters::find(firmingRunId, InventTransType::Purch, _groupingKey, true);
            groupFirmingParameters.FirmedOrderReferenceId = purchId;
            groupFirmingParameters.BuyerGroupId = _reqPO.ItemBuyerGroupId;
            groupFirmingParameters.MustUpdateBuyerGroupId = purchTable.ItemBuyerGroupId == ''; // We are not updating buyer group on the header from reqPOs if it's initialized from the vendor
            groupFirmingParameters.MustChangeDocumentState = true;
            groupFirmingParameters.update();
        }

        if (groupFirmingParameters.MustUpdateBuyerGroupId)
        {
            this.setPurchBuyerGroupId(purchId, _reqPO);
        }

        return purchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupFirmingParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the GroupFirmingParameters
    /// </summary>
    /// <param name = "_inventTransType"> The reference type. </param>
    /// <param name = "_groupingKey"> The group by key. </param>
    /// <returns> The group firming parameters </returns>
    protected ReqPlannedOrderGroupFirmingParameters groupFirmingParameters(InventTransType _inventTransType, ReqPlannedOrderGroupingKey _groupingKey)
    {
        var groupFirmingParameters = ReqPlannedOrderGroupFirmingParameters::find(firmingRunId, _inventTransType, _groupingKey);

        if (!groupFirmingParameters.RecId)
        {
            var logLineTry = infologLine();
            try
            {
                // We insert groupFirmingParameters with empty RefId to make sure that only one process will create the necessary data
                groupFirmingParameters.FirmingRunId = firmingRunId;
                groupFirmingParameters.FirmedOrderType = _inventTransType;
                groupFirmingParameters.GroupingKey = _groupingKey;
                groupFirmingParameters.insert();
            }
            catch (Exception::DuplicateKeyException)
            {
                infolog.clear(logLineTry); // We want to remove the information about duplicate key exception from infolog

                groupFirmingParameters = ReqPlannedOrderGroupFirmingParameters::find(firmingRunId, _inventTransType, _groupingKey);
            }
        }

        return groupFirmingParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqTransFirmLog</Name>
				<Source><![CDATA[
    protected void createReqTransFirmLog(
        ReqTrans            _reqTrans,
        InventTransType     _inventTransType,
        InventTransRefId    _inventTransRefId,
        InventTransId       _inventTransId)
    {
        ReqTransFirmLog reqTransFirmLog;

        if (!_reqTrans.IsDerivedDirectly)
        {
            reqTransFirmLog = this.initReqTransFirmLog();
            reqTransFirmLog.initFromReqTrans(_reqTrans);

            reqTransFirmLog.InventTransType     = _inventTransType;
            reqTransFirmLog.InventTransRefId    = _inventTransRefId;
            reqTransFirmLog.InventTransId       = _inventTransId;

            reqTransFirmLog.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWrkCtrCapRes</Name>
				<Source><![CDATA[
    protected void createWrkCtrCapRes(
        ReqTrans    _reqTrans,
        ProdTable   _prodTable,
        OprNum      _oprNumOffset)
    {
        WrkCtrCapRes wrkCtrCapRes;

        wrkCtrCapRes.skipDataMethods(true);

        update_recordset wrkCtrCapRes
            setting PlanVersion             = 0,
                    RefType                 = WrkCtrCapRefType::Production,
                    RefId                   = _prodTable.ProdId,
                    OprNum                  = wrkCtrCapRes.OprNum +_oprNumOffset,
                    JobId                   = ''
            where wrkCtrCapRes.PlanVersion  == _reqTrans.PlanVersion
               && wrkCtrCapRes.RefType      == WrkCtrCapRefType::PlannedOrder
               && wrkCtrCapRes.RefId        == _reqTrans.RefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        Map         mapReqTrans;
        Integer     showPurchaseTab;
        Integer     showTransferTab;
        Integer     countMarkedElements = this.countMarkedElements();

        Integer     pmfCountMarkedRefTypeBOMOrFormula;

        if (countMarkedElements < 50 && this.areMarkedElementsKnownUpfront())
        {
            mapReqTrans =
            this.mapReqTransMark();

            pmfCountMarkedRefTypeBOMOrFormula = ReqTransPoMark::countMarkedRefType(mapReqTrans,ReqRefType::BOMPlannedOrder)
                                                    + ReqTransPoMark::countMarkedRefType(mapReqTrans,ReqRefType::PmfPlannedProdBatch);

            if (pmfCountMarkedRefTypeBOMOrFormula > 0)
            {
                showPurchaseTab = 1;
            }
            else
            {
                showPurchaseTab = ReqTransPoMark::countMarkedRefType(mapReqTrans,ReqRefType::ItemPlannedOrder)-1;
            }
            showTransferTab = ReqTransPoMark::countMarkedRefType(mapReqTrans,ReqRefType::TransferPlannedOrder)-1;
        }
        else
        {
            showPurchaseTab = 1;
            showTransferTab = 1;
        }

        dialog = super();

        this.dialogAddDefaultFields(dialog, true, false);

        if (!ReqTransPoMarkFirmDialogMultiThreadedRunFlight::instance().isEnabled())
        {
            startMultiThreadedRun = false;
        }

        if (countMarkedElements > 1 || !this.areMarkedElementsKnownUpfront())
        {
            dialog.addGroup();
            dialogAbortIfErrors = dialog.addFieldValue(enumStr(NoYes), abortIfErrors, "@SYS83595", "@SYS83596");

            this.initializeUseMultiThreadDialog();
        }

        dialog.addGroup();
        dialogMarkUpdate = dialog.addFieldValue(enumStr(ReqMarkUpdate), reqMarkUpdate);

        if (!callerPurchId)
        {
            this.initializeTabs(showPurchaseTab, showTransferTab);
        }

        dialog.allowUpdateOnSelectCtrl(true);

        this.dialogSelectCtrl();

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTabs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the dialog tabs
    /// </summary>
    /// <param name="_showPurchaseTab">
    ///    Counts the number of reqTrans with ReqRefType::ItemPlannedOrder
    /// </param>
    /// <param name="_showTransferTab">
    ///    Counts the number of reqTrans with ReqRefType::TransferPlannedOrder
    /// </param>
    protected void initializeTabs(Integer _showPurchaseTab, Integer _showTransferTab)
    {
        if (_showPurchaseTab > 0)
        {
            this.initializePurchaseDialogTab();
        }
 
        if (_showTransferTab > 0)
        {
            this.initializeTransferDialogTab();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogCollectPerVendor_modified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Explicitly implemented <c>dialogCollectPerVendor</c> field <c>modified</c> method as this field is dynamically
    ///    added at runtime, no method can be specified at design time.
    /// </summary>
    /// <param name="_dialogCollectPerVendor">
    ///    The <c>FormCheckBoxControl</c> object that triggers this event.
    /// </param>
    /// <returns>
    /// True
    /// </returns>
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    private boolean dialogCollectPerVendor_modified(FormCheckBoxControl _dialogCollectPerVendor)
    {
        boolean ret = true;
        this.dialogSelectCtrl();
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogUseMultiThread_modified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Explicitly implemented <c>dialogUseMultiThread</c> field <c>modified</c> method as this field is dynamically
    ///    added at runtime, no method can be specified at design time.
    /// </summary>
    /// <param name="_dialogUseMultiThread">
    ///    The <c>FormCheckBoxControl</c> object that triggers this event.
    /// </param>
    /// <returns>
    /// True
    /// </returns>
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    private boolean dialogUseMultiThread_modified(FormCheckBoxControl _dialogUseMultiThread)
    {
        boolean ret = true;
        this.dialogSelectCtrl();
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogSelectCtrl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    When using the dialog class for dialog, this method is called whenever a control is selected.
    /// </summary>
    /// <remarks>
    ///    To enable this callback, the <c>allowUpdateOnSelectCtrl</c> method must have been set true.
    /// </remarks>
    public void dialogSelectCtrl()
    {
        super();

        if (dialogCollectPerVendor)
        {
            if (dialogCollectPerVendor.value())
            {
                dialogCollectPerBuyer.allowEdit(true);
                dialogCollectPerPeriodPurch.allowEdit(true);
                
                if (dialogCollectPerPlanningPriority)
                {
                    dialogCollectPerPlanningPriority.allowEdit(true);
                }
                
                if (dialogCollectPerPurchAgreement)
                {
                    dialogCollectPerPurchAgreement.allowEdit(false);
                    dialogCollectPerPurchAgreement.value(dialogCollectPerVendor.value());
                }
            }
            else
            {
                dialogCollectPerBuyer.allowEdit(false);
                dialogCollectPerBuyer.value(NoYes::No);

                dialogCollectPerPeriodPurch.allowEdit(false);
                dialogCollectPerPeriodPurch.value("");

                if (dialogCollectPerPlanningPriority)
                {
                    dialogCollectPerPlanningPriority.allowEdit(false);
                    dialogCollectPerPlanningPriority.value(NoYes::No);
                }

                if (dialogCollectPerPurchAgreement)
                {
                    dialogCollectPerPurchAgreement.allowEdit(false);
                    dialogCollectPerPurchAgreement.value(NoYes::No);
                }
            }
        }

        if (dialogUseMultiThread)
        {
            if (dialogUseMultiThread.value())
            {
                dialogMaxChildThreads.visible(true);
                dialogAbortIfErrors.value(false);
                dialogAbortIfErrors.enabled(false);
            }
            else
            {
                dialogMaxChildThreads.visible(false);
                dialogAbortIfErrors.enabled(true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustExecuteFirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the firming of the planned orders must be executed.
    /// </summary>
    /// <returns>true if the firming must be executed; otherwise, false.</returns>
    protected boolean mustExecuteFirm()
    {
        return (!this.areMarkedElementsKnownUpfront()) || this.countMarkedElements() || this.countDisqualifiedMarkedElements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeAction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the main workflow of the class.
    /// </summary>
    /// <remarks>
    ///    This method encapsulates the typical workflow of the action and should be invoked by the static
    ///    main method of the concrete <c>ReqTransPoMarkImplementation</c> class.
    /// </remarks>
    public void executeAction()
    {
        if (this.mustExecuteFirm())
        {
            if (this.prompt())
            {
                if (startMultiThreadedRun)
                {
                    throw error("@SCMPlanning:ReqScheduleParallelFirmingNotExecutingInBatchError");
                }
                else
                {
                    this.run();
                    
                    mustUpdateCallerForm = true;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandBOMRoute</Name>
				<Source><![CDATA[
    protected container expandBOMRoute(
        ReqTrans    _reqTrans,
        ProdTable   _prodTable,
        LineNum     _lineNumOffset,
        OprNum      _oprNumOffset,
        ProdRoute   _phantomProdRoute,
        BOM         _phantomBOM)
    {
        LineNum             lineNumNext;
        OprNum              oprNumfirst;
        OprNum              oprNumNext;
        OprNum              oprNumPhantom;
        Factor              phantomUnitFactor;
        phantomUnitFactor   = _phantomBOM.RecId ? _phantomBOM.BOMMap::phantomUnitFactor(_prodTable.QtySched) : 1;
        
        if (this.canExpandPhantomProductionRoute() || _phantomBOM.BOMType != BOMType::Phantom)
        {
            // Create prodRoute
            [oprNumfirst,oprNumNext] = this.createProdRoute(_reqTrans,_prodTable,_oprNumOffset,_phantomProdRoute,_phantomBOM,phantomUnitFactor);
            // Create prodRouteJobs
            this.createProdRouteJob(_reqTrans,_prodTable,_oprNumOffset);
            // Create capacity reservations
            this.createWrkCtrCapRes(_reqTrans,_prodTable,_oprNumOffset);
            // update prodRoute defaultDimension
            this.updateProdRouteDefaultDimension(_prodTable);
        }

        // Create prodBOm
        if (!oprNumfirst)
        {
            if (_phantomProdRoute.RecId)
            {
                oprNumPhantom   = _phantomProdRoute.OprNum;
                oprNumfirst     = _phantomProdRoute.OprNum;
            }
            else
            {
                oprNumPhantom = 0;
            }
        }
        [lineNumNext, oprNumNext] = this.createProdBOM(_reqTrans,_prodTable,_lineNumOffset,_oprNumOffset,oprNumfirst,oprNumNext,oprNumPhantom,_phantomBOM,phantomUnitFactor);
        if (_prodTable.inventTable().isFormulaAllowed())
        {
            this.pmfCreateCoBys(_reqTrans,_prodTable);
        }
        return [lineNumNext, oprNumNext];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExpandPhantomProductionRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if phantom BOM route should be expanded as part of parent BOM route.
    /// </summary>
    /// <returns>True if phantom BOM route should be expanded; otherwise false.</returns>
    protected boolean canExpandPhantomProductionRoute()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReqTransDynamic</Name>
				<Source><![CDATA[
    protected ReqTrans findReqTransDynamic(ReqTrans  _reqTrans)
    {
        ReqTrans  reqTransCopy;
        ReqPlanId reqPlanId = ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId;

        if (reqParameters.autoUpdateDynamicPlan(reqPlanId))
        {
            select firstonly forupdate reqTransCopy
                where reqTransCopy.PlanVersion              == ReqPlanVersion::findActiveReqPlanIdDynamic().RecId   &&
                      reqTransCopy.RefType                  == _reqTrans.RefType                                    &&
                      reqTransCopy.RefId                    == _reqTrans.RefId                                      &&
                      reqTransCopy.InventTransOrigin        == _reqTrans.InventTransOrigin                          &&
                      reqTransCopy.ItemId                   == _reqTrans.ItemId                                     &&
                      reqTransCopy.CovInventDimId           == _reqTrans.CovInventDimId                             &&
                      reqTransCopy.bomRefRecId              == _reqTrans.bomRefRecId;
        }
        return reqTransCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firmingSelectedPlannedOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to perform other related actions, before the firming of the selected planned orders.
    /// </summary>
    /// <param name = "_mapReqTransMark">A <c>Map</c> containing the list of orders being firmed.</param>
    [SysObsolete('', false, 30\11\2017)]
    delegate void firmingSelectedPlannedOrders(Map _mapReqTransMark)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>firmSelectedPlannedOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Firms the selected planned orders and updates related data.
    /// </summary>
    protected void firmSelectedPlannedOrders()
    {
        this.mapReqTransMark();

        if (mapReqTransMark
            && mapReqTransMark.elements())
        {
            this.doFirm();
            
            // If run in as a part of a bigger run post processing will be done in a separate step, since we cannot do post processing until all the lines that should be group together have been processed
            if (isPartOfBiggerRun)
            {
                this.updatePlannedOrderGroupFirmingParameters();
            }
            else
            {
                this.purchTablePostProcessing();
            }

            this.removeDeletedFromMark();

            // When running in single threaded mode as a part of a bigger run we fall back to the standard line numbering logic for purchase orders. Therefore after the run we need to update the numbering in ReqTransPoMarkFirmPurchaseLineNumberSequence
            if (isPartOfBiggerRun && !isPartOfMultithreadedRun)
            {
                processedOrdersData.syncPurchaseOrderLineNumbering();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTablePostProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post processes the purchase order.
    /// </summary>
    protected void purchTablePostProcessing()
    {
        this.setPurchTable();
        this.updatePurchBuyerGroup();

        if (!this.shouldSkipWorkflowSubmissionAndApproval())
        {
            this.submitPurchOrdersToWorkflow();
            this.autoApproveFirmedPlannedPurchaseOrders();
        }

        this.autoCreateForICSO();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostProcessingOfOrders</Name>
				<Source><![CDATA[
    internal void runPostProcessingOfOrders(Set _groupedOrders, ReqFirmingRunId _firmingRunId)
    {
        #OCCRetryCount

        m_oPurchToCrossDock = new RecordSortedList(tableNum(PurchTable)); // It is used by createCrossDockingJournals method

        var se = _groupedOrders.getEnumerator();
        while (se.moveNext())
        {
            ReqPlannedOrderGroupFirmingParameters groupFirmingParameters = se.current();
            
            try
            {
                this.runPostProcessingOfOrder(groupFirmingParameters);
            }
            catch (Exception::Deadlock)
            {
                retry;
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
                {
                    retry;
                }

                hasErrors = true;
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() != 0)
                {
                    throw Exception::UpdateConflict;
                }
                    
                if (xSession::currentRetryCount() < #RetryNum)
                {
                    retry;
                }

                hasErrors = true;
            }
            catch (Exception::DuplicateKeyException)
            {
                if (appl.ttsLevel() != 0)
                {
                    throw Exception::DuplicateKeyException;
                }

                if (xSession::currentRetryCount() < #RetryNum)
                {
                    retry;
                }

                hasErrors = true;
            }
            catch (Exception::Error)
            {
                hasErrors = true;
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            this.createCrossDockingJournals();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostProcessingOfOrder</Name>
				<Source><![CDATA[
    protected void runPostProcessingOfOrder(ReqPlannedOrderGroupFirmingParameters _groupFirmingParameters)
    {
        switch (_groupFirmingParameters.FirmedOrderType)
        {
            case InventTransType::Purch:
                this.runPostProcessingPurchaseOrder(_groupFirmingParameters);
                break;

            case InventTransType::TransferOrderReceive:
                this.runPostProcessingTransferOrder(_groupFirmingParameters);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostProcessingTransferOrder</Name>
				<Source><![CDATA[
    private void runPostProcessingTransferOrder(ReqPlannedOrderGroupFirmingParameters _groupFirmingParameters)
    {
        InventTransferId transferId = _groupFirmingParameters.FirmedOrderReferenceId;
        setPrefix(strFmt("@SCM:Error_ReqTransPoMarkFirm_TransferOrderPostProcessing", transferId));
        
        ttsbegin;
        var transferTable = InventTransferTable::find(transferId, true);
        this.setDatesFromLinesForTransferOrder(transferTable);
        transferTable.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostProcessingPurchaseOrder</Name>
				<Source><![CDATA[
    private void runPostProcessingPurchaseOrder(ReqPlannedOrderGroupFirmingParameters _groupFirmingParameters)
    {
        ttsbegin;

        PurchId purchId = _groupFirmingParameters.FirmedOrderReferenceId;
        setPrefix(strFmt("@SCM:Error_ReqTransPoMarkFirm_PurchaseOrderPostProcessing", purchId));

        var purchTable = PurchTable::find(purchId, true);
        if (purchTable.RecId)
        {
            this.setDeliveryDateForPurchTable(purchTable);

            if (_groupFirmingParameters.MustUpdateBuyerGroupId && ReqTransPoMarkFirm::checkCanUpdateBuyerGroupForPurchOrder(purchTable, _groupFirmingParameters.BuyerGroupId))
            {
                purchTable.parmItemBuyerGroupId(_groupFirmingParameters.BuyerGroupId);
            }

            if (_groupFirmingParameters.MustUpdateAddressFromInventLocationId)
            {
                purchTable.setAddressFromInventLocationId(_groupFirmingParameters.InventLocationId);
            }

            if (_groupFirmingParameters.MustUpdateReplenishmentLocation)
            {
                purchTable.ReplenishmentLocation = _groupFirmingParameters.ReplenishmentLocation;
            }

            purchTable.update();

            this.updatePurchaseOrderHeaderFromLines(purchTable);

            if (_groupFirmingParameters.MustBeCrossDocked)
            {
                m_oPurchToCrossDock.ins(purchTable);
            }

            if (_groupFirmingParameters.MustChangeDocumentState)
            {
                if (_groupFirmingParameters.MustOnlySubmitToWorkflow)
                {
                    ReqTransPoMarkFirm::submitPurchaseOrderToWorkflow(purchTable);
                }
                else
                {
                    this.autoApprovePurchaseOrder(purchTable);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeliveryDateForPurchTable</Name>
				<Source><![CDATA[
    private void setDeliveryDateForPurchTable(PurchTable _purchTable)
    {
        PurchLine purchLine;
        select minof(DeliveryDate) from purchLine
            where purchLine.PurchId == _purchTable.PurchId;

        _purchTable.DeliveryDate = min(purchLine.DeliveryDate, _purchTable.DeliveryDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDatesFromLinesForTransferOrder</Name>
				<Source><![CDATA[
    private void setDatesFromLinesForTransferOrder(InventTransferTable _transferTable)
    {
        InventTransferLine transferLine;
        select minof(ShipDate), maxof(ReceiveDate) from transferLine
            where transferLine.TransferId == _transferTable.TransferId;

        _transferTable.ShipDate = min(_transferTable.ShipDate, transferLine.ShipDate);
        _transferTable.ReceiveDate = max(_transferTable.ReceiveDate, transferLine.ReceiveDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePlannedOrderGroupFirmingParameters</Name>
				<Source><![CDATA[
    private void updatePlannedOrderGroupFirmingParameters()
    {
        processedOrdersData.updatePlannedOrderGroupFirmingParameters();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doFirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Firms the selected planned orders.
    /// </summary>
    protected void doFirm()
    {
        #OCCRetryCount
        MapEnumerator me;

        if (isSortingByLevelNeeded)
        {
            me = ReqTransPoMarkFirm::createReqTransMarkMapSortedByLevel(mapReqTransMark).getEnumerator();
        }
        else
        {
            me = mapReqTransMark.getEnumerator();
        }

        using (KanbanJobDeferredSchedulingScope deferredSchedulingScope = new KanbanJobDeferredSchedulingScope(isKanbanRuleAutoPlanningDeferred))
        {
            
            while (me.moveNext())
            {
                var logLineTry = infologLine();
                try
                {
                    if (ReqTransPOMarkFirmBatchValidatePerOrderFlight::instance().isEnabled() 
                        && !abortIfErrors 
                        && !this.validatePmfCheckApprovedFormulaForSingleTrans(me.currentValue())
                        && !this.areMarkedElementsKnownUpfront())
                    {
                        throw error("@PRO2682");
                    }
                    ttsbegin;
                    progress.incCount();
                    reqTransThrow = me.currentValue();
                    this.create(reqTransThrow);
                    ttscommit;
                    firmedOrderCount++;
                    this.saveRollbackPoint();
                }
                catch (Exception::Deadlock) 
                {
                    this.rollback();
                    retry;
                }
                catch (Exception::TransientSqlConnectionError)
                {
                    this.rollback();
                    var currentRetryCount = xSession::currentRetryCount();
                    if (currentRetryCount < #RetryNum && ReqTransientSqlConnectionErrorHandlingHelper::isReqTransientSqlConnectionErrorHandlingToggleEnabled())
                    {
                        ReqTransientSqlConnectionErrorHandlingHelper::delayRetry(currentRetryCount);
                        retry;
                    }

                    if (!isPartOfBiggerRun)
                    {
                        throw;
                    }
                    this.handleSettingHasErrorsWhenFirming(logLineTry);
                }
                catch (Exception::UpdateConflict)
                {
                    this.rollback();

                    if (appl.ttsLevel() != 0)
                    {
                        throw Exception::UpdateConflict;
                    }
                    
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        retry;
                    }
                    
                    if (!isPartOfBiggerRun)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }

                    this.handleSettingHasErrorsWhenFirming(logLineTry);
                }
                catch (Exception::DuplicateKeyException)
                {
                    this.rollback();

                    if (appl.ttsLevel() != 0)
                    {
                        throw Exception::DuplicateKeyException;
                    }

                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        retry;
                    }
                    
                    if (!isPartOfBiggerRun)
                    {
                        throw Exception::DuplicateKeyExceptionNotRecovered;
                    }

                    this.handleSettingHasErrorsWhenFirming(logLineTry);
                }
                catch (Exception::CLRError)
                {
                    this.rollback();

                    this.handleCLRException(logLineTry);
                }
                catch (Exception::Error)
                {
                    this.rollback();

                    this.handleSettingHasErrorsWhenFirming(logLineTry);

                    if (abortIfErrors && (this.countMarkedElements() != 1))
                    {
                        error("@SYS83593");
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveRollbackPoint</Name>
				<Source><![CDATA[
    private void saveRollbackPoint()
    {
        processedOrdersData.saveRollbackPoint();
    }

]]></Source>
			</Method>
			<Method>
				<Name>rollback</Name>
				<Source><![CDATA[
    private void rollback()
    {
        processedOrdersData.rollback();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a boolean indicating whether the firming has errors.
    /// </summary>
    /// <returns>
    /// true if the firming has errors; otherwise, false.
    /// </returns>
    public boolean hasErrors()
    {
        return hasErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        if (dialogAbortIfErrors)
        {
            abortIfErrors = dialogAbortIfErrors.value();
        }

        if (dialogUseMultiThread && dialogMaxChildThreads)
        {
            startMultiThreadedRun = dialogUseMultiThread.value();
            maxChildThreads = dialogMaxChildThreads.value();
        }

        reqMarkUpdate = dialogMarkUpdate.value();

        if (dialogCollectPerPlanningPriority)
        {
            collectPerPlanningPriority = dialogCollectPerPlanningPriority.value();
        }

        if (dialogCollectPerVendor)
        {
            collectPerVendor = dialogCollectPerVendor.value();
        }

        if (dialogCollectPerBuyer)
        {
            collectPerBuyer = dialogCollectPerBuyer.value();
        }

        if (dialogCollectPerPurchAgreement)
        {
            collectPerPurchAgreement = dialogCollectPerPurchAgreement.value();
        }

        if (dialogCollectPerPeriodPurch)
        {
            collectPerPeriodPurch = dialogCollectPerPeriodPurch.value();
        }

        if (dialogCollectPerPeriodJournal)
        {
            collectPerPeriodJournal = dialogCollectPerPeriodJournal.value();
        }

        if (dialogCollectPerPlanningPriorityTransfer)
        {
            collectPerPlanningPriorityTransfer = dialogCollectPerPlanningPriorityTransfer.value();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromArgs</Name>
				<Source><![CDATA[
    public void initFromArgs(Args _args)
    {
        super(_args);

        callerPurchId = _args.parm();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePurchLineFromProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields of the purchase line based on a production BOM.
    /// </summary>
    /// <param name = "_purchLine">
    /// The <c>PurchLine</c> that will be initialized.
    /// </param>
    /// <param name = "_prodBOMParent">
    /// The <c>ProdBOM</c> to initialize from.
    /// </param>
    protected void initializePurchLineFromProdBOM(
        PurchLine   _purchLine,
        ProdBOM     _prodBOMParent)
    {
        _purchLine.InventRefId            = _prodBOMParent.ProdId;
        _purchLine.InventRefTransId       = _prodBOMParent.InventTransId;
        _purchLine.ItemRefType            = InventRefType::ProdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePurchLineFromSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields of the purchase line based on a sales line.
    /// </summary>
    /// <param name = "_purchLine">
    /// The <c>PurchLine</c> that will be initialized.
    /// </param>
	/// <param name = "_salesLine">
    /// The <c>SalesLine</c> to initialize from.
    /// </param>
    protected void initializePurchLineFromSalesLine(
        PurchLine   _purchLine,
        SalesLine   _salesLine)
    {
        _purchLine.InventRefId            = _salesLine.SalesId;
        _purchLine.InventRefTransId       = _salesLine.InventTransId;
        _purchLine.ItemRefType            = InventRefType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInfologAction</Name>
				<Source><![CDATA[
    public void initInfologAction(ReqTrans _reqTrans)
    {
        container            c;
        Integer              line;
        SysInfologEnumerator enum;
        ReqTransInfoAction   reqTransInfoAction = ReqTransInfoAction::newReqTrans(_reqTrans);

        line = infologLine();
        c    = infolog.copy(logPoint + 1, line);

        infolog.clear(logPoint);
        enum = SysInfologEnumerator::newData(c);

        while (enum.moveNext())
        {
            switch (enum.currentException())
            {
                case Exception::Info:
                    info(enum.currentMessage(), '', reqTransInfoAction);
                    break;

                case Exception::Warning:
                    warning(enum.currentMessage(), '', reqTransInfoAction);
                    break;

                default:
                    error(enum.currentMessage(), '', reqTransInfoAction);
            }
        }

        logPoint = line;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        abortIfErrors                   = reqParameters.ReqAbortFirmIfError;
        reqMarkUpdate                   = reqParameters.DefaultMarkUpdate;

        collectPerPlanningPriority      = reqParameters.ReqPOCollectPerPlanningPriority;
        collectPerPlanningPriorityTransfer = reqParameters.ReqPOCollectPerPlanningPriorityTransfer;

        collectPerVendor                = reqParameters.ReqPOCollectPerVendor;
        collectPerBuyer                 = reqParameters.ReqPOCollectPerBuyer;

        collectPerPurchAgreement        = reqParameters.ReqPOCollectPerPurchAgreement;
        searchPurchAgreement            = reqParameters.ReqPOSearchPurchAgreement;

        collectPerPeriodPurch           = reqParameters.DefaultCollectPerPeriodPurch;
        collectPerPeriodJournal         = reqParameters.DefaultCollectPerPeriodJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqTransFirmLog</Name>
				<Source><![CDATA[
    protected ReqTransFirmLog initReqTransFirmLog()
    {
        ReqTransFirmLog reqTransFirmLog;

        reqTransFirmLog.ReqFirmDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        reqTransFirmLog.ReqFirmUserId = curUserId();

        return reqTransFirmLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initResultsFromPackedMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the class variables that represent the result of firming the planned order from the
    ///    specified container.
    /// </summary>
    /// <param name="_packedMap">
    ///    The container from which to initialize the class.
    /// </param>
    public void initResultsFromPackedMap(container _packedMap)
    {
        Map resultsMap = Map::create(_packedMap);

        mapReqPoDeleted     = Map::create(resultsMap.lookup(#mapKeyReqPoDeleted));
        mapReqTransDeleted  = Map::create(resultsMap.lookup(#mapKeyReqTransDeleted));
        mapReqTransMark     = Map::create(resultsMap.lookup(#mapKeyReqTransMark));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMovement</Name>
				<Source><![CDATA[
    public void insertMovement(Common _common)
    {
        // Begin > skip of logging to InventSumLogTTS because reqTrans is updated directly in updateFirmedReqTrans
        using (var scope = new InventSumLogTTSSkippingScope(this.mustSkipTTS()))
        {
            switch (_common.TableId)
            {
                case tableNum(ProdTable):
                    ProdTable localProdTable = _common as ProdTable;
                    Common dummy;
                    localProdTable.insert(false, dummy, false);
                    break;
                case tableNum(ProdBOM):
                    ProdBOM localProdBom = _common;
                    localProdBom.insert(false, null, true);
                    break;
                case tableNum(PurchLine):
                    PurchLine localPurchLine = _common;
                    boolean dropInvent = false;
                    boolean findMarkup = true;
                    boolean updatePurchTableDistributions = false;
                    localPurchLine.insert(dropInvent, findMarkup, updatePurchTableDistributions, false, true);
                    break;
                default:
                    _common.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySynchronize</Name>
				<Source><![CDATA[
    public void interCompanySynchronize(PurchLine _purchLine)
    {
        PurchLine       purchLine  = _purchLine;
        PurchTable      purchTable = _purchLine.purchTable();
        SalesLine       salesLine;
        SalesTable      salesTable;

        AxPurchLine                     axPurchLine;
        AxPurchTable                    axPurchTable;
        InterCompanyPurchSalesReference interCompanyPurchSalesReference;

        ttsbegin;
        salesLine  = SalesLine::findInventTransId(_purchLine.InventRefTransId, true);
        salesTable = salesLine.salesTable();

        if (salesTable.InterCompanyDirectDelivery)
        {
            salesLine.DeliveryType = TradeLineDlvType::DropShip;
        }
        else
        {
            salesLine.DeliveryType = TradeLineDlvType::None;
        }

        if (this.mustPopulateSourcingFields(salesLine))
        {
            salesLine.populateSourcingFields(purchTable, _purchLine, salesLine.DeliveryType, purchTable.OrderAccount);
            salesLine.SkipUpdate = InterCompanySkipUpdate::Internal;
        }

        salesLine.update();

        purchTable.InterCompanyOrigin = InterCompanyOrigin::Derived;
        axPurchTable = SalesTableType::construct(salesTable).syncPurchTable(salesTable, purchTable, true);
        axPurchTable.setTableFieldsForce();
        axPurchTable.save();

        purchLine.reread();
        purchLine.InterCompanyOrigin = InterCompanyOrigin::Derived;
        axPurchLine = SalesLineType::construct(salesLine).syncPurchLine(salesLine,purchLine);
        axPurchLine.setTableFieldsForce();
        axPurchLine.save();

        if (!InterCompanyPurchSalesReference::exist(salesTable.SalesId, purchTable.PurchId))
        {
            interCompanyPurchSalesReference.clear();
            interCompanyPurchSalesReference.SalesId = salesTable.SalesId;
            interCompanyPurchSalesReference.PurchId = purchTable.PurchId;
            interCompanyPurchSalesReference.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPopulateSourcingFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if source field populating is needed.
    /// </summary>
    /// <param name = "_salesLine">The sales line.</param>
    /// <returns>true if the sourcing vendor account is not filled in; otherwise false.</returns>
    protected boolean mustPopulateSourcingFields(SalesLine _salesLine)
    {
        return !_salesLine.SourcingVendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>labelDialogMarkedElements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a label to be used in the dialog for showing how many marked records were marked.
    /// </summary>
    /// <param name="_countMarkedElements">
    ///    The number of marked records.
    /// </param>
    /// <returns>
    ///    A label.
    /// </returns>
    protected str labelDialogMarkedElements(int _countMarkedElements)
    {
        str text;

        if (!this.areMarkedElementsKnownUpfront())
        {
            return "@SYS147421";
        }

        switch (_countMarkedElements)
        {
            case 0:
                text = "@SYS345110";
                break;
            case 1:
                text = "@SYS69953";
                break;
            default:
                text = strFmt("@SYS69954", _countMarkedElements);
                break;
        }

        return text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        reqTransPoMarkFirmInventJournalTableRecordCheckFlightIsEnabled = ReqTransPoMarkFirmInventJournalTableRecordCheckFlight::instance().isEnabled();
        processedOrdersData = ReqTransPoMarkFirmProcessedOrdersData::construct();
        instrumentationLogger = PurchInstrumentationLogger::createLogger(classStr(ReqTransPoMarkFirm));
        reqParameters = ReqParameters::find();
        prodParameters = ProdParameters::find();
        consOrdId     = '';
        pmfCoCreateDynamicPlan = false;
        //if firming called from MRP(autofirming) mapReqTransMark holds ReqTrans records for the same BOM level and additional sorting by BOM level is not needed. In MRP this property is set to false explicitly, but for other cases it is true by default and sorting by BOM level is being done
        isSortingByLevelNeeded = true;
        isPurchLineRefProjSalesFlightEnabled = ReqTransPoMarkFirmPurchLineRefProjSalesFlight::instance().isEnabled();
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, super(), #CurrentList];
        packed = this.appendVariableToPack(packed, varStr(startMultiThreadedRun), startMultiThreadedRun);
        packed = this.appendVariableToPack(packed, varStr(maxChildThreads), maxChildThreads);
        packed = this.appendVariableToPack(packed, varStr(collectPerPlanningPriority), collectPerPlanningPriority);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        // It has to be a XppEventHandlerCalledWhen::Post type, because otherwise the assignment to setReturnValue will do nothing
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        
        // The SysPackExtensions::pack method uses the return value as the source of the container but the unpack uses the args, so need to set both
        prePostArgs.setReturnValue(_pack);

        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(ReqTransPoMarkFirm) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packResultsMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Packs the variables that represent the result of the planned order firming into a container.
    /// </summary>
    /// <returns>
    ///    The container with the results of firming the planned order.
    /// </returns>
    public container packResultsMap()
    {
        Map map = new Map(Types::Integer, Types::Container);

        map.insert(#mapKeyReqPoDeleted,     this.packReqPoDeleted());
        map.insert(#mapKeyReqTransDeleted,  this.packReqTransDeleted());
        map.insert(#mapKeyReqTransMark,     this.packReqTransMark());

        return map.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerPurchId</Name>
				<Source><![CDATA[
    public PurchId parmCallerPurchId(PurchId _callerPurchId = callerPurchId)
    {
        callerPurchId = _callerPurchId;
        return callerPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPartOfBiggerRun</Name>
				<Source><![CDATA[
    public boolean parmIsPartOfBiggerRun()
    {
        return isPartOfBiggerRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirmingRunId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the firming run id of the run that is associated with the instance of the class.
    /// </summary>
    /// <returns>The firming run id.</returns>
    protected ReqFirmingRunId getFirmingRunId()
    {
        return firmingRunId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfConsOrdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets/sets the consolidated order id.
    /// </summary>
    /// <param name="_consOrdId">consolidated order id.</param>
    /// <returns>returns consolidated order id.</returns>
    public PmfConsOrdId parmPmfConsOrdId(PmfConsOrdId _consOrdId = consOrdId)
    {
        consOrdId = _consOrdId;
        return consOrdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfCoRecreateDynamic</Name>
				<Source><![CDATA[
    public boolean parmPmfCoRecreateDynamic(boolean _pmfCoCreateDynamicPlan = pmfCoCreateDynamicPlan)
    {
        pmfCoCreateDynamicPlan = _pmfCoCreateDynamicPlan;
        return pmfCoCreateDynamicPlan;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessedOrdersData</Name>
				<Source><![CDATA[
    public ReqTransPoMarkFirmProcessedOrdersData parmProcessedOrdersData()
    {
        return processedOrdersData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqRefType</Name>
				<Source><![CDATA[
    public ReqRefType parmReqRefType(ReqRefType _refType = refType)
    {
        refType = _refType;
        return refType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSearchPurchAgreement</Name>
				<Source><![CDATA[
    public ReqPOSearchPurchAgreement parmSearchPurchAgreement(ReqPOSearchPurchAgreement _searchPurchAgreement = searchPurchAgreement)
    {
        searchPurchAgreement = _searchPurchAgreement;
        return searchPurchAgreement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqMarkUpdate</Name>
				<Source><![CDATA[
    public ReqMarkUpdate parmReqMarkUpdate(ReqMarkUpdate _reqMarkUpdate = reqMarkUpdate)
    {
        reqMarkUpdate = _reqMarkUpdate;
        return reqMarkUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerVendor</Name>
				<Source><![CDATA[
    internal ReqPOCollectPerVendor parmCollectPerVendor(ReqPOCollectPerVendor _collectPerVendor = collectPerVendor)
    {
        collectPerVendor = _collectPerVendor;
        return collectPerVendor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerPlanningPriority</Name>
				<Source><![CDATA[
    internal ReqPOCollectPerPlanningPriority parmCollectPerPlanningPriority(ReqPOCollectPerPlanningPriority _collectPerPlanningPriority = collectPerPlanningPriority)
    {
        collectPerPlanningPriority = _collectPerPlanningPriority;
        return collectPerPlanningPriority;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerBuyer</Name>
				<Source><![CDATA[
    internal ReqPOCollectPerBuyer parmCollectPerBuyer(ReqPOCollectPerBuyer _collectPerBuyer = collectPerBuyer)
    {
        collectPerBuyer = _collectPerBuyer;
        return collectPerBuyer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerPurchAgreement</Name>
				<Source><![CDATA[
    internal ReqPOCollectPerPurchAgreement parmCollectPerPurchAgreement(ReqPOCollectPerPurchAgreement _collectPerPurchAgreement = collectPerPurchAgreement)
    {
        collectPerPurchAgreement = _collectPerPurchAgreement;
        return collectPerPurchAgreement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerPeriodPurch</Name>
				<Source><![CDATA[
    internal ReqPoCollectPerPeriod parmCollectPerPeriodPurch(ReqPoCollectPerPeriod _collectPerPeriodPurch = collectPerPeriodPurch)
    {
        collectPerPeriodPurch = _collectPerPeriodPurch;
        return collectPerPeriodPurch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerPeriodJournal</Name>
				<Source><![CDATA[
    internal ReqPoCollectPerPeriod parmCollectPerPeriodJournal(ReqPoCollectPerPeriod _collectPerPeriodJournal = collectPerPeriodJournal)
    {
        collectPerPeriodJournal = _collectPerPeriodJournal;
        return collectPerPeriodJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectPerPlanningPriorityTransfer</Name>
				<Source><![CDATA[
    internal ReqPOCollectPerPlanningPriorityTransfer parmCollectPerPlanningPriorityTransfer(ReqPOCollectPerPlanningPriorityTransfer _collectPerPlanningPriorityTransfer = collectPerPlanningPriorityTransfer)
    {
        collectPerPlanningPriorityTransfer = _collectPerPlanningPriorityTransfer;
        return collectPerPlanningPriorityTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAbortIfErrors</Name>
				<Source><![CDATA[
    internal NoYes parmAbortIfErrors(NoYes _abortIfErrors = abortIfErrors)
    {
        abortIfErrors = _abortIfErrors;
        return abortIfErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckApprovedVendorList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method validates if the planning item or the corresponding formula lines have valid approved vendor list entry if controlled by AVL
    /// functionality.
    /// </summary>
    /// <param name="_reqTrans">Planned order line</param>
    /// <param name="_reqPO">Planned order</param>
    /// <returns>Returns True / false</returns>
    private boolean pdsCheckApprovedVendorList(ReqTrans _reqTrans,ReqPO _reqPO)
    {
        boolean ret = true;

        var avlCheck = PdsApprovedVendorListCheck::newFromTable(_reqPO);
        ret = avlCheck.validateCheck();

        if (ret
            && (_reqTrans.RefType == ReqRefType::PmfPlannedProdBatch
                || _reqTrans.RefType == ReqRefType::BOMPlannedOrder))
        {
            BOM         bom;
            ReqTrans    reqTrans;

            while select bom
                where bom.bomId == _reqPO.ItemBomId
                    && bom.VendId != ''
                exists join reqTrans
                    where reqTrans.PlanVersion == _reqPO.PlanVersion
                       && reqTrans.RefId       == _reqPO.RefId
                       && reqTrans.BOMRefRecId == bom.RecId
            {
                var bomCheck = PdsApprovedVendorListCheck::newFromTable(bom);
                bomCheck.parmActiveDate(_reqPO.ReqDateDlv);

                if (bom.ToDate
                    && bom.ToDate < bomCheck.parmActiveDate()
                    && bom.inventTable().PdsVendorCheckItem != PdsVendorCheckItem::NoCheck)
                {
                    throw error(strFmt("@SCMPlanning:Message_ReqTransForInvalidBomLine", bom.ItemId, bom.bomId, bomCheck.parmActiveDate()));
                }
                ret = bomCheck.validateCheck();
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCreateProdCompensationPrinciples</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates compensation principles for any compensating ingredients on a production order.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> for the production order.
    /// </param>
    /// <remarks>
    /// This method must be called after all <c>ProdBOM</c> records have been created to ensure that the
    /// referenced active ingredients exist in the production order.
    /// </remarks>
    protected void pdsCreateProdCompensationPrinciples(ProdTable _prodTable)
    {
        BOMCopyToProd::copyProdCompensationPrinciples(_prodTable.ProdId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCheckApprovedFormula</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a validation to ensure an approved formula can be found for the active item.
    /// </summary>
    /// <returns>
    /// True if an approved formula has been found.
    /// </returns>
    public boolean pmfCheckApprovedFormula()
    {
        boolean     ret = true;
        ReqTrans    reqTrans;
        Map         localMapReqTransMark =  Map::create(conReqTransMark);

        MapIterator mi = new MapIterator(localMapReqTransMark);

        if (#PmfEnabled)
        {
            mi.begin();
            while (mi.more())
            {
                reqTrans = localMapReqTransMark.lookup(mi.key());

                ret = this.validatePmfCheckApprovedFormulaForSingleTrans(reqTrans);

                if (!ret)
                {
                    break;
                }
    
                mi.next();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoUpdateFirmedReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the co-product <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_reqTrans">Co-product <c>ReqTrans</c> record to update.</param>
    /// <param name="_inventTransId" >The <c>InventTransId</c> for the production co/by related inventory transaction.</param>
    /// <param name="_refId">Production order number used to update the <c>ReqTrans</c> record.</param>
    public void pmfCoUpdateFirmedReqTrans(
        ReqTrans            _reqTrans,
        InventTransId       _inventTransId,
        InventTransRefId    _refId)
    {
        _reqTrans.InventTransOrigin  = InventTransOrigin::findByInventTransId(_inventTransId).RecId;
        _reqTrans.IsForecastPurch   = NoYes::No;
        _reqTrans.RefId = _refId;
        _reqTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipTTS</Name>
				<Source><![CDATA[
    private boolean mustSkipTTS()
    {
        return mustSkipTTS || isAutoFirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsMustSkipTTS</Name>
				<Source><![CDATA[
    public boolean parmIsMustSkipTTS(boolean _mustSkipTTS = mustSkipTTS)
    {
        mustSkipTTS = _mustSkipTTS;
        return mustSkipTTS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsAutoFirm</Name>
				<Source><![CDATA[
    public boolean parmIsAutoFirm(boolean _isAutoFirm = isAutoFirm)
    {
        isAutoFirm = _isAutoFirm;
        return isAutoFirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBypassParallelFirmingFlag</Name>
				<Source><![CDATA[
    internal boolean parmBypassParallelFirmingFlag(boolean _bypassParallelFirmingFlag = bypassParallelFirmingFlag)
    {
        bypassParallelFirmingFlag = _bypassParallelFirmingFlag;
        return bypassParallelFirmingFlag;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCreateCoBys</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method creates the co/bys for the batch order
    /// </summary>
    /// <param name="_reqTrans">The <c>ReqTrans</c> record to use</param>
    /// <param name="_prodTable">The <c>ProdTable</c> record to use</param>
    protected void pmfCreateCoBys(ReqTrans _reqTrans, ProdTable _prodTable)
    {
        if (!pmfCoCreateDynamicPlan)
        {
            // Switch off invent sum log as the updates to ReqTrans are handled manually
            using (var scope = new InventSumLogTTSSkippingScope(this.mustSkipTTS()))
            {
                this.createCoByProductsForBatchOrder(_reqTrans, _prodTable);
            }
        }
        else
        {
            this.createCoByProductsForBatchOrder(_reqTrans, _prodTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCoByProductsForBatchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates production co-by products for a batch orders.
    /// </summary>
    /// <param name = "_reqTrans">The production order receipt requirement.</param>
    /// <param name = "_prodTable">The production order.</param>
    protected void createCoByProductsForBatchOrder(ReqTrans _reqTrans, ProdTable _prodTable)
    {
        ReqTrans       reqTransCoBy;
        PmfProdCoBy    prodCoBy;

        while select reqTransCoBy
            where reqTransCoBy.PlanVersion  == _reqTrans.PlanVersion
                && reqTransCoBy.RefType     == ReqRefType::PmfCoProduct
                && reqTransCoBy.RefId       == _reqTrans.RefId
        {
            prodCoBy.initFromBatchOrder(reqTransCoBy, _prodTable);

            prodCoBy.insert();

            prodCoBy.QtyCoByCalc      = reqTransCoBy.Qty;
            prodCoBy.RemainCoByPhysical= reqTransCoBy.Qty;
            prodCoBy.update();

            // Auto reserve settled issues
            if (! prodCoBy.InventRefTransId)
            {
                this.updateInventReference(reqTransCoBy);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns planning transaction related production/batch order id.
    /// </summary>
    /// <returns>class module name.</returns>
    public ProdId prodId()
    {
        return prodId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransTransferIdKey</Name>
				<Source><![CDATA[
    protected str reqTransTransferIdKey(ReqTrans _reqTrans, ReqPO _reqPO)
    {
        str key = int2str(enum2int(_reqTrans.RefType));

        _reqTrans.inventDim();
        _reqTrans.selectDerived().inventDim();
        key = key + '#' + _reqPO.fromInventDimWithDefaultLocation().InventLocationId + '#' + _reqPO.inventDimAndDefault().InventLocationId;

        if (collectPerPeriodJournal)
        {
            key = key + '#' + this.reqTransTransferPeriodKey(_reqTrans);
        }

        if (collectPerPlanningPriorityTransfer)
        {
            key += '#PlanningPriority:' + num2Str(_reqPO.PlanningPriority, 0, 2, DecimalSeparator::Auto, ThousandSeparator::None);
        }

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransTransferPeriodKey</Name>
				<Source><![CDATA[
    public str reqTransTransferPeriodKey(ReqTrans _reqTrans)
    {
        return ReqPoCollectPerPeriodHelper::getPeriodKeyForDate(collectPerPeriodJournal, _reqTrans.ReqDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the class to its default state.
    /// </summary>
    /// <remarks>
    ///    This method is called by the <c>RunBaseSetDefault</c> class.
    /// </remarks>
    public void reset()
    {
        prodPurch = null;
        processedOrdersData.reset();
        firmedOrderCount = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeUseMultiThreadDialog</Name>
				<Source><![CDATA[
    private void initializeUseMultiThreadDialog()
    {
        dialog.addText("@SCMPlanning:ReqTransPOMarkFirmParallelizationRecommendationText");
        dialogUseMultiThread = dialog.addFieldValue(enumStr(NoYes), startMultiThreadedRun, "@SCMPlanning:ReqTransPOMarkFirmDialogParalellization", "@SCMPlanning:ReqTransPOMarkFirmDialogParalellizationHelpText");

        if (!ReqTransPoMarkFirmDialogMultiThreadedRunFlight::instance().isEnabled())
        {
            dialogUseMultiThread.value(NoYes::No);
        }

        dialogMaxChildThreads = dialog.addFieldValue(extendedTypeStr(ReqProcessNumThreads), maxChildThreads);
        dialogMaxChildThreads.visible(false);

        // Register overridden event handler for modified event of dialogUseMultiThread check box
        dialogUseMultiThread.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(ReqTransPoMarkFirm, dialogUseMultiThread_modified), this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupMultiThreadedRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up the multi threaded run.
    /// </summary>
    protected void setupMultiThreadedRun()
    {
        startMultiThreadedRun = false;

        ReqScheduleParallelFirmingContract contract = this.setupMultiThreadedRunContract();

        ReqScheduleParallelFirmingService service = new ReqScheduleParallelFirmingService();
        service.scheduleFirming(contract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupMultiThreadedRunContract</Name>
				<Source><![CDATA[
    protected ReqScheduleParallelFirmingContract setupMultiThreadedRunContract()
    {
        ReqScheduleParallelFirmingContract contract = new ReqScheduleParallelFirmingContract();
        contract.parmMaxChildThreads(this.maxChildThreads);
        contract.parmConReqTransMark(this.conReqTransMark);
        contract.parmCollectPerPlanningPriority(this.parmCollectPerPlanningPriority());
        contract.parmCollectPerPlanningPriorityTransfer(this.parmCollectPerPlanningPriorityTransfer());
        contract.parmCollectPerVendor(this.parmCollectPerVendor());
        contract.parmCollectPerBuyer(this.parmCollectPerBuyer());
        contract.parmCollectPerPurchAgreement(this.parmCollectPerPurchAgreement());
        contract.parmCollectPerPeriodPurch(this.parmCollectPerPeriodPurch());
        contract.parmCollectPerPeriodJournal(this.parmCollectPerPeriodJournal());
        contract.parmCallerPurchId(this.parmCallerPurchId());
        contract.parmReqMarkUpdate(this.parmReqMarkUpdate());
        contract.parmSearchPurchAgreement(this.parmSearchPurchAgreement());
        contract.parmReqRefType(this.parmReqRefType());

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        // If the marked elements were known upfront, we did an early check already.
        // Otherwise this is the earliest point where we can do the check.
        if (!this.areMarkedElementsKnownUpfront()
                && (abortIfErrors || !ReqTransPOMarkFirmBatchValidatePerOrderFlight::instance().isEnabled())
                && !this.pmfCheckApprovedFormula())
        {
            throw error("@PRO2682");
        }
        
        if (startMultiThreadedRun)
        {
            this.setupMultiThreadedRun();
            return;
        }

        using (var instrumentation = ReqInstrumentationSegmentFactory::create(ReqInstrumentationActivities::Firming, ReqInstrumentationActivities::DefaultActivityId, this.getParametersForTelemetry()))
        {
            #OCCRetryCount
            setPrefix(ReqTransPoMarkFirm::description());

            phantomDerivedData = new Map(Types::Integer, Types::Container);

            if (!this.validate())
            {
                throw error("@SYS18447");
            }

            super();

            instrumentation.addAdditionalParameterToStopEvent(ReqInstrumentationActivities::ParmIsMoreThanOne, int2Str(mapReqTransMark.elements() > 1));

            logPoint = infologLine();

            this.progressInit(ReqTransPoMarkFirm::description(), mapReqTransMark.elements(), #AviUpdate);

            if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
            {
                m_oPurchToCrossDock = new RecordSortedList(tableNum(PurchTable));
            }

            this.setGroupingIndicators();

            // Firm selected planned orders
            var logLineTry = infologLine();
            try
            {
                if (abortIfErrors)
                {
                    ttsbegin;
                    this.firmSelectedPlannedOrders();
                    ttscommit;
                }
                else
                {
                    this.firmSelectedPlannedOrders();
                }
            }
            catch (Exception::Deadlock)
            {
                if (abortIfErrors)
                {
                    this.reset();
                }

                retry;
            }
            catch (Exception::TransientSqlConnectionError)
            {
                var currentRetryCount = xSession::currentRetryCount();
                if (currentRetryCount < #RetryNum && ReqTransientSqlConnectionErrorHandlingHelper::isReqTransientSqlConnectionErrorHandlingToggleEnabled())
                {
                    if (abortIfErrors)
                    {
                        this.reset();
                    }
                    ReqTransientSqlConnectionErrorHandlingHelper::delayRetry(currentRetryCount);
                    retry;
                }
                if (!isPartOfBiggerRun)
                {
                    throw;
                }

                this.handleSettingHasErrorsWhenFirming(logLineTry);
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() != 0)
                {
                    throw Exception::UpdateConflict;
                }

                if (xSession::currentRetryCount() < #RetryNum)
                {
                    if (abortIfErrors)
                    {
                        this.reset();
                    }

                    retry;
                }
            
                if (!isPartOfBiggerRun)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }

                this.handleSettingHasErrorsWhenFirming(logLineTry);
            }
            catch (Exception::DuplicateKeyException)
            {
                if (appl.ttsLevel() != 0)
                {
                    throw Exception::DuplicateKeyException;
                }

                if (xSession::currentRetryCount() < #RetryNum)
                {
                    if (abortIfErrors)
                    {
                        this.reset();
                    }

                    retry;
                }
                    
                if (!isPartOfBiggerRun)
                {
                    throw Exception::DuplicateKeyExceptionNotRecovered;
                }

                this.handleSettingHasErrorsWhenFirming(logLineTry);
            }
            catch (Exception::CLRError)
            {
                this.handleCLRException(logLineTry);
            }
            catch (Exception::Error)
            {
                if (isPartOfMultithreadedRun)
                {
                    // Since isPartOfMultithreadedRun is true we want to remove infolog messages created while executing statements in the try block.
                    // We will retry firming of this order in the single threaded phase
                    infolog.clear(logLineTry);
                }
                else
                {
                    hasErrors = true;
                    this.initInfologAction(reqTransThrow);
                    if (abortIfErrors && (this.countMarkedElements() != 1))
                    {
                        error("@SYS83593");
                    }
                }
            }

            // If run as a part of a bigger run post processing will be done in a separate step, since we cannot do post processing until all the lines that should be group together into have been processed
            if (!isPartOfBiggerRun && isConfigurationkeyEnabled(configurationKeyNum(Retail)))
            {
                this.createCrossDockingJournals();
            }

            instrumentation.addAdditionalParameterToStopEvent(ReqInstrumentationActivities::FirmedOrderCount, int2Str(firmedOrderCount));
            instrumentation.addAdditionalParameterToStopEvent(ReqInstrumentationActivities::ParmHasErrors, int2Str(hasErrors));
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && (PurchParameters::find().AutomaticFactBoxUpdateOnPO_PSN))
        {
            PurchTotalsSummary purchTotalsSummary;
            select PurchId from purchTotalsSummary order by RecId desc;

            if (purchTotalsSummary && !purchTotalsSummary.IsValid)
            {
                PurchTotalsSummaryController::updateTotals(PurchTable::find(purchTotalsSummary.PurchId), tableNum(PurchTotalsSummary), purchTotalsSummary);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCLRException</Name>
				<Source><![CDATA[
    protected void handleCLRException(int _logLineTry)
    {
        if (isPartOfMultithreadedRun)
        {
            // Since isPartOfMultithreadedRun is true we want to remove infolog messages created while executing statements in the try block.
            // We will retry firming of this order in the single threaded phase
            infolog.clear(_logLineTry);

            // We still want to log the error into telemetry for troubleshooting purposes
            System.Exception ex = ClrInterop::getLastException();
            if (ex)
            {
                ApplicationUnhandledExceptionLogger::logCLRException(ex);
            }
        }
        else
        {
            hasErrors = true;

            ApplicationUnhandledExceptionLogger::processUnhandledCLRException();

            if (abortIfErrors && (this.countMarkedElements() != 1))
            {
                error("@SYS83593");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleSettingHasErrorsWhenFirming</Name>
				<Source><![CDATA[
    protected void handleSettingHasErrorsWhenFirming(int _logLineTry)
    {
        if (isPartOfMultithreadedRun)
        {
            // Since isPartOfMultithreadedRun is true we want to remove infolog messages created while executing statements in the try block.
            // We will retry firming of this order in the single threaded phase
            infolog.clear(_logLineTry);
        }
        else
        {
            hasErrors = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGroupingIndicators</Name>
				<Source><![CDATA[
    private void setGroupingIndicators()
    {
        isTransfersGroupingEnabled = this.isTransfersGroupingEnabled();
        mustRunTransfersPostProcessing = isPartOfBiggerRun && isTransfersGroupingEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransfersGroupingEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if transfers grouping is enabled.
    /// </summary>
    /// <returns>
    /// true if transfers grouping is enabled; otherwise, false.
    /// </returns>
    protected boolean isTransfersGroupingEnabled()
    {
        return (collectPerPeriodJournal != ReqPoCollectPerPeriod::No || collectPerPlanningPriorityTransfer != NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchBuyerGroupId</Name>
				<Source><![CDATA[
    private void setPurchBuyerGroupId(PurchId _purchId, ReqPO _reqPO)
    {
        processedOrdersData.markPurchaseOrderForUpdatingBuyerGroupId(_purchId, _reqPO.ItemBuyerGroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Set related field value from purchLine to PurchTable.
    /// </summary>
    protected void setPurchTable()
    {
        var map = processedOrdersData.getGroupingKeyToPurchIdMap();

        if (map && map.elements())
        {
            MapEnumerator me = map.getEnumerator();
            while (me.moveNext())
            {
                ttsbegin;
                PurchId purchId = me.currentValue();
                PurchTable purchTable = PurchTable::find(purchId, true);

                this.updatePurchaseOrderHeaderFromLines(purchTable);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrderHeaderFromLines</Name>
				<Source><![CDATA[
    private void updatePurchaseOrderHeaderFromLines(PurchTable _purchTable)
    {
        if (_purchTable.RecId)
        {
            List listRecordList = new List(Types::Record);

            PurchLine purchLine;
            while select purchLine
                where purchLine.PurchId == _purchTable.purchId
            {
                listRecordList.addEnd(purchLine);
            }

            if (listRecordList.empty())
            {
                return;
            }

            this.initPurchTable(_purchTable, listRecordList);
            _purchTable.type().interCompanyCalcDisc();

            this.updatePurchTableFromSite(_purchTable);
            this.updatePurchTable(_purchTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the purchase order from the purchase lines.
    /// </summary>
    /// <param name="_purchTable">
    ///     The purchase order to be initialized.
    /// </param>
    /// <param name="_purchLineList">
    ///     The list of purchase lines used to initialize the purchase order.
    /// </param>
    protected void initPurchTable(PurchTable _purchTable, List _purchLineList)
    {
        if (!_purchLineList.empty())
        {
            ListEnumerator listEnumerator = _purchLineList.getEnumerator();
            _purchTable.updateFromPurchReqLineMap(listEnumerator);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the purchase order.
    /// </summary>
    /// <param name="_purchTable">
    ///     The purchase order to be updated.
    /// </param>
    protected void updatePurchTable(PurchTable _purchTable)
    {
        if (_purchTable.isInterCompanyOrder())
        {
            _purchTable.update();
        }
        else
        {
            _purchTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitPurchOrdersToWorkflow</Name>
				<Source><![CDATA[
    private void submitPurchOrdersToWorkflow()
    {
        ttsbegin;

        var purchIdsToSubmitToWorkflow = processedOrdersData.getPurchaseOrdersToSubmitToWorflow();
        var enumerator = purchIdsToSubmitToWorkflow.getEnumerator();
        while (enumerator.moveNext())
        {
            var purchOrder = PurchTable::find(enumerator.current(), true);
            ReqTransPoMarkFirm::submitPurchaseOrderToWorkflow(purchOrder);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitPurchaseOrderToWorkflow</Name>
				<Source><![CDATA[
    private static void submitPurchaseOrderToWorkflow(PurchTable _purchOrder)
    {
        if (_purchOrder.RecId && _purchOrder.ChangeRequestRequired && _purchOrder.DocumentState == VersioningDocumentState::Draft)
        {
            _purchOrder.submitToWorkflow(workFlowTypeStr(PurchTableTemplate), '', false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer   version = RunBase::getVersion(_packedClass);
        container base;

        switch (version)
        {
            case #CurrentVersion:
                [version,base,#CurrentList] = _packedClass;
                super(base);
                startMultiThreadedRun = this.extractPackedVariable(_packedClass, varStr(startMultiThreadedRun));
                maxChildThreads = this.extractPackedVariable(_packedClass, varStr(maxChildThreads));
                collectPerPlanningPriority = this.extractPackedVariable(_packedClass, varStr(collectPerPlanningPriority));
                break;
            case 12:
                [version,base,#CurrentList] = _packedClass + NoYes::Yes;
                super(base);
                break;
            case 15:
                [version,base,#CurrentList] = _packedClass + DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                super(base);
                break;
            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFirmedReqTrans</Name>
				<Source><![CDATA[
    protected void updateFirmedReqTrans(
        ReqTrans            _reqTrans,
        ReqPO               _reqPO,
        ReqRefType          _refType,
        InventTransRefId    _refId,
        InventTransOriginId _inventTransOriginId,
        InventTransOriginId _inventTransOriginIdShip = 0)
    {
        ReqPlanId           reqPlanId;
        InventTrans         inventTrans = InventTrans::findByInventTransOrigin(_inventTransOriginId);
        InventTransOriginId markingInventTransOriginId = inventTrans.MarkingRefInventTransOrigin;
        Integer             priority = ReqTrans::statusIssue2Priority(inventTrans.StatusIssue);

        reqPlanId = ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId;

        if (reqParameters.autoUpdateDynamicPlan(reqPlanId))
        {
            this.updateDynamicPlanData(_reqTrans, _refType, _refId, _inventTransOriginId);
        }

        if (_reqPO.supplyPrinciple() == ReqSupplyPrinciple::Transfer)
        {
            this.updateTransferDemand(_reqTrans, _refType, _refId, _inventTransOriginIdShip);
        }

        _reqTrans.InventTransOrigin = _inventTransOriginId;
        _reqTrans.MarkingRefInventTransOrigin   = markingInventTransOriginId;
        _reqTrans.Priority                      = priority;
        _reqTrans.RefType           = _refType;
        _reqTrans.RefId             = _refId;
        _reqTrans.IsForecastPurch   = NoYes::No;
        _reqTrans.update();

        //delete reqPo
        _reqPO.delete(true);

        if (_reqPO.RowCount() == 0)
        {
            infolog.add(Exception::UpdateConflict, "@SYS107548");
            throw Exception::UpdateConflict; // to prevent that multiple orders are created in parallel.
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferDemand</Name>
				<Source><![CDATA[
    private void updateTransferDemand(
        ReqTrans _reqTrans,
        ReqRefType _refType,
        InventTransRefId _refId,
        InventTransOriginId _inventTransOriginIdShip = 0)
    {
        ReqTrans reqTransTransferDemand;

        reqTransTransferDemand  = _reqTrans.selectDerived(true);
        if (reqTransTransferDemand.RecId)
        {
            reqTransTransferDemand.InventTransOrigin    = _inventTransOriginIdShip;
            reqTransTransferDemand.RefType              = ReqTrans::derivedRefType(_refType);
            reqTransTransferDemand.RefId                = _refId;

            InventTrans demandInventTrans = InventTrans::findByInventTransOrigin(_inventTransOriginIdShip);
            reqTransTransferDemand.Priority = ReqTrans::statusIssue2Priority(demandInventTrans.StatusIssue);

            reqTransTransferDemand.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDynamicPlanData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes ReqTrans records for the planned order between the current plan and the dynamic plan.
    /// </summary>
    /// <param name = "_reqTrans">The ReqTrans of the planned order.</param>
    /// <param name = "_refType">The reference type</param>
    /// <param name = "_refId">The reference id</param>
    /// <param name = "_inventTransOriginId">The inventory transaction origin id</param>
    /// <param name = "_inventTransOriginIdShip">The inventory transaction origin id ship</param>
    private void updateDynamicPlanData(
        ReqTrans _reqTrans,
        ReqRefType _refType,
        InventTransRefId _refId,
        InventTransOriginId _inventTransOriginId,
        InventTransOriginId _inventTransOriginIdShip = 0)
    {
        ReqTrans reqTransCopy;
        ReqPO reqPoCopy;
        InventTrans inventTrans = InventTrans::findByInventTransOrigin(_inventTransOriginId);
        InventTransOriginId markingInventTransOriginId = inventTrans.MarkingRefInventTransOrigin;
        Integer priority = ReqTrans::statusIssue2Priority(inventTrans.StatusIssue);

        select firstonly forupdate reqTransCopy
            where reqTransCopy.PlanVersion       == ReqPlanVersion::findActiveReqPlanIdDynamic().RecId
               && reqTransCopy.RefType           == _reqTrans.RefType
               && reqTransCopy.RefId             == _reqTrans.RefId
               && reqTransCopy.InventTransOrigin == _reqTrans.InventTransOrigin
               && reqTransCopy.ItemId            == _reqTrans.ItemId
               && reqTransCopy.CovInventDimId    == _reqTrans.CovInventDimId;

        reqPoCopy = reqTransCopy.reqPo(true);

        if (reqTransCopy.RecId && reqPoCopy.RecId)
        {
            if (reqPoCopy.supplyPrinciple() == ReqSupplyPrinciple::Transfer)
            {
                this.updateTransferDemand(reqTransCopy, _refType, _refId, _inventTransOriginIdShip);
            }

            if (reqTransCopy.RefType == ReqRefType::BOMPlannedOrder
                || (#PmfEnabled
                    && reqTransCopy.RefType == ReqRefType::PmfPlannedProdBatch))
            {
                WrkCtrCapResHandler::construct().deleteOrderReservations(WrkCtrCapRefType::PlannedOrder,reqTransCopy.RefId, 0, reqTransCopy.PlanVersion);
            }

            reqTransCopy.InventTransOrigin  = _inventTransOriginId;
            reqTransCopy.MarkingRefInventTransOrigin = markingInventTransOriginId;
            reqTransCopy.Priority = priority;
            reqTransCopy.RefType = _refType;
            reqTransCopy.RefId = _refId;
            reqTransCopy.IsForecastPurch = NoYes::No;
            reqTransCopy.update();

            reqPoCopy.delete(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFirmedReqTransBOM</Name>
				<Source><![CDATA[
    protected void updateFirmedReqTransBOM(
        ReqTrans            _reqTransBOM,
        ProdBOM             _prodBOM)
    {
        ReqTrans                reqTransCopy;
        InventTrans             inventTrans = InventTrans::findTransId(_prodBOM.InventTransId);
        InventTransOriginId     inventTransOriginId = inventTrans.InventTransOrigin;
        InventTransOriginId     markingInventTransOriginId = inventTrans.MarkingRefInventTransOrigin;
        Integer                 priority = ReqTrans::statusIssue2Priority(inventTrans.StatusIssue);

        // Update reqTrans as production line

        reqTransCopy = this.findReqTransDynamic(_reqTransBOM);
        if (reqTransCopy.RecId)
        {
            reqTransCopy.InventTransOrigin              = inventTransOriginId;
            reqTransCopy.MarkingRefInventTransOrigin    = markingInventTransOriginId;
            reqTransCopy.Priority                       = priority;
            reqTransCopy.RefType                        = ReqRefType::ProdLine;
            reqTransCopy.RefId                          = _prodBOM.ProdId;
            reqTransCopy.ReqDateDlvOrig                 = reqTransCopy.ReqDate;
            reqTransCopy.update();
        }

        _reqTransBOM.InventTransOrigin              = inventTransOriginId;
        _reqTransBOM.MarkingRefInventTransOrigin    = markingInventTransOriginId;
        _reqTransBOM.Priority                       = priority;
        _reqTransBOM.RefType                        = ReqRefType::ProdLine;
        _reqTransBOM.RefId                          = _prodBOM.ProdId;
        _reqTransBOM.ReqDateDlvOrig                 = _reqTransBOM.ReqDate;
        _reqTransBOM.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventReference</Name>
				<Source><![CDATA[
    protected void updateInventReference(ReqTrans   _reqTrans)
    {                
        if (_reqTrans.CovQty && reqMarkUpdate != ReqMarkUpdate::No)
        {
            InventTrans::updateMarkReqTransCov(_reqTrans, reqMarkUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProdRouteDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the default dimension of the specified production order.
    /// </summary>
    /// <param name="_prodTable">
    ///     The specified production order.
    /// </param>
    protected void updateProdRouteDefaultDimension(ProdTable  _prodTable)
    {
        ProdRoute   prodRoute;

        while select forupdate prodRoute
            index hint NumOprNumIdx
            where prodRoute.ProdId      == _prodTable.ProdId
        {
            prodRoute.initDimensionWrkCtrTable();
            prodRoute.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchBuyerGroup</Name>
				<Source><![CDATA[
    private void updatePurchBuyerGroup()
    {
        ttsbegin;

        mapPurchBuyerGroupId = processedOrdersData.getPurchaseOrderForUpdatingBuyerGroupId();
        var me = mapPurchBuyerGroupId.getEnumerator();
        while (me.moveNext())
        {
            var purchTable = PurchTable::find(me.currentKey(), true);
            ItemBuyerGroupId itemBuyerGroupId =  me.currentValue();
            if (purchTable.RecId && ReqTransPoMarkFirm::checkCanUpdateBuyerGroupForPurchOrder(purchTable, itemBuyerGroupId))
            {
                purchTable.parmItemBuyerGroupId(itemBuyerGroupId);
                purchTable.doUpdate();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanUpdateBuyerGroupForPurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the buyer group can be updated for the purchase order.
    /// </summary>
    /// <param name = "_purchTable">
    ///     The purchase order for which the buyer group needs to be updated.
    /// </param>
    /// <param name = "_itemBuyerGroupId">
    ///     The buyer group ID.
    /// </param>
    /// <returns>
    ///     true if the buyer group can be updated for the purchase order; otherwise, false.
    /// </returns>
    protected static boolean checkCanUpdateBuyerGroupForPurchOrder(PurchTable _purchTable, ItemBuyerGroupId _itemBuyerGroupId)
    {
        if (_purchTable.ItemBuyerGroupId != _itemBuyerGroupId && !_purchTable.canAutoUpdatePurchOrder())
        {
            var dictField = new DictField(tableNum(PurchTable), fieldNum(PurchTable, ItemBuyerGroupId));
            warning(strFmt("@SYS300247", dictField.label(), _purchTable.PurchId, _purchTable.InvoiceAccount));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static ReqTransPoMarkFirm construct()
    {
        return new ReqTransPoMarkFirm();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParametersFromReqScheduleParallelFirmingContract</Name>
				<Source><![CDATA[
    public void setParametersFromReqScheduleParallelFirmingContract(ReqScheduleParallelFirmingContract _contract)
    {
        this.parmCollectPerPlanningPriority(_contract.parmCollectPerPlanningPriority());
        this.parmCollectPerVendor(_contract.parmCollectPerVendor());
        this.parmCollectPerBuyer(_contract.parmCollectPerBuyer());
        this.parmCollectPerPurchAgreement(_contract.parmCollectPerPurchAgreement());
        this.parmCollectPerPeriodPurch(_contract.parmCollectPerPeriodPurch());
        this.parmCollectPerPeriodJournal(_contract.parmCollectPerPeriodJournal());
        this.parmCallerPurchId(_contract.parmCallerPurchId());
        this.parmReqMarkUpdate(_contract.parmReqMarkUpdate());
        this.parmSearchPurchAgreement(_contract.parmSearchPurchAgreement());
        this.parmReqRefType(_contract.parmReqRefType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqTransMarkMapSortedByLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a map of <c>ReqTrans</c> records sorted in descending order based on their level value.
    /// </summary>
    /// <param name="_mapReqTransMark">
    /// A map of <c>ReqTrans</c> records.
    /// </param>
    /// <returns>
    /// A map of <c>ReqTrans</c> records sorted by level value in descending order.
    /// </returns>
    public static Map createReqTransMarkMapSortedByLevel(Map _mapReqTransMark)
    {
        Map sortedMap = new Map(Types::String, Types::Record);

        MapEnumerator me = _mapReqTransMark.getEnumerator();

        while (me.moveNext())
        {
            ReqTrans reqTrans = me.currentValue();

            // The fact the map is sorted by its keys in order of lowest character.
            // The reqtrans records should be sorted descending in terms of is level, the record ID is
            // used to allow multiple reqtrans entries with the same level value.
            sortedMap.insert(strFmt('%1#%2', ReqTransPoAutoFirmPartitioner::PossibleBiggestBomLevel - reqTrans.Level, reqTrans.RecId), reqTrans);
        }

        return sortedMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS77789";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
        {
            ReqTransPoMarkFirm reqTransPoMarkFirmClient;

            reqTransPoMarkFirmClient = ReqTransPoMarkFirm::newForm(_args);

            reqTransPoMarkFirmClient.parmIsSortingByLevelNeeded(true);

            if (reqTransPoMarkFirmClient.areMarkedElementsKnownUpfront()
                && reqTransPoMarkFirmClient.countMarkedElements()
                && !reqTransPoMarkFirmClient.pmfCheckApprovedFormula())
            {
                throw error("@PRO2682");
            }

            reqTransPoMarkFirmClient.isStartedFromUI = _args ? _args.callerType() == UtilElementType::Form : false;

            reqTransPoMarkFirmClient.executeAction();

            if (reqTransPoMarkFirmClient.mustUpdateCallerForm)
            {
                reqTransPoMarkFirmClient.refreshCallerForm();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForm</Name>
				<Source><![CDATA[
    public static ReqTransPoMarkFirm newForm(Args _args)
    {
        ReqTransPoMarkFirm  reqTransPoMarkFirm  = ReqTransPoMarkFirm::construct();
        ReqRefType          reqRefType;

        if (_args.parmEnumType() == enumNum(ReqPOType))
        {
            reqRefType = ReqPO::reqPoType2ReqRefType(_args.parmEnum());
        }

        reqTransPoMarkFirm.getLast();
        reqTransPoMarkFirm.initFromArgs(_args);

        reqTransPoMarkFirm.parmReqRefType(reqRefType);
        reqTransPoMarkFirm.parmSearchPurchAgreement(ReqParameters::find().ReqPOSearchPurchAgreement);
        reqTransPoMarkFirm.init();

        return reqTransPoMarkFirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMap</Name>
				<Source><![CDATA[
    public static ReqTransPoMarkFirm newMap(Map _mapReqTransMark)
    {
        ReqTransPoMarkFirm reqTransPoMarkFirm  = ReqTransPoMarkFirm::construct();

        reqTransPoMarkFirm.initFromReqTransMap(_mapReqTransMark);

        return reqTransPoMarkFirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromReqTransMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance from the given map.
    /// </summary>
    /// <param name = "_mapReqTransMark">Map ReqTrans.RecId to ReqTrans that hold all ReqTrans records that should be firmed.</param>
    internal void initFromReqTransMap(Map _mapReqTransMark)
    {
        this.getLast();
        this.parmReqRefType(ReqRefType::None);
        this.parmConReqTransMark(_mapReqTransMark.pack());
        this.parmStartMultiThreadedRun(NoYes::No);
        this.initParmDefault();

        this.init();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedSalesReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the reference of the purchase line on to the sales line.
    /// </summary>
    /// <param name="_purchLine">
    /// The <c>PurchLine</c> record from which sales line references must be set.
    /// </param>
    public void updateMarkedSalesReferences(PurchLine _purchLine)
    {
        ttsBegin;
        var salesLine = SalesLine::findInventTransId(_purchLine.InventRefTransId, true);
        salesLine.InventRefId = _purchLine.PurchId;
        salesLine.InventRefTransId = _purchLine.InventTransId;
        salesLine.InventRefType = InventRefType::Purch;
        salesLine.update();
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStartMultiThreadedRun</Name>
				<Source><![CDATA[
    internal NoYes parmStartMultiThreadedRun(NoYes _startMultiThreadedRun = startMultiThreadedRun)
    {
        startMultiThreadedRun = _startMultiThreadedRun;
        return startMultiThreadedRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaxChildThreads</Name>
				<Source><![CDATA[
    internal NoYes parmMaxChildThreads(NoYes _maxChildThreads = maxChildThreads)
    {
        maxChildThreads = _maxChildThreads;
        return maxChildThreads;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSortingByLevelNeeded</Name>
				<Source><![CDATA[
    public boolean parmIsSortingByLevelNeeded(boolean _isSortingByLevelNeeded = isSortingByLevelNeeded)
    {
        isSortingByLevelNeeded = _isSortingByLevelNeeded;
        return isSortingByLevelNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsKanbanRuleAutoPlanningDeferred</Name>
				<Source><![CDATA[
    public boolean parmIsKanbanRuleAutoPlanningDeferred(boolean _isKanbanRuleAutoPlanningDeferred = isKanbanRuleAutoPlanningDeferred)
    {
        isKanbanRuleAutoPlanningDeferred = _isKanbanRuleAutoPlanningDeferred;
        return isKanbanRuleAutoPlanningDeferred;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIgnoreUnhandledUpdateConflicts</Name>
				<Source><![CDATA[
    public boolean parmIgnoreUnhandledUpdateConflicts(boolean _ignoreUnhandledUpdateConflicts = ignoreUnhandledUpdateConflicts)
    {
        ignoreUnhandledUpdateConflicts = _ignoreUnhandledUpdateConflicts;
        return ignoreUnhandledUpdateConflicts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAsPartOfBiggerRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the instance of the class to be a part of a bigger firming run.
    /// </summary>
    /// <param name = "_firmingRunId">The firming run id of the run that should be associated with the instance of the class.</param>
    /// <param name = "_isMultiThreaded">Indicates whether other firming processes connected to the same firming run can be running while the firming is done by this instance of the class.</param>
    internal void setAsPartOfBiggerRun(ReqFirmingRunId _firmingRunId, boolean _isMultiThreaded = false)
    {
        isPartOfBiggerRun = true;
        firmingRunId = _firmingRunId;
        isPartOfMultithreadedRun = _isMultiThreaded;
        processedOrdersData.setAsPartOfBiggerRun(_firmingRunId);
        abortIfErrors = false; // we do not support the "Stop firming if an error occurs" functionality in this case
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirmedOrderCount</Name>
				<Source><![CDATA[
    public ReqNumOfTrans getFirmedOrderCount()
    {
        return firmedOrderCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates purchase line supply as part of firming planned purchase order line
    /// </summary>
    /// <param name="_reqTrans">
    /// A <c>reqTrans</c> that represents planned purchase order supply transaction.
    /// </param>
    /// <param name="_reqPO">
    /// A <c>reqPO</c> that represents planned purchase order supply.
    /// </param>
    /// <param name="_purchaseLine">
    /// A <c>PurchLine</c> that represents actual purchase order line.
    /// </param>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> that represents marked sales order line demand used in project accounting
    /// </param>
    protected void updatePurchLine(ReqTrans _reqTrans, ReqPO _reqPO, PurchLine _purchaseLine, SalesLine _salesLine = null)
    {
        // Update reqTrans as purchline
        this.updateFirmedReqTrans(_reqTrans, _reqPO, ReqRefType::Purch, _purchaseLine.PurchId, InventTransOriginPurchLine::findInventTransOriginId(_purchaseLine.DataAreaId, _purchaseLine.InventTransId));
        ReqRequisitionsHelper::updateRequisitionLinesFromFirmedReqTrans(_reqTrans);

        // Auto reserve settled issues
        if (!_purchaseLine.InventRefTransId)
        {
            this.updateInventReference(_reqTrans);
        }

        flush PurchLine;
        _purchaseLine = PurchLine::findRecId(_purchaseLine.RecId);

        if (   _purchaseLine.ItemRefType == InventRefType::Sales
        && _purchaseLine.InventRefTransId
        && _purchaseLine.purchTable().isInterCompanyOrder())
        {
            this.interCompanySynchronize(_purchaseLine);
        }
    
        if (_salesLine
        && _reqTrans.MarkingRefInventTransOrigin
        && _purchaseLine.ItemRefType == InventRefType::Sales)
        {
            //update the purch references on the marked sales transaction
            this.updateMarkedSalesReferences(_purchaseLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseLineReferences</Name>
				<Source><![CDATA[
    private void updatePurchaseLineReferences(PurchLine _purchLine)
    {
        if (_purchLine.ItemRefType == InventRefType::Sales && _purchLine.InventRefTransId)
        {
            SalesLine salesLine = SalesLine::findInventTransId(_purchLine.InventRefTransId, true);

            if (salesLine && salesLine.InventDimId != _purchLine.InventDimId)
            {
                ttsbegin;
                salesLine.setInventDimId(_purchLine.InventDimId);

                salesLine.update();

                // Update marking
                InventTransOrigin::updateMarking(
                    InventTransOrigin::findByInventTransId(_purchLine.InventTransId).RecId,
                    InventTransOrigin::findByInventTransId(salesLine.InventTransId).RecId,
                    _purchLine.PurchQty,
                    '',
                    SortOrder::Ascending,
                    false,
                    _purchLine.inventDim(),
                    InventMovement::construct(_purchLine).markingInventDimParmFixed(),
                    _purchLine.PdsCWQty);

                InventUpd_Reservation::updateReserveRefTransId(InventMovement::construct(salesLine));

                ttscommit;
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>getParametersForTelemetry</Name>
				<Source><![CDATA[
    private SysInstrumentationAdditionalParameters getParametersForTelemetry()
    {
        var instrumentationAdditionalParameters = SysInstrumentationAdditionalParameters::construct()
            .addIsBatchParameter(this.inBatch)
            .add(ReqInstrumentationActivities::ParmIsStartedFromUI, int2Str(this.isStartedFromUI))
            .add(ReqInstrumentationActivities::ParmUpdateMarking, enum2Symbol(enumNum(ReqMarkUpdate), this.reqMarkUpdate))
            .add(ReqInstrumentationActivities::ParmIsGroupByPlanningPriority, int2Str(this.collectPerPlanningPriority))
            .add(ReqInstrumentationActivities::ParmIsTransferGroupByPlanningPriority, int2Str(this.collectPerPlanningPriorityTransfer))
            .add(ReqInstrumentationActivities::ParmIsGroupByVendor, int2Str(this.collectPerVendor))
            .add(ReqInstrumentationActivities::ParmIsGroupByBuyerGroup, int2Str(this.collectPerBuyer))
            .add(ReqInstrumentationActivities::ParmGroupByPeriodPurchase, enum2Symbol(enumNum(ReqPoCollectPerPeriod), this.collectPerPeriodPurch))
            .add(ReqInstrumentationActivities::ParmGroupByPeriodJournal, enum2Symbol(enumNum(ReqPoCollectPerPeriod), this.collectPerPeriodJournal))
            .add(ReqInstrumentationActivities::ParmIsGroupByPurchaseAgreement, int2Str(this.collectPerPurchAgreement))
            .add(ReqInstrumentationActivities::ParmIsAbortIfErrors, int2Str(this.abortIfErrors));

        return instrumentationAdditionalParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePurchaseDialogTab</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes dialog fields of purchase order dialog group
    /// </summary>
    protected void initializePurchaseDialogTab()
    {
        dialog.addGroup("@SYS25204");

        dialogCollectPerVendor  = dialog.addFieldValue(extendedTypeStr(ReqPOCollectPerVendor), collectPerVendor);
        dialogCollectPerBuyer   = dialog.addFieldValue(extendedTypeStr(ReqPOCollectPerBuyer), collectPerBuyer);

        if (searchPurchAgreement)
        {
            dialogCollectPerPurchAgreement  = dialog.addFieldValue(extendedTypeStr(ReqPOCollectPerPurchAgreement), collectPerPurchAgreement);
            // Register overridden event handler for modified event of dialogCollectPerVendor check box
            dialogCollectPerVendor.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(ReqTransPoMarkFirm, dialogCollectPerVendor_modified), this);
        }

        dialogCollectPerPeriodPurch = dialog.addFieldValue(enumStr(ReqPoCollectPerPeriod), collectPerPeriodPurch);
        
        if (ReqPriorityBasedPlanningFeature::instance().isEnabled())
        {
            dialogCollectPerPlanningPriority = dialog.addFieldValue(extendedTypeStr(ReqPOCollectPerPlanningPriority), collectPerPlanningPriority);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransferDialogTab</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes dialog fields of transfer dialog group
    /// </summary>
    protected void initializeTransferDialogTab()
    {
        dialog.addGroup("@SYS54545");

        dialogCollectPerPeriodJournal = dialog.addFieldValue(enumStr(ReqPoCollectPerPeriod), collectPerPeriodJournal);

        if (ReqPriorityBasedPlanningFeature::instance().isEnabled())
        {
            dialogCollectPerPlanningPriorityTransfer = dialog.addFieldValue(extendedTypeStr(ReqPOCollectPerPlanningPriorityTransfer), collectPerPlanningPriorityTransfer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProdPurchCreateParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>ProdPurchCreateParameters</c> parameter class instance.
    /// </summary>
    /// <param name = "_vendId">Vendor account to search with (<c>parmVendAccount</c>).</param>
    /// <param name = "_purchaseType">Purchase type to search with (<c>parmPurchaseType</c>).</param>
    /// <param name = "_deliveryDate">Delivery date to search with (<c>parmDeliveryDate</c>).</param>
    /// <param name = "_agreementId">Agreement ID to search with (<c>parmAgreementId</c>).</param>
    /// <param name = "_interCompanySilent">Inter company silent flag to search with (<c>parmInterCompanySilent</c>).</param>
    /// <param name = "_projId">Project ID to search with (<c>parmProjId</c>).</param>
    /// <param name = "_salesId">Sales ID to search with (<c>parmSalesId</c>).</param>
    /// <returns>An instance of the <c>ProdPurchCreateParameters</c> class.</returns>
    protected ProdPurchCreateParameters instantiateProdPurchCreateParameters(VendAccount      _vendId,
                                                                            PurchaseType     _purchaseType,
                                                                            DlvDate          _deliveryDate,
                                                                            PurchAgreementId _agreementId = '',
                                                                            boolean          _interCompanySilent = false,
                                                                            ProjId           _projId = '',
                                                                            SalesId          _salesId = '')
    {
        ProdPurchCreateParameters prodPurchCreateParameters = ProdPurchCreateParameters::construct();

        prodPurchCreateParameters.parmVendAccount(_vendId);
        prodPurchCreateParameters.parmPurchaseType(_purchaseType);
        prodPurchCreateParameters.parmDeliveryDate(_deliveryDate);
        prodPurchCreateParameters.parmAgreementId(_agreementId);
        prodPurchCreateParameters.parmInterCompanySilent(_interCompanySilent);
        prodPurchCreateParameters.parmProjId(_projId);
        prodPurchCreateParameters.parmSalesId(_salesId);

        return prodPurchCreateParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a purch table record.
    /// </summary>
    /// <param name = "_vendId">Vendor account to search with (<c>parmVendAccount</c>).</param>
    /// <param name = "_purchaseType">Purchase type to search with (<c>parmPurchaseType</c>).</param>
    /// <param name = "_deliveryDate">Delivery date to search with (<c>parmDeliveryDate</c>).</param>
    /// <param name = "_agreementId">Agreement ID to search with (<c>parmAgreementId</c>).</param>
    /// <param name = "_interCompanySilent">Inter company silent flag to search with (<c>parmInterCompanySilent</c>).</param>
    /// <param name = "_projId">Project ID to search with (<c>parmProjId</c>).</param>
    /// <param name = "_salesId">Sales ID to search with (<c>parmSalesId</c>).</param>
    /// <returns>Purchase ID of the new purchase order.</returns>
    protected PurchId insertPurchTable(VendAccount      _vendId,
                                    PurchaseType     _purchaseType,
                                    DlvDate          _deliveryDate,
                                    PurchAgreementId _agreementId = '',
                                    boolean          _interCompanySilent = false,
                                    ProjId           _projId = '',
                                    SalesId          _salesId = '')
    {
        ProdPurchCreateParameters prodPurchCreateParameters = this.instantiateProdPurchCreateParameters(_vendId, _purchaseType, _deliveryDate, _agreementId, _interCompanySilent, _projId, _salesId);
        ProdPurchCreate prodPurchCreate                     = this.instantiateProdPurchCreate(prodPurchCreateParameters);

        return prodPurchCreate.createPurchTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProdPurchCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of the <c>ProdPurchCreate</c> class.
    /// </summary>
    /// <param name = "_prodPurchCreateParameters">
    /// The instance of the <c>ProdPurchCreateParameters</c> class
    /// </param>
    /// <returns>
    /// The instance of the <c>ProdPurchCreate</c> class
    /// </returns>
    protected ProdPurchCreate instantiateProdPurchCreate(ProdPurchCreateParameters _prodPurchCreateParameters)
    {
        return ProdPurchCreate::construct(_prodPurchCreateParameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areMarkedElementsKnownUpfront</Name>
				<Source><![CDATA[
    /// <summary>
    /// Informs whether the set of orders to firm is known upfront.
    /// </summary>
    /// <returns>
    /// True if the number of orders is known; false otherwise (e.g. when the actual set will be determined by running a query later).
    /// </returns>
    protected boolean areMarkedElementsKnownUpfront()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBomRouteDimension</Name>
				<Source><![CDATA[
    private void updateBomRouteDimension(ProdId _prodID, LedgerDefaultDimensionValueSet _defaultDimension)
    {
        if (_defaultDimension)
        {
            ttsbegin;
            ProdBOM prodBOM;
            while select forupdate prodBOM
                where prodBOM.ProdId == _prodID
            {
                prodBOM.DefaultDimension = prodBOM.mergeDimension(prodBOM.DefaultDimension, _defaultDimension);
                prodBOM.update();
            }
            ttscommit;

            ttsbegin;
            ProdRoute prodRoute;
            while select forupdate prodRoute
                where prodRoute.ProdId == _prodID
            {
                prodRoute.DefaultDimension = prodRoute.mergeDimension(prodRoute.DefaultDimension, _defaultDimension);
                prodRoute.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectParamInProdBom</Name>
				<Source><![CDATA[
    private void updateProjectParamInProdBom(ProdID _prodId)
    {
        ProdTable prodTableBOM;
        ProdBOM prodBOM;
        SalesLine salesLine;

        if(UpdateQueryForGettingProdBomFlight_ProjectPurch::instance().isEnabled())
        {
            while select forupdate prodBOM
            join prodTableBOM 
                where prodTableBOM.ProdId == _prodId
                    && prodTableBOM.ProdId == prodBOM.ProdId
            join salesLine 
                where salesLine.InventRefId == prodTableBOM.ProdId 
                    && salesLine.InventRefTransId == prodTableBOM.InventTransId
            {
                if (prodBOM && prodTableBOM.isProjMethodConsumedAndLinkedToOrder())
                {
                    ttsbegin;
                    prodBOM.ProjId = salesLine.ProjId;
                    prodBOM.ProjCategoryId = salesLine.ProjCategoryId;
                    prodBOM.ProjLinePropertyId = salesLine.ProjLinePropertyId;
                    prodBOM.ProjSalesCurrencyId = salesLine.CurrencyCode;
                    prodBOM.ProjTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    prodBOM.update();
                    ttscommit;
                }
            }
        }
        else
        {
            ProdTable prodTable;
            while select forupdate prodBOM
            join prodTable
                where prodTable.ProdId == prodBOM.InventRefId
                    && prodTable.InventTransId == prodBOM.InventRefTransId
            join prodTableBOM
                where prodTableBOM.ProdId == prodTable.InventRefId
                    && prodTableBOM.ProdId == _prodId
            join salesLine
                where salesLine.InventRefId == prodTableBOM.ProdId
                    && salesLine.InventRefTransId == prodTableBOM.InventTransId
            {
                if (prodBOM && prodTableBOM.isProjMethodConsumedAndLinkedToOrder())
                {
                    ttsbegin;
                    prodBOM.ProjId = salesLine.ProjId;
                    prodBOM.ProjCategoryId = salesLine.ProjCategoryId;
                    prodBOM.ProjLinePropertyId = salesLine.ProjLinePropertyId;
                    prodBOM.ProjSalesCurrencyId = salesLine.CurrencyCode;
                    prodBOM.ProjTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    prodBOM.update();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePmfCheckApprovedFormulaForSingleTrans</Name>
				<Source><![CDATA[
	 private boolean validatePmfCheckApprovedFormulaForSingleTrans(ReqTrans _reqTrans)
    {
        boolean     ret = true;
        boolean     useDlvDateFlight = ReqTransPoMarkFirmUseDlvDateForBOMVersionFlight::instance().isEnabled();
        InventTable inventTable;
        BOMVersion  bomVersion;

        if (_reqTrans.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            inventTable = InventTable::find(_reqTrans.ItemId);
            if (inventTable.isFormulaAllowed())
            {
                TransDate bomDate = useDlvDateFlight ? _reqTrans.reqPo().getBomDate() : _reqTrans.ReqDate;
                bomVersion = BOMVersion::findApproved(
                                                    _reqTrans.ItemId,
                                                    _reqTrans.ItemBomId,
                                                    NoYes::Yes,
                                                    bomDate,
                                                    bomDate,
                                                    _reqTrans.Qty);
                if (!bomVersion.RecId)
                {
                    ret = false;
                    if (ReqTransPoMarkFirmNotApprovedFormulaErrorToggle::instance().isEnabled())
                    {
                        if (useDlvDateFlight)
                        {
                            ret = checkFailed(strFmt("@PRO:FormulaNotApprovedAsOfDateForBatchOrderError", _reqTrans.RefId, _reqTrans.ItemId, bomDate));
                        }
                        else
                        {
                            ret = checkFailed(strFmt("@PRO:FormulaNotApprovedForBatchOrderError", _reqTrans.RefId, _reqTrans.ItemId));
                        }
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    public void getLast()
    {
        super();

        if (ReqTransPoMarkFirmDialogMultiThreadedRunFlight::instance().isEnabled())
        {
            startMultiThreadedRun = false;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>