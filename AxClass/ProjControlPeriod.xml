<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjControlPeriod</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>ProjControlPeriod</c> class serves as the base class for handling estimates.
/// </summary>
class ProjControlPeriod extends RunBaseBatch implements BatchRetryable
{
    #OCCRetryCount

    ProjForecastModelId     forecastModelId;
    ProjForecastModelId     forecastModelIdOld;
    ProjEstimateMethod      projEstimateMethod;
    ProjControlCompletionMethod
                            projCompletionMethod;
    boolean                 checkControl;

    ProjPeriodFrom          periodFrom;
    ProjPeriodTo            periodTo;
    [FormObservable]
    ProjPeriodId            periodId;
    ProjControlId           controlId;
    ProjId                  projId;
    ProjWipId               wipProjId;
    ProjCostGroupId         costGroupId;
    ProjCostType            costType;
    NoYes                   eliminate;
    NoYes                   forecast;
    ProjTransDate           enterDate;
    boolean                 showQueryValues;
    boolean                 continuesPeriodes;
    ProjControlTypeOutput   outputResult;
    NoYes                   updateCalculation;
    NoYes                   outputInfolog;
    NoYes                   deleteForecast;
    NoYes                   markProjectAsFinished;
    NoYes                   markProjectAsInProcess;
    AcknowledgementDate     acknowledgementDate;
    NoYes                   postWIPWarnings;

    ProjBeginningBalance    beginningBalance;

    ProjControlPeriodTable  controlPeriodOld;

    AmountMST               ctcAmountCostGroup;
    UnitQty                 ctcUnitCostGroup;

    AmountMST               actualAmountCostGroup, actualAmountCostGroupCapitalize;
    UnitQty                 actualUnitCostGroup;

    AmountMST               committedAmountCostGroup;
    UnitQty                 committedUnitCostGroup;

    AmountMST               actualPeriodEndAmountCostGroup;
    UnitQty                 actualPeriodEndUnitCostGroup;

    AmountMST               committedPeriodEndAmountCostGroup;
    UnitQty                 committedPeriodEndUnitCostGroup;

    ProjControlVersion      projControlVersion;
    boolean                 periodic;
    Counter                 infoLogCounter;

    QueryRun                queryRun;

    TmpProjControlActual        tmpProjControlActual;
    TmpProjControlActualCost    tmpProjControlActualCost;

    ProjWIPTable            projWIPTable;
    ProjRevRecContractLine projRevRecContractLine;
    boolean                 isContractLineUsed;

    container projids;

    boolean                 isRecalc;
    ProjPeriodFrom          prevPeriodFrom;
    ProjControlVersion      prevVersion;

    AmountMST               amountfromforecast;
    UnitQty                 unitfromforecast;

    AmountMST               periodEndForecastCostAmount;
    UnitQty                 periodEndForecastCostUnit;

    AmountMST               currPeriodForecastCostAmount;
    UnitQty                 currPeriodForecastCostUnit;

    [SysObsolete("This variable is obsolete. Use projContractCurrencyForRevRecParmEnabled instead.", false, 10\6\2024)]
    boolean contractCurrencyRevRecCalculationFeature = ProjContractCurrencyForRevRecCalculationFeature::isEnabled();

    boolean multipleContractLinesFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
    private boolean projContractCurrencyForRevRecParmEnabled = ProjParameters::find().EnableContractCurrencyForRevRec;
    boolean projOpsEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled();
    boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();

    protected const str LoggerRetryExceptionMsg = '%1 retries exceeded max limit for %2 method. ProjWIPTable: %3';
    protected const str LoggerTTSLevelNotZeroExceptionMsg = '%1 ttsLevel <> 0 for %2 method. ProjWIPTable: %3';
    private boolean projControlPeriodMultipleBatchTasksFeature =
        FeatureStateProvider::isFeatureEnabled(ProjControlPeriodMultipleBatchTasksFeature::instance());
    private int subtasksNumForEstimate;
    private boolean skipCreateEstimateValidation;
    private ProjControlType projControlType;
    private ProjRevRecInstrumentationLogger logger;
    private boolean shouldExecuteBatchInMultiSubtasks;
    
    #define.CurrentVersion(26)
    #localmacro.CurrentList
        periodFrom,
        periodTo,
        eliminate,
        forecastModelId,
        forecastModelIdold,
        projControlVersion,
        WIPProjId,
        costGroupId,
        periodic,
        projWIPTable,
        forecast,
        enterDate,
        showQueryValues,
        periodId,
        continuesPeriodes,
        outputInfolog,
        outputResult,
        deleteForecast,
        updateCalculation,
        markProjectAsFinished,
        markProjectAsInProcess,
        projEstimateMethod,
        ProjCompletionMethod,
        acknowledgementDate,
        postWIPWarnings,
        beginningBalance,
        skipCreateEstimateValidation
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>action</Name>
				<Source><![CDATA[
    protected void action()
    {
        if (queryRun.changed(tableNum(ProjWIPTable)))
        {
            projWIPTable = queryRun.get(tableNum(ProjWIPTable));

            this.addEstimates(projWIPTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actual</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the actual variables that will be used to update the <c>ProjControlPeriodCostGroup</c>
    ///    buffer.
    /// </summary>
    /// <remarks>
    ///    This method is called by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void actual()
    {
        if (multipleContractLinesFeatureEnabled || (contractLineBasedRevRecFeature && isContractLineUsed))
        {
            this.actualWithMultipleContractLineFeature();
        }
        else
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId  == this.parmProjCostGroupId() &&
                    tmpProjControlActual.Type       == ProjControlActualCostType::Actual &&
                    tmpProjControlActual.Range      == ProjControlActualRange::CurrentPeriod;

            actualUnitCostGroup = tmpProjControlActual.qty;

            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type        == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range       == ProjControlActualRange::AfterPeriodEnd;

            actualPeriodEndUnitCostGroup = tmpProjControlActual.qty;

            select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range    == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId        == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId  == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type         == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range        == ProjControlActualRange::CurrentPeriod;

            actualAmountCostGroup           = tmpProjControlActualCost.CostAmount;
            actualAmountCostGroupCapitalize = tmpProjControlActualCost.Capitalize;

            select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range    == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId       == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type        == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range       == ProjControlActualRange::AfterPeriodEnd;

            actualPeriodEndAmountCostGroup  = tmpProjControlActualCost.CostAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualWithMultipleContractLineFeature</Name>
				<Source><![CDATA[
    private void actualWithMultipleContractLineFeature()
    {
        switch (this.parmProjCostType())
        {
            case ProjCostType::Hour:
                this.actualEmpl();
                break;

            case ProjCostType::Cost:
                this.actualCost();
                break;

            case ProjCostType::Item:
                this.actualItem();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualEmpl</Name>
				<Source><![CDATA[
    private void actualEmpl()
    {
        PSAContractLineItems contractLine;
        PSAContractLineItemsSetup contractLineAssoc;
        ProjTable projTableJoin;
        ProjWIPTable projWIPTableLocal;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod &&
                tmpProjControlActual.projId == this.parmProjWIPProjId()
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId()
                && ProjRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeHourTrans == NoYes::Yes
                && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == projRevRecContractLine.RevenueRecognitionId;
        }
        else
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualUnitCostGroup = tmpProjControlActual.qty;

        
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && ProjRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualPeriodEndUnitCostGroup = tmpProjControlActual.qty;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualAmountCostGroup = tmpProjControlActualCost.CostAmount;
        actualAmountCostGroupCapitalize = tmpProjControlActualCost.Capitalize;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where  contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeHourTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualPeriodEndAmountCostGroup = tmpProjControlActualCost.CostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualCost</Name>
				<Source><![CDATA[
    private void actualCost()
    {
        PSAContractLineItems contractLine;
        ProjTable projTableJoin;
        PSAContractLineItemsSetup contractLineAssoc;
        ProjWIPTable projWIPTableLocal;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualUnitCostGroup = tmpProjControlActual.qty;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice; 
        }
        else
        {
        select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }
        

        actualPeriodEndUnitCostGroup = tmpProjControlActual.qty;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
             exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualAmountCostGroup = tmpProjControlActualCost.CostAmount;
        actualAmountCostGroupCapitalize = tmpProjControlActualCost.Capitalize;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
           exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice; 
        }
        else
        {
        select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeExpenseTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualPeriodEndAmountCostGroup  = tmpProjControlActualCost.CostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualItem</Name>
				<Source><![CDATA[
    private void actualItem()
    {
        PSAContractLineItems contractLine;
        ProjTable projTableJoin;
        PSAContractLineItemsSetup contractLineAssoc;
        ProjWIPTable projWIPTableLocal;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualUnitCostGroup = tmpProjControlActual.qty;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
        select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
            select sum(Qty) from tmpProjControlActual
            where tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                  tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                  tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;

        }

        actualPeriodEndUnitCostGroup = tmpProjControlActual.qty;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(CostAmount), sum(Capitalize) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::CurrentPeriod
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::CurrentPeriod
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualAmountCostGroup = tmpProjControlActualCost.CostAmount;
        actualAmountCostGroupCapitalize = tmpProjControlActualCost.Capitalize;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
             exists join projWIPTableLocal
                where projWIPTableLocal.ProjId == tmpProjControlActual.projId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWIPTableLocal.projId
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
        }
        else
        {
        select sum(CostAmount) from tmpProjControlActualCost
            where tmpProjControlActualCost.Range == ProjControlActualRange::AfterPeriodEnd
            join RecId from tmpProjControlActual
                where tmpProjControlActual.RecId == tmpProjControlActualCost.RefRecID &&
                      tmpProjControlActual.CostGroupId == this.parmProjCostGroupId() &&
                      tmpProjControlActual.Type == ProjControlActualCostType::Actual &&
                      tmpProjControlActual.Range == ProjControlActualRange::AfterPeriodEnd
            exists join projTableJoin
                where projTableJoin.ProjId == tmpProjControlActual.projId
            exists join contractLine
                where contractLine.ProjInvoiceProjId == projTableJoin.projInvoiceProjId
                    && contractLine.IncludeItemTrans == NoYes::Yes
                    && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
            exists join contractLineAssoc
                where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum
                    && contractLineAssoc.ProjId == projTableJoin.ProjId;
        }

        actualPeriodEndAmountCostGroup = tmpProjControlActualCost.CostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualClear</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the actual fields in the <c>ProjControlPeriodCostGroup</c> buffer the actual variables that
    ///    will be used to update the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is called by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void actualClear(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        if (! this.parmCheck())
        {
            _projControlPeriodCostGroup.ActuelCostAmount             = 0;
            _projControlPeriodCostGroup.ActuelCostAmountCapitalized  = 0;
            _projControlPeriodCostGroup.ActuelCostUnit               = 0;
            _projControlPeriodCostGroup.ActualPeriodEndCostAmount    = 0;
            _projControlPeriodCostGroup.ActualPeriodEndCostUnit      = 0;
        }

        actualAmountCostGroup               = 0;
        actualAmountCostGroupCapitalize     = 0;
        actualUnitCostGroup                 = 0;
        actualPeriodEndAmountCostGroup       = 0;
        actualPeriodEndUnitCostGroup         = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualCreate</Name>
				<Source><![CDATA[
    void actualCreate(NoYes _updateWIPPeriod = true)
    {
        ProjControlActual projControlActual = new ProjControlActual(_updateWIPPeriod);

        // If project cost template is blank when initialized from the batch.
        // Cost template must set when recalculating estimate.
        if (!this.parmProjControlId())
        {
            this.parmProjControlId(projWIPTable.ControlId);
        }

        projControlActual.parmProjControlId(this.parmProjControlId());
        projControlActual.parmProjPeriodFrom(this.parmProjPeriodFrom());
        projControlActual.parmProjPeriodTo(this.parmProjPeriodTo());
        projControlActual.parmProjControlVersion(this.parmProjControlVersion());
        projControlActual.parmWIPProjId(this.parmProjWIPProjId());
        projControlActual.parmIsContractLineUsed(this.parmIsContractLineUsed());
        projControlActual.parmIncludeActual(true);
        projControlActual.parmIncludeCommitted(true);
        projControlActual.parmIncludeCurrentPeriod(true);
        projControlActual.parmIncludeAfterPeriodEnd(true);
        projControlActual.parmBeginningBalance(this.parmBeginningBalance());
        projControlActual.run();

        tmpProjControlActual.linkPhysicalTableInstance(projControlActual.tmpProjControlActual());
        tmpProjControlActualCost.linkPhysicalTableInstance(projControlActual.tmpProjControlActualCost());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePeriodTotals</Name>
				<Source><![CDATA[
    void calculatePeriodTotals()
    {
        ProjControlCalc controlCalc = this.createProjControlCalc();

        this.initializeProjControlCalc(controlCalc);

        controlCalc.run();

        if (this.checkCreatePeriod() && this.parmShowInfoLog() && !eliminate)
        {
            info(strFmt("@SYS55663",this.parmProjWIPTable().ProjId,this.parmProjPeriodTo(),this.parmProjControlVersion()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjControlCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>ProjControlCalc</c> class.
    /// </summary>
    /// <returns>
    /// The <c>ProjControlCalc</c> instance.
    /// </returns>
    protected ProjControlCalc createProjControlCalc()
    {
        ProjControlCalc controlCalc;
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            controlCalc = ProjControlCalc::constructFromWIPProjectOrRevenueProfile(ProjWIPTable::find(projWIPTable.projId), eliminate, ProjContractBillingMethod::FixedPrice);
        }
        else
        {
            controlCalc = ProjControlCalc::constructFromProjGroupOrRevenueProfile(ProjTable::find(projWIPTable.projId), eliminate, ProjContractBillingMethod::FixedPrice);
        }
        return controlCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjControlCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ProjControlCalc</c> instance
    /// </summary>
    /// <param name = "_controlcalc">
    /// The <c>ProjControlCalc</c> instance.
    /// </param>
    protected void initializeProjControlCalc(ProjControlCalc  _controlcalc)
    {
        _controlCalc.parmControlId(this.parmProjWIPTable().ControlId);
        _controlCalc.parmEliminate(eliminate);
        _controlCalc.parmPeriodFrom(this.parmProjPeriodFrom());
        _controlCalc.parmPeriodTo(this.parmProjPeriodTo());
        _controlCalc.parmProjId(this.parmProjWIPTable().ProjId);
        _controlCalc.parmControlVersion(this.parmProjControlVersion());
        _controlCalc.parmBeginningBalance(this.parmBeginningBalance());
        _controlCalc.parmIsContractLineUsed(this.parmProjWIPTable().IsContractLineUsed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Checks if the user is trying to create estimate for a period which is greater than the last posted estimate period.
    /// </summary>
    /// <returns>
    /// True if can create a new estimate, otherwise False.
    /// </returns>
    private boolean canCreate()
    {
        // Return false if there is a record for period > the period of new estimate
        return (select firstonly projControlPeriodTable
                    where   projControlPeriodTable.ProjId       == projWIPTable.ProjId
                    &&      projControlPeriodTable.PeriodStatus != ProjControlPeriodStatus::Reversal
                    &&      projControlPeriodTable.PeriodFrom   > this.parmProjPeriodFrom()).RecId ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateCostGroup</Name>
				<Source><![CDATA[
    protected boolean canCreateCostGroup()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true.
    /// </summary>

    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// This method must be in this class because it is called from the <c>DialogRunbase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOutput</Name>
				<Source><![CDATA[
    boolean canOutput()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateCostGroup</Name>
				<Source><![CDATA[
    protected boolean canUpdateCostGroup()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    private void check(ProjControlPeriodCostGroup projControlPeriodCostGroup)
    {
        boolean     ok = true;
        LogText     errortext;

        ok = this.difference(projControlPeriodCostGroup);

        if (ok)
        {
            projControlPeriodCostGroup.ErrorText = '';
        }
        else
        {
            errortext = Info::infoCon2Str(infolog.copy(infoLogCounter+1,infolog.num()));

            projControlPeriodCostGroup.ErrorText = errortext;
            infoLogCounter = infologLine();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCloseDialog</Name>
				<Source><![CDATA[
    public boolean checkCloseDialog(Object _calledFrom = null)
    {
        boolean ret;

        if (_calledFrom.name() == formStr(sysQueryForm))
        {
            // Don't call super()
            return true;
        }

        ret = super(_calledFrom);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCostGroupUpdate</Name>
				<Source><![CDATA[
    public boolean checkCostGroupUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreatePeriod</Name>
				<Source><![CDATA[
    boolean checkCreatePeriod()
    {
        boolean ret = this.checkCostGroupUpdate();

        return !ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearWIPPeriod</Name>
				<Source><![CDATA[
    void clearWIPPeriod()
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            // Clear WIP Period on cost trans
            ProjCostTrans::clearWIPPeriodContractLine(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

            // Clear WIP Period on empl trans
            ProjEmplTrans::clearWIPPeriodContractLine(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

            // Clear WIP Period on item trans
            ProjItemTransCost::clearWIPPeriodContractLine(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

            // Clear WIP Period on On account trans
            ProjOnAccTrans::clearWIPPeriodContractLine(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

        }
        else
        {
        // Change required
        // Clear WIP Period on cost trans
        ProjCostTrans::clearWIPPeriod(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

        // Clear WIP Period on empl trans
        ProjEmplTrans::clearWIPPeriod(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

        // Clear WIP Period on item trans
        ProjItemTransCost::clearWIPPeriod(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

        // Clear WIP Period on On account trans
        ProjOnAccTrans::clearWIPPeriod(projWIPTable.ProjId,this.parmProjPeriodTo(), this.parmBeginningBalance());

        // Clear WIP Period on committed trans
        CostControlTransCommittedCost::clearWIPPeriod(projWIPTable.ProjId,this.parmProjPeriodTo());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>committed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the committed variables that will be used to update the <c>ProjControlPeriodCostGroup</c>
    ///    buffer.
    /// </summary>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void committed()
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return;
        }
        while select tmpProjControlActual
            where   tmpProjControlActual.CostGroupId  == this.parmProjCostGroupId() &&
                    tmpProjControlActual.Type == ProjControlActualCostType::Committed
        {
            switch (tmpProjControlActual.Range)
            {
                case ProjControlActualRange::CurrentPeriod:
                    committedUnitCostGroup             += tmpProjControlActual.Qty;
                    break;

                case ProjControlActualRange::AfterPeriodEnd:
                    committedPeriodEndUnitCostGroup             += tmpProjControlActual.Qty;
                    break;
            }

            while select tmpProjControlActualCost
                where tmpProjControlActualCost.RefRecID == tmpProjControlActual.RecId
            {
                switch (tmpProjControlActualCost.Range)
                {
                    case ProjControlActualRange::CurrentPeriod:
                        committedAmountCostGroup           += tmpProjControlActualCost.CostAmount;
                        break;

                    case ProjControlActualRange::AfterPeriodEnd:
                        committedPeriodEndAmountCostGroup           += tmpProjControlActualCost.CostAmount;
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>committedClear</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the committed fields in the <c>ProjControlPeriodCostGroup</c> buffer and the committed
    ///    variables that will be used to update the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void committedClear(ProjControlPeriodCostGroup    _projControlPeriodCostGroup)
    {

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return;
        }

        if (! this.parmCheck())
        {
            _projControlPeriodCostGroup.CommittedCostAmount             = 0;
            _projControlPeriodCostGroup.CommittedCostUnit               = 0;

            _projControlPeriodCostGroup.CommittedPeriodEndCostAmount    = 0;
            _projControlPeriodCostGroup.CommittedPeriodEndCostUnit      = 0;
        }

        committedAmountCostGroup             = 0;
        committedUnitCostGroup               = 0;

        committedPeriodEndAmountCostGroup    = 0;
        committedPeriodEndUnitCostGroup      = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>controlPeriodOld</Name>
				<Source><![CDATA[
    ProjControlPeriodTable controlPeriodOld(boolean set = false)
    {
        if (set)
        {
            select reverse controlPeriodOld
                order by PeriodFrom
                where   controlPeriodOld.ProjId     == this.parmProjWIPTable().ProjId
                &&      controlPeriodOld.ControlId  == this.parmProjWIPTable().ControlId
                &&      controlPeriodOld.PeriodFrom <  this.parmProjPeriodFrom();
        }

        return controlPeriodOld;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimate</Name>
				<Source><![CDATA[
    private void copyEstimate()
    {
        ProjTable   projTable;
        ProjRevRecContractLine revRecContractLine;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            while select ContractLineNum from revRecContractLine
            where    revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId()
            {
                this.copyEstimateEmplContractLine(revRecContractLine.ContractLineNum);
                this.copyEstimateCostContractLine(revRecContractLine.ContractLineNum);
                this.copyEstimateItemContractLine(revRecContractLine.ContractLineNum);
            }
        }
        else
        {
        while select ProjId from projTable
            where    projTable.wipProject == this.parmProjWIPProjId()
        {
            this.copyEstimateEmpl(projTable.ProjId);
            this.copyEstimateCost(projTable.ProjId);
            this.copyEstimateItem(projTable.ProjId);
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimateCost</Name>
				<Source><![CDATA[
    private void copyEstimateCost(ProjId    _projId)
    {
        ProjForecastCost              projForecastCostOld;
        ProjForecastCost              projForecastCostNew;

        while select projForecastCostOld
            where projForecastCostOld.ProjId  == _projId    &&
                  projForecastCostOld.Active  == NoYes::Yes &&
                  projForecastCostOld.ModelId == this.parmForcastModelold()
        {
            projForecastCostNew.data(projForecastCostOld);
            projForecastCostNew.ModelId   = this.parmForecastModelId();

            projForecastCostNew.initSchedFromDateToSourceActivity();

            if (projForecastCostNew.validateWrite())
            {
                projForecastCostNew.TransId = '';
                projForecastCostNew.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimateCostContractLine</Name>
				<Source><![CDATA[
    private void copyEstimateCostContractLine(PSAContractLineNum    _contractLineNum)
    {
        ProjForecastCost              projForecastCostOld;
        ProjForecastCost              projForecastCostNew;

        while select projForecastCostOld
            where projForecastCostOld.ContractLineId  == _contractLineNum    &&
                  projForecastCostOld.Active  == NoYes::Yes &&
                  projForecastCostOld.ModelId == this.parmForcastModelold()
        {
            projForecastCostNew.data(projForecastCostOld);
            projForecastCostNew.ModelId   = this.parmForecastModelId();

            projForecastCostNew.initSchedFromDateToSourceActivity();

            if (projForecastCostNew.validateWrite())
            {
                projForecastCostNew.TransId = '';
                projForecastCostNew.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimateEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies all <c>ProjForecastEmpl</c> records to the new forecast model.
    /// </summary>
    /// <param name="_projId">
    /// The ID of the project to copy.
    /// </param>
    private void copyEstimateEmpl(ProjId    _projId)
    {
        ProjForecastEmpl  projForecastEmplOld;
        ProjForecastEmpl  projForecastEmplNew;

        while select projForecastEmplOld
            where projForecastEmplOld.ProjId  == _projId        &&
                  projForecastEmplOld.Active  == NoYes::Yes     &&
                  projForecastEmplOld.ModelId == this.parmForcastModelold()
        {
            projForecastEmplNew.data(projForecastEmplOld);
            projForecastEmplNew.ModelId   = this.parmForecastModelId();

            //To skip the resource validation for the <c>ProjForecastEmpl</c> records created from project budget
            if (projForecastEmplNew.ProjForecastBudgetType != ProjForecastBudgetType::None)
            {
                projForecastEmplNew.ResourceValidationSkipped = NoYes::Yes;
            }

            projForecastEmplNew.initSchedFromDateToSourceActivity();

            if (projForecastEmplNew.validateWrite())
            {
                projForecastEmplNew.TransId = '';
                projForecastEmplNew.insert();

                //Copy activity requirements
                WrkCtrActivityRequirementSet::copyRequirements(projForecastEmplOld.activity(), projForecastEmplNew.activity());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimateEmplContractLine</Name>
				<Source><![CDATA[
    private void copyEstimateEmplContractLine(PSAContractLineNum    _contractLineNum)
    {
        ProjForecastEmpl  projForecastEmplOld;
        ProjForecastEmpl  projForecastEmplNew;

        while select projForecastEmplOld
            where projForecastEmplOld.ContractLineId  == _contractLineNum        &&
                  projForecastEmplOld.Active  == NoYes::Yes     &&
                  projForecastEmplOld.ModelId == this.parmForcastModelold()
        {
            projForecastEmplNew.data(projForecastEmplOld);
            projForecastEmplNew.ModelId   = this.parmForecastModelId();

            //To skip the resource validation for the <c>ProjForecastEmpl</c> records created from project budget
            if (projForecastEmplNew.ProjForecastBudgetType != ProjForecastBudgetType::None)
            {
                projForecastEmplNew.ResourceValidationSkipped = NoYes::Yes;
            }

            projForecastEmplNew.initSchedFromDateToSourceActivity();

            if (projForecastEmplNew.validateWrite())
            {
                projForecastEmplNew.TransId = '';
                projForecastEmplNew.insert();

                //Copy activity requirements
                WrkCtrActivityRequirementSet::copyRequirements(projForecastEmplOld.activity(), projForecastEmplNew.activity());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimateItem</Name>
				<Source><![CDATA[
    private void copyEstimateItem(ProjId    _projId)
    {
        ForecastSales  forecastSalesOld;
        ForecastSales  forecastSalesNew;

        while select forecastSalesOld
            where forecastSalesOld.ProjId  == _projId       &&
                  forecastSalesOld.Active  == NoYes::Yes    &&
                  forecastSalesOld.ModelId == this.parmForcastModelold()
        {
            forecastSalesNew.data(forecastSalesOld);
            forecastSalesNew.ModelId   = this.parmForecastModelId();
            if (forecastSalesNew.validateWrite())
            {
                forecastSalesNew.ProjTransId = '';
                forecastSalesNew.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyEstimateItemContractLine</Name>
				<Source><![CDATA[
    private void copyEstimateItemContractLine(PSAContractLineNum    _contractLineNum)
    {
        ForecastSales  forecastSalesOld;
        ForecastSales  forecastSalesNew;

        while select forecastSalesOld
            where forecastSalesOld.ContractLineId  == _contractLineNum       &&
                  forecastSalesOld.Active  == NoYes::Yes    &&
                  forecastSalesOld.ModelId == this.parmForcastModelold()
        {
            forecastSalesNew.data(forecastSalesOld);
            forecastSalesNew.ModelId   = this.parmForecastModelId();
            if (forecastSalesNew.validateWrite())
            {
                forecastSalesNew.ProjTransId = '';
                forecastSalesNew.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costGroupInsert</Name>
				<Source><![CDATA[
    private void costGroupInsert()
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;
        ProjControlPeriodTable      projControlPeriod = ProjControlPeriodTable::find(
                                                            this.parmProjWIPTable().ProjId,
                                                            this.parmProjWIPTable().ControlId,
                                                            this.parmProjPeriodFrom(),
                                                            this.parmProjControlVersion(),
                                                            true);

        RecordInsertList            insertList;

        insertList = new RecordInsertList(tableNum(ProjControlPeriodCostGroup));

        while select projControlCostGroup
            where   projControlCostGroup.ControlId  == this.parmProjWIPTable().ControlId
        {
            projControlPeriodCostGroup.clear();
            projControlPeriodCostGroup.initFromControlCostGroup(projControlCostGroup);
            projControlPeriodCostGroup.ProjId               = this.parmProjWIPTable().ProjId;
            projControlPeriodCostGroup.Version              = this.parmProjControlVersion();
            projControlPeriodCostGroup.PeriodFrom           = this.parmProjPeriodFrom();
            insertList.add(projControlPeriodCostGroup);
        }

        insertList.insertDatabase();
        if (!this.parmIsProjPeriodContolTableRecalculated())
        {
            projControlPeriod.Recalculated = NoYes::Yes;
            projControlPeriod.update();
            this.parmIsProjPeriodContolTableRecalculated(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costGroupUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_costGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void costGroupUpdate(ProjControlPeriodCostGroup _costGroup)
    {
        ProjControlPeriodCostGroup  prevCostGroup;
        ProjControlPeriodTable      projControlPeriodTableLocal;
        ProjPeriodFrom              locPrevPeriodFrom;
        ProjControlVersion          locPrevVersion;

        if (! this.parmCheck())
        {
            this.costGroupUpdateSetAmounts(_costGroup);

            if (this.canCreateCostGroup() || this is ProjControlPeriodEliminate)//Estimate is being created or eliminated
            {
                projControlPeriodTableLocal = ProjControlPeriodTable::findLastPosted(this.parmProjWIPTable().ProjId, this.parmProjControlId());

                locPrevPeriodFrom = projControlPeriodTableLocal.PeriodFrom;
                locPrevVersion = projControlPeriodTableLocal.Version;
                if (locPrevPeriodFrom && locPrevVersion)
                {
                    _costGroup.Contract = ProjControlPeriodCostGroup::prevCostGroup(_costGroup.ProjId,
                            _costGroup.ControlId,
                            locPrevPeriodFrom,
                            locPrevVersion,
                            _costGroup.CostGroupId).Contract;
                }
                else //there is no previous posted transaction
                {
                    // check if the first estimate is reversed
                    prevCostGroup=ProjControlPeriodCostGroup::prevCostGroup(_costGroup.ProjId,
                        _costGroup.ControlId,
                        _costGroup.PeriodFrom,
                        _costGroup.Version - 1,
                        _costGroup.CostGroupId);

                    if (prevCostGroup
                    && prevCostGroup.projControlPeriod().PeriodStatus ==ProjControlPeriodStatus::Reversal)
                    {
                        _costGroup.Contract = prevCostGroup.Contract; //copy from the reversal transaction
                    }
                }
            }

            switch (_costGroup.ctcMethod)
            {
                case ProjControlPeriodCostGroupCTCMethod::TotalEstimateActual://Set cost to complete to zero
                    _costGroup.setCTCToZero();
                    break;
                case ProjControlPeriodCostGroupCTCMethod::TotalEstimate://Total cost - Actual
                        if (this.canCreateCostGroup())//Estimate is being created
                    {
                        if (!this.parmPrevPeriodFrom() || !this.parmPrevVersion())
                        {
                            this.parmPrevPeriodFrom(locPrevPeriodFrom);
                            this.parmPrevVersion(locPrevVersion);
                        }

                        if (this.parmPrevPeriodFrom() && this.parmPrevVersion())
                        {
                            _costGroup.totalCostMinusActual(
                                ProjControlPeriodCostGroup::prevCostGroup(_costGroup.ProjId,
                                    _costGroup.ControlId,
                                    this.parmPrevPeriodFrom(),
                                    this.parmPrevVersion(),
                                    _costGroup.CostGroupId));
                        }
                        else //there is no previous posted transaction
                        {
                            // check if the first estimate is reversed
                            prevCostGroup=ProjControlPeriodCostGroup::prevCostGroup(_costGroup.ProjId,
                                _costGroup.ControlId,
                                _costGroup.PeriodFrom,
                                _costGroup.Version - 1,
                                _costGroup.CostGroupId);

                            if (prevCostGroup
                            && prevCostGroup.projControlPeriod().PeriodStatus ==ProjControlPeriodStatus::Reversal)
                            {
                                _costGroup.totalCostMinusActual(prevCostGroup); //copy from the reversal transaction
                            }
                        }
                    }
                    else if (this.canUpdateCostGroup())//Estimate is being recalculated/updated
                    {
                        _costGroup.totalCostMinusActualRecalc();
                    }
                    break;
                case ProjControlPeriodCostGroupCTCMethod::RemainingEstimate://Remaining budget
                    _costGroup.remainingBudget();
                    break;
                case ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage://cost to complete = total budget - actual
                case ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual://Total budget - Actual
                    _costGroup.totalBudgetMinusActual();
                    break;
            }

            _costGroup.ErrorText   = '';
        }
        else
        {
            this.check(_costGroup);
        }

        _costGroup.update(!this.parmCheck() && !this.parmIsProjPeriodContolTableRecalculated());
        if (!this.parmCheck() && !this.parmIsProjPeriodContolTableRecalculated())
        {
            this.parmIsProjPeriodContolTableRecalculated(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costGroupUpdateSetAmounts</Name>
				<Source><![CDATA[
    private void costGroupUpdateSetAmounts(ProjControlPeriodCostGroup _costGroup)
    {
        _costGroup.ActuelCostAmount              = actualAmountCostGroup;
        _costGroup.ActuelCostAmountCapitalized   = actualAmountCostGroupCapitalize;
        _costGroup.ActuelCostUnit                = actualUnitCostGroup;

        _costGroup.ForecastCostAmount            = amountfromforecast;
        _costGroup.ForecastCostUnit              = unitfromforecast;

        _costGroup.ActualPeriodEndCostAmount     = actualPeriodEndAmountCostGroup;
        _costGroup.ActualPeriodEndCostUnit       = actualPeriodEndUnitCostGroup;

        _costGroup.CommittedCostAmount           = committedAmountCostGroup;
        _costGroup.CommittedCostUnit             = committedUnitCostGroup;

        _costGroup.CommittedPeriodEndCostAmount  = committedPeriodEndAmountCostGroup;
        _costGroup.CommittedPeriodEndCostUnit    = committedPeriodEndUnitCostGroup;

        _costGroup.PeriodEndForecastCostAmount = periodEndForecastCostAmount;
        _costGroup.PeriodEndForecastCostUnit = periodEndForecastCostUnit;

        _costGroup.ForecastPeriodCostAmount = currPeriodForecastCostAmount;
        _costGroup.ForecastPeriodCostUnit = currPeriodForecastCostUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Cost To Complete (CTC) variables that will be used to check the
    /// <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    /// The <c>ProjControlPeriodCostGroup</c> buffer from which to update or read values.
    /// </param>
    /// <remarks>
    /// This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    protected void ctc(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::RemainingEstimate ||//Remaining budget
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual || //Total budget - Actual
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage)
        {
            switch (this.parmProjCostType())
            {
                case ProjCostType::Hour:
                    this.ctcEmpl(_projControlPeriodCostGroup);
                    break;

                case ProjCostType::Cost:
                    this.ctcCost(_projControlPeriodCostGroup);
                    break;

                case ProjCostType::Item:
                    this.ctcItem(_projControlPeriodCostGroup);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcClear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the Cost To Complete (CTC) fields in the <c>ProjControlPeriodCostGroup</c> buffer and the
    /// CTC variables that will be used to check the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    /// The <c>ProjControlPeriodCostGroup</c> buffer from which to update or read values.
    /// </param>
    /// <remarks>
    /// This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void ctcClear(ProjControlPeriodCostGroup    _projControlPeriodCostGroup)
    {
        if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::RemainingEstimate ||//Remaining budget
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual ||//Total budget - Actual
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage)
        {
            if (! this.parmCheck())
            {
                _projControlPeriodCostGroup.ctcCostAmount                   = 0;
                _projControlPeriodCostGroup.ctcCostUnit                     = 0;
            }

            ctcAmountCostGroup                   = 0;
            ctcUnitCostGroup                     = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Cost To Complete (CTC) variables that will be used to check the
    /// <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    /// The <c>ProjControlPeriodCostGroup</c> buffer from which to update or read values.
    /// </param>
    /// <remarks>
    /// This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void ctcCost(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        ProjTable           projTableJoin;
        ProjForecastCost    projForecastCost;
        ProjControlCategory projControlCategory;
        ProjTrans           projTrans;
        ProjRevRecContractLine revRecContractLine;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            if( multipleContractLinesFeatureEnabled)
            {
                PSAContractLineItems contractLine;
                while select revRecContractLine
                    where revRecContractLine.RevenueRecognitionId == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId     &&
                          projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join projForecastCost
                    where projForecastCost.ContractLineId   == revRecContractLine.ContractLineNum &&
                          projForecastCost.ModelId          == this.parmForecastModelId()			 &&
                          projForecastCost.CategoryId       == projControlCategory.CategoryId		 &&
                          projForecastCost.Active           == NoYes::Yes							 &&
                          projForecastCost.Report           == NoYes::Yes
                {
                    if (PSAContractLineItems::find(projForecastCost.ContractLineId).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        projTrans = ProjTrans::newProjForecastCost(projForecastCost);
                        this.ctcUpdate(projTrans);
                    }
                }
            }
            else
            {
                while select RecId from revRecContractLine
                    where revRecContractLine.RevenueRecognitionId    == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId  &&
                          projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  projForecastCost
                    where projForecastCost.ContractLineId   == revRecContractLine.ContractLineNum            &&
                          projForecastCost.ModelId          == this.parmForecastModelId()         &&
                          projForecastCost.CategoryId       == projControlCategory.CategoryId     &&
                          projForecastCost.Active           == NoYes::Yes                         &&
                          projForecastCost.Report           == NoYes::Yes

                {
                    projTrans  = ProjTrans::newProjForecastCost(projForecastCost);
                    this.ctcUpdate(projTrans);
                }
            }
        }
        
        else if (multipleContractLinesFeatureEnabled)
        {
            PSAContractLineItems contractLine;
            while select projTableJoin
                    where projTableJoin.wipProject == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId     &&
                          projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join projForecastCost
                    where projForecastCost.ProjId           == projTableJoin.ProjId					 &&
                          projForecastCost.ModelId          == this.parmForecastModelId()			 &&
                          projForecastCost.CategoryId       == projControlCategory.CategoryId		 &&
                          projForecastCost.Active           == NoYes::Yes							 &&
                          projForecastCost.Report           == NoYes::Yes
            {
                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(projTableJoin, projForecastCost.ContractLineId, ProjTransType::Cost, projOpsEnabled))
                {
                    projTrans = ProjTrans::newProjForecastCost(projForecastCost);
                    this.ctcUpdate(projTrans);
                }
            }
        }
        else
        {
            while select RecId from projTableJoin
                    where projTableJoin.wipProject          == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId  &&
                          projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  projForecastCost
                    where projForecastCost.ProjId           == projTableJoin.ProjId               &&
                          projForecastCost.ModelId          == this.parmForecastModelId()         &&
                          projForecastCost.CategoryId       == projControlCategory.CategoryId     &&
                          projForecastCost.Active           == NoYes::Yes                         &&
                          projForecastCost.Report           == NoYes::Yes

            {
                projTrans  = ProjTrans::newProjForecastCost(projForecastCost);
                this.ctcUpdate(projTrans);
            }
        }

        this.ctcUpdateBudget(_projControlPeriodCostGroup);

    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Cost To Complete (CTC) variables that will be used to check the
    /// <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    /// The <c>ProjControlPeriodCostGroup</c> buffer from which to update or read values.
    /// </param>
    /// <remarks>
    /// This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void ctcEmpl(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        ProjTable           projTableJoin;
        ProjForecastEmpl    projForecastEmpl;
        ProjControlCategory projControlCategory;
        ProjTrans           projTrans;
        ProjRevRecContractLine revRecContractLine;

        switch (_projControlPeriodCostGroup.ctcMethod)
        {
            case ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage:
                    if (_projControlPeriodCostGroup.CompletePct)
                {
                    [ctcAmountCostGroup, ctcUnitCostGroup] = this.getCTCEmplFromWBS();
                }
                break;
            default:
                if(contractLineBasedRevRecFeature && isContractLineUsed)
                {
                    if (multipleContractLinesFeatureEnabled)
                    {
                        while select revRecContractLine
                        where revRecContractLine.RevenueRecognitionId  == this.parmProjWIPTable().ProjId
                    join RecId from projControlCategory
                        where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId        &&
                              projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                    join	  projForecastEmpl
                        where projForecastEmpl.ContractLineId			== revRecContractLine.ContractLineNum &&
                              projForecastEmpl.ModelId			== this.parmForecastModelId()				&&
                              projForecastEmpl.CategoryId		== projControlCategory.CategoryId			&&
                              projForecastEmpl.Active           == NoYes::Yes								&&
                              projForecastEmpl.Report           == NoYes::Yes
                        {
                            if (PSAContractLineItems::find(projForecastEmpl.ContractLineId).BillingMethod == ProjContractBillingMethod::FixedPrice)
                            {
                                projTrans = ProjTrans::newProjForecastEmpl(projForecastEmpl);
                                this.ctcUpdate(projTrans);
                            }
                        }
                    }
                    else
                    {
                        while select RecId from revRecContractLine
                    where revRecContractLine.RevenueRecognitionId  == this.parmProjWIPTable().ProjId
                    join RecId from projControlCategory
                    where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId        &&
                          projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                    join  projForecastEmpl
                        where projForecastEmpl.ContractLineId         == revRecContractLine.ContractLineNum                   &&
                              projForecastEmpl.ModelId      == this.parmForecastModelId()               &&
                              projForecastEmpl.CategoryId   == projControlCategory.CategoryId           &&
                              projForecastEmpl.Active             == NoYes::Yes                         &&
                              projForecastEmpl.Report             == NoYes::Yes
                        {
                            projTrans = ProjTrans::newProjForecastEmpl(projForecastEmpl);
                            this.ctcUpdate(projTrans);
                        }
                    }

                }
                   else  if (multipleContractLinesFeatureEnabled)
                {
                    while select projTableJoin
                        where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
                    join RecId from projControlCategory
                        where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId        &&
                              projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                    join	  projForecastEmpl
                        where projForecastEmpl.ProjId			== projTableJoin.ProjId						&&
                              projForecastEmpl.ModelId			== this.parmForecastModelId()				&&
                              projForecastEmpl.CategoryId		== projControlCategory.CategoryId			&&
                              projForecastEmpl.Active           == NoYes::Yes								&&
                              projForecastEmpl.Report           == NoYes::Yes
                    {
                        if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(projTableJoin, projForecastEmpl.ContractLineId, ProjTransType::Hour, projOpsEnabled))
                        {
                            projTrans = ProjTrans::newProjForecastEmpl(projForecastEmpl);
                            this.ctcUpdate(projTrans);
                        }
                    }
                }
                else
                {
                    while select RecId from projTableJoin
                    where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
                    join RecId from projControlCategory
                    where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId        &&
                          projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                    join  projForecastEmpl
                        where projForecastEmpl.ProjId         == projTableJoin.ProjId                   &&
                              projForecastEmpl.ModelId      == this.parmForecastModelId()               &&
                              projForecastEmpl.CategoryId   == projControlCategory.CategoryId           &&
                              projForecastEmpl.Active             == NoYes::Yes                         &&
                              projForecastEmpl.Report             == NoYes::Yes
                    {
                        projTrans = ProjTrans::newProjForecastEmpl(projForecastEmpl);
                        this.ctcUpdate(projTrans);
                    }
                }
                break;
        }
        this.ctcUpdateBudget(_projControlPeriodCostGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the Cost To Complete (CTC) variables that will be used to check the
    ///    <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void ctcItem(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        ForecastSales       forecastSales;
        ProjControlCategory projControlCategory;
        ProjTrans           projTrans;
        ProjTable           projTableJoin;
        ProjRevRecContractLine  revRecContractLine;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            if (multipleContractLinesFeatureEnabled)
            {
                PSAContractLineItems contractLine;
            
                while select revRecContractLine
                        where revRecContractLine.RevenueRecognitionId  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId        &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
            join  forecastSales
                where forecastSales.ContractLineId      == revRecContractLine.ContractLineNum       &&
                      forecastSales.ModelId             == this.parmForecastModelId()               &&
                      forecastSales.ProjCategoryId      == projControlCategory.CategoryId           &&
                      forecastSales.Active              == NoYes::Yes                               &&
                      forecastSales.Report              == NoYes::Yes
                {
                    if (PSAContractLineItems::find(forecastSales.ContractLineId).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        projTrans = ProjTrans::newForecastSales(forecastSales);
                        this.ctcUpdate(projTrans);
                    }
                }
            }
            else
            {
                while select revRecContractLine
            where revRecContractLine.RevenueRecognitionId  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId    &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  forecastSales
                where forecastSales.ContractLineId          == revRecContractLine.ContractLineNum       &&
                      forecastSales.ModelId         == this.parmForecastModelId()               &&
                      forecastSales.ProjCategoryId  == projControlCategory.CategoryId           &&
                      forecastSales.Active          == NoYes::Yes                               &&
                      forecastSales.Report          == NoYes::Yes

                {
                    projTrans   = ProjTrans::newForecastSales(forecastSales);
                    this.ctcUpdate(projTrans);
                }
            }
        }
        else if (multipleContractLinesFeatureEnabled)
        {
            PSAContractLineItems contractLine;
            
            while select projTableJoin
                where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId        &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
            join  forecastSales
                where forecastSales.ProjId              == projTableJoin.ProjId                     &&
                      forecastSales.ModelId             == this.parmForecastModelId()               &&
                      forecastSales.ProjCategoryId      == projControlCategory.CategoryId           &&
                      forecastSales.Active              == NoYes::Yes                               &&
                      forecastSales.Report              == NoYes::Yes
            {
                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(projTableJoin, forecastSales.ContractLineId, ProjTransType::Item, projOpsEnabled))
                {
                    projTrans = ProjTrans::newForecastSales(forecastSales);
                    this.ctcUpdate(projTrans);
                }
            }
        }
        else
        {
            while select RecId from projTableJoin
            where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId    &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  forecastSales
                where forecastSales.ProjId          == projTableJoin.ProjId                     &&
                      forecastSales.ModelId         == this.parmForecastModelId()               &&
                      forecastSales.ProjCategoryId  == projControlCategory.CategoryId           &&
                      forecastSales.Active          == NoYes::Yes                               &&
                      forecastSales.Report          == NoYes::Yes

            {
                projTrans   = ProjTrans::newForecastSales(forecastSales);
                this.ctcUpdate(projTrans);
            }
        }

        this.ctcUpdateBudget(_projControlPeriodCostGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Cost To Complete (CTC) variables that will be used to check the
    /// <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projTrans">
    /// The <c>ProjTrans</c> object from which to read values.
    /// </param>
    /// <remarks>
    /// This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void ctcUpdate(ProjTrans _projTrans)
    {
        ctcAmountCostGroup  += _projTrans.transCostMST() + _projTrans.indirectCostAmount();
        ctcUnitCostGroup    += _projTrans.qty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcUpdateBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the Cost To Complete (CTC) variables that will be used to check the
    ///    <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void ctcUpdateBudget(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::RemainingEstimate)//Remaining budget
        {
            ctcAmountCostGroup += committedAmountCostGroup;
            ctcAmountCostGroup += committedPeriodEndAmountCostGroup;
            ctcAmountCostGroup += actualPeriodEndAmountCostGroup;
            ctcUnitCostGroup += committedUnitCostGroup;
            ctcUnitCostGroup += committedPeriodEndUnitCostGroup;
            ctcUnitCostGroup += actualPeriodEndUnitCostGroup;
        }
        else if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual ||
        _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage)//Total budget - Actual
        {
            ctcAmountCostGroup -= actualAmountCostGroup;
            ctcUnitCostGroup -= actualUnitCostGroup;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForecast</Name>
				<Source><![CDATA[
    void deleteForecast()
    {
        ProjForecastCost      projForecastCost;
        ProjForecastEmpl      projForecastEmpl;
        ProjForecastRevenue   projForecastRevenue;
        ForecastSales       forecastSales;
        ProjTable           projTable;
        ProjRevRecContractLine revRecContractLine;

        ttsbegin;
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
                delete_from projForecastEmpl
                where   projForecastEmpl.ModelId  == this.parmForecastModelId()
                &&      projForecastEmpl.ContractLineId   == revRecContractLine.ContractLineNum
                    exists join revRecContractLine
                    where revRecContractLine.ContractLineNum == projForecastEmpl.ContractLineId
                    && revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId();

                delete_from projForecastCost
                where   projForecastCost.ModelId  == this.parmForecastModelId()
                    exists join revRecContractLine
                    where revRecContractLine.ContractLineNum == projForecastCost.ContractLineId
                    && revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId();

                delete_from forecastSales
                where   forecastSales.ModelId   == this.parmForecastModelId()
                    exists join revRecContractLine
                    where revRecContractLine.ContractLineNum == forecastSales.ContractLineId
                    && revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId();
            
        }
        else
        {
        while select ProjId from projTable
            where projTable.wipProject  == this.parmProjWIPProjId()
        {
            delete_from projForecastEmpl
                where   projForecastEmpl.ModelId  == this.parmForecastModelId()
                &&      projForecastEmpl.ProjId   == projTable.ProjId;

            delete_from projForecastCost
                where   projForecastCost.ModelId  == this.parmForecastModelId()
                &&      projForecastCost.ProjId   == projTable.ProjId;

            delete_from projForecastRevenue
                where   projForecastRevenue.ModelId  == this.parmForecastModelId()
                &&      projForecastRevenue.ProjId   == projTable.ProjId;

            delete_from forecastSales
                where   forecastSales.ModelId   == this.parmForecastModelId()
                &&      forecastSales.ProjId    == projTable.ProjId;
        }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>difference</Name>
				<Source><![CDATA[
    protected boolean difference(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        boolean ok  = true;

        if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::RemainingEstimate ||//Remaining budget
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual ||//Total budget - Actual
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage)
        {
            if (ctcAmountCostGroup  != _projControlPeriodCostGroup.ctcCostAmount)
            {
                ok  = checkFailed(strFmt("@SYS54942","@SYS95",ctcAmountCostGroup,_projControlPeriodCostGroup.ctcCostAmount));
            }

            if (ctcUnitCostGroup        != _projControlPeriodCostGroup.ctcCostUnit)
            {
                ok  = checkFailed(strFmt("@SYS54942","@SYS7108",ctcUnitCostGroup,_projControlPeriodCostGroup.ctcCostUnit));
            }
        }

        if (actualAmountCostGroup   != _projControlPeriodCostGroup.ActuelCostAmount)
        {
            ok  = checkFailed(strFmt("@SYS54942","@SYS54596",actualAmountCostGroup,_projControlPeriodCostGroup.ActuelCostAmount));
        }

        if (actualUnitCostGroup     != _projControlPeriodCostGroup.ActuelCostUnit)
        {
            ok  = checkFailed(strFmt("@SYS54942","@SYS3562",actualUnitCostGroup,_projControlPeriodCostGroup.ActuelCostUnit));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the forecast variables that will be used to update the <c>ProjControlPeriodCostGroup</c>
    ///    buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    protected void forecast(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        if (this.checkProjControlPeriodCostGroupCTCMethod(_projControlPeriodCostGroup))
        {
            switch (this.parmProjCostType())
            {
                case ProjCostType::Cost:
                    [amountfromforecast,unitfromforecast,periodEndForecastCostAmount,periodEndForecastCostUnit,currPeriodForecastCostAmount,currPeriodForecastCostUnit] = this.getCTCCost();
                    break;

                case ProjCostType::Hour:
                        if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage)
                    {
                        if (_projControlPeriodCostGroup.CompletePct && !this.hasExistingForecast(_projControlPeriodCostGroup))
                        {
                            PSAContractLineItems   psaContractLineItems;
                            ProjOnAccTrans         projOnAccTrans;
                            ProjRevRecContractLine revRecContractLine;
                            if(contractLineBasedRevRecFeature && isContractLineUsed)
                            {
                                select RecId from projOnAccTrans
                                exists join psaContractLineItems
                                where projOnAccTrans.PSAContractLineNum == psaContractLineItems.ContractLineNum && 
                                    projOnAccTrans.TransactionOrigin == ProjOrigin::Milestone &&
                                    psaContractLineItems.ProjInvoiceProjId == ProjTable::find(_projControlPeriodCostGroup.ProjId).ProjInvoiceProjId
                                exists join revRecContractLine
                                    where revRecContractLine.ContractLineNum == psaContractLineItems.ContractLineNum
                                    && revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId();
                            }
                            else
                            {
                                select RecId from projOnAccTrans
                                exists join psaContractLineItems
                                where projOnAccTrans.PSAContractLineNum == psaContractLineItems.ContractLineNum &&
                                    projOnAccTrans.ProjID == _projControlPeriodCostGroup.ProjId &&
                                    projOnAccTrans.TransactionOrigin == ProjOrigin::Milestone &&
                                    psaContractLineItems.ProjInvoiceProjId == ProjTable::find(_projControlPeriodCostGroup.ProjId).ProjInvoiceProjId;
                            }
                            if ((projOnAccTrans.RecId) || (!this.parmForecastModelId()))
                            {
                                [amountfromforecast,unitfromforecast] = this.getCTCEmplFromWBS();
                            }
                            break;
                        }
                    }
                    [amountfromforecast,unitfromforecast,periodEndForecastCostAmount,periodEndForecastCostUnit,currPeriodForecastCostAmount,currPeriodForecastCostUnit] = this.getCTCEmpl();
                    break;

                case ProjCostType::Item:
                    [amountfromforecast,unitfromforecast,periodEndForecastCostAmount,periodEndForecastCostUnit,currPeriodForecastCostAmount,currPeriodForecastCostUnit] = this.getCTCItem();
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjControlPeriodCostGroupCTCMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the field <c>ctcMethod</c> of <c>ProjControlPeriodCostGroup</c> has a valid value of <c>ProjControlPeriodCostGroupCTCMethod</c>.
    /// </summary>
    /// <param name = "_projControlPeriodCostGroup">
    /// <c>ProjControlPeriodCostGroup</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the field <c>ctcMethod</c> of the <c>ProjControlPeriodCostGroup</c> has an allowed value; otherwise, false.
    /// </returns>
    protected boolean checkProjControlPeriodCostGroupCTCMethod(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        return (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::RemainingEstimate ||//Remaining budget
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual || //Total budget - Actual
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasExistingForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check whether any foreCast exists for hour, item, cost, revenue.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///     The <c>ProjControlPeriodCostGroup</c> buffer to read values from.
    /// </param>
    /// <returns>
    ///     returns true if  forecast exist.
    /// </returns>
    private boolean hasExistingForecast(ProjControlPeriodCostGroup _projControlPeriodCostGroup)
    {
        boolean             found = false;
        ProjForecastEmpl    projForecastEmpl;
        ProjRevRecContractLine revRecContractLine;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            select firstOnly RecId from revRecContractLine
            where revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId()
            join projForecastEmpl
            where projForecastEmpl.ModelId  == this.parmForecastModelId()
                && projForecastEmpl.ContractLineId == revRecContractLine.ContractLineNum;
        }
        else
        {
        select firstOnly RecId from projForecastEmpl
            where projForecastEmpl.ProjId == _projControlPeriodCostGroup.ProjId &&
                projForecastEmpl.ModelId  == this.parmForecastModelId();
        }

        found = projForecastEmpl.RecId ? true : false;
        
        if (!found)
        {
            ProjForecastCost    projForecastCost;

            if(contractLineBasedRevRecFeature && isContractLineUsed)
            {
                select firstOnly RecId from revRecContractLine
                where revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId()
                join projForecastCost
                where projForecastCost.ModelId  == this.parmForecastModelId()
                    && projForecastCost.ContractLineId == revRecContractLine.ContractLineNum;
            }
            else
            {
            select firstOnly RecId from projForecastCost
                where projForecastCost.ProjId == _projControlPeriodCostGroup.ProjId &&
                    projForecastCost.ModelId  == this.parmForecastModelId();
            }

            found = projForecastCost.RecId ? true : false;
        }
        
        if (!found)
        {
            ProjForecastRevenue projForecastRevenue;

            if(!contractLineBasedRevRecFeature || !isContractLineUsed)
            {
                
            select firstOnly RecId from projForeCastRevenue
                where projForeCastRevenue.ProjId == _projControlPeriodCostGroup.ProjId &&
                    projForeCastRevenue.ModelId  == this.parmForecastModelId();
            }

            found = projForecastRevenue.RecId ? true : false;
        }
        
        if (!found)
        {
            ForecastSales   forecastSales;

            if(contractLineBasedRevRecFeature && isContractLineUsed)
            {
                select firstOnly RecId from revRecContractLine
                where revRecContractLine.RevenueRecognitionId == this.parmProjWIPProjId()
                join forecastSales
                where forecastSales.ModelId  == this.parmForecastModelId()
                    && forecastSales.ContractLineId == revRecContractLine.ContractLineNum;
            }
            else
            {
            select firstOnly RecId from forecastSales
                where forecastSales.ProjId == _projControlPeriodCostGroup.ProjId &&
                    forecastSales.ModelId  == this.parmForecastModelId();
            }

            found = forecastSales.RecId ? true : false;
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastClear</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the forecast fields in the <c>ProjControlPeriodCostGroup</c> buffer and the forecast
    ///    variables that will be used to update the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </summary>
    /// <param name="_projControlPeriodCostGroup">
    ///    The <c>ProjControlPeriodCostGroup</c> buffer to update or read values from.
    /// </param>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private void forecastClear(ProjControlPeriodCostGroup    _projControlPeriodCostGroup)
    {
        if (_projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::RemainingEstimate ||//Remaining budget
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual ||
            _projControlPeriodCostGroup.ctcMethod == ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage)//Total budget - Actual
        {
            if (! this.parmCheck())
            {
                _projControlPeriodCostGroup.ForecastCostAmount              = 0;
                _projControlPeriodCostGroup.ForecastCostUnit                = 0;
            }

            amountfromforecast                   = 0;
            unitfromforecast                     = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCTCCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast values that will be used to update the <c>ProjControlPeriodCostGroup</c>
    ///    buffer
    /// </summary>
    /// <returns>
    ///    The forecast values that will be used to update the ProjControlPeriodCostGroup buffer.
    /// </returns>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private container getCTCCost()
    {
        ProjTable projTableJoin;
        ProjForecastCost projForecastCost;
        ProjControlCategory projControlCategory;
        ProjTrans projTrans;
        AmountMST lcTCAmountCostGroup = 0;
        UnitQty lcTCUnitCostGroup = 0;
        AmountMST forecastperiodEndCostAmount = 0;
        UnitQty forecastperiodEndCostUnit = 0;
        AmountMST periodForecastCostAmount = 0;
        UnitQty periodForecastCostUnit = 0;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            ProjRevRecContractLine revRecContractLine;
            if (multipleContractLinesFeatureEnabled)
            {
                PSAContractLineItems contractLine;
  
                while select revRecContractLine
                    where revRecContractLine.RevenueRecognitionId == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where projControlCategory.ControlId			== this.parmProjWIPTable().ControlId	 &&
                          projControlCategory.CostGroupId		== this.parmProjCostGroupId()
                join projForecastCost
                    where projForecastCost.ContractLineId       == revRecContractLine.ContractLineNum					 &&
                          projForecastCost.ModelId				== this.parmForecastModelId()			 &&
                          projForecastCost.CategoryId			== projControlCategory.CategoryId		 &&
                          projForecastCost.Active				== NoYes::Yes							 &&
                          projForecastCost.Report				== NoYes::Yes
                {
                    if (PSAContractLineItems::find(revRecContractLine.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                      
                        projTrans   = ProjTrans::newProjForecastCost(projForecastCost);
                        AmountMST costAmount;
                        if (projContractCurrencyForRevRecParmEnabled)
                        {
                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                                Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastCost.company()).RecId),
                                projForecastCost.StartDate);
                            costAmount = currencyExchangeHelper.calculateAccountingToTransaction(
                               ProjInvoiceTable::find(PSAContractLineItems::find(revRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId, projTrans.transCostMST(), true);
                        }
                        else
                        {
                            costAmount = projTrans.transCostMST();
                        }

                        lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                        lcTCUnitCostGroup += projTrans.qty();
                        if (projTrans.transDate() <= this.parmProjPeriodTo())
                        {
                            forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                            forecastperiodEndCostUnit += projTrans.qty();
                            if (projTrans.transDate() >= this.parmProjPeriodFrom())
                            {
                                periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                                periodForecastCostUnit += projTrans.qty();
                            }
                        }
   
                    }
                }
            }
            else
            {
                while select revRecContractLine
                    where revRecContractLine.RevenueRecognitionId == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where   projControlCategory.ControlId     == this.parmProjWIPTable().ControlId  &&
                            projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  projForecastCost
                   where    projForecastCost.ContractLineId       == revRecContractLine.ContractLineNum            &&
                            projForecastCost.ModelId            == this.parmForecastModelId()       &&
                            projForecastCost.CategoryId         == projControlCategory.CategoryId   &&
                            projForecastCost.Active             == NoYes::Yes                       &&
                            projForecastCost.Report             == NoYes::Yes
                {
                    projTrans = ProjTrans::newProjForecastCost(projForecastCost);

                    AmountMST costAmount;
                    if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(revRecContractLine.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastCost.company()).RecId),
                            projForecastCost.StartDate);
                        costAmount = currencyExchangeHelper.calculateAccountingToTransaction(
                            ProjInvoiceTable::find(PSAContractLineItems::find(revRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId, projTrans.transCostMST(), true);
                    }
                    else
                    {
                        costAmount = projTrans.transCostMST();
                    }
                
                    lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                    lcTCUnitCostGroup += projTrans.qty();
                    if (projTrans.transDate() <= this.parmProjPeriodTo())
                    {
                        forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                        forecastperiodEndCostUnit += projTrans.qty();
                        if (projTrans.transDate() >= this.parmProjPeriodFrom())
                        {
                            periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                            periodForecastCostUnit += projTrans.qty();
                        }
                    }
                }
            }

        }
        else if (multipleContractLinesFeatureEnabled)
        {
            PSAContractLineItems contractLine;
  
            while select projTableJoin
                    where projTableJoin.wipProject == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where projControlCategory.ControlId			== this.parmProjWIPTable().ControlId	 &&
                          projControlCategory.CostGroupId		== this.parmProjCostGroupId()
                join projForecastCost
                    where projForecastCost.ProjId				== projTableJoin.ProjId					 &&
                          projForecastCost.ModelId				== this.parmForecastModelId()			 &&
                          projForecastCost.CategoryId			== projControlCategory.CategoryId		 &&
                          projForecastCost.Active				== NoYes::Yes							 &&
                          projForecastCost.Report				== NoYes::Yes
            {
                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(projTableJoin, projForecastCost.ContractLineId, ProjTransType::Cost, projOpsEnabled))
                {
                    projTrans   = ProjTrans::newProjForecastCost(projForecastCost);
                    AmountMST costAmount;
                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                                Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastCost.company()).RecId),
                                projForecastCost.StartDate);
                        costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTableJoin.contractCurrCode(), projTrans.transCostMST(), true);
                    }
                    else
                    {
                        costAmount = projTrans.transCostMST();
                    }

                    lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                    lcTCUnitCostGroup += projTrans.qty();
                    if (projTrans.transDate() <= this.parmProjPeriodTo())
                    {
                        forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                        forecastperiodEndCostUnit += projTrans.qty();
                        if (projTrans.transDate() >= this.parmProjPeriodFrom())
                        {
                            periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                            periodForecastCostUnit += projTrans.qty();
                        }
                    }
   
                }
            }
        }
        else
        {
            while select RecId, ProjInvoiceProjId, Type from projTableJoin
                where projTableJoin.wipProject              == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                    where   projControlCategory.ControlId     == this.parmProjWIPTable().ControlId  &&
                            projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  projForecastCost
                   where    projForecastCost.ProjId             == projTableJoin.ProjId             &&
                            projForecastCost.ModelId            == this.parmForecastModelId()       &&
                            projForecastCost.CategoryId         == projControlCategory.CategoryId   &&
                            projForecastCost.Active             == NoYes::Yes                       &&
                            projForecastCost.Report             == NoYes::Yes
            {
                projTrans = ProjTrans::newProjForecastCost(projForecastCost);

                AmountMST costAmount;
                if (projContractCurrencyForRevRecParmEnabled && projTableJoin.Type == ProjType::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastCost.company()).RecId),
                            projForecastCost.StartDate);
                    costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTableJoin.contractCurrCode(), projTrans.transCostMST(), true);
                }
                else
                {
                    costAmount = projTrans.transCostMST();
                }
                
                lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                lcTCUnitCostGroup += projTrans.qty();
                if (projTrans.transDate() <= this.parmProjPeriodTo())
                {
                    forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                    forecastperiodEndCostUnit += projTrans.qty();
                    if (projTrans.transDate() >= this.parmProjPeriodFrom())
                    {
                        periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                        periodForecastCostUnit += projTrans.qty();
                    }
                }
            }
        }

        return [lcTCAmountCostGroup,lcTCUnitCostGroup,forecastperiodEndCostAmount,forecastperiodEndCostUnit,periodForecastCostAmount,periodForecastCostUnit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCTCEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast values that will be used to update the <c>ProjControlPeriodCostGroup</c>
    ///    buffer.
    /// </summary>
    /// <returns>
    ///    The forecast values that will be used to update the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </returns>
    private container getCTCEmpl()
    {
        ProjTable           projTableJoin;
        ProjForecastEmpl    projForecastEmpl;
        ProjControlCategory projControlCategory;
        ProjTrans           projTrans;
        AmountMST           lcTCAmountCostGroup = 0;
        UnitQty             lcTCUnitCostGroup = 0;
        AmountMST           forecastperiodEndCostAmount = 0;
        UnitQty             forecastperiodEndCostUnit = 0;
        AmountMST           periodForecastCostAmount = 0;
        UnitQty             periodForecastCostUnit = 0;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            ProjRevRecContractLine revRecContractLine;
            if (multipleContractLinesFeatureEnabled)
            {
                PSAContractLineItems contractLine;
        
                while select revRecContractLine
                     where revRecContractLine.RevenueRecognitionId == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                     where projControlCategory.ControlId		== this.parmProjWIPTable().ControlId		&&
                           projControlCategory.CostGroupId		== this.parmProjCostGroupId()
                join projForecastEmpl
                     where projForecastEmpl.ContractLineId	    == revRecContractLine.ContractLineNum						&&
                           projForecastEmpl.ModelId				== this.parmForecastModelId()				&&
                           projForecastEmpl.CategoryId			== projControlCategory.CategoryId			&&
                           projForecastEmpl.Active				== NoYes::Yes								&&
                           projForecastEmpl.Report				== NoYes::Yes
                {
                    if (PSAContractLineItems::find(revRecContractLine.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        projTrans   = ProjTrans::newProjForecastEmpl(projForecastEmpl);
                        AmountMST costAmount;
                        if (projContractCurrencyForRevRecParmEnabled)
                        {
                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastEmpl.company()).RecId), projForecastEmpl.SchedFromDate);
                            costAmount = currencyExchangeHelper.calculateAccountingToTransaction(
                                ProjInvoiceTable::find(PSAContractLineItems::find(revRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId, projTrans.transCostMST(), true);
                        }
                        else
                        {
                            costAmount = projTrans.transCostMST();
                        }

                        lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                        lcTCUnitCostGroup += projTrans.qty();

                        if (projTrans.transDate() <= this.parmProjPeriodTo())
                        {
                            forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                            forecastperiodEndCostUnit += projTrans.qty();
                            if (projTrans.transDate() >= this.parmProjPeriodFrom())
                            {
                                periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                                periodForecastCostUnit += projTrans.qty();
                            }
                        }
                    }
                }
            }
            else
            {
                while select revRecContractLine
                where revRecContractLine.RevenueRecognitionId == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId    &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  projForecastEmpl
                    where projForecastEmpl.ContractLineId	    == revRecContractLine.ContractLineNum         &&
                        projForecastEmpl.ModelId        == this.parmForecastModelId()           &&
                        projForecastEmpl.CategoryId     == projControlCategory.CategoryId       &&
                        projForecastEmpl.Active         == NoYes::Yes                           &&
                        projForecastEmpl.Report         == NoYes::Yes
                {
                    projTrans = ProjTrans::newProjForecastEmpl(projForecastEmpl);

                    AmountMST costAmount;
                    if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(revRecContractLine.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastEmpl.company()).RecId),
                            projForecastEmpl.SchedFromDate);
                        costAmount = currencyExchangeHelper.calculateAccountingToTransaction(
                            ProjInvoiceTable::find(PSAContractLineItems::find(revRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId, projTrans.transCostMST(), true);
                    }
                    else
                    {
                        costAmount = projTrans.transCostMST();
                    }

                    lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                    lcTCUnitCostGroup += projTrans.qty();

                    if (projTrans.transDate() <= this.parmProjPeriodTo())
                    {
                        forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                        forecastperiodEndCostUnit += projTrans.qty();
                        if (projTrans.transDate() >= this.parmProjPeriodFrom())
                        {
                            periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                            periodForecastCostUnit += projTrans.qty();
                        }
                    }
                }
            }
        }
        else if (multipleContractLinesFeatureEnabled)
        {
            PSAContractLineItems contractLine;
        
            while select projTableJoin
                     where projTableJoin.wipProject				== this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                     where projControlCategory.ControlId		== this.parmProjWIPTable().ControlId		&&
                           projControlCategory.CostGroupId		== this.parmProjCostGroupId()
                join projForecastEmpl
                     where projForecastEmpl.ProjId				== projTableJoin.ProjId						&&
                           projForecastEmpl.ModelId				== this.parmForecastModelId()				&&
                           projForecastEmpl.CategoryId			== projControlCategory.CategoryId			&&
                           projForecastEmpl.Active				== NoYes::Yes								&&
                           projForecastEmpl.Report				== NoYes::Yes
            {
                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(projTableJoin, projForecastEmpl.ContractLineId, ProjTransType::Hour, projOpsEnabled))
                {
                    projTrans   = ProjTrans::newProjForecastEmpl(projForecastEmpl);
                    AmountMST costAmount;
                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastEmpl.company()).RecId), projForecastEmpl.SchedFromDate);
                        costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTableJoin.contractCurrCode(), projTrans.transCostMST(), true);
                    }
                    else
                    {
                        costAmount = projTrans.transCostMST();
                    }

                    lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                    lcTCUnitCostGroup += projTrans.qty();

                    if (projTrans.transDate() <= this.parmProjPeriodTo())
                    {
                        forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                        forecastperiodEndCostUnit += projTrans.qty();
                        if (projTrans.transDate() >= this.parmProjPeriodFrom())
                        {
                            periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                            periodForecastCostUnit += projTrans.qty();
                        }
                    }
                }
            }
        }
        else
        {
            while select RecId, ProjInvoiceProjId, Type from projTableJoin
                where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
                join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId    &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  projForecastEmpl
                    where projForecastEmpl.ProjId       == projTableJoin.ProjId                 &&
                        projForecastEmpl.ModelId        == this.parmForecastModelId()           &&
                        projForecastEmpl.CategoryId     == projControlCategory.CategoryId       &&
                        projForecastEmpl.Active         == NoYes::Yes                           &&
                        projForecastEmpl.Report         == NoYes::Yes
            {
                projTrans = ProjTrans::newProjForecastEmpl(projForecastEmpl);

                AmountMST costAmount;
                if (projContractCurrencyForRevRecParmEnabled && projTableJoin.Type == ProjType::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(projForecastEmpl.company()).RecId),
                            projForecastEmpl.SchedFromDate);
                    costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTableJoin.contractCurrCode(), projTrans.transCostMST(), true);
                }
                else
                {
                    costAmount = projTrans.transCostMST();
                }

                lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                lcTCUnitCostGroup += projTrans.qty();

                if (projTrans.transDate() <= this.parmProjPeriodTo())
                {
                    forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                    forecastperiodEndCostUnit += projTrans.qty();
                    if (projTrans.transDate() >= this.parmProjPeriodFrom())
                    {
                        periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                        periodForecastCostUnit += projTrans.qty();
                    }
                }
            }
        }
        
        return [lcTCAmountCostGroup,lcTCUnitCostGroup,forecastperiodEndCostAmount,forecastperiodEndCostUnit,periodForecastCostAmount,periodForecastCostUnit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCTCEmplFromWBS</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast values from work break down structure.
    /// </summary>
    /// <returns>
    ///     Container for all ctc values.
    /// </returns>
    private container getCTCEmplFromWBS()
    {
        AmountMST   lcTCAmountCostGroup = 0;
        UnitQty     lcTCUnitCostGroup = 0;
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return [lcTCAmountCostGroup,lcTCUnitCostGroup];
        }

        ProjTable projTable = ProjTable::find(this.parmProjWIPProjId());

        if (projTable && (!multipleContractLinesFeatureEnabled || ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForTransTypeBillingMethod(projTable.projInvoiceProjId, ProjTransType::Hour, ProjContractBillingMethod::FixedPrice)))
        {
            HierarchyLinkTable hierarchyLinkTable = HierarchyLinkTable::findRefTableRecId(tableNum(ProjTable), projTable.RecId);

            if (hierarchyLinkTable)
            {
                ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findLatestByHierarchyId(hierarchyLinkTable.HierarchyId, false, false, ProjPlanVersionType::PublishedCurrent);

                ProjPlanVersion planVersion;

                select sum(TaskEffort), sum(TaskCostAtComplete) from planVersion
                    where planVersion.HierarchyId == planVersionDetail.HierarchyId
                        && planVersion.TaskCategory != '';

                lcTCAmountCostGroup = planVersion.TaskCostAtComplete;
                lcTCUnitCostGroup = planVersion.TaskEffort;
            }
        }
        
        return [lcTCAmountCostGroup, lcTCUnitCostGroup];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCTCItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast values that will be used to update the <c>ProjControlPeriodCostGroup</c>
    ///    buffer.
    /// </summary>
    /// <returns>
    ///    The forecast values that will be used to update the <c>ProjControlPeriodCostGroup</c> buffer.
    /// </returns>
    /// <remarks>
    ///    This method is used by the <c>updateCostGroup</c> method.
    /// </remarks>
    private container getCTCItem()
    {
        ForecastSales       forecastSales;
        ProjControlCategory projControlCategory;
        ProjTrans           projTrans;
        ProjTable           projTableJoin;
        AmountMST           lcTCAmountCostGroup = 0;
        UnitQty             lcTCUnitCostGroup = 0;
        AmountMST           forecastperiodEndCostAmount = 0;
        UnitQty             forecastperiodEndCostUnit = 0;
        AmountMST           periodForecastCostAmount = 0;
        UnitQty             periodForecastCostUnit = 0;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            ProjRevRecContractLine revRecContractLine;
            if (multipleContractLinesFeatureEnabled)
            {
                PSAContractLineItems contractLine;

                while select revRecContractLine
                where revRecContractLine.RevenueRecognitionId  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId         == this.parmProjWIPTable().ControlId        &&
                      projControlCategory.CostGroupId       == this.parmProjCostGroupId()
                join  forecastSales
                    where forecastSales.ContractLineId      == revRecContractLine.ContractLineNum                    &&
                          forecastSales.ModelId             == this.parmForecastModelId()               &&
                          forecastSales.ProjCategoryId      == projControlCategory.CategoryId           &&
                          forecastSales.Active              == NoYes::Yes                               &&
                          forecastSales.Report              == NoYes::Yes
                {
                    if (PSAContractLineItems::find(revRecContractLine.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        projTrans = ProjTrans::newForecastSales(forecastSales);

                        AmountMST costAmount;
                        if (projContractCurrencyForRevRecParmEnabled)
                        {
                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(forecastSales.company()).RecId),
                        forecastSales.StartDate);
                            costAmount = currencyExchangeHelper.calculateAccountingToTransaction(
                                ProjInvoiceTable::find(PSAContractLineItems::find(revRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId, projTrans.transCostMST(), true);
                        }
                        else
                        {
                            costAmount = projTrans.transCostMST();
                        }

                        lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                        lcTCUnitCostGroup += projTrans.qty();

                        if (projTrans.transDate() <= this.parmProjPeriodTo())
                        {
                            forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                            forecastperiodEndCostUnit += projTrans.qty();
                            if (projTrans.transDate() >= this.parmProjPeriodFrom())
                            {
                                periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                                periodForecastCostUnit += projTrans.qty();
                            }
                        }
                    }
                }
            }
            else
            {
                while select revRecContractLine
                where revRecContractLine.RevenueRecognitionId  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId    &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  forecastSales
                where forecastSales.ContractLineId      == revRecContractLine.ContractLineNum       &&
                      forecastSales.ModelId         == this.parmForecastModelId()               &&
                      forecastSales.ProjCategoryId  == projControlCategory.CategoryId           &&
                      forecastSales.Active          == NoYes::Yes                               &&
                      forecastSales.Report          == NoYes::Yes
                {
                    projTrans = ProjTrans::newForecastSales(forecastSales);

                    AmountMST costAmount;
                    if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(revRecContractLine.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(forecastSales.company()).RecId),
                        forecastSales.StartDate);
                        costAmount = currencyExchangeHelper.calculateAccountingToTransaction(
                            ProjInvoiceTable::find(PSAContractLineItems::find(revRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId, projTrans.transCostMST(), true);
                    }
                    else
                    {
                        costAmount = projTrans.transCostMST();
                    }

                    lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                    lcTCUnitCostGroup += projTrans.qty();

                    if (projTrans.transDate() <= this.parmProjPeriodTo())
                    {
                        forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                        forecastperiodEndCostUnit += projTrans.qty();
                        if (projTrans.transDate() >= this.parmProjPeriodFrom())
                        {
                            periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                            periodForecastCostUnit += projTrans.qty();
                        }
                    }
                }
            }
        }
        else if (multipleContractLinesFeatureEnabled)
        {
            PSAContractLineItems contractLine;
     
            while select projTableJoin
                where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId         == this.parmProjWIPTable().ControlId        &&
                      projControlCategory.CostGroupId       == this.parmProjCostGroupId()
                join  forecastSales
                    where forecastSales.ProjId              == projTableJoin.ProjId                     &&
                          forecastSales.ModelId             == this.parmForecastModelId()               &&
                          forecastSales.ProjCategoryId      == projControlCategory.CategoryId           &&
                          forecastSales.Active              == NoYes::Yes                               &&
                          forecastSales.Report              == NoYes::Yes
            {
                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(projTableJoin, forecastSales.ContractLineId, ProjTransType::Item, projOpsEnabled))
                {
                    projTrans = ProjTrans::newForecastSales(forecastSales);

                    AmountMST costAmount;
                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(forecastSales.company()).RecId),
                        forecastSales.StartDate);
                        costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTableJoin.contractCurrCode(), projTrans.transCostMST(), true);
                    }
                    else
                    {
                        costAmount = projTrans.transCostMST();
                    }

                    lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                    lcTCUnitCostGroup += projTrans.qty();

                    if (projTrans.transDate() <= this.parmProjPeriodTo())
                    {
                        forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                        forecastperiodEndCostUnit += projTrans.qty();
                        if (projTrans.transDate() >= this.parmProjPeriodFrom())
                        {
                            periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                            periodForecastCostUnit += projTrans.qty();
                        }
                    }
                }
            }
        }
        else
        {
            while select RecId, ProjInvoiceProjId, Type from projTableJoin
            where projTableJoin.wipProject  == this.parmProjWIPTable().ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId     == this.parmProjWIPTable().ControlId    &&
                      projControlCategory.CostGroupId   == this.parmProjCostGroupId()
                join  forecastSales
                where forecastSales.ProjId          == projTableJoin.ProjId                     &&
                      forecastSales.ModelId         == this.parmForecastModelId()               &&
                      forecastSales.ProjCategoryId  == projControlCategory.CategoryId           &&
                      forecastSales.Active          == NoYes::Yes                               &&
                      forecastSales.Report          == NoYes::Yes
            {
                projTrans = ProjTrans::newForecastSales(forecastSales);

                AmountMST costAmount;
                if (projContractCurrencyForRevRecParmEnabled && projTableJoin.Type == ProjType::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(forecastSales.company()).RecId),
                        forecastSales.StartDate);
                    costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTableJoin.contractCurrCode(), projTrans.transCostMST(), true);
                }
                else
                {
                    costAmount = projTrans.transCostMST();
                }

                lcTCAmountCostGroup += costAmount + projTrans.indirectCostAmount();
                lcTCUnitCostGroup += projTrans.qty();

                if (projTrans.transDate() <= this.parmProjPeriodTo())
                {
                    forecastperiodEndCostAmount += costAmount + projTrans.indirectCostAmount();
                    forecastperiodEndCostUnit += projTrans.qty();
                    if (projTrans.transDate() >= this.parmProjPeriodFrom())
                    {
                        periodForecastCostAmount += costAmount + projTrans.indirectCostAmount();
                        periodForecastCostUnit += projTrans.qty();
                    }
                }
            }
        }

        return [lcTCAmountCostGroup,lcTCUnitCostGroup,forecastperiodEndCostAmount,forecastperiodEndCostUnit,periodForecastCostAmount,periodForecastCostUnit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryValues</Name>
				<Source><![CDATA[
    container getQueryValues()
    {
        QueryRun                tmpQueryRun;
        Query                   tmpQuery;
        QueryBuildDataSource    tmpQueryBuildDataSource;
        QueryBuildRange         tmpQueryBuildRange;
        QueryBuildRange         tmpQueryBuildRangeProjPeriodId;
        ProjId                  projIdRangeValue            = '';
        ProjPeriodId            projPeriodIdRangeValue      = '';

        if (this.queryRun())
        {
            tmpQueryRun = this.queryRun();

            if (tmpQueryRun)
            {
                tmpQuery = this.queryRun().query();

                if (tmpQuery.dataSourceTable(tableNum(ProjWIPTable)))
                {
                    tmpQueryBuildDataSource = tmpQuery.dataSourceTable(tableNum(ProjWIPTable));

                    if (tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,ProjId)))
                    {
                        tmpQueryBuildRange = tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,ProjId));
                        projIdRangeValue = tmpQueryBuildRange.value();
                    }

                    if (tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,PeriodId)))
                    {
                        tmpQueryBuildRangeProjPeriodId = tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,PeriodId));
                        projPeriodIdRangeValue = tmpQueryBuildRangeProjPeriodId.value();
                    }
                }
            }
        }

        return [projIdRangeValue,projPeriodIdRangeValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEstimateCreate</Name>
				<Source><![CDATA[
    public void initEstimateCreate()
    {
        ProjControlPeriodTable  projControlPeriodTableLocal;

        if (this.canCreateCostGroup())//Estimate is being created
        {
            switch (this.parmProjEstimateMethod())
            {
                case ProjEstimateMethod::TotalEstimate, ProjEstimateMethod::PreviousEstimate:
                    //Get previous version value
                    projControlPeriodTableLocal = ProjControlPeriodTable::findLastPosted(this.parmProjWIPTable().ProjId, this.parmProjControlId());
                    this.parmPrevPeriodFrom(projControlPeriodTableLocal.PeriodFrom);
                    this.parmPrevVersion(projControlPeriodTableLocal.Version);
                    break;
            }

            this.setCostGroupCTCMethod();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal variables.
    /// </summary>
    /// <remarks>
    /// This method is called when no <c>SysLastValue</c> record can be found when the SysLastValue.GetLast
    /// method is called. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        this.initQuery();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    void initQuery()
    {
        Query query = new Query();
        
        QueryBuildDataSource dataSourceProjWIPTable = query.addDataSource(tableNum(ProjWIPTable));
        QueryBuildRange rangeEliminated = dataSourceProjWIPTable.addRange(fieldNum(ProjWIPTable, WIPEliminated));
        rangeEliminated.value(queryValue(NoYes::No));
        rangeEliminated.status(RangeStatus::Hidden);
        QueryBuildRange rangeProjId = dataSourceProjWIPTable.addRange(fieldNum(ProjWIPTable, ProjId));

        if (!this.parmPeriodic())
        {
            rangeProjId.value(this.parmProjWIPProjId());
        }

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            QueryBuildDataSource dataSourceProjTable = dataSourceProjWIPTable.addDataSource(tableNum(ProjRevRecContractLine));
            dataSourceProjTable.relations(true);
            dataSourceProjTable.joinMode(JoinMode::InnerJoin);
            dataSourceProjTable.addRange(fieldNum(ProjRevRecContractLine, RevenueRecognitionId));
        }
            else
        {
        
            QueryBuildDataSource dataSourceProjTable = dataSourceProjWIPTable.addDataSource(tableNum(ProjTable));
            dataSourceProjTable.relations(true);
            dataSourceProjTable.joinMode(JoinMode::InnerJoin);
            dataSourceProjTable.addRange(fieldNum(ProjTable, ProjGroupId));
            dataSourceProjTable.addRange(fieldNum(ProjTable, WorkerResponsible));
            dataSourceProjTable.addRange(fieldNum(ProjTable, WorkerResponsibleFinancial));
        }

        queryRun = new SysQueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContinuesPeriodesOk</Name>
				<Source><![CDATA[
    boolean isContinuesPeriodesOk()
    {
        boolean                 ret = true;
        ProjPeriodLine          projPeriodLine;
        ProjPeriodTo            projPeriodTo;

        // Is there any records at all ??
        if ((select firstonly reverse projControlPeriodTable
                    where   projControlPeriodTable.ProjId       == projWIPTable.ProjId
                    &&      projControlPeriodTable.PeriodStatus != ProjControlPeriodStatus::Reversal).RecId)
        {
            ProjControlPeriodTable nextProjControlPeriodTable = this.findNextControlPeriodTable();

            if (nextProjControlPeriodTable.RecId)
            {
                ret = false;
            }
            else
            {
                // Test for another estimate in this period
                ProjControlPeriodTable prevProjControlPeriodTable = this.findPrevControlPeriodTable();

                if (prevProjControlPeriodTable.RecId
                    && (prevProjControlPeriodTable.PeriodFrom == this.parmProjPeriodFrom()))
                {
                    if (prevProjControlPeriodTable.BeginningBalance == this.parmBeginningBalance())
                    {
                        ret = false;
                    }
                }
                else
                {
                    if (this.parmProjPeriodFrom() == this.parmProjPeriodTo())
                    {
                        projPeriodLine = ProjPeriodLine::findPrevFromDate(this.parmProjPeriodId(), (this.parmProjPeriodFrom() - 1));
                    }
                    else
                    {
                        projPeriodLine = ProjPeriodLine::findPrevFromDate(this.parmProjPeriodId(), this.parmProjPeriodFrom());
                    }

                    if (projPeriodLine)
                    {
                        projPeriodTo = projPeriodLine.PeriodTo;

                        if (ProjPeriodTable::find(this.parmProjPeriodId()).TimeFrequency == PerDayWeekMthQtYr::Day)
                        {
                            select firstonly reverse projPeriodLine
                                where projPeriodLine.PeriodId == this.parmProjPeriodId() &&
                                      projPeriodLine.PeriodTo <= projPeriodTo;
                        }
                    }

                    if (prevProjControlPeriodTable.RecId && (prevProjControlPeriodTable.PeriodFrom != projPeriodLine.PeriodFrom))
                    {
                        ret = false;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEliminated</Name>
				<Source><![CDATA[
    private boolean isEliminated()
    {
        return (select firstonly projControlPeriodTable
                    where   projControlPeriodTable.ProjId       == projWIPTable.ProjId
                    &&      projControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Eliminate).RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForecastModelStopped</Name>
				<Source><![CDATA[
    public boolean isForecastModelStopped()
    {
        return ForecastModel::find(HeadingSub::Heading,this.parmForecastModelId()).Blocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    IdentifierName lastValueDesignName()
    {
        return queryValue(periodic);
    }

]]></Source>
			</Method>
			<Method>
				<Name>outputIncludeCreated</Name>
				<Source><![CDATA[
    NoYes outputIncludeCreated()
    {
        return NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>outputIncludeEliminated</Name>
				<Source><![CDATA[
    NoYes outputIncludeEliminated()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>outputIncludePosted</Name>
				<Source><![CDATA[
    NoYes outputIncludePosted()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>outputIncludeReversed</Name>
				<Source><![CDATA[
    NoYes outputIncludeReversed()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcknowledgementDate</Name>
				<Source><![CDATA[
    public AcknowledgementDate parmAcknowledgementDate(AcknowledgementDate _acknowledgementDate = acknowledgementDate)
    {
        acknowledgementDate = _acknowledgementDate;

        return acknowledgementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBeginningBalance</Name>
				<Source><![CDATA[
    public ProjBeginningBalance parmBeginningBalance(ProjBeginningBalance _beginningBalance = beginningBalance)
    {
        beginningBalance = _beginningBalance;

        return beginningBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheck</Name>
				<Source><![CDATA[
    public boolean parmCheck(boolean _checkControl = checkControl)
    {
        checkControl  = _checkControl;

        return checkControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContinuesPeriodes</Name>
				<Source><![CDATA[
    public boolean parmContinuesPeriodes(boolean _continuesPeriodes = continuesPeriodes)
    {
        continuesPeriodes = _continuesPeriodes;

        return continuesPeriodes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeleteForecast</Name>
				<Source><![CDATA[
    public NoYes parmDeleteForecast(NoYes _deleteforecast = deleteforecast)
    {
        deleteforecast = _deleteforecast;

        return deleteforecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEliminate</Name>
				<Source><![CDATA[
    public NoYes parmEliminate(NoYes _eliminate = eliminate)
    {
        eliminate  = _eliminate;

        return eliminate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForcastModelold</Name>
				<Source><![CDATA[
    public ProjForecastModelId parmForcastModelold(ProjForecastModelId _forecastModelIdOld = forecastModelIdOld)
    {
        forecastModelIdOld  = _forecastModelIdOld;

        return forecastModelIdOld;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForecastModelId</Name>
				<Source><![CDATA[
    public ProjForecastModelId parmForecastModelId(ProjForecastModelId _forecastModelId = forecastModelId)
    {
        forecastModelId  = _forecastModelId;

        return forecastModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsProjPeriodContolTableRecalculated</Name>
				<Source><![CDATA[
    protected boolean parmIsProjPeriodContolTableRecalculated(boolean _isRecalc = isRecalc)
    {
        isRecalc = _isRecalc;

        return isRecalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkProjectAsFinished</Name>
				<Source><![CDATA[
    public NoYes parmMarkProjectAsFinished(NoYes _markProjectAsFinished = markProjectAsFinished)
    {
        markProjectAsFinished = _markProjectAsFinished; //maybe hidden on the form.. and not applicable for oru use case

        return markProjectAsFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkProjectAsInProcess</Name>
				<Source><![CDATA[
    public NoYes parmMarkProjectAsInProcess(NoYes _markProjectAsInProcess = markProjectAsInProcess)
    {
        markProjectAsInProcess = _markProjectAsInProcess;

        return markProjectAsInProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodic</Name>
				<Source><![CDATA[
    public boolean parmPeriodic(boolean _periodic = periodic)
    {
        periodic  = _periodic;

        return periodic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostWIPWarnings</Name>
				<Source><![CDATA[
    public NoYes parmPostWIPWarnings(NoYes _postWIPWarnings = postWIPWarnings)
    {
        postWIPWarnings = _postWIPWarnings;

        return postWIPWarnings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevPeriodFrom</Name>
				<Source><![CDATA[
    public ProjPeriodFrom parmPrevPeriodFrom(ProjPeriodFrom _prevPeriodFrom = prevPeriodFrom)
    {
        prevPeriodFrom = _prevPeriodFrom;

        return prevPeriodFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevVersion</Name>
				<Source><![CDATA[
    public ProjControlVersion parmPrevVersion(ProjControlVersion _prevVersion = prevVersion)
    {
        prevVersion = _prevVersion;

        return prevVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCompletionMethod</Name>
				<Source><![CDATA[
    public ProjControlCompletionMethod parmProjCompletionMethod(
        ProjControlCompletionMethod  _projCompletionMethod = projCompletionMethod)
    {
        projCompletionMethod = _projCompletionMethod;

        return projCompletionMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlId</Name>
				<Source><![CDATA[
    public ProjControlId parmProjControlId(ProjControlId _controlId = controlId)
    {
        controlId = _controlId;

        return controlId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlTypeOutput</Name>
				<Source><![CDATA[
    public ProjControlTypeOutput parmProjControlTypeOutput(ProjControlTypeOutput _outputResult = outputResult)
    {
        outputResult = _outputResult;

        return outputResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlVersion</Name>
				<Source><![CDATA[
    public ProjControlVersion parmProjControlVersion(ProjControlVersion _version = projControlVersion)
    {
        projControlVersion = _version ? _version : 1;

        return projControlVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCostGroupId</Name>
				<Source><![CDATA[
    public ProjCostGroupId parmProjCostGroupId(ProjCostGroupId _costGroupId = costGroupId)
    {
        costGroupId  = _costGroupId;

        return costGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCostType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProjCostType</c> parameter.
    /// </summary>
    /// <param name="_costType">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProjCostType</c> parameter.
    /// </returns>
    public ProjCostType parmProjCostType(ProjCostType _costType = costType)
    {
        costType    = _costType;

        return costType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjEstimateMethod</Name>
				<Source><![CDATA[
    public ProjEstimateMethod parmProjEstimateMethod(ProjEstimateMethod  _projEstimateMethod = projEstimateMethod)
    {
        projEstimateMethod = _projEstimateMethod;

        return projEstimateMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjId</Name>
				<Source><![CDATA[
    public ProjId parmProjId(ProjId _parmProjId = projId)
    {
        projId = _parmProjId;

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjPeriodFrom</Name>
				<Source><![CDATA[
    public ProjPeriodFrom parmProjPeriodFrom(ProjPeriodFrom _period = periodFrom)
    {
        periodFrom  = _period;

        return periodFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjPeriodId</Name>
				<Source><![CDATA[
    public ProjPeriodId parmProjPeriodId(ProjPeriodId _projPeriodId = periodId)
    {
        periodId    = _projPeriodId;

        return periodId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjPeriodTo</Name>
				<Source><![CDATA[
    public ProjPeriodTo parmProjPeriodTo(ProjPeriodTo    _period = periodTo)
    {
        periodTo  = _period;

        return periodTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDate</Name>
				<Source><![CDATA[
    public ProjTransDate parmProjTransDate(ProjTransDate _enterDate = enterDate)
    {
        enterDate = _enterDate;

        return enterDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjWIPProjId</Name>
				<Source><![CDATA[
    public ProjWipId parmProjWIPProjId(ProjWipId _parmWIPProjId = wipProjId)
    {
        wipProjId = _parmWIPProjId;

        return wipProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsContractLineUsed</Name>
				<Source><![CDATA[
    public boolean parmIsContractLineUsed(boolean _isContractLineUsed = isContractLineUsed )
    {
        isContractLineUsed = _isContractLineUsed;

        return isContractLineUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjWIPTable</Name>
				<Source><![CDATA[
    public ProjWIPTable parmProjWIPTable(ProjWIPTable _projWIPTable = projWIPTable)
    {
        projWIPTable    = _projWIPTable;

        return projWIPTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowInfoLog</Name>
				<Source><![CDATA[
    public NoYes parmShowInfoLog(NoYes _outputInfolog = outputInfolog)
    {
        outputInfolog = _outputInfolog;

        return outputInfolog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowQueryValues</Name>
				<Source><![CDATA[
    public boolean parmShowQueryValues(boolean _showQueryValues = showQueryValues)
    {
        showQueryValues = _showQueryValues;

        return showQueryValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateCalculation</Name>
				<Source><![CDATA[
    public NoYes parmUpdateCalculation(NoYes _updateCalculation = updateCalculation)
    {
        updateCalculation = _updateCalculation;

        return updateCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipCreateEstimateValidation</Name>
				<Source><![CDATA[
    public boolean parmSkipCreateEstimateValidation(boolean _skipCreateEstimateValidation = skipCreateEstimateValidation)
    {
        skipCreateEstimateValidation = _skipCreateEstimateValidation;

        return skipCreateEstimateValidation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodCalculate</Name>
				<Source><![CDATA[
    void periodCalculate()
    {
        ProjTable projTableLoc = ProjTable::find(this.parmProjWIPTable().ProjId);
        ProjControlCalc controlCalc;
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            controlCalc = ProjControlCalc::constructFromWIPProjectOrRevenueProfile(this.parmProjWIPTable(), this.parmEliminate());
        }
        else
        {
            projTableLoc = ProjTable::find(this.parmProjWIPTable().ProjId);
            controlCalc = ProjControlCalc::constructFromProjGroupOrRevenueProfile(projTableLoc, this.parmEliminate(), ProjContractBillingMethod::FixedPrice);
        }
        controlCalc.parmProjId(this.parmProjWIPTable().ProjId);
        controlCalc.parmControlId(this.parmProjWIPTable().ControlId);
        controlCalc.parmPeriodFrom(this.parmProjPeriodFrom());
        controlCalc.parmControlVersion(this.parmProjControlVersion());
        controlCalc.parmEliminate(this.parmEliminate());
        controlCalc.parmPeriodTo(this.parmProjPeriodTo());
        controlCalc.parmBeginningBalance(this.parmBeginningBalance());
        controlCalc.parmIsContractLineUsed(this.parmProjWIPTable().IsContractLineUsed);

        controlCalc.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodCreate</Name>
				<Source><![CDATA[
    void periodCreate()
    {
        this.periodInsert();

        if (this.parmForcastModelold() && this.parmForecastModelId())
        {
            this.copyEstimate();
        }

        this.costGroupInsert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjControlPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a new <c>ProjControlPerdiodTable</c> buffer.
    /// </summary>
    /// <returns>The populated <c>ProjControlPerdiodTable</c> buffer.</returns>
    protected ProjControlPeriodTable populateProjControlPeriod()
    {
        ProjControlPeriodTable projControlPeriod, projControlPeriodPrev;

        projControlPeriod.ProjId            = this.parmProjWIPProjId();
        projControlPeriod.ControlId         = this.parmProjControlId();
        projControlPeriod.ModelId           = this.parmForecastModelId();
        projControlPeriod.PeriodFrom        = this.parmProjPeriodFrom();
        projControlPeriod.PeriodTo          = this.parmProjPeriodTo();
        projControlPeriod.Version           = this.parmProjControlVersion();
        projControlPeriod.Elimination       = this.parmEliminate();
        projControlPeriod.EliminationOrig   = this.parmEliminate();
        projControlPeriod.PeriodId          = this.parmProjPeriodId();
        projControlPeriod.BeginningBalance  = this.parmBeginningBalance();

        switch (this.parmProjCompletionMethod())
        {
            case ProjControlCompletionMethod::Automatic:
                projControlPeriod.AutoManualCalculation = ProjAutoManual::Auto;
                break;

            case ProjControlCompletionMethod::Manual:
                projControlPeriod.AutoManualCalculation = ProjAutoManual::Manual;
                break;

            case ProjControlCompletionMethod::Default_:
                projControlPeriod.AutoManualCalculation = ProjControl::find(controlId).AutoManual;
                break;
        }

        projControlPeriod.PeriodStatus      = ProjControlPeriodStatus::Created;

        projControlPeriodPrev               = ProjControlPeriodTable::findPrev(
                                                projControlPeriod.ProjId,
                                                projControlPeriod.ControlId,
                                                projControlPeriod.PeriodFrom,
                                                false,
                                                projControlPeriod.Elimination);

        if (projControlPeriodPrev)
        {
            projControlPeriod.EstimateOutput    = projControlPeriodPrev.EstimateOutput;
            projControlPeriod.LedgerDimension   = projControlPeriodPrev.LedgerDimension;
            projControlPeriod.AssetIdNew        = projControlPeriodPrev.AssetIdNew;
            projControlPeriod.AssetBookId       = projControlPeriodPrev.AssetBookId;
            projControlPeriod.ProjIdNew         = projControlPeriodPrev.ProjIdNew;
            projControlPeriod.CategoryNew       = projControlPeriodPrev.CategoryNew;
            projControlPeriod.ActivityNew       = projControlPeriodPrev.ActivityNew;
            projControlPeriod.QtyCostNew        = projControlPeriodPrev.QtyCostNew;
            projControlPeriod.LinePropertyIdNew = projControlPeriodPrev.LinePropertyIdNew;
            projControlPeriod.TotalMaxCapital   = projControlPeriodPrev.TotalMaxCapital;
        }

        if (projControlPeriod.AutoManualCalculation == ProjAutoManual::Auto)
        {
            projControlPeriod.CompletePct = projControlPeriod.CompletePctCalculated;
        }
        else
        {
            projControlPeriod.CompletePct = projControlPeriodPrev.CompletePct;
        }

        return projControlPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodInsert</Name>
				<Source><![CDATA[
    private void periodInsert()
    {
        ProjControlPeriodTable projControlPeriod = this.populateProjControlPeriod();

        projControlPeriod.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>prevPeriodIsValid</Name>
				<Source><![CDATA[
    boolean prevPeriodIsValid()
    {
        boolean                 ret = true;

        // Is there any records at all ??
        if ((select firstonly reverse projControlPeriodTable
                    where   projControlPeriodTable.ProjId       == projWIPTable.ProjId
                    &&      projControlPeriodTable.PeriodStatus != ProjControlPeriodStatus::Reversal).RecId)
        {
            // find record where estimate has already been posted for a period > period in current estimate.
            ProjControlPeriodTable  nextProjControlPeriodTable = this.findNextControlPeriodTable();

            if (nextProjControlPeriodTable.RecId)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNextControlPeriodTable</Name>
				<Source><![CDATA[
    private ProjControlPeriodTable findNextControlPeriodTable()
    {
        ProjControlPeriodTable  nextProjControlPeriodTable;
        ProjPeriodFrom newEstimatePeriodFrom = this.parmProjPeriodFrom();

        select firstonly RecId from nextProjControlPeriodTable
                where   nextProjControlPeriodTable.ProjId == projWIPTable.ProjId
                && (nextProjControlPeriodTable.PeriodFrom > newEstimatePeriodFrom
                || (nextProjControlPeriodTable.PeriodFrom == newEstimatePeriodFrom && nextProjControlPeriodTable.BeginningBalance == this.parmBeginningBalance()))
                && nextProjControlPeriodTable.PeriodStatus != ProjControlPeriodStatus::Reversal;

        return nextProjControlPeriodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPrevControlPeriodTable</Name>
				<Source><![CDATA[
    private ProjControlPeriodTable findPrevControlPeriodTable()
    {
        ProjControlPeriodTable prevProjControlPeriodTable;
        
        select firstonly reverse RecId, PeriodFrom, BeginningBalance from prevProjControlPeriodTable
                where   prevProjControlPeriodTable.ProjId       == projWIPTable.ProjId
                &&      prevProjControlPeriodTable.PeriodFrom   <= this.parmProjPeriodFrom()
                &&      prevProjControlPeriodTable.PeriodStatus != ProjControlPeriodStatus::Reversal;
        
        return prevProjControlPeriodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressSet</Name>
				<Source><![CDATA[
    void progressSet(Counter _i)
    {
        Counter i = _i;

        i++;
        progress.setCount(i);
        progress.setText(this.progressTransText(this.parmProjPeriodFrom()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressTransText</Name>
				<Source><![CDATA[
    private str progressTransText(ProjPeriodFrom _periodFrom)
    {
        return strFmt("@SYS50726",_periodFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    /// The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used if a query prompt is the dialog, and if a Select menu item is added to a dialog
    /// box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in
    /// the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlPeriod));
        }
        else
        {
            logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlPeriod));
        }
        if (this.isInBatch())
        {
            subtasksNumForEstimate = ProjcontrolPeriod::getSubtasksNumForEstimates();
            shouldExecuteBatchInMultiSubtasks = this.shouldExecuteBatchInMultiSubtasks();
        }

        this.runEnhancedCommitmentScope();

        if (this.canOutput())
        {
            if (this.parmProjControlTypeOutput() != ProjControlTypeOutput::NothingToPrint)
            {
                Args args = new Args();
                args.parmObject(this);
                this.showSRSReport(args);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRunProgress</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void initRunProgress(boolean _getNonEliminatedProjectsCount = true)
    {
        int numOfWipProjects = 1;
        
        if (_getNonEliminatedProjectsCount && this.parmPeriodic())
        {
            ProjWIPTable projWIPProject;
            select count(RecId) from projWIPProject
                where projWIPProject.WIPEliminated == NoYes::No;

            numOfWipProjects = int642int(projWIPProject.RecId);
        }

        this.progressInit(strFmt("@SYS50725", this.parmProjPeriodFrom()), numOfWipProjects, #AviUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyCreatableViewQuery</Name>
				<Source><![CDATA[
    private void applyCreatableViewQuery()
    {
        Query query = this.queryRun().query();
        QueryBuildDataSource dataSourceProjTable = query.dataSourceTable(tableNum(ProjTable));
            
        if (dataSourceProjTable)
        {
            QueryBuildDataSource qbdsCreatableView = dataSourceProjTable.addDataSource(tableNum(ProjControlPeriodCreatableView));
            qbdsCreatableView.relations(false);
            qbdsCreatableView.joinMode(JoinMode::InnerJoin);
            qbdsCreatableView.addLink(fieldNum(ProjTable, WIPProject), fieldNum(ProjControlPeriodCreatableView, WIPProject));

            skipCreateEstimateValidation = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runEnhancedCommitmentScope</Name>
				<Source><![CDATA[
    private void runEnhancedCommitmentScope()
    {
        try
        {
            if (!shouldExecuteBatchInMultiSubtasks)
            {
                this.initRunProgress();
            }

            if (this.shouldApplyCreatableViewQuery())
            {
                this.applyCreatableViewQuery();
            }
            
            queryRun.reset();

            if (shouldExecuteBatchInMultiSubtasks)
            {
                this.createEstimateInMultiSubTasks();
            }
            else
            {
                using (var activityContext = logger.revRecActivity().estimateCommitmentScopeFlightEnabled())
                {
                    int totalWIPProjs;

                    if (multipleContractLinesFeatureEnabled || (contractLineBasedRevRecFeature && isContractLineUsed))
                    {
                        while (queryRun.next())
                        {
                            ProjWIPTable projWIPTableLoc = queryRun.get(tableNum(ProjWIPTable));
                
                            if (this.validateWIPProjectForMultipleContractLineFeature(projWIPTableLoc))
                            {
                                totalWIPProjs++;
                                this.actionExecution();
                            }
                        }
                    }
                    else
                    {
                        while (queryRun.next())
                        {
                            totalWIPProjs++;
                            this.actionExecution();
                        }
                    }

                    activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::ProjControlType, enum2Symbol(enumNum(ProjControlType), projControlType));
                    activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::NumOfEstimateProject, int2Str(totalWIPProjs));
                    activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::IsBatchProcessing, any2Str(this.isInBatch()));
                }
            }
        }
        catch (Exception::Error)
        {
            logger.logError(strFmt(ProjConstants::GeneralLoggerErrorMsg,
                'ProjControlPeriod.runEnhancedCommitmentScope()',
                'Caught Exception::Error'));
            throw error("@SYS21628");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalWIPProjToProcess</Name>
				<Source><![CDATA[
    private int getTotalWIPProjToProcess(Set _wipProjSet)
    {
        while (queryRun.next())
        {
            ProjWIPTable projWIPTableLoc = queryRun.get(tableNum(ProjWIPTable));

            boolean validWIPProj = true;
            if (multipleContractLinesFeatureEnabled || (contractLineBasedRevRecFeature && isContractLineUsed))
            {
                validWIPProj = this.validateWIPProjectForMultipleContractLineFeature(projWIPTableLoc);
            }

            if (validWIPProj)
            {
                _wipProjSet.add(projWIPTableLoc.ProjId);
            }
        }

        int totalWIPProjs = _wipProjSet.elements();

        return totalWIPProjs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBundleSize</Name>
				<Source><![CDATA[
    private int getBundleSize(int _wipProjectsNum, int _remainingSubTasks)
    {
        int bundleSize;
        if (_remainingSubTasks > 0)
        {
            if (_remainingSubTasks >= _wipProjectsNum)
            {
                bundleSize = 1;
            }
            else
            {
                bundleSize = roundUp(_wipProjectsNum / _remainingSubTasks, 1);
            }
        }
        return bundleSize;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEstimateInMultiSubTasks</Name>
				<Source><![CDATA[
    private void createEstimateInMultiSubTasks()
    {
        using (var activityContext = logger.revRecActivity().createEstimateSubTasksDistribution())
        {
            activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::ProjControlType, enum2Symbol(enumNum(ProjControlType), projControlType));
            activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::NumOfSubtasks, int2Str(subtasksNumForEstimate));

            boolean valid = true;
            if (subtasksNumForEstimate <= 0)
            {
                valid = false;
                logger.logError(strFmt(ProjConstants::GeneralLoggerErrorMsg, 'ProjControlPeriod.createEstimateInMultiSubTasks()',
                    'Number of subtasks is less than 1.'));
            }

            Set wipProjSet;
            int totalWIPProjs;
            if (valid)
            {
                wipProjSet = new Set(Types::String);
                totalWIPProjs = this.getTotalWIPProjToProcess(wipProjSet);

                activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::NumOfEstimateProject, int2Str(totalWIPProjs));

                if (totalWIPProjs <= 0)
                {
                    valid = false;
                    logger.logError(strFmt(ProjConstants::GeneralLoggerErrorMsg, 'ProjControlPeriod.createEstimateInMultiSubTasks()',
                        'Number of estimate projects is less than 1.'));
                }
            }

            if (valid)
            {
                // Create unique identify for this batch execution
                guid batchGUID = newGuid();
                activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::BatchExecutionGUID, guid2Str(batchGUID));

                ProjControlPeriodCreateBundle bundle;
                Batch batchInstance = this.parmCurrentBatch();
                BatchHeader batchHeader = BatchHeader::getCurrentBatchHeader();

                SetIterator wipProjSetIterator = new SetIterator(wipProjSet);
                int bundleItemCounter, distributedWIPProjsCounter, distributedSubtasks, bundleSize, maxBundleSize;
                int subtaskId = 1;

                while (wipProjSetIterator.more())
                {
                    // Initialize ProjControlPeriodCreateBundle object for each subtask.
                    if (bundleItemCounter == 0)
                    {
                        bundleSize = this.getBundleSize(totalWIPProjs - distributedWIPProjsCounter, subtasksNumForEstimate - distributedSubtasks);
                        maxBundleSize = maxBundleSize > bundleSize ? maxBundleSize : bundleSize;
                        bundle = ProjControlPeriodCreateBundle::construct(bundleSize);
                    }

                    bundleItemCounter++;
                    distributedWIPProjsCounter++;

                    ProjWipId wipProjIdLoc = wipProjSetIterator.value();
                    if (bundleItemCounter <= bundleSize)
                    {
                        RunBaseBatch createEstimatesBatch = ProjControlPeriodCreateTask::Construct(
                            batchGUID, subtaskId, wipProjIdLoc, this);
                        bundle.addTask(createEstimatesBatch);
                    }

                    if (bundle.isFull())
                    {
                        bundleItemCounter = 0;
                        distributedSubtasks++;
                        
                        if (batchInstance)
                        {
                            batchHeader.addRuntimeTask(bundle, batchInstance.RecId);
                        }
                        else
                        {
                            batchHeader.addTask(bundle);
                        }
                       
                        subtaskId = distributedSubtasks + 1;
                    }
                    wipProjSetIterator.next();
                }

                activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::MaxSubtaskBundleSize, int2Str(maxBundleSize));
    
                batchHeader.save();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWIPProjectForMultipleContractLineFeature</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the <c>ProjWIPTable</c> table record.
    /// </summary>
    /// <param name = "_projWIPTable"><c>ProjWIPTable</c> table record buffer.</param>
    /// <returns>true if the project estimate record is valid; otherwise, false.</returns>
    /// <remarks>This method should only be called when <c>ProjEnableMultipleContractLinesForProjectFeature</c> is enabled.</remarks>
    private boolean validateWIPProjectForMultipleContractLineFeature(ProjWIPTable _projWIPTable)
    {
        boolean valid = true;
        if ( _projWIPTable.IsContractLineUsed)
        {
            ProjRevRecHelper::prepareFixedPriceRevRecProjectWithRevProfileContractLine(_projWIPTable);
        }

        if (!_projWIPTable.ProjRevenueProfileId)
        {
            warning(strFmt("@Proj:FPRevRecProjectRevProfileAssociationFailure", _projWIPTable.ProjId));
            valid = false;
        }
        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionExecution</Name>
				<Source><![CDATA[
    private void actionExecution()
    {
        try
        {
            ttsbegin;
            this.action();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                logger.logError(strFmt(LoggerRetryExceptionMsg, 'Deadlock', 'ProjControlPeriod.actionExecution()', projWIPTable.RecId));
                throw Exception::Deadlock;
            }
            else
            {
                sleep(ProjConstants::DeadLockRetryInterval * xSession::currentRetryCount());
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    logger.logError(strFmt(LoggerRetryExceptionMsg, 'UpdateConflict', 'ProjControlPeriod.actionExecution()', projWIPTable.RecId));
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                logger.logError(strFmt(LoggerTTSLevelNotZeroExceptionMsg, 'UpdateConflict', 'ProjControlPeriod.actionExecution()', projWIPTable.RecId));
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                logger.logError(strFmt(LoggerRetryExceptionMsg, 'TransientSqlConnectionError', 'ProjControlPeriod.actionExecution()', projWIPTable.RecId));
                throw Exception::TransientSqlConnectionError;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the batch job will be run with the account of the user who created the job.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// If you want a batch job that extends this class to run on a client, you must override this method
    /// to return false. Jobs that return true must not access any client-side functionality. If true is
    /// returned, the batch server will execute the job by using the <c>runAs</c> method.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCostGroupCTCMethod</Name>
				<Source><![CDATA[
    protected void setCostGroupCTCMethod()
    {
        ProjControlPeriodCostGroup  costGroup;
        ProjControlPeriodCostGroup  locPrevCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        if (this.parmProjEstimateMethod() == ProjEstimateMethod::PreviousEstimate)
        {
            update_recordset costGroup
                setting ctcMethod = locPrevCostGroup.ctcMethod
                where costGroup.ProjId == this.parmProjWIPTable().ProjId &&
                    costGroup.ControlId == this.parmProjWIPTable().ControlId &&
                    costGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    costGroup.Version == this.parmProjControlVersion()
                    join locPrevCostGroup
                    where locPrevCostGroup.ProjId == costGroup.ProjId &&
                        locPrevCostGroup.ControlId == costGroup.ControlId &&
                        locPrevCostGroup.PeriodFrom == this.parmPrevPeriodFrom() &&
                        locPrevCostGroup.Version == this.parmPrevVersion() &&
                        locPrevCostGroup.CostGroupId == costGroup.CostGroupId;
        }
        else if (this.parmProjEstimateMethod() == ProjEstimateMethod::CostTemplate)
        {
            update_recordset costGroup
                setting ctcMethod = projControlCostGroup.ctcMethod
                where costGroup.ProjId == this.parmProjWIPTable().ProjId &&
                    costGroup.ControlId == this.parmProjWIPTable().ControlId &&
                    costGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    costGroup.Version == this.parmProjControlVersion()
                    join projControlCostGroup
                    where projControlCostGroup.ControlId == costGroup.ControlId &&
                          projControlCostGroup.CostGroupId == costGroup.CostGroupId;
        }
        else
        {
            update_recordset costGroup
                setting ctcMethod = this.getProjControlPeriodCostGroupCTCMethod()
                where costGroup.ProjId == this.parmProjWIPTable().ProjId &&
                    costGroup.ControlId == this.parmProjWIPTable().ControlId &&
                    costGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    costGroup.Version == this.parmProjControlVersion();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjControlPeriodCostGroupCTCMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>ProjControlPeriodCostGroupCTCMethod</c> enumeration value.
    /// </summary>
    /// <returns>
    /// A <c>ProjControlPeriodCostGroupCTCMethod</c> enumeration value.
    /// </returns>
    protected ProjControlPeriodCostGroupCTCMethod getProjControlPeriodCostGroupCTCMethod()
    {
        ProjControlPeriodCostGroupCTCMethod ctcMethod;

        if (this.parmProjEstimateMethod() == ProjEstimateMethod::TotalEstimateActual)
        {
            ctcMethod = ProjControlPeriodCostGroupCTCMethod::TotalEstimateActual;//Set cost to complete to zero
        }
        else if (this.parmProjEstimateMethod() == ProjEstimateMethod::TotalEstimate)
        {
            ctcMethod = ProjControlPeriodCostGroupCTCMethod::TotalEstimate;//Total cost - Actual
        }
        else if (this.parmProjEstimateMethod() == ProjEstimateMethod::RemainingEstimate)
        {
            ctcMethod = ProjControlPeriodCostGroupCTCMethod::RemainingEstimate;//Remaining budget
        }
        else if (this.parmProjEstimateMethod() == ProjEstimateMethod::TotBudgetMinusActual)
        {
            ctcMethod = ProjControlPeriodCostGroupCTCMethod::TotBudgetMinusActual;//Total budget - Actual
        }
        else if (this.parmProjEstimateMethod() == ProjEstimateMethod::WorkProgressPercentage)
        {
            ctcMethod = ProjControlPeriodCostGroupCTCMethod::WorkProgressPercentage;//Total budget - Actual
        }

        return ctcMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryValues</Name>
				<Source><![CDATA[
    void setQueryValues()
    {
        QueryRun                tmpQueryRun;
        Query                   tmpQuery;
        QueryBuildDataSource    tmpQueryBuildDataSource;
        QueryBuildRange         tmpQueryBuildRange;

        this.initQuery();

        if (this.queryRun())
        {
            tmpQueryRun = this.queryRun();

            if (tmpQueryRun)
            {
                tmpQuery = this.queryRun().query();

                if (tmpQuery.dataSourceTable(tableNum(ProjWIPTable)))
                {
                    tmpQueryBuildDataSource = tmpQuery.dataSourceTable(tableNum(ProjWIPTable));

                    if (tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable, ProjId)))
                    {
                        tmpQueryBuildRange = tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable, ProjId));
                        tmpQueryBuildRange.value(this.parmProjWIPProjId());
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a Select button to the dialog box.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> object.If you change the return value to false the button will no
    /// longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return showQueryValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showSRSReport</Name>
				<Source><![CDATA[
    public void showSRSReport(Args _args)
    {
        MenuFunction            menuItemRun;
        menuItemRun = new MenuFunction(menuitemOutputStr(projEstimateList),MenuItemType::Output);
        menuItemRun.run(_args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container _packedClass)
    {
        int         version = conPeek(_packedClass,1);
        container   packedQuery;

        #LOCALMACRO.List22
            periodFrom,
            periodTo,
            eliminate,
            forecastModelId,
            forecastModelIdold,
            projControlVersion,
            WIPProjId,
            costGroupId,
            periodic,
            projWIPTable,
            forecast,
            enterDate,
            showQueryValues,
            periodId,
            continuesPeriodes,
            outputInfolog,
            outputResult,
            deleteForecast,
            updateCalculation,
            markProjectAsFinished,
            markProjectAsInProcess,
            projEstimateMethod,
            ProjCompletionMethod
        #ENDMACRO

        #localmacro.List25
            periodFrom,
            periodTo,
            eliminate,
            forecastModelId,
            forecastModelIdold,
            projControlVersion,
            WIPProjId,
            costGroupId,
            periodic,
            projWIPTable,
            forecast,
            enterDate,
            showQueryValues,
            periodId,
            continuesPeriodes,
            outputInfolog,
            outputResult,
            deleteForecast,
            updateCalculation,
            markProjectAsFinished,
            markProjectAsInProcess,
            projEstimateMethod,
            ProjCompletionMethod,
            acknowledgementDate,
            postWIPWarnings,
            beginningBalance
        #endmacro

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.initQuery();
                }
                break;

            case 25:
                [version, #List25, packedQuery] = _packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.initQuery();
                }
                break;

            case 4:
                [version, #List22, packedQuery] = _packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.initQuery();
                }
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostGroup</Name>
				<Source><![CDATA[
    public void updateCostGroup()
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;

        while select forupdate projControlPeriodCostGroup
            where   projControlPeriodCostGroup.ProjId       == this.parmProjWIPTable().ProjId      &&
                    projControlPeriodCostGroup.ControlId    == this.parmProjWIPTable().ControlId   &&
                    projControlPeriodCostGroup.Version      == this.parmProjControlVersion()       &&
                    projControlPeriodCostGroup.PeriodFrom   == this.parmProjPeriodFrom()
        {
            this.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
            this.parmProjCostType(projControlPeriodCostGroup.costType());

            this.actualClear(projControlPeriodCostGroup);
            this.committedClear(projControlPeriodCostGroup);
            this.ctcClear(projControlPeriodCostGroup);
            this.forecastClear(projControlPeriodCostGroup);

            this.actual();
            this.committed();
            this.ctc(projControlPeriodCostGroup);
            this.forecast(projControlPeriodCostGroup);

            this.costGroupUpdate(projControlPeriodCostGroup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        boolean ret;

        ret = super(calledFrom);

        ret = ret && this.validateRemain();
        ret = ret && this.validateModel();
        ret = ret && this.validateEliminate();
        ret = ret && this.validatePeriodFrom();
        ret = ret && this.validateEstimateMethod();
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEliminate</Name>
				<Source><![CDATA[
    private boolean validateEliminate()
    {
        ProjControlPeriodTable  projControlPeriodOld;
        ProjParameters          projParameters;
        boolean                 ret;

        if (this.parmEliminate()  == NoYes::Yes)
        {
            projParameters = ProjParameters::find();
            ret = false;

            if(!contractLineBasedRevRecFeature || !isContractLineUsed)
            {
                if (CostControlTransCommittedCost::isWIPCommittedCostOpen(this.parmProjWIPTable().ProjId, projParameters.CommittedEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
                {
                    if ((projParameters.CommittedEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.CommittedEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                    {
                        ret = true;
                    }
                }
            }

            if (ProjEmplTrans::isWIPTransOpenBeforeDate(this.parmProjWIPTable().ProjId, this.parmProjPeriodTo(), projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
            {
                if ((projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                {
                    ret = true;
                }
            }

            if (ProjCostTrans::isWIPTransOpenBeforeDate(this.parmProjWIPTable().ProjId, this.parmProjPeriodTo(), projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
            {
                if ((projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                {
                    ret = true;
                }
            }

            if (ProjItemTransCost::isWIPTransOpenBeforeDate(this.parmProjWIPTable().ProjId, this.parmProjPeriodTo(), projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
            {
                if ((projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.TransBeforeEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                {
                    ret = true;
                }
            }

            if (ProjEmplTrans::isWIPTransOpenAfterDate(this.parmProjWIPTable().ProjId, this.parmProjPeriodTo(), projParameters.TransAfterEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
            {
                if ((projParameters.TransAfterEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.TransAfterEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                {
                    ret = true;
                }
            }

            if (ProjCostTrans::isWIPTransOpenAfterDate(this.parmProjWIPTable().ProjId, this.parmProjPeriodTo(), projParameters.TransAfterEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
            {
                if ((projParameters.TransAfterEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.TransAfterEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                {
                    ret = true;
                }
            }

            if (ProjItemTransCost::isWIPTransOpenAfterDate(this.parmProjWIPTable().ProjId, this.parmProjPeriodTo(), projParameters.TransAfterEliminationTolerance == ErrorTolerance::Accept ? ProjMsgLevel::Info : ProjMsgLevel::Warning))
            {
                if ((projParameters.TransAfterEliminationTolerance == ErrorTolerance::Error)
                    || (projParameters.TransAfterEliminationTolerance == ErrorTolerance::Warning && !this.parmPostWIPWarnings()))
                {
                    ret = true;
                }
            }

            if (ret)
            {
                return checkFailed("@SYS108969");
            }

            select reverse firstonly projControlPeriodOld
                order by PeriodFrom, Version
                where projControlPeriodOld.ProjId       == this.parmProjWIPTable().ProjId       &&
                        projControlPeriodOld.PeriodStatus == ProjControlPeriodStatus::Posted  &&
                        projControlPeriodOld.PeriodFrom   <= dateMax();

            if (! projControlPeriodOld)
            {
                return checkFailed("@SYS56618");
            }

            if (projControlPeriodOld && (projControlPeriodOld.ctcContract || projControlPeriodOld.CTCCostAmount))
            {
                return checkFailed("@SYS56600");
            }
        }
       
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEstimateMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if selected <c>ProjEstimateMethod</c> is valid with the selected wip project
    /// </summary>
    /// <returns>
    /// True if selected <c>ProjEstimateMethod</c> is compatiable with the wip project. False otherwise
    /// </returns>
    private boolean validateEstimateMethod()
    {
        if (this.parmProjEstimateMethod() == ProjEstimateMethod::WorkProgressPercentage)
        {
            if (!ProjControlWBS::doesWBSExistForProjTable(ProjTable::find(this.parmProjWIPProjId())))
            {
                return checkFailed(strFmt("@SYS4006498", this.parmProjWIPProjId()));
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateModel</Name>
				<Source><![CDATA[
    private boolean validateModel()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePeriodFrom</Name>
				<Source><![CDATA[
    boolean validatePeriodFrom()
    {
        ProjPeriodLine  projPeriodLine;

        if (!this.parmProjPeriodFrom())
        {
            return checkFailed("@SYS74628");
        }

        if (!(select projPeriodLine where projPeriodLine.PeriodId == this.parmProjPeriodId() && projPeriodLine.PeriodFrom == this.parmProjPeriodFrom()).RecId)
        {
            return checkFailed("@SYS74628");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRemain</Name>
				<Source><![CDATA[
    private boolean validateRemain()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static ProjControlPeriod construct(ProjControlType _projControlType)
    {
        ProjControlPeriod  retval;
        
        switch (_projControlType)
        {
            case ProjControlType::Check:
                retval = new ProjControlPeriodUpdateCheck();
                break;

            case ProjControlType::Update:
                retval = new ProjControlPeriodUpdate();
                break;

            case ProjControlType::Create:
            case ProjControlType::PeriodicCreate:
                retval = new ProjControlPeriodCreate();
                break;

            case ProjControlType::Delete:
            case ProjControlType::PeriodicDelete:
                retval = new ProjControlPeriodDelete();
                break;

            case ProjControlType::Calculate:
            case ProjControlType::PeriodicCalculate:
                retval = new ProjControlPeriodCalculate();
                break;

            case ProjControlType::Reversal:
            case ProjControlType::PeriodicReversal:
                retval = new ProjControlPeriodRevEstimate();
                break;

            case ProjControlType::Eliminate:
            case ProjControlType::PeriodicEliminate:
                retval = new ProjControlPeriodEliminate();
                break;

            case ProjControlType::EliminateReverse:
            case ProjControlType::PeriodicEliminateReverse:
                retval = new ProjControlPeriodEliminateRev();
                break;

            default:
                throw error(strFmt("@SYS26908", _projControlType));
        }
        retval.projControlType = _projControlType;

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    private static ClassDescription description()
    {
        return "@SYS57240";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        if (!args)
        {
            throw error("@SYS25407");
        }

        ProjControlType projControlType;
        if ( args.parmEnumType()  && args.parmEnumType() == enumNum(ProjControlType) )
        {
            projControlType = args.parmEnum();
        }

        ProjControlPeriod projControlPeriod  = ProjControlPeriod::new_ProjControlPeriodic(projControlType, args);

        if (projControlPeriod.prompt())
        {
            projControlPeriod.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new_ProjControlPeriodic</Name>
				<Source><![CDATA[
    static ProjControlPeriod new_ProjControlPeriodic(ProjControlType _projControlType, Args _args)
    {
        ProjControlPeriod           projControlPeriod = ProjControlPeriod::construct(_projControlType);
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlPeriodTable      projControlPeriodTable;

        switch (_args.dataset())
        {
            case tableNum(ProjControlPeriodCostGroup):
                projControlPeriodCostGroup  = _args.record();
                projControlPeriodTable      = projControlPeriodCostGroup.projControlPeriod();
                break;

            case tableNum(ProjControlPeriodTable):
                projControlPeriodTable  = _args.record();
                break;

            default :
                break;
        }

        switch (_projControlType)
        {
            case ProjControlType::Check :
                projControlPeriod.parmCheck(true);                         // should fall into update

            case ProjControlType::Update:
                projControlPeriod.getLast();
                projControlPeriod.parmPeriodic(false);

                projControlPeriod.parmProjPeriodFrom(projControlPeriodTable.PeriodFrom);
                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);
                break;

            case ProjControlType::Create:
                projControlPeriod.getLast();
                projControlPeriod.parmPeriodic(false);

                projControlPeriod.parmProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);
                break;

            case ProjControlType::Delete:
                projControlPeriod.getLast();

                projControlPeriod.parmPeriodic(false);

                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);
                projControlPeriod.parmProjPeriodFrom(projControlPeriodTable.PeriodFrom);
                projControlPeriod.parmProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmBeginningBalance(projControlPeriodTable.BeginningBalance);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);
                break;

            case ProjControlType::PeriodicCreate:
                projControlPeriod.parmPeriodic(true);
                break;

            case ProjControlType::PeriodicDelete:
                projControlPeriod.parmPeriodic(true);
                break;

            case ProjControlType::PeriodicCalculate:
                projControlPeriod.parmPeriodic(true);
                projControlPeriod.parmUpdateCalculation(true);
                break;

            case ProjControlType::Reversal:
                projControlPeriod.getLast();
                projControlPeriod.parmPeriodic(false);
                projControlPeriod.parmProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmBeginningBalance(projControlPeriodTable.BeginningBalance);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);
                break;

            case ProjControlType::PeriodicReversal:
                projControlPeriod.parmPeriodic(true);
                break;

            case ProjControlType::PeriodicEliminate:
                projControlPeriod.parmPeriodic(true);
                break;

            case ProjControlType::Calculate:
                projControlPeriod.getLast();
                projControlPeriod.parmProjPeriodFrom(projControlPeriodTable.PeriodFrom);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);

                projControlPeriod.parmUpdateCalculation(true);
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmPeriodic(false);
                projControlPeriod.parmBeginningBalance(projControlPeriodTable.BeginningBalance);
                break;

            case ProjControlType::Eliminate:
                projControlPeriod.getLast();
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);

                projControlPeriod.parmProjPeriodFrom(projControlPeriodTable.PeriodFrom);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);

                projControlPeriod.parmPeriodic(false);
                break;

            case ProjControlType::EliminateReverse:
                projControlPeriod.getLast();
                projControlPeriod.parmPeriodic(false);
                projControlPeriod.parmProjPeriodId(projControlPeriodTable.PeriodId ? projControlPeriodTable.PeriodId : ProjWIPTable::find(projControlPeriodTable.ProjId).PeriodId);
                projControlPeriod.parmProjWIPProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjId(projControlPeriodTable.ProjId);
                projControlPeriod.parmProjControlVersion(projControlPeriodTable.Version);
                projControlPeriod.parmProjControlId(projControlPeriodTable.ControlId);
                projControlPeriod.parmForecastModelId(projControlPeriodTable.ModelId);
                projControlPeriod.parmProjCostGroupId(projControlPeriodCostGroup.CostGroupId);
                projControlPeriod.parmIsContractLineUsed(ProjWIPTable::find(projControlPeriodTable.ProjId).IsContractLineUsed);

                projControlPeriod.parmProjPeriodFrom(projControlPeriodTable.PeriodFrom);
                projControlPeriod.parmProjPeriodTo(projControlPeriodTable.PeriodTo);
                break;

            case ProjControlType::PeriodicEliminateReverse:
                projControlPeriod.parmPeriodic(true);
                break;

            default :
                break;
        }

        // Set query values
        if (!projControlPeriod.parmPeriodic())
        {
            projControlPeriod.setQueryValues();
        }

        if (projControlPeriod.parmProjWIPProjId())
        {
            projControlPeriod.parmProjWIPTable(ProjWIPTable::find(projControlPeriod.parmProjWIPProjId()));
        }
        else
        {
            //change needed
            if (projControlPeriod.parmIsContractLineUsed() || ProjTable::find(projControlPeriod.parmProjId()).wipProject)
            {
                projControlPeriod.parmProjWIPTable(ProjWIPTable::find(projControlPeriod.parmProjWIPProjId()));
            }
        }

        projControlPeriod.parmShowQueryValues(projControlPeriod.parmPeriodic());

        return projControlPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateEstimate</Name>
				<Source><![CDATA[
    protected void recalculateEstimate(ProjControlPeriodTable  _localProjControlPeriodTable = null)
    {
        if ((this.parmProjPeriodId() && projWIPTable.PeriodId == this.parmProjPeriodId()))
        {
            if (this.parmPeriodic())
            {
                if (!_localProjControlPeriodTable)
                {
                    _localProjControlPeriodTable = ProjControlPeriodTable::find(projWIPTable.ProjId,projWIPTable.ControlId,this.parmProjPeriodFrom());
                }

                if (_localProjControlPeriodTable)
                {
                    this.parmProjPeriodFrom(_localProjControlPeriodTable.PeriodFrom);
                    this.parmProjControlVersion(_localProjControlPeriodTable.Version);
                    this.parmProjWIPProjId(_localProjControlPeriodTable.ProjId);
                    this.parmIsContractLineUsed(ProjWIPTable::find(_localProjControlPeriodTable.ProjId).IsContractLineUsed);

                    this.parmForecastModelId(_localProjControlPeriodTable.ModelId);
                    this.parmProjControlId(_localProjControlPeriodTable.ControlId);
                    this.parmProjPeriodTo(_localProjControlPeriodTable.PeriodTo);
                    this.parmProjPeriodId(_localProjControlPeriodTable.PeriodId ? _localProjControlPeriodTable.PeriodId : ProjWIPTable::find(_localProjControlPeriodTable.ProjId).PeriodId);
                    this.parmBeginningBalance(_localProjControlPeriodTable.BeginningBalance);
                }
            }

            if (! this.validate())
            {
                throw error("@SYS21628");
            }

            this.parmIsProjPeriodContolTableRecalculated(false);

            this.actualCreate();

            if (this.parmUpdateCalculation())
            {
                this.updateCostGroup();
            }

            this.periodCalculate();

            if (this.parmShowInfoLog())
            {
                if (!confind(projids,this.parmProjWIPProjId()))
                {
                    info(strfmt("@SYS76447", this.parmProjWIPProjId(), this.parmProjPeriodTo(), this.parmProjControlVersion()));
                    projids = conins(projids, (conlen(projids) ? conlen(projids) : 1 ) + 1, this.parmProjWIPProjId());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addEstimates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add estimate records by the specific <c>ProjWIPTable</c> table buffer
    /// by the specific parmProjPeriodFrom().
    /// </summary>
    /// <param name = "_projWIPTable"><c>ProjWIPTable</c> table buffer.</param>
    /// <remarks>
    /// This method should only be called if the specific estimates project
    /// do not have estimates records by the specific parmProjPeriodFrom().
    /// </remarks>
    protected void addEstimates(ProjWIPTable _projWIPTable)
    {
        boolean validEstimate = true;

        if (!_projWIPTable)
        {
            validEstimate = false;
        }
        else
        {
            this.parmProjWIPTable(_projWIPTable);
        }

        //Check permissions to create estimates
        if (validEstimate && !this.parmSkipCreateEstimateValidation() && !this.isValidToCreateEstimate(_projWIPTable))
        {
            validEstimate = false;
        }
            
        if (validEstimate)
        {
            this.progressSet(1);

            // If they don't have the same periodcode..... Don't even think about it...
            if (_projWIPTable.PeriodId == this.parmProjPeriodId())
            {
                if (! this.validate())
                {
                    throw error("@SYS21628");
                }

                if (this.prevPeriodIsValid() && this.canCreate() && !this.isEliminated())
                {
                    if (!this.parmContinuesPeriodes() || this.isContinuesPeriodesOk())
                    {
                        if (this.parmPeriodic()) // Update Parm to reflect the current record
                        {
                            this.parmProjWIPProjId(_projWIPTable.ProjId);
                            this.parmProjControlId(_projWIPTable.ControlId);
                        }

                        if (! this.validate())
                        {
                            throw error("@SYS21628");
                        }

                        if (this.checkCreatePeriod())
                        {
                            this.parmProjControlId(_projWIPTable.ControlId);
                            this.parmProjControlVersion(ProjControlPeriodTable::find(this.parmProjWIPProjId(), this.parmProjControlId(),this.parmProjPeriodFrom(),maxInt()).Version + 1);
                            this.parmProjPeriodTo(ProjControlPeriodTable::periodTo(_projWIPTable.PeriodId,this.parmProjPeriodFrom()));
                        }

                        if (! this.checkCreatePeriod() ||
                                 (this.checkCreatePeriod() && ! ProjControlPeriodTable::existCreated(this.parmProjWIPTable().ProjId,this.parmProjWIPTable().ControlId))
                                )
                        {
                            this.parmIsProjPeriodContolTableRecalculated(false);

                            if (this.checkCreatePeriod())
                            {
                                this.controlPeriodOld(true);
                                this.periodCreate();
                            }

                            this.initEstimateCreate();

                            if (! this.parmEliminate())
                            {
                                this.actualCreate();
                            }

                            this.updateCostGroup();

                            this.periodCalculate();

                            if (this.checkCreatePeriod())
                            {
                                if (this.parmShowInfoLog())
                                {
                                    info(strFmt("@SYS55663",this.parmProjWIPProjId(),this.parmProjPeriodTo(),this.parmProjControlVersion()));
                                }
                            }
                        }
                    }
                    else
                    {
                        str errorLabel;
                        if (FeatureStateProvider::isFeatureEnabled(ProjEstimatesToRevRecRenameFeature::instance()))
                        {
                            errorLabel = strFmt("@Proj:ProjEstimateCreationErrorV2", this.parmProjPeriodFrom());
                        }
                        else
                        {
                            errorLabel = strFmt("@Proj:ProjEstimateCreationError", this.parmProjPeriodFrom());
                        }
                        throw error(errorLabel);
                    }
                }
                else
                {
                    if (! this.prevPeriodIsValid() || ! this.canCreate())
                    {
                        str warningLabel;
                        if (FeatureStateProvider::isFeatureEnabled(ProjEstimatesToRevRecRenameFeature::instance()))
                        {
                            warningLabel = "@Proj:ProjRevRecEstimateCreationErrorV2";
                        }
                        else
                        {
                            warningLabel = "@Proj:ProjRevRecEstimateCreationError";
                        }

                        warning(warningLabel);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidToCreateEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the estimate project is valid.
    /// For classic PMA, we verify by project stage if any project which
    /// reference to this estimate project has valid status to create estimate.
    /// </summary>
    /// <param name = "_projWIPTable">
    /// <c>ProjWIPTable</c> estimate project table buffer.
    /// </param>
    /// <returns>
    /// true if the estimate project contains any project which can create estimate; otherwise, false.
    /// </returns>
    /// <remarks>
    /// For Project operation integration feature is enabled, then projects cannot rely on
    /// project stage rule to determine if the project can create estimates or not.
    /// Hence make this a protected method so that chain of command can be applied
    /// to add additional logic for the determination.
    /// </remarks>
    protected boolean isValidToCreateEstimate(ProjWIPTable _projWIPTable)
    {
        boolean valid;
        if (projOpsEnabled)
        {
            valid = true;
        }
        else
        {
            ProjControlPeriodCreatableView controlPeriodCreatableView;
            select firstonly RecId from controlPeriodCreatableView
                where controlPeriodCreatableView.WIPProject == _projWIPTable.ProjId;

            if (controlPeriodCreatableView)
            {
                valid = true;
            }
            else
            {
                valid = false;
            }
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSubtasksNumForEstimates</Name>
				<Source><![CDATA[
    /// <summary>
    /// The number of subtasks at most to be executed for project estimates operation.
    /// </summary>
    /// <returns>
    /// The number of subtasks at most for estimates batch to execute in parallel.
    /// </returns>
    protected static int getSubtasksNumForEstimates()
    {
        int numSubtasks;
        ProjParameters projParameters = ProjParameters::find();
        if (projParameters)
        {
            numSubtasks = projParameters.getMaxTasksForEstimateBatch();
        }
        else
        {
            numSubtasks = ProjConstants::NumOfBatchSubTasks;
        }
        return numSubtasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldApplyCreatableViewQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to have the query to join to <c>ProjControlPeriodCreatableView</c> to
    /// query just the creatable estimate projects.
    /// </summary>
    /// <returns>true if join to <c>ProjControlPeriodCreatableView</c> should be applied; otherwise, false.</returns>
    protected boolean shouldApplyCreatableViewQuery()
    {
        return !projOpsEnabled && projControlPeriodMultipleBatchTasksFeature && this is ProjControlPeriodCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldExecuteBatchInMultiSubtasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether batch execution will be processed through multiple subtasks.
    /// </summary>
    /// <returns>true if batch should execute in multiple substasks; otherwise, false.</returns>
    protected boolean shouldExecuteBatchInMultiSubtasks()
    {
        return projControlPeriodMultipleBatchTasksFeature && this is ProjControlPeriodCreate
            && subtasksNumForEstimate > 1  && this.isInBatch();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>