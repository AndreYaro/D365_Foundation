<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecuteDisplayUserDirected</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Handles the logic behind the RF flow used to find user directed works.
/// </summary>
[WHSWorkExecuteMode(WHSWorkExecuteMode::UserDirected)]
[WHSWorkExecuteMode(WHSWorkExecuteMode::SystemDirected)]
public class whsWorkExecuteDisplayUserDirected extends WHSWorkExecuteDisplay
{
    private WMSLocationId newLocationId;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildNoSysDirWork</Name>
				<Source><![CDATA[
	/// <summary>
	/// Adds controls to form state to show no work is available.
	/// </summary>
	/// <returns>
	/// Container containing the controls after they are added to the form state.
	/// </returns>
    public container buildNoSysDirWork()
    {
        container   ret = conNull();

        ret += [this.buildControl(#RFLabel, 'System Directed', pass.lookup(#MenuItem), 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFLabel, 'NoSysDirWork', "@WAX1834", 1, '', #WHSRFUndefinedDataType, '', 0, true, '', WHSRFColorText::Error)];

        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processButtonClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the button clicked.
    /// </summary>
    /// <param name = "_buttonClicked">The name of the button clicked.</param>
    /// <param name = "_workExecute">The work execute engine.</param>
    protected void processButtonClicked(str _buttonClicked, WhsWorkExecute _workExecute)
    {
        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
        
        switch (_buttonClicked)
        {
            case #RFOverride:
                step = #OverrideStep1;
                break;

            case #RFFull:
                if (step != 0)
                {
                    step = #SplitWork;
                }
                break;

            case #RFOK:
                if (pass.exists(#ExcludedLocations))
                {
                    //Once user click OK button, the excluded locations will be expired.
                    pass.remove(#ExcludedLocations);
                }
                break;

            case #RFNoLocation: // Suggest Location (NoLocation)
                Set excludeLocationId = new Set(Types::String);

                workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                if (pass.exists(#ExcludedLocations))
                {
                    excludeLocationId = this.buildLocationListFromStr(pass.lookup(#ExcludedLocations));
                }
                else
                {
                    excludeLocationId = this.buildLocationListFromStr(workLine.wmsLocationId);
                }
            
                container tmpCon;

                [newLocationId, tmpCon] = _workExecute.findNewLocation(workLine, excludeLocationId);
                excludeLocationId = Set::create(tmpCon);
                pass.insert(#SuggestLocation, 1);
                pass.insert(#ExcludedLocations, this.buildLocationListFromSet(excludeLocationId));
                if (pass.exists(#PrevStep))
                {
                    step = pass.lookup(#PrevStep);
                }
                else
                {
                    pass.insert(#NoValidation, '1');
                }
                break;

            case #RFShortPick:
                pass.insert(#Initiation, '1');
                step = #ShortPick;
                break;

            case WHSWorkExecuteShowWorkLineListConstants::SkipToButton:
                pass.insert(WHSWorkExecuteShowWorkLineListConstants::SkipLines, 1);
                pass.insert(WHSWorkExecuteShowWorkLineListConstants::PrevLineNum, pass.parmLineNum());
                step = #WorkLineListStep;
                break;

            case #RFSkip:
                workTable = WHSWorkTable::find(pass.lookup(#WorkId));
            
                if (menuItemTable.isUserDirectedMenuItem()
                || (workTable.countFirstPicks() > 1 && !WHSWorkTable::isFirstPutCompleted(workTable.WorkId)))
                {
                    // Remove dirty data of the skipped line for coming lines.
                    if (pass.exists(#LicensePlateId))
                    {
                        pass.remove(#LicensePlateId);
                    }

                    if (workTable.TargetLicensePlateId && !pass.exists(#TargetLicensePlateId))
                    {
                        select firstonly RecId from workLine
                        where workLine.WorkId       == pass.lookup(#WorkId)
                           && workLine.WorkType     == WHSWorkType::Pick
                           && workLine.WorkStatus   == WHSWorkStatus::Closed;

                        // If current line is skipped and no line was picked, rescan target LP.
                        if (!workLine.RecId)
                        {
                            WHSWorkTable::setTargetLicensePlate(workTable.WorkId, '');
                        }
                    }

                    if (pass.isGroupPick())
                    {
                        pass.skipGroupedWorkLines();
                    }
                    else
                    {
                        WHSWorkLine::skipWorkLine(pass.lookup(#WorkId), pass.parmLineNum());                                          
                        pass.clearGroupPickFail();                       
                    }

                    if (menuItemTable.isUserDirectedMenuItem()
                    || !workTable.allInitialPickWorkLinesSkipped())
                    {
                        workLine = _workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                    }
                    else
                    {
                        workLine = null;
                    }
                }
                if (!workLine)
                {
                    container skipWorkId = this.adjustPassSkipWorkId();

                    WHSSeqNum systemDirectedSequenceNumber = str2Int(pass.lookupStr(WHSWorkExecuteDisplayUserDirectedControls::SequenceNumber));

                    WHSSystemDirectedWorkLineDetails systemDirectedWorkLineDetails = _workExecute.getSystemDirectedWorkLineDetails(pass.lookup(#MenuItem),
                    pass.lookup(#InventSiteId),
                    pass.lookup(#InventLocationId),
                    userId,
                    skipWorkId,
                    systemDirectedSequenceNumber);

                    if (!systemDirectedWorkLineDetails.hasWorkLine())
                    {
                        pass.remove(#SkipWorkId);

                        systemDirectedWorkLineDetails = _workExecute.getSystemDirectedWorkLineDetails(pass.lookup(#MenuItem),
                        pass.lookup(#InventSiteId),
                        pass.lookup(#InventLocationId),
                        userId,
                        conNull(),
                        systemDirectedSequenceNumber);
                    }

                    workLine = systemDirectedWorkLineDetails.WorkLine;
                    pass.insert(WHSWorkExecuteDisplayUserDirectedControls::SequenceNumber, systemDirectedWorkLineDetails.SequenceNumber);

                    workTable = WHSWorkTable::find(workLine.WorkId);
                    pass.insert(#WorkId, workTable.WorkId);

                    if (pass.lookupStr(#LicensePlateId) != '')
                    {
                        pass.insert(#LicensePlateId, '');
                    }

                    if (pass.exists(#TargetLicensePlateId))
                    {
                        pass.remove(#TargetLicensePlateId);
                    }
                }

                this.clearVerificationFields();

                pass.parmLineNum(workLine.LineNum);
                pass.insert(#DetermineStep, 1);
                break;

            case #RFOverpick:
                pass.insert(#PrevStep, step);
                step = #OverpickStep;
                break;

            case #RFSplitPut:
                this.validateSplitPutAllowed();
                step = #SplitPutWork;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    public container displayForm(container _con, str _buttonClicked = '')
    {
        WhsWorkExecute                      workExecute = WhsWorkExecute::construct();
        WHSWorkExecuteDisplay               workExecuteDisplay = WHSWorkExecuteDisplay::construct(WHSWorkExecuteMode::UserDirected);
        WHSWorkExecuteDisplayCycleCount     workExecuteDisplayCycleCount = WHSWorkExecuteDisplay::construct(WhsWorkExecuteMode::CycleCounting);
        WHSWorkExecuteMode                  workExecuteMode;
        boolean                             hasError;
        boolean                             recall;
        container                           tmpPass;
        container                           ret;
        container                           con = _con;
        boolean                             addButtons = true;
        WHSRFPassthrough                    globalPass;
        boolean                             listWork;
        WHSRFMenuItemTable                  menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        globalPass = pass;

        pass = WHSRFPassthrough::create(conPeek(_con, 2));

        pass = this.combineMaps(globalPass, pass);

        if (pass.exists(#WorkListSavedID))
        {
            str workListSavedId = pass.lookup(#WorkListSavedID);
            pass.insert(#Id, workListSavedId);
            pass.insert(#WorkId, workListSavedId);
            pass.insert(#Recall, workListSavedId);
            pass.remove(#WorkListSavedID);

            if (menuItemTable.ShowWorkLineList == WHSShowWorkLineList::FirstPick)
            {
                pass.insert(WHSWorkExecuteShowWorkLineListConstants::ShowWorkLineList, 1);
            }

            step = 1;
        }

        pass.remove(#AddButtons);        

        hasError = this.hasError(con);


        if (pass.exists(#UserId))
        {
            userId = pass.lookup(#UserId);
        }

        this.processButtonClicked(_buttonClicked, workExecute);

        if (_buttonClicked == WHSWorkExecuteShowWorkLineListConstants::SkipToButton)
        {
            ret = this.buildWorkLineList(ret, menuItemTable, WHSWorkExecuteShowWorkLineListConstants::CancelResetProcessButton);
            pass.clearGroupPickFail();
       
            if (WHSWorkExecuteDisplayGroupPickSkipToWorkLineQtyVerificationStepEnabledFlight::instance().isEnabled())
            {
                // Group Pick flag will be re-initialized
                pass.clearGroupPick();
            }

            ret = this.updateModeStepPass(ret, mode, step, pass);
            return ret;
        }

        if (pass.exists(#WorkId)
            && WHSWorkTable::find(pass.lookup(#WorkId)).WorkTransType == WHSWorkTransType::CycleCount)
        {
            con = conPoke(con, 2, pass.pack());
            ret = this.displayCycleCount(con, 
                                         workExecuteDisplayCycleCount, 
                                         _buttonClicked, 
                                         globalPass);

            if (!pass.exists(#WorkId)
                && menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected)
            {
                ret            = conNull();
                _buttonClicked = #RFOK;
            }
            else
            {
                return ret;
            }
        }
        
        WHSSeqNum systemDirectedSequenceNumber = str2Int(pass.lookupStr(WHSWorkExecuteDisplayUserDirectedControls::SequenceNumber));

        if (!pass.exists(#WorkId) && menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected && step != #WorkAuditTemplate)
        {
            if (!pass.exists(#InventSiteId))
            {
                pass.insert(#InventLocationId, WHSWorkUserSession::find(userId).InventLocationId);
                pass.insert(#InventSiteId, InventLocation::find(WHSWorkUserSession::find(userId).InventLocationId).InventSiteId);
            }

            WHSSystemDirectedWorkLineDetails systemDirectedWorkLineDetails = workExecute.getSystemDirectedWorkLineDetails(pass.lookup(#MenuItem),
                    pass.lookup(#InventSiteId),
                    pass.lookup(#InventLocationId),
                    userId,
                    conNull(),
                    systemDirectedSequenceNumber);

            if (!systemDirectedWorkLineDetails.hasWorkLine() && pass.exists(#SkipWorkId))
            {
                pass.remove(#SkipWorkId);

                systemDirectedWorkLineDetails = workExecute.getSystemDirectedWorkLineDetails(pass.lookup(#MenuItem),
                        pass.lookup(#InventSiteId),
                        pass.lookup(#InventLocationId),
                        userId,
                        conNull(),
                        systemDirectedSequenceNumber);
            }

            workLine = systemDirectedWorkLineDetails.WorkLine;
            pass.insert(WHSWorkExecuteDisplayUserDirectedControls::SequenceNumber, systemDirectedWorkLineDetails.SequenceNumber);

            if (!workLine)
            {
                if (pass.exists(#WorkComplete))
                {
                    ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                    pass.remove(#WorkComplete);
                }
                ret += this.buildNoSysDirWork();
                ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::SystemDirected, step, pass);
                return ret;
            }
            pass.insert(#Id, workLine.WorkId);
            pass.insert(#Recall, 1);

            if (menuItemTable.ShowWorkLineList == WHSShowWorkLineList::FirstPick)
            {
                pass.insert(WHSWorkExecuteShowWorkLineListConstants::ShowWorkLineList, 1);
            }

            step = 1;
        }

        switch (step)
        {
            case 0:
                if (pass.exists(#WorkComplete))
                {
                    ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                    pass.remove(#Recall);
                }
                ret = this.buildGetWorkIdLicensePlateId(ret);
                addButtons = false;
                step = 1;

                if (menuItemTable.ShowWorkLineList == WHSShowWorkLineList::FirstPick)
                {
                    pass.insert(WHSWorkExecuteShowWorkLineListConstants::ShowWorkLineList, 1);
                }

                break;

            case 1:
                if (!pass.exists(#Recall))
                {
                    pass.insert(#Id, conPeek(conPeek(con, 4 + hasError), #data));
                }
                if (pass.exists(#WorkComplete))
                {
                    if (menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected)
                    {
                        if (menuItemTable.RFDisplayPickSummary == NoYes::Yes)
                        {
                            ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                            pass.remove(#WorkComplete);
                        }
                    }
                    else
                    {
                        pass.remove(#WorkComplete);
                    }
                }
                if (!pass.exists(#WorkId))
                {
                    if (!pass.exists(#Id) || pass.lookup(#Id) == '')
                    {
                        ret = this.addErrorLabel(ret, "@WAX1080", WHSRFColorText::Error);
                        ret = this.buildGetWorkIdLicensePlateId(ret);
                        addButtons = false;
                        break;
                    }

                    workTable = this.findWorkById();
                }
                else
                {
                    workTable = WHSWorkTable::find(pass.lookup(#WorkId));
                }

                if (!workTable)
                {
                    workTable = this.findWorkByTargetLicensePlateId(this.shouldHandleByLP());
                }

                this.validateWorkIsEligibleForDirectedFlows();
                
                if (this.shouldWorkBeLockedWhenWorkLineListShown() ||
                    this.shouldWorkBeLockedWhenDisplaySummaryShown())
                {
                    WHSWorkHeaderProcessingValidator::newFromWorkTable(workTable, userId).validateWorkHeaderForProcessing();
                    WHSWorkTable::lockUnlockWork(workTable.WorkId, userId);
                }

                pass.insert(#WorkId, workTable.WorkId);

                if (!workLine
                    && menuItemTable.ShowWorkLineList == WHSShowWorkLineList::FirstPick
                    && pass.exists(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum)
                    && !pass.exists(#CommentsDisplayed)
                    && WHSWorkExecuteDisplayLineKeepActiveAfterCommentsFlight::instance().isEnabled())
                {
                    workLine = WHSWorkLine::find(workTable.WorkId, pass.lookupNum(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum));
                }

                if (this.mustDisplayPickSummary())
                {
                    pass.insert(#CommentsDisplayed, 1);
                    ret = this.buildPickSummaryForm(ret);
                    ret = this.updateModeStepPass(ret, mode, step, pass);
                    break;
                }

                boolean fullQtyGroupPickFlight = WHSEnableFullQtyGroupPickFlight::instance().isEnabled();

                if (menuItemTable.ShowWorkLineList == WHSShowWorkLineList::EveryPick
                    && !pass.exists(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum)
                    && (!fullQtyGroupPickFlight || pass.parmPrevStep() != #SplitWork)
                    && workTable.hasOpenPickLinesPriorToFirstPut())
                {
                    step = #WorkLineListStep;
                    ret = this.buildWorkLineList(ret, menuItemTable, #RFCancel);
                    ret = this.updateModeStepPass(ret, mode, step, pass);
                    return ret;
                }

                if (menuItemTable.ShowWorkLineList == WHSShowWorkLineList::FirstPick
                    && pass.exists(WHSWorkExecuteShowWorkLineListConstants::ShowWorkLineList)
                    && (!fullQtyGroupPickFlight || pass.parmPrevStep() != #SplitWork)
                    && workTable.hasOpenPickLinesPriorToFirstPut())
                {
                    step = #WorkLineListStep;
                    pass.remove(WHSWorkExecuteShowWorkLineListConstants::ShowWorkLineList);
                    ret = this.buildWorkLineList(ret, menuItemTable, #RFCancel);
                    ret = this.updateModeStepPass(ret, mode, step, pass);
                    return ret;
                }

                if (!pass.exists(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum))
                {
                    workLine = workExecute.getFirstOpenLine(workTable.WorkId, userId);
                }
                else
                {
                    workLine = WHSWorkLine::find(workTable.WorkId, pass.lookupNum(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum));

                    WHSWorkHeaderProcessingValidator::newFromWorkTable(workLine.whsWorkTable(), userId).validateWorkHeaderForProcessing();
                    WHSWorkLineProcessingValidator::newFromWorkLine(workLine, userId).validateWorkLineForProcessing();

                    pass.remove(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum);
                }

                if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                {
                    if (pass.exists(#WorkId))
                    {
                        pass.remove(#WorkId);
                    }

                    // If rejecting a quality check, and the menu item does not have the correct work class for 
                    // the quality in quality check work created.
                    if (_buttonClicked == WHSWorkExecuteDisplayQualityCheckControls::Reject
                    &&  WHSWorkClassTable::exist(workLine.WorkClassId, WHSWorkTransType::QualityInQualityCheck))
                    {
                        throw error("@WAX:InvalidQualityCheckWorkClass");
                    }

                    throw error("@WAX1459");
                }

                if (!workLine)
                {
                    if (pass.exists(#WorkId))
                    {
                        pass.remove(#WorkId);
                    }
                    throw error("@WAX1323");
                }
                if (pass.lookup(#InventLocationId) != workLine.whsWorkTable().InventLocationId)
                {
                    if (pass.exists(#WorkId))
                    {
                        pass.remove(#WorkId);
                    }
                    throw error("@WAX1207");
                }
                pass.parmLineNum(workLine.LineNum);
                if (workTable.WorkTransType == WHSWorkTransType::CycleCount)
                {
                    con = conPoke(con, 2, pass.pack());
                    con = conPoke(con, 1, conPoke(conPeek(con, 1), 2, step));
                    ret = workExecuteDisplayCycleCount.displayForm(con, _buttonClicked);
                    return ret;
                }

                WHSWorkLine preWorkLine;
                int			runningWorkLineCount;
                int			totalWorkLines = WHSWorkLine::getTotalNumberOfWorkLinesForWorkType(workLine.WorkId, workLine.WorkType);
                boolean		okToReprocess  = (menuItemTable.GroupPutaway
                                          &&  workLine.WorkType == WHSWorkType::Put)
										  ||  WHSRFAutoConfirm::isAutoConfirmationEnabled(menuItemTable.MenuItemName, workLine.WorkType);

				do
                {
					pass.insert(#DetermineStep, 1);
					con	= conPoke(con, 2, pass.pack());
                    // This record could have been updated in the processsWorkLine() call below, 
					// and thus needs to be reread to get the updated Target LP value
                    workTable.reread();  
					workExecuteMode = this.getWorkExecuteModeFromWorkTransType(workTable.WorkTransType, workTable.TargetLicensePlateId);
                    preWorkLine		= workLine;

					[ret, step, recall, tmpPass] = this.processWorkLine(workLine, con, workExecuteMode, step, userId, newLocationId, _buttonClicked, false);

					pass = new WHSRFPassthrough(Types::String, Types::String);
					pass = WHSRFPassthrough::create(tmpPass);

					if (step == #Restart)
					{
						step = 0;

						// If restarting, need to remove target lp that might have been saved from group puts
						if (pass.exists(#TargetLicensePlateId))
						{
							pass.remove(#TargetLicensePlateId);
						}
					}
					else if (step == #StepOne)
					{
						step = 1;
						pass.insert(#DetermineStep, 1);
					}

                    runningWorkLineCount++;

                    if (runningWorkLineCount > totalWorkLines)
                    {
                        throw error(strFmt("@WAX:WorkProcessingPotentialError", workLine.WorkId, workLine.LineNum));
                    }
                }
				while (recall
                    && okToReprocess
                    && step				 == 1
					&& workLine.WorkType == preWorkLine.WorkType
                    && workLine.LineNum  != preWorkLine.LineNum);

                if (recall)
                {
                    pass.insert(WHSWorkExecuteDisplayUserDirectedControls::SequenceNumber, systemDirectedSequenceNumber);
                    [ret, addButtons, listWork] = this.recall(ret, addButtons, listWork, con, globalPass, workExecuteDisplay, _buttonClicked);
                }
                break;

            case #WorkLineListStep:
                str lineNum;

                if (_buttonClicked == WHSWorkExecuteShowWorkLineListConstants::CancelResetProcessButton)
                {
                    lineNum = pass.lookupStr(WHSWorkExecuteShowWorkLineListConstants::PrevLineNum);
                }
                else
                {
                    lineNum = _buttonClicked;
                }

                if (pass.lookupNum(WHSWorkExecuteShowWorkLineListConstants::PrevLineNum) != str2Num(lineNum)
                    && pass.exists(WHSWorkExecuteShowWorkLineListConstants::SkipLines))
                {
                    WHSWorkLine::skipWorkLinesTo(pass.lookup(#WorkId), userId, str2Num(lineNum));
                    pass.remove(WHSWorkExecuteShowWorkLineListConstants::SkipLines);
                }

                pass.insert(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum, lineNum);
                step = 1;
                this.updateModeStepPass(_con, mode, step, pass);

                return this.displayForm(_con);

            default:
                if (pass.exists(#WorkId) || step == #WorkAuditTemplate)
                {
                    if (pass.exists(#LineNum))
                    {
                        workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                    }
                    else if (pass.exists(#AuditWorkId))
                    {
                        workLine = WHSWorkTable::getLastWorkLine(pass.lookup(#AuditWorkId));
                        pass.insert(#InventLocationId, workLine.whsWorkTable().InventLocationId);
                    }
                    else
                    {
                        workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                    }

                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                    {
                        throw error("@WAX1459");
                    }

                    if (workLine)
                    {
                        if (pass.lookup(#InventLocationId) != workLine.whsWorkTable().InventLocationId)
                        {
                            throw(error("@WAX1207"));
                        }

                        LineNum prevLineNum = workLine.LineNum;

                        con = conPoke(con, 2, pass.pack());
                        workTable = workLine.whsWorkTable();
                        workExecuteMode = this.getWorkExecuteModeFromWorkTransType(workTable.WorkTransType, workTable.TargetLicensePlateId);
                        [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, workExecuteMode, step, userId, newLocationId, _buttonClicked, false);
                        pass = new WHSRFPassthrough(Types::String, Types::String);
                        pass = WHSRFPassthrough::create(tmpPass);

                        if (step == #Restart)
                        {
                            step = 0;
                            addButtons = false;

                            // If restarting, need to remove target lp that might have been saved from group puts
                            if (pass.exists(#TargetLicensePlateId))
                            {
                                pass.remove(#TargetLicensePlateId);
                            }
                        }
                        else if (step == #StepOne)
                        {
                            step = 1;
                            pass.insert(#DetermineStep, 1);
                        }

                        if (recall)
                        {
                            if (menuItemTable.ShowWorkLineList == WHSShowWorkLineList::EveryPick && workLine.LineNum == prevLineNum 
                                && WHSWorkExecuteDisplayWorkLineListKeepLineNumFlight::instance().isEnabled())
                            {
                                pass.insert(WHSWorkExecuteShowWorkLineListConstants::SelectedLineNum, workLine.LineNum);
                            }

                            pass.insert(WHSWorkExecuteDisplayUserDirectedControls::SequenceNumber, systemDirectedSequenceNumber);
                            [ret, addButtons, listWork] = this.recall(ret, addButtons, listWork, con, globalPass, workExecuteDisplay, _buttonClicked);
                        }
                    }
                    else
                    {
                        throw error("@WAX859");
                    }
                }
                else
                {
                    throw error("@WAX859");
                }
                break;
        }

        if (this.mustAddButtonsToForm(addButtons))
        {
            if (ret == conNull())
            {
                ret = _con;
            }
            ret = this.addButtons(ret);
        }

        if (!listWork)
        {
            ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::UserDirected, step, pass);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkById</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds work table that matches the current identity value.
    /// </summary>
    /// <returns>Work table that matches the current identity value.</returns>
    protected WHSWorkTable findWorkById()
    {
        return WHSWorkTable::find(pass.lookup(#Id));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWorkBeLockedWhenWorkLineListShown</Name>
				<Source><![CDATA[
    private boolean shouldWorkBeLockedWhenWorkLineListShown()
    {
        boolean ret;

        if (workTable
            && workTable.LockedUser != userId
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowWorkLineList != WHSShowWorkLineList::NeverShow)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWorkBeLockedWhenDisplaySummaryShown</Name>
				<Source><![CDATA[
    private boolean shouldWorkBeLockedWhenDisplaySummaryShown()
    {
        boolean ret;

        if (workTable
            && workTable.LockedUser != userId
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).RFDisplayPickSummary == NoYes::Yes)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAddButtonsToForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether buttons must be added to the form.
    /// </summary>
    /// <param name = "_addButtons">Boolean value indicating whether buttons should be added.</param>
    /// <returns>true if buttons must be added to the form; otherwise, false. </returns>
    protected boolean mustAddButtonsToForm(boolean _addButtons)
    {
        return _addButtons && !pass.exists(#AddButtons);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays cycle count work.
    /// </summary>
    /// <param name = "_con">The container with information from the pass.</param>
    /// <param name = "_workExecuteDisplayCycleCount">The current instance of the <c>WHSWorkExecuteDisplayCycleCount</c> class.</param>
    /// <param name = "_buttonClicked">The button that has been clicked.</param>
    /// <param name = "_globalPass">The pass value before running through the display form method.</param>
    /// <returns>The container after running through the cycle count flow.</returns>
    public container displayCycleCount(
        container                       _con, 
        WHSWorkExecuteDisplayCycleCount _workExecuteDisplayCycleCount, 
        str                             _buttonClicked, 
        WHSRFPassthrough                _globalPass)
    {
        container ret = _workExecuteDisplayCycleCount.displayForm(_con, _buttonClicked);

        pass = WHSRFPassthrough::create(conPeek(ret, 2));

        if (pass.exists(#WorkComplete)
            &&  _globalPass.exists(#CameFromWorkList)
            &&  step != #WorkAuditTemplate)
        {
            pass.insert(#MenuItem, _globalPass.lookup(#CameFromWorkList));
            pass.remove(#WorkComplete);

            mode = WHSRFMenuItemTable::getWHSWorkExecuteMode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)));

            WHSWorkExecuteDisplay workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);

            workExecuteDisplay.setGlobals(mode, 0, userId, pass);

            _con = this.updateModeStepPass(_con, WHSWorkExecuteMode::WorkList, 0, pass);
            _con = conPoke(_con, #StateInfo, [mode, 0]);

            ret = workExecuteDisplay.displayForm(_con);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recall</Name>
				<Source><![CDATA[
    private container recall(container _ret, boolean _addButtons, boolean _listWork, container _con, WHSRFPassthrough _globalPass, WHSWorkExecuteDisplay _workExecuteDisplay, str _buttonClicked)
    {
        WHSWorkExecuteDisplay               workExecuteDisplay = _workExecuteDisplay;
        container                           ret = _ret;
        container                           con = _con;
        boolean                             addButtons = _addButtons;
        boolean                             listWork = _listWork;

        if (pass.exists(#WorkComplete)
            && _globalPass.exists(#CameFromWorkList)
            && step != #WorkAuditTemplate)
        {
            pass.insert(#MenuItem, _globalPass.lookup(#CameFromWorkList));
            if (_globalPass.exists(WHSWorkExecuteDisplayListWorkControls::WorkListGroupingFieldValue))
            {
                var previousGrouppingFieldValue = _globalPass.lookupStr(WHSWorkExecuteDisplayListWorkControls::WorkListGroupingFieldValue);
                pass.insert(WHSWorkExecuteDisplayListWorkControls::WorkListGroupingFieldValue, previousGrouppingFieldValue);

                if (WHSShortPickKeepWorkListPrevWorkIdValueFlight::instance().isEnabled())
                {
                    if (_globalPass.exists(#WorkId))
                    {
                        pass.insert(#PrevWorkId, _globalPass.lookupStr(#WorkId));
                    }
                }
            }

            mode = WHSRFMenuItemTable::getWHSWorkExecuteMode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)));
            workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
            workExecuteDisplay.setGlobals(mode, 0, userId, pass);
            con = this.updateModeStepPass(con, WHSWorkExecuteMode::WorkList, 0, pass);
            con = conPoke(con, #StateInfo, [mode, 0]);
            ret = workExecuteDisplay.displayForm(con);
            listWork    = true;
            addButtons  = false;
        }
        else
        {
            pass.insert(#Recall, 1);
            con = this.updateModeStepPass(con, WHSWorkExecuteMode::UserDirected, step, pass);
            con = conPoke(con, 1, [WHSWorkExecuteMode::UserDirected, step]);

            if (_globalPass.exists(#CameFromWorkList) && !pass.exists(#CameFromWorkList))
            {
                pass.insert(#CameFromWorkList, _globalPass.lookup(#CameFromWorkList));
            }

            workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
            ret = workExecuteDisplay.displayForm(con, _buttonClicked);
            pass = new WHSRFPassthrough(Types::String, Types::String);
            pass = WHSRFPassthrough::create(conPeek(ret, 2));
            if (pass.exists(#WorkId) && pass.exists(#LineNum))
            {
                workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
            }
        }

        return [ret, addButtons, listWork];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPickSummaryForm</Name>
				<Source><![CDATA[
    private container buildPickSummaryForm(container _con)
    {
        container ret = this.buildComments(_con);
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkLineList</Name>
				<Source><![CDATA[
    private container buildWorkLineList(container _con, WHSRFMenuItemTable _menuItemTable, str _cancelButtonName)
    {
        container ret = this.buildWorkLineListHeader(_con, _menuItemTable);
        ret = this.buildWorkLineListTableContent(ret, _menuItemTable);

        ret += [this.buildControl(#RFButton, _cancelButtonName, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkLineListHeader</Name>
				<Source><![CDATA[
    private container buildWorkLineListHeader(container _con, WHSRFMenuItemTable _menuItemTable)
    {
        container ret = _con;

        //build header
        ret += [this.buildControl(#RFLabel, WHSWorkExecuteShowWorkLineListConstants::WorkLineList, WHSWorkExecuteShowWorkLineListConstants::WorkLineList, 1, '', #WHSRFUndefinedDatatype, '', 0)];

        int length = conLen(_menuItemTable.WorkListFieldList);

        for (var i = 1; i <= length; i++)
        {
            TableId tableId;
            IdentifierName identifierName;

            [identifierName, tableId] = _menuItemTable.workFieldAtPosition(i);

            if (tableId)
            {
                FieldId fieldId = fieldName2id(tableId, identifierName);

                ret += [this.buildControl(#RFButton, identifierName, fieldId2PName(tableId, fieldId), (i == 1), '', this.getHeaderControlDataType(tableId, fieldId), '', 0)];
            }
            else
            {
                // If no table Id must be a display method.
                SysDictMethod method = new SysDictMethod(UtilElementType::TableInstanceMethod, tableNum(WHSWorkLine), identifierName);
                
                // Assert the display method was found
                Debug::assert(method && method.name() == identifierName);

                ret += [this.buildControl(#RFLabel, identifierName, extendedTypeId2pname(method.returnId()), 0, '', this.getDataType(new SysDictType(method.returnId()).baseType()), '', 0)];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkLineListTableContent</Name>
				<Source><![CDATA[
    protected container buildWorkLineListTableContent(container _con, WHSRFMenuItemTable _menuItemTable)
    {
        container ret = _con;

        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(pass.lookup(#WorkId));
        WHSWorkLine workLineLocal;

        int numOfWorkLines = 0;
        while select firstonly1000 workLineLocal
            where workLineLocal.WorkId == pass.lookup(#WorkId)
                && workLineLocal.WorkType == WHSWorkType::Pick
                && workLineLocal.ReplenDemand == NoYes::No
                && workLineLocal.LineNum < cache.parmFirstPutLineNum()
                && (workLineLocal.WorkStatus == WHSWorkStatus::Open
                 || workLineLocal.WorkStatus == WHSWorkStatus::InProcess)
        {
            ret = this.addWorkLineToWorkLineList(ret, _menuItemTable, workLineLocal);
            
            numOfWorkLines++;
            if (numOfWorkLines > 500)
            {
                break;
            }
        }
     
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkLineToWorkLineList</Name>
				<Source><![CDATA[
    protected container addWorkLineToWorkLineList(container _con, WHSRFMenuItemTable _menuItemTable, WhsWorkLine _workLine)
    {
        str buttonName = int2Str(real2int(_workLine.LineNum));

        _con += [this.buildControl(#RFButton, buttonName, buttonName,  1, '', #WHSRFUndefinedDatatype, '', 0, true, '', WHSRFColorText::Default, extendedTypeNum(LineNum))];

        Counter length = conLen(_menuItemTable.WorkListFieldList);

        // The first element in field list is Linenum, which has been added as button. So here starts from 2.
        for (var i = 2; i <= length; i++)
        {
            IdentifierName  identifierName;
            TableId         tableId;

            [identifierName, tableId] = _menuItemTable.workFieldAtPosition(i);

            _con += [this.addWorkLineListFieldForWorkLine(_workLine, identifierName, tableId)];
        }

        return _con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkLineListFieldForWorkLine</Name>
				<Source><![CDATA[
    private container addWorkLineListFieldForWorkLine(WHSWorkLine _workLine, IdentifierName _identifierName, TableId _tableId)
    {
        FormControlName labelName;

        labelName = int2Str(real2int(_workLine.LineNum)) + '_' + _identifierName;
        

        if (_tableId)
        {
            FieldId fieldId = fieldName2id(_tableId, _identifierName);
            SysDictField dictField = new SysDictField(_tableId, fieldId);

            switch (dictField.baseType())
            {
                case Types::Enum:
                    SysDictEnum dictEnum = new SysDictEnum(dictField.enumId());
                    
                    return this.buildControl(#RFLabel, labelName, dictEnum.value2Label(_workLine.(fieldId)), 0, '', #WHSRFUndefinedDatatype, '', 0);
                    
                case Types::UtcDateTime:
                    return this.buildControl(#RFLabel, labelName, WhsrfControlData::convertDateTime2DateTimeFormatStrCurrentUserDateCulture(
                                                                                DateTimeUtil::applyTimeZoneOffset(_workLine.(fieldId),
                                                                                InventSite::timeZoneSite(_workLine.inventDim().InventSiteId)),
                                                                                pass.lookupStr(#UserId)),
                                                                                0, '', #WHSRFUndefinedDatatype, '', 0);
                    
                
                default:
                    return this.addDefaultWorkLineListField(_workLine, fieldId, labelName);
            }
        }
        else
        {
            // If no table must be display method from Work Line
            SysDictTable dictTable = new SysDictTable(tableNum(WHSWorkLine));
            anytype value = dictTable.callObject(_identifierName, _workLine);
            str valueStr = WHSWorkExecuteDisplay::value2StrDisplay(value, _workLine.inventDim().InventSiteId, pass.lookupStr(#UserId));
            return this.buildControl(#RFLabel, labelName, valueStr, 0, '', #WHSRFUndefinedDatatype, '', 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDefaultWorkLineListField</Name>
				<Source><![CDATA[
    protected container addDefaultWorkLineListField(WHSWorkLine _workLine, FieldId _fieldId, FormControlName _labelName)
    {
       
        return this.buildControl(#RFLabel, _labelName, _workLine.(_fieldId),  0, '', #WHSRFUndefinedDatatype, '', 0);
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSkipToButton</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean useSkipToButton(WHSWorkLine _workLine)
    {
        return workLine.WorkType == WHSWorkType::Pick
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowWorkLineList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessWorkLineForPickOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre-processes the work line for pick operation.
    /// </summary>
    /// <param name = "_state">The state for processing work lines.</param>
    /// <returns>true, if the pre-processing of the work line has been finished; otherwise, false.</returns>
    protected boolean preProcessWorkLineForPickOperation(WhsWorkProcessWorkLineState _state)
    {       
        return super( _state);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>