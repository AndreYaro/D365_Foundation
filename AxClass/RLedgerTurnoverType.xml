<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RLedgerTurnoverType</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RLedgerTurnoverType</c> class implements base logic for the report types
/// utilized by the <c>RLedgerTurnoverEngine</c> class
/// </summary>
abstract class RLedgerTurnoverType implements RLedgerTurnoverTypeable
{
    Set     accountNumSet;
    Set     offsetAccountNumSet;
    boolean expandedBalance;
    boolean updateMode;

    const str newLine = '; ';

    Map     mapTransFactureCache;
    Map     mapDimAttrRecId;
    RecId   factureSourceRecId;
    RecId   factureSplitTransRecId;
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addMainAccount</Name>
				<Source><![CDATA[
    private void addMainAccount(MainAccountNum _account, boolean _offset = false)
    {
        MainAccount                                 mainAccount, childTable;
        DimensionAttributeValue                     dimensionAttributeValue;
        DimensionAttributeValueTotallingCriteria    dimAttrValueTotCrit;

        if (! _account)
        {
            return;
        }

        mainAccount = MainAccount::findByMainAccountId(_account);

        if (mainAccount.Type == DimensionLedgerAccountType::Total)
        {
            while select TableId from dimensionAttributeValue
                where dimensionAttributeValue.DimensionAttribute == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)
                   && dimensionAttributeValue.EntityInstance     == mainAccount.RecId
            join InvertTotalSign, FromValue, ToValue from dimAttrValueTotCrit
                where dimAttrValueTotCrit.DimensionAttributeValue == dimensionAttributeValue.RecId
            {
                while select MainAccountId from childTable
                    where childTable.MainAccountId >= dimAttrValueTotCrit.FromValue &&
                          childTable.MainAccountId <= dimAttrValueTotCrit.ToValue   &&
                          childTable.MainAccountId != _account
                {
                    this.addMainAccount(childTable.MainAccountId, _offset);
                }
            }
        }

        if (! _offset)
        {
            accountNumSet.add(_account);
        }
        else
        {
            offsetAccountNumSet.add(_account);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMainAccountRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds main account range to the report query.
    /// </summary>
    /// <param name="_accountRange">
    /// The main account range value.
    /// </param>
    /// <param name="_offset">
    /// The flag indicating whether the range value relates to the offset account.
    /// </param>
    public void addMainAccountRange(MainAccountRange _accountRange, boolean _offset = false)
    {
        MainAccount          mainAccount;
        QueryBuildDataSource qbds;
        QueryBuildRange      qbr;
        Query                query;
        QueryRun             queryRun;

        if (_accountRange)
        {
            query = new Query();
            qbds = query.addDataSource(tableNum(MainAccount));

            qbr = qbds.addRange(fieldNum(MainAccount, LedgerChartOfAccounts));
            qbr.value(queryValue(LedgerChartOfAccounts::current()));

            qbr = qbds.addRange(fieldNum(MainAccount, MainAccountId));
            qbr.value(_accountRange);

            queryRun = new QueryRun(query);
            while (queryRun.next())
            {
                mainAccount = queryRun.get(tableNum(MainAccount));
                this.addMainAccount(mainAccount.MainAccountId, _offset);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRecIdFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds record ID filter to the transaction form data source.
    /// </summary>
    /// <param name="_formRun">
    /// A reference to the transaction form.
    /// </param>
    /// <param name="_tmpRecIdFilter">
    /// A temporary buffer containing record IDs.
    /// </param>
    protected void addRecIdFilter(FormRun _formRun, TmpRecIdFilter _tmpRecIdFilter)
    {
        const str recIdField = 'RecId';
        int                  idx;
        FormDataSource       formDataSource;
        QueryBuildDataSource queryDataSource;

        if (_tmpRecIdFilter)
        {
            for (idx = 1; idx <= _formRun.dataSourceCount(); idx++)
            {
                if (_formRun.dataSource(idx).cursor().TableId == this.transTableId())
                {
                    formDataSource = _formRun.dataSource(idx);
                    break;
                }
            }

            if (formDataSource)
            {
                queryDataSource = formDataSource.queryRun().query().dataSourceTable(this.transTableId());
                queryDataSource = queryDataSource.addDataSource(tableNum(TmpRecIdFilter));
                queryDataSource.addLink(fieldname2id(this.transTableId(), recIdField), fieldNum(TmpRecIdFilter, RefRecId));
                queryDataSource.fetchMode(QueryFetchMode::One2One);
                queryDataSource.joinMode(JoinMode::ExistsJoin);
                formDataSource.queryRun().setCursor(_tmpRecIdFilter);

                _formRun.dataSource().research();
                _formRun.doRefresh();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToFactureMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds facture information to the facture info cache.
    /// </summary>
    /// <param name="_factureJour">
    /// The facture journal table buffer.
    /// </param>
    protected void addToFactureMap(FactureJour_RU _factureJour)
    {
        container   mapValue;
        container   value;
        container   key = [factureSourceRecId, factureSplitTransRecId];

        if (mapTransFactureCache.exists(key))
        {
            mapValue = mapTransFactureCache.lookup(key);
        }

        value = [_factureJour.RecId,
                 _factureJour.FactureExternalId,
                 strFmt('%1', _factureJour.FactureDate_External)];

        if (! conFind(mapValue, value))
        {
            mapValue = conins(mapValue, conlen(mapValue) + 1, value);
            mapTransFactureCache.insert(key, mapValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountFieldLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding amount field labels.
    /// </summary>
    /// <returns>
    /// A container holding amount field labels.
    /// </returns>
    public container amountFieldLabels()
    {
        return [ "@GLS104989",
                 "@GLS104990",
                 "@GLS105001",
                 "@GLS105002",
                 "@GLS104995",
                 "@GLS104996" ] + (expandedBalance ? [ "@SYS4081705", "@SYS4081704" ] : ['', '']);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSelectParam</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a boolean value indicating whether the report parameter can be selected.
    /// </summary>
    /// <param name="_name">
    /// The name of the parameter.
    /// </param>
    /// <returns>
    /// true if the report parameter can be selected; otherwise, false.
    /// </returns>
    public boolean canSelectParam(Name _name)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPrecalcData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates precalculated data for a transaction.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_transHeader">
    /// A table buffer holding the transaction header.
    /// </param>
    /// <param name="_transSplit">
    /// A table buffer holding the split transaction.
    /// </param>
    public void createPrecalcData(Common _trans,
                                  Common _transHeader,
                                  Common _transSplit)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public ClassDescription description()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>drillThroughAction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a drill-through action for a particular amount.
    /// </summary>
    /// <param name="_query">
    /// The query for a drill-through form.
    /// </param>
    /// <param name="_amountType">
    /// The type of the amount.
    /// </param>
    /// <param name="_tmpRecIdFilter">
    /// The reference to a temporary table containing record IDs for filtering.
    /// </param>
    public void drillThroughAction(Query _query, int _amountType, TmpRecIdFilter _tmpRecIdFilter)
    {
        FormRun formRun;
        Args    args = new Args();

        args = new Args(this.transForm());
        args.caller(this);
        args.parmObject(_query);
        args.parmEnumType(enumnum(RLedgerTurnoverSheetType));

        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();

        this.addRecIdFilter(formRun, _tmpRecIdFilter);
        formRun.detach();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns field ID for the transaction field holding the amount.
    /// </summary>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <returns>
    /// A field ID for the transaction field holding the amount.
    /// </returns>
    public FieldId fieldAmount(CurrencyType_RU _currencyType)
    {
        FieldId ret;

        switch (_currencyType)
        {
            case CurrencyType_RU::Standard  :
                ret = this.fieldAmountMST();
                break;
            case CurrencyType_RU::Secondary :
                ret = this.fieldAmountMSTSec();
                break;
            case CurrencyType_RU::Currency  :
                ret = this.fieldAmountCur();
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns field ID for the transaction field holding the amount in currency.
    /// </summary>
    /// <returns>
    /// The field ID for the transaction field holding the amount in currency.
    /// </returns>
    protected FieldId fieldAmountCur()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns field ID for the transaction field holding the amount in accounting currency.
    /// </summary>
    /// <returns>
    /// The field ID for the transaction field holding the amount in accounting currency.
    /// </returns>
    protected FieldId fieldAmountMST()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountMSTSec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns field ID for the transaction field holding the amount in reporting currency.
    /// </summary>
    /// <returns>
    /// The field ID for the transaction field holding the amount in reporting currency.
    /// </returns>
    protected FieldId fieldAmountMSTSec()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns field ID for the transaction field holding the correction flag.
    /// </summary>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <returns>
    /// A container with table ID and field ID for the transaction field holding the correction flag.
    /// </returns>
    public container fieldCorrection(CurrencyType_RU _currencyType = CurrencyType_RU::Standard)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the currency code field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the currency code field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldCurrencyCode()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the default dimension field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the default dimension field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldDefaultDimension()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the ledger dimension field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the ledger dimension field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldLedgerDimension()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the Main account field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the Main account field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldMainAccount()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldOperationsTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the posting layer field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the posting layer field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldOperationsTax()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldSettlementDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the settlement date field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the settlement date field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldSettlementDate()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the table and field IDs for the transaction date field.
    /// </summary>
    /// <returns>
    /// A container holding the table and field IDs for the transaction date field.
    /// </returns>
    /// <remarks>
    /// [TableId, FieldId]
    /// </remarks>
    public container fieldTransDate()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the facture journal for the particular voucher and transaction date.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_voucher">
    /// The transaction voucher.
    /// </param>
    /// <returns>
    /// true if the facture journal has been found; otherwise, false.
    /// </returns>
    protected boolean findFacture(TransDate _transDate, Voucher _voucher)
    {
        boolean found;

        found = this.findFactureAdvExchAdj(_transDate, _voucher);

        if (! found)
        {
            found = this.findFacturePostingLog(_transDate, _voucher);
        }

        if (! found)
        {
            found = this.findFactureSettlement(_transDate, _voucher);
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFactureAdvExchAdj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the facture journal of type 'exchange adjustment' for the particular voucher and transaction date.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_voucher">
    /// The transaction voucher.
    /// </param>
    /// <returns>
    /// true if the facture journal has been found; otherwise, false.
    /// </returns>
    protected boolean findFactureAdvExchAdj(TransDate _transDate, Voucher _voucher)
    {
        boolean        ret;
        FactureJour_RU factureJour;

        while select factureJour
            where factureJour.Voucher     == _voucher                        &&
                 (factureJour.FactureType == FactureType_RU::Prepayment      ||
                  factureJour.FactureType == FactureType_RU::AmoutDifference ||
                  factureJour.FactureType == FactureType_RU::ExchAdj         ||
                  factureJour.FactureType == FactureType_RU::VATAdjustment   ||
                  factureJour.FactureType == FactureType_RU::AdvanceAdjustment)
        {
            this.addToFactureMap(factureJour);
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFactureAdvReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the facture journal of type 'advance report' for the particular voucher and transaction date.
    /// </summary>
    /// <param name="_emplTrans">
    /// The advance holder transaction table buffer.
    /// </param>
    /// <returns>
    /// true if the facture journal has been found; otherwise, false.
    /// </returns>
    protected boolean findFactureAdvReport(EmplTrans_RU _emplTrans)
    {
        boolean         ret;
        FactureJour_RU  factureJour;
        FactureTrans_RU factureTrans;
        EmplAdvLine_RU  emplAdvLine = EmplAdvLine_RU::findTransEmplRecId(_emplTrans.RecId);

        while select factureJour
            exists join factureTrans
            where factureTrans.FactureId        == factureJour.FactureId
               && factureTrans.Module           == factureJour.Module
               && factureTrans.FactureLineType  == FactureLineType_RU::AdvanceReport
               && ((emplAdvLine.RecId
               && factureTrans.Module           == FactureModule_RU::Empl
               && factureTrans.InvoiceId        == emplAdvLine.AdvanceId
               && factureTrans.InvoiceLineNum   == emplAdvLine.LineNum)
               || (factureTrans.MarkupRefRecId  == _emplTrans.RecId
               && factureTrans.MarkupRefTableId == _emplTrans.TableId))
        {
            this.addToFactureMap(factureJour);
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFactureInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the facture journal of type 'invoice' for the particular voucher and transaction date.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The invoice transaction table buffer.
    /// </param>
    /// <returns>
    /// true if the facture journal has been found; otherwise, false.
    /// </returns>
    protected boolean findFactureInvoice(CustVendTrans _custVendTrans)
    {
        boolean                 ret;
        FactureJour_RU          factureJour;
        FactureTrans_RU         factureTrans;
        FactureModule_RU        module;
        CustVendInvoiceJour     custVendInvoiceJour;
        TableId                 tableId = _custVendTrans.TableId == tablenum(CustTrans) ?
                                          tablenum(CustInvoiceJour)                     :
                                          tablenum(VendInvoiceJour);

        custVendInvoiceJour = new DictTable(tableId).makeRecord();

        select firstonly custVendInvoiceJour
            where custVendInvoiceJour.InvoiceAccount == _custVendTrans.AccountNum &&
                  custVendInvoiceJour.InvoiceDate    == _custVendTrans.TransDate  &&
                  custVendInvoiceJour.InvoiceId      == _custVendTrans.Invoice    &&
                  custVendInvoiceJour.LedgerVoucher  == _custVendTrans.Voucher;

        if (! custVendInvoiceJour)
        {
            return false;
        }

        module = _custVendTrans.TableId == tablenum(CustTrans) ? FactureModule_RU::Cust : FactureModule_RU::Vend;

        while select factureJour
            where factureJour.Module == module
        exists join factureTrans
            where factureTrans.FactureId            == factureJour.FactureId                           &&
                  factureTrans.Module               == factureJour.Module                              &&
                  factureTrans.FactureLineType      == FactureLineType_RU::InvoiceLine                 &&
                  factureTrans.InvoiceId            == custVendInvoiceJour.InvoiceId                   &&
                  factureTrans.InvoiceDate          == custVendInvoiceJour.InvoiceDate                 &&
                  (module                           == FactureModule_RU::Cust                          ||
                  factureTrans.InternalInvoiceId    == custVendInvoiceJour.PurchInternalInvoiceId_RU)  &&
                  factureTrans.SalesPurchId         == custVendInvoiceJour.Num                         &&
                  factureTrans.NumberSequenceGroup  == custVendInvoiceJour.NumberSequenceGroupId
        {
            this.addToFactureMap(factureJour);
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFacturePostingLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the facture journal for the particular voucher and transaction date using transaction posting log.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_voucher">
    /// The transaction voucher.
    /// </param>
    /// <returns>
    /// true if the facture journal has been found; otherwise, false.
    /// </returns>
    protected boolean findFacturePostingLog(TransDate _transDate, Voucher _voucher)
    {
        boolean                    ret;
        CustVendTrans              custVendTrans;
        CustVendTransPostingLog_RU transPostingLog;

        while select * from transPostingLog
            where transPostingLog.TransDate == _transDate &&
                  transPostingLog.Voucher   == _voucher
        {
            custVendTrans = new DictTable(transPostingLog.RefTableId).makeRecord();

            if (transPostingLog.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStorno ||
                transPostingLog.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStornoVAT)
            {
                changecompany(transPostingLog.TransCompany)
                {
                    custVendTrans.company(transPostingLog.TransCompany);
                    select firstonly custVendTrans
                        where custVendTrans.RecId == transPostingLog.TransRecId;

                    ret = this.findFactureAdvExchAdj(custVendTrans.TransDate, custVendTrans.Voucher) || ret;
                }
            }
            else
            {
                changecompany(transPostingLog.TransCompany)
                {
                    custVendTrans.company(transPostingLog.TransCompany);
                    select firstonly custVendTrans
                        where custVendTrans.RecId == transPostingLog.TransRecId;

                    ret = this.findFactureInvoice(custVendTrans) || ret;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFactureSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the facture journal for the particular voucher and transaction date using settlement history.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_voucher">
    /// The transaction voucher.
    /// </param>
    /// <returns>
    /// true if the facture journal has been found; otherwise, false.
    /// </returns>
    protected boolean findFactureSettlement(TransDate _transDate, Voucher _voucher)
    {
        boolean             ret;
        CustVendTrans       custVendTrans;
        CustVendSettlement  custVendSettlement;

        void findSettlement(TableId _tableId)
        {
            custVendTrans = new DictTable(_tableId).makeRecord();
            custVendSettlement = CustVendTransStatic::newTrans(custVendTrans).custVendSettlement();

            select firstonly custVendSettlement
                where custVendSettlement.TaxVoucher_RU  == _voucher
                   && custVendSettlement.TransDate      == _transDate;

            if (custVendSettlement)
            {
                changecompany(custVendSettlement.TransCompany)
                {
                    custVendTrans.company(custVendSettlement.TransCompany);
                    select firstonly custVendTrans
                        where custVendTrans.RecId       == custVendSettlement.TransRecId
                           && custVendTrans.AccountNum  == custVendSettlement.AccountNum;

                    ret = this.findFactureInvoice(custVendTrans);
                }
            }
        }

        findSettlement(tablenum(VendTrans));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getKeyValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a key value for a transaction field for filtering purposes.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_fieldId">
    /// The field ID for the key field.
    /// </param>
    /// <returns>
    /// The key value for a transaction field for filtering purposes.
    /// </returns>
    public anytype getKeyValue(Common _trans, fieldId _fieldId)
    {
        return _trans.(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupKeyData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding field IDs of key fields for filtering purposes.
    /// </summary>
    /// <param name="_key">
    /// A container holding the selected parameters of the report.
    /// </param>
    /// <returns>
    /// A container holding field IDs of key fields for filtering purposes.
    /// </returns>
    public container groupKeyData(container _key)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the default report grouping parameters.
    /// </summary>
    /// <returns>
    /// A container holding the default report grouping parameters.
    /// </returns>
    public container groupParamDefault()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding labels for selected report grouping parameters.
    /// </summary>
    /// <param name="_key">
    /// A container holding the selected grouping parameters of the report.
    /// </param>
    /// <returns>
    /// A container holding labels for the selected report grouping parameters.
    /// </returns>
    public container groupParamLabels(container _key)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamNames</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding the list of available report grouping parameters.
    /// </summary>
    /// <returns>
    /// A container holding the list of available report grouping parameters.
    /// </returns>
    public container groupParamNames()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamValueName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the description of a particular report grouping parameter value.
    /// </summary>
    /// <param name="_paramName">
    /// The name of the report grouping parameter.
    /// </param>
    /// <param name="_paramValue">
    /// The value of the report grouping parameter.
    /// </param>
    /// <param name="_common">
    /// The table buffer containing the record of the related entity.
    /// </param>
    /// <returns>
    /// The description of a particular report grouping parameter value.
    /// </returns>
    public Name groupParamValueName(Name _paramName, container _paramValue, Common _common = null)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container of grouping parameter values for the transaction.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_key">
    /// A container holding the selected grouping parameters of the report.
    /// </param>
    /// <param name="_transHeader">
    /// A table buffer holding the transaction header.
    /// </param>
    /// <param name="_transSplit">
    /// A table buffer holding the split transaction.
    /// </param>
    /// <returns>
    /// A container of grouping parameter values for the transaction.
    /// </returns>
    public container groupParamValues(Common    _trans,
                                      container _key,
                                      Common    _transHeader = null,
                                      Common    _transSplit  = null)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the transaction must be included in the report calculation.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_subtrans">
    /// A table buffer holding the related transaction.
    /// </param>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <param name="_fromDate">
    /// The starting date of the report period.
    /// </param>
    /// <param name="_toDate">
    /// The ending date of the report period.
    /// </param>
    /// <returns>
    /// true if the transaction must be included in the report calculation; otherwise, false.
    /// </returns>
    public boolean isTransIncluded(Common           _trans,
                                   Common           _subtrans,
                                   CurrencyType_RU  _currencyType,
                                   TransDate        _fromDate = dateNull(),
                                   TransDate        _toDate   = dateNull())
    {
        TransactionReversalTrans reversalTrans;
        TransactionReversalTrans reversalTransOffset;
        Common                   transOffset    = _trans.data();
        FieldId                  fieldTransDate = conPeek(this.fieldTransDate(), 2);

        if (_trans.(this.fieldAmount(_currencyType)) == 0)
        {
            return false;
        }

        if (_fromDate && _toDate)
        {
            reversalTrans = TransactionReversalTrans::findTransactionReversalTrans(_trans.TableId, _trans.RecId);
            if (reversalTrans.Reversed)
            {
                select firstonly reversalTransOffset
                    where reversalTransOffset.TraceNum == reversalTrans.TraceNum
                       && reversalTransOffset.RecId    != reversalTrans.RecId
                exists join transOffset
                    where  transOffset.TableId           == reversalTransOffset.RefTableId
                       &&  transOffset.RecId             == reversalTransOffset.RecId
                       && (transOffset.(fieldTransDate)  <  _fromDate
                       ||  transOffset.(fieldTransDate)  >  _toDate);

                if (! reversalTransOffset)
                {
                    return false;
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the Main account report grouping parameter.
    /// </summary>
    /// <returns>
    /// The name of the Main account report grouping parameter.
    /// </returns>
    public str keyMainAccount()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the class name.
    /// </summary>
    /// <returns>
    /// The class name.
    /// </returns>
    public ClassName name()
    {
        return classStr(RLedgerTurnoverType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        mapTransFactureCache    = new Map(Types::Container, Types::Container);
        mapDimAttrRecId         = new Map(Types::String,    Types::Int64);
        accountNumSet           = new Set(Types::String);
        offsetAccountNumSet     = new Set(Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExpandedBalance</Name>
				<Source><![CDATA[
    public boolean parmExpandedBalance(boolean _expandedBalance = expandedBalance)
    {
        expandedBalance = _expandedBalance;
        return expandedBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateMode</Name>
				<Source><![CDATA[
    public boolean parmUpdateMode(boolean _updateMode = updateMode)
    {
        updateMode = _updateMode;
        return updateMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the packed query of the report type.
    /// </summary>
    /// <returns>
    /// The packed query of the report type.
    /// </returns>
    public container query()
    {
        Query query = new Query();

        query.addDataSource(this.transTableId());

        return query.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the packed balance query of the report type.
    /// </summary>
    /// <param name="_key">
    /// A container holding the selected grouping parameters of the report.
    /// </param>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <param name="_debitCredit">
    /// The type of calculated amounts.
    /// </param>
    /// <param name="_query">
    /// The query of the report.
    /// </param>
    /// <param name="_debitExpr">
    /// An extended query range expression for debit amounts; optional.
    /// </param>
    /// <param name="_creditExpr">
    /// An extended query range expression for credit amounts; optional.
    /// </param>
    /// <returns>
    /// The packed balance query of the report type.
    /// </returns>
    public container queryBalance(container         _key,
                                  CurrencyType_RU   _currencyType,
                                  DebCredProposal   _debitCredit = DebCredProposal::None,
                                  Query             _query       = null,
                                  str               _debitExpr   = '',
                                  str               _creditExpr  = '')
    {
        QueryBuildDataSource    qbds;
        QueryBuildDataSource    qbds_W;
        Query                   query           = _query;
        FieldName               fieldAmount     = fieldid2name(this.transTableId(), this.fieldAmount(_currencyType));
        FieldName               fieldCorrection;
        TableId                 tableIdCorrection;
        FieldId                 fieldIdCorrection;
        str                     debitExpr;
        str                     creditExpr;
        const str TableIdField = 'TableId';

        [tableIdCorrection, fieldIdCorrection]  = this.fieldCorrection(_currencyType);

        fieldCorrection = fieldid2name(tableIdCorrection, fieldIdCorrection);

        debitExpr       = _debitExpr  ? _debitExpr  : '((%1.' + fieldAmount + ' > 0) && (%2.' + fieldCorrection + ' == 0)) || ((%1.'
                                                              + fieldAmount + ' < 0) && (%2.' + fieldCorrection + ' == 1))';

        creditExpr      = _creditExpr ? _creditExpr : '((%1.' + fieldAmount + ' < 0) && (%2.' + fieldCorrection + ' == 0)) || ((%1.'
                                                              + fieldAmount + ' > 0) && (%2.' + fieldCorrection + ' == 1))';

        if (! query)
        {
            query = new Query(this.query());
        }

        qbds  = query.dataSourceTable(this.subTransTableId());
        if (! qbds)
        {
            throw error(strfmt("@GLS105652", funcname()));
        }

        if (tableIdCorrection != this.subTransTableId())
        {
            qbds_W = query.dataSourceTable(tableIdCorrection);

            if (! qbds_W)
            {
                throw error(strfmt("@GLS105652", funcname()));
            }
        }

        switch (_debitCredit)
        {
            case DebCredProposal::Debit :
                findOrCreateRange_W(qbds,
                                    fieldname2id(this.subTransTableId(), tableIdField),
                                    strFmt(debitExpr, qbds.name(), tableIdCorrection == this.subTransTableId() ? qbds.name() : qbds_W.name()));
                break;
            case DebCredProposal::Credit :
                findOrCreateRange_W(qbds,
                                    fieldname2id(this.subTransTableId(), tableIdField),
                                    strFmt(creditExpr, qbds.name(), tableIdCorrection == this.subTransTableId() ? qbds.name() : qbds_W.name()));
                break;
        }

        return query.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>QueryRun</c> instance of the report query.
    /// </summary>
    /// <param name="_query">
    /// The query of the report.
    /// </param>
    /// <param name="_key">
    /// A container holding the selected grouping parameters of the report.
    /// </param>
    /// <returns>
    /// The <c>QueryRun</c> instance of the report query.
    /// </returns>
    public QueryRun queryRun(Query _query, container _key = conNull())
    {
        return new QueryRun(_query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the type enumeration for the report.
    /// </summary>
    /// <returns>
    /// The type enumeration for the report.
    /// </returns>
    abstract protected RLedgerTurnoverSheetType reportType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>settledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the settled amount on date for the transaction.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_settlement">
    /// A table buffer holding the settlement transaction.
    /// </param>
    /// <param name="_dateFrom">
    /// The starting date of the report period.
    /// </param>
    /// <param name="_dateTo">
    /// The ending date of the report period.
    /// </param>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <returns>
    /// The settled amount on date for the transaction.
    /// </returns>
    public Amount settledAmount(Common             _trans,
                                Common             _settlement,
                                TransDate          _dateFrom,
                                TransDate          _dateTo,
                                CurrencyType_RU    _currencyType)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settledTransAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the settled amounts on date for the transaction.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_dateFrom">
    /// The starting date of the report period.
    /// </param>
    /// <param name="_dateTo">
    /// The ending date of the report period.
    /// </param>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <param name="_trans_W">
    /// A table buffer holding _W extension table for the transaction.
    /// </param>
    /// <returns>
    /// The settled amounts on date for the transaction.
    /// </returns>
    /// <remarks>
    /// [debit amount, credit amount]
    /// </remarks>
    public container settledTransAmounts(Common          _trans,
                                         TransDate       _dateFrom,
                                         TransDate       _dateTo,
                                         CurrencyType_RU _currencyType,
                                         Common          _trans_W)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlementTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the table ID of the setllement history table.
    /// </summary>
    /// <returns>
    /// The table ID of the setllement history table.
    /// </returns>
    public TableId settlementTableId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showBalanceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if itemizing balance is the option for this type of the report.
    /// </summary>
    /// <returns>
    /// true if itemizing balance is the option for this type of the report; otherwise, false.
    /// </returns>
    public boolean showBalanceTrans()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if showing the transaction origin is the option for this type of the report.
    /// </summary>
    /// <returns>
    /// true if the transaction origin is the option for this type of the report; otherwise, false.
    /// </returns>
    public boolean showOrigin()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the buffer containing the split transaction.
    /// </summary>
    /// <param name="_trans">
    /// The source transaction.
    /// </param>
    /// <returns>
    /// The buffer containing the split transaction.
    /// </returns>
    public Common splitTrans(Common _trans)
    {
        Common trans;

        return trans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subTransTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the table ID for the subtransaction table.
    /// </summary>
    /// <returns>
    /// The table ID for the subtransaction table.
    /// </returns>
    public TableId subTransTableId()
    {
        return this.transTableId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding amounts for the transaction.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_currencyType">
    /// The currency type report parameter value.
    /// </param>
    /// <param name="_trans_W">
    /// A table buffer holding _W extension table for the transaction.
    /// </param>
    /// <returns>
    /// A container holding amounts for the transaction.
    /// </returns>
    /// <remarks>
    /// [debit amount, credit amount]
    /// </remarks>
    public container transAmounts(Common _trans, CurrencyType_RU _currencyType, Common _trans_W)
    {
        Amount    amount;
        container ret;
        FieldId   fieldCorrection;
        TableId   tableIdCorrection;

        [tableIdCorrection, fieldCorrection] = this.fieldCorrection(_currencyType);

        amount = _trans.(this.fieldAmount(_currencyType));

        ret = ((amount > 0) ^ (tableIdCorrection == _trans.TableId ? _trans.(fieldCorrection) : _trans_W.(fieldCorrection))) ? [amount, 0] : [0, -amount];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDetailLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the container holding labels for the transaction document fields.
    /// </summary>
    /// <returns>
    /// The container holding labels for the transaction document fields.
    /// </returns>
    public container transDetailLabels()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding document fields for the transaction.
    /// </summary>
    /// <param name="_trans">
    /// A table buffer holding the transaction.
    /// </param>
    /// <param name="_transHeader">
    /// A table buffer holding the transaction header.
    /// </param>
    /// <returns>
    /// A container holding document fields for the transaction.
    /// </returns>
    public container transDetails(Common _trans, Common _transHeader = null)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the transaction form.
    /// </summary>
    /// <returns>
    /// The name of the transaction form.
    /// </returns>
    abstract protected str transForm()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transHeaderTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the table ID of the transaction header table.
    /// </summary>
    /// <returns>
    /// The table ID of the transaction header table.
    /// </returns>
    public TableId transHeaderTableId()
    {
        return this.transTableId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transKeyData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container holding field IDs of key fields for filtering purposes on the transaction level.
    /// </summary>
    /// <returns>
    /// A container holding field IDs of key fields for filtering purposes on the transaction level.
    /// </returns>
    public container transKeyData()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the table ID of the transaction table.
    /// </summary>
    /// <returns>
    /// The table ID of the transaction table.
    /// </returns>
    abstract public TableId transTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRangeForDualWarehouseEventHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(tableStr(GeneralJournalEntry), tableStaticMethodStr(GeneralJournalEntry, addRangeForPostingLayer))]
    /// <summary>
    /// Adds the query range value of dual warehouse for posting layer.
    /// </summary>
    /// <param name="_args">
    /// The input arguments.
    /// </param>
    public static void addRangeForDualWarehouseEventHandler(XppPrePostArgs _args)
    {
        QueryBuildRange range = _args.getReturnValue();

        if (_args.getArg(identifierStr(_postingLayer)) == OperationsTax::WarehouseCur_RU)
        {
            range.value(SysQuery::value(enum2int(CurrentOperationsTax::WarehouseCur_RU)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPostingLayerForDualWarehouseEventHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(tableStr(LedgerPostingLayerTmp), tableStaticMethodStr(LedgerPostingLayerTmp, createPostingLayerList))]
    /// <summary>
    /// Adds the <c>CurrentOperationsTax</c> value of dual warehouse for posting layer to the list.
    /// </summary>
    /// <param name="_args">
    /// The input arguments.
    /// </param>
    public static void addPostingLayerForDualWarehouseEventHandler(XppPrePostArgs _args)
    {
        List postingLayerList = _args.getReturnValue();

        if (_args.getArg(identifierStr(_operationsTax)) == OperationsTax::WarehouseCur_RU)
        {
            postingLayerList.addEnd(CurrentOperationsTax::WarehouseCur_RU);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of one of the <c>RLedgerTurnoverType</c> class descendants.
    /// </summary>
    /// <param name="_reportType">
    /// The report type.
    /// </param>
    /// <returns>
    /// The instance of a <c>RLedgerTurnoverType</c> class descendant.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws exception if report type parameter value is not supported.
    /// </exception>
    public static RLedgerTurnoverType construct(RLedgerTurnoverSheetType _reportType)
    {
        RLedgerTurnoverType rLedgerTurnoverType;

        switch (_reportType)
        {
            case RLedgerTurnoverSheetType::CustTurnover    :
                rLedgerTurnoverType = new RLedgerTurnoverTypeCust();
                break;
            case RLedgerTurnoverSheetType::VendTurnover    :
                rLedgerTurnoverType = new RLedgerTurnoverTypeVend();
                break;
            case RLedgerTurnoverSheetType::LedgerDimension :
                rLedgerTurnoverType = new RLedgerTurnoverTypeLedger();
                break;
            case RLedgerTurnoverSheetType::EmplTurnover :
                rLedgerTurnoverType = new RLedgerTurnoverTypeEmpl();
                break;
            default :
                throw error("@SYS104799");
        }

        return rLedgerTurnoverType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimensionAttributeName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the default dimension attribute.
    /// </summary>
    /// <param name="_defaultDimension">
    /// The default dimension reference.
    /// </param>
    /// <param name="_paramName">
    /// The report parameter name.
    /// </param>
    /// <param name="_paramValue">
    /// The report parameter value.
    /// </param>
    /// <returns>
    /// The name of the default dimension attribute.
    /// </returns>
    static Name getDefaultDimensionAttributeName(DimensionDefault _defaultDimension,
                                                        Name             _paramName,
                                                        DimensionValue   _paramValue)
    {
        Query                               query;
        QueryRun                            queryRun;
        QueryBuildDataSource                dataSource;
        DimensionAttribute                  dimensionAttribute;
        DimensionAttributeValueSetItemView  valueView;
        Common                              entity;
        Name                                invariantName;
        Name                                ret;

        select firstOnly dimensionAttribute
            where dimensionAttribute.Name == _paramName
        exists join valueView
            where valueView.DimensionAttribute         == dimensionAttribute.RecId
               && valueView.DimensionAttributeValueSet == _defaultDimension
               && valueView.DisplayValue               == _paramValue;

        if (dimensionAttribute)
        {
            query = new Query();
            dataSource = query.addDataSource(dimensionAttribute.BackingEntityType);
            dataSource.firstOnly(true);
            findOrCreateRange_W(dataSource, dimensionAttribute.ValueAttribute, queryValue(_paramValue));

            queryRun = new QueryRun(query);
            if (queryRun.next())
            {
                entity = queryRun.getNo(1);
                invariantName = entity.(dimensionAttribute.NameAttribute);
                ret = DimensionAttribute::getLocalizedNameByEntityAndInstance(dimensionAttribute.RecId, entity.RecId, invariantName);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimensionDisplayValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the default dimension attribute display value.
    /// </summary>
    /// <param name="_defaultDimension">
    /// The default dimension reference.
    /// </param>
    /// <param name="_dimensionAttributeRecId">
    /// The record ID of the <c>DimensionAttribute</c> table.
    /// </param>
    /// <returns>
    /// The default dimension attribute display value.
    /// </returns>
    static DimensionValue getDefaultDimensionDisplayValue(DimensionDefault _defaultDimension, DimensionAttributeRecId _dimensionAttributeRecId)
    {
        DimensionAttributeValueSetItemView  valueView;

        select firstOnly DisplayValue from valueView
            where valueView.DimensionAttributeValueSet == _defaultDimension
               && valueView.DimensionAttribute == _dimensionAttributeRecId;

        return valueView.DisplayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionAttributeName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ledger dimension attribute name.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension reference.
    /// </param>
    /// <param name="_paramName">
    /// The report parameter name.
    /// </param>
    /// <param name="_paramValue">
    /// The report parameter value.
    /// </param>
    /// <returns>
    /// The name of the ledger dimension attribute.
    /// </returns>
    static Name getLedgerDimensionAttributeName(LedgerDimensionAccount _ledgerDimension,
                                                       Name                   _paramName,
                                                       DimensionValue         _paramValue)
    {
        Query                               query;
        QueryRun                            queryRun;
        QueryBuildDataSource                dataSource;
        DimensionAttribute                  dimensionAttribute;
        DimensionAttributeLevelValueView    valueView;
        Common                              entity;
        Name                                invariantName;
        Name                                ret;

        select firstOnly dimensionAttribute
            where dimensionAttribute.Name == _paramName
        exists join valueView
            where valueView.DimensionAttribute    == dimensionAttribute.RecId
               && valueView.ValueCombinationRecId == _ledgerDimension
               && valueView.DisplayValue          == _paramValue;

        if (dimensionAttribute)
        {
            query = new Query();
            dataSource = query.addDataSource(dimensionAttribute.BackingEntityType);
            dataSource.firstOnly(true);
            findOrCreateRange_W(dataSource, dimensionAttribute.ValueAttribute, queryValue(_paramValue));

            queryRun = new QueryRun(query);
            if (queryRun.next())
            {
                entity = queryRun.getNo(1);
                invariantName = entity.(dimensionAttribute.NameAttribute);
                ret = DimensionAttribute::getLocalizedNameByEntityAndInstance(dimensionAttribute.RecId, entity.RecId, invariantName);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionDisplayValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ledger dimension attribute display value.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension reference.
    /// </param>
    /// <param name="_dimensionAttributeRecId">
    /// The record ID of the <c>DimensionAttribute</c> table.
    /// </param>
    /// <returns>
    /// The ledger dimension attribute display value.
    /// </returns>
    static DimensionValue getLedgerDimensionDisplayValue(LedgerDimensionAccount _ledgerDimension, DimensionAttributeRecId _dimensionAttributeRecId)
    {
        DimensionAttributeLevelValueView    valueView;

        select firstOnly DisplayValue from valueView
            where valueView.ValueCombinationRecId == _ledgerDimension
               && valueView.DimensionAttribute == _dimensionAttributeRecId;

        return valueView.DisplayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInterface</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a report type class.
    /// </summary>
    /// <param name="_reportType">
    /// The report type enumeration value.
    /// </param>
    /// <returns>
    /// The instance of the report type class implementing the <c>RLedgerTurnoverTypeable</c> interface.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Incorrect value of report type was passed into the method.
    /// </exception>
    public static RLedgerTurnoverTypeable newInterface(RLedgerTurnoverSheetType _reportType)
    {
        RLedgerTurnoverTypeable rLedgerTurnoverTypeable;

        switch (_reportType)
        {
            case RLedgerTurnoverSheetType::CustTurnover    :
                rLedgerTurnoverTypeable = new RLedgerTurnoverTypeCust();
                break;
            case RLedgerTurnoverSheetType::VendTurnover    :
                rLedgerTurnoverTypeable = new RLedgerTurnoverTypeVend();
                break;
            case RLedgerTurnoverSheetType::LedgerDimension :
                rLedgerTurnoverTypeable = new RLedgerTurnoverTypeLedger();
                break;
            case RLedgerTurnoverSheetType::EmplTurnover :
                rLedgerTurnoverTypeable = new RLedgerTurnoverTypeEmpl();
                break;
            default :
                throw error("@SYS104799");
        }

        return rLedgerTurnoverTypeable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPrecalcInterface</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a report type class using precalculated data.
    /// </summary>
    /// <param name="_reportType">
    /// The report type enumeration value.
    /// </param>
    /// <returns>
    /// The instance of the report type class implementing the <c>RLedgerTurnoverTypeable</c> interface.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Incorrect value of report type was passed into the method.
    /// </exception>
    public static RLedgerTurnoverTypeable newPrecalcInterface(RLedgerTurnoverSheetType _reportType)
    {
        RLedgerTurnoverTypeable RLedgerTurnoverTypeable;
        ;

        switch (_reportType)
        {
            case RLedgerTurnoverSheetType::CustTurnover    :
                RLedgerTurnoverTypeable = new RLedgerTurnoverTypePrecalcCust();
                break;
            case RLedgerTurnoverSheetType::VendTurnover    :
                RLedgerTurnoverTypeable = new RLedgerTurnoverTypePrecalcVend();
                break;
            case RLedgerTurnoverSheetType::LedgerDimension :
                RLedgerTurnoverTypeable = new RLedgerTurnoverTypePrecalcLedger();
                break;
            case RLedgerTurnoverSheetType::EmplTurnover :
                RLedgerTurnoverTypeable = new RLedgerTurnoverTypePrecalcEmpl();
                break;
            default :
                throw error("@SYS104799");
        }

        return RLedgerTurnoverTypeable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrecalcData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs creation of precalculated transaction data.
    /// </summary>
    /// <param name="_trans">
    /// The transaction table buffer.
    /// </param>
    /// <param name="_reportType">
    /// The report type enumeration value.
    /// </param>
    /// <param name="_showProgress">
    /// A flag indicating whether to show a progress bar or not.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Incorrect transaction buffer was passed into the method.
    /// </exception>
    static void updatePrecalcData(Common                   _trans,
                                         RLedgerTurnoverSheetType _reportType,
                                         boolean                  _showProgress = false)
    {
        Query                   query;
        QueryRun                queryRun;
        Common                  trans;
        Common                  transHeader;
        Common                  transSplit;
        RunbaseProgress         progress;
        RLedgerTurnoverType     type;

        type = RLedgerTurnoverType::construct(_reportType);
        type.parmUpdateMode(true);

        if (type.transTableId() != _trans.TableId)
        {
            throw error(strFmt("@GLS105652", funcName()));
        }

        query = new Query(type.query());

        if (_trans.RecId)
        {
            findOrCreateRange_W(query.dataSourceTable(_trans.TableId),
                                fieldName2id(_trans.TableId, 'RecId'),
                                queryValue(_trans.RecId));
        }

        if (_showProgress)
        {
            progress = RunbaseProgress::construct(1, null);
            progress.setCaption("@SYS4081702");
            progress.setTotal(QueryRun::getQueryRowCount(query, maxInt()));
            progress.setText(tableId2pname(_trans.TableId));
        }

        transSplit.setTmp();

        queryRun = type.queryRun(query, type.groupParamNames());
        while (queryRun.next())
        {
            trans       = queryRun.get(_trans.TableId);
            transHeader = queryRun.get(type.transHeaderTableId());
            transSplit  = type.splitTrans(trans);

            if (transSplit.RecId)
            {
                select transSplit;
            }

            do
            {
                type.createPrecalcData(trans, transHeader, transSplit);

                if (transSplit)
                {
                    next transSplit;
                }
            }
            while (transSplit.RecId);

            if (progress)
            {
                progress.incCount();
            }
        }

        if (progress)
        {
            progress.kill();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>