<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RLedgerTurnoverEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RLedgerTurnoverEngine</c> class performs generaton of turnover balance statements.
/// </summary>
class RLedgerTurnoverEngine extends RunBaseBatch implements BatchRetryable
{
    DateCode                        periodCode;
    TransDate                       fromDate;
    TransDate                       toDate;
    CurrencyType_RU                 currencyType;
    CurrencyCode                    currencyCode;
    MainAccountRange                mainAccountNum;
    MainAccountRange                mainAccountNumCorr;
    container                       selectedFieldsOrder;
    container                       selectedFieldsExp;
    OperationsTax                   operationsTax;
    DimensionDefault                dimensionCriteria;
    NoYes                           printRanges;
    NoYes                           deleteZero;
    NoYes                           showSumAccount;
    NoYes                           showTotalsOnly;
    NoYes                           showTrans;
    NoYes                           showBalanceTrans;
    NoYes                           showBalance;
    NoYes                           showOrigin;
    RefRecId                        reportTableRecId;
    TableId                         tableIdCorrection;
    int                             expandLevel;
    boolean                         hideProgress;
    boolean                         useTrans_W;
    str                             lastVouchersDialogValue;
    boolean                         isInitialized;

    DialogField                     dialogOperationsTax;
    DialogField                     dialogDimensionCriteria;
    DialogField                     dialogPrintRanges;
    DialogField                     dialogDeleteZero;
    DialogField                     dialogShowSumAccount;
    DialogField                     dialogShowSumAccountShrinked;
    DialogField                     dialogShowTrans;
    DialogField                     dialogShowBalanceTrans;
    DialogField                     dialogShowBalance;
    DialogField                     dialogShowOrigin;

    DialogGroup                     dlgGroupBalance;
    DialogGroup                     dlgGroupDimensionCriteria;
    DialogGroup                     dlgGroupSetup;

    SysQueryRun                     queryRun;
    Object                          dialogFormRun;

    RLedgerTurnoverSheetType        reportType;
    RLedgerTurnoverTypeable         ledgerSheetType;

    Map                             mapMapTrans;
    Map                             mapSumAccounts;
    Map                             mapBalanceAmounts;
    Map                             mapSumAccountAmounts;
    Map                             mapTransKeyData;
    Map                             mapParamValueNames;
    Map                             vouchersColumnsMap = new Map(Types::String, Types::Integer);

    protected const Version currentVersion = 3;

    const int balanceDebitStart = 1;
    const int balanceCreditStart = 2;
    const int turnoverDebit = 3;
    const int turnoverCredit = 4;
    const int balanceDebitEnd = 5;
    const int balanceCreditEnd = 6;
    const int settledDebit = 7;
    const int settledCredit = 8;
    const int settledDebitStart = 9;
    const int settledCreditStart = 10;

    const str labelDelimiter = ' / ';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addBalanceAmount</Name>
				<Source><![CDATA[
    private void addBalanceAmount(Map               _map,
                                  container         _mapKey,
                                  int               _debitPos,
                                  int               _creditPos,
                                  Amount            _transAmount,
                                  DebCredProposal   _debitCredit,
                                  boolean           _reverseSign = false,
                                  boolean           _sumAccount  = false)
    {
        int         idx;
        container   mapKey;
        container   mapValue;
        int         sign = _reverseSign ? -1 : 1;
        ;

        for (idx = 1; idx <= conlen(_mapKey); idx++)
        {
            mapKey = conins(mapKey, conlen(mapKey) + 1, conpeek(_mapKey, idx));

            if (_sumAccount && idx < conlen(_mapKey))
            {
                continue;
            }

            if (_map.exists(mapKey))
            {
                mapValue = _map.lookup(mapKey);
            }
            else
            {
                mapValue = [0,0,0,0,0,0,0,0,0,0];
            }

            if (idx > expandLevel)
            {
                switch (_debitCredit)
                {
                    case DebCredProposal::Debit  :
                        mapValue = conpoke(mapValue,
                                           _debitPos,
                                           conpeek(mapValue, _debitPos)  + sign * _transAmount);
                        break;

                    case DebCredProposal::Credit :
                        mapValue = conpoke(mapValue,
                                           _creditPos,
                                           conpeek(mapValue, _creditPos) - sign * _transAmount);
                        break;
                }
            }

            _map.insert(mapKey, mapValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransKeyData</Name>
				<Source><![CDATA[
    private void addTransKeyData(Common     _trans,
                                 container  _key,
                                 boolean    _isTrans = false,
                                 boolean    _updateMapValue = true)
    {
        int         idx;
        container   key;
        container   value;
        Map         mapValue;
        str         rangeValue;
        Name        name;
        FieldId     fieldId;
        str         valueStr;
        str         keyStr  = con2Str(_key);
        container   keyData = _isTrans                   ?
                              this.type().transKeyData() :
                              this.type().groupKeyData(selectedFieldsOrder);

        if (_updateMapValue)
        {
            if (mapTransKeyData.exists(keyStr))
            {
                mapValue = mapTransKeyData.lookup(keyStr);
            }
            else
            {
                mapValue = new Map(Types::String, Types::Container);
                mapTransKeyData.insert(keyStr, mapValue);
            }

            for (idx = 1; idx <= conlen(keyData); idx++)
            {
                fieldId     = conpeek(keyData, idx);
                rangeValue  = queryValue(this.type().getKeyValue(_trans, fieldId));
                value       = [fieldId, rangeValue ?
                                        rangeValue :
                                        SysQuery::valueEmptyString()];
                valueStr    = con2Str(value + '$');

                if (! mapValue.exists(valueStr))
                {
                    mapValue.insert(valueStr, value);
                }
            }
        }

        if (! _isTrans)
        {
            for (idx = 1; idx <= conLen(selectedFieldsOrder); idx++)
            {
                key = [conPeek(selectedFieldsOrder, idx), conPeek(_key, idx)];
                if (! mapParamValueNames.exists(key))
                {
                    name = this.type().groupParamValueName(conPeek(selectedFieldsOrder, idx), conPeek(_key, idx), _trans);
                    mapParamValueNames.insert(key, name);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates balance amounts.
    /// </summary>
    /// <param name="_debitCredit">
    /// The enumeration value indicating whether debit or credit balances should be calculated.
    /// </param>
    protected void balanceTrans(DebCredProposal _debitCredit)
    {
        Common      trans;
        Common      trans_W;
        Common      transHeader;
        Common      transSplit;
        Common      subTrans;
        container   mapKey;
        Amount      transAmount;
        Amount      settledAmount;
        container   settledTransAmounts;
        QueryRun    queryRunBalance;
        Query       query = new Query(queryRun.query().pack());

        void calcBalance(int _debitPos, int _creditPos)
        {
            this.addBalanceAmount(mapBalanceAmounts,
                                  mapKey,
                                  _debitPos,
                                  _creditPos,
                                  transAmount,
                                  _debitCredit);

            this.calcSumAccount(mapKey,
                                _debitPos,
                                _creditPos,
                                transAmount,
                                _debitCredit);
        }

        transSplit.setTmp();

        query = new Query(this.type().queryBalance(selectedFieldsOrder, currencyType, _debitCredit, query));

        if (showBalance || showBalanceTrans)
        {
            if (progress)
            {
                progress.setText(strfmt("@SYS4081711", _debitCredit));
                this.redrawWindows();
            }

            this.setQueryRanges(query, datenull(), fromDate - 1);

            queryRunBalance = this.type().queryRun(query, selectedFieldsOrder);
            while (queryRunBalance.next())
            {
                trans       = queryRunBalance.get(this.type().transTableId());
                subTrans    = queryRunBalance.get(this.type().subTransTableId());
                transHeader = queryRunBalance.get(this.type().transHeaderTableId());

                if (! this.type().isTransIncluded(trans, subTrans, currencyType))
                {
                    continue;
                }

                if (useTrans_W)
                {
                    trans_W = queryRunBalance.get(tableIdCorrection);
                }

                settledTransAmounts = this.type().settledTransAmounts(trans, datenull(), fromDate - 1, currencyType, trans_W);
                settledAmount = conPeek(settledTransAmounts, 1) - conPeek(settledTransAmounts, 2);

                transSplit = this.type().splitTrans(trans);
                if (transSplit.RecId)
                {
                    select transSplit;
                }

                do
                {
                    transAmount = transSplit.RecId                                   ?
                                  transSplit.(this.type().fieldAmount(currencyType)) :
                                  trans.(this.type().fieldAmount(currencyType));

                    mapKey = this.type().groupParamValues(trans, selectedFieldsOrder, transHeader, transSplit);
                    this.addTransKeyData(subTrans, mapKey, false);

                    calcBalance(balanceDebitStart, balanceCreditStart);
                    calcBalance(balanceDebitEnd,   balanceCreditEnd);

                    if (transSplit.RecId)
                    {
                        next transSplit;
                    }
                }
                while (transSplit.RecId);

                transAmount = settledAmount;
                calcBalance(settledDebitStart, settledCreditStart);

                settledTransAmounts = this.type().settledTransAmounts(trans, fromDate, toDate, currencyType, trans_W);
                transAmount = conPeek(settledTransAmounts, 1) - conPeek(settledTransAmounts, 2);
                calcBalance(settledDebit, settledCredit);
            }
        }

        if (progress)
        {
            progress.incCount();
            progress.setText(strfmt("@SYS4081710", _debitCredit));
            this.redrawWindows();
        }

        this.setQueryRanges(query, fromDate, toDate);

        queryRunBalance = this.type().queryRun(query, selectedFieldsOrder);

        while (queryRunBalance.next())
        {
            trans       = queryRunBalance.get(this.type().transTableId());
            subTrans    = queryRunBalance.get(this.type().subTransTableId());
            transHeader = queryRunBalance.get(this.type().transHeaderTableId());

            if (! this.type().isTransIncluded(trans, subTrans, currencyType))
            {
                continue;
            }

            if (useTrans_W)
            {
                trans_W = queryRunBalance.get(tableIdCorrection);
            }

            settledTransAmounts = this.type().settledTransAmounts(trans, fromDate, toDate, currencyType, trans_W);
            settledAmount = conPeek(settledTransAmounts, 1) - conPeek(settledTransAmounts, 2);

            transSplit = this.type().splitTrans(trans);
            if (transSplit.RecId)
            {
                select transSplit;
            }

            do
            {
                transAmount = transSplit.RecId                                   ?
                              transSplit.(this.type().fieldAmount(currencyType)) :
                              trans.(this.type().fieldAmount(currencyType));

                mapKey = this.type().groupParamValues(trans, selectedFieldsOrder, transHeader, transSplit);
                this.addTransKeyData(subTrans, mapKey);

                calcBalance(turnoverDebit,   turnoverCredit);

                if (showBalance)
                {
                    calcBalance(balanceDebitEnd, balanceCreditEnd);
                }

                if (transSplit.RecId)
                {
                    next transSplit;
                }
            }
            while (transSplit.RecId);

            transAmount = settledAmount;
            calcBalance(settledDebit, settledCredit);
        }

        if (progress)
        {
            progress.incCount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBalanceTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates totals on grouping levels of the report.
    /// </summary>
    protected void calcBalanceTotals()
    {
        MapEnumerator mapBalanceEnumerator;
        container     key;
        container     sumKey;
        container     amounts;
        container     subtotals;
        container     sumtotals;
        int           idx;
        int           ledgerAccountIdx;
        boolean       expandSumAccount;

        if (! expandLevel)
        {
            return;
        }

        if (showSumAccount)
        {
            ledgerAccountIdx = confind(selectedFieldsOrder, this.type().keyMainAccount());
            if (ledgerAccountIdx && conpeek(selectedFieldsExp, ledgerAccountIdx))
            {
                expandSumAccount = true;
            }
        }

        mapBalanceEnumerator = mapBalanceAmounts.getEnumerator();

        while (mapBalanceEnumerator.moveNext())
        {
            key = mapBalanceEnumerator.currentKey();

            if (conLen(key) != (expandLevel + 1))
            {
                continue;
            }

            amounts = this.collapseBalance(mapBalanceEnumerator.currentValue(), false);

            key = conDel(key, conLen(key), 1);
            while (conLen(key))
            {
                subtotals = mapBalanceAmounts.lookup(key);

                for (idx = balanceDebitStart; idx <= balanceCreditEnd; idx++)
                {
                    subtotals = conPoke(subtotals, idx, conPeek(subtotals, idx) + conPeek(amounts, idx));
                }

                mapBalanceAmounts.insert(key, subtotals);

                if (expandSumAccount && (conLen(key) == ledgerAccountIdx))
                {
                    sumKey = this.getSumKey(key);
                    sumtotals = mapSumAccountAmounts.lookup(sumKey);

                    for (idx = balanceDebitStart; idx <= balanceCreditEnd; idx++)
                    {
                        sumtotals = conPoke(sumtotals, idx, conPeek(sumtotals, idx) + conPeek(amounts, idx));
                    }

                    mapSumAccountAmounts.insert(sumKey, sumtotals);
                }

                key = conDel(key, conLen(key), 1);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSumAccount</Name>
				<Source><![CDATA[
    private void calcSumAccount(container       _paramValues,
                                int             _debitPos,
                                int             _creditPos,
                                Amount          _transAmount,
                                DebCredProposal _debitCredit)
    {
        container       key;
        Name            name;
        MainAccountNum  sumAccount;
        boolean         reverseSign;
        ;

        if (! showSumAccount || ! this.type().keyMainAccount())
            return;

        key = this.getSumKey(_paramValues);
        if (key)
        {
            [ sumAccount, reverseSign ] = conpeek(key, conlen(key));
            if (sumAccount)
            {
                this.addBalanceAmount(mapSumAccountAmounts,
                                      key,
                                      _debitPos,
                                      _creditPos,
                                      _transAmount,
                                      _debitCredit,
                                      reverseSign,
                                      true);

                key = [this.type().keyMainAccount(), [sumAccount]];
                if (! mapParamValueNames.exists(key))
                {
                    name = this.type().groupParamValueName(this.type().keyMainAccount(), [sumAccount]);
                    mapParamValueNames.insert(key, name);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog box can be shown and the parameters can be changed, but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class two times with the
    ///    same parameters is not always possible. If the <c>RunBaseBatch.canGoBatch</c> method is false, this
    ///    method will not have any effect.
    /// </remarks>
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>collapseBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates collapsed or expanded balances depending on the report parameters.
    /// </summary>
    /// <param name="_amounts">
    /// A container holding amounts.
    /// </param>
    /// <param name="_expanded">
    /// A Boolean parameter indicating whether collapsed or expanded balance should be calculated.
    /// </param>
    /// <returns>
    /// The resulting container holding collapsed or expanded balances.
    /// </returns>
    protected container collapseBalance(container _amounts, boolean _expanded)
    {
        Amount    balance;
        container values = _amounts;

        void collapse(int _debitPos, int _creditPos)
        {
            balance = conpeek(_amounts, _debitPos) - conpeek(_amounts, _creditPos);

            if (balance >= 0)
            {
                values = conpoke(values, _debitPos,  balance);
                values = conpoke(values, _creditPos, 0);
            }
            else
            {
                values = conpoke(values, _debitPos,  0);
                values = conpoke(values, _creditPos, (- balance));
            }
        }

        if (! _expanded)
        {
            collapse(balanceDebitStart, balanceCreditStart);
            collapse(balanceDebitEnd, balanceCreditEnd);
        }
        else
        {
            if (this.type().settlementTableId())
            {
                values = conpoke(values, balanceDebitStart,  conpeek(_amounts, balanceDebitStart)  - conpeek(_amounts, settledDebitStart));
                values = conpoke(values, balanceCreditStart, conpeek(_amounts, balanceCreditStart) - conpeek(_amounts, settledCreditStart));

                values = conpoke(values, balanceDebitEnd,    conpeek(_amounts, balanceDebitEnd)  - conpeek(_amounts, settledDebitStart)  - conpeek(_amounts, settledDebit));
                values = conpoke(values, balanceCreditEnd,   conpeek(_amounts, balanceCreditEnd) - conpeek(_amounts, settledCreditStart) - conpeek(_amounts, settledCredit));

                values = conpoke(values, settledDebit,  conpeek(_amounts, settledDebit));
                values = conpoke(values, settledCredit, conpeek(_amounts, settledCredit));
            }
        }

        return values;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates report header records.
    /// </summary>

    protected void createReportHeader()
    {
        int                                 i, j;
        int                                 idxDS, idxRange;
        str                                 paramStr;
        container                           paramLabels;
        container                           parameters;
        container                           paramHeader;
        UserInfo                            userInfo;
        RLedgerTurnoverSheet                reportTable;
        RLedgerTurnoverSheetHeader          reportHeader;
        DefaultDimensionView                defaultDimensionView;
        Query                               query = new Query(queryRun.query().pack());
        const str rangeDelimiter = ': ';
        const str newLine = '\r\n';

        str rangeStr(str _name, anytype _value)
        {
            str ret;

            if (_value)
            {
                ret = _name + rangeDelimiter + strfmt("@SYS82282", _value) + newLine;
            }

            return ret;
        }

        switch (currencyType)
        {
            case CurrencyType_RU::Standard :
                currencyCode = CompanyInfoHelper::standardCurrency();
                break;
            case CurrencyType_RU::Secondary :
                currencyCode = CompanyInfoHelper::secondaryCurrency_RU();
                break;
        }

        reportTable.ReportType          = reportType;
        reportTable.FromDate            = fromDate;
        reportTable.ToDate              = toDate;
        reportTable.PackedQuery         = query.pack();
        reportTable.PackedCaller        = this.pack();
        reportTable.GroupKey            = selectedFieldsOrder;
        reportTable.GroupKeyExp         = selectedFieldsExp;
        reportTable.CurrencyType        = currencyType;
        reportTable.CurrencyCode        = currencyCode;
        reportTable.MainAccountNum      = mainAccountNum;
        reportTable.MainAccountNumCorr  = mainAccountNumCorr;
        reportTable.DimensionCriteria   = dimensionCriteria;
        reportTable.PrintRanges         = printRanges;
        reportTable.DeleteZero          = deleteZero;
        reportTable.ShowSumAccount      = showSumAccount;
        reportTable.ShowTrans           = showTrans;
        reportTable.ShowBalanceTrans    = showBalanceTrans;
        reportTable.ShowBalance         = showBalance;
        reportTable.ShowOrigin          = showOrigin;
        reportTable.insert();

        reportTableRecId = reportTable.RecId;

        paramLabels = this.type().groupParamLabels(selectedFieldsOrder);
        for (i = 1; i <= conlen(paramLabels); i++)
        {
            paramStr   = '';
            parameters = conpeek(paramLabels, i);
            for (j = 1; j <= conlen(parameters); j++)
            {
                paramStr += (paramStr ? labelDelimiter + conpeek(parameters, j) : conpeek(parameters, j));
            }

            paramHeader += paramStr;
        }

        for (i = 1; i <= conlen(paramHeader); i++)
        {
            reportHeader.GroupParam[i] = strReplace(conpeek(paramHeader, i), ' ', num2char(160));
        }

        reportHeader.Name        = "@SYS7399";
        reportHeader.RefRecId    = reportTableRecId;

        [reportHeader.BalanceDebitStart,
         reportHeader.BalanceCreditStart,
         reportHeader.TurnoverDebit,
         reportHeader.TurnoverCredit,
         reportHeader.BalanceDebitEnd,
         reportHeader.BalanceCreditEnd,
         reportHeader.SettlementDebit,
         reportHeader.SettlementCredit] = this.type().amountFieldLabels();

        if (! showBalance)
        {
            if (! showBalanceTrans)
            {
                reportHeader.BalanceDebitStart  = '';
                reportHeader.BalanceCreditStart = '';
            }
            reportHeader.BalanceDebitEnd    = '';
            reportHeader.BalanceCreditEnd   = '';
        }

        if (showTrans || showBalanceTrans)
        {
            [reportHeader.TransDate,
             reportHeader.Description,
             reportHeader.DocumentNum,
             reportHeader.DocumentDate,
             reportHeader.Txt] = this.type().transDetailLabels();
        }

        if (printRanges)
        {
            select Name from userInfo where userInfo.Id == curUserId();
            reportHeader.RangeStr += rangeStr("@SYS26237",  userInfo.name);
            reportHeader.RangeStr += rangeStr("@SYS5209",   fromDate);
            reportHeader.RangeStr += rangeStr("@SYS14656",  toDate);
            reportHeader.RangeStr += rangeStr("@SYS7572",   currencyCode);
            reportHeader.RangeStr += rangeStr("@SYS135766", mainAccountNum);
            reportHeader.RangeStr += rangeStr("@GLS102172", mainAccountNumCorr);

            while select Name, DisplayValue from defaultDimensionView
                where defaultDimensionView.DefaultDimension == dimensionCriteria
            {
                reportHeader.RangeStr += rangeStr(defaultDimensionView.Name, defaultDimensionView.DisplayValue);
            }

            for (idxDS = 1; idxDS <= query.dataSourceCount(); idxDS++)
            {
                for (idxRange = 1; idxRange <= query.dataSourceNo(idxDS).rangeCount(); idxRange++)
                {
                    reportHeader.RangeStr += rangeStr(fieldId2pname(query.dataSourceNo(idxDS).table(),
                                                                    query.dataSourceNo(idxDS).range(idxRange).field(),
                                                                    query.dataSourceNo(idxDS).range(idxRange).fieldArrayIndex()),
                                                                    query.dataSourceNo(idxDS).range(idxRange).value());
                }
            }
        }

        reportHeader.RangeStr = strReplace(reportHeader.RangeStr, ' ', num2char(160));
        reportHeader.Title    = enum2str(reportType);
        reportHeader.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates report line records.
    /// </summary>

    protected void createReportLine()
    {
        int                             lineNum;
        int                             curLineNum;
        int                             nextLineNum;
        int                             idx;
        int                             parentLineNum;
        int                             level;
        int                             keyLength;
        int                             ledgerAccountIdx;
        container                       parameter;
        container                       amounts;
        container                       sumAccountKey;
        container                       balanceKey;
        container                       key;
        int                             sumParentLineNum;
        str                             paramStr;
        str                             paramValue;
        Map                             mapTrans;
        MapEnumerator                   mapTransEnumerator;
        MapEnumerator                   mapBalanceEnumerator;
        RLedgerTurnoverSheetLine        reportLine;
        MainAccountNum                  sumAccount;
        container                       totals = [0,0,0,0,0,0,0,0,0,0];
        Set                             setSumAccKey = new Set(Types::Container);
        Map                             mapKeyLineNum = new Map(Types::Integer, Types::Integer);
        anytype                         emptyStr = '';
        const str emptyParameter = '---';

        void fillKeyData(container _key)
        {
            const int bufSize = 55;
            RLedgerTurnoverKeyData  keyData;
            Map                     mapValue;
            MapEnumerator           me;
            int                     i           = 1;
            str                     keyStr      = con2Str(_key);
            RecordInsertList        insertList  = new RecordInsertList(tableNum(RLedgerTurnoverKeyData));

            if (mapTransKeyData.exists(keyStr))
            {
                keyData.RLedgerTurnoverSheetLine = reportLine.RecId;

                mapValue = mapTransKeyData.lookup(keyStr);
                me = mapValue.getEnumerator();

                while (me.moveNext())
                {
                    if (i > bufSize)
                    {
                        insertList.add(keyData);
                        keyData.KeyData = conNull();
                        i = 1;
                    }

                    keyData.KeyData = conIns(keyData.KeyData, i, me.currentValue());
                    i++;
                }

                if (i > 1)
                {
                    insertList.add(keyData);
                }

                insertList.insertDatabase();
            }
        }

        void addSumAccount(boolean _endReport = false)
        {
            boolean showSumTotal;

            if (showSumAccount && ledgerAccountIdx)
            {
                if (sumAccountKey && ! setSumAccKey.in(sumAccountKey))
                {
                    if (! _endReport)
                    {
                        if (keyLength < ledgerAccountIdx)
                        {
                            for (idx = 1; idx <= keyLength; idx++)
                            {
                                if (conpeek(sumAccountKey, idx) != conpeek(balanceKey, idx))
                                {
                                    showSumTotal = true;
                                    break;
                                }
                            }
                        }

                        if (keyLength == ledgerAccountIdx)
                        {
                            showSumTotal = (sumAccountKey != this.getSumKey(balanceKey));
                        }
                    }

                    if (showSumTotal || _endReport)
                    {
                        [sumAccount] = conpeek(sumAccountKey, ledgerAccountIdx);

                        key = [this.type().keyMainAccount(), [sumAccount]];

                        amounts = mapSumAccountAmounts.lookup(sumAccountKey);
                        amounts = this.collapseBalance(amounts, conpeek(selectedFieldsExp, ledgerAccountIdx));

                        lineNum++;
                        reportLine.clear();
                        reportLine.RefRecId = reportTableRecId;
                        reportLine.LineNum = lineNum;
                        reportLine.ParentLineNum = sumParentLineNum;
                        reportLine.Level = ledgerAccountIdx;
                        reportLine.Parameter[ledgerAccountIdx] = sumAccount;
                        reportLine.Name = mapParamValueNames.exists(key) ? mapParamValueNames.lookup(key) : emptyStr;
                        [reportLine.BalanceDebitStart, reportLine.BalanceCreditStart, reportLine.TurnoverDebit, reportLine.TurnoverCredit, reportLine.BalanceDebitEnd, reportLine.BalanceCreditEnd, reportLine.SettlementDebit, reportLine.SettlementCredit] = amounts;
                        reportLine.LineType = RLedgerTurnoverSheetLineType::SumAccount;
                        reportLine.insert();

                        setSumAccKey.add(sumAccountKey);
                    }
                }

                if (ledgerAccountIdx == keyLength)
                {
                    sumAccountKey    = this.getSumKey(balanceKey);
                    sumParentLineNum = parentLineNum;
                }
            }
        }
        ;

        if (progress)
        {
            progress.setText("@SYS4081714");
        }

        this.calcBalanceTotals();

        ledgerAccountIdx = confind(selectedFieldsOrder, this.type().keyMainAccount());

        mapBalanceEnumerator = mapBalanceAmounts.getEnumerator();

        while (mapBalanceEnumerator.moveNext())
        {
            balanceKey = mapBalanceEnumerator.currentKey();
            keyLength = conlen(balanceKey);

            if (mapKeyLineNum.exists(keyLength - 1))
            {
                parentLineNum = mapKeyLineNum.lookup(keyLength - 1);
            }
            else
            {
                parentLineNum = 0;
            }

            addSumAccount();

            lineNum++;
            mapKeyLineNum.insert(keyLength, lineNum);

            paramStr  = '';
            parameter = conpeek(balanceKey, keyLength);
            for (idx = 1; idx <= conlen(parameter); idx++)
            {
                paramValue = strfmt("@SYS82282", conpeek(parameter, idx));
                paramValue = paramValue ? paramValue : emptyParameter;

                paramStr += (paramStr ? labelDelimiter + paramValue : paramValue);
            }

            key = [conPeek(selectedFieldsOrder, keyLength), parameter];

            amounts = mapBalanceEnumerator.currentValue();
            amounts = this.collapseBalance(amounts, conpeek(selectedFieldsExp, keyLength));

            reportLine.clear();
            reportLine.RefRecId = reportTableRecId;
            reportLine.LineNum = lineNum;
            reportLine.ParentLineNum = parentLineNum;
            reportLine.Level = keyLength;
            reportLine.Parameter[keyLength] = paramStr;
            reportLine.Name = mapParamValueNames.exists(key) ? mapParamValueNames.lookup(key) : emptyStr;
            [reportLine.BalanceDebitStart, reportLine.BalanceCreditStart, reportLine.TurnoverDebit, reportLine.TurnoverCredit, reportLine.BalanceDebitEnd, reportLine.BalanceCreditEnd, reportLine.SettlementDebit, reportLine.SettlementCredit] = amounts;
            reportLine.LineType = RLedgerTurnoverSheetLineType::Body;
            reportLine.insert();
            fillKeyData(balanceKey);

            if (keyLength == conlen(selectedFieldsOrder) && (showTrans || showBalanceTrans))
            {
                reportLine.clear();
                reportLine.RefRecId         = reportTableRecId;
                reportLine.ParentLineNum    = lineNum;

                if (mapMapTrans.exists(balanceKey))
                {
                    mapTrans           = mapMapTrans.lookup(balanceKey);
                    mapTransEnumerator = mapTrans.getEnumerator();

                    while (mapTransEnumerator.moveNext())
                    {
                        lineNum++;
                        reportLine.LineNum              = lineNum;
                        reportLine.TransDate            = strfmt("@SYS82282", conpeek(mapTransEnumerator.currentKey(), 1));
                        reportLine.Description          = conpeek(mapTransEnumerator.currentKey(), 2);
                        reportLine.DocumentNum          = conpeek(mapTransEnumerator.currentKey(), 3);
                        reportLine.DocumentDate         = strfmt("@SYS82282", conpeek(mapTransEnumerator.currentKey(), 4));
                        reportLine.Txt                  = conpeek(mapTransEnumerator.currentKey(), 5);
                        reportLine.TurnoverDebit        = conpeek(mapTransEnumerator.currentValue(), 1);
                        reportLine.TurnoverCredit       = conpeek(mapTransEnumerator.currentValue(), 2);
                        reportLine.SettlementDebit      = conpeek(mapTransEnumerator.currentValue(), 3);
                        reportLine.SettlementCredit     = conpeek(mapTransEnumerator.currentValue(), 4);
                        reportLine.BalanceDebitEnd      = conpeek(mapTransEnumerator.currentValue(), 5);
                        reportLine.BalanceCreditEnd     = conpeek(mapTransEnumerator.currentValue(), 6);
                        reportLine.BalanceDebitStart    = conpeek(mapTransEnumerator.currentValue(), 7);
                        reportLine.BalanceCreditStart   = conpeek(mapTransEnumerator.currentValue(), 8);
                        reportLine.LineType             = RLedgerTurnoverSheetLineType::Trans;
                        reportLine.insert();
                        fillKeyData(balanceKey + mapTransEnumerator.currentKey());
                    }
                }
            }

            if (keyLength == 1)
            {
                amounts = mapBalanceEnumerator.currentValue();
                for (idx = 1; idx <= conlen(amounts); idx++)
                {
                    totals = conpoke(totals, idx, conpeek(totals, idx) + conpeek(amounts, idx));
                }
            }
        }

        addSumAccount(true);

        totals = this.collapseBalance(totals, confind(selectedFieldsExp, true));

        lineNum++;
        reportLine.clear();
        reportLine.RefRecId = reportTableRecId;
        reportLine.LineNum = lineNum;
        reportLine.Level = 1;
        reportLine.Parameter[1] = "@GLS100890";
        [reportLine.BalanceDebitStart, reportLine.BalanceCreditStart, reportLine.TurnoverDebit, reportLine.TurnoverCredit, reportLine.BalanceDebitEnd, reportLine.BalanceCreditEnd, reportLine.SettlementDebit, reportLine.SettlementCredit] = totals;
        reportLine.LineType = RLedgerTurnoverSheetLineType::Total;
        reportLine.insert();

        if (progress)
        {
            progress.incCount();
        }

        if (deleteZero)
        {
            if (progress)
            {
                progress.setText("@SYS4081712");
            }

            curLineNum = 1;
            reportLine = RLedgerTurnoverSheetLine::findLineNum(reportTableRecId, curLineNum);
            while (reportLine)
            {
                if (reportLine.BalanceDebitStart  == 0 &&
                    reportLine.BalanceCreditStart == 0 &&
                    reportLine.TurnoverDebit      == 0 &&
                    reportLine.TurnoverCredit     == 0 &&
                   (reportLine.LineType           == RLedgerTurnoverSheetLineType::Body ||
                    reportLine.LineType           == RLedgerTurnoverSheetLineType::Trans))
                {
                    nextLineNum = 0;
                    if (reportLine.LineType == RLedgerTurnoverSheetLineType::Body)
                    {
                        level = reportLine.Level;
                        select firstonly LineNum from reportLine
                            order by lineNum
                            where reportLine.RefRecId == reportTableRecId &&
                                  reportLine.LineNum  >  curLineNum       &&
                                  reportLine.Level    >  0                &&
                                  reportLine.Level    <= level;

                        nextLineNum = reportLine ? reportLine.LineNum : lineNum;
                    }

                    delete_from reportLine
                        index hint LineNumIdx
                        where reportLine.RefRecId == reportTableRecId &&
                              reportLine.LineNum  == curLineNum;

                    curLineNum++;

                    if (nextLineNum > curLineNum)
                    {
                        delete_from reportLine
                            index hint LineNumIdx
                            where reportLine.RefRecId == reportTableRecId &&
                                  reportLine.LineNum  >= curLineNum       &&
                                  reportLine.LineNum  <  nextLineNum;

                        curLineNum = nextLineNum;
                    }
                }
                else
                {
                    curLineNum++;
                }

                reportLine = RLedgerTurnoverSheetLine::findLineNum(reportTableRecId, curLineNum);
            }
        }

        if (progress)
        {
            progress.incCount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    ///    created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog =  Dialog::newFormnameRunbase(formstr(RLedgerTurnoverDialog), this);
        ;

        dialog.caption(this.type().description());
        dialog = this.dialogInternal(dialog);

        if (this.type().fieldOperationsTax())
        {
            dlgGroupBalance     = dialog.addGroup("@SYS6350");
            dialogOperationsTax = dialog.addFieldValue(enumstr(OperationsTax), operationsTax);
        }

        if (this.type().fieldDefaultDimension() || this.type().fieldLedgerDimension())
        {
            dlgGroupDimensionCriteria = dialog.addGroup();
            dlgGroupDimensionCriteria.hideIfEmpty(false);
        }

        dlgGroupSetup = dialog.addGroup("@SYS29158");
        dlgGroupSetup.columns(2);
        dialogPrintRanges   = dialog.addFieldValue(enumstr(NoYes), printRanges, "@SYS56502",  "@SYS68123");
        dialogDeleteZero    = dialog.addFieldValue(enumstr(NoYes), deleteZero,  "@GLS104958", "@GLS104959");

        if (this.type().keyMainAccount())
        {
            dialogShowSumAccount = dialog.addFieldValue(enumstr(NoYes), showSumAccount, "@SYS3783",  "@GLS104965");
            dialogShowSumAccount.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(RLedgerTurnoverEngine, dialogShowSumAccount_modified), this);
        }
        dialogShowSumAccountShrinked = dialog.addFieldValue(enumStr(NoYes), showTotalsOnly,"@GLS105022",   "@GLS105022");
        dialogShowSumAccountShrinked.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(RLedgerTurnoverEngine, dialogTotalsOnly_modified), this);
        dialogShowSumAccountShrinked.value(false);
        dialogShowTrans = dialog.addFieldValue(enumstr(NoYes), showTrans, "@GLS100955", "@SYS4081707");

        if (this.type().showBalanceTrans())
        {
            dialogShowBalanceTrans = dialog.addFieldValue(enumstr(NoYes), showBalanceTrans, "@GLS114497", "@GLS114498");
        }

        dialogShowBalance = dialog.addFieldValue(enumstr(NoYes), showBalance, "@SYS4081691", "@SYS4081700");

        if (this.type().showOrigin())
        {
            dialogShowOrigin = dialog.addFieldValue(enumstr(NoYes), showOrigin, "@SYS4081706", "@SYS4081694");
        }

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogFormRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets a reference to a dialog <c>FormRun</c>.
    /// </summary>
    /// <param name="_dialogFormRun">
    /// A reference to a dialog <c>FormRun</c>.
    /// </param>
    /// <returns>
    /// A reference to a dialog <c>FormRun</c>.
    /// </returns>
    public Object dialogFormRun(Object _dialogFormRun = dialogFormRun)
    {
        ;
        dialogFormRun = _dialogFormRun;

        return dialogFormRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogTotalsOnly_modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method invoked on modified event in the dialog control.
    /// </summary>
    /// <param name="_value">
    /// The dialog control.
    /// </param>
    /// <returns>
    /// true if value in the dialog control is modified successfully; otherwise, false.
    /// </returns>
    protected boolean dialogTotalsOnly_modified(FormCheckBoxControl _value)
    {
        dialogShowSumAccountShrinked.value(false);

        info(strFmt("@RLedgerTurnover:TotalsOnlyDepricatedWarning"));
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogShowSumAccount_modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method invoked on modified event in the dialog control.
    /// </summary>
    /// <param name="_value">
    /// The dialog control.
    /// </param>
    /// <returns>
    /// true if value in the dialog control is modified successfully; otherwise, false.
    /// </returns>
    protected boolean dialogShowSumAccount_modified(FormCheckBoxControl _value)
    {
        if (dialogShowSumAccount.value())
        {
            dialogShowSumAccountShrinked.enabled(true);
        }
        else
        {
            dialogShowSumAccountShrinked.enabled(false);
            dialogShowSumAccountShrinked.value(false);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogUpdate</Name>
				<Source><![CDATA[
    public void dialogUpdate(DialogRunbase dialog = null)
    {
        super(dialog);
        if (dialogFormRun)
        {
            dialogFormRun.init();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionCriteriaGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a reference to the financial dimension criteria dialog group.
    /// </summary>
    /// <returns>
    /// A reference to the financial dimension criteria dialog group.
    /// </returns>
    public DialogGroup dimensionCriteriaGroup()
    {
        return dlgGroupDimensionCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDialogLastValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container of report parameters from dialog.
    /// </summary>
    /// <returns>
    /// A container of report parameters from dialog.
    /// </returns>
    public container getDialogLastValue()
    {
        return [periodCode, fromDate, toDate, currencyType, currencyCode, mainAccountNum,
            mainAccountNumCorr, selectedFieldsOrder, selectedFieldsExp, dimensionCriteria];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers values from dialog fields to the class member values that represent the user input.
    /// </summary>
    /// <returns>
    /// true if super(), otherwise, false.
    /// </returns>
    public boolean getFromDialog()
    {
        boolean ret = super();

        [periodCode, fromDate, toDate, currencyType, currencyCode, mainAccountNum,
            mainAccountNumCorr, selectedFieldsOrder, selectedFieldsExp,
            dimensionCriteria] = dialogFormRun.getControlValue();

        if (this.type().fieldTransDate())
        {
            if (! toDate)
            {
                return checkFailed("@GLS105013");
            }

            if (fromDate > toDate)
            {
                return checkFailed("@GLS101164");
            }
        }

        if (this.type().fieldCurrencyCode())
        {
            if (currencyType == CurrencyType_RU::Currency && ! currencyCode)
            {
                return checkFailed("@GLS105020");
            }
        }

        if (this.type().groupParamNames() && ! conlen(selectedFieldsOrder))
        {
            ret = checkFailed("@GLS105080");
        }

        if (this.type().fieldOperationsTax())
        {
            operationsTax = dialogOperationsTax.value();
        }

        if (this.type().keyMainAccount())
        {
            showSumAccount = dialogShowSumAccount.value();
        }

        showTotalsOnly = dialogShowSumAccountShrinked.value() && showSumAccount;
        printRanges         = dialogPrintRanges.value();
        deleteZero          = dialogDeleteZero.value();
        showTrans           = dialogShowTrans.value();
        showBalance         = dialogShowBalance.value();

        if (dialogShowBalanceTrans)
        {
            showBalanceTrans = dialogShowBalanceTrans.value();
        }

        if (dialogShowOrigin)
        {
            showOrigin  = dialogShowOrigin.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportTableRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a reference to the <c>RLedgerTurnoverSheet</c> table record.
    /// </summary>
    /// <returns>
    /// A reference to the <c>RLedgerTurnoverSheet</c> table record.
    /// </returns>
    public RefRecId getReportTableRecId()
    {
        return reportTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlement</Name>
				<Source><![CDATA[
    private Common getSettlement(QueryRun _queryRun)
    {
        Common               settlement;
        TableId              settlementTableId = this.type().settlementTableId();
        QueryBuildDataSource dataSource        = _queryRun.query().dataSourceTable(settlementTableId);

        if (dataSource)
        {
            settlement = _queryRun.get(settlementTableId);
        }

        return settlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSumAccount</Name>
				<Source><![CDATA[
    private container getSumAccount(MainAccountNum _account)
    {
        MainAccount                                 mainAccount;
        DimensionAttributeValue                     dimensionAttributeValue;
        DimensionAttributeValueTotallingCriteria    dimAttrValueTotCrit;
        MainAccountNum                              sumAccount;
        boolean                                     reverseSign;

        if (mapSumAccounts.exists(_account))
        {
            [ sumAccount, reverseSign ] = mapSumAccounts.lookup(_account);
        }
        else
        {
            select firstOnly InvertTotalSign from dimAttrValueTotCrit
                where   dimAttrValueTotCrit.FromValue   <= _account
                    &&  dimAttrValueTotCrit.ToValue     >= _account
            join tableId from dimensionAttributeValue
                where   dimensionAttributeValue.RecId               == dimAttrValueTotCrit.DimensionAttributeValue
                    &&  dimensionAttributeValue.DimensionAttribute  == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)
            join MainAccountId from mainAccount
                where   mainAccount.RecId                   == dimensionAttributeValue.EntityInstance
                    &&  mainAccount.LedgerChartOfAccounts   == LedgerChartOfAccounts::current();

            sumAccount  = mainAccount.MainAccountId;
            reverseSign = dimAttrValueTotCrit.InvertTotalSign;

            mapSumAccounts.insert(_account, [ sumAccount, reverseSign ]);
        }

        return [ sumAccount, reverseSign ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSumKey</Name>
				<Source><![CDATA[
    private container getSumKey(container _paramValues)
    {
        int             pos, idx;
        container       ret;
        container       sumAccount;
        MainAccountNum  accountNum;
        ;

        if (! this.type().keyMainAccount())
            return ret;

        pos = confind(selectedFieldsOrder, this.type().keyMainAccount());

        if (pos)
        {
            [accountNum] = conpeek(_paramValues, pos);
            sumAccount   = this.getSumAccount(accountNum);

            if (conpeek(sumAccount, 1))
            {
                for (idx = 1; idx < pos; idx++)
                {
                    ret = conins(ret, conlen(ret) + 1, conpeek(_paramValues, idx));
                }

                ret = conins(ret, conlen(ret) + 1, sumAccount);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVouchersColumnsMap</Name>
				<Source><![CDATA[
    public Map getVouchersColumnsMap()
    {
        return vouchersColumnsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class.
    /// </summary>
    /// <returns>
    /// A Boolean value indicating whether the initialization was successful.
    /// </returns>
    public boolean init()
    {
        boolean ret = super();

        mapMapTrans             = new Map(Types::Container, Types::Class);
        mapBalanceAmounts       = new Map(Types::Container, Types::Container);
        mapSumAccounts          = new Map(Types::String,    Types::Container);
        mapSumAccountAmounts    = new Map(Types::Container, Types::Container);
        mapTransKeyData         = new Map(Types::String,    Types::Class);
        mapParamValueNames      = new Map(Types::Container, Types::String);

        ledgerSheetType = LedgerParameters::find().UsePrecalcData_RU           ?
                          RLedgerTurnoverType::newPrecalcInterface(reportType) :
                          RLedgerTurnoverType::newInterface(reportType);

        isInitialized = true;

        return ret && (ledgerSheetType != null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        int idx;
        ;

        this.initQuery();

        selectedFieldsOrder = ledgerSheetType.groupParamDefault();

        selectedFieldsExp = connull();
        for (idx = 1; idx <= conlen(selectedFieldsOrder); idx++)
        {
            selectedFieldsExp += false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a default query.
    /// </summary>
    protected void initQuery()
    {
        ;
        queryRun = new SysQueryRun(this.query());
        queryRun.promptShowSorting(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns identifier for serializing the class in the SysLastValue.
    /// </summary>
    /// <returns>
    /// The identifier name.
    /// </returns>
    public identifiername lastValueElementName()
    {
        Session session = new Session();

        return con2Str([classId2Name(classidget(this)),
                        session.interfaceLanguage(),
                        enum2int(reportType),
                        LedgerParameters::find().UsePrecalcData_RU]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loopBalanceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs calculation of balances.
    /// </summary>
    protected void loopBalanceTrans()
    {
        this.balanceTrans(DebCredProposal::Debit);
        this.balanceTrans(DebCredProposal::Credit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loopTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs calculation of transactions.
    /// </summary>
    protected void loopTrans()
    {
        const int trans1 = 1;
        const int balanceTrans = 2;

        Set             set;
        SetEnumerator   setEnumerator;
        Common          trans;
        Common          trans_W;
        Common          transHeader;
        Common          transSplit;
        Common          subTrans;
        container       mapKey;
        container       transKey;
        container       transValue;
        container       transAmounts;
        container       settledTransAmounts;
        container       settledCurPeriodAmounts;
        Map             mapTrans;
        QueryRun        queryRunTrans;
        Query           query;
        TransDate       startDate;
        TransDate       endDate;

        if (progress)
        {
            progress.setText("@SYS4081709");
            this.redrawWindows();
        }

        if (! showTrans && ! showBalanceTrans)
        {
            if (progress)
            {
                progress.incCount();
            }
            return;
        }

        transSplit.setTmp();

        set = new Set(Types::Integer);

        if (showTrans)
        {
            set.add(trans1);
        }

        if (showBalanceTrans)
        {
            set.add(balanceTrans);
        }

        setEnumerator = set.getEnumerator();
        while (setEnumerator.moveNext())
        {
            if (setEnumerator.current() == trans1)
            {
                startDate   = fromDate;
                endDate     = toDate;
            }
            else
            {
                startDate   = dateNull();
                endDate     = fromDate - 1;
            }

            query = new Query(queryRun.query().pack());
            this.setQueryRanges(query, startDate, endDate);

            queryRunTrans = this.type().queryRun(query, selectedFieldsOrder);
            while (queryRunTrans.next())
            {
                trans       = queryRunTrans.get(this.type().transTableId());
                subTrans    = queryRunTrans.get(this.type().subTransTableId());
                transHeader = queryRunTrans.get(this.type().transHeaderTableId());

                if (! this.type().isTransIncluded(trans, subTrans, currencyType, startDate, endDate))
                    continue;

                if (useTrans_W)
                {
                    trans_W = queryRunTrans.get(tableIdCorrection);
                }

                transKey            = this.type().transDetails(subTrans, transHeader);
                settledTransAmounts = this.type().settledTransAmounts(trans, startDate, endDate, currencyType, trans_W);

                transSplit = this.type().splitTrans(trans);
                if (transSplit.RecId)
                {
                    select transSplit;
                }

                do
                {
                    transAmounts = this.type().transAmounts(transSplit.RecId ? transSplit : trans, currencyType, trans_W);

                    mapKey = this.type().groupParamValues(trans, selectedFieldsOrder, transHeader, transSplit);

                    if (mapMapTrans.exists(mapKey))
                    {
                        mapTrans = mapMapTrans.lookup(mapKey);
                    }
                    else
                    {
                        mapTrans = new Map(Types::Container, Types::Container);
                    }

                    if (mapTrans.exists(transKey))
                    {
                        transValue = mapTrans.lookup(transKey);
                    }
                    else
                    {
                        transValue = [0, 0, 0, 0, 0, 0, 0, 0];
                    }

                    if (setEnumerator.current() == trans1)
                    {
                        transValue = [ conpeek(transValue, 1) + conpeek(transAmounts, 1),
                                       conpeek(transValue, 2) + conpeek(transAmounts, 2),
                                       conpeek(transValue, 3) + conpeek(settledTransAmounts, 1),
                                       conpeek(transValue, 4) + conpeek(settledTransAmounts, 2),
                                       conpeek(transValue, 1) + conpeek(transAmounts, 1) - (conpeek(transValue, 3) + conpeek(settledTransAmounts, 1)),
                                       conpeek(transValue, 2) + conpeek(transAmounts, 2) - (conpeek(transValue, 4) + conpeek(settledTransAmounts, 2)),
                                       0,
                                       0 ];
                    }
                    else
                    {
                        settledCurPeriodAmounts = this.type().settledTransAmounts(trans, fromDate, toDate, currencyType, trans_W);
                        transValue = [ 0,
                                       0,
                                       conpeek(transValue, 3) + conpeek(settledCurPeriodAmounts, 1),
                                       conpeek(transValue, 4) + conpeek(settledCurPeriodAmounts, 2),
                                       0,
                                       0,
                                       conpeek(transValue, 7) + conpeek(transAmounts, 1) - conpeek(settledTransAmounts, 1),
                                       conpeek(transValue, 8) + conpeek(transAmounts, 2) - conpeek(settledTransAmounts, 2) ];

                        transValue = conPoke(transValue, 5, conpeek(transValue, 7) - conpeek(transValue, 3));
                        transValue = conPoke(transValue, 6, conpeek(transValue, 8) - conpeek(transValue, 4));
                    }

                    if (transValue != [0, 0, 0, 0, 0, 0, 0, 0])
                    {
                        if (setEnumerator.current() == trans1)
                        {
                            this.addTransKeyData(subTrans, mapKey + transKey, true);
                        }

                        mapTrans.insert(transKey, transValue);

                        mapMapTrans.insert(mapKey, mapTrans);
                    }

                    if (transSplit.RecId)
                    {
                        next transSplit;
                    }
                }
                while (transSplit.RecId);
            }
        }

        if (progress)
        {
            progress.incCount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>originalDocumentsByRow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method launches dialog for specifying column of selected row in grid of RLedgerTurnoverView form for drill-down functionality processing.
    /// </summary>
    /// <param name="_idx">
    /// An integer value corresponding to the number of row.
    /// </param>
    /// <param name="_view">
    /// The <c>RLedgerTurnoverView</c> instance.
    /// </param>
    public void originalDocumentsByRow(int _idx, RLedgerTurnoverView _view)
    {
        FormListControl listControl = _view.parmFormListControl();
        int colAmount = listControl.getColumnCount();
        container colContainer;
        container amountTypeCon = _view.getAmountTypeCon();

        if (colAmount != conLen(amountTypeCon))
        {
            return;
        }

        for (int it = 0; it < colAmount; it++)
        {
            if (conPeek(amountTypeCon, it+1) != 0)
            {
                str columnName = listControl.getColumn(it).text();
                colContainer += columnName;
                vouchersColumnsMap.insert(columnName, it);
            }
        }

        Args args = new Args();
        args.caller(this);
        RLedgerTurnoverEngineVouchersController::main(args, colContainer, _view, _idx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [currentVersion, periodCode, fromDate, toDate, currencyType, currencyCode, mainAccountNum, mainAccountNumCorr, selectedFieldsOrder, selectedFieldsExp, operationsTax, dimensionCriteria, printRanges, deleteZero, showSumAccount, showTotalsOnly, showTrans, showBalanceTrans, showBalance, showOrigin, reportType, (queryRun) ? queryRun.pack() : connull()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode = currencyCode)
    {
        currencyCode = _currencyCode;
        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyType</Name>
				<Source><![CDATA[
    public CurrencyType_RU parmCurrencyType(CurrencyType_RU _currencyType = currencyType)
    {
        currencyType = _currencyType;
        return currencyType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeleteZero</Name>
				<Source><![CDATA[
    public NoYes parmDeleteZero(NoYes _deleteZero = deleteZero)
    {
        deleteZero = _deleteZero;
        return deleteZero;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionCriteria</Name>
				<Source><![CDATA[
    public DimensionDefault parmDimensionCriteria(DimensionDefault _dimensionCriteria = dimensionCriteria)
    {
        dimensionCriteria = _dimensionCriteria;
        return dimensionCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    public TransDate parmFromDate(TransDate _fromDate = fromDate)
    {
        fromDate = _fromDate;
        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHideProgress</Name>
				<Source><![CDATA[
    public boolean parmHideProgress(boolean _hideProgress = hideProgress)
    {
        hideProgress = _hideProgress;
        return hideProgress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastVouchersDialogValue</Name>
				<Source><![CDATA[
    public str parmLastVouchersDialogValue(str _lastVouchersDialogValue = lastVouchersDialogValue)
    {
        lastVouchersDialogValue = _lastVouchersDialogValue;
        return lastVouchersDialogValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMainAccountNum</Name>
				<Source><![CDATA[
    public MainAccountRange parmMainAccountNum(MainAccountRange _mainAccountNum = mainAccountNum)
    {
        mainAccountNum = _mainAccountNum;
        return mainAccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMainAccountNumCorr</Name>
				<Source><![CDATA[
    public MainAccountRange parmMainAccountNumCorr(MainAccountRange _mainAccountNumCorr = mainAccountNumCorr)
    {
        mainAccountNumCorr = _mainAccountNumCorr;
        return mainAccountNumCorr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintRanges</Name>
				<Source><![CDATA[
    public NoYes parmPrintRanges(NoYes _printRanges = printRanges)
    {
        printRanges = _printRanges;
        return printRanges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportType</Name>
				<Source><![CDATA[
    public RLedgerTurnoverSheetType parmReportType(RLedgerTurnoverSheetType _reportType = reportType)
    {
        reportType = _reportType;
        return reportType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowBalance</Name>
				<Source><![CDATA[
    public NoYes parmShowBalance(NoYes _showBalance = showBalance)
    {
        showBalance = _showBalance;
        return showBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowBalanceTrans</Name>
				<Source><![CDATA[
    public NoYes parmShowBalanceTrans(NoYes _showBalanceTrans = showBalanceTrans)
    {
        showBalanceTrans = _showBalanceTrans;
        return showBalanceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowOrigin</Name>
				<Source><![CDATA[
    public NoYes parmShowOrigin(NoYes _showOrigin = showOrigin)
    {
        showOrigin = _showOrigin;
        return showOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowSumAccount</Name>
				<Source><![CDATA[
    public NoYes parmShowSumAccount(NoYes _showSumAccount = showSumAccount)
    {
        showSumAccount = _showSumAccount;
        return showSumAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowTotalsOnly</Name>
				<Source><![CDATA[
    public NoYes parmShowTotalsOnly(NoYes _showTotalsOnly = showTotalsOnly)
    {
        showTotalsOnly = _showTotalsOnly;
        return showTotalsOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowTrans</Name>
				<Source><![CDATA[
    public NoYes parmShowTrans(NoYes _showTrans = showTrans)
    {
        showTrans = _showTrans;
        return showTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    public TransDate parmToDate(TransDate _toDate = toDate)
    {
        toDate = _toDate;
        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a default query.
    /// </summary>
    /// <returns>
    /// The <c>Query</c> instance.
    /// </returns>
    public Query query()
    {
        return new Query(ledgerSheetType.query());
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>redrawWindows</Name>
				<Source><![CDATA[
    private void redrawWindows()
    {
        if (progress)
        {
            progress.update(true);
        }
        infolog.redrawAllWindows();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        Args    args;
        FormRun formRun;

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00011, funcName());

        if (!isInitialized)
        {
            this.init();
        }

        this.runReport();

        if (!isRunningOnBatch())
        {
            args = new Args(formStr(RLedgerTurnoverView));
            args.record(RLedgerTurnoverSheet::findRecId(reportTableRecId));
            args.caller(this);

            formRun = classFactory.formRunClass(args);
            FormRun.parmShrinked(showTotalsOnly);
            formRun.init();
            formRun.run();
            formRun.detach();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the report processing.
    /// </summary>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// The update conflict could not be resolved automatically.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// The update conflict occured.
    /// </exception>
    public void runReport()
    {
        const int total = 7;
        const int retryNum = 5;

        FieldId                         fieldIdCorrection;

        try
        {
            if (! this.type().settlementTableId())
            {
                expandLevel = conLen(selectedFieldsExp);
                while (expandLevel > 0 && ! conPeek(selectedFieldsExp, expandLevel))
                {
                    expandLevel--;
                }
            }
            else
            {
                this.type().parmExpandedBalance(conFind(selectedFieldsExp, true) > 0);
            }

            [tableIdCorrection, fieldIdCorrection]  = this.type().fieldCorrection(currencyType);

            if (tableIdCorrection != this.type().transTableId())
            {
                useTrans_W = true;
            }

            this.loopBalanceTrans();
            this.loopTrans();

            ttsbegin;

            this.createReportHeader();
            this.createReportLine();

            ttscommit;

            this.progressHide();
            this.progressKill();
            infolog.redrawAllWindows();
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= retryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimensionRange</Name>
				<Source><![CDATA[
    private void setDimensionRange(Query _query, QueryBuildDataSource _queryBuildDataSource, FieldId _dimensionField)
    {
        int                                 idx;
        DimensionAttributeValueSetStorage   dimAttrValueSetStorage;

        dimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(dimensionCriteria);

        for (idx = 1; idx <= dimAttrValueSetStorage.elements(); idx++)
        {
            SysQuery::addDimensionAttributeRange(
                _query,
                _queryBuildDataSource.name(),
                fieldId2name(_queryBuildDataSource.table(), _dimensionField),
                DimensionComponent::DimensionAttribute,
                dimAttrValueSetStorage.getDisplayValueByIndex(idx),
                DimensionAttribute::find(dimAttrValueSetStorage.getAttributeByIndex(idx)).Name);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryRanges</Name>
				<Source><![CDATA[
    private void setQueryRanges(Query     _query,
                                TransDate _fromDate,
                                TransDate _toDate)
    {
        TableId                 tableId;
        FieldId                 fieldId;
        QueryBuildDataSource    dataSource;

        boolean getDS(container _fieldInfo)
        {
            if (_fieldInfo == connull())
                return false;

            [tableId, fieldId] = _fieldInfo;

            dataSource = _query.dataSourceTable(tableId);

            return dataSource != null;
        }
        ;

        if (getDS(this.type().fieldTransDate()))
        {
            findOrCreateRange_W(dataSource, fieldId, queryRange(_fromDate, _toDate));
        }

        if (getDS(this.type().fieldSettlementDate()))
        {
            findOrCreateRange_W(dataSource, fieldId, queryRange(_fromDate, _toDate));
        }

        if (getDS(this.type().fieldCurrencyCode()) && currencyType == CurrencyType_RU::Currency)
        {
            findOrCreateRange_W(dataSource, fieldId, queryValue(currencyCode));
        }

        if (this.type().fieldMainAccount())
        {
            this.type().addMainAccountRange(mainAccountNum);
            this.type().addMainAccountRange(mainAccountNumCorr, true);
        }

        if (getDS(this.type().fieldOperationsTax()))
        {
            GeneralJournalEntry::addRangeForPostingLayer(dataSource, fieldId, operationsTax);
        }

        if (getDS(this.type().fieldDefaultDimension()))
        {
            this.setDimensionRange(_query, dataSource, fieldId);
        }

        if (getDS(this.type().fieldLedgerDimension()))
        {
            this.setDimensionRange(_query, dataSource, fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDefaultButton</Name>
				<Source><![CDATA[
    public boolean showDefaultButton()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates and returns the interface to the particular type of the report implementation.
    /// </summary>
    /// <returns>
    /// The interface to the particular type of the report implementation.
    /// </returns>
    public RLedgerTurnoverTypeable type()
    {
        if (! ledgerSheetType)
        {
            ledgerSheetType = LedgerParameters::find().UsePrecalcData_RU           ?
                              RLedgerTurnoverType::newPrecalcInterface(reportType) :
                              RLedgerTurnoverType::newInterface(reportType);
        }

        return ledgerSheetType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer     version;
        container   packedQuery;

        if (packedClass != conNull())
        {
            version     = RunBase::getVersion(packedClass);
            packedQuery = conpeek(packedClass, conlen(packedClass));
        }

        switch (version)
        {
            case currentVersion:
                [version, periodCode, fromDate, toDate, currencyType, currencyCode, mainAccountNum, mainAccountNumCorr, selectedFieldsOrder, selectedFieldsExp, operationsTax, dimensionCriteria, printRanges, deleteZero, showSumAccount, showTotalsOnly, showTrans, showBalanceTrans, showBalance, showOrigin, reportType] = packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun  = new SysQueryRun(packedQuery) ;
                }
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>RLedgerTurnoverEngine</c> class.
    /// </summary>
    /// <param name="_args">
    /// The <c>Args</c> object.
    /// </param>
    /// <returns>
    /// A new instance of the <c>RLedgerTurnoverEngine</c> class.
    /// </returns>
    public static RLedgerTurnoverEngine construct(Args _args)
    {
        RLedgerTurnoverEngine     ledgerSheetEngine;
        RLedgerTurnoverSheetType  reportType = _args.parmEnum();

        ledgerSheetEngine = new RLedgerTurnoverEngine();
        ledgerSheetEngine.parmReportType(reportType);
        ledgerSheetEngine.init();

        return ledgerSheetEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args _args)
    {
        FormDataSource        formDataSource;
        RLedgerTurnoverEngine RLedgerTurnoverEngine = RLedgerTurnoverEngine::construct(_args);

        if (RLedgerTurnoverEngine.prompt())
        {
            RLedgerTurnoverEngine.runOperation();
        }

        if (_args && _args.parmObject())
        {
            formDataSource = _args.parmObject();
            formDataSource.research();
            formDataSource.last();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>