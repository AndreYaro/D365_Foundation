<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendCheque</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendCheque</c> class generates the output data to be used for cheque printing.
/// </summary>
/// <remarks>
/// All lengths used in this class are in millimeters.
/// </remarks>
public class CustVendCheque
{
    protected CompanyBankAccountId accountId;
    protected ChequeNumMethod chequeNumMethod;
    protected BankChequeNum chequeNum;
    protected TmpChequePrintout tmpChequePrintout;
    protected LedgerJournalACType ledgerJournalACType;
    protected Counter numOfSlips;
    protected ReportPosition chequeTop;

    private BankChequeStartNum nextChequeNum;
    private BankChequeStartNum firstChequeNum;
    private BankChequeQty numOfBlankCheque;
    private Set createdChequeNumbers;
    private CompanyCity companyCity;
    private PrintJobSettingsPacked printJobSettingsPacked;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcPaymAmount_BR</Name>
				<Source><![CDATA[
    private AmountCur calcPaymAmount_BR(
        Amount _amount,
        LedgerJournalTrans _ledgerJournalTrans,
        CompanyId _transCompany,
        CurrencyCode _transCurrencyCode,
        ExchRate _crossRate)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(
            Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId),
            _ledgerJournalTrans.CurrencyCode);

        return this.convertAmountTransCurToAmountPaymCur(
            _amount,
            _transCompany,
            _transCurrencyCode,
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.TransDate,
            _crossRate,
            exchangeRateHelper.prepareExchangeRateForStorage(_ledgerJournalTrans.crossrate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextChequeNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current cheque number.
    /// </summary>
    /// <returns>
    /// A value of type <c>BankChequeStartNum</c>.
    /// </returns>
    protected final BankChequeStartNum getNextChequeNum()
    {
        return nextChequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNextChequeNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the current cheque number value.
    /// </summary>
    /// <param name = "_num">
    /// Value of type <c>BankChequeStartNum</c>.
    /// </param>
    protected final void setNextChequeNum(BankChequeStartNum _num)
    {
        nextChequeNum = _num;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreatedChequeNumberEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the enumerator value of created cheque numbers.
    /// </summary>
    /// <returns>
    /// Enumerator value of created cheque numbers.
    /// </returns>
    protected final Enumerator getCreatedChequeNumberEnumerator()
    {
        return createdChequeNumbers.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCreatedChequeNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new cheque number to the created cheque numbers set.
    /// </summary>
    /// <param name = "_num">
    /// A value of type <c>BankChequeNum</c>.
    /// </param>
    protected final void addCreatedChequeNumber(BankChequeNum _num)
    {
        createdChequeNumbers.add(_num);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePaymentFee_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the payment fee.
    /// </summary>
    /// <param name="_recId">
    /// The reference record id in the <c>CustVendPaymJournalFee</c> table.
    /// </param>
    /// <returns>
    /// The payment amount.
    /// </returns>
    private Amount calculatePaymentFee_IN(RecId _recId)
    {
        VendPaymFee vendPaymFeeLoc;
        CustVendPaymJournalFee custVendPaymJournalFeeLoc;
        AmountCur feeAmount;

        while select FeeId, FeeValue from custVendPaymJournalFeeLoc
            where custVendPaymJournalFeeLoc.RefRecId == _recId
        {
            select vendPaymFeeLoc
                where vendPaymFeeLoc.FeeId == custVendPaymJournalFeeLoc.FeeId
                    && (vendPaymFeeLoc.TaxWithholdFeeType_IN == TaxWithholdFeeType_IN::Interest
                        || vendPaymFeeLoc.TaxWithholdFeeType_IN == TaxWithholdFeeType_IN::Others);

            if (vendPaymFeeLoc)
            {
                feeAmount -= custVendPaymJournalFeeLoc.FeeValue;
            }
        }

        return feeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelGeneratedCheques</Name>
				<Source><![CDATA[
    void cancelGeneratedCheques()
    {
        SetEnumerator setEnumerator;
        BankChequeTable bankChequeTable;
        BankChequePaymTrans bankChequePaymTrans;
        LedgerJournalTrans ledgerJournalTrans;
        BankChequeNum cancelChequeNum;

        ttsbegin;

        setEnumerator = this.getCreatedChequeNumberEnumerator();

        while (setEnumerator.moveNext())
        {
            cancelChequeNum = setEnumerator.current();

            update_recordset bankChequeTable
                setting ChequeStatus = ChequeStatus::Created,
                    RecipientType = BankChequeRecipientType::Unknown,
                    RecipientCompany = '',
                    RecipientAccountNum = '',
                    TransDate = dateNull(),
                    AmountCur = 0,
                    Voucher = '',
                    CurrencyCode = ''
                where bankChequeTable.AccountID == accountId
                    && bankChequeTable.ChequeNum == cancelChequeNum;

            ledgerJournalTrans.skipDataMethods(true);

            update_recordset ledgerJournalTrans
                setting BankChequeNum = '',
                    PaymentStatus = CustVendPaymStatus::None
                where ledgerJournalTrans.AccountType == ledgerJournalACType
                    && ledgerJournalTrans.BankChequeNum == cancelChequeNum;

            delete_from bankChequePaymTrans
                where bankChequePaymTrans.AccountId == accountId
                    && bankChequePaymTrans.ChequeNum == cancelChequeNum;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDataOk</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates record of <c>LedgerJournaltrans</c>
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Record of <c>LedgerJournalTrans</c> to be checked
    /// </param>
    /// <returns>
    /// True if record is valid otherwise false
    /// </returns>
    boolean checkDataOk(LedgerJournalTrans _ledgerJournalTrans)
    {
        setPrefix(strFmt("@SYS25866", _ledgerJournalTrans.Voucher));

        switch (ledgerJournalACType)
        {
            case LedgerJournalACType::Vend,
                LedgerJournalACType::Bank,
                LedgerJournalACType::Ledger:
                if (_ledgerJournalTrans.VendTransId
                    && !VendTrans::findByCompany(_ledgerJournalTrans.Company, _ledgerJournalTrans.VendTransId).Approved
                    && _ledgerJournalTrans.SettleVoucher != SettlementType::None)
                {
                    return checkFailed("@SYS3508");
                }
                break;

            case LedgerJournalACType::Cust:
                if (_ledgerJournalTrans.CustTransId
                    && !CustTrans::findByCompany(_ledgerJournalTrans.Company, _ledgerJournalTrans.CustTransId).Approved
                    && _ledgerJournalTrans.SettleVoucher != SettlementType::None)
                {
                    return checkFailed("@SYS3508");
                }
                break;
        }

        if (!accountId)
        {
            return checkFailed(this.getErrorMessageForMissingBankAccountId());
        }

        if (!BankAccountTable::find(accountId))
        {
            return checkFailed(this.getErrorMessageForInvalidBankAccountId());
        }

        if (!this.getNextChequeNum())
        {
            return checkFailed("@SYS24069");
        }

        if (BankChequeTable::find(accountId, this.formatChequeNum(this.getNextChequeNum())).ChequeStatus != ChequeStatus::Created)
        {
            return checkFailed(strFmt("@SYS24139", this.getNextChequeNum()));
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
            && !_ledgerJournalTrans.BankNegInstRecipientName)
        {
            if (ledgerJournalACType == LedgerJournalACType::Vend)
            {
                return checkFailed("@SYS92828");
            }
            else if (ledgerJournalACType == LedgerJournalACType::Cust)
            {
                return checkFailed("@SYS96659");
            }
        }
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
            && ledgerJournalACType == LedgerJournalACType::Cust)
        {
            return checkFailed("@SYS96659");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorMessageForMissingBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the error message when bank account number is not specified.
    /// </summary>
    /// <returns>
    ///     The appropriate error message for a missing bank account.
    /// </returns>
    [Wrappable(true)]
    protected final str getErrorMessageForMissingBankAccountId()
    {
        return "@SYS24651";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorMessageForInvalidBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the error message when bank account number is invalid.
    /// </summary>
    /// <returns>
    ///     The appropriate error message for an invalid bank account.
    /// </returns>
    [Wrappable(true)]
    protected final str getErrorMessageForInvalidBankAccountId()
    {
        return strFmt("@SYS27061", accountId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDataOk_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates record of <c>LedgerJournaltrans</c> according to brazilian rules
    /// </summary>
    /// <param name="_oneVoucher">
    /// OneVoucher_BR object instance to be checked with a list of <c>LedgerJournalTrans</c>
    /// </param>
    /// <returns>
    /// True if record is valid otherwise false
    /// </returns>
    public boolean checkDataOk_BR(OneVoucher_BR _oneVoucher)
    {
        LedgerJournalTrans ledgerJournalTrans;
        ListEnumerator enumerator;
        boolean ret = true;

        enumerator = _oneVoucher.parmVoucherTrans().getEnumerator();

        while (enumerator.moveNext())
        {
            ledgerJournalTrans = enumerator.current();

            ret = ret && this.checkDataOk(ledgerJournalTrans);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chequeNum</Name>
				<Source><![CDATA[
    BankChequeNum chequeNum()
    {
        chequeNum = this.formatChequeNum(this.getNextChequeNum());

        if (chequeNumMethod == ChequeNumMethod::Fixed)
        {
            if (!BankChequeTable::exist(accountId, num2str(this.getNextChequeNum(), 0, 0, 0, 0))) // The sequence is broken, find the next cheque
            {
                this.setNextChequeNum(NumberSeq::numRemoveFormat(BankChequeTable::findNextFree(accountId), ''));

                if (!this.getNextChequeNum())
                {
                    throw error(strFmt("@SYS28696", accountId));
                }

                chequeNum = this.formatChequeNum(this.getNextChequeNum());
            }
        }
        else
        {
            BankChequeTable::createCheque(chequeNum, accountId);
        }
        this.setNextChequeNum(this.getNextChequeNum() + 1);

        this.addCreatedChequeNumber(chequeNum);

        return chequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountPaymCurToAmountTransCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the currency of the payment to the currency of the transaction.
    /// </summary>
    /// <param name="_amountPaymCur">
    /// The amount in payment currency to convert.
    /// </param>
    /// <param name="_paymCompany">
    /// The company where the payment exists.
    /// </param>
    /// <param name="_paymCurrencyCode">
    /// The currency the payment uses.
    /// </param>
    /// <param name="_transCompany">
    /// The company where the transaction exists.
    /// </param>
    /// <param name="_transCurrencyCode">
    /// The currency the transaction uses.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date to use for exchange rate calculations; optional.
    /// </param>
    /// <param name="_crossRate">
    /// The cross rate to use. The default is 0; optional.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate to use. The default is 0; optional.
    /// </param>
    /// <returns>
    /// The amount converted to transaction currency.
    /// </returns>
    protected AmountCur convertAmountPaymCurToAmountTransCur(
        Amount _amountPaymCur,
        CompanyId _paymCompany,
        CurrencyCode _paymCurrencyCode,
        CompanyId _transCompany,
        CurrencyCode _transCurrencyCode,
        TransDate _exchRateDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate _crossRate = 0,
        ExchRate _exchRate = 0)
    {
        AmountCur amountTransCur;
        AmountCur interimAmount;
        CurrencyCode transMstCurrency;
        CurrencyCode paymMstCurrency;
        CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_transCompany).RecId), _exchRateDate);
        CurrencyExchangeHelper paymExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_paymCompany).RecId), _exchRateDate);

        if (_transCurrencyCode == _paymCurrencyCode)
        {
            // Currencies are the same between the marked transaction & the payment
            amountTransCur = _amountPaymCur;
        }
        else if (_crossRate != 0)
        {
            // Cross rate is specified, convert directly from payment to marked transaction currency
            amountTransCur = CurrencyExchange::round(CurrencyExchange::calculateAmount(_amountPaymCur, 100 / _crossRate), _paymCurrencyCode );
        }
        else
        {
            // Convert from payment currency to payment company currency
            if (_exchRate != 0)
            {
                // If an exchange rate was specified for the payment use to convert from payment to payment company currency
                paymExchRateHelper.parmExchangeRate1(_exchRate);
            }

            interimAmount = paymExchRateHelper.calculateTransactionToAccounting(_paymCurrencyCode, _amountPaymCur, false);

            if (_paymCompany != _transCompany)
            {
                // Convert from payment company currency to trans company currency
                changecompany(_transCompany)
                {
                    // Get trans company currency
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(_paymCompany)
                {
                    // Get paym company currency
                    paymMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (paymMstCurrency != transMstCurrency)
                {
                    interimAmount = transExchRateHelper.calculateTransactionToAccounting(paymMstCurrency, interimAmount, false);
                }
            }

            // Convert from trans company currency to trans currency
            amountTransCur = transExchRateHelper.calculateAccountingToTransaction(_transCurrencyCode, interimAmount, true);
        }

        return amountTransCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountTransCurToAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the currency of the open transaction to the currency of the
    /// payment.
    /// </summary>
    /// <param name="_amountTransCur">
    /// The amount in transaction currency to convert.
    /// </param>
    /// <param name="_transCompany">
    /// The company where the transaction exists.
    /// </param>
    /// <param name="_transCurrencyCode">
    /// The currency the transaction uses.
    /// </param>
    /// <param name="_paymCompany">
    /// The company where the payment exists.
    /// </param>
    /// <param name="_paymCurrencyCode">
    /// The currency the payment uses.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date to use for exchange rate calculations; optional.
    /// </param>
    /// <param name="_crossRate">
    /// The cross rate to use; default is 0; optional.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate to use; default is 0; optional.
    /// </param>
    /// <returns>
    /// The amount converted to payment currency.
    /// </returns>
    protected AmountCur convertAmountTransCurToAmountPaymCur(
        Amount _amountTransCur,
        CompanyId _transCompany,
        CurrencyCode _transCurrencyCode,
        CompanyId _paymCompany,
        CurrencyCode _paymCurrencyCode,
        TransDate _exchRateDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate _crossRate = 0,
        ExchRate _exchRate = 0)
    {
        AmountCur amountPaymCur;
        AmountCur interimAmount;
        CurrencyCode transMstCurrency;
        CurrencyCode paymMstCurrency;

        if (_transCurrencyCode == _paymCurrencyCode)
        {
            // Currencies are the same between the marked transaction & the payment
            amountPaymCur = _amountTransCur;
        }
        else if (_crossRate != 0)
        {
            // Cross rate is specified, convert directly from payment to marked transaction currency
            amountPaymCur = CurrencyExchange::round(CurrencyExchange::calculateAmount(_amountTransCur, _crossRate), _paymCurrencyCode);
        }
        else
        {
            CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_transCompany).RecId), _exchRateDate);
            CurrencyExchangeHelper paymExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_paymCompany).RecId), _exchRateDate);

            // Convert from transaction currency to transaction company currency
            interimAmount = transExchRateHelper.calculateTransactionToAccounting(_transCurrencyCode, _amountTransCur, false);

            if (_transCompany != _paymCompany)
            {
                // Convert from transaction company currency to payment company currency
                changecompany(_transCompany)
                {
                    // Get trans company currency
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(_paymCompany)
                {
                    // Get paym company currency
                    paymMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (transMstCurrency != paymMstCurrency)
                {
                    interimAmount = transExchRateHelper.calculateAccountingToTransaction(paymMstCurrency, interimAmount, false);
                }
            }

            if (_exchRate != 0)
            {
                paymExchRateHelper.parmExchangeRate1(_exchRate);
            }

            amountPaymCur = paymExchRateHelper.calculateAccountingToTransaction(_paymCurrencyCode, interimAmount, true);
        }

        return amountPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertToMm</Name>
				<Source><![CDATA[
    ChequeLength convertToMm(ChequeLength _value, ChequeFormatUnit _unit)
    {
        return units2mm(_value, _unit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankChequePaymentTrans</Name>
				<Source><![CDATA[
    private void createBankChequePaymentTrans(
        SpecTrans _specTrans,
        CustVendPaym _custVendPaym,
        AmountCur _paymAmount = _specTrans.Balance01) // Amount is assumed to be in transaction currency
    {
        BankChequePaymTrans bankChequePaymTrans;

        switch (ledgerJournalACType)
        {
            case LedgerJournalACType::Vend,
                LedgerJournalACType::Bank,
                LedgerJournalACType::Ledger:

                bankChequePaymTrans = this.initBankChequePaymentTransFromVendTrans(_specTrans, _custVendPaym, _paymAmount);

                bankChequePaymTrans.insert();
                break;

            case LedgerJournalACType::Cust:

                bankChequePaymTrans = this.initBankChequePaymentTransFromCustTrans(_specTrans, _custVendPaym, _paymAmount);

                bankChequePaymTrans.insert();
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankChequePaymentTrans_BR</Name>
				<Source><![CDATA[
    private void createBankChequePaymentTrans_BR(
        SpecTrans _specTrans,
        LedgerJournalTrans _ledgerJournalTrans,
        ChequeOneVoucher_BR _oneVoucher,
        AmountCur _paymAmount = _specTrans.Balance01) // Amount is assumed to be in transaction currency
    {
        BankChequePaymTrans bankChequePaymTrans;
        VendTrans vendTrans;

        switch (ledgerJournalACType)
        {
            case LedgerJournalACType::Vend:
                vendTrans = _specTrans.vendTrans();
                bankChequePaymTrans.clear();
                bankChequePaymTrans.AccountId = accountId;
                bankChequePaymTrans.ChequeNum = chequeNum;
                bankChequePaymTrans.RecipientType = BankChequeRecipientType::Vend;
                bankChequePaymTrans.RecipientAccountNum = _ledgerJournalTrans.parmAccount();
                bankChequePaymTrans.RecipientCompany = _ledgerJournalTrans.Company;
                bankChequePaymTrans.Voucher = _oneVoucher.parmVoucher();
                bankChequePaymTrans.TransDate = _oneVoucher.parmTransDate();
                bankChequePaymTrans.CurrencyCode = vendTrans.CurrencyCode;
                bankChequePaymTrans.InvoiceAmountCur = vendTrans.AmountCur;

                bankChequePaymTrans.CashDiscAmountCur = _specTrans.getPossibleCashDiscAmount(
                    _ledgerJournalTrans.TransDate,
                    VendPaymModeTable::discGraceDays(_ledgerJournalTrans.PaymMode));

                bankChequePaymTrans.PaymentAmountCur = _paymAmount;
                bankChequePaymTrans.InvoiceId = vendTrans.Invoice;
                bankChequePaymTrans.InvoiceDate = vendTrans.documentInvoiceDate();
                bankChequePaymTrans.InvoiceTransDate = vendTrans.TransDate;
                bankChequePaymTrans.InvoiceVoucher = vendTrans.Voucher;
                bankChequePaymTrans.InvoiceCompany = vendTrans.DataAreaId;
                bankChequePaymTrans.InvoiceAccountNum = vendTrans.AccountNum;
                bankChequePaymTrans.VendPaymentGroup = vendTrans.VendPaymentGroup;
                bankChequePaymTrans.RemittanceAddress = _ledgerJournalTrans.RemittanceAddress;

                bankChequePaymTrans.insert();
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillBankChequePaymentTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the calculation of payment transactions.
    /// </summary>
    /// <param name="_oneVoucher">
    /// Voucher list to process.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Wrong use of function when it isn't vendoraccount type.
    /// </exception>
    void fillBankChequePaymentTrans_BR(OneVoucher_BR _oneVoucher)
    {
        SpecTrans specTrans;
        AmountCur paymAmount;
        AmountCur unsettledPaym;
        LedgerJournalTrans ledgerJournalTrans;
        ListEnumerator oneVoucherTrans;

        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(
                Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId),
                ledgerJournalTrans.CurrencyCode);

        void calcPaym_BR()
        {
            switch (ledgerJournalACType)
            {
                case LedgerJournalACType::Vend:
                    unsettledPaym = this.convertAmountPaymCurToAmountTransCur(
                        unsettledPaym,
                        ledgerJournalTrans.Company,
                        ledgerJournalTrans.CurrencyCode,
                        specTrans.RefCompany,
                        specTrans.vendTrans().CurrencyCode,
                        ledgerJournalTrans.TransDate,
                        specTrans.CrossRate,
                        exchangeRateHelper.prepareExchangeRateForStorage(ledgerJournalTrans.crossrate()));
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            paymAmount = min(-specTrans.Balance01, unsettledPaym);
            this.createBankChequePaymentTrans_BR(specTrans, ledgerJournalTrans, _oneVoucher, -paymAmount);
            unsettledPaym -= paymAmount;
            unsettledPaym = unsettledPaym <= 0 ? 0 : this.calcPaymAmount_BR(
                unsettledPaym,
                ledgerJournalTrans,
                specTrans.RefCompany,
                ledgerJournalACType == LedgerJournalACType::Cust ?
                    specTrans.custTrans().CurrencyCode :
                    specTrans.vendTrans().CurrencyCode,
                specTrans.CrossRate);
        }

        oneVoucherTrans = _oneVoucher.parmVoucherTrans().getEnumerator();

        while (oneVoucherTrans.moveNext())
        {
            ledgerJournalTrans = oneVoucherTrans.current();

            unsettledPaym = ledgerJournalTrans.amount();

            while select crosscompany specTrans
                order by Balance01 desc
                where specTrans.SpecTableId == ledgerJournalTrans.TableId
                    && specTrans.SpecRecId == ledgerJournalTrans.RecId
                    && specTrans.SpecCompany == ledgerJournalTrans.company()
            {
                calcPaym_BR();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatChequeNum</Name>
				<Source><![CDATA[
    private BankChequeNum formatChequeNum(BankChequeStartNum _chequeNum, Num _mask = '')
    {
        return NumberSeq::numInsertFormat(_chequeNum, _mask);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaturityDate</Name>
				<Source><![CDATA[
    private PDCMaturityDate getMaturityDate(PDCMaturityDate _maturityDate, LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_maturityDate && CustVendPDCManager::allowPostDatedChecks(_ledgerJournalTrans))
        {
            return _maturityDate;
        }
        else
        {
            return _ledgerJournalTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBankPaymentTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the transaction information for the given <c>LedgerJournalTrans</c> record into
    /// the <c>BankChequePaymTrans</c> table for the current cheque.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record containing the transaction information.
    /// </param>
    /// <param name="_custVendPaym">
    /// The <c>CustVendPaym</c> class that contains the transaction information that is needed for the check.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Thrown if the _ledgerJournalTrans parameter contains an invalid AccountType value.
    /// </exception>
    protected void insertBankPaymentTrans(LedgerJournalTrans _ledgerJournalTrans, CustVendPaym _custVendPaym)
    {
        SpecTrans specTrans;
        AmountCur paymAmount;
        AmountCur unsettledPaym;
        AmountCur totalAmountCur;

        VendTrans vendTrans;

        CustTrans custTrans;
        boolean partPaid = false;
        ExchrateSecondary crossRate;
        ExchangeRateHelper exchangeRateHelper;
        CurrencyExchangeRate exchangeRateForStorage;
        TaxWithholdTrans taxWithholdTrans;

        crossRate = _custVendPaym.ledgerJournalTrans().crossrate();

        exchangeRateHelper = ExchangeRateHelper::newCurrency(
            Ledger::primaryLedger(CompanyInfo::findDataArea(_custVendPaym.ledgerJournalTrans().Company).RecId),
            _custVendPaym.ledgerJournalTrans().CurrencyCode);

        exchangeRateForStorage = exchangeRateHelper.prepareExchangeRateForStorage(crossRate);

        unsettledPaym = _ledgerJournalTrans.amount();

        // Determine if has been partially paid
        while select crosscompany Balance01, RefCompany, RefTableId, RefRecId, CrossRate from specTrans
            where specTrans.SpecTableId == tableNum(LedgerJournalTrans)
                && specTrans.SpecRecId   == _ledgerJournalTrans.RecId
                && specTrans.SpecCompany == _ledgerJournalTrans.company()
        {
            if (ledgerJournalACType == ledgerJournalACType::Cust)
            {
                custTrans = specTrans.custTrans();
                totalAmountCur += this.convertAmountTransCurToAmountPaymCur(
                    -specTrans.Balance01,
                    specTrans.RefCompany,
                    custTrans.CurrencyCode,
                    _custVendPaym.ledgerJournalTrans().Company,
                    _custVendPaym.ledgerJournalTrans().CurrencyCode,
                    _custVendPaym.ledgerJournalTrans().TransDate,
                    specTrans.CrossRate,
                    exchangeRateForStorage);
            }
            else
            {
                vendTrans = specTrans.vendTrans();
                totalAmountCur += this.convertAmountTransCurToAmountPaymCur(
                    -specTrans.Balance01,
                    specTrans.RefCompany,
                    vendTrans.CurrencyCode,
                    _custVendPaym.ledgerJournalTrans().Company,
                    _custVendPaym.ledgerJournalTrans().CurrencyCode,
                    _custVendPaym.ledgerJournalTrans().TransDate,
                    specTrans.CrossRate,
                    exchangeRateForStorage);
            }
        }

        if (unsettledPaym < totalAmountCur)
        {
            partPaid = true;
        }

        totalAmountCur = 0;

        while select crosscompany specTrans
            order by specTrans.Balance01 desc
            where specTrans.SpecTableId == tableNum(LedgerJournalTrans)
                && specTrans.SpecRecId == _ledgerJournalTrans.RecId
                && specTrans.SpecCompany == _ledgerJournalTrans.company()
        {
            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Vend,
                    LedgerJournalACType::Bank,
                    LedgerJournalACType::Ledger:

                    vendTrans = specTrans.vendTrans();

                    unsettledPaym = this.convertAmountPaymCurToAmountTransCur(
                        unsettledPaym,
                        _custVendPaym.ledgerJournalTrans().Company,
                        _custVendPaym.ledgerJournalTrans().CurrencyCode,
                        specTrans.RefCompany,
                        vendTrans.CurrencyCode,
                        _custVendPaym.ledgerJournalTrans().TransDate,
                        specTrans.CrossRate,
                        exchangeRateForStorage);

                    // Assign different value to payment amount in different situation
                    if (partPaid)
                    {
                        select firstonly RecId, sum(InvoiceTaxWithholdAmount) from taxWithholdTrans
                            group by RecId
                            where taxWithholdTrans.SpecTransId == specTrans.RecId;
                        
                        if(_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && taxWithholdTrans.RecId != 0)
                        {
                            paymAmount = min((-(specTrans.Balance01) - taxWithholdTrans.InvoiceTaxWithholdAmount), unsettledPaym);
                            paymAmount = max(paymAmount, 0);
                        }
                        else
                        {
                            paymAmount = min(-specTrans.Balance01, unsettledPaym);
                            paymAmount = max(paymAmount, 0);
                        }
                    }
                    else
                    {
                        paymAmount = -specTrans.Balance01;
                    }

                    this.createBankChequePaymentTrans(specTrans, _custVendPaym, -paymAmount);

                    unsettledPaym -= paymAmount;

                    if (unsettledPaym > 0)
                    {
                        unsettledPaym = this.convertAmountTransCurToAmountPaymCur(
                            unsettledPaym,
                            specTrans.RefCompany,
                            vendTrans.CurrencyCode,
                            _custVendPaym.ledgerJournalTrans().Company,
                            _custVendPaym.ledgerJournalTrans().CurrencyCode,
                            _custVendPaym.ledgerJournalTrans().TransDate,
                            specTrans.CrossRate,
                            exchangeRateForStorage);
                    }
                    else
                    {
                        unsettledPaym = 0;
                    }

                    totalAmountCur += paymAmount;
                    break;

                case LedgerJournalACType::Cust:

                    custTrans = specTrans.custTrans();

                    unsettledPaym = this.convertAmountPaymCurToAmountTransCur(
                        unsettledPaym,
                        _custVendPaym.ledgerJournalTrans().Company,
                        _custVendPaym.ledgerJournalTrans().CurrencyCode,
                        specTrans.RefCompany,
                        custTrans.CurrencyCode,
                        _custVendPaym.ledgerJournalTrans().TransDate,
                        specTrans.CrossRate,
                        exchangeRateForStorage);

                    // Assign different value to payment amount in different situation
                    if (partPaid)
                    {
                        paymAmount = min(-specTrans.Balance01, unsettledPaym);
                        paymAmount = max(paymAmount, 0);
                    }
                    else
                    {
                        paymAmount = -specTrans.Balance01;
                    }

                    this.createBankChequePaymentTrans(specTrans, _custVendPaym, -paymAmount);

                    unsettledPaym -= paymAmount;

                    if (unsettledPaym > 0)
                    {
                        unsettledPaym = this.convertAmountTransCurToAmountPaymCur(
                            unsettledPaym,
                            specTrans.RefCompany,
                            custTrans.CurrencyCode,
                            _custVendPaym.ledgerJournalTrans().Company,
                            _custVendPaym.ledgerJournalTrans().CurrencyCode,
                            _custVendPaym.ledgerJournalTrans().TransDate,
                            specTrans.CrossRate,
                            exchangeRateForStorage);
                    }
                    else
                    {
                        unsettledPaym = 0;
                    }

                    totalAmountCur += paymAmount;
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankDetails</Name>
				<Source><![CDATA[
    protected void initBankDetails(
        BankAccountID _accountId,
        BankChequeLayout _bankChequeLayout,
        BankAccountTable _bankAccountTable)
    {
        tmpChequePrintout.AccountId = _accountId;
        tmpChequePrintout.BankName = _bankChequeLayout.BankName ? _bankAccountTable.Name : '';
        tmpChequePrintout.RegistrationNum = _bankChequeLayout.BankNum ? _bankAccountTable.RegistrationNum : '';
        tmpChequePrintout.AccountNum = _bankChequeLayout.BankNum ? _bankAccountTable.AccountNum : '';
        tmpChequePrintout.micrLine = _bankChequeLayout.micrLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initChequeNum</Name>
				<Source><![CDATA[
    private void initChequeNum()
    {
        BankChequeLayout bankChequeLayout;

        if (firstChequeNum && BankChequeTable::find(accountId, this.formatChequeNum(firstChequeNum)).ChequeStatus == ChequeStatus::Created)
        {
            return;
        }

        bankChequeLayout = BankChequeLayout::find(accountId);
        chequeNumMethod = bankChequeLayout.ChequeNumMethod;

        if (bankChequeLayout)
        {
            this.setChequeNum();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initChequeNumEx</Name>
				<Source><![CDATA[
    public void initChequeNumEx(boolean _forOpen)
    {
        this.initChequeNum();

        if (_forOpen)
        {
            this.setNextChequeNum(firstChequeNum);
            tmpChequePrintout = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpChequePrintout</Name>
				<Source><![CDATA[
    protected void initTmpChequePrintout(
        LedgerJournalACType _accountType,
        LogisticsPostalAddress _address,
        LogisticsLocationEntity _location,
        VendTable _vendTable,
        CustTable _custTable,
        BankAccountTable _bankAccountTable,
        BankNegInstRecipientName _bankNegInstRecipientName,
        RefRecId _recId,
        ChequeFormType _chequeFormType,
        CustVendChequeSlipTextCalculator _slipTextCalculator,
        boolean _printStreetCity,
        boolean _printSignature)
    {
        switch (_accountType)
        {
            case LedgerJournalACType::Vend:
                //if there is a remit to address, use it to create the check, else use the address in the vendor table
                if (_address)
                {
                    tmpChequePrintout.RecipientName = _location ? _location.parmLocationDescription() : '';
                    tmpChequePrintout.Address = _address.Address;
                    tmpChequePrintout.CountryRegionId = _address.CountryRegionId;
                    tmpChequePrintout.State = _address.State;
                    tmpChequePrintout.County = _address.County;
                    if (_printStreetCity)
                    {
                        tmpChequePrintout.Street = _address.Street;
                        tmpChequePrintout.City = _address.City;
                    }
                }
                else
                {
                    _address = _vendTable.postalAddress();
                    tmpChequePrintout.RecipientName = _vendTable.name();
                    tmpChequePrintout.Address = _address.Address;
                    tmpChequePrintout.CountryRegionId = _address.CountryRegionId;
                    tmpChequePrintout.State = _address.State;
                    tmpChequePrintout.County = _address.County;
                    if (_printStreetCity)
                    {
                        tmpChequePrintout.Street = _address.Street;
                        tmpChequePrintout.City = _address.City;
                    }
                }
                break;

            case LedgerJournalACType::Cust:
                _address = _custTable.postalAddress();
                tmpChequePrintout.RecipientName = _custTable.name();
                tmpChequePrintout.Address = _address.Address;
                tmpChequePrintout.CountryRegionId = _address.CountryRegionId;
                tmpChequePrintout.State = _address.State;
                tmpChequePrintout.County = _address.County;
                if (_printStreetCity)
                {
                    tmpChequePrintout.Street = _address.Street;
                    tmpChequePrintout.City = _address.City;
                }
                break;

            case LedgerJournalACType::Bank:
                _address = _bankAccountTable.postalAddress();
                tmpChequePrintout.RecipientName = _bankAccountTable.Name;
                tmpChequePrintout.Address = _address.Address;
                tmpChequePrintout.CountryRegionId = _address.CountryRegionId;
                tmpChequePrintout.State = _address.State;
                tmpChequePrintout.County = _address.County;
                tmpChequePrintout.Street = _address.Street;
                tmpChequePrintout.City = _address.City;
                break;

            case LedgerJournalACType::Ledger:
                tmpChequePrintout.RecipientName = _bankNegInstRecipientName;
                tmpChequePrintout.Address = '';
                tmpChequePrintout.CountryRegionId = '';
                tmpChequePrintout.State = '';
                tmpChequePrintout.County = '';
                tmpChequePrintout.Street = '';
                tmpChequePrintout.City = '';
                break;
        }

        tmpChequePrintout.CompanyCity = this.parmCompanyCity();
        tmpChequePrintout.TransactionRecId = _recId;
        tmpChequePrintout.NumOfSlips = _slipTextCalculator.getNumOfSlips();
        tmpChequePrintout.SlipTop1 = _slipTextCalculator.getSlipTop1();
        tmpChequePrintout.SlipTop2 = _slipTextCalculator.getSlipTop2();

        tmpChequePrintout.ChequeTop = _slipTextCalculator.getChequeTop();
        tmpChequePrintout.ChequeFormType = _chequeFormType;
        tmpChequePrintout.ChequeTopDrop = _slipTextCalculator.getChequeTopDrop();

        tmpChequePrintout.RowNumberPerPage = _slipTextCalculator.getRowNumberPerPage();

        if (_printSignature)
        {
            tmpChequePrintout.Signature1 = NoYes::No;
            tmpChequePrintout.Signature2 = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpChequePrintoutForBank_BR</Name>
				<Source><![CDATA[
    private void initTmpChequePrintoutForBank_BR(BankAccountTable _bankAccountTable, ChequeFormType _chequeFormType)
    {
        LogisticsPostalAddress address;

        address = _bankAccountTable.postalAddress();

        tmpChequePrintout.RecipientName = _bankAccountTable.Name;
        tmpChequePrintout.Address = address.Address;
        tmpChequePrintout.CountryRegionId = address.CountryRegionId;
        tmpChequePrintout.State = address.State;
        tmpChequePrintout.County = address.County;
        tmpChequePrintout.Street = address.Street;
        tmpChequePrintout.City = address.City;

        tmpChequePrintout.CompanyCity = this.parmCompanyCity();
        tmpChequePrintout.ChequeFormType = _chequeFormType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpChequePrintoutForVendor_BR</Name>
				<Source><![CDATA[
    private void initTmpChequePrintoutForVendor_BR(VendTable _vendTable, LogisticsPostalAddress _address, LogisticsLocationEntity _location, ChequeFormType _chequeFormType)
    {
        if (_address)
        {
            tmpChequePrintout.RecipientName = _location ? _location.parmLocationDescription() : '';
        }
        else
        {
            _address = _vendTable.postalAddress();
            tmpChequePrintout.RecipientName = _vendTable.name();
        }

        tmpChequePrintout.Address = _address.Address;
        tmpChequePrintout.CountryRegionId = _address.CountryRegionId;
        tmpChequePrintout.State = _address.State;
        tmpChequePrintout.County = _address.County;
        tmpChequePrintout.Street = _address.Street;
        tmpChequePrintout.City = _address.City;

        tmpChequePrintout.CompanyCity = this.parmCompanyCity();
        tmpChequePrintout.ChequeFormType = _chequeFormType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interval</Name>
				<Source><![CDATA[
    BankChequeNum interval()
    {
        return strFmt('%1..%2', firstChequeNum, chequeNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        numOfBlankCheque = 0;
        createdChequeNumbers = new Set(Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>notesLines</Name>
				<Source><![CDATA[
    Counter notesLines(FreeTxt _paymentNotes)
    {
        int lines =  0;
        int pos = -1;

        while (pos)
        {
            pos = strScan(_paymentNotes, '\n', pos + 1, 255);
            lines++;
        }
        return lines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendChequeSlipTextCalculator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustVendChequeSlipTestCalculator</c> class.
    /// </summary>
    /// <param name = "_bankChequeLayout">The <c>BankChequeLayout</c> table buffer to use for initializing.</param>
    /// <returns>A new instance of the <c>CustVendChequeSlipTestCalculator</c> class.</returns>
    protected CustVendChequeSlipTextCalculator initCustVendChequeSlipTextCalculator(BankChequeLayout _bankChequeLayout)
    {
        return CustVendChequeSlipTextCalculator::construct(_bankChequeLayout);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldResetPaymentNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the Payment Note can be reset.
    /// </summary>
    /// <param name = "_chequeType">The current cheque form type.</param>
    /// <returns>true if the payment note can be reset.</returns>
    protected boolean shouldResetPaymentNotes(ChequeFormType _chequeType)
    {
        return (_chequeType == ChequeFormType::USStyle
            || _chequeType ==  ChequeFormType::ESStyle);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateSlipTextForChequePrinting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the slip text used for cheque printing can be updated.
    /// </summary>
    /// <param name = "_chequeType">The current cheque form type.</param>
    /// <returns>true if the slip text can be updated.</returns>
    protected boolean shouldUpdateSlipTextForChequePrinting(ChequeFormType _chequeType)
    {
        return (_chequeType == ChequeFormType::USStyle
            || _chequeType ==  ChequeFormType::ESStyle);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustSlipTextLinesForAdditionalCheques</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adjusts the slip text lines for additional cheques.
    /// </summary>
    /// <param name = "_slipLines">
    ///     The current slip text lines.
    /// </param>
    /// <returns>
    ///     Adjusted slip text lines.
    /// </returns>
    /// <remarks>
    ///     This method is provided for extensibility.
    /// </remarks>
    protected Counter adjustSlipTextLinesForAdditionalCheques(Counter _slipLines)
    {
        return _slipLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>output</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>TmpChequePrintout</c> table buffer that contains the information that is required to
    /// create the physical check.
    /// </summary>
    /// <param name="_custVendPaym">
    /// A class that contains the transaction information that is needed for the check.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The <c>LedgerJournalACType</c> enumeration value cannot have checks.
    /// </exception>
    public void output(CustVendPaym _custVendPaym)
    {
        BankNegInstRecipientName recipientName;

        VendTable vendTable;
        CustTable custTable;

        Counter endLines;
        Counter notesLines;
        Counter paymentNotesHeaderLinesPrinted;
        Counter i;

        LedgerJournalTrans ledgerJournalTrans = _custVendPaym.ledgerJournalTrans();
        BankAccountTable bankAccountTableCurrent;
        LogisticsLocationEntity location;
        LogisticsPostalAddress address;
        BankChequeNum slipChequeNum;
        List paymentNotesList;
        ListEnumerator le;

        str paymentNotesLine;
        ChequeSlipTxt slipText;

        boolean firstCheque = true;

        changecompany(ledgerJournalTrans.Company)
        {
            switch (ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Vend:
                    vendTable = VendTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension());

                    //Verify if the remittancelocation on the table is still active; if no remittancelocation exists or is invalid then default
                    ledgerJournalTrans.RemittanceLocation = this.setVendorOutputFieldsRemittanceLocation(ledgerJournalTrans, vendTable);

                    //get the vendors remit to address
                    location = this.setVendorOutputFieldsLocation(ledgerJournalTrans);
                    address = this.setVendorOutputFieldsAddress(location, address, ledgerJournalTrans);
                    ledgerJournalTrans.RemittanceAddress = address.RecId;
                    recipientName = this.setVendorOutputFieldsRecipientName(ledgerJournalTrans);
                    break;

                case LedgerJournalACType::Cust:
                    custTable = CustTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension());
                    address = this.setCustomerOutputFieldsAddress(custTable);
                    recipientName = this.setCustomerOutputFieldsRecipientName(address);
                    break;

                case LedgerJournalACType::Bank:
                    bankAccountTableCurrent = this.setBankAccountTableCurrentOutputFields(ledgerJournalTrans);
                    break;

                case LedgerJournalACType::Ledger:
                    this.initLedgerJournalTransLedger(ledgerJournalTrans);
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        BankAccountTable bankAccountTable = BankAccountTable::find(accountId);
        BankChequeLayout bankChequeLayout = BankChequeLayout::find(accountId);

        Currency currency = (bankChequeLayout.OtherCurrencies == NoYes::Yes ?
            Currency::find(ledgerJournalTrans.CurrencyCode) :
            Currency::find(bankAccountTable.CurrencyCode));

        AmountCur amountCur = ledgerJournalTrans.AmountCurDebit - ledgerJournalTrans.AmountCurCredit;

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            AmountCur taxAmount;

            if (ledgerJournalTrans.OffsetLedgerDimension)
            {
                taxAmount = TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(ledgerJournalTrans.ledgerJournalTable().TableId, ledgerJournalTrans.ledgerJournalTable().RecId, ledgerJournalTrans.Voucher, false, '', ledgerjournalTrans.RecId);
            }
            else
            {
                taxAmount = TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(ledgerJournalTrans.ledgerJournalTable().TableId, ledgerJournalTrans.ledgerJournalTable().RecId, ledgerJournalTrans.Voucher, false);
            }

            ledgerJournalTrans.AmountCurDebit += taxAmount;
            amountCur += taxAmount;
        }

        if (TaxWithholdParameters_IN::checkTaxParameters() || TaxParameters::checkTaxParameters_IN())
        {
            //Calculate fee amount for all the lines...attached with that journal line...
            AmountCur feeAmount = this.calculatePaymentFee_IN(ledgerJournalTrans.RecId);
            amountCur += feeAmount;
            ledgerJournalTrans.AmountCurDebit -= feeAmount;
        }

        if (ledgerJournalTrans.BankNegInstRecipientName)
        {
            recipientName = ledgerJournalTrans.BankNegInstRecipientName;
        }

        if (!recipientName && (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust))
        {
            recipientName = ledgerJournalTrans.LedgerDimensionName;
        }

        BankChequeTable::setChequeStatus(
            accountId,
            chequeNum,
            ChequeStatus::Payment,
            ledgerJournalTrans.TransDate,
            ledgerJournalTrans.Voucher,
            CustVendCheque::ledgerJournalACType2RecipientType(ledgerJournalTrans.AccountType),
            ledgerJournalTrans.Company,
            ledgerJournalTrans.parmAccount(),
            ledgerJournalTrans.CurrencyCode,
            amountCur,
            recipientName,
            ledgerJournalTrans.RemittanceAddress,
            ledgerJournalTrans.TableId,
            ledgerJournalTrans.RecId);

        BankChequeTable bankChequeTable = BankChequeTable::find(accountId, chequeNum);
        this.insertBankPaymentTrans(ledgerJournalTrans, _custVendPaym);

        Counter totalBankChequePaymTransLines = this.getInvoiceCount(bankChequeTable);

        CustVendChequeSlipTextCalculator slipTextCalculator = this.initCustVendChequeSlipTextCalculator(bankChequeLayout);

        Counter slipLines = slipTextCalculator.calculateSlipTextLines();

        Counter startLines = 0;
        Counter bankChequePaymTransLines = 0;

        if (slipLines < slipTextCalculator.getMinimumSlipLines(bankChequeLayout.ChequeFormType))
        {
            totalBankChequePaymTransLines = 0;

            if (this.shouldResetPaymentNotes(bankChequeLayout.ChequeFormType))
            {
                ledgerJournalTrans.PaymentNotes = '';
            }
        }

        CustVendPDCRegister custVendPDCRegister;
        select firstonly MaturityDate from custVendPDCRegister
            where custVendPDCRegister.LedgerJournalTrans == ledgerJournalTrans.RecId;

        PDCMaturityDate maturityDate = this.getMaturityDate(custVendPDCRegister.MaturityDate, ledgerJournalTrans);

        while (bankChequePaymTransLines < totalBankChequePaymTransLines || totalBankChequePaymTransLines == 0)
        {
            tmpChequePrintout.clear();
            this.initTmpChequePrintout(
                ledgerJournalTrans.AccountType,
                address,
                location,
                vendTable,
                custTable,
                bankAccountTableCurrent,
                ledgerJournalTrans.BankNegInstRecipientName,
                ledgerJournalTrans.RecId,
                bankChequeLayout.ChequeFormType,
                slipTextCalculator,
                true,
                true);

            if (firstCheque)
            {
                firstCheque = false;

                this.initBankDetails(
                    accountId,
                    bankChequeLayout,
                    bankAccountTable);

                this.setChequeAmount(
                    amountCur,
                    currency,
                    bankChequeLayout,
                    vendTable,
                    custTable);

                this.setSignatures(bankChequeLayout, amountCur);

                slipChequeNum = chequeNum;
            }
            else
            {
                this.setBlankCheque(ledgerJournalTrans);
                tmpChequePrintout.Void = NoYes::Yes;
                tmpChequePrintout.BankCopySignatureText = "@SYS53120";
                tmpChequePrintout.BankCopyCustomWatermark = "@SYS53120";
                tmpChequePrintout.AccountId = accountId;

                slipLines = this.adjustSlipTextLinesForAdditionalCheques(slipLines);
            }

            tmpChequePrintout.ChequeNum = chequeNum;
            tmpChequePrintout.TransDate = ledgerJournalTrans.TransDate;
            tmpChequePrintout.MaturityDate = maturityDate;

            if ((slipTextCalculator.getNumOfSlips() > 0 && bankChequeLayout.ChequeFormType != ChequeFormType::FRStyle)
                || (bankChequeLayout.UseGER == NoYes::Yes && bankChequeLayout.GERNumberOfSlipTxtLines > 0))
            {
                [slipText, bankChequePaymTransLines, endLines] = slipTextCalculator.fillSlipText(
                    bankChequeTable,
                    startLines,
                    slipLines,
                    totalBankChequePaymTransLines,
                    bankChequeLayout.ChequeFormType);

                tmpChequePrintout.SlipTxt = slipText;

                if (this.shouldPrintPaymentNotes(ledgerJournalTrans, bankChequePaymTransLines, totalBankChequePaymTransLines))
                {
                    notesLines = this.notesLines(ledgerJournalTrans.PaymentNotes);

                    if (notesLines <= endLines - 1)
                    {
                        tmpChequePrintout.SlipTxt += this.formatSlipText(ledgerJournalTrans);
                        endLines -= notesLines;
                    }
                    else
                    {
                        if (endLines > 1)
                        {
                            tmpChequePrintout.SlipTxt += strRep('\n', endLines - 1);
                            endLines = 1;
                        }

                        this.insertTmpChequePrintout();
                        tmpChequePrintout.clear();

                        //Printing Payment notes but the payment notes won't fit on one check, spread it out to several checks
                        paymentNotesList = strSplit(ledgerJournalTrans.PaymentNotes, '\n');
                        notesLines = paymentNotesList.elements();
                        le = paymentNotesList.getEnumerator();

                        while (notesLines > 0)
                        {
                            endLines = slipLines;
                            this.initTmpChequePrintout(
                                ledgerJournalTrans.AccountType,
                                address,
                                location,
                                vendTable,
                                custTable,
                                bankAccountTableCurrent,
                                ledgerJournalTrans.BankNegInstRecipientName,
                                ledgerJournalTrans.ledgerJournalTable().RecId,
                                bankChequeLayout.ChequeFormType,
                                slipTextCalculator,
                                false,
                                false);

                            this.setBlankCheque(ledgerJournalTrans);

                            tmpChequePrintout.ChequeNum = chequeNum;
                            tmpChequePrintout.Void = NoYes::Yes;
                            tmpChequePrintout.BankCopySignatureText = "@SYS53120";
                            tmpChequePrintout.BankCopyCustomWatermark = "@SYS53120";
                            tmpChequePrintout.AccountId = accountId;
                            tmpChequePrintout.TransDate = ledgerJournalTrans.TransDate;

                            tmpChequePrintout.MaturityDate = maturityDate;

                            paymentNotesHeaderLinesPrinted = 0;

                            if (this.shouldUpdateSlipTextForChequePrinting(bankChequeLayout.ChequeFormType))
                            {
                                tmpChequePrintout.SlipTxt = strFmt('%1 %2\n\n', "@SYS22495", slipChequeNum);
                                paymentNotesHeaderLinesPrinted = 2;
                                endLines -= 2;
                            }

                            for (i = 0; i < slipLines - paymentNotesHeaderLinesPrinted; i++)
                            {
                                le.moveNext();
                                paymentNotesLine = le.current();

                                tmpChequePrintout.SlipTxt += paymentNotesLine;

                                if (endLines != 1)
                                {
                                    tmpChequePrintout.SlipTxt += '\n';
                                }

                                notesLines--;

                                endLines -= 1;

                                if (notesLines <= 0 || endLines == 0)
                                {
                                    break;
                                }
                            }

                            if (endLines > 1)
                            {
                                tmpChequePrintout.SlipTxt += strRep('\n', endLines - 1);
                                endLines = 1;
                            }

                            this.insertTmpChequePrintout();
                            tmpChequePrintout.SlipTxt = '';

                            if (notesLines <= 0)
                            {
                                return;
                            }
                        }
                    }

                    if (endLines > 1)
                    {
                        tmpChequePrintout.SlipTxt += strRep('\n', endLines - 1);
                        endLines = 1;
                    }
                }
                else
                {
                    if (endLines > 1)
                    {
                        tmpChequePrintout.SlipTxt += strRep('\n', endLines - 1);
                        endLines = 1;
                    }
                }
            }
            else
            {
                totalBankChequePaymTransLines = -1;
            }

            this.insertTmpChequePrintout();
            startLines = bankChequePaymTransLines;

            totalBankChequePaymTransLines = this.getRemainingTotalBankChequePaymentTransLines(totalBankChequePaymTransLines);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingTotalBankChequePaymentTransLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the remaining total bank check payment transaction lines.
    /// </summary>
    /// <param name = "_totalBankChequePaymTransLines">
    /// The current total of remaining bank cheque payment transaction lines.
    /// </param>
    /// <returns>
    /// The total remaining bank check payment transaction lines.
    /// </returns>
    protected int getRemainingTotalBankChequePaymentTransLines(int _totalBankChequePaymTransLines)
    {
        int totalBankChequePaymTransLines = _totalBankChequePaymTransLines;

        if (totalBankChequePaymTransLines == 0)
        {
            totalBankChequePaymTransLines = -1;
        }

        return totalBankChequePaymTransLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTmpChequePrintout</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert row into <c>TmpChequePrintout</c>
    /// </summary>
    protected void insertTmpChequePrintout()
    {
        tmpChequePrintout.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get invoice count.
    /// </summary>
    /// <param name = "_bankChequeTable">The bank check table.</param>
    /// <returns>The invoice count.</returns>
    protected int getInvoiceCount(BankChequeTable _bankChequeTable)
    {
        int totalBankChequePaymTransLines = BankChequePaymTrans::getInvoiceCount(_bankChequeTable.ChequeNum, _bankChequeTable.AccountID);

        return totalBankChequePaymTransLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatSlipText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Formats the slip text.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to pass the transaction data.
    /// </param>
    /// <returns>
    /// The formatted slip text.
    /// </returns>
    protected ChequeSlipTxt formatSlipText(LedgerJournalTrans _ledgerJournalTrans)
    {
        return strFmt('\n%1', _ledgerJournalTrans.PaymentNotes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPrintPaymentNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should print payment notes.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The payment.</param>
    /// <param name = "_bankChequePaymTransLines">The current count of bank payment transactions.</param>
    /// <param name = "_totalBankChequePaymTransLines">The total count of bank payment transactions.</param>
    /// <returns>True when payment notes should be printed; otherwise false.</returns>
    protected boolean shouldPrintPaymentNotes(LedgerJournalTrans _ledgerJournalTrans, Counter _bankChequePaymTransLines, Counter _totalBankChequePaymTransLines)
    {
        return (_ledgerJournalTrans.PaymentNotes && _bankChequePaymTransLines == _totalBankChequePaymTransLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>output_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>TmpChequePrintout</c> table buffer that contains the information that is required to
    /// create the physical check.
    /// </summary>
    /// <param name="_oneVoucher">
    /// A class that represents the single check and contains the related transactions
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The <c>LedgerJournalACType</c> enumeration value cannot have checks.
    /// </exception>
    void output_BR(OneVoucher_BR _oneVoucher)
    {
        VendTable vendTable;
        CustTable custTable;
        BankAccountTable bankAccountTable;
        BankChequeLayout bankChequeLayout;
        BankNegInstRecipientName recipientName;
        Currency currency;
        AmountCur amountCur;
        LogisticsLocationEntity location;
        LogisticsPostalAddress address;
        RemittanceLocation remittanceLocation;

        changecompany(_oneVoucher.parmCompany())
        {
            switch (_oneVoucher.parmAccountType())
            {
                case LedgerJournalACType::Vend:
                    vendTable = VendTable::findByLedgerDimension(_oneVoucher.parmLedgerDimension());

                    //Verify if the remittancelocation on the table is still active; if no remittancelocation exists or is invalid then default
                    remittanceLocation = LogisticsLocation::isLocationActive(
                        _oneVoucher.parmRemittanceLocation())?
                        _oneVoucher.parmRemittanceLocation() : VendTable::getDefaultRemittanceLocation(vendTable.AccountNum);

                    //get the vendors remit to address
                    location = LogisticsLocationEntity::constructFromLocationRecId(remittanceLocation);
                    address = location ? LogisticsLocationEntity::location2PostalAddress(location.parmLocationRecId(), DateTimeUtil::getSystemDateTime(), true) : address;
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        bankAccountTable = BankAccountTable::find(accountId);
        bankChequeLayout = BankChequeLayout::find(accountId);

        if (bankChequeLayout.OtherCurrencies)
        {
            currency = Currency::find(_oneVoucher.parmCurrencyCode());
        }
        else
        {
            currency = Currency::find(bankAccountTable.CurrencyCode);
        }

        amountCur = _oneVoucher.parmAmountCurDebit() - _oneVoucher.parmAmountCurCredit();

        if (_oneVoucher.parmPostingLevel() == Posting_BR::Bank)
        {
            recipientName = bankAccountTable.Name;
        }
        else if (_oneVoucher.parmPostingLevel() == Posting_BR::Vendor)
        {
            recipientName = vendTable.name();
        }

        LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findJournalForVoucher(_oneVoucher.parmVoucher(), _oneVoucher.parmTransDate());
        BankChequeTable::setChequeStatus(
            accountId,
            chequeNum,
            ChequeStatus::Payment,
            _oneVoucher.parmTransDate(),
            _oneVoucher.parmVoucher(),
            CustVendCheque::ledgerJournalACType2RecipientType(_oneVoucher.parmAccountType()),
            _oneVoucher.parmCompany(),
            _oneVoucher.parmAccount(),
            _oneVoucher.parmCurrencyCode(),
            _oneVoucher.parmAmountCurDebit(),
            recipientName,
            address.RecId,
            ledgerJournalTrans.TableId,
            ledgerJournalTrans.RecId);

        delete_from tmpChequePrintout;

        tmpChequePrintout.clear();

        if (_oneVoucher.parmPostingLevel() == Posting_BR::Bank)
        {
            this.initTmpChequePrintoutForBank_BR(bankAccountTable, bankChequeLayout.ChequeFormType);
        }
        else if (_oneVoucher.parmPostingLevel() == Posting_BR::Vendor)
        {
            this.initTmpChequePrintoutForVendor_BR(vendTable, address, location, bankChequeLayout.ChequeFormType);
        }

        tmpChequePrintout.ChequeNum = chequeNum;

        this.initBankDetails(
            accountId,
            bankChequeLayout,
            bankAccountTable);

        this.setChequeAmount(
            amountCur,
            currency,
            bankChequeLayout,
            vendTable,
            custTable);

        if (bankChequeLayout.Signature1)
        {
            if (!bankChequeLayout.Signature1Limit)
            {
                tmpChequePrintout.Signature1 = NoYes::Yes;
            }
            else
            {
                tmpChequePrintout.Signature1 = bankChequeLayout.Signature1Limit >= amountCur ? NoYes::Yes : NoYes::No;
            }
        }

        if (bankChequeLayout.Signature2)
        {
            if (!bankChequeLayout.Signature2Limit)
            {
                tmpChequePrintout.Signature2 = NoYes::Yes;
            }
            else
            {
                tmpChequePrintout.Signature2 = bankChequeLayout.Signature2Limit >= amountCur ? NoYes::Yes : NoYes::No;
            }
        }

        tmpChequePrintout.TransDate = _oneVoucher.parmTransDate();

        this.fillBankChequePaymentTrans_BR(_oneVoucher);

        this.insertTmpChequePrintout();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountId</Name>
				<Source><![CDATA[
    public CompanyBankAccountId parmAccountId(CompanyBankAccountId _accountId = accountId)
    {
        accountId = _accountId;

        return accountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChequeNumMethod</Name>
				<Source><![CDATA[
    public ChequeNumMethod parmChequeNumMethod(ChequeNumMethod _chequeNumMethod = chequeNumMethod)
    {
        chequeNumMethod = _chequeNumMethod;

        return chequeNumMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompanyCity</Name>
				<Source><![CDATA[
    public CompanyCity parmCompanyCity(CompanyCity _companyCity = companyCity)
    {
        companyCity = _companyCity;
        return companyCity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFirstChequeNum</Name>
				<Source><![CDATA[
    public BankChequeStartNum parmFirstChequeNum(BankChequeStartNum _firstChequeNum = firstChequeNum)
    {
        firstChequeNum = _firstChequeNum;

        return firstChequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalACType</Name>
				<Source><![CDATA[
    public LedgerJournalACType parmLedgerJournalACType(LedgerJournalACType _ledgerJournalACType = ledgerJournalACType)
    {
        ledgerJournalACType = _ledgerJournalACType;

        if (ledgerJournalACType != LedgerJournalACType::Vend
            && ledgerJournalACType != LedgerJournalACType::Cust
            && ledgerJournalACType != LedgerJournalACType::Bank
            && ledgerJournalACType != LedgerJournalACType::Ledger)
        {
            throw error(strFmt("@SYS89876", "@SYS302", "@SYS8079"));
        }

        return ledgerJournalACType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumOfBlankCheque</Name>
				<Source><![CDATA[
    public BankChequeQty parmNumOfBlankCheque(BankChequeQty _numOfBlankCheque = numOfBlankCheque)
    {
        numOfBlankCheque = _numOfBlankCheque;

        return numOfBlankCheque;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processChequeNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>BankChequeTable</c> table update
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <returns>
    /// The identification of the bank check.
    /// </returns>
    BankChequeNum processChequeNum(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (numOfBlankCheque > 0)
        {
            this.setBlankCheque(_ledgerJournalTrans, numOfBlankCheque);
            numOfBlankCheque = 0;
        }

        this.generateChequeNumForProcessChequeNum();
        this.setPaymentRef(chequeNum, _ledgerJournalTrans);

        return chequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateChequeNumForProcessChequeNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates cheque number.
    /// </summary>
    /// <param name = "_useDefaultChequeNum">
    ///     A boolean flag to use default cheque number; optional.
    /// </param>
    protected void generateChequeNumForProcessChequeNum(boolean _useDefaultChequeNum = true)
    {
        if(_useDefaultChequeNum)
        {
            this.chequeNum();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processChequeNum_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>BankChequeTable</c> table update
    /// </summary>
    /// <param name="_oneVoucher">
    /// OneVoucher_BR object instance.
    /// </param>
    /// <returns>
    /// The identification of the bank check.
    /// </returns>
    public BankChequeNum processChequeNum_BR(OneVoucher_BR _oneVoucher)
    {
        if (numOfBlankCheque > 0)
        {
            this.setBlankCheque_BR(_oneVoucher, numOfBlankCheque);
            numOfBlankCheque = 0;
        }

        this.chequeNum();
        this.setPaymentRef_BR(chequeNum, _oneVoucher);

        return chequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBlankCheque</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes process to update <c>BankChequeTable</c> table.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <param name="_blankCheques">
    /// Interaction counter
    /// </param>
    /// <exception cref="Exception::Error">
    /// When cheque status is not created.
    /// </exception>
    void setBlankCheque(
        LedgerJournalTrans _ledgerJournalTrans,
        BankChequeQty _blankCheques = 1)
    {
        BankChequeNum chequeNumToBlank;

        this.createAndSetBlankCheques(_ledgerJournalTrans.CurrencyCode, _ledgerJournalTrans.TransDate, _blankCheques);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndSetBlankCheques</Name>
				<Source><![CDATA[
    internal void createAndSetBlankCheques(CurrencyCode _currencyCode, TransDate _blankChequeDate, BankChequeQty _numberOfBlankCheques)
    {
        BankChequeNum chequeNumToBlank;
        BankChequeQty numberOfBlankChequesLocal = _numberOfBlankCheques;

        while (numberOfBlankChequesLocal > 0)
        {
            chequeNumToBlank = this.chequeNum();

            if (BankChequeTable::find(accountId, chequeNumToBlank).ChequeStatus == ChequeStatus::Created)
            {
                BankChequeTable::setChequeStatus(
                    accountId,
                    chequeNumToBlank,
                    ChequeStatus::NotPrinted,
                    _blankChequeDate,
                    '',
                    BankChequeRecipientType::Unknown,
                    '',
                    '',
                    _currencyCode,
                    0,
                    '');

                BankChequeTable::clearChequeRecipientNameAndAddress(accountId, chequeNumToBlank);
            }
            else
            {
                // Set variable back since it was incremented in call this.chequeNum()
                this.setNextChequeNum(this.getNextChequeNum() - 1);
                throw error(strFmt("@SYS100216", chequeNumToBlank));
            }

            numberOfBlankChequesLocal--;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBlankCheque_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes process to update <c>BankChequeTable</c> table.
    /// </summary>
    /// <param name="_oneVoucher">
    /// OneVoucher_BR object instance.
    /// </param>
    /// <param name="_blankCheques">
    /// Interaction counter
    /// </param>
    /// <exception cref="Exception::Error">
    /// When cheque status is not created.
    /// </exception>
    public void setBlankCheque_BR(OneVoucher_BR _oneVoucher, BankChequeQty _blankCheques = 1)
    {
        BankChequeNum chequeNumToBlank;

        while (_blankCheques > 0)
        {
            chequeNumToBlank = this.chequeNum();

            if (BankChequeTable::find(accountId, chequeNumToBlank).ChequeStatus == ChequeStatus::Created)
            {
                BankChequeTable::setChequeStatus(
                    accountId,
                    chequeNumToBlank,
                    ChequeStatus::NotPrinted,
                    _oneVoucher.parmTransDate(),
                    '',
                    BankChequeRecipientType::Unknown,
                    '',
                    '',
                    _oneVoucher.parmCurrencyCode(),
                    0,
                    '');
            }
            else
            {
                // Set variable back since it was incremented in call this.chequeNum()
                this.setNextChequeNum(this.getNextChequeNum() - 1);;
                throw error(strFmt("@SYS100216", chequeNumToBlank));
            }

            _blankCheques--;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChequeAmount</Name>
				<Source><![CDATA[
    protected void setChequeAmount(
        AmountCur _amountCur,
        Currency _currency,
        BankChequeLayout _bankChequeLayout,
        VendTable _vendTable,
        CustTable _custTable)
    {
        tmpChequePrintout.AmountCur = _amountCur;
        tmpChequePrintout.Numerals2Letter = _amountCur != 0 ? numeralsToTxt(_amountCur) : '';
        tmpChequePrintout.CurrencyTxt = _currency.Txt;
        tmpChequePrintout.CurrencyCode = _currency.CurrencyCode;

        if (BrazilParameters::isEnabled() && _bankChequeLayout.ChequeFormType)
        {
            tmpChequePrintout.Numerals2Letter = strFmt('***%1***', Global::numeralsToTxt_BR(tmpChequePrintout.AmountCur));
        }

        // setting the currency text format.
        tmpChequePrintout.setChequeAmount(
            _amountCur,
            _bankChequeLayout.ChequeFormType,
            _currency,
            _bankChequeLayout,
            _vendTable,
            _custTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChequeNum</Name>
				<Source><![CDATA[
    private void setChequeNum()
    {
        BankChequeTable bankChequeTable;

        switch (chequeNumMethod)
        {
            case ChequeNumMethod::Free:
                select maxof(ChequeNum) from bankChequeTable
                    where bankChequeTable.AccountID == accountId;

                firstChequeNum = NumberSeq::numRemoveFormat(bankChequeTable.ChequeNum, '') + 1;
                break;

            case ChequeNumMethod::Fixed:
                firstChequeNum = NumberSeq::numRemoveFormat(BankChequeTable::findNextFree(accountId), '');
                if (!firstChequeNum)
                {
                    throw error(strFmt("@SYS28696", accountId));
                }
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value in PaymReference and BankChequeNum fields of <c>LedgerJournalTrans</c>
    /// </summary>
    /// <param name="_bankChequeNum">
    /// Value to set PaymReference and BankChequeNum
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    void setPaymentRef(BankChequeNum _bankChequeNum, LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.PaymReference = _bankChequeNum;
        _ledgerJournalTrans.BankChequeNum = _bankChequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentRef_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value in PaymReference and BankChequeNum fields of <c>LedgerJournalTrans</c>
    /// </summary>
    /// <param name="_bankChequeNum">
    /// Value to set PaymReference and BankChequeNum
    /// </param>
    /// <param name="_oneVoucher">
    /// ChequeOneVoucher_BR object to be updated.
    /// </param>
    void setPaymentRef_BR(BankChequeNum _bankChequeNum, ChequeOneVoucher_BR _oneVoucher)
    {
        _oneVoucher.parmPaymReference(_bankChequeNum);
        _oneVoucher.parmBankChequeNum(_bankChequeNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSignatures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the signatures boolean values.
    /// </summary>
    /// <param name="_bankChequeLayout">
    /// A record of <c>BankChequeLayout</c> table.
    /// </param>
    /// <param name="_amountCur">
    /// An amount value which is used to check whether signatures should be set or not.
    /// </param>
    protected void setSignatures(BankChequeLayout _bankChequeLayout, AmountCur _amountCur)
    {
        if (_bankChequeLayout.Signature1)
        {
            if (!_bankChequeLayout.Signature1Limit)
            {
                tmpChequePrintout.Signature1 = NoYes::Yes;
            }
            else
            {
                tmpChequePrintout.Signature1 = _bankChequeLayout.Signature1Limit >= _amountCur ? NoYes::Yes : NoYes::No;
            }
        }

        if (_bankChequeLayout.Signature2)
        {
            if (!_bankChequeLayout.Signature2Limit)
            {
                tmpChequePrintout.Signature2 = NoYes::Yes;
            }
            else
            {
                tmpChequePrintout.Signature2 = _bankChequeLayout.Signature2Limit >= _amountCur ? NoYes::Yes : NoYes::No;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTransLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the ledger.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    protected void initLedgerJournalTransLedger(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBankAccountTableCurrentOutputFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the bank account table.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <returns>
    /// The bank account table.
    /// </returns>
    protected BankAccountTable setBankAccountTableCurrentOutputFields(LedgerJournalTrans _ledgerJournalTrans)
    {
        return BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerOutputFieldsAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the customer address field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <returns>
    /// The customer address.
    /// </returns>
    protected LogisticsPostalAddress setCustomerOutputFieldsAddress(CustTable _custTable)
    {
        return _custTable.postalAddress();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerOutputFieldsRecipientName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the customer recipient name.
    /// </summary>
    /// <param name="_logisticsPostalAddress">
    /// <c>LogisticsPostalAddress</c> record to be updated.
    /// </param>
    /// <returns>
    /// The customer recipient name.
    /// </returns>
    protected BankNegInstRecipientName setCustomerOutputFieldsRecipientName(LogisticsPostalAddress _logisticsPostalAddress)
    {
        return LogisticsLocation::locationNameFromRecId(_logisticsPostalAddress.Location);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendorOutputFieldsLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the vendor location field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <returns>
    /// The vendor location.
    /// </returns>
    protected LogisticsLocationEntity setVendorOutputFieldsLocation(LedgerJournalTrans _ledgerJournalTrans)
    {
        return LogisticsLocationEntity::constructFromLocationRecId(_ledgerJournalTrans.RemittanceLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendorOutputFieldsAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the vendor address field.
    /// </summary>
    /// <param name="_location">
    /// <c>LogisticsLocationEntity</c> record.
    /// </param>
    /// <param name="_address">
    /// <c>LogisticsPostalAddress</c> record.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The vendor address.
    /// </returns>
    protected LogisticsPostalAddress setVendorOutputFieldsAddress(LogisticsLocationEntity _location, LogisticsPostalAddress _address, LedgerJournalTrans _ledgerJournalTrans)
    {
        return _location ? LogisticsLocationEntity::location2PostalAddress(_location.parmLocationRecId(), DateTimeUtil::getSystemDateTime(), true) : _address;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendorOutputFieldsRecipientName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the vendor recipient name field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <returns>
    /// The vendor recipient name.
    /// </returns>
    protected BankNegInstRecipientName setVendorOutputFieldsRecipientName(LedgerJournalTrans _ledgerJournalTrans)
    {
        return LogisticsLocation::locationNameFromRecId(_ledgerJournalTrans.RemittanceLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendorOutputFieldsRemittanceLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets value for the vendor remittance location field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <param name="_vendTable">
    /// <c>VendTable</c> record to be updated.
    /// </param>
    /// <returns>
    /// The vendor remittance location.
    /// </returns>
    protected RemittanceLocation setVendorOutputFieldsRemittanceLocation(LedgerJournalTrans _ledgerJournalTrans, VendTable _vendTable)
    {
        return LogisticsLocation::isLocationActive(_ledgerJournalTrans.RemittanceLocation) ?
                        _ledgerJournalTrans.RemittanceLocation : VendTable::getDefaultRemittanceLocation(_vendTable.AccountNum, _vendTable.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldBlockOverride_BR</Name>
				<Source><![CDATA[
    public NoYes shouldBlockOverride_BR()
    {
        PrintMgmtPrintContext printContext;
        PrintMgmtNodeInstance nodeInstance = new PrintMgmtNodeInstance();
        PrintMgmtPrintSetting printSetting;

        BankChequeTable bankChequeTable;

        nodeInstance.parmNodeDefinition(PrintMgmtNode::construct(PrintMgmtNodeType::Sales));
        nodeInstance.parmReferencedTableBuffer(null);

        //There isn't real data in this record
        bankChequeTable.setTmp();
        bankChequeTable.insert();

        if (!nodeInstance.isValidReference())
        {
            return false;
        }

        printSetting = new PrintMgmtPrintSetting();
        printContext = new PrintMgmtPrintContext();

        printContext.parmDefaultOriginalPrintJobSettings(new SRSPrintDestinationSettings());
        printContext.parmDefaultCopyPrintJobSettings(new SRSPrintDestinationSettings());
        printContext.parmLanguageId(CompanyInfo::find().LanguageId);
        printContext.parmQueryTableBuffer(bankChequeTable);
        printContext.parmForcePrintJobSettings(true);

        printContext.setHierarchyContext(
            PrintMgmtHierarchyType::Bank,
            PrintMgmtNodeType::Bank,
            PrintMgmtDocumentType::BankCheque,
            null);

        printSetting = PrintMgmt::getSettings(printContext);

        return printSetting.parmBlockOverride_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpChequePrintout</Name>
				<Source><![CDATA[
    TmpChequePrintout tmpChequePrintout()
    {
        return tmpChequePrintout;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalACType2RecipientType</Name>
				<Source><![CDATA[
    public static BankChequeRecipientType ledgerJournalACType2RecipientType(LedgerJournalACType _ledgerJournalACType)
    {
        BankChequeRecipientType bankChequeRecipientType;

        switch (_ledgerJournalACType)
        {
            case LedgerJournalACType::Vend:
                bankChequeRecipientType = BankChequeRecipientType::Vend;
                break;

            case LedgerJournalACType::Cust:
                bankChequeRecipientType = BankChequeRecipientType::Cust;
                break;

            case LedgerJournalACType::Bank:
                bankChequeRecipientType = BankChequeRecipientType::Bank;
                break;

            case LedgerJournalACType::Ledger:
                bankChequeRecipientType = BankChequeRecipientType::Ledger;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return bankChequeRecipientType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintJobSettingsPacked</Name>
				<Source><![CDATA[
    public PrintJobSettingsPacked parmPrintJobSettingsPacked(PrintJobSettingsPacked _printJobSettingsPacked = printJobSettingsPacked)
    {
        printJobSettingsPacked = _printJobSettingsPacked;

        return printJobSettingsPacked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankChequePaymentTransFromVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values from the <c>VendTrans</c> table buffer to <c>BankChequePaymTrans</c> table buffer.
    /// </summary>
    /// <param name = "_specTrans">The <c>SpecTrans</c> table buffer instance.</param>
    /// <param name = "_custVendPaym">The <c>CustVendPaym</c> table buffer instance.</param>
    /// <param name = "_paymAmount">The payment amount.</param>
    /// <returns>The initialized <c>BankChequePaymTrans</c> table buffer.</returns>
    protected BankChequePaymTrans initBankChequePaymentTransFromVendTrans(SpecTrans _specTrans, CustVendPaym _custVendPaym, AmountCur _paymAmount)
    {
        BankChequePaymTrans bankChequePaymTrans;

        VendTrans vendTrans = _specTrans.vendTrans();

        BankChequeLayout bankChequeLayout = BankChequeLayout::find(accountId);

        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(
                Ledger::primaryLedger(CompanyInfo::findDataArea(_custVendPaym.ledgerJournalTrans().Company).RecId),
                _custVendPaym.ledgerJournalTrans().CurrencyCode);

        bankChequePaymTrans.clear();
        bankChequePaymTrans.AccountId = accountId;
        bankChequePaymTrans.ChequeNum = chequeNum;
        bankChequePaymTrans.RecipientType = BankChequeRecipientType::Vend;
        bankChequePaymTrans.RecipientAccountNum = _custVendPaym.ledgerJournalTrans().parmAccount();
        bankChequePaymTrans.RecipientCompany = _custVendPaym.ledgerJournalTrans().Company;
        bankChequePaymTrans.Voucher = _custVendPaym.ledgerJournalTrans().Voucher;
        bankChequePaymTrans.TransDate = _custVendPaym.ledgerJournalTrans().TransDate;

        bankChequePaymTrans.InvoiceAmountCur = vendTrans.AmountCur;

        bankChequePaymTrans.CashDiscAmountCur = this.convertAmountTransCurToAmountPaymCur(          
            _specTrans.CashDiscToTake,
            vendTrans.company(),
            vendTrans.CurrencyCode,
            _custVendPaym.ledgerJournalTrans().Company,
            _custVendPaym.ledgerJournalTrans().CurrencyCode,
            _custVendPaym.ledgerJournalTrans().TransDate,
            _specTrans.CrossRate,
            exchangeRateHelper.prepareExchangeRateForStorage(_custVendPaym.ledgerJournalTrans().crossrate()));

        bankChequePaymTrans.PaymentAmountCur = this.convertAmountTransCurToAmountPaymCur(
            _paymAmount,
            vendTrans.company(),
            vendTrans.CurrencyCode,
            _custVendPaym.ledgerJournalTrans().Company,
            _custVendPaym.ledgerJournalTrans().CurrencyCode,
            _custVendPaym.ledgerJournalTrans().TransDate,
            _specTrans.CrossRate,
            exchangeRateHelper.prepareExchangeRateForStorage(_custVendPaym.ledgerJournalTrans().crossrate()));

        bankChequePaymTrans.CurrencyCode = vendTrans.CurrencyCode;

        bankChequePaymTrans.InvoiceId = vendTrans.Invoice;
        bankChequePaymTrans.InvoiceDate = vendTrans.documentInvoiceDate();
        bankChequePaymTrans.InvoiceTransDate = vendTrans.TransDate;
        bankChequePaymTrans.InvoiceVoucher = vendTrans.Voucher;
        bankChequePaymTrans.InvoiceCompany = vendTrans.DataAreaId;
        bankChequePaymTrans.InvoiceAccountNum = vendTrans.AccountNum;
        bankChequePaymTrans.VendPaymentGroup = vendTrans.VendPaymentGroup;
        bankChequePaymTrans.RemittanceAddress = _custVendPaym.ledgerJournalTrans().RemittanceAddress;

        return bankChequePaymTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankChequePaymentTransFromCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values from <c>CustTrans</c> table to <c>BankChequePaymTrans</c> table buffer.
    /// </summary>
    /// <param name = "_specTrans">The <c>SpecTrans</c> table buffer instance.</param>
    /// <param name = "_custVendPaym">The <c>CustVendPaym</c> table buffer instance.</param>
    /// <param name = "_paymAmount">The payment amount.</param>
    /// <returns>The initialized <c>BankChequePaymTrans</c> table buffer.</returns>
    protected BankChequePaymTrans initBankChequePaymentTransFromCustTrans(SpecTrans _specTrans, CustVendPaym _custVendPaym, AmountCur _paymAmount)
    {
        BankChequePaymTrans bankChequePaymTrans;

        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(
                Ledger::primaryLedger(CompanyInfo::findDataArea(_custVendPaym.ledgerJournalTrans().Company).RecId),
                _custVendPaym.ledgerJournalTrans().CurrencyCode);

        CustTrans custTrans = _specTrans.custTrans();
        bankChequePaymTrans.clear();
        bankChequePaymTrans.AccountId = accountId;
        bankChequePaymTrans.ChequeNum = chequeNum;
        bankChequePaymTrans.RecipientType = BankChequeRecipientType::Cust;
        bankChequePaymTrans.RecipientCompany = _custVendPaym.ledgerJournalTrans().Company;
        bankChequePaymTrans.RecipientAccountNum = _custVendPaym.ledgerJournalTrans().parmAccount();
        bankChequePaymTrans.Voucher = _custVendPaym.ledgerJournalTrans().Voucher;
        bankChequePaymTrans.TransDate = _custVendPaym.ledgerJournalTrans().TransDate;
        bankChequePaymTrans.CurrencyCode = custTrans.CurrencyCode;
        bankChequePaymTrans.InvoiceId = custTrans.Invoice;
        bankChequePaymTrans.InvoiceDate = custTrans.DocumentDate ? custTrans.DocumentDate : custTrans.TransDate;
        bankChequePaymTrans.InvoiceTransDate = custTrans.TransDate;
        bankChequePaymTrans.InvoiceVoucher = custTrans.Voucher;
        bankChequePaymTrans.InvoiceCompany = custTrans.DataAreaId;
        bankChequePaymTrans.InvoiceAccountNum = custTrans.AccountNum;
        bankChequePaymTrans.InvoiceAmountCur = custTrans.AmountCur;

        bankChequePaymTrans.CashDiscAmountCur = this.convertAmountTransCurToAmountPaymCur(  
            _specTrans.CashDiscToTake,
            custTrans.company(),
            custTrans.CurrencyCode,
            _custVendPaym.ledgerJournalTrans().Company,
            _custVendPaym.ledgerJournalTrans().CurrencyCode,
            _custVendPaym.ledgerJournalTrans().TransDate,
            _specTrans.CrossRate,
            exchangeRateHelper.prepareExchangeRateForStorage(_custVendPaym.ledgerJournalTrans().crossrate()));

        bankChequePaymTrans.PaymentAmountCur = this.convertAmountTransCurToAmountPaymCur(
            _paymAmount,
            custTrans.company(),
            custTrans.CurrencyCode,
            _custVendPaym.ledgerJournalTrans().Company,
            _custVendPaym.ledgerJournalTrans().CurrencyCode,
            _custVendPaym.ledgerJournalTrans().TransDate,
            _specTrans.CrossRate,
            exchangeRateHelper.prepareExchangeRateForStorage(_custVendPaym.ledgerJournalTrans().crossrate()));

        return bankChequePaymTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFreeChequeNumber</Name>
				<Source><![CDATA[
    internal boolean validateFreeChequeNumber(BankCheckNumCreated _inputCheckNum)
    {
        NoYes enableCheckNumberValidation = BankParameters::find().CheckNumberValidation;
        if (FeatureStateProvider::isFeatureEnabled(BankChequeSequenceValidationFeature::instance()) && enableCheckNumberValidation && this.chequeNumMethod == ChequeNumMethod::Free)
        {
            return this.validateFreeChequeNumberIntervalAndInt(_inputCheckNum);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFreeChequeNumberIntervalAndInt</Name>
				<Source><![CDATA[
    private boolean validateFreeChequeNumberIntervalAndInt(BankCheckNumCreated _inputCheckNum)
    {
        BankChequeNum lastChequeNum = BankChequeTable::findLastChequeNum(accountId);
        BankChequeQty checkNumberInterval = BankParameters::find().CheckNumberInterval;
        boolean isValid = isInteger(_inputCheckNum);

        if (isValid && isInteger(lastChequeNum) && checkNumberInterval >= 1)
        {
            int distance = str2Int(_inputCheckNum) - str2Int(lastChequeNum);
            isValid = distance <= checkNumberInterval;
        }

        return isValid || Box::yesNo(strFmt("@CashManagement:BankChequeNumConfirm", lastChequeNum), DialogButton::No) == DialogButton::Yes;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>