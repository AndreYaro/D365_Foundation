<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>IntrastatTransfer</Name>
	<SourceCode>
		<Declaration><![CDATA[
class IntrastatTransfer extends RunBaseBatch implements BatchRetryable
{
    private const str FeatureReferenceEUR00002 = GlobalizationConstants::FeatureReferenceEUR00002;

    DialogRunbase   dialog;
    DialogField     dialogFreeTextInvoice;
    DialogField     dialogCustInvoice;
    DialogField     dialogCustPckSlp;
    DialogField     dialogVendInvoice;
    DialogField     dialogVendPckSlp;
    DialogField     dialogProjInvoice;
    DialogField     dialogInventTransfer;

    DialogField     dialogCustInvoicePrev;
    DialogField     dialogCustPckSlpPrev;
    DialogField     dialogVendInvoicePrev;
    DialogField     dialogVendPckSlpPrev;
    DialogField     dialogProjInvoicePrev;

    SysQueryRun     qeIntrastatTransfer;
    QueryRun        queryRunIntrastatTransfer;

    NoYes           freeTextInvoice;
    NoYes           custInvoice;
    NoYes           custPckSlp;
    NoYes           vendInvoice;
    NoYes           vendPckSlp;
    NoYes           projInvoice;
    NoYes           inventTransfer;

    NoYes           overwrite;

    TransDate       fromDate;
    TransDate       toDate;

    #DEFINE.CurrentVersion(7)
    #LOCALMACRO.CurrentList
        freeTextInvoice,
        CustInvoice,
        CustPckSlp,
        VendInvoice,
        VendPckSlp,
        ProjInvoice,
        inventTransfer
    #ENDMACRO

    NumberSeq       numberseqExport;
    NumberSeq       numberseqImport;
    Num             numberExport;
    Num             numberImport;

    Map             custInvoiceTotalMap;
    Map             vendInvoiceTotalMap;

    IntrastatParameters     intrastatParm;

    boolean isLegalEntityInEEU;

    private boolean isLegalEntityInLV;

    //error message, strictly used only for exch rate error
    str                     exchRateErrMsg;
    #ISOCountryRegionCodes

    real invoicePackingSlipFactor;

    //these are used in the main class logic - transferring the data from source to Intrastat table
    CustInvoiceJour         custInvoiceJourRun;
    CustPackingSlipJour     custPackingSlipJourRun;
    VendInvoiceJour         vendInvoiceJourRun;
    VendPackingSlipJour     vendPackingSlipJourRun;
    ProjInvoiceJour         projInvoiceJourRun;
    InventTransferJour      inventTransferJourRun;

    private RefRecId custInvoiceJourRunLastRecId;
    private RefRecId custPackingSlipJourRunLastRecId;
    private RefRecId vendInvoiceJourRunLastRecId;
    private RefRecId vendPackingSlipJourRunLastRecId;
    private RefRecId projInvoiceJourRunLastRecId;
    private RefRecId inventTransferJourRunLastRecId;

    private RefRecId shipmentAddressRecIdBuffer;

    Map isInEUMap;
    Map vendAccountCountryRegionIdMap;

    protected Map countryRegionStateIsInEUCache;
    protected LogisticsPostalAddress deliveryPostalAddress;
    protected LogisticsPostalAddress invoicePostalAddress;
    protected LogisticsPostalAddress transportDocumentPostalAddress;
    protected LogisticsAddressStateId stateIdOfShipment;

    private Map logisticsPostalAddressCache;
    private Map primaryPostalAddressCache;
    private Map shipmentPostalAddressCache;
    private Map vendAccountFromInventLocationCache;
    private Map isDomesticCache;
    private Map isSpecialDomesticCache;
    private Map taxRegistrationValueCache;

    private System.Diagnostics.Stopwatch stopwatch;

    private const str outcomeMsg = 'The percentage of processed trans from FreeTextCustInvoiceJours of the total number: %1%, of which got into Intrastat %2%\n'
        + 'The percentage of processed trans from CustInvoiceJours of the total number: %3%, of which got into Intrastat %4%\n'
        + 'The percentage of processed trans from CustPckSlpJours of the total number: %5%, of which got into Intrastat %6%\n'
        + 'The percentage of processed lines from InventTransferJours of the total number: %7%, of which got into Intrastat %8%\n'
        + 'The percentage of processed items from ProjInvoiceJours of the total number: %9%, of which got into Intrastat %10%\n'
        + 'The percentage of processed items from VendInvoiceJours of the total number: %11%, of which got into Intrastat %12%\n'
        + 'The percentage of processed VenInvoiceJours of the total number: %13%, of which matches with VendInvoiceIntrastat and got into the Intrastat %14%\n'
        + 'The percentage of processed items from VendPckSlpJours of the total number: %15%, of which got into Intrastat %16%';

    private int freeTextCustInvoiceTransCounter = 0;
    private int freeTextCustInvoiceTransToTransferCounter = 0;
 
    private int custInvoiceTransCounter = 0;
    private int custInvoiceTransToTransferCounter = 0;

    private int custPckSlpTransCounter = 0;
    private int custPckSlpTransToTransferCounter = 0;

    private int inventTransferJourLinesCounter = 0;
    private int inventTransferJourLinesToTransferCounter = 0;

    private int projInvoiceItemsCounter = 0;
    private int projInvoiceItemsToTransferCounter = 0;

    private int vendInvoiceTransCounter = 0;
    private int vendInvoiceTransToTransferCounter = 0;

    private int vendInvoiceJoursMatchedToVendInvoiceIntrastatCounter = 0;
    private int vendInvoiceIntrastatToTransferCounter = 0;

    private int vendPckSlpTransCounter = 0;
    private int vendPckSlpTransToTransferCounter = 0;

    private int totalToTransferCounter;
    private int totalTransCounter;

    private boolean runTransferNotInInclusiveTransaction = FeatureStateProvider::isFeatureEnabled(RunTransferNotInInclusiveTransactionFeature::instance());

    protected readonly LogisticsPostalAddress primaryPostalAddressForCurrentCompany;

    private PackingSlipId lastPackingSlipId;
    private TableId lastPackingSlipTableId;
    private RefRecId lastPackingSlipRecId;
    private InventTable lastInventTable;
    private CustTable lastCustTable;
    private VendTable lastVendTable;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static IntrastatTransfer construct()
    {
        return SysExtensionAppClassFactory::getClassFromSysAttribute(
            classStr(IntrastatTransfer),
            new IntrastatCountryRegionAttribute(SysCountryRegionCode::countryInfo()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS323";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        if (args && args.dataset() == tableNum(Intrastat))
        {
            IntrastatTransfer intrastatTransfer = IntrastatTransfer::construct();
            FormDataSource intrastat_ds         = FormDataUtil::getFormDataSource(args.record());

            if (intrastatTransfer.prompt())
            {
                intrastatTransfer.runOperation();
            }

            intrastat_ds.executeQuery();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container packedClass)
    {
        Integer      version      = conPeek(packedClass,1);
        container    packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList,packedQuery]      = packedClass;
                if (packedQuery)
                {
                    queryRunIntrastatTransfer = new QueryRun(packedQuery);
                }
                break;

            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds datasource to the query for thansfer.
    /// </summary>
    /// <param name = "_tableId">Id of the table.</param>
    /// <param name = "_dateFieldId">Id of the field.</param>
    /// <param name = "_dispatchFieldId">Id of the dispatch field.</param>
    /// <param name = "_isEnabled">Sets the Enabled property for the data source.</param>
    public void addSource(TableId _tableId, FieldId _dateFieldId, FieldId _dispatchFieldId, boolean _isEnabled)
    {
        Query intrastatQuery = queryRunIntrastatTransfer.query();
        QueryBuildDataSource qbds = intrastatQuery.dataSourceTable(_tableId);
        QueryBuildRange qbr;

        if (!qbds)
        {
            qbds = intrastatQuery.addDataSource(_tableId);
        }

        if (_dateFieldId)
        {
            findOrCreateRange_W(qbds, _dateFieldId);
        }

        if (_dispatchFieldId)
        {
            findOrCreateRange_W(qbds, _dispatchFieldId);
        }

        this.addRangeToDataSource(qbds, _tableId, _isEnabled);

        if (_tableId == tableNum(CompanyInfo))
        {
            qbds.allowAdd(QueryAllowAdd::NoFields);
            qbr = findOrCreateRange_W(qbds, fieldNum(CompanyInfo, DataArea));
            qbr.value(curext());
            qbr.status(RangeStatus::Hidden);
            qbds.name('');
        }
        else
        {
            qbds.update(true);
            qbds.enabled(_isEnabled);
        }

        this.addRanges(qbds, _tableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRangeToDataSource</Name>
				<Source><![CDATA[
    private void addRangeToDataSource(
        QueryBuildDataSource _qbds,
        TableId _tableId,
        boolean _isEnabled)
    {
        if (_isEnabled && FeatureStateProvider::isFeatureEnabled(CompanyTaxRegistrationFeature::instance()))
        {
            switch (_tableId)
            {
                case tableNum(CustInvoiceJour):
                    this.addTaxRegistrationRange(_qbds, fieldNum(CustInvoiceJour, TaxID));
                    break;

                case tableNum(CustPackingSlipJour):
                    this.addTaxRegistrationRange(_qbds, fieldNum(CustPackingSlipJour, TaxID));
                    break;

                case tableNum(ProjInvoiceJour):
                    this.addTaxRegistrationRange(_qbds, fieldNum(ProjInvoiceJour, TaxID));
                    break;

                default:
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxRegistrationRange</Name>
				<Source><![CDATA[
    private void addTaxRegistrationRange(QueryBuildDataSource _qbds, FieldId _fieldId)
    {
        QueryBuildDataSource taxRegistrationDataSource;
        boolean childTaxRegistrationDataSourceExists = false;

        for (int idx = 1; idx <= _qbds.childDataSourceCount(); idx++)
        {
            QueryBuildDataSource childDataSource = _qbds.childDataSourceNo(idx);

            if (childDataSource.table() == tableNum(TaxRegistration))
            {
                childTaxRegistrationDataSourceExists = true;
                break;
            }
        }

        if (!childTaxRegistrationDataSourceExists)
        {
            taxRegistrationDataSource = _qbds.addDataSource(tableNum(TaxRegistration));
            taxRegistrationDataSource.joinMode(JoinMode::OuterJoin);
            taxRegistrationDataSource.relations(false);
            taxRegistrationDataSource.addLink(fieldNum(TaxRegistration, RecId), _fieldId);
        }

        findOrCreateRange_W(taxRegistrationDataSource, fieldNum(TaxRegistration, RegistrationNumber));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRanges</Name>
				<Source><![CDATA[
    protected void addRanges(QueryBuildDataSource _qbds, RefTableId _tableId)
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query with the list of datasources.
    /// </summary>
    public void updateQuery()
    {
        this.addSource(tableNum(CompanyInfo), 0, 0, true); // Root element must be always enabled
        this.addSource(tableNum(CustInvoiceJour), fieldNum(CustInvoiceJour, InvoiceDate), fieldNum(CustInvoiceJour, IntrastatDispatch), freeTextInvoice || custInvoice);
        this.addSource(tableNum(CustPackingSlipJour), fieldNum(CustPackingSlipJour, DeliveryDate), fieldNum(CustPackingSlipJour, IntrastatDispatch), custPckSlp);
        this.addSource(tableNum(VendInvoiceJour), fieldNum(VendInvoiceJour, InvoiceDate), fieldNum(VendInvoiceJour, IntrastatDispatch), vendInvoice);
        this.addSource(tableNum(VendPackingSlipJour), fieldNum(VendPackingSlipJour, DeliveryDate), fieldNum(VendPackingSlipJour, IntrastatDispatch), vendPckSlp);
        this.addSource(tableNum(ProjInvoiceJour), fieldNum(ProjInvoiceJour, InvoiceDate), fieldNum(ProjInvoiceJour, IntrastatDispatchId), projInvoice);
        this.addSource(tableNum(InventTransferJour), fieldNum(InventTransferJour, TransDate), fieldNum(InventTransferJour, IntrastatDispatch), inventTransfer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRunIntrastatTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>queryRunIntrastatTransfer</c> parameter.
    /// </summary>
    /// <param name="_queryRunIntrastatTransfer">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>queryRunIntrastatTransfer</c> parameter.
    /// </returns>
    public QueryRun queryRunIntrastatTransfer(QueryRun _queryRunIntrastatTransfer = queryRunIntrastatTransfer)
    {
        queryRunIntrastatTransfer = _queryRunIntrastatTransfer;
        return queryRunIntrastatTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>vendInvoice</c> parameter.
    /// </summary>
    /// <param name="_vendInvoice">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>vendInvoice</c> parameter.
    /// </returns>
    public NoYes vendInvoice(NoYes _vendInvoice = vendInvoice)
    {
        vendInvoice = _vendInvoice;
        return vendInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendPckSlp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>vendPckSlp</c> parameter.
    /// </summary>
    /// <param name="_vendPckSlp">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>vendPckSlp</c> parameter.
    /// </returns>
    public NoYes vendPckSlp(NoYes _vendPckSlp = vendPckSlp)
    {
        vendPckSlp = _vendPckSlp;
        return vendPckSlp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>custInvoice</c> parameter.
    /// </summary>
    /// <param name="_custInvoice">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>custInvoice</c> parameter.
    /// </returns>
    public NoYes custInvoice(NoYes _custInvoice = custInvoice)
    {
        custInvoice = _custInvoice;
        return custInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freeTextInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>freeTextInvoice</c> parameter.
    /// </summary>
    /// <param name="_freeTextInvoice">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>freeTextInvoice</c> parameter.
    /// </returns>
    public NoYes freeTextInvoice(NoYes _freeTextInvoice = freeTextInvoice)
    {
        freeTextInvoice = _freeTextInvoice;
        return freeTextInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>inventTransfer</c> parameter.
    /// </summary>
    /// <param name="_inventTransfer">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>inventTransfer</c> parameter.
    /// </returns>
    public NoYes inventTransfer(NoYes _inventTransfer = inventTransfer)
    {
        inventTransfer = _inventTransfer;
        return inventTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    container pack()
    {
        return [#CurrentVersion,#CurrentList,queryRunIntrastatTransfer.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>projInvoice</c> parameter.
    /// </summary>
    /// <param name="_projInvoice">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>projInvoice</c> parameter.
    /// </returns>
    public NoYes projInvoice(NoYes _projInvoice = projInvoice)
    {
        projInvoice = _projInvoice;
        return projInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog box, and if a Select menu item is added to a
    ///    dialog box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do
    ///    it in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    QueryRun queryRun()
    {
        this.updateQuery();

        return queryRunIntrastatTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        setPrefix("@SYS8801");

        this.progressInit("@SYS8801", 0, #Avifilemove, 0);
        progress.updateInterval(0);
        progress.setCount(0);

        boolean isSuccess;

        using (IntrastatContext context = IntrastatContext::instance())
        {
            try
            {
                GlobalizationInstrumentationHelper::featureProcessingStartEvent(
                    FeatureReferenceEUR00002,
                    strFmt('%1#Start', "@SYS8801"),
                    funcName());

                stopwatch = System.Diagnostics.Stopwatch::StartNew();

                if (!runTransferNotInInclusiveTransaction)
                {
                    ttsbegin;
                }

                this.updateQuery();

                while (queryRunIntrastatTransfer.next())
                {
                    this.getRecordFromQueryRun();

                    /* Start inserting */
                    this.loadIntrastatFromRecord();

                    this.resetTableBuffers();
                }

                this.setUsedExportDispatchId();
                this.setUsedImportDispatchId();

                if (!runTransferNotInInclusiveTransaction)
                {
                    ttscommit;
                }

                isSuccess = true;
            }
            catch(Exception::Error)
            {
                new SystemSequence().removeRecIdSuspension(tableNum(Intrastat));

                if (runTransferNotInInclusiveTransaction)
                {
                    if (numberseqExport)
                    {
                        numberseqExport.abort();
                    }

                    if (numberseqImport)
                    {
                        numberseqImport.abort();
                    }
                }

                isSuccess = false;
            }
            finally
            {
                stopwatch.Stop();

                totalToTransferCounter = this.getTotalToTransferCounter();
                totalTransCounter = this.getTotalTransCounter();

                GlobalizationInstrumentationHelper::featureProcessingFinishEvent(
                    FeatureReferenceEUR00002,
                    strFmt('%1#Finish', "@SYS8801"),
                    funcName(),
                    '1',
                    SysCountryRegionCode::countryInfo(),
                    stopwatch.ElapsedMilliseconds,
                    false,
                    isSuccess,
                    this.elapsedTimePerOutputItemInMilliseconds(),
                    this.getOutcomeMsg());

                if (FeatureStateProvider::isFeatureEnabled(IntrastatMiscChargesPerKgFeature::instance()))
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00042, funcName());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalToTransferCounter</Name>
				<Source><![CDATA[
    private int getTotalToTransferCounter()
    {
        return freeTextCustInvoiceTransToTransferCounter + custInvoiceTransToTransferCounter
            + custPckSlpTransToTransferCounter + inventTransferJourLinesToTransferCounter
            + projInvoiceItemsToTransferCounter + vendInvoiceTransToTransferCounter
            + vendInvoiceIntrastatToTransferCounter + vendPckSlpTransToTransferCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalTransCounter</Name>
				<Source><![CDATA[
    private int getTotalTransCounter()
    {
        return freeTextCustInvoiceTransCounter + custInvoiceTransCounter
            + custPckSlpTransCounter + inventTransferJourLinesCounter
            + projInvoiceItemsCounter + vendInvoiceTransCounter
            + vendInvoiceJoursMatchedToVendInvoiceIntrastatCounter + vendPckSlpTransCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>elapsedTimePerOutputItemInMilliseconds</Name>
				<Source><![CDATA[
    private int64 elapsedTimePerOutputItemInMilliseconds()
    {
        return totalToTransferCounter ? stopwatch.ElapsedMilliseconds / totalToTransferCounter : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOutcomeMsg</Name>
				<Source><![CDATA[
    private str getOutcomeMsg()
    {
        return strFmt(outcomeMsg,
            this.calcPercentageOfTotalNumberTrans(freeTextCustInvoiceTransCounter), this.calcPercentageOfNumberTransferred(freeTextCustInvoiceTransToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(custInvoiceTransCounter), this.calcPercentageOfNumberTransferred(custInvoiceTransToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(custPckSlpTransCounter), this.calcPercentageOfNumberTransferred(custPckSlpTransToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(inventTransferJourLinesCounter), this.calcPercentageOfNumberTransferred(inventTransferJourLinesToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(projInvoiceItemsCounter), this.calcPercentageOfNumberTransferred(projInvoiceItemsToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(vendInvoiceTransCounter), this.calcPercentageOfNumberTransferred(vendInvoiceTransToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(vendInvoiceJoursMatchedToVendInvoiceIntrastatCounter), this.calcPercentageOfNumberTransferred(vendInvoiceIntrastatToTransferCounter),
            this.calcPercentageOfTotalNumberTrans(vendPckSlpTransCounter), this.calcPercentageOfNumberTransferred(vendPckSlpTransToTransferCounter));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPercentageOfTotalNumberTrans</Name>
				<Source><![CDATA[
    private real calcPercentageOfTotalNumberTrans(int _transCounter)
    {
        return totalTransCounter
            ? _transCounter / totalTransCounter * 100
            : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPercentageOfNumberTransferred</Name>
				<Source><![CDATA[
    private real calcPercentageOfNumberTransferred(int _toTransferCounter)
    {
        return totalToTransferCounter
            ? _toTransferCounter / totalToTransferCounter * 100
            : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecordFromQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets record from the main query according to the record type.
    /// </summary>
    protected void getRecordFromQueryRun()
    {
        if ((custInvoice || freeTextInvoice))
        {
            custInvoiceJourRun = queryRunIntrastatTransfer.get(tableNum(CustInvoiceJour));
            if (custInvoiceJourRunLastRecId != custInvoiceJourRun.RecId)
            {
                custInvoiceJourRunLastRecId = custInvoiceJourRun.RecId;
            }
            else
            {
                custInvoiceJourRun = null;
            }
        }

        if (custPckSlp)
        {
            custPackingSlipJourRun = queryRunIntrastatTransfer.get(tableNum(CustPackingSlipJour));
            if (custPackingSlipJourRunLastRecId != custPackingSlipJourRun.RecId)
            {
                custPackingSlipJourRunLastRecId = custPackingSlipJourRun.RecId;
            }
            else
            {
                custPackingSlipJourRun = null;
            }
        }

        if (vendInvoice)
        {
            vendInvoiceJourRun = queryRunIntrastatTransfer.get(tableNum(VendInvoiceJour));
            if (vendInvoiceJourRun.RecId && vendInvoiceJourRunLastRecId != vendInvoiceJourRun.RecId)
            {
                vendInvoiceJourRunLastRecId = vendInvoiceJourRun.RecId;
            }
            else
            {
                vendInvoiceJourRun = null;
            }
        }

        if (vendPckSlp)
        {
            vendPackingSlipJourRun = queryRunIntrastatTransfer.get(tableNum(VendPackingSlipJour));
            if (vendPackingSlipJourRun.RecId && vendPackingSlipJourRunLastRecId != vendPackingSlipJourRun.RecId)
            {
                vendPackingSlipJourRunLastRecId = vendPackingSlipJourRun.RecId;
            }
            else
            {
                vendPackingSlipJourRun = null;
            }
        }

        if (projInvoice)
        {
            projInvoiceJourRun = queryRunIntrastatTransfer.get(tableNum(ProjInvoiceJour));
            if (projInvoiceJourRun.RecId && projInvoiceJourRunLastRecId != projInvoiceJourRun.RecId)
            {
                projInvoiceJourRunLastRecId = projInvoiceJourRun.RecId;
            }
            else
            {
                projInvoiceJourRun = null;
            }
        }

        if (inventTransfer)
        {
            inventTransferJourRun = queryRunIntrastatTransfer.get(tablenum(InventTransferJour));
            if (inventTransferJourRun.RecId && inventTransferJourRunLastRecId != inventTransferJourRun.RecId)
            {
                inventTransferJourRunLastRecId = inventTransferJourRun.RecId;
            }
            else
            {
                inventTransferJourRun = null;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadIntrastatFromRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads Intrastat data from the source data according to the record type.
    /// </summary>
    protected void loadIntrastatFromRecord()
    {
        transportDocumentPostalAddress = null;
        invoicePostalAddress = null;
        deliveryPostalAddress = null;

        if (custInvoiceJourRun)
        {
            if (freeTextInvoice && custInvoiceJourRun.RefNum == RefNum::Cust)
            {
                this.loadFreeTextFromCustInvoiceJour(IntrastatDirection::Export, custInvoiceJourRun);
            }

            if (custInvoice && custInvoiceJourRun.RefNum != RefNum::Cust)
            {
                this.loadFromCustInvoiceJour(IntrastatDirection::Export, custInvoiceJourRun);
            }
        }

        if (custPackingSlipJourRun)
        {
            this.loadFromCustPckSlpJour(IntrastatDirection::Export, custPackingSlipJourRun);
        }

        if (vendInvoiceJourRun)
        {
            this.loadFromVendInvoiceJour(IntrastatDirection::Import, vendInvoiceJourRun);
        }

        if (vendPackingSlipJourRun)
        {
            this.loadFromVendPckSlpJour(IntrastatDirection::Import, vendPackingSlipJourRun);
        }

        if (projInvoiceJourRun)
        {
            this.loadFromProjInvoiceJour(IntrastatDirection::Import, projInvoiceJourRun);
        }

        if (inventTransferJourRun)
        {
            this.loadFromInventTransferJour(IntrastatDirection::Export, inventTransferJourRun);
            this.loadFromInventTransferJour(IntrastatDirection::Import, inventTransferJourRun);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetTableBuffers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the table buffers.
    /// </summary>
    protected void resetTableBuffers()
    {
        custInvoiceJourRun     = null;
        custPackingSlipJourRun = null;
        vendInvoiceJourRun     = null;
        vendPackingSlipJourRun = null;
        inventTransferJourRun  = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendPackingSlipInvoiceId</Name>
				<Source><![CDATA[
    InvoiceId vendPackingSlipInvoiceId(VendPackingSlipTrans _vendPackingSlipTrans)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select firstonly InvoiceId from inventTrans
            where inventTrans.PackingSlipId == _vendPackingSlipTrans.PackingSlipId
               && inventTrans.DatePhysical  == _vendPackingSlipTrans.vendPackingslipJour().DeliveryDate
               && inventTrans.InvoiceId
            exists join inventTransOrigin
                where inventTransOrigin.RecId         == inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _vendPackingSlipTrans.InventTransId;

        return inventTrans.InvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewRecordInsertList</Name>
				<Source><![CDATA[
    private static RecordInsertList getNewRecordInsertList()
    {
        return new RecordInsertList(
            tableNum(Intrastat),
            true,
            true,
            true,
            false,
            true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFreeTextFromCustInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies data that originated from free text invoices from the <c>CustInvoiceJour</c> and
    ///    <c>CustInvoiceTrans</c> tables to the <c>Intrastat</c> table.
    /// </summary>
    /// <param name="_direction">
    ///    The direction of the transfer.
    /// </param>
    /// <param name="_custInvoiceJour">
    ///    The <c>CustInvoiceJour</c> buffer from which the data is copied.
    /// </param>
    /// <remarks>
    ///    The data from the free text invoice is filtered from the <c>CustInvoiceJour</c> table by using the
    ///    <c>RefNum::Cust</c> enumeration value.
    /// </remarks>
    void loadFreeTextFromCustInvoiceJour(IntrastatDirection  _direction, // this direction only determines the dispatchID - not the intrastat reporting direction
                                         CustInvoiceJour     _custInvoiceJour)
    {
        Intrastat               intrastat;
        CustInvoiceTrans        custInvoiceTrans;

        setPrefix(#PreFixField(_custInvoiceJour, invoiceId));

        using (IntrastatContext context = IntrastatContext::instance())
        {
            ttsbegin;

            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            while select forupdate custInvoiceTrans
                where custInvoiceTrans.InvoiceId        == _custInvoiceJour.InvoiceId     &&
                      custInvoiceTrans.InvoiceDate      == _custInvoiceJour.InvoiceDate
            {
                setPrefix(#PreFixField(CustInvoicetrans, itemId));

                freeTextCustInvoiceTransCounter++;

                if (this.exportToBeIncludedCustFreeInvoiceTrans(_custInvoiceJour, custInvoiceTrans))
                {
                    Intrastat::deleteTransId(custInvoiceTrans.TableId, custInvoiceTrans.RecId);

                    intrastat = this.initIntrastatFromFreeCustInvoiceTrans(_custInvoiceJour, custInvoiceTrans);

                    if (intrastat.checkIfTransferAllowed(custInvoiceTrans, custInvoiceTrans.Weight))
                    {
                        if (isLegalEntityInEEU
                            && intrastatParm.IntrastatExchRateType
                            && exchRateErrMsg)
                        {
                            // thorws error only when the transaction is going to be included in intrastat
                            throw error(exchRateErrMsg);
                        }

                        intrastat.DispatchId = this.getDispatchId(_direction);
                        intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                        recordInsertList.add(intrastat);

                        if (_custInvoiceJour.IntrastatDispatch != intrastat.DispatchId)
                        {
                            _custInvoiceJour.IntrastatDispatch = intrastat.DispatchId;
                            _custInvoiceJour.update();
                        }

                        custInvoiceTrans.IntrastatDispatchId = intrastat.DispatchId;
                        custInvoiceTrans.update();
                    }
                }
            }

            freeTextCustInvoiceTransToTransferCounter += recordInsertList.insertDatabase();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsCustPackingSlipInstrastat</Name>
				<Source><![CDATA[
    private boolean existsCustPackingSlipInstrastat(CustInvoiceTrans _custInvoiceTrans)
    {
        PackingSlipId packingSlipId = this.custVendInvoiceTransPackingSlipId(_custInvoiceTrans);

        if (!packingSlipId)
        {
            return false;
        }

        CustPackingSlipTrans custPackingSlipTrans;
        Intrastat packingSlipIntrastat;

        select firstonly RecId from custPackingSlipTrans
            where custPackingSlipTrans.InventTransId == _custInvoiceTrans.InventTransId
                && custPackingSlipTrans.PackingSlipId == packingSlipId
            exists join packingSlipIntrastat
                where packingSlipIntrastat.TransTableId == custPackingSlipTrans.TableId
                    && packingSlipIntrastat.TransRecId == custPackingSlipTrans.RecId;

        return custPackingSlipTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromCustInvoiceJour</Name>
				<Source><![CDATA[
    void loadFromCustInvoiceJour(IntrastatDirection  _direction, // this direction only determines the dispatchID - not the intrastat reporting direction
                                 CustInvoiceJour     _custInvoiceJour)
    {
        Intrastat                   intrastat;
        CustInvoiceTrans            custInvoiceTrans;
        CustInvoiceJour_Intrastat   custInvoiceJour_Intrastat;
        CustInvoiceTrans_Intrastat  custInvoiceTrans_Intrastat;

        Counter                 invoiceLines;
        List                    insertedLines = new List(Types::Int64);
        CustInvoiceJour_W       custInvoiceJourW;

        setPrefix(#PreFixField(_custInvoiceJour, invoiceId));

        using (IntrastatContext context = IntrastatContext::instance())
        {
            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            SystemSequence systemSequence;
            if (isLegalEntityInLV)
            {
                systemSequence = new SystemSequence();
                systemSequence.suspendRecIds(tableNum(Intrastat));
            }

            ttsbegin;

            while select forupdate custInvoiceTrans
                where custInvoiceTrans.InvoiceId        == _custInvoiceJour.InvoiceId     &&
                      custInvoiceTrans.InvoiceDate      == _custInvoiceJour.InvoiceDate   &&
                      custInvoiceTrans.SalesId          == _custInvoiceJour.SalesId

                outer join custInvoiceJour_Intrastat
                    where _custInvoiceJour.RecId == custInvoiceJour_Intrastat.CustInvoiceJour

                outer join custInvoiceTrans_Intrastat
                    where custInvoiceTrans.RecId == custInvoiceTrans_Intrastat.CustInvoiceTrans
            {
                setPrefix(#PreFixField(CustInvoicetrans, itemId));

                custInvoiceTransCounter++;

                if (this.exportToBeIncludedCustInvoiceTrans(_custInvoiceJour, custInvoiceTrans))
                {
                    Intrastat::deleteTransId(custInvoiceTrans.TableId, custInvoiceTrans.RecId);

                    boolean checkPackingSlipIntrastat = custPckSlp || this.existsCustPackingSlipInstrastat(custInvoiceTrans);

                    if (!this.checkItemQty(checkPackingSlipIntrastat, custInvoiceTrans.QtyPhysical, intrastat, _custInvoiceJour, custInvoiceTrans))
                    {
                        continue;
                    }

                    intrastat = this.initIntrastatFromCustInvoiceTrans(_custInvoiceJour,
                                                               custInvoiceTrans,
                                                               custInvoiceJour_Intrastat,
                                                               custInvoiceTrans_Intrastat);

                    if (this.checkItemQty(custPckSlp, custInvoiceTrans.QtyPhysical, intrastat)
                        && intrastat.checkIfTransferAllowed(custInvoiceTrans, custInvoiceTrans.Weight))
                    {
                        if (isLegalEntityInEEU
                            && intrastatParm.IntrastatExchRateType
                            && exchRateErrMsg)
                        {
                            // throws error only when the transaction is going to be included in intrastat
                            throw error(exchRateErrMsg);
                        }

                        intrastat.DispatchId = this.getDispatchId(_direction);
                        intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                        if (systemSequence)
                        {
                            intrastat.RecId = systemSequence.reserveValues(1, tableNum(Intrastat));
                        }
                        recordInsertList.add(intrastat);

                        if (isLegalEntityInLV)
                        {
                            invoiceLines++;
                            insertedLines.addEnd(intrastat.RecId);
                        }

                        if (_custInvoiceJour.IntrastatDispatch != intrastat.DispatchId)
                        {
                            _custInvoiceJour.IntrastatDispatch = intrastat.DispatchId;
                            _custInvoiceJour.update();
                        }

                        custInvoiceTrans.IntrastatDispatchId = intrastat.DispatchId;
                        custInvoiceTrans.update();
                    }
                }
            }

            custInvoiceTransToTransferCounter += recordInsertList.insertDatabase();
            if (systemSequence)
            {
                systemSequence.removeRecIdSuspension(tableNum(Intrastat));
            }

            if (isLegalEntityInLV && invoiceLines)
            {
                custInvoiceJourW = _custInvoiceJour.custInvoiceJour_W();

                if (custInvoiceJourW.IntrastatAddValue_LV != 0)
                {
                    this.distributeIntrastatAddValueLV(invoiceLines, insertedLines, custInvoiceJourW.IntrastatAddValue_LV);
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromCustPckSlpJour</Name>
				<Source><![CDATA[
    void loadFromCustPckSlpJour(IntrastatDirection  _direction, // this direction only determines the dispatchID - not the intrastat reporting direction
                                CustPackingSlipJour _custPackingSlipJour)
    {
        Intrastat                       intrastat;
        CustPackingSlipTrans            custPackingSlipTrans;
        CustPackingSlipJour_Intrastat   custPackingSlipJour_Intrastat;
        CustPackingSlipTrans_Intrastat  custPackingSlipTrans_Intrastat;

        setPrefix(#PreFixField(_custPackingSlipJour, PackingSlipId));

        using (IntrastatContext context = IntrastatContext::instance())
        {
            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            ttsbegin;

            while select forupdate custPackingSlipTrans
                where custPackingSlipTrans.PackingSlipId == _custPackingSlipJour.PackingSlipId &&
                      custPackingSlipTrans.DeliveryDate  == _custPackingSlipJour.DeliveryDate &&
                      custPackingSlipTrans.SalesId       == _custPackingSlipJour.SalesId

                outer join custPackingSlipJour_Intrastat
                    where _custPackingSlipJour.RecId == custPackingSlipJour_Intrastat.CustPackingSlipJour

                outer join custPackingSlipTrans_Intrastat
                    where custPackingSlipTrans.RecId == custPackingSlipTrans_Intrastat.CustPackingSlipTrans
            {
                setPrefix(#PreFixField(custPackingSlipTrans, itemId));

                custPckSlpTransCounter++;

                if (this.exportToBeIncludedCustPckSlipTrans(_custPackingSlipJour, custPackingSlipTrans))
                {
                    Intrastat::deleteTransId(custPackingSlipTrans.TableId, custPackingSlipTrans.RecId);

                    intrastat = this.initIntrastatFromCustPckSlpTrans(_custPackingSlipJour,
                                                                  custPackingSlipTrans,
                                                                  custPackingSlipJour_Intrastat,
                                                                  custPackingSlipTrans_Intrastat);

                    if (intrastat.checkIfTransferAllowed(custPackingSlipTrans, custPackingSlipTrans.Weight))
                    {
                        if (isLegalEntityInEEU
                            && intrastatParm.IntrastatExchRateType
                            && exchRateErrMsg)
                        {
                            // thorws error only when the transaction is going to be included in intrastat
                            throw error(exchRateErrMsg);
                        }

                        intrastat.DispatchId = this.getDispatchId(_direction);
                        intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                        recordInsertList.add(intrastat);

                        if (_custPackingSlipJour.IntrastatDispatch != intrastat.DispatchId)
                        {
                            _custPackingSlipJour.IntrastatDispatch = intrastat.DispatchId;
                            _custPackingSlipJour.update();
                        }

                        custPackingSlipTrans.IntrastatDispatchId = intrastat.DispatchId;
                        custPackingSlipTrans.update();
                    }
                }
            }

            custPckSlpTransToTransferCounter += recordInsertList.insertDatabase();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransferJourUpdateTypeForExport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the update type describes an export.
    /// </summary>
    /// <param name = "_inventTransferJourUpdateType">
    /// An inventory transfer journal update type.
    /// </param>
    /// <returns>
    /// true if the update type describes an export; otherwise, false.
    /// </returns>
    [Hookable]
    protected static boolean isInventTransferJourUpdateTypeForExport(InventTransferUpdateType _updateType)
    {
        switch (_updateType)
        {
            case InventTransferUpdateType::Shipment:
                return true;
            case InventTransferUpdateType::Receive:
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromInventTransferJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies data that originated from inventory transfer orders from the <c>InventTransferJour</c> and <c>InventTransferJourLine</c> tables to the Intrastat table.
    /// </summary>
    /// <param name="_direction">
    /// The direction of the transfer.
    /// </param>
    /// <param name="_inventTransferJour">
    /// The <c>InventTransferJour</c> buffer that data is copied from.
    /// </param>
    /// <remarks>
    /// The data from the inventory transfer orders is filtered from the <c>InventTransferJour</c> table by using the enum value <c>InventTransferUpdateType::Shipment</c>.
    /// </remarks>
    void loadFromInventTransferJour(IntrastatDirection  _direction,
                                    InventTransferJour  _inventTransferJour)
    {
        Intrastat              intrastat;
        InventTransferJourLine inventTransferJourLine;

        boolean export = IntrastatTransfer::isInventTransferJourUpdateTypeForExport(_inventTransferJour.UpdateType);
        
        if (!this.validateInventTransferJournalExport(_inventTransferJour, _direction))
        {
            return;
        }

        if (_inventTransferJour.IntrastatDispatch)
        {
            Intrastat::deleteTransaction(_inventTransferJour.IntrastatDispatch);
        }

        setprefix(#PreFixField(_inventTransferJour, TransferId));

        using (IntrastatContext context = IntrastatContext::instance())
        {
            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            ttsbegin;
            while select forupdate inventTransferJourLine
                where inventTransferJourLine.VoucherId  == _inventTransferJour.VoucherId  &&
                      inventTransferJourLine.TransferId == _inventTransferJour.TransferId
            {
                setprefix(#PreFixField(inventTransferJourLine, ItemId));

                inventTransferJourLinesCounter++;

                if (( export && this.exportToBeIncludedInventTransferJour(_inventTransferJour, inventTransferJourLine))
                    || (!export && this.importToBeIncludedInventTransferJour(_inventTransferJour, inventTransferJourLine)))
                {
                    Intrastat::deleteTransId(inventTransferJourLine.TableId, inventTransferJourLine.RecId);

                    intrastat = this.initIntrastatFromInventTransferJour(_direction,
                                                                     _inventTransferJour,
                                                                     inventTransferJourLine);

                    if (intrastat.checkIfTransferAllowed(inventTransferJourLine))
                    {
                        intrastat.DispatchId = this.getDispatchId(_direction);
                        intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        recordInsertList.add(intrastat);

                        if (_inventTransferJour.IntrastatDispatch != intrastat.DispatchId)
                        {
                            _inventTransferJour.IntrastatDispatch = intrastat.DispatchId;
                            _inventTransferJour.update();
                        }

                        inventTransferJourLine.IntrastatDispatch = intrastat.DispatchId;
                        inventTransferJourLine.update();
                    }
                }
            }

            inventTransferJourLinesToTransferCounter += recordInsertList.insertDatabase();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromProjInvoiceJour</Name>
				<Source><![CDATA[
    void loadFromProjInvoiceJour(IntrastatDirection  _direction, // this direction only determines the dispatchID - not the intrastat reporting direction
                                 ProjInvoiceJour _projInvoiceJour)
    {
        Intrastat               intrastat;
        ProjInvoiceItem         projInvoiceItem;
        Counter                 invoiceLines;
        List                    insertedLines = new List(Types::Int64);

        setPrefix(#PreFixField(_ProjInvoiceJour, ProjInvoiceId));

        if (!isLegalEntityInEEU
            && !this.exportToBeIncludedProjInvoiceJour(_projInvoiceJour))
        {
            return;
        }

        using (IntrastatContext context = IntrastatContext::instance())
        {
            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            SystemSequence systemSequence;
            if (isLegalEntityInLV)
            {
                systemSequence = new SystemSequence();
                systemSequence.suspendRecIds(tableNum(Intrastat));
            }

            ttsbegin;

            while select forupdate projInvoiceItem
                where projInvoiceItem.ProjInvoiceId    == _projInvoiceJour.ProjInvoiceId     &&
                      projInvoiceItem.InvoiceDate      == _projInvoiceJour.InvoiceDate   &&
                      projInvoiceItem.Qty              != 0
            {
                if (! isLegalEntityInEEU
                    || (isLegalEntityInEEU
                        && this.exportToBeIncludedProjInvoiceItem(_projInvoiceJour, projInvoiceItem)))
                {
                    setPrefix(#PreFixField(ProjInvoiceItem, itemId));

                    projInvoiceItemsCounter++;

                    Intrastat::deleteTransId(projInvoiceItem.TableId, projInvoiceItem.RecId);

                    intrastat = this.initIntrastatFromProjInvoiceItem(_projInvoiceJour, projInvoiceItem);

                    if (intrastat.checkIfTransferAllowed(projInvoiceItem, projInvoiceItem.Weight))
                    {
                        if (isLegalEntityInEEU
                            && intrastatParm.IntrastatExchRateType
                            && exchRateErrMsg)
                        {
                            // thorws error only when the transaction is going to be included in intrastat
                            throw error(exchRateErrMsg);
                        }

                        intrastat.DispatchId = this.getDispatchId(_direction);
                        intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                        if (systemSequence)
                        {
                            intrastat.RecId = systemSequence.reserveValues(1, tableNum(Intrastat));
                        }
                        recordInsertList.add(intrastat);

                        if (isLegalEntityInLV)
                        {
                            invoiceLines++;
                            insertedLines.addEnd(intrastat.RecId);
                        }

                        if (_projInvoiceJour.IntrastatDispatchId != intrastat.DispatchId)
                        {
                            _projInvoiceJour.IntrastatDispatchId = intrastat.DispatchId;
                            _projInvoiceJour.update();
                        }

                        projInvoiceItem.IntrastatDispatchId = intrastat.DispatchId;
                        projInvoiceItem.update();
                    }
                }
            }

            projInvoiceItemsToTransferCounter += recordInsertList.insertDatabase();
            if (systemSequence)
            {
                systemSequence.removeRecIdSuspension(tableNum(Intrastat));
            }

            if (isLegalEntityInLV
                && invoiceLines
                && _projInvoiceJour.IntrastatAddValue_LV != 0)
            {
                this.distributeIntrastatAddValueLV(invoiceLines, insertedLines, _projInvoiceJour.IntrastatAddValue_LV);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromVendInvoiceIntrastat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the intrastat information from the <c>VendInvoiceIntrastat</c> table to the
    /// <c>Intrastat</c> table.
    /// </summary>
    /// <param name="_direction">
    /// The direction of intrastat transfer, which is either import or export.
    /// </param>
    /// <param name="_vendInvoiceJour">
    /// A <c>VendInvoiceJour</c> table buffer.
    /// </param>
    /// <param name="_invoiceTrans">
    /// true if the corresponding <c>VendInvoiceTrans</c> lines exist for the current
    /// <c>VendInvoiceJour</c> record; otherwise, false.
    /// </param>
    /// <remarks>
    /// This method is called for each record in the <c>VendInvoiceJour</c> table. If a matching record is
    /// in the <c>VendInvoiceIntrastat</c> table, it is transferred to the <c>Intrastat</c> table.
    /// </remarks>
    public void loadFromVendInvoiceIntrastat(IntrastatDirection  _direction,
                                             VendInvoiceJour     _vendInvoiceJour,
                                             boolean             _invoiceTrans)
    {
        Intrastat               intrastat;
        VendInvoiceIntrastat    vendInvoiceIntrastat = VendInvoiceIntrastat::findByVendInvoiceJour(_vendInvoiceJour.RecId);

        using (IntrastatContext context = IntrastatContext::instance())
        {
            if (vendInvoiceIntrastat)
            {
                vendInvoiceJoursMatchedToVendInvoiceIntrastatCounter++;

                if (this.importToBeIncludedVendInvoiceIntrastat(_vendInvoiceJour))
                {
                    ttsbegin;

                    Intrastat::deleteTransId(_vendInvoiceJour.TableId, _vendInvoiceJour.RecId);

                    intrastat = this.initIntrastatFromVendInvoiceIntrastat(_vendInvoiceJour, vendInvoiceIntrastat);

                    if (intrastat.transferIsAllowed())
                    {
                        if (isLegalEntityInEEU
                            && intrastatParm.IntrastatExchRateType
                            && exchRateErrMsg)
                        {
                            // thorws error only when the transaction is going to be included in intrastat
                            throw error(exchRateErrMsg);
                        }

                        intrastat.DispatchId        = this.getDispatchId(_direction);
                        intrastat.SeqNum            = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                        intrastat.insert();
                        vendInvoiceIntrastatToTransferCounter++;

                        if (_vendInvoiceJour.IntrastatDispatch != intrastat.DispatchId)
                        {
                            _vendInvoiceJour.IntrastatDispatch = intrastat.DispatchId;
                            _vendInvoiceJour.update();
                        }
                    }

                    // Handle the case when a registered invoice is associated with a purchase order in the Invoice approval Journal.
                    // The posted VendInvoiceJour record is updated with the details from the purchase order. Thus, a new line with the
                    // opposite amount needs to be created in VendInvoiceIntrastat table to balance the original line.

                    if (_invoiceTrans && intrastat && _vendInvoiceJour.PurchId)
                    {
                        this.alignSigns(intrastat, -this.calcValuesSign(intrastat));

                        intrastat.DispatchId        = this.getDispatchId(_direction);
                        intrastat.SeqNum            = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        intrastat.insert();
                        vendInvoiceIntrastatToTransferCounter++;
                    }

                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsVendPackingSlipInstrastat</Name>
				<Source><![CDATA[
    private boolean existsVendPackingSlipInstrastat(VendInvoiceTrans _vendInvoiceTrans)
    {
        PackingSlipId packingSlipId = this.custVendInvoiceTransPackingSlipId(_vendInvoiceTrans);

        if (!packingSlipId)
        {
            return false;
        }

        VendPackingSlipTrans vendPackingSlipTrans;
        Intrastat packingSlipIntrastat;

        select firstonly RecId from vendPackingSlipTrans
            where vendPackingSlipTrans.InventTransId == _vendInvoiceTrans.InventTransId
                && vendPackingSlipTrans.PackingSlipId == packingSlipId
            exists join packingSlipIntrastat
                where packingSlipIntrastat.TransTableId == vendPackingSlipTrans.TableId
                    && packingSlipIntrastat.TransRecId == vendPackingSlipTrans.RecId;

        return vendPackingSlipTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromVendInvoiceJour</Name>
				<Source><![CDATA[
    void loadFromVendInvoiceJour(IntrastatDirection  _direction, // this direction only determines the dispatchID - not the intrastat reporting direction
                                 VendInvoiceJour     _vendInvoiceJour)
    {
        Intrastat               intrastat;
        VendInvoiceTrans        vendInvoiceTrans;
        boolean                 invoiceTrans;
        VendInvoiceJour_Intrastat   vendInvoiceJour_Intrastat;
        VendInvoiceTrans_Intrastat  vendInvoiceTrans_Intrastat;
        VendTrans                   vendTrans;
        TransactionReversalTrans    transactionReversalTrans;

        Counter                 invoiceLines;
        List                    insertedLines = new List(Types::Int64);

        void loadFromVendInvoiceTrans(RecordInsertList _recordInsertList, SystemSequence _systemSequence)
        {
            invoiceTrans = true;

            vendInvoiceTransCounter++;

            if (this.importToBeIncludedVendInvoiceTrans(_vendInvoiceJour, vendInvoiceTrans))
            {
                setPrefix(#PreFixField(vendInvoiceTrans, itemId));

                Intrastat::deleteTransId(vendInvoiceTrans.TableId, vendInvoiceTrans.RecId);

                boolean checkPackingSlipIntrastat = vendPckSlp || this.existsVendPackingSlipInstrastat(vendInvoiceTrans);

                if (!this.checkItemQty(checkPackingSlipIntrastat, vendInvoiceTrans.QtyPhysical, intrastat, _vendInvoiceJour, vendInvoiceTrans))
                {
                    return;
                }

                intrastat = this.initIntrastatFromVendInvoiceTrans(_vendInvoiceJour,
                                                               vendInvoiceTrans,
                                                               vendInvoiceJour_Intrastat,
                                                               vendInvoiceTrans_Intrastat);

                if (intrastat.checkIfTransferAllowed(vendInvoiceTrans, vendInvoiceTrans.Weight))
                {
                    if (isLegalEntityInEEU
                            && intrastatParm.IntrastatExchRateType
                            && exchRateErrMsg)
                    {
                        // throws error only when the transaction is going to be included in intrastat
                        throw error(exchRateErrMsg);
                    }

                    intrastat.DispatchId = this.getDispatchId(_direction);
                    intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                    this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                    if (_systemSequence)
                    {
                        intrastat.RecId = _systemSequence.reserveValues(1, tableNum(Intrastat));
                    }
                    _recordInsertList.add(intrastat);

                    if (isLegalEntityInLV)
                    {
                        invoiceLines++;
                        insertedLines.addEnd(intrastat.RecId);
                    }

                    if (_vendInvoiceJour.IntrastatDispatch != intrastat.DispatchId)
                    {
                        _vendInvoiceJour.IntrastatDispatch = intrastat.DispatchId;
                        _vendInvoiceJour.update();
                    }

                    vendInvoiceTrans.IntrastatDispatchId = intrastat.DispatchId;
                    vendInvoiceTrans.update();
                }
            }
        }

        setPrefix(#PreFixField(_vendInvoiceJour, invoiceId));

        using (IntrastatContext context = IntrastatContext::instance())
        {
            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            SystemSequence systemSequence;
            if (isLegalEntityInLV)
            {
                systemSequence = new SystemSequence();
                systemSequence.suspendRecIds(tableNum(Intrastat));
            }

            VendInvoiceJour_Intrastat vendInvoiceJour_IntrastatLoc = _vendInvoiceJour.vendInvoiceJour_Intrastat();

            if (vendInvoiceJour_IntrastatLoc && vendInvoiceJour_IntrastatLoc.ShipmentPostalAddress)
            {
                shipmentAddressRecIdBuffer = vendInvoiceJour_IntrastatLoc.ShipmentPostalAddress;
            }

            ttsbegin;

            while select forupdate vendInvoiceTrans
                where vendInvoiceTrans.InvoiceId         ==     _vendInvoiceJour.InvoiceId    &&
                      vendInvoiceTrans.InvoiceDate       ==     _vendInvoiceJour.InvoiceDate  &&
                      vendInvoiceTrans.PurchID           ==     _vendInvoiceJour.PurchId      &&
                      vendInvoiceTrans.InternalInvoiceId ==     _vendInvoiceJour.InternalInvoiceId
            outer join vendInvoiceJour_Intrastat
                where _vendInvoiceJour.RecId == vendInvoiceJour_Intrastat.VendInvoiceJour
            outer join vendInvoiceTrans_Intrastat
                where vendInvoiceTrans.RecId == vendInvoiceTrans_Intrastat.VendInvoiceTrans
            exists join vendTrans
                where vendTrans.Voucher     == _vendInvoiceJour.LedgerVoucher   &&
                      vendTrans.AccountNum  == _vendInvoiceJour.InvoiceAccount  &&
                      vendTrans.TransDate   == _vendInvoiceJour.InvoiceDate
            notexists join transactionReversalTrans
                where transactionReversalTrans.refrecid   == vendTrans.RecId  &&
                      transactionReversalTrans.refTableId == vendTrans.TableId
            {
                loadFromVendInvoiceTrans(recordInsertList, systemSequence);
            }

            if (!invoiceTrans)
            {
                LedgerJournalVoucherChanged ledgerJournalVoucherChanged;

                while select forupdate vendInvoiceTrans
                    where vendInvoiceTrans.InvoiceId         ==     _vendInvoiceJour.InvoiceId    &&
                          vendInvoiceTrans.InvoiceDate       ==     _vendInvoiceJour.InvoiceDate  &&
                          vendInvoiceTrans.PurchID           ==     _vendInvoiceJour.PurchId      &&
                          vendInvoiceTrans.InternalInvoiceId ==     _vendInvoiceJour.InternalInvoiceId
                outer join vendInvoiceJour_Intrastat
                    where _vendInvoiceJour.RecId == vendInvoiceJour_Intrastat.VendInvoiceJour
                outer join vendInvoiceTrans_Intrastat
                    where vendInvoiceTrans.RecId == vendInvoiceTrans_Intrastat.VendInvoiceTrans
                exists join ledgerJournalVoucherChanged
                    where ledgerJournalVoucherChanged.ToVoucher == _vendInvoiceJour.LedgerVoucher
                        && ledgerJournalVoucherChanged.ToDate   == _vendInvoiceJour.InvoiceDate
                exists join vendTrans
                    where vendTrans.AccountNum  == _vendInvoiceJour.InvoiceAccount      &&
                          vendTrans.TransDate   == ledgerJournalVoucherChanged.FromDate &&
                          vendTrans.Voucher     == ledgerJournalVoucherChanged.FromVoucher
                notexists join transactionReversalTrans
                    where transactionReversalTrans.refrecid   == vendTrans.RecId  &&
                          transactionReversalTrans.refTableId == vendTrans.TableId
                {
                    loadFromVendInvoiceTrans(recordInsertList, systemSequence);
                }
            }

            vendInvoiceTransToTransferCounter += recordInsertList.insertDatabase();
            if (systemSequence)
            {
                systemSequence.removeRecIdSuspension(tableNum(Intrastat));
            }

            if (isLegalEntityInLV
                && invoiceLines
                && _vendInvoiceJour.IntrastatAddValue_LV != 0)
            {
                this.distributeIntrastatAddValueLV(invoiceLines, insertedLines, _vendInvoiceJour.IntrastatAddValue_LV);
            }

            //transfer the intrastat information saved from vendor invoice journals
            this.loadFromVendInvoiceIntrastat(_direction, _vendInvoiceJour, invoiceTrans);

            ttscommit;

            shipmentAddressRecIdBuffer = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromVendPckSlpJour</Name>
				<Source><![CDATA[
    void loadFromVendPckSlpJour(IntrastatDirection  _direction, // this direction only determines the dispatchID - not the intrastat reporting direction
                                VendPackingSlipJour _vendPackingSlipJour)
    {
        Intrastat                   intrastat;
        VendPackingSlipTrans        vendPackingSlipTrans;
        VendPackingSlipJour_Intrastat   vendPackingSlipJour_Intrastat;
        VendPackingSlipTrans_Intrastat  vendPackingSlipTrans_Intrastat;

        setPrefix(#PreFixField(_vendPackingSlipJour, PackingSlipId));

        using (IntrastatContext context = IntrastatContext::instance())
        {
            RecordInsertList recordInsertList = IntrastatTransfer::getNewRecordInsertList();

            VendPackingSlipJour_Intrastat vendPackingSlipJour_IntrastatLoc = _vendPackingSlipJour.vendPackingSlipJour_Intrastat();

            if (vendPackingSlipJour_IntrastatLoc && vendPackingSlipJour_IntrastatLoc.ShipmentPostalAddress)
            {
                shipmentAddressRecIdBuffer = vendPackingSlipJour_IntrastatLoc.ShipmentPostalAddress;
            }

            ttsbegin;

            while select forupdate vendPackingSlipTrans
                where vendPackingSlipTrans.VendPackingSlipJour == _vendPackingSlipJour.RecId
    
                outer join vendPackingSlipJour_Intrastat
                    where _vendPackingSlipJour.RecId == vendPackingSlipJour_Intrastat.VendPackingSlipJour
    
                outer join vendPackingSlipTrans_Intrastat
                    where vendPackingSlipTrans.RecId == vendPackingSlipTrans_Intrastat.VendPackingSlipTrans
            {
                vendPckSlpTransCounter++;

                if (this.importToBeIncludedVendPckSlipTrans(_vendPackingSlipJour, vendPackingSlipTrans))
                {
                    setPrefix(#PreFixField(vendPackingSlipTrans, itemId));

                    Intrastat::deleteTransId(vendPackingSlipTrans.TableId, vendPackingSlipTrans.RecId);

                    intrastat = this.initIntrastatFromVendPckSlpTrans(_vendPackingSlipJour,
                                                              vendPackingSlipTrans,
                                                              vendPackingSlipJour_Intrastat,
                                                              vendPackingSlipTrans_Intrastat);

                    if (intrastat.AmountMST
                        && intrastat.Qty
                        && intrastat.checkIfTransferAllowed(vendPackingSlipTrans, vendPackingSlipTrans.Weight))
                    {
                        if (isLegalEntityInEEU && intrastatParm.IntrastatExchRateType && exchRateErrMsg)
                        {
                            // throws error only when the transaction is going to be included in intrastat
                            throw error(exchRateErrMsg);
                        }

                        intrastat.DispatchId = this.getDispatchId(_direction);
                        intrastat.SeqNum     = this.getNextSeqNum(intrastat.DispatchId, _direction);

                        this.alignSigns(intrastat, this.calcValuesSign(intrastat));

                        recordInsertList.add(intrastat);

                        if (_vendPackingSlipJour.IntrastatDispatch != intrastat.DispatchId)
                        {
                            _vendPackingSlipJour.IntrastatDispatch = intrastat.DispatchId;
                            _vendPackingSlipJour.update();
                        }

                        vendPackingSlipTrans.IntrastatDispatchId = intrastat.DispatchId;
                        vendPackingSlipTrans.update();
                    }
                }
            }

            vendPckSlpTransToTransferCounter += recordInsertList.insertDatabase();

            ttscommit;

            shipmentAddressRecIdBuffer = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPackingSlipInvoiceId</Name>
				<Source><![CDATA[
    InvoiceId custPackingSlipInvoiceId(CustPackingSlipTrans _custPackingSlipTrans)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select firstonly InvoiceId from inventTrans
            where inventTrans.PackingSlipId   == _custPackingSlipTrans.PackingSlipId
               && inventTrans.DatePhysical    == _custPackingSlipTrans.custPackingslipJour().DeliveryDate
               && inventTrans.InvoiceId
            exists join inventTransOrigin
                where inventTransOrigin.RecId         == inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _custPackingSlipTrans.InventTransId;

        return inventTrans.InvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPckslp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>custPckSlp</c> parameter.
    /// </summary>
    /// <param name="_custPckSlp">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of the <c>custPckSlp</c> parameter.
    /// </returns>
    public NoYes custPckslp(NoYes _custPckSlp = custPckSlp)
    {
        custPckSlp = _custPckSlp;
        return custPckSlp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendInvoiceTransPackingSlipId</Name>
				<Source><![CDATA[
    PackingSlipId custVendInvoiceTransPackingSlipId(CustVendInvoiceTrans _invoiceTrans)
    {
        if (_invoiceTrans.TableId == lastPackingSlipTableId && _invoiceTrans.RecId == lastPackingSlipRecId)
        {
            return lastPackingSlipId;
        }

        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select firstonly PackingSlipId from inventTrans
            where inventTrans.InvoiceId     == _invoiceTrans.InvoiceNum
               && inventTrans.PackingSlipId != ''
            exists join inventTransOrigin
                where inventTransOrigin.RecId         == inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _invoiceTrans.InventTransId;

        lastPackingSlipTableId = _invoiceTrans.TableId;
        lastPackingSlipRecId = _invoiceTrans.RecId;
        lastPackingSlipId = inventTrans.PackingSlipId;

        return lastPackingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingIntrastat</Name>
				<Source><![CDATA[
    void deleteExistingIntrastat(IntrastatDispatchId _dispatchId)
    {
        Intrastat   myIntrastat;

        delete_from myIntrastat
            where myIntrastat.DispatchId == _dispatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog box can be built by using the <c>Dialog</c> class or by using a class that is created in
    ///    the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        dialog = this.dialogInternal(dialog, true);

        dialogFreeTextInvoice   = dialog.addFieldValue(enumStr(NoYes), this.freeTextInvoice(), "@SYS23028");

        dialogCustInvoice   = dialog.addFieldValue(enumStr(NoYes), this.custInvoice(), "@SYS6486");
        dialogCustPckSlp    = dialog.addFieldValue(enumStr(NoYes), this.custPckslp(), "@SYS10319");

        dialogVendInvoice   = dialog.addFieldValue(enumStr(NoYes), this.vendInvoice(), "@SYS3179");
        dialogVendPckSlp    = dialog.addFieldValue(enumStr(NoYes), this.vendPckSlp(), "@SYS15402");

        dialogProjInvoice   = dialog.addFieldValue(enumStr(NoYes), this.projInvoice(), "@SYS10619");

        dialogInventTransfer = dialog.addFieldValue(enumStr(NoYes), this.inventTransfer(), "@SYS78234");

        // <GLS>
        if (this.allowRunBaseQuery())
        {
            // </GLS>
            dialog.addMenuItemButton(MenuItemType::Display, menuitemDisplayStr(RunBaseQueryDialog), DialogMenuItemGroup::BottomGrp);
            // <GLS>
        }
        // </GLS>
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ok = super();

        freeTextInvoice = dialogFreeTextInvoice.value();
        custInvoice     = dialogCustInvoice.value();
        custPckSlp      = dialogCustPckSlp.value();
        vendInvoice     = dialogVendInvoice.value();
        vendPckSlp      = dialogVendPckSlp.value();
        projInvoice     = dialogProjInvoice.value();
        inventTransfer  = dialogInventTransfer.value();

        if (!this.isAnyOptionSelected())
        {
            throw error("@SYS27391");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyOptionSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the user has selected any option in the dialog box.
    /// </summary>
    /// <returns>true if selected; otherwise, false.</returns>
    protected boolean isAnyOptionSelected()
    {
        return freeTextInvoice
            || custInvoice
            || custPckSlp
            || vendInvoice
            || vendPckSlp
            || projInvoice
            || inventTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowRunBaseQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>runbase</c> query can be modified in runtime by user.
    /// </summary>
    /// <returns>
    /// true if it is allowed; otherwise, false.
    /// </returns>
    protected boolean allowRunBaseQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>alignSigns</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Aligns the sign of the values in the <c>Intrastat</c> table buffer.
    /// </summary>
    /// <param name="_intrastat">
    ///     The <c>Intrastat</c> table buffer.
    /// </param>
    /// <param name="_commonSign">
    ///     The sign of the values.
    /// </param>
    protected void alignSigns(Intrastat _intrastat, real _commonSign)
    {
        _intrastat.AmountMST = _commonSign * _intrastat.AmountMST;
        _intrastat.StatisticalValue = _commonSign * _intrastat.StatisticalValue;
        _intrastat.Markup = _commonSign * _intrastat.Markup;
        _intrastat.InvoiceMarkupMST = _commonSign * _intrastat.InvoiceMarkupMST;

        _intrastat.Qty = _commonSign * _intrastat.Qty;
        _intrastat.Weight = _commonSign * _intrastat.Weight;
        _intrastat.AdditionalUnits = _commonSign * _intrastat.AdditionalUnits;

        _intrastat.Consignments = real2int(sign(_intrastat.AmountMST)) * _intrastat.Consignments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCustInvoiceJourAccountNum</Name>
				<Source><![CDATA[
    protected CustAccount calcCustInvoiceJourAccountNum(CustInvoiceJour _custInvoiceJour)
    {
        return _custInvoiceJour.OrderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicePackingSlipFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates part of the invoice that was delivered with packing slip.
    /// </summary>
    /// <param name="_headerSource">
    /// <c>CustVendInvoiceJour</c> buffer.
    /// </param>
    /// <param name="_lineSource">
    /// <c>CustVendInvoiceTrans</c> buffer.
    /// </param>
    /// <returns>
    /// Part of the invoice that was delivered with packing slip.
    /// </returns>
    /// <remarks>
    /// If there is no packing slip returns 1.
    /// </remarks>
    protected real calcInvoicePackingSlipFactor(CustVendInvoiceJour _headerSource, CustVendInvoiceTrans _lineSource)
    {
        real factor = 1;

        if (_lineSource.Qty && this.isPackingSlipAvailable(_headerSource, _lineSource))
        {
            factor = abs(_lineSource.QtyPhysical / _lineSource.Qty);
        }

        return factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCustPckSlipJourAccountNum</Name>
				<Source><![CDATA[
    protected CustAccount calcCustPckSlipJourAccountNum(CustPackingSlipJour _custPackingSlipJour)
    {
        return _custPackingSlipJour.OrderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFreeCustInvoiceJourAccountNum</Name>
				<Source><![CDATA[
    protected CustAccount calcFreeCustInvoiceJourAccountNum(CustInvoiceJour _custInvoiceJour)
    {
        return _custInvoiceJour.OrderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcProjInvoiceJourAccountNum</Name>
				<Source><![CDATA[
    protected CustAccount calcProjInvoiceJourAccountNum(ProjInvoiceJour _projInvoiceJour)
    {
        return _projInvoiceJour.OrderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCustVendInvoiceTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the invoice quantity.
    /// </summary>
    /// <param name="_headerSource">
    /// <c>CustVendInvoiceJour</c> buffer.
    /// </param>
    /// <param name="_lineSource">
    /// <c>CustVendInvoiceTrans</c> buffer.
    /// </param>
    /// <param name="_outputInAdditionalUnit">
    /// Flag indicates that quantity should be converted into additional units; optional.
    /// </param>
    /// <returns>
    /// Invoice quantity.
    /// </returns>
    public Qty calcCustVendInvoiceTransQty(CustVendInvoiceJour _headerSource,
                                              CustVendInvoiceTrans _lineSource,
                                              boolean _outputInAdditionalUnit = false)
    {
        UnitOfMeasureSymbol unit;
        Qty qty;

        if (this.isPackingSlipAvailable(_headerSource, _lineSource))
        {
            qty = _lineSource.QtyPhysical;
            unit = _lineSource.Unit;
        }
        else
        {
            if (_lineSource.StockedProduct)
            {
                qty = _lineSource.InventQty;
                unit = '';
            }
            else
            {
                qty = _lineSource.Qty;

                if (!qty) // free text or vendor journal invoice could be created without quantity
                {
                    qty = sign(_lineSource.LineAmount);
                }

                unit = _lineSource.Unit;
            }
        }

        return _lineSource.IntrastatTransferMap::qty(qty, unit, _outputInAdditionalUnit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVendInvoiceJourAccountNum</Name>
				<Source><![CDATA[
    protected CustAccount calcVendInvoiceJourAccountNum(VendInvoiceJour _vendInvoiceJour)
    {
        return _vendInvoiceJour.OrderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVendPckSlipJourAccountNum</Name>
				<Source><![CDATA[
    protected VendAccount calcVendPckSlipJourAccountNum(VendPackingSlipJour _vendPackingSlipJour)
    {
        return _vendPackingSlipJour.OrderAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemQty</Name>
				<Source><![CDATA[
    protected boolean checkItemQty(
        NoYes _pckSlip,
        SalesQty _qty,
        Intrastat _intrastat,
        CustVendInvoiceJour _headerSource = null,
        CustVendInvoiceTrans _lineSource = null)
    {
        boolean ret = true;

        if (_pckSlip && this.isPackingSlipAvailable(
            _headerSource, 
            _lineSource, 
            _pckSlip && _lineSource.TableId == tableNum(CustInvoiceTrans),
            _pckSlip && _lineSource.TableId == tableNum(VendInvoiceTrans)))
        {
            ret = _qty != 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportDeliveryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets delivery postal address for dispatches.
    /// </summary>
    /// <param name="_orderAccount">
    /// Customer order account.
    /// </param>
    /// <param name="_postalAddressRecId">
    /// Record ID of the delivery postal address; optional.
    /// </param>
    /// <param name="_salesType">
    /// Type of the order.
    /// </param>
    /// <param name="_inventTransId">
    /// Inventory lot id.
    /// </param>
    /// <returns>
    /// <c>LogisticsPostalAddress</c> buffer.
    /// </returns>
    protected LogisticsPostalAddress exportDeliveryPostalAddress(CustAccount _orderAccount,
                                                                LogisticsPostalAddressRecId _postalAddressRecId = 0,
                                                                SalesType _salesType = SalesType::Sales,
                                                                InventTransId _inventTransId = '')
    {
        SalesLine returnedSalesLine;
        LogisticsPostalAddress postalAddress;

        if (_salesType == SalesType::ReturnItem)
        {
            returnedSalesLine = SalesLine::findInventTransId(_inventTransId);

            if (returnedSalesLine.InventTransIdReturn)
            {
                postalAddress = this.postalAddress(SalesLine::findInventTransId(returnedSalesLine.InventTransIdReturn).DeliveryPostalAddress);
            }
            else
            {
                postalAddress = this.primaryPostalAddress(this.getCustTable(_orderAccount).Party);
            }
        }
        else
        {
            if (_postalAddressRecId)
            {
                postalAddress = this.postalAddress(_postalAddressRecId);
            }
            else
            {
                postalAddress = this.primaryPostalAddress(this.getCustTable(_orderAccount).Party);
            }
        }

        return postalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportInvoicePostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets invoice postal address for dispatches.
    /// </summary>
    /// <param name="_invoiceAccount">
    /// Customer invoice account.
    /// </param>
    /// <param name="_invoicePostalAddressRecId">
    /// Record ID of the invoice postal address; optional.
    /// </param>
    /// <returns>
    /// <c>LogisticsPostalAddress</c> buffer.
    /// </returns>
    protected LogisticsPostalAddress exportInvoicePostalAddress(CustAccount _invoiceAccount,
                                                                LogisticsPostalAddressRecId _invoicePostalAddressRecId = 0)
    {
        LogisticsPostalAddress postalAddress;

        if (_invoicePostalAddressRecId)
        {
            postalAddress = this.postalAddress(_invoicePostalAddressRecId);
        }
        else
        {
            postalAddress = this.primaryPostalAddress(this.getCustTable(_invoiceAccount).Party);
        }

        return postalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an export transaction needs to be included into <c>Intrastat</c>.
    /// </summary>
    /// <param name="_dlvCountryRegion">
    /// CountryRegionId of delivery country.
    /// </param>
    /// <param name="_refNum">
    /// RefNum of the transaction.
    /// </param>
    /// <param name="_countryRegionOfShipment">
    /// CountryRegionId of shipment country.
    /// </param>
    /// <param name="_invoiceCountryRegion">
    /// CountryRegionId of invoice country.
    /// </param>
    /// <param name="_dlvType">
    /// Delivery type of the transaction.
    /// </param>
    /// <param name="_trnasportDocumentCountryRegion">
    /// Transportation document of the transcation.
    /// </param>
    /// <param name="_orderType">
    /// <c>IntrastatOrderType</c> of the transaction.
    /// </param>
    /// <returns>
    /// true if the transactions needs to be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncluded(LogisticsAddressCountryRegionId   _dlvCountryRegion,
                                       RefNum                            _refNum                     = RefNum::SalesOrder,
                                       LogisticsAddressCountryRegionId   _countryRegionOfShipment    = '',
                                       LogisticsAddressCountryRegionId   _invoiceCountryRegion       = '',
                                       TradeLineDlvTypeId                _dlvType                    = TradeLineDlvType::None,
                                       LogisticsAddressCountryRegionId   _transportDocumentCountryRegion = '',
                                       IntrastatOrderType                _orderType                  = IntrastatOrderType::Order)
    {
        if ((_refNum != RefNum::SalesOrder &&  _refNum != RefNum::Cust ) && _refNum)
        {
            return false;
        }

        if (_dlvType == TradeLineDlvType::DropShip)
        {
            return this.exportToBeIncludedDropShip(_countryRegionOfShipment, _dlvCountryRegion);
        }

        if (this.isCountryRegionStateInEU(deliveryPostalAddress)
                || (!_dlvCountryRegion
                    && this.isCountryRegionStateInEU(invoicePostalAddress)))
        {
            if (_transportDocumentCountryRegion == ''
                    || this.isCountryRegionStateInEU(transportDocumentPostalAddress))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            if (this.isCountryRegionStateInEU(transportDocumentPostalAddress))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedDropShip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an export transaction needs to be included into <c>Intrastat</c> in case of direct Delivery.
    /// </summary>
    /// <param name="_countryRegionOfShipment">
    /// CountryRegionId of shipment country.
    /// </param>
    /// <param name="_dlvCountryRegion">
    /// CountryRegionId of delivery country.
    /// </param>
    /// <returns>
    /// true if the transactions needs to be included; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean exportToBeIncludedDropShip(LogisticsAddressCountryRegionId _countryRegionOfShipment, LogisticsAddressCountryRegionId _dlvCountryRegion)
    {
        return (this.isDomesticCache(_countryRegionOfShipment)
            && this.isCountryRegionStateInEU(deliveryPostalAddress));
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedCustFreeInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a free text invoice transaction must be included into the <c>Intrastat</c>
    /// transaction.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> involved.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// The customer invoice transaction.
    /// </param>
    /// <returns>
    /// true if the transactions must be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncludedCustFreeInvoiceTrans(
        CustInvoiceJour         _custInvoiceJour,
        CustInvoiceTrans        _custInvoiceTrans)
    {
        IntrastatOrderType      orderType;

        deliveryPostalAddress = this.exportDeliveryPostalAddress(_custInvoiceJour.OrderAccount, _custInvoiceTrans.DeliveryPostalAddress ? _custInvoiceTrans.DeliveryPostalAddress : _custInvoiceJour.DeliveryPostalAddress);
        invoicePostalAddress = this.exportInvoicePostalAddress(_custInvoiceJour.InvoiceAccount, _custInvoiceJour.InvoicePostalAddress);
        transportDocumentPostalAddress = this.postalAddress(TransportationDocument::find(_custInvoiceJour.TransportationDocument).LoadedPostalAddress);

        orderType = this.getOrderType(ModuleCustVend::Cust,
                                    _custInvoiceTrans.Qty,
                                    _custInvoiceTrans.TransactionCode,
                                    intrastatParm.DefaultCreditNote);
        stateIdOfShipment = _custInvoiceTrans.StateOfShipment;

        return this.checkCustomerPrimaryAddress(_custInvoiceJour.OrderAccount) &&
               this.exportToBeIncluded(deliveryPostalAddress.CountryRegionId,
                                        _custInvoiceJour.RefNum,
                                        _custInvoiceTrans.CountryRegionOfShipment,
                                        invoicePostalAddress.CountryRegionId,
                                        _custInvoiceTrans.DeliveryType,
                                        transportDocumentPostalAddress.CountryRegionId,
                                        orderType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a <c>CustInvoiceTrans</c> must be included into the <c>Intrastat</c> transaction.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> involved.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// The customer invoice transaction involved.
    /// </param>
    /// <returns>
    /// true if the transactions must be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncludedCustInvoiceTrans(
        CustInvoiceJour         _custInvoiceJour,
        CustInvoiceTrans        _custInvoiceTrans)
    {
        IntrastatOrderType      orderType;

        deliveryPostalAddress = this.exportDeliveryPostalAddress(_custInvoiceJour.OrderAccount,
                                                                 _custInvoiceTrans.DeliveryPostalAddress,
                                                                 _custInvoiceJour.SalesType,
                                                                 _custInvoiceTrans.InventTransId);

        invoicePostalAddress = this.exportInvoicePostalAddress(_custInvoiceJour.InvoiceAccount, _custInvoiceJour.InvoicePostalAddress);

        transportDocumentPostalAddress = this.postalAddress(TransportationDocument::find(_custInvoiceJour.TransportationDocument).LoadedPostalAddress);

        orderType = this.getOrderType(ModuleCustVend::Cust,
                                        _custInvoiceTrans.Qty,
                                        _custInvoiceTrans.TransactionCode,
                                        intrastatParm.DefaultCreditNote);
        stateIdOfShipment = _custInvoiceTrans.StateOfShipment;

        return this.checkCustomerPrimaryAddress(_custInvoiceJour.OrderAccount) &&
               this.exportToBeIncluded(deliveryPostalAddress.CountryRegionId,
                                        _custInvoiceJour.RefNum,
                                        _custInvoiceTrans.CountryRegionOfShipment,
                                        invoicePostalAddress.CountryRegionId,
                                        _custInvoiceTrans.DeliveryType,
                                        transportDocumentPostalAddress.CountryRegionId,
                                        orderType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedCustPckSlipTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a <c>CustPackingSlipTrans</c> must be included into the <c>Intrastat</c>
    /// transaction.
    /// </summary>
    /// <param name="_custPackingSlipJour">
    /// The <c>CustPackingSlipJour</c> involved.
    /// </param>
    /// <param name="_custPackingSlipTrans">
    /// The <c>CustPackingSlipTrans</c> involved.
    /// </param>
    /// <returns>
    /// true if the transactions must be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncludedCustPckSlipTrans(
        CustPackingSlipJour     _custPackingSlipJour,
        CustPackingSlipTrans    _custPackingSlipTrans)
    {
        IntrastatOrderType      orderType;

        deliveryPostalAddress = this.exportDeliveryPostalAddress(_custPackingSlipJour.OrderAccount,
                                                                _custPackingSlipTrans.DeliveryPostalAddress,
                                                                _custPackingSlipJour.SalesType,
                                                                _custPackingSlipTrans.InventTransId);

        invoicePostalAddress = this.exportInvoicePostalAddress(_custPackingSlipJour.InvoiceAccount, _custPackingSlipJour.InvoicePostalAddress);

        transportDocumentPostalAddress = this.postalAddress(TransportationDocument::find(_custPackingSlipJour.TransportationDocument).LoadedPostalAddress);

        orderType = this.getOrderType(ModuleCustVend::Cust,
                                  _custPackingSlipTrans.Qty,
                                  _custPackingSlipTrans.TransactionCode,
                                  intrastatParm.DefaultCreditNote);
        stateIdOfShipment = _custPackingSlipTrans.StateOfShipment;

        return this.checkCustomerPrimaryAddress(_custPackingSlipJour.OrderAccount) &&
               this.exportToBeIncluded(deliveryPostalAddress.CountryRegionId,
                                       _custPackingSlipJour.RefNum,
                                       _custPackingSlipTrans.CountryRegionOfShipment,
                                       invoicePostalAddress.CountryRegionId,
                                       _custPackingSlipTrans.DeliveryType,
                                       transportDocumentPostalAddress.CountryRegionId,
                                       orderType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedInventTransferJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the data from shipment part of the transfer order is to be included in the Intrastat.
    /// </summary>
    /// <param name="_inventTransferJour">
    /// The <c>InventTransferJour</c> buffer.
    /// </param>
    /// <param name="_inventTransferJourLine">
    /// The <c>InventTransferJourLine</c> buffer.
    /// </param>
    /// <returns>
    /// true if the data to be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncludedInventTransferJour(InventTransferJour _inventTransferJour, InventTransferJourLine _inventTransferJourLine)
    {
        if (_inventTransferJourLine.QtyShipped == 0)
        {
            return false;
        }

        if (!this.isInventLocationVendorExists(_inventTransferJour.InventLocationIdTo))
        {
            return false;
        }

        LogisticsPostalAddress postalAddressTo = this.postalAddress(_inventTransferJour.ToPostalAddress);
        LogisticsPostalAddress postalAddressFrom = this.postalAddress(_inventTransferJour.FromPostalAddress);
        
        deliveryPostalAddress = postalAddressTo;

        if (!this.exportToBeIncluded(postalAddressTo.CountryRegionId) ||
            !this.validateCompanyInfoCountryRegion(postalAddressFrom.CountryRegionId))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventLocationVendorExists</Name>
				<Source><![CDATA[
    protected boolean isInventLocationVendorExists(InventLocationIdTo _inventLocationId)
    {
        return this.getVendTable(this.getVendAccountFromInventLocationCache(_inventLocationId)).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedProjInvoiceItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a <c>ProjInvoiceItem</c> must be included into the <c>Intrastat</c> transaction.
    /// </summary>
    /// <param name="_projInvoiceJour">
    /// The project invoice journal involved.
    /// </param>
    /// <param name="_projInvoiceItem">
    /// The project invoice item involved.
    /// </param>
    /// <returns>
    /// true if the transactions must be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncludedProjInvoiceItem(ProjInvoiceJour         _projInvoiceJour,
                                                        ProjInvoiceItem         _projInvoiceItem)
    {
        IntrastatOrderType      orderType;

        deliveryPostalAddress = this.exportDeliveryPostalAddress(_projInvoiceJour.OrderAccount, _projInvoiceJour.DeliveryPostalAddress);
        invoicePostalAddress = this.exportInvoicePostalAddress(_projInvoiceJour.InvoiceAccount);
        transportDocumentPostalAddress = this.postalAddress(TransportationDocument::find(_projInvoiceJour.TransportationDocument).LoadedPostalAddress);

        orderType = this.getOrderType(ModuleCustVend::Cust,
                                        _projInvoiceItem.Qty,
                                        _projInvoiceItem.TransactionCode,
                                        intrastatParm.DefaultCreditNote);

        return this.checkCustomerPrimaryAddress(_projInvoiceJour.OrderAccount) &&
               this.exportToBeIncluded(deliveryPostalAddress.CountryRegionId,
                                    RefNum::SalesOrder,
                                    '',
                                    invoicePostalAddress.CountryRegionId,
                                    TradeLineDlvType::None,
                                    transportDocumentPostalAddress.CountryRegionId,
                                    orderType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportToBeIncludedProjInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a <c>ProjInvoiceJour</c> must be included into the <c>Intrastat</c> transaction.
    /// </summary>
    /// <param name="_projInvoiceJour">
    /// The project invoice journal involved.
    /// </param>
    /// <returns>
    /// true if the transactions must be included; otherwise, false.
    /// </returns>
    protected boolean exportToBeIncludedProjInvoiceJour(ProjInvoiceJour _projInvoiceJour)
    {

        SalesTable salesTable = ProjProposalJour::find(_projInvoiceJour.ProposalId).salesTable();
        if(!salesTable)
        {
            deliveryPostalAddress = this.exportDeliveryPostalAddress(_projInvoiceJour.OrderAccount, _projInvoiceJour.DeliveryPostalAddress);
        }
        else
        {
            deliveryPostalAddress = this.exportDeliveryPostalAddress(_projInvoiceJour.OrderAccount, salesTable.DeliveryPostalAddress);
        }

        invoicePostalAddress = this.exportInvoicePostalAddress(_projInvoiceJour.InvoiceAccount);

        return this.checkCustomerPrimaryAddress(_projInvoiceJour.OrderAccount) &&
               this.exportToBeIncluded(deliveryPostalAddress.CountryRegionId,
                                        RefNum::SalesOrder,
                                        '',
                                        invoicePostalAddress.CountryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDispatchId</Name>
				<Source><![CDATA[
    protected IntrastatDispatchId getDispatchId(IntrastatDirection _direction)
    {
        switch (_direction)
        {
            case IntrastatDirection::Import :       return this.getImportDispatchId();
            case IntrastatDirection::Export :       return this.getExportDispatchId();
        }
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExportDispatchId</Name>
				<Source><![CDATA[
    protected IntrastatDispatchId getExportDispatchId()
    {
        if (!numberExport)
        {
            return this.getNewExportDispatchId();
        }

        return numberExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImportDispatchId</Name>
				<Source><![CDATA[
    protected IntrastatDispatchId getImportDispatchId()
    {
        if (!numberImport)
        {
            return this.getNewImportDispatchId();
        }

        return numberImport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewExportDispatchId</Name>
				<Source><![CDATA[
    protected IntrastatDispatchId getNewExportDispatchId()
    {
        this.setUsedExportDispatchId();

        numberseqExport = NumberSeq::newGetNum(IntrastatParameters::numRefIntrastatDispatchId(),true);
        numberExport    = numberseqExport.num();

        this.deleteExistingIntrastat(numberExport);

        return numberExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewImportDispatchId</Name>
				<Source><![CDATA[
    protected IntrastatDispatchId getNewImportDispatchId()
    {
        this.setUsedImportDispatchId();

        numberseqImport = NumberSeq::newGetNum(IntrastatParameters::numRefIntrastatDispatchId(),true);
        numberImport    = numberseqImport.num();

        this.deleteExistingIntrastat(numberImport);

        return numberImport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextSeqNum</Name>
				<Source><![CDATA[
    protected IntrastatSeqNum getNextSeqNum(IntrastatDispatchId _dispatchId, IntrastatDirection _direction = IntrastatDirection::Import)
    {
        IntrastatSeqNum seqNum = Intrastat::maxNum(_dispatchId);

        IntrastatContext intrastatContext = IntrastatContext::current();
        if (intrastatContext)
        {
            intrastatContext.incCurrentSeqNumForDispatchId(_dispatchId);
        }

        return seqNum + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get order type of a transaction.
    /// </summary>
    /// <param name="_moduleCustVend">
    /// The module of the transaction.
    /// </param>
    /// <param name="_qty">
    /// Quantity of the transaction.
    /// </param>
    /// <param name="_transactionCode">
    /// The <c>TransactionCode</c> value of the transaction.
    /// </param>
    /// <param name="_returnOrderCode">
    /// The <c>TransactionCode</c> code predefined for return order.
    /// </param>
    /// <returns>
    /// The order type of the transaction.
    /// </returns>
    protected IntrastatOrderType getOrderType(ModuleCustVend             _moduleCustVend,
                                                Qty                        _qty,
                                                IntrastatTransactionCodeId _transactionCode,
                                                IntrastatTransactionCodeId _returnOrderCode)
    {
        if (_moduleCustVend == ModuleCustVend::Cust)
        {
            if (_qty >= 0)
            {
                return IntrastatOrderType::Order;
            }
            else
            {
                if (_transactionCode == _returnOrderCode)
                {
                    //return order from customer is deemed as import
                    return IntrastatOrderType::Return;
                }
                else
                {
                    return IntrastatOrderType::Correction;
                }
            }
        }
        else
        {
            if (_qty >= 0)
            {
                return IntrastatOrderType::Order;
            }
            else
            {
                if (_transactionCode == _returnOrderCode)
                {
                    //return order from vendor is deemed as export
                    return IntrastatOrderType::Return;
                }
                else
                {
                    return IntrastatOrderType::Correction;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSendRecvAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets sender or receiver address from input.
    /// </summary>
    /// <param name="_custVend">
    /// The type module to get the address for.
    /// </param>
    /// <param name="_intrastatOrderType">
    /// The type of intrastat order to get the address for.
    /// </param>
    /// <param name="_accountNum">
    /// The customer or vendor account number from journal transaction.
    /// </param>
    /// <param name="_transDelivAddressRecId">
    /// The delivery address record ID from journal transaction.
    /// </param>
    /// <param name="_transportDocumentAddressRecId">
    /// The address record ID of transaction document from journal transaction.
    /// </param>
    /// <returns>
    /// The desired sender or receiver address.
    /// </returns>
    protected LogisticsPostalAddress getSendRecvAddress(ModuleCustVend _custVend,
                                                        IntrastatOrderType _intrastatOrderType,
                                                        CustVendAC _accountNum,
                                                        RecId _transDelivAddressRecId = 0,
                                                        RecId _transportDocumentAddressRecId = 0)
    {
        LogisticsPostalAddress retAddress;
        RecId retAddressRecId = 0;

        if (_custVend == ModuleCustVend::Cust)
        {
            switch (_intrastatOrderType)
            {
                case IntrastatOrderType::Return :
                    retAddressRecId = _transportDocumentAddressRecId;
                    if (retAddressRecId == 0)
                    {
                        retAddress = this.primaryPostalAddress(this.getCustTable(_accountNum).Party);
                    }
                    else
                    {
                        retAddress = this.postalAddress(retAddressRecId);
                    }
                    break;

                default :
                    retAddress = primaryPostalAddressForCurrentCompany;
            }
        }
        else
        {
            switch (_intrastatOrderType)
            {
                case IntrastatOrderType::Correction :
                case IntrastatOrderType::Order :
                    retAddressRecId = _transportDocumentAddressRecId;
                    break;
            }
            if (retAddressRecId == 0)
            {
                retAddress = this.primaryPostalAddress(this.getVendTable(_accountNum).Party);
            }
            else
            {
                retAddress = this.postalAddress(retAddressRecId);
            }
        }

        return retAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importToBeIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an accounts payable transaction line needs to be included in Intrastat.
    /// </summary>
    /// <param name="_account">
    /// Vendor account number on the transaction line.
    /// </param>
    /// <param name="_countryRegion">
    /// Destination country region of the accounts payable transaction.
    /// </param>
    /// <param name="_transportDocumentCountryRegion">
    /// Country region on the transportation of the accounts payable transaction.
    /// </param>
    /// <returns>
    /// true if the accounts payable transaction needs to be included in Intrastat; otherwise, false.
    /// </returns>
    protected boolean importToBeIncluded(VendAccount              _account,
                               LogisticsAddressCountryRegionId    _countryRegion,
                               LogisticsAddressCountryRegionId    _transportDocumentCountryRegion = ''
                               )
    {
        /*
        If the country/region on the Buy-From-Vendor is an EU country/region and the country/region to be delivered
        to is equal to the company country/region, the order is reported to Intrastat.
        */
        if (this.validateCompanyInfoCountryRegion(_countryRegion))
        {
            if (shipmentAddressRecIdBuffer)
            {
                LogisticsPostalAddress shipmentAddress = this.shipmentPostalAddress(shipmentAddressRecIdBuffer);

                return this.isCountryRegionStateInEU(shipmentAddress);
            }

            if (_account == '' || this.isCountryRegionStateInEU(this.primaryPostalAddress(this.getVendTable(_account).Party)))
            {
                if (_transportDocumentCountryRegion == ''
                    || this.isCountryRegionStateInEU(transportDocumentPostalAddress))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                if (this.isCountryRegionStateInEU(transportDocumentPostalAddress))
                {
                    return true;
                }

                return false;
            }
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCompanyInfoCountryRegion</Name>
				<Source><![CDATA[
    protected boolean validateCompanyInfoCountryRegion(LogisticsAddressCountryRegionId _countryRegion)
    {
        return _countryRegion == primaryPostalAddressForCurrentCompany.CountryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importToBeIncludedInventTransferJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the data from receiving part of the transfer order is to be included in the Intrastat.
    /// </summary>
    /// <param name="_inventTransferJour">
    /// The <c>InventTransferJour</c> buffer.
    /// </param>
    /// <param name="_inventTransferJourLine">
    /// The <c>InventTransferJourLine</c> buffer.
    /// </param>
    /// <returns>
    /// true if the data to be included; otherwise, false.
    /// </returns>
    protected boolean importToBeIncludedInventTransferJour(InventTransferJour _inventTransferJour, InventTransferJourLine _inventTransferJourLine)
    {
        if (_inventTransferJourLine.QtyReceived < _inventTransferJourLine.QtyScrapped)
        {
            return false;
        }

        if (!this.isInventLocationVendorExists(_inventTransferJour.InventLocationIdFrom))
        {
            return false;
        }

        LogisticsPostalAddress postalAddressTo = this.postalAddress(_inventTransferJour.ToPostalAddress);
        LogisticsPostalAddress postalAddressFrom = this.postalAddress(_inventTransferJour.FromPostalAddress);
        VendTable vendTable = this.getVendTable(this.getVendAccountFromInventLocationCache(_inventTransferJour.InventLocationIdFrom));

        if (postalAddressFrom.CountryRegionId == postalAddressTo.CountryRegionId
            || !this.validateCompanyInfoCountryRegion(postalAddressTo.CountryRegionId)
            || !this.importToBeIncluded(vendTable.AccountNum, postalAddressTo.CountryRegionId))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importToBeIncludedVendInvoiceIntrastat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a <c>VendInvoiceIntrastat</c> line needs to be included in Intrastat.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// <c>VendInvoiceJour</c> record related to the <c>VendInvoiceIntrastat</c> line.
    /// </param>
    /// <returns>
    /// true if the <c>VendInvoiceIntrastat</c> line needs to be included in Intrastat; otherwise, false.
    /// </returns>
    protected boolean importToBeIncludedVendInvoiceIntrastat(VendInvoiceJour _vendInvoiceJour)
    {
        return this.importToBeIncluded(_vendInvoiceJour.OrderAccount, primaryPostalAddressForCurrentCompany.CountryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>importToBeIncludedVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a <c>VendInvoiceTrans</c> line needs to be included in Intrastat.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// <c>VendInvoiceJour</c> record related to the <c>VendInvoiceTrans</c> line.
    /// </param>
    /// <param name="_vendInvoiceTrans">
    /// The <c>VendInvoiceTrans</c> line to be included.
    /// </param>
    /// <returns>
    /// true if the <c>VendInvoiceTrans</c> line needs to be included in Intrastat; otherwise, false.
    /// </returns>
    protected boolean importToBeIncludedVendInvoiceTrans(VendInvoiceJour     _vendInvoiceJour,
                                                         VendInvoiceTrans    _vendInvoiceTrans)
    {
        transportDocumentPostalAddress = this.postalAddress(TransportationDocument::find(_vendInvoiceJour.TransportationDocument).LoadedPostalAddress);

        LogisticsAddressCountryRegionId locCountryRegionId = transportDocumentPostalAddress.CountryRegionId;

        return this.importToBeIncluded(_vendInvoiceJour.OrderAccount,
                                        this.importDestinationAddressCountry(_vendInvoiceTrans.DestCountryRegionId,
                                                                            _vendInvoiceJour.PurchaseType,
                                                                            _vendInvoiceTrans.InventRefType,
                                                                            _vendInvoiceTrans.InventRefTransId,
                                                                            _vendInvoiceTrans.inventDim()),
                                                                            locCountryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>importToBeIncludedVendPckSlipTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a <c>VendPackingSlipTrans</c> line needs to be included in Intrastat.
    /// </summary>
    /// <param name="_vendPackingSlipJour">
    /// <c>VendPackingSlipJour</c> record related to the <c>VendPackingSlipTrans</c> line.
    /// </param>
    /// <param name="_vendPackingSlipTrans">
    /// The <c>VendPackingSlipTrans</c> line to be included.
    /// </param>
    /// <returns>
    /// true if the <c>VendPackingSlipTrans</c> line needs to be included in Intrastat; otherwise, false.
    /// </returns>
    protected boolean importToBeIncludedVendPckSlipTrans(VendPackingSlipJour     _vendPackingSlipJour,
                                                         VendPackingSlipTrans    _vendPackingSlipTrans)
    {
        transportDocumentPostalAddress = this.postalAddress(TransportationDocument::find(_vendPackingSlipJour.TransportationDocument).LoadedPostalAddress);

        LogisticsAddressCountryRegionId locCountryRegionId = transportDocumentPostalAddress.CountryRegionId;

        return this.importToBeIncluded(_vendPackingSlipJour.OrderAccount,
                                       this.importDestinationAddressCountry(_vendPackingSlipTrans.DestCountryRegionId,
                                                                            _vendPackingSlipJour.PurchaseType,
                                                                            _vendPackingSlipTrans.InventRefType,
                                                                            _vendPackingSlipTrans.InventRefTransId,
                                                                            _vendPackingSlipTrans.inventDim()),
                                                                            locCountryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDirectionAndOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the direction and order type of an <c>Intrastat</c> transaction.
    /// </summary>
    /// <param name="_moduleCustVend">
    /// The module of the transaction.
    /// </param>
    /// <param name="_qty">
    /// Quantity of the transaction.
    /// </param>
    /// <param name="_intrastat">
    /// The <c>Intrastat</c> transaction to initialize.
    /// </param>
    /// <param name="_transactionCode">
    /// The <c>TransactionCode</c> value of the transaction.
    /// </param>
    /// <param name="_isReturnItem">
    /// Indicates that order type is return order; optional.
    /// </param>///
    protected void initDirectionAndOrderType(ModuleCustVend             _moduleCustVend,
                                             Qty                        _qty,
                                             Intrastat                  _intrastat,
                                             IntrastatTransactionCodeId _transactionCode,
                                             boolean                    _isReturnItem = false)
    {
        if (_isReturnItem)
        {
            _intrastat.OrderType = _qty >= 0 ? IntrastatOrderType::Order : IntrastatOrderType::Return;
        }
        else
        {
            _intrastat.OrderType = this.getOrderType(_moduleCustVend, _qty, _transactionCode, intrastatParm.DefaultCreditNote);
        }

        if (_moduleCustVend == ModuleCustVend::Cust)
        {
            if (_intrastat.OrderType == IntrastatOrderType::Return)
            {
                _intrastat.Direction = IntrastatDirection::Import;
            }
            else
            {
                _intrastat.Direction = IntrastatDirection::Export;
            }
        }
        else
        {
            if (_intrastat.OrderType == IntrastatOrderType::Return)
            {
                _intrastat.Direction = IntrastatDirection::Export;
            }
            else
            {
                _intrastat.Direction = IntrastatDirection::Import;
            }
        }

        if (_intrastat.OrderType == IntrastatOrderType::Correction)
        {
            _intrastat.Correct = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from a <c>CustInvoiceTrans</c> line of a sales order.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// <c>CustInvoiceJour</c> record realted to the <c>CustInvoiceTrans</c> line.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// The source <c>CustInvoiceTrans</c> line.
    /// </param>
    /// <param name="_custInvoiceJour_Intrastat">
    /// The extension table record for <c>CustInvoiceJour</c> record.
    /// </param>
    /// <param name="_custInvoiceTrans_Intrastat">
    /// The extension table record for <c>CustInvoiceTrans</c> record.
    /// </param>
    /// <returns>
    /// The initalized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromCustInvoiceTrans(
        CustInvoiceJour             _custInvoiceJour,
        CustInvoiceTrans            _custInvoiceTrans,
        CustInvoiceJour_Intrastat   _custInvoiceJour_Intrastat = null,
        CustInvoiceTrans_Intrastat  _custInvoiceTrans_Intrastat = null)
    {
        Intrastat               intrastat;

        LogisticsPostalAddress  sendRecvAddr;

        intrastat.initValue();

        intrastat.TransDate            = _custInvoiceJour.InvoiceDate;
        intrastat.AccountNum           = this.calcCustInvoiceJourAccountNum(_custInvoiceJour);
        intrastat.DlvTerm              = _custInvoiceJour.DlvTerm;
        intrastat.DebCredType          = ModuleInventCustVend::Cust;

        intrastat.Qty                  = this.calcCustVendInvoiceTransQty(_custInvoiceJour, _custInvoiceTrans);

        this.calcAmountsAndMarkups(_custInvoiceJour, _custInvoiceTrans, intrastat);

        /* Unique reference */
        intrastat.TransTableId         = _custInvoiceTrans.TableId;
        intrastat.TransRecId           = _custInvoiceTrans.RecId;
        intrastat.UpdateNum            = _custInvoiceTrans.InvoiceId;

        intrastat.CountryRegionId      = deliveryPostalAddress.CountryRegionId;
        intrastat.State                = deliveryPostalAddress.State;
        intrastat.County               = deliveryPostalAddress.County;

        intrastat.PackingSlipId        = this.custVendInvoiceTransPackingSlipId(_custInvoiceTrans);

        SalesTable salesTable = _custInvoiceTrans.salesLine().salesTable();
        if (FeatureStateProvider::isFeatureEnabled(IntrastatTransferPartnerVATIDFeature::instance())
            && salesTable.InterCompanyDirectDeliveryOrig)
        {
            changecompany (salesTable.InterCompanyCompanyId)
            {
                CustTable custTableDD = CustTable::find(salesTable.InterCompanyOriginalCustAccount);
                VATNum postalVATNum = custTableDD.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, salesTable.DeliveryDate);
                intrastat.VATNum = this.getVATNum(custTableDD, intrastat.TransDate, deliveryPostalAddress, postalVATNum);
            }
        }
        else
        {
            intrastat.VATNum = this.getInvoiceVATNum(
                intrastat,
                _custInvoiceJour,
                deliveryPostalAddress);
        }

        this.initDirectionAndOrderType(ModuleCustVend::Cust, intrastat.Qty, intrastat, _custInvoiceTrans.TransactionCode, _custInvoiceJour.SalesType == SalesType::ReturnItem);

        intrastat.Category             = _custInvoiceTrans.SalesCategory;

        this.initIntrastatFromTransferMap(intrastat, _custInvoiceTrans);

        sendRecvAddr = this.getSendRecvAddress(ModuleCustVend::Cust,
                                                intrastat.OrderType,
                                                _custInvoiceJour.InvoiceAccount,
                                                _custInvoiceTrans.DeliveryPostalAddress,
                                                TransportationDocument::find(_custInvoiceJour.TransportationDocument).LoadedPostalAddress);

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromCustPckSlpTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an <c>Intrastat</c> line from a <c>CustPackingSlipTrans</c> line.
    /// </summary>
    /// <param name="_custPackingSlipJour">
    /// <c>CustPackingSlipJour</c> record realted to the <c>CustPackingSlipTrans</c> line.
    /// </param>
    /// <param name="_custPackingSlipTrans">
    /// The source <c>CustPackingSlipTrans</c> line.
    /// </param>
    /// <param name="_custPackingSlipJour_Intrastat">
    /// The extension table record for <c>CustPackingSlipJour</c> record.
    /// </param>
    /// <param name="_custPackingSlipTrans_Intrastat">
    /// The extension table record for <c>CustPackingSlipTrans</c> record.
    /// </param>
    /// <returns>
    /// The initialized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromCustPckSlpTrans(
        CustPackingSlipJour             _custPackingSlipJour,
        CustPackingSlipTrans            _custPackingSlipTrans,
        CustPackingSlipJour_Intrastat   _custPackingSlipJour_Intrastat = null,
        CustPackingSlipTrans_Intrastat  _custPackingSlipTrans_Intrastat = null)
    {
        Intrastat               intrastat;
        CustInvoiceTrans        custInvoiceTrans;

        LogisticsPostalAddress  sendRecvAddr;

        intrastat.initValue();

        intrastat.TransDate         = _custPackingSlipJour.DeliveryDate;
        intrastat.AccountNum        = this.calcCustPckSlipJourAccountNum(_custPackingSlipJour);
        intrastat.DlvTerm           = _custPackingSlipJour.DlvTerm;
        intrastat.DebCredType       = ModuleInventCustVend::Cust;

        /* Unique reference */
        intrastat.TransTableId      = _custPackingSlipTrans.TableId;
        intrastat.TransRecId        = _custPackingSlipTrans.RecId;
        intrastat.UpdateNum         = _custPackingSlipTrans.PackingSlipId;

        intrastat.CountryRegionId   = deliveryPostalAddress.CountryRegionId;
        intrastat.State             = deliveryPostalAddress.State;
        intrastat.County            = deliveryPostalAddress.County;

        intrastat.Qty               = _custPackingSlipTrans.StockedProduct ? _custPackingSlipTrans.InventQty : _custPackingSlipTrans.Qty;

        this.calcAmountsAndMarkups(_custPackingSlipJour, _custPackingSlipTrans, intrastat);

        intrastat.PackingSlipId     = _custPackingSlipTrans.PackingSlipId;

        CustTable custTable = this.getCustTable(intrastat.AccountNum);

        VATNum postalVATNum = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _custPackingSlipJour.DeliveryDate);

        SalesTable salesTable = _custPackingSlipTrans.salesLine().salesTable();
        if (FeatureStateProvider::isFeatureEnabled(IntrastatTransferPartnerVATIDFeature::instance())
            && salesTable.InterCompanyDirectDeliveryOrig)
        {
            changecompany (salesTable.InterCompanyCompanyId)
            {
                CustTable custTableDD = CustTable::find(salesTable.InterCompanyOriginalCustAccount);
                postalVATNum = custTableDD.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _custPackingSlipJour.DeliveryDate);
                intrastat.VATNum = this.getVATNum(custTableDD, intrastat.TransDate, deliveryPostalAddress, postalVATNum);
            }
        }
        else
        {
            intrastat.VATNum = this.getVATNum(custTable, intrastat.TransDate, deliveryPostalAddress, postalVATNum);
        }
        this.initDirectionAndOrderType(ModuleCustVend::Cust, intrastat.Qty, intrastat, _custPackingSlipTrans.TransactionCode, _custPackingSlipJour.SalesType == SalesType::ReturnItem);

        intrastat.Category          = _custPackingSlipTrans.SalesCategory;

        this.initIntrastatFromTransferMap(intrastat, _custPackingSlipTrans);

        if (_custPackingSlipTrans.ItemId)
        {
            intrastat.InvoiceId = this.custPackingSlipInvoiceId(_custPackingSlipTrans);
        }
        else
        {
            //Description Based Line
            select InvoiceId from custInvoiceTrans
                where custInvoiceTrans.InventTransId == intrastat.InventTransId;

            if (custInvoiceTrans)
            {
                intrastat.InvoiceId = custInvoiceTrans.InvoiceId;
            }
        }

        sendRecvAddr = this.getSendRecvAddress(ModuleCustVend::Cust,
                                                intrastat.OrderType,
                                                _custPackingSlipJour.OrderAccount,
                                                _custPackingSlipTrans.DeliveryPostalAddress,
                                                TransportationDocument::find(_custPackingSlipJour.TransportationDocument).LoadedPostalAddress);

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromFreeCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from a <c>CustInvoiceTrans</c> line of a free text invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// <c>CustPackingSlipJour</c> record realted to the <c>CustPackingSlipTrans</c> line.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// The source <c>CustPackingSlipTrans</c> line.
    /// </param>
    /// <returns>
    /// The initalized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromFreeCustInvoiceTrans(CustInvoiceJour         _custInvoiceJour,
                                                              CustInvoiceTrans        _custInvoiceTrans)
    {
        Intrastat               intrastat;
        LogisticsPostalAddress  sendRecvAddr;

        intrastat.initValue();

        intrastat.TransDate             = _custInvoiceJour.InvoiceDate;
        intrastat.AccountNum            = this.calcFreeCustInvoiceJourAccountNum(_custInvoiceJour);
        intrastat.CountryRegionId       = deliveryPostalAddress.CountryRegionId;
        intrastat.State                 = deliveryPostalAddress.State;
        intrastat.County                = deliveryPostalAddress.County;
        intrastat.DlvTerm               = _custInvoiceJour.DlvTerm;
        intrastat.DebCredType           = ModuleInventCustVend::Cust;

        /* Unique reference */
        intrastat.TransTableId          = _custInvoiceTrans.TableId;
        intrastat.TransRecId            = _custInvoiceTrans.RecId;
        intrastat.UpdateNum             = _custInvoiceTrans.InvoiceId;
        intrastat.Qty                   = this.calcCustVendInvoiceTransQty(_custInvoiceJour, _custInvoiceTrans);

        this.calcAmountsAndMarkups(_custInvoiceJour, _custInvoiceTrans, intrastat);

        intrastat.VATNum = this.getInvoiceVATNum(
            intrastat,
            _custInvoiceJour,
            deliveryPostalAddress);

        this.initDirectionAndOrderType(ModuleCustVend::Cust, intrastat.Qty, intrastat, _custInvoiceTrans.TransactionCode);
        this.initIntrastatFromTransferMap(intrastat, _custInvoiceTrans);

        sendRecvAddr = this.getSendRecvAddress(ModuleCustVend::Cust,
                                                intrastat.OrderType,
                                                _custInvoiceJour.InvoiceAccount,
                                                _custInvoiceTrans.DeliveryPostalAddress,
                                                TransportationDocument::find(_custInvoiceJour.TransportationDocument).LoadedPostalAddress);

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromInventTransferJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes intrastat data from the transfer order.
    /// </summary>
    /// <param name="_direction">
    /// The direction of the transfer.
    /// </param>
    /// <param name="_inventTransferJour">
    /// The <c>InventTransferJour</c> buffer.
    /// </param>
    /// <param name="_inventTransferJourLine">
    /// The <c>InventTransferJourLine</c> buffer.
    /// </param>
    /// <returns>
    /// The <c>Intrastat</c> buffer.
    /// </returns>
    protected Intrastat initIntrastatFromInventTransferJour(
        IntrastatDirection      _direction,
        InventTransferJour      _inventTransferJour,
        InventTransferJourLine  _inventTransferJourLine)
    {
        Intrastat               intrastat;
        VendTable               vendTable;
        IntrastatParameters     intrastatParameters = IntrastatParameters::find();
        Qty                     qty;
        LogisticsPostalAddress postalAddressFrom = this.postalAddress(_inventTransferJour.FromPostalAddress);

        if (_direction == IntrastatDirection::Export)
        {
            deliveryPostalAddress = this.postalAddress(_inventTransferJour.ToPostalAddress);
            vendTable                  = this.getVendTable(this.getVendAccountFromInventLocationCache(_inventTransferJour.InventLocationIdTo));
            qty                        = abs(_inventTransferJourLine.QtyShipped);
        }
        else
        {
            deliveryPostalAddress      = postalAddressFrom;
            vendTable                  = this.getVendTable(this.getVendAccountFromInventLocationCache(_inventTransferJour.InventLocationIdFrom));
            qty                        = abs(_inventTransferJourLine.QtyReceived - _inventTransferJourLine.QtyScrapped);
        }

        intrastat.clear();
        intrastat.initValue();

        intrastat.TransDate            = _inventTransferJour.TransDate;
        intrastat.DlvTerm              = _inventTransferJour.DlvTermId ? _inventTransferJour.DlvTermId : intrastatParameters.DlvTermParm;
        intrastat.DebCredType          = ModuleInventCustVend::Invent;

        intrastat.CountryRegionId      = deliveryPostalAddress.CountryRegionId;
        intrastat.State                = deliveryPostalAddress.State;
        intrastat.County               = deliveryPostalAddress.County;

        intrastat.UpdateNum            = _inventTransferJour.TransferId;

        intrastat.vatNum               = vendTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _inventTransferJour.TransDate);

        /* Unique reference */
        intrastat.TransTableId         = _inventTransferJourLine.TableId;
        intrastat.TransRecId           = _inventTransferJourLine.RecId;

        [intrastat.AmountMST, intrastat.StatisticalValue]          = this.getTransferOrderValue(_direction, _inventTransferJourLine);

        intrastat.Qty                  = _inventTransferJourLine.IntrastatTransferMap::qty(qty, _inventTransferJourLine.UnitId);

        intrastat.InventTransId        = _inventTransferJourLine.InventTransId;

        this.initDirectionAndOrderType(_direction == IntrastatDirection::Export ? ModuleCustVend::Cust : ModuleCustVend::Vend,
                                        intrastat.Qty,
                                        intrastat,
                                        _inventTransferJourLine.TransactionCode);

        this.initIntrastatFromTransferMap(intrastat, _inventTransferJourLine);

        if (_inventTransferJourLine.IntrastatCommodity)
        {
            intrastat.IntrastatCommodity = _inventTransferJourLine.IntrastatCommodity;
        }

        if (_inventTransferJourLine.OrigCountryRegionId)
        {
            intrastat.OrigCountryRegionId = _inventTransferJourLine.OrigCountryRegionId;
        }

        if (_inventTransferJourLine.OrigStateId)
        {
            intrastat.OrigState = _inventTransferJourLine.OrigStateId;
        }

        if (_inventTransferJourLine.OrigCountyId)
        {
            intrastat.OrigCounty = _inventTransferJourLine.OrigCountyId;
        }

        intrastat.SendReceiveCountryRegionId    = postalAddressFrom.CountryRegionId;
        intrastat.SendReceiveState              = postalAddressFrom.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromProjInvoiceItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from a <c>ProjInvoiceItem</c> line
    /// </summary>
    /// <param name="_projInvoiceJour">
    /// <c>ProjInvoiceJour</c> record realted to the <c>ProjInvoiceItem</c> line.
    /// </param>
    /// <param name="_projInvoiceItem">
    /// The source <c>ProjInvoiceItem</c> line.
    /// </param>
    /// <returns>
    /// The initalized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromProjInvoiceItem(
        ProjInvoiceJour         _projInvoiceJour,
        ProjInvoiceItem         _projInvoiceItem)
    {
        Intrastat               intrastat;
        LogisticsPostalAddress  sendRecvAddr;

        intrastat.initValue();

        intrastat.TransDate         = _projInvoiceJour.InvoiceDate;
        intrastat.AccountNum        = this.calcProjInvoiceJourAccountNum(_projInvoiceJour);
        intrastat.DlvTerm           = _projInvoiceJour.DlvTerm;
        intrastat.DebCredType       = ModuleInventCustVend::Cust;

        intrastat.CountryRegionId   = deliveryPostalAddress.CountryRegionId;
        intrastat.State             = deliveryPostalAddress.State;
        intrastat.County            = deliveryPostalAddress.County;

        /* Unique reference */
        intrastat.TransTableId      = _projInvoiceItem.TableId;
        intrastat.TransRecId        = _projInvoiceItem.RecId;
        intrastat.UpdateNum         = _projInvoiceItem.ProjInvoiceId;
        intrastat.Qty               = _projInvoiceItem.IntrastatTransferMap::qty(abs(_projInvoiceItem.Qty), _projInvoiceItem.Salesunit);

        this.calcAmountsAndMarkups(_projInvoiceJour, _projInvoiceItem, intrastat);

        CustTable custTable = this.getCustTable(intrastat.AccountNum);

        VATNum postalVATNum = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _projInvoiceJour.InvoiceDate);

        intrastat.VATNum = this.getVATNum(custTable, intrastat.TransDate, deliveryPostalAddress, postalVATNum);
        this.initDirectionAndOrderType(ModuleCustVend::Cust, intrastat.Qty, intrastat, _projInvoiceItem.TransactionCode, _projInvoiceItem.salesLine().SalesType == SalesType::ReturnItem);

        intrastat.Category          = SalesLine::findInventTransId(_projInvoiceItem.InventTransId).SalesCategory;

        this.initIntrastatFromTransferMap(intrastat,  _projInvoiceItem);

        sendRecvAddr = this.getSendRecvAddress(ModuleCustVend::Cust,
                                            intrastat.OrderType,
                                            _projInvoiceJour.InvoiceAccount,
                                            _projInvoiceJour.DeliveryPostalAddress,
                                            TransportationDocument::find(_projInvoiceJour.TransportationDocument).LoadedPostalAddress);

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromVendInvoiceIntrastat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from a <c>VendInvoiceIntrastat</c> line of a free text invoice.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// <c>VendInvoiceJour</c> record realted to the <c>VendInvoiceIntrastat</c> line.
    /// </param>
    /// <param name="_vendInvoiceIntrastat">
    /// The source <c>VendInvoiceIntrastat</c> line.
    /// </param>
    /// <returns>
    /// The initalized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromVendInvoiceIntrastat(
        VendInvoiceJour         _vendInvoiceJour,
        VendInvoiceIntrastat    _vendInvoiceIntrastat)
    {
        Intrastat               intrastat;
        LogisticsPostalAddress  sendRecvAddr;

        LogisticsPostalAddress vendPostalAddress = this.primaryPostalAddress(_vendInvoiceJour.vendTable_OrderAccount().Party);

        VendInvoiceTrans vendInvoiceTrans = VendInvoiceTrans::findVendInvoiceTrans(_vendInvoiceJour.PurchId,
                                                                                   _vendInvoiceJour.InvoiceId,
                                                                                   _vendInvoiceJour.InvoiceDate,
                                                                                   _vendInvoiceJour.numberSequenceGroup,
                                                                                   _vendInvoiceJour.InternalInvoiceId,
                                                                                   '');

        if (!vendInvoiceTrans)
        {
            vendInvoiceTrans.InvoiceId = _vendInvoiceJour.InvoiceId;
            vendInvoiceTrans.InvoiceDate = _vendInvoiceJour.InvoiceDate;
            vendInvoiceTrans.CurrencyCode = _vendInvoiceJour.CurrencyCode;
            vendInvoiceTrans.LineAmount = _vendInvoiceJour.InvoiceAmount;
        }

        vendInvoiceTrans.LineAmountMST = _vendInvoiceJour.amountMST(vendInvoiceTrans.LineAmount);
        vendInvoiceTrans.TransactionCode = _vendInvoiceIntrastat.TransactionCode;

        intrastat.initValue();

        intrastat.TransDate             = _vendInvoiceJour.InvoiceDate;
        intrastat.AccountNum            = this.calcVendInvoiceJourAccountNum(_vendInvoiceJour);
        intrastat.CountryRegionId       = vendPostalAddress.CountryRegionId;
        intrastat.DlvTerm               = _vendInvoiceJour.DlvTerm;
        intrastat.DebCredType           = ModuleInventCustVend::Vend;

        intrastat.Qty                   = _vendInvoiceJour.Qty;

        this.calcAmountsAndMarkups(_vendInvoiceJour, vendInvoiceTrans, intrastat);

        intrastat.TransTableId          = _vendInvoiceJour.TableId;
        intrastat.TransRecId            = _vendInvoiceJour.RecId;
        intrastat.UpdateNum             = _vendInvoiceJour.InvoiceId;
        intrastat.IntrastatCommodity    = _vendInvoiceIntrastat.IntrastatCommodity;
        intrastat.ngpCodesTable_FR      = _vendInvoiceIntrastat.ngpCodesTable_FR;
        intrastat.OrigCountryRegionId   = _vendInvoiceIntrastat.OrigCountryRegionId;
        intrastat.OrigState             = _vendInvoiceIntrastat.OrigStateId;
        intrastat.InvoiceId             = _vendInvoiceJour.InvoiceId;

        intrastat.VATNum = this.getInvoiceVATNum(
            intrastat,
            _vendInvoiceJour,
            vendPostalAddress);

        intrastat.TransactionCode       = _vendInvoiceIntrastat.TransactionCode;
        intrastat.TransportMode         = _vendInvoiceIntrastat.Transport;
        intrastat.Port                  = _vendInvoiceIntrastat.Port;
        intrastat.StatProcId            = _vendInvoiceIntrastat.StatProcId;
        intrastat.AdditionalUnits       = _vendInvoiceIntrastat.IntraUnit;
        intrastat.State                 = vendPostalAddress.State;
        intrastat.County                = _vendInvoiceIntrastat.CountyOrigDest ? _vendInvoiceIntrastat.CountyOrigDest : vendPostalAddress.County;

        this.initDirectionAndOrderType(ModuleCustVend::Vend, sign(intrastat.AmountMST), intrastat, _vendInvoiceIntrastat.TransactionCode);

        if (shipmentAddressRecIdBuffer)
        {
            sendRecvAddr = this.shipmentPostalAddress(shipmentAddressRecIdBuffer);
        }
        else
        {
            sendRecvAddr = this.getSendRecvAddress(ModuleCustVend::Vend,
                                                    intrastat.OrderType,
                                                    _vendInvoiceJour.InvoiceAccount);
        }

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from a <c>VendInvoiceTrans</c> line.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// <c>VendInvoiceJour</c> record realted to the <c>VendInvoiceTrans</c> line.
    /// </param>
    /// <param name="_vendInvoiceTrans">
    /// The source <c>VendInvoiceTrans</c> line.
    /// </param>
    /// <param name="_vendInvoiceJour_Intrastat">
    /// The extension table record for <c>VendInvoiceJour</c> record.
    /// </param>
    /// <param name="_vendInvoiceTrans_Intrastat">
    /// The extension table record for <c>VendInvoiceTrans</c> record.
    /// </param>
    /// <returns>
    /// The initalized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromVendInvoiceTrans(
        VendInvoiceJour             _vendInvoiceJour,
        VendInvoiceTrans            _vendInvoiceTrans,
        VendInvoiceJour_Intrastat   _vendInvoiceJour_Intrastat = null,
        VendInvoiceTrans_Intrastat  _vendInvoiceTrans_Intrastat = null)
    {
        Intrastat               intrastat;
        LogisticsPostalAddress vendPostalAddress;
        LogisticsPostalAddress  sendRecvAddr;

        vendPostalAddress = this.primaryPostalAddress(_vendInvoiceJour.vendTable_OrderAccount().Party);

        intrastat.initValue();

        intrastat.TransDate         = _vendInvoiceJour.InvoiceDate;
        intrastat.AccountNum        = this.calcVendInvoiceJourAccountNum(_vendInvoiceJour);
        intrastat.DlvTerm           = _vendInvoiceJour.DlvTerm;
        intrastat.DebCredType       = ModuleInventCustVend::Vend;

        /* Unique reference */
        intrastat.TransTableId      = _vendInvoiceTrans.TableId;
        intrastat.TransRecId        = _vendInvoiceTrans.RecId;
        intrastat.UpdateNum         = _vendInvoiceTrans.InvoiceId;

        intrastat.Qty               = this.calcCustVendInvoiceTransQty(_vendInvoiceJour, _vendInvoiceTrans);

        this.calcAmountsAndMarkups(_vendInvoiceJour, _vendInvoiceTrans, intrastat);

        intrastat.PackingSlipId     = this.custVendInvoiceTransPackingSlipId(_vendInvoiceTrans);

        intrastat.VATNum = this.getInvoiceVATNum(
            intrastat,
            _vendInvoiceJour,
            vendPostalAddress);

        intrastat.State             = vendPostalAddress.State;
        intrastat.County            = vendPostalAddress.County;
        intrastat.CountryRegionId   = vendPostalAddress.CountryRegionId;

        this.initDirectionAndOrderType(ModuleCustVend::Vend, intrastat.Qty, intrastat, _vendInvoiceTrans.TransactionCode, _vendInvoiceJour.PurchaseType == PurchaseType::ReturnItem);

        intrastat.Category          = _vendInvoiceTrans.ProcurementCategory;

        this.initIntrastatFromTransferMap(intrastat, _vendInvoiceTrans);

        if (_vendInvoiceJour_Intrastat && _vendInvoiceJour_Intrastat.ShipmentPostalAddress)
        {
            sendRecvAddr = this.shipmentPostalAddress(_vendInvoiceJour_Intrastat.ShipmentPostalAddress);
        }
        else
        {
            sendRecvAddr = this.getSendRecvAddress(ModuleCustVend::Vend,
                                                intrastat.OrderType,
                                                _vendInvoiceJour.InvoiceAccount,
                                                _vendInvoiceTrans.DeliveryPostalAddress,
                                                TransportationDocument::find(_vendInvoiceJour.TransportationDocument).LoadedPostalAddress);
        }

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceVATNum</Name>
				<Source><![CDATA[
    private VATNum getInvoiceVATNum(
        Intrastat _intrastat, 
        CustVendInvoiceJour _custVendInvoice,
        LogisticsPostalAddress _logisticsPostalAddress)
    {
        CustVendTable custVendTable;

        switch (_custVendInvoice.module())
        {
            case SysModule::Cust :
                custVendTable = this.getCustTable(_intrastat.AccountNum) as CustVendTable;
                break;

            case SysModule::Vend :
                custVendTable = this.getVendTable(_intrastat.AccountNum) as CustVendTable;
                break;

            default :
                throw error(error::wrongUseOfFunction(funcName()));
        }

        Common custVendTableCommon = custVendTable;

        VATNum postalVATNum;

        if (FeatureStateProvider::isFeatureEnabled(IntrastatTransferVATIDInvoiceAccFeature::instance()))
        {
            postalVATNum = this.getVATNum(
                custVendTableCommon as DirPartyMap,
                _intrastat.TransDate,
                _logisticsPostalAddress,
                '');

            if (!postalVATNum && _custVendInvoice.InvoiceAccount == _intrastat.AccountNum)
            {
                postalVATNum = _custVendInvoice.VATNum;
            }

            if (!postalVATNum)
            {
                postalVATNum = custVendTable.CustVendTable::getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _intrastat.TransDate);
            }
        }
        else
        {
            postalVATNum = this.getVATNum(
                custVendTableCommon as DirPartyMap,
                _intrastat.TransDate,
                _logisticsPostalAddress,
                _custVendInvoice.VATNum);
        }

        return postalVATNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromTransferMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from an <c>IntrastatTransferMap</c> instance.
    /// </summary>
    /// <param name = "_intrastat">Intrastat to initiate.</param>
    /// <param name = "_intrastatTransferMap">The source <c>IntrastatTransferMap</c> instance.</param>
    protected void initIntrastatFromTransferMap(Intrastat _intrastat, IntrastatTransferMap _intrastatTransferMap)
    {
        _intrastat.InventTransId        = _intrastatTransferMap.InventTransId;
        _intrastat.InvoiceId            = _intrastatTransferMap.InvoiceId;

        _intrastat.TransactionCode      = _intrastatTransferMap.TransactionCode;
        _intrastat.TransportMode        = _intrastatTransferMap.Transport;
        _intrastat.Port                 = _intrastatTransferMap.Port;
        _intrastat.StatProcId           = _intrastatTransferMap.StatProcId;
        
        _intrastat.ItemId               = _intrastatTransferMap.ItemId;
        _intrastat.IntrastatCommodity   = _intrastatTransferMap.IntrastatCommodity;
        _intrastat.OrigCountryRegionId  = _intrastatTransferMap.OrigCountryRegionId;
        _intrastat.OrigState            = _intrastatTransferMap.OrigState;

        if (_intrastatTransferMap.ItemId)
        {
            // InventTable fields
            InventTable inventTable = this.getInventTable(_intrastatTransferMap.ItemId);
            _intrastat.MarkupPct = inventTable.StatisticsFactor;

            if (inventTable.ngpCodesTable_FR)
            {
                GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes([
                    [#isoFR, GlobalizationConstants::FeatureReferenceFR00015] ],
                    funcName()
                );
            }

            _intrastat.ngpCodesTable_FR = inventTable.ngpCodesTable_FR;
            _intrastat.Weight = _intrastatTransferMap.IntrastatTransferMap::itemWeight(_intrastat.Qty);

            if (!_intrastat.Markup)
            {
                _intrastat.Markup = _intrastatTransferMap.IntrastatTransferMap::itemMarkup(_intrastat.AmountMST);
                _intrastat.MarkupCur = _intrastatTransferMap.IntrastatTransferMap::itemMarkup(_intrastat.AmountCur);
            }

            _intrastat.NetWeightByUnit = _intrastatTransferMap.IntrastatTransferMap::itemNetWeightKgByUnit();
        }
        else
        {
            _intrastat.ngpCodesTable_FR = _intrastatTransferMap.ngpCodesTable_FR;
            _intrastat.Weight = _intrastatTransferMap.IntrastatTransferMap::WeightKg();
            _intrastat.NetWeightByUnit = _intrastat.Qty ? round(_intrastat.Weight / abs(_intrastat.Qty), 0.01) : 0;
        }

        if (_intrastat.intrastatCommodityExt(false))
        {
            Qty additionalQty =  _intrastatTransferMap.IntrastatTransferMap::qty(_intrastat.Qty, '', true);
            this.applyAdditionalUnits(_intrastat, additionalQty);
        }

        if (_intrastatTransferMap.TableId == tableNum(VendInvoiceIntrastat) || _intrastatTransferMap.TableId == tableNum(InventTable))
        {
            _intrastat.MarkupPct = _intrastatTransferMap.MarkupPct;
        }

        if (this.isMiscChargesPerKgEnabled(_intrastat))
        {
            _intrastat.MiscChargePerKg = this.getInventTable(_intrastatTransferMap.ItemId).IntrastatChargePerKg;
            _intrastat.calcMarkup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMiscChargesPerKgEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean isMiscChargesPerKgEnabled(Intrastat _intrastat)
    {
        return _intrastat.ItemId && 
            FeatureStateProvider::isFeatureEnabled(IntrastatMiscChargesPerKgFeature::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDirectionCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the direction code on the <c>Intrastat</c> table buffer.
    /// </summary>
    /// <param name="_intrastat">
    ///     The <c>Intrastat</c> table buffer.
    /// </param>
    /// <remarks>
    ///     Derived classes can override this method to set a value for direction code.
    /// </remarks>
    protected void setDirectionCode(Intrastat _intrastat)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUsedExportDispatchId</Name>
				<Source><![CDATA[
    protected void setUsedExportDispatchId()
    {
        if (numberExport)
        {
            if (Intrastat::transNumExist(numberExport))
            {
                numberseqExport.used();
            }
            else
            {
                numberseqExport.abort();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUsedImportDispatchId</Name>
				<Source><![CDATA[
    protected void setUsedImportDispatchId()
    {
        if (numberImport)
        {
            if (Intrastat::transNumExist(numberImport))
            {
                numberseqImport.used();
            }
            else
            {
                numberseqImport.abort();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntrastatFromVendPckSlpTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates an <c>Intrastat</c> line from a <c>VendPackingSlipTrans</c> line.
    /// </summary>
    /// <param name="_vendPackingSlipJour">
    /// <c>VendPackingSlipJour</c> record realted to the <c>VendPackingSlipTrans</c> line.
    /// </param>
    /// <param name="_vendPackingSlipTrans">
    /// The source <c>VendPackingSlipTrans</c> line.
    /// </param>
    /// <param name="vendPackingSlipJour_Intrastat">
    /// The extension table record for <c>VendPackingSlipJour</c> record.
    /// </param>
    /// <param name="vendPackingSlipTrans_Intrastat">
    /// The extension table record for <c>VendPackingSlipTrans</c> record.
    /// </param>
    /// <returns>
    /// The initalized <c>Intrastat</c> line.
    /// </returns>
    protected Intrastat initIntrastatFromVendPckSlpTrans(
        VendPackingSlipJour             _vendPackingSlipJour,
        VendPackingSlipTrans            _vendPackingSlipTrans,
        VendPackingSlipJour_Intrastat   vendPackingSlipJour_Intrastat = null,
        VendPackingSlipTrans_Intrastat  vendPackingSlipTrans_Intrastat = null)
    {
        Intrastat               intrastat;
        VendInvoiceTrans        vendInvoiceTrans;
        LogisticsPostalAddress  sendRecvAddr;

        LogisticsPostalAddress vendPostalAddress;

        vendPostalAddress = this.primaryPostalAddress(_vendPackingSlipJour.vendTable_OrderAccount().Party);

        intrastat.initValue();

        intrastat.TransDate            = _vendPackingSlipJour.DeliveryDate;
        intrastat.AccountNum           = this.calcVendPckSlipJourAccountNum(_vendPackingSlipJour);
        intrastat.DlvTerm              = _vendPackingSlipJour.DlvTerm;
        intrastat.DebCredType          = ModuleInventCustVend::Vend;

        /* Unique reference */
        intrastat.TransTableId         = _vendPackingSlipTrans.TableId;
        intrastat.TransRecId           = _vendPackingSlipTrans.RecId;

        intrastat.UpdateNum            = _vendPackingSlipTrans.PackingSlipId;

        intrastat.Qty                   = _vendPackingSlipTrans.StockedProduct ? _vendPackingSlipTrans.InventQty : _vendPackingSlipTrans.Qty;

        this.calcAmountsAndMarkups(_vendPackingSlipJour, _vendPackingSlipTrans, intrastat);

        intrastat.PackingSlipId        = _vendPackingSlipTrans.PackingSlipId;

        VendTable vendTable = this.getVendTable(intrastat.AccountNum);

        VATNum postalVATNum = vendTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _vendPackingSlipJour.DocumentDate);
        intrastat.VATNum = this.getVATNum(
            vendTable,
            intrastat.TransDate,
            this.primaryPostalAddress(_vendPackingSlipJour.vendTable_OrderAccount().Party),
            postalVATNum);

        intrastat.State                = vendPostalAddress.State;
        intrastat.County               = vendPostalAddress.County;
        intrastat.CountryRegionId      = vendPostalAddress.CountryRegionId;

        this.initDirectionAndOrderType(ModuleCustVend::Vend, intrastat.Qty, intrastat, _vendPackingSlipTrans.TransactionCode, _vendPackingSlipJour.PurchaseType == PurchaseType::ReturnItem);

        intrastat.Category             = _vendPackingSlipTrans.ProcurementCategory;

        this.initIntrastatFromTransferMap(intrastat, _vendPackingSlipTrans);

        if (_vendPackingSlipTrans.ItemId)
        {
            intrastat.InvoiceId = this.vendPackingSlipInvoiceId(_vendPackingSlipTrans);
        }
        else
        {
            //Description based line
            select InvoiceId from vendInvoiceTrans
                where vendInvoiceTrans.InventTransId == intrastat.InventTransId;

            if (vendInvoiceTrans)
            {
                intrastat.InvoiceId = vendInvoiceTrans.InvoiceId;
            }
            else
            {
                intrastat.InvoiceId = '';
            }
        }

        if (vendPackingSlipJour_Intrastat && vendPackingSlipJour_Intrastat.ShipmentPostalAddress)
        {
            sendRecvAddr = this.shipmentPostalAddress(vendPackingSlipJour_Intrastat.ShipmentPostalAddress);
        }
        else
        {
            sendRecvAddr = this.getSendRecvAddress(
                ModuleCustVend::Vend,
                intrastat.OrderType,
                _vendPackingSlipJour.InvoiceAccount,
                _vendPackingSlipJour.DeliveryPostalAddress,
                TransportationDocument::find(_vendPackingSlipJour.TransportationDocument).LoadedPostalAddress);
        }

        intrastat.SendReceiveCountryRegionId    = sendRecvAddr.CountryRegionId;
        intrastat.SendReceiveState              = sendRecvAddr.State;

        this.setDirectionCode(intrastat);

        return intrastat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes basic parameters for later use.
    /// </summary>
    protected void initParameters()
    {
        intrastatParm       = IntrastatParameters::find();
        isLegalEntityInEEU  = IntrastatParameters::isLegalEntityInEEU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        this.featureRun(funcName());

        queryRunIntrastatTransfer = new QueryRun(queryStr(IntrastatTransfer));

        custInvoiceTotalMap = new Map(Types::String /*InventTransId*/, Types::Real /*Qty*/);
        vendInvoiceTotalMap = new Map(Types::String /*InventTransId*/, Types::Real /*Qty*/);

        isInEUMap = new Map(Types::String /*LogisticsAddressCountryRegionId*/, Types::Enum /*boolean*/);
        isDomesticCache = new Map(Types::String, Types::Enum);
        isSpecialDomesticCache = new Map(Types::String, Types::Enum);

        countryRegionStateIsInEUCache = new Map(Types::Container, Types::Enum);
        taxRegistrationValueCache = new Map(Types::Container, Types::String);
        logisticsPostalAddressCache = new Map(Types::Int64, Types::Record);
        primaryPostalAddressCache = new Map(Types::Int64, Types::Record);
        shipmentPostalAddressCache = new Map(Types::Int64, Types::Record);
        vendAccountFromInventLocationCache = new Map(Types::String, Types::String);

        this.initParameters();

        isLegalEntityInLV = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLV]);
        primaryPostalAddressForCurrentCompany = this.primaryPostalAddress(CompanyInfo::find().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>featureRun</Name>
				<Source><![CDATA[
    protected void featureRun(str _funcName)
    {
        GlobalizationInstrumentationHelper::featureRun(FeatureReferenceEUR00002, _funcName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyAdditionalUnits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies additional units to the <c>Intrastat</c> table fields.
    /// </summary>
    /// <param name = "_intrastat"><c>Intrastat</c> table to modify.</param>
    /// <param name = "_additionalQty">Additional qunantity amount.</param>
    private void applyAdditionalUnits(Intrastat _intrastat, Qty _additionalQty)
    {
        EcoResCategoryIntrastat ecoResCategoryIntrastat = _intrastat.intrastatCommodityExt();

        if (ecoResCategoryIntrastat)
        {
            if (ecoResCategoryIntrastat.AdditionalUnits)
            {
                _intrastat.AdditionalQtyUnit = ecoResCategoryIntrastat.AdditionalUnits;
                _intrastat.AdditionalUnits   = _additionalQty;
            }
            else
            {
                _intrastat.AdditionalQtyUnit = '';
            }

            if (ecoResCategoryIntrastat.OptionalWeight)
            {
                _intrastat.Weight = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importDestinationAddressCountry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the destination address country id.
    /// </summary>
    /// <param name="_destAddressCountryRegionId">
    /// Default destination country id for a purchase iype other than return order.
    /// </param>
    /// <param name="_purchaseType">
    /// Puchase type of the vendor transaction.
    /// </param>
    /// <param name="_inventRefType">
    /// Reference type of the vendor transaction.
    /// </param>
    /// <param name="_inventRefTransId">
    /// InventTransId of original order for return order created.
    /// </param>
    /// <param name="_inventDim">
    /// <c>InventDim</c> record related to the vendor transaction.
    /// </param>
    /// <returns>
    /// returns destination address country id.
    /// </returns>
    /// <remarks>
    /// Original PO delivery address is fetched for the return order if there is linking functionality used.
    /// If user does not use linking functionality then the warehouse primary address is fetched or else company address is fetched as shipping country.
    /// </remarks>
    private AddressCountryRegionId importDestinationAddressCountry(
        AddressCountryRegionId _destAddressCountryRegionId,
        PurchaseType _purchaseType,
        InventRefType _inventRefType,
        InventRefTransid _inventRefTransId,
        InventDim _inventDim)
    {
        AddressCountryRegionId destAddressCountryRegionId;

        destAddressCountryRegionId = _destAddressCountryRegionId;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            if (_purchaseType == PurchaseType::ReturnItem)
            {
                if (_inventRefTransId)
                {
                    if (IntrastatIncludeInterCompanyVendInvoiceReturnInFRFlight::instance().isEnabled()
                        && _inventRefType == InventRefType::Sales)
                    {
                        destAddressCountryRegionId = CustInvoiceTrans::findInventTransid(_inventRefTransId).CountryRegionOfShipment;
                    }
                    else
                    {
                        destAddressCountryRegionId = VendInvoiceTrans::find(_inventRefTransId).DestCountryRegionId;
                    }
                }
                else
                {
                    destAddressCountryRegionId = _inventDim.inventLocation().logisticsPostalAddress().CountryRegionId;
                }
            }
        }

        return destAddressCountryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmount</Name>
				<Source><![CDATA[
    private void calcAmount(IntrastatTransactionCode _intrastatTransactionCode,
                            CustVendInvoiceJour _headerSource,
                            CustVendInvoiceTrans _lineSource,
                            Intrastat _intrastat)
    {
        // Invoice amount
        IntrastatAmountCalc intrastatAmountCalc = IntrastatAmountCalcFactory::construct(_intrastatTransactionCode.InvoiceAmountCalcMethod);

        intrastatAmountCalc.calc(_headerSource, _lineSource);

        exchRateErrMsg = intrastatAmountCalc.parmExchRateErrorMessage();

        if (exchRateErrMsg)
        {
            return;
        }

        _intrastat.AmountMST = intrastatAmountCalc.parmAccountingCurrencyAmount() * invoicePackingSlipFactor;

        _intrastat.CurrencyCode = intrastatAmountCalc.parmTransactionCurrency();
        _intrastat.AmountCur = intrastatAmountCalc.parmTransactionCurrencyAmount() * invoicePackingSlipFactor;

        // Statistical amount
        if (_intrastatTransactionCode.InvoiceAmountCalcMethod == _intrastatTransactionCode.StatisticalAmountCalcMethod)
        {
            _intrastat.StatisticalValue = _intrastat.AmountMST;
            _intrastat.StatisticalValueCur = _intrastat.AmountCur;
        }
        else
        {
            intrastatAmountCalc = IntrastatAmountCalcFactory::construct(_intrastatTransactionCode.StatisticalAmountCalcMethod);

            intrastatAmountCalc.calc(_headerSource, _lineSource);

            exchRateErrMsg = intrastatAmountCalc.parmExchRateErrorMessage();

            if (exchRateErrMsg)
            {
                return;
            }

            _intrastat.StatisticalValue = intrastatAmountCalc.parmAccountingCurrencyAmount() * invoicePackingSlipFactor;
            _intrastat.StatisticalValueCur = intrastatAmountCalc.parmTransactionCurrencyAmount() * invoicePackingSlipFactor;

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountsAndMarkups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amounts and markups from the source data for an Intrastat record.
    /// </summary>
    /// <param name = "_headerSource">A header record of the source.</param>
    /// <param name = "_lineSource">A line record of the source.</param>
    /// <param name = "_intrastat">An Intrastat record.</param>
    protected void calcAmountsAndMarkups(CustVendInvoiceJour _headerSource,
                                        CustVendInvoiceTrans _lineSource,
                                        Intrastat _intrastat)
    {
        invoicePackingSlipFactor = this.calcInvoicePackingSlipFactor(_headerSource, _lineSource);

        // Invoice & Statistical amounts
        this.calcAmount(IntrastatTransactionCode::find(_lineSource.TransactionCode), _headerSource, _lineSource, _intrastat);

        if (!exchRateErrMsg)
        {
            // Invoice & Statistical charges
            this.calcMarkup(_headerSource, _lineSource, _intrastat);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkup</Name>
				<Source><![CDATA[
    private void calcMarkup(CustVendInvoiceJour _headerSource,
                            CustVendInvoiceTrans _lineSource,
                            Intrastat _intrastat)
    {
        IntrastatCalcMarkupAmount intrastatCalcMarkupAmount;
        AmountMST statisticalMarkupAmount;
        AmountMST invoiceMarkupAccountingAmount;
        AmountCur invoiceMarkupTransactionAmount;
        AmountCur statisticalMarkupTransactionAmount;

        // Statistical & invoice charges from transactions
        switch (_headerSource.TableId)
        {
            case tableNum(CustInvoiceJour):
            case tableNum(VendInvoiceJour):
            case tableNum(ProjInvoiceJour):
                intrastatCalcMarkupAmount = IntrastatCalcMarkupAmount::construct();
                intrastatCalcMarkupAmount.calc(_headerSource, _lineSource);

                exchRateErrMsg = intrastatCalcMarkupAmount.parmExchRateErrorMessage();

                if (exchRateErrMsg)
                {
                    return;
                }

                statisticalMarkupAmount = intrastatCalcMarkupAmount.parmStatisticalAmount() * invoicePackingSlipFactor;
                statisticalMarkupTransactionAmount = intrastatCalcMarkupAmount.parmStatisticalTransactionCurrencyAmount() * invoicePackingSlipFactor;
                invoiceMarkupAccountingAmount = intrastatCalcMarkupAmount.parmInvoiceAccountingCurrencyAmount() * invoicePackingSlipFactor;
                invoiceMarkupTransactionAmount = intrastatCalcMarkupAmount.parmInvoiceTransactionCurrencyAmount() * invoicePackingSlipFactor;
                break;

            case tableNum(CustPackingSlipJour):
            case tableNum(VendPackingSlipJour):
                // Misc charges are tied to invoices so we don't want to calculate them if invoices are not supposed to be reported
                if (custInvoice || vendInvoice)
                {
                    intrastatCalcMarkupAmount = IntrastatCalcMarkupAmount::construct();
                    intrastatCalcMarkupAmount.calc(_headerSource, _lineSource);

                    exchRateErrMsg = intrastatCalcMarkupAmount.parmExchRateErrorMessage();

                    if (exchRateErrMsg)
                    {
                        return;
                    }

                    statisticalMarkupAmount = intrastatCalcMarkupAmount.parmStatisticalAmount();
                    statisticalMarkupTransactionAmount = intrastatCalcMarkupAmount.parmStatisticalTransactionCurrencyAmount();
                    invoiceMarkupAccountingAmount = intrastatCalcMarkupAmount.parmInvoiceAccountingCurrencyAmount();
                    invoiceMarkupTransactionAmount = intrastatCalcMarkupAmount.parmInvoiceTransactionCurrencyAmount();
                }
                break;

            default:
                throw error(error::wrongUseOfFunction(funcName()));
        }

        // Save invoice charges
        _intrastat.InvoiceMarkupMST = invoiceMarkupAccountingAmount;
        _intrastat.InvoiceMarkupCur = invoiceMarkupTransactionAmount;

        // Save statistical charges
        _intrastat.Markup += statisticalMarkupAmount;
        _intrastat.MarkupCur += statisticalMarkupTransactionAmount;
        _intrastat.calcMarkupPct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcValuesSign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the value sign based on a Intrastat record.
    /// </summary>
    /// <param name = "_intrastat">The Intrastat table record.</param>
    /// <returns>A value sign; either 1 or -1.</returns>
    protected Sign calcValuesSign(Intrastat _intrastat)
    {
        return _intrastat.OrderType == IntrastatOrderType::Return ? -1 : 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeIntrastatAddValueLV</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes the additional value (specific for Latvia) across the Intrastat lines.
    /// </summary>
    /// <param name = "_invoiceLines">A counter for invoice lines.</param>
    /// <param name = "intrastatLines">A list of Intrastat lines.</param>
    /// <param name = "_intrastatAddValue">An additional value.</param>
    protected void distributeIntrastatAddValueLV(Counter _invoiceLines, List intrastatLines, LvIntrastatAddValue _intrastatAddValue)
    {
        Counter currentLine;
        LvIntrastatAddValue remain;
        ListIterator distrubuteLines = new ListIterator(intrastatLines);
        Intrastat intrastat;
        RecId   recId;

        remain = CurrencyExchangeHelper::amount(_intrastatAddValue);
        while (distrubuteLines.more())
        {
            currentLine ++;
            recId = distrubuteLines.value();

            select firstonly forupdate intrastat
                where intrastat.RecId == recId;

            intrastat.StatisticalAdjustmentAmount = CurrencyExchangeHelper::amount(remain / (_invoiceLines - currentLine + 1));
            remain -= intrastat.StatisticalAdjustmentAmount;
            intrastat.update();
            distrubuteLines.next();
        }
        if (remain && _invoiceLines)
        {
            throw error(strFmt("@SYS19378",funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPackingSlipAvailable</Name>
				<Source><![CDATA[
    private boolean isPackingSlipAvailable(
        CustVendInvoiceJour _headerSource, 
        CustVendInvoiceTrans _lineSource,
        boolean _custPackingSlip = custPckSlp,
        boolean _vendPackingSlip = vendPckSlp)
    {
        CustInvoiceJour custInvoiceJour;
        VendInvoiceJour vendInvoiceJour;

        boolean ret = (_custPackingSlip && _lineSource.TableId == tableNum(CustInvoiceTrans)) || (_vendPackingSlip && _lineSource.TableId == tableNum(VendInvoiceTrans));

        if (ret)
        {
            if (_headerSource.TableId == tableNum(CustInvoiceJour))
            {
                custInvoiceJour = _headerSource;
                ret = custInvoiceJour.RefNum == RefNum::SalesOrder;
            }
            else if (_headerSource.TableId == tableNum(VendInvoiceJour))
            {
                vendInvoiceJour = _headerSource;
                ret = !vendInvoiceJour.isNonPO();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderValue</Name>
				<Source><![CDATA[
    private container getTransferOrderValue(IntrastatDirection     _direction,
                                            InventTransferJourLine _inventTransferJourLine)
    {
        IntrastatTransactionCode     intrastatTransactionCode;
        TransferOrderAmountValueType transferOrderAmountValueType,
                                     transferOrderStatValueType;
        AmountMst                    amountValue,
                                     statValue;

        AmountMst calcAmount(TransferOrderAmountValueType _valueType, NoYes _isAmountValue)
        {
            AmountMst         amountMst, amount;
            InventTrans       inventTrans;
            InventTransOrigin inventTransOrigin;

            switch (_valueType)
            {
                case TransferOrderAmountValueType::Empty:
                    amountMst = 0;
                    break;

                case TransferOrderAmountValueType::Manual:
                    amountMst = _isAmountValue ? _inventTransferJourLine.AmountValue : _inventTransferJourLine.StatisticalValue;
                    InventTransferLine inventTransferLine = _inventTransferJourLine.inventTransferLine();

                    if (inventTransferLine.QtyTransfer)
                    {
                        amount = amountMst / abs(inventTransferLine.QtyTransfer);

                        amountMst = this.getAdjustedAmount(_direction, amount, _inventTransferJourLine);
                    }
                    
                    break;

                case TransferOrderAmountValueType::InitialCostValue:
                case TransferOrderAmountValueType::TotalCostValue:

                    select sum(CostAmountPosted), sum(CostAmountAdjustment), sum(Qty) from inventTrans
                        exists join inventTransOrigin
                        where inventTransOrigin.InventTransId == _inventTransferJourLine.InventTransId
                            && inventTransOrigin.RecId         == inventTrans.InventTransOrigin
                            && (   (_direction == IntrastatDirection::Export && inventTrans.StatusIssue   == StatusIssue::Sold)
                                || (_direction == IntrastatDirection::Import && inventTrans.StatusReceipt == StatusReceipt::Purchased));

                    if (inventTrans.Qty)
                    {
                        amount = inventTrans.CostAmountPosted / abs(inventTrans.Qty);

                        amountMst = this.getAdjustedAmount(_direction, amount, _inventTransferJourLine);
                    }
                    else
                    {
                        amountMst = inventTrans.CostAmountPosted;
                    }

                    if (_valueType == TransferOrderAmountValueType::TotalCostValue)
                    {
                        amountMst += inventTrans.CostAmountAdjustment;
                    }

                    break;
            }

            return abs(amountMst);
        }

        if (_inventTransferJourLine.TransactionCode)
        {
            intrastatTransactionCode = IntrastatTransactionCode::find(_inventTransferJourLine.TransactionCode);

            if (intrastatTransactionCode)
            {
                transferOrderAmountValueType = intrastatTransactionCode.TransferOrderAmountValueType;
                transferOrderStatValueType   = intrastatTransactionCode.TransferOrderStatValueType;
            }
        }

        amountValue = calcAmount(transferOrderAmountValueType, true);

        if (transferOrderStatValueType == transferOrderAmountValueType && transferOrderStatValueType != TransferOrderAmountValueType::Manual)
        {
            statValue = amountValue;
        }
        else
        {
            statValue = calcAmount(transferOrderStatValueType, false);
        }

        return [amountValue, statValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedAmount</Name>
				<Source><![CDATA[
    private AmountMST getAdjustedAmount(IntrastatDirection _direction, AmountMST _amount, InventTransferJourLine _inventTransferJourLine)
    {
        AmountMST amountMST;

        if (_direction == IntrastatDirection::Export)
        {
            amountMST = _amount * _inventTransferJourLine.QtyShipped;
        }
        else
        {
            amountMST = _amount * (_inventTransferJourLine.QtyReceived - _inventTransferJourLine.QtyScrapped);
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInEU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the country belongs to EU.
    /// </summary>
    /// <param name="_countryRegionId">
    /// The <c>LogisticsAddressCountryRegionId</c> string, that identifies the Country/region to which the address is related.
    /// </param>
    protected boolean isInEU(LogisticsAddressCountryRegionId _countryRegionId)
    {
        if (!isInEUMap.exists(_countryRegionId))
        {
            isInEUMap.insert(_countryRegionId, this.getIsInEU(_countryRegionId));
        }

        return isInEUMap.lookup(_countryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsInEU</Name>
				<Source><![CDATA[
    protected boolean getIsInEU(LogisticsAddressCountryRegionId _countryRegionId)
    {
        return IntrastatCountryRegionParameters::isInEU(_countryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDomesticCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a country or region has the domestic type.
    /// </summary>
    /// <param name="_countryRegionId">
    /// The country or region to check.
    /// </param>
    /// <returns>
    /// true if the country or region is of the domestic type; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Caches values to the <c>isDomesticCache</c> map for the same region or country.
    /// </remarks>
    [Hookable(false)]
    protected boolean isDomesticCache(LogisticsAddressCountryRegionId _countryRegionId)
    {
        if (!isDomesticCache.exists(_countryRegionId))
        {
            isDomesticCache.insert(_countryRegionId, IntrastatCountryRegionParameters::isDomestic(_countryRegionId));
        }

        return isDomesticCache.lookup(_countryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSpecialDomesticCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a country or region has the special domestic type.
    /// </summary>
    /// <param name="_countryRegionId">
    /// The country or region to check.
    /// </param>
    /// <returns>
    /// true if the country or region is of the special domestic type; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Caches values to the <c>isSpecialDomesticCache</c> map for the same region or country.
    /// </remarks>
    [Hookable(false)]
    protected boolean isSpecialDomesticCache(LogisticsAddressCountryRegionId _countryRegionId)
    {
        if (!isSpecialDomesticCache.exists(_countryRegionId))
        {
            isSpecialDomesticCache.insert(_countryRegionId, IntrastatCountryRegionParameters::isSpecialDomestic(_countryRegionId));
        }

        return isSpecialDomesticCache.lookup(_countryRegionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves and caches the record that matches the provided <c>logisticsPostalAddressRecId</c> value.
    /// </summary>
    /// <param name="_logisticsPostalAddressRecId">
    /// The record to select from the table.
    /// </param>
    /// <returns>
    /// The record that matches the specified <c>logisticsPostalAddressRecId</c> value.
    /// </returns>
    [Hookable(false)]
    protected LogisticsPostalAddress postalAddress(LogisticsPostalAddressRecId _logisticsPostalAddressRecId)
    {
        if (!logisticsPostalAddressCache.exists(_logisticsPostalAddressRecId))
        {
            logisticsPostalAddressCache.insert(_logisticsPostalAddressRecId, LogisticsPostalAddress::findRecId(_logisticsPostalAddressRecId));
        }

        return logisticsPostalAddressCache.lookup(_logisticsPostalAddressRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>primaryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves and caches the record that matches the provided <c>DirPartyRecId</c> value.
    /// </summary>
    /// <param name="_partyRecId">
    /// The record to select from the table.
    /// </param>
    /// <returns>
    /// The record that matches the specified <c>DirPartyRecId</c> value.
    /// </returns>
    [Hookable(false)]
    protected LogisticsPostalAddress primaryPostalAddress(DirPartyRecId _partyRecId)
    {
        if (!primaryPostalAddressCache.exists(_partyRecId))
        {
            primaryPostalAddressCache.insert(_partyRecId, DirParty::primaryPostalAddress(_partyRecId));
        }

        return primaryPostalAddressCache.lookup(_partyRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipmentPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves and caches the record that matches the provided <c>AddressRecId</c> value.
    /// </summary>
    /// <param name="_addressRecId">
    /// The record to select from the table.
    /// </param>
    /// <returns>
    /// The record that matches the specified <c>AddressRecId</c> value.
    /// </returns>
    [Hookable(false)]
    protected LogisticsPostalAddress shipmentPostalAddress(RefRecId _addressRecId)
    {
        LogisticsPostalAddress ret;

        if (shipmentPostalAddressCache.exists(_addressRecId))
        {
            ret = shipmentPostalAddressCache.lookup(_addressRecId);
        }
        else
        {
            ret = LogisticsPostalAddress::findRecId(_addressRecId);
            shipmentPostalAddressCache.insert(_addressRecId, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendAccountFromInventLocationCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves and caches the vendor account corresponding to the specified value <c>Inventlocationid</c>.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse to select from the table.
    /// </param>
    /// <returns>
    /// The vendor account corresponding to the <c>InventlocationId</c> value.
    /// </returns>
    [Hookable(false)]
    protected VendAccount getVendAccountFromInventLocationCache(InventLocationId _inventLocationId)
    {
        if (!vendAccountFromInventLocationCache.exists(_inventLocationId))
        {
            vendAccountFromInventLocationCache.insert(_inventLocationId, InventLocation::find(_inventLocationId).VendAccount);
        }

        return vendAccountFromInventLocationCache.lookup(_inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCountryRegionStateInEU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the country belongs to EU.
    /// </summary>
    /// <param name = "_deliveryAddress">
    /// The logistics postal address.
    /// </param>
    /// <returns>
    /// true, if the address belongs to EU; otherwise, false.
    /// </returns>
    protected boolean isCountryRegionStateInEU(LogisticsPostalAddress _deliveryAddress)
    {
        container countryRegionStateContainer = [_deliveryAddress.CountryRegionId, _deliveryAddress.State];

        if (!countryRegionStateIsInEUCache.exists(countryRegionStateContainer))
        {
            countryRegionStateIsInEUCache.insert(countryRegionStateContainer, this.getIsCountryRegionStateInEU(_deliveryAddress));
        }

        return countryRegionStateIsInEUCache.lookup(countryRegionStateContainer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsCountryRegionStateInEU</Name>
				<Source><![CDATA[
    protected boolean getIsCountryRegionStateInEU(LogisticsPostalAddress _deliveryAddress)
    {
        return IntrastatCountryRegionParameters::isCountryRegionStateInEU(_deliveryAddress);
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public ClassDescription caption()
    {
        return strFmt('%1 (%2)', "@SYS6530", "@Intrastat:Transfer");
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxRegistrationValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax registration number either from the given party address or a primary address of the party.
    /// </summary>
    /// <param name = "_party">A party.</param>
    /// <param name = "_date">An effective date on what to find tax registration number.</param>
    /// <returns>A tax registration number.</returns>
    protected VATNum getTaxRegistrationValue(
        DirPartyMap _party,
        date _date,
        LogisticsPostalAddress _postalAddress)
    {
        container key = [_party.Party, _date, _postalAddress.RecId];

        if (!taxRegistrationValueCache.exists(key))
        {
            TaxRegistrationTypeId taxRegistrationTypeId = TaxRegistrationLegislationTypes::getTaxRegistrationTypeApplicabilityRule(
            TaxRegistrationTypesList::TAXID,
            DirPartyTable::findRec(_party.Party).baseType(),
            _postalAddress.CountryRegionId).TaxRegistrationTypeApplicabilityRule;

            // Find the tax registration num in the provided address
            DirPartyLocation dirPartyLocation = DirPartyLocation::findByPartyLocation(
            _party.Party,
            _postalAddress.Location);

            VATNum vatNum = TaxRegistration::findDirPartyLocationOnDate(
            dirPartyLocation.RecId,
            taxRegistrationTypeId,
            true,
            ConcurrencyModel::Auto,
            _date).RegistrationNumber;

            // Find the tax registration num in the primary for country/region address (isPrimaryTaxRegistration)
            // Country/region is taken from the provided address
            if (!vatNum)
            {
                LogisticsPostalAddress logisticsPostalAddress;

                select firstOnly RecId from dirPartyLocation
                where dirPartyLocation.Party == _party.Party
                    && dirPartyLocation.IsPostalAddress == NoYes::Yes
                    && dirPartyLocation.IsPrimaryTaxRegistration == NoYes::Yes
                exists join logisticsPostalAddress
                    where logisticsPostalAddress.Location == dirPartyLocation.Location
                        && logisticsPostalAddress.CountryRegionId == _postalAddress.CountryRegionId;

                vatNum = TaxRegistration::findDirPartyLocationOnDate(
                dirPartyLocation.RecId,
                taxRegistrationTypeId,
                true,
                ConcurrencyModel::Auto,
                _date).RegistrationNumber;
            }

            // Find the tax registration num from a party primary address (isPrimary)
            if (!vatNum)
            {
                vatNum = TaxRegistration::getPrimaryAddressTaxRegistration(_party, TaxRegistrationTypesList::TAXID, _date).RegistrationNumber;
            }

            taxRegistrationValueCache.insert(key, vatNum);
        }

        return taxRegistrationValueCache.lookup(key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVATNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns VAT registration number for the particular party.
    /// </summary>
    /// <param name = "_party">The party.</param>
    /// <param name = "_date">Transaction date.</param>
    /// <param name = "_postalAddress">Logistics postal address.</param>
    /// <param name = "_defaultVATNum">VAT number specified in party.</param>
    /// <returns>VAT registration number.</returns>
    protected VATNum getVATNum(
        DirPartyMap _party,
        TransDate _date,
        LogisticsPostalAddress _postalAddress,
        VATNum _defaultVATNum)
    {
        VATNum vatNum;

        if (FeatureStateProvider::isFeatureEnabled(IntrastatTransferPartnerVATIDFeature::instance()))
        {
            vatNum = this.getTaxRegistrationValue(_party, _date, _postalAddress);
        }

        return vatNum ? vatNum : _defaultVATNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventTransferJournalExport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the journal is transfered for export as an Dispatch.
    /// </summary>
    /// <param name = "_inventTransferJour">Invent transfer journal.</param>
    /// <param name = "_direction">Intrastat transfer direction.</param>
    /// <returns>true, if Intrastat transfers the shipment journal; otherwise, false.</returns>
    protected boolean validateInventTransferJournalExport(InventTransferJour _inventTransferJour, IntrastatDirection _direction)
    {
        boolean ret = true;

        boolean export = IntrastatTransfer::isInventTransferJourUpdateTypeForExport(_inventTransferJour.UpdateType);
        
        if (export != (_direction == IntrastatDirection::Export))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustomerPrimaryAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows to check primary address of the customer
    /// </summary>
    /// <returns>
    /// Depends from country context
    /// </returns>
    protected boolean checkCustomerPrimaryAddress(CustAccount _orderAccount)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventTable</Name>
				<Source><![CDATA[
    protected InventTable getInventTable(ItemId _itemId)
    {
        if (lastInventTable.ItemId != _itemId)
        {
            lastInventTable = InventTable::find(_itemId);
        }

        return lastInventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustTable</Name>
				<Source><![CDATA[
    protected CustTable getCustTable(CustAccount _accountNum)
    {
        if (lastCustTable.AccountNum != _accountNum)
        {
            lastCustTable = CustTable::find(_accountNum);
        }

        return lastCustTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendTable</Name>
				<Source><![CDATA[
    protected VendTable getVendTable(VendAccount _accountNum)
    {
        if (lastVendTable.AccountNum != _accountNum)
        {
            lastVendTable = VendTable::find(_accountNum);
        }

        return lastVendTable;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>