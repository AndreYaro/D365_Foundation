<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProdStandardVariance</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>ProdStandardVariance</c> class calculates a range of production variances from standard.
/// </summary>
/// <remarks>
///    Variances are calculated between a reference cost, which is a standard cost or a cost estimate, and
///    the actual cost.
/// </remarks>
class ProdStandardVariance
{
    // Entity for which variances are calculated
    CostTransRefId              transRefId;
    ProdTransRefType            transRefType;
    Level                       collectRefLevel;
    CostTransRefId              collectRefId;

    // Variables per std cost
    InventItemPrice             inventItemPrice;
    BOMCalcTable                bomCalcTable;
    Qty                         estQty;
    Qty                         actQty;

    TmpProdStandardVariance     tmpProdStandardVariance;
    Map                         costMarkupQtyMap;
    Map                         costPriceQtyMap;
    Set                         transEstimateSet;
    Set                         transActualSet;

    boolean                     isCostBreakdownActivated;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTransActual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the temporary variance record to the set of actual cost records.
    /// </summary>
    /// <param name="_prodCalcTrans">
    /// The <c>ProdCalcTrans</c> record.
    /// </param>
    protected void addTransActual(
        PmfProdCalcTransMap _prodCalcTrans
        )
    {
        // No need to calculate lotSize and std allowed here,
        // All the lines that did exist in the bom, have already been calculated
        // and for the ones that only exist in prod (=substitues) it is zero

        transActualSet.add(tmpProdStandardVariance.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the lot size and standard allowed and adds the temporary variance record to the set of
    /// estimated cost records.
    /// </summary>
    /// <param name="_consumpVariable">
    /// The permitted variable consumption.
    /// </param>
    /// <param name="_consumpConstant">
    /// The permitted constant consumption.
    /// </param>
    /// <param name="_costMarkupQty">
    /// The markup for the total lot size.
    /// </param>
    /// <param name="_costPriceQty">
    /// The <c>costPrice</c> value for one piece.
    /// </param>
    protected void addTransEstimate(
        InventQty       _consumpVariable,
        InventQty       _consumpConstant,
        CostMarkup      _costMarkupQty,
        CostPrice       _costPriceQty
        )
    {
        // Calc LotSize and std allowed
        tmpProdStandardVariance.addLotSizeAndStdAllowed(_consumpVariable, _consumpConstant, actQty, estQty, _costMarkupQty, _costPriceQty);

        transEstimateSet.add(tmpProdStandardVariance.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildActualQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query to use to load for actual cost.
    /// </summary>
    /// <returns>
    ///    The query for loading actual cost.
    /// </returns>
    protected Query buildActualQuery()
    {
        // Roll up actual
        Query query = new Query(queryStr(ProdCalcSum));
        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(ProdCalcTrans)), fieldNum(ProdCalcTrans, CollectRefProdId)).value(queryValue(collectRefId));
        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(ProdCalcTrans)), fieldNum(ProdCalcTrans, TransRefId)).value(queryValue(transRefId));
        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(ProdCalcTrans)), fieldNum(ProdCalcTrans, TransRefType)).value(queryValue(transRefType));

        if (!isCostBreakdownActivated)
        {
            QueryBuildRange qbrLevel = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(ProdCalcTrans)), fieldNum(ProdCalcTrans, CollectRefLevel));
            qbrLevel.value(queryValue(collectRefLevel + 1));
        }
        else
        {
            QueryBuildRange qbrOrCondition = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(ProdCalcTrans)), fieldNum(ProdCalcTrans, Resource));

            // Add an or Condition:
            // Everything that is level single or not bom
            int subProdSingleLevel = collectRefLevel + InventCostLevel::Single;

            qbrOrCondition.value(strFmt('((%1.%2 == %3) || (%1.%4 == %5))',
                                        query.dataSourceTable(tableNum(ProdCalcTrans)).name(),   // ProdCalcTrans %1
                                        fieldStr(ProdCalcTrans, CollectRefLevel),                // CollectRefLevel %2
                                        any2int(subProdSingleLevel),                             // 1 (= Level Single) %3
                                        fieldStr(ProdCalcTrans, bom),                            // BOM %4
                                        any2int(NoYes::No)));                                    // No %5
            qbrOrCondition.status(RangeStatus::Hidden);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildEstimateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query to use to load the estimated cost.
    /// </summary>
    /// <returns>
    ///    The query to use for loading estimated cost.
    /// </returns>
    protected Query buildEstimateQuery()
    {
        Query query = new Query(queryStr(BOMCalcSum));
        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(BOMCalcTrans)), fieldNum(BOMCalcTrans, PriceCalcId)).value(queryValue(inventItemPrice.PriceCalcId));

        // Loop through the records using the lineNum
        query.dataSourceTable(tableNum(BOMCalcTrans)).addSortField(fieldNum(BOMCalcTrans, LineNum));
        query.dataSourceTable(tableNum(BOMCalcTrans)).orderMode(OrderMode::OrderBy);

        if (! isCostBreakdownActivated)
        {
            QueryBuildRange qbrLevel = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(BOMCalcTrans)), fieldNum(BOMCalcTrans, Level));
            qbrLevel.value(queryValue(1));
        }
        else
        {
            QueryBuildRange qbrOrCondition = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(BOMCalcTrans)), fieldNum(BOMCalcTrans, Resource));

            // Add an or Condition:
            // Everything that is level single or not bom
            qbrOrCondition.value(strFmt('((%1.%2 == %3) || (%1.%4 == %5))',
                                        query.dataSourceTable(tableNum(BOMCalcTrans)).name(),   // BOMCalcTrans %1
                                        fieldStr(BOMCalcTrans, Level),                          // Level %2
                                        any2int(InventCostLevel::Single),                       // 1 (= Level Single) %3
                                        fieldStr(BOMCalcTrans, bom),                            // BOM %4
                                        any2int(NoYes::No)));                                   // No %5
            qbrOrCondition.status(RangeStatus::Hidden);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFinishedItemQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for the finished items.
    /// </summary>
    /// <returns>A query containing the finished items.</returns>
    protected Query buildFinishedItemQuery()
    {
        Query query = new Query();
        QueryBuildDataSource qbdsProdCalcTrans = query.addDataSource(tableNum(ProdCalcTrans));
        qbdsProdCalcTrans.addRange(fieldNum(ProdCalcTrans, collectRefLevel)).value(queryValue(collectRefLevel));
        qbdsProdCalcTrans.addRange(fieldNum(ProdCalcTrans, CalcType)).value(queryValue(ItemCalcType::Production));
        qbdsProdCalcTrans.addRange(fieldNum(ProdCalcTrans, TransRefId)).value(queryValue(transRefId));
        qbdsProdCalcTrans.addRange(fieldNum(ProdCalcTrans, TransRefType)).value(queryValue(transRefType));

        QueryBuildDataSource qbdsInventTable = qbdsProdCalcTrans.addDataSource(tableNum(InventTable));
        qbdsInventTable.addLink(fieldNum(ProdCalcTrans, Resource), fieldNum(InventTable, ItemId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates production variances.
    /// </summary>
    /// <param name="_transRefId">
    /// The transaction reference ID.
    /// </param>
    /// <param name="_transRefType">
    /// The transaction reference type, either production or production flow.
    /// </param>
    /// <param name="_collectRefLevel">
    /// The level of the production order within a sub production order stack.
    /// </param>
    /// <param name="_collectRefId">
    /// The reference of the top production order.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// true if variance calculation was successful; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The calculation has been called without knowing the production order on which to perform the
    /// calculation.
    /// </exception>
    public boolean calc(
        CostTransRefId          _transRefId,
        ProdTransRefType        _transRefType,
        Level                   _collectRefLevel,
        CostTransRefId          _collectRefId,
        TransDate               _transDate
        )
    {
        boolean             error;
        boolean             stdCostBased;
        boolean             isStdCostBasedCached;

        this.init(_transRefId, _transRefType, _collectRefLevel, _collectRefId);

        if (!this.validate())
        {
            return false;
        }

        // now loop over the finished items
        QueryRun queryRun = new QueryRun(this.buildFinishedItemQuery());
        while (queryRun.next())
        {
            // The GetNo is used here since the first data source can either be of type ProdCalcTrans or PmfCoByProdCalcTrans
            PmfProdCalcTransMap prodCalcTrans = queryRun.getNo(1);
            InventTable inventTable = queryRun.getNo(2);

            if (!isStdCostBasedCached)
            {
                stdCostBased = inventTable.modelGroup().inventModelType().stdCostBased();
                isStdCostBasedCached = true;
            }

            if (!stdCostBased)
            {
                error = true;
                break;
            }

            InventItemPrice currentInventItemPrice;
            if (_transRefType == ProdTransRefType::Production)
            {
                // If this is a production order and the production order is ended, we need to use the standard cost that was active when the production order was ended.
                ProdTable prodTable = ProdTable::find(_transRefId);
                if (prodTable.ProdStatus == ProdStatus::Completed)
                {
                    currentInventItemPrice = InventCostTrans::getFinancialIssueOrReceiptPriceForProductionOrder(inventTable, prodCalcTrans.inventTransId(), InventDim::find(prodCalcTrans.InventDimId), prodTable.RealDate);
                }
            }

            if (!currentInventItemPrice)
            {
                currentInventItemPrice = InventItemPrice::stdCostFindDate(inventTable,
                                                             _transDate,
                                                             prodCalcTrans.InventDimId);
            }

            this.initEstimate(currentInventItemPrice);

            // Set the actual and estimated qty to calculate the std qty allowed
            this.initQty(prodCalcTrans.RealQty, prodCalcTrans.UnitId);

            this.loadEstimate();
            this.removeFromEstimateMapLinesWithZeroQty();
        }

        if (error)
        {
            return false;
        }

        // Now load the actual values
        this.loadActual();

        // Do the variance calculation
        this.calcVariances();

        if ( InventParameters::find().ProdStandardCostVariance == ProdStandardCostVariance::Summarized)
        {
            // remove all the details
            this.removeDetails();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSubstitutionVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates substitution variances.
    /// </summary>
    /// <returns>
    ///    The substitution variance amount.
    /// </returns>
    protected CostAmount calcSubstitutionVariance()
    {
        if (!transEstimateSet.in(tmpProdStandardVariance.RecId) ||
            !transActualSet.in(tmpProdStandardVariance.RecId))
        {
            return tmpProdStandardVariance.calcSubstitutionVariance();
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVariances</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates variances for each rolled up variance transaction record.
    /// </summary>
    protected void calcVariances()
    {
        CostAmount      prodLotSizeVariance;
        CostAmount      prodCostVariance;
        CostAmount      prodQtyVariance;
        CostAmount      prodSubstitutionVariance;

        CostAmount      realCostAmount;
        CostAmount      realAdjustment;
        CostMarkup      costMarkupQty;
        CostPrice       costPriceQty;
        CostAmount      stdCostAllowedSum;

        while select forupdate tmpProdStandardVariance
        {
            // Reset Variables
            CostAmount curCostVariance         = 0;
            CostAmount curQtyVariance          = 0;
            CostAmount curSubstitutionVariance = 0;

            if (transEstimateSet.in(tmpProdStandardVariance.RecId) &&
                transActualSet.in(tmpProdStandardVariance.RecId))
            {
                curCostVariance            = tmpProdStandardVariance.calcCostVariance();
                curQtyVariance             = tmpProdStandardVariance.calcQtyVariance();
            }
            else
            {
                curSubstitutionVariance    = this.calcSubstitutionVariance();
            }
            tmpProdStandardVariance.update();

            // If I have no cost break down enabled, I need to sum up the split equals yes level,
            // because I am only handling one level here
            // otherwise I must exclude the split equals yes levels
            if (tmpProdStandardVariance.Split == NoYes::No || ! isCostBreakdownActivated)
            {
                prodLotSizeVariance         += tmpProdStandardVariance.LotSizeVariance;
                prodCostVariance            += curCostVariance;
                prodQtyVariance             += curQtyVariance;
                prodSubstitutionVariance    += curSubstitutionVariance;

                costMarkupQty       += tmpProdStandardVariance.CostMarkupQty;
                realCostAmount      += tmpProdStandardVariance.RealCostAmount;
                realAdjustment      += tmpProdStandardVariance.RealCostAdjustment;
                stdCostAllowedSum   += tmpProdStandardVariance.StdCost;
            }
        }

        this.createTotalVariance(prodLotSizeVariance, prodCostVariance, prodQtyVariance, prodSubstitutionVariance, realCostAmount, realAdjustment, costMarkupQty, costPriceQty, stdCostAllowedSum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTotalVariance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates total variance and stores it in the temporary table for variances.
    /// </summary>
    /// <param name="_lotSizeVariance">
    /// The lot size variance amount.
    /// </param>
    /// <param name="_costVariance">
    /// The cost variance amount.
    /// </param>
    /// <param name="_qtyVariance">
    /// The quantity variance amount.
    /// </param>
    /// <param name="_substitutionVariance">
    /// The substitution variance amount.
    /// </param>
    /// <param name="_realCostAmount">
    /// The real cost amount.
    /// </param>
    /// <param name="_realAdjustment">
    /// The real adjustment amount.
    /// </param>
    /// <param name="_costMarkupQty">
    /// The cost markup quantity amount.
    /// </param>
    /// <param name="_costPriceQty">
    /// The cost price quantity amount.
    /// </param>
    /// <param name="_stdCostAllowed">
    /// The allowed standard cost amount.
    /// </param>
    protected void createTotalVariance(
        CostAmount      _lotSizeVariance,
        CostAmount      _costVariance,
        CostAmount      _qtyVariance,
        CostAmount      _substitutionVariance,
        CostAmount      _realCostAmount,
        CostAmount      _realAdjustment,
        CostAmount      _costMarkupQty,
        CostAmount      _costPriceQty,
        CostAmount      _stdCostAllowed
        )
    {
        // Create total
        this.initTotalVariance();

        tmpProdStandardVariance.LotSizeVariance         = _lotSizeVariance;
        tmpProdStandardVariance.CostVariance            = _costVariance;
        tmpProdStandardVariance.QtyVariance             = _qtyVariance;
        tmpProdStandardVariance.SubstitutionVariance    = _substitutionVariance;

        tmpProdStandardVariance.RealCostAmount          = _realCostAmount;
        tmpProdStandardVariance.RealCostAdjustment      = _realAdjustment;
        tmpProdStandardVariance.CostMarkupQty           = _costMarkupQty;
        tmpProdStandardVariance.StdCost                 = _stdCostAllowed;

        tmpProdStandardVariance.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateVarianceTrans</Name>
				<Source><![CDATA[
/// <summary>
    ///    Finds or creates the rolled up variance transaction record for a <c>ProdCalcTrans</c> or
    ///    <c>BOMCalcTrans</c> record.
    /// </summary>
    /// <param name="_bomCalcTransMap">
    ///    A <c>ProdCalcTrans</c> or <c>BOMCalcTrans</c> record.
    /// </param>
    protected void findOrCreateVarianceTrans(BOMCalcTransMap _bomCalcTransMap)
    {
        InventDim                       inventDimItem;      // Holding only item dimensions
        InventCostLevel                 inventCostLevel = min(_bomCalcTransMap.Level, 2);

        switch (_bomCalcTransMap.CalcType)
        {
            // Material
            case ItemCalcType::Item,
                 ItemCalcType::Service,
                 ItemCalcType::BOM,
                 ItemCalcType::Burden:

                // Resolve default OprNum for BOMCalcTrans
                if (_bomCalcTransMap.TableId == tableNum(BOMCalcTrans)  &&
                    bomCalcTable.RouteId                                &&
                    _bomCalcTransMap.OprNum == 0                        &&
                    _bomCalcTransMap.CalcType != ItemCalcType::Burden)
                {
                    _bomCalcTransMap.OprNum = Route::findFirst(bomCalcTable.RouteId).OprNum;
                }

                // Rollup only on the item dimensions
                InventDim inventDimTrans = InventDim::find(_bomCalcTransMap.InventDimId);
                inventDimItem.data(inventDimTrans);
                inventDimItem.clearNotProductDim(InventDimGroupSetup::newItemId(_bomCalcTransMap.Resource));
                inventDimItem = InventDim::findOrCreate(inventDimItem);

                select firstonly forupdate tmpProdStandardVariance
                    where tmpProdStandardVariance.OprNum            == _bomCalcTransMap.OprNum
                       && tmpProdStandardVariance.CostGroupId       == _bomCalcTransMap.CostGroupId
                       && tmpProdStandardVariance.CalcType          == _bomCalcTransMap.CalcType
                       && tmpProdStandardVariance.Resource          == _bomCalcTransMap.Resource
                       && tmpProdStandardVariance.InventDimId       == inventDimItem.InventDimId
                       && tmpProdStandardVariance.InventCostLevel   == inventCostLevel
                       && tmpProdStandardVariance.Split             == _bomCalcTransMap.bom;

                if (!tmpProdStandardVariance)
                {
                    tmpProdStandardVariance.initFromBOMCalcTransMap(_bomCalcTransMap);
                    tmpProdStandardVariance.OprNum          = _bomCalcTransMap.OprNum;
                    tmpProdStandardVariance.Resource        = _bomCalcTransMap.Resource;
                    tmpProdStandardVariance.InventDimId     = inventDimItem.InventDimId;
                    tmpProdStandardVariance.InventCostLevel = inventCostLevel;
                    tmpProdStandardVariance.Split           = _bomCalcTransMap.bom;
                    tmpProdStandardVariance.insert();
                }
                break;

            // Manufacturing
            case ItemCalcType::Process,
                 ItemCalcType::Setup,
                 ItemCalcType::Qty :

                WrkCtrType wrkCtrType = WrkCtrTable::find(_bomCalcTransMap.Resource).WrkCtrType;

                select firstonly forupdate tmpProdStandardVariance
                    where tmpProdStandardVariance.OprNum            == _bomCalcTransMap.OprNum
                       && tmpProdStandardVariance.CostGroupId       == _bomCalcTransMap.CostGroupId
                       && tmpProdStandardVariance.CalcType          == _bomCalcTransMap.CalcType
                       && tmpProdStandardVariance.OprId             == _bomCalcTransMap.OprId
                       && tmpProdStandardVariance.WrkCtrType        == wrkCtrType
                       && tmpProdStandardVariance.InventCostLevel   == inventCostLevel;

                if (!tmpProdStandardVariance)
                {
                    tmpProdStandardVariance.initFromBOMCalcTransMap(_bomCalcTransMap);
                    tmpProdStandardVariance.OprNum          = _bomCalcTransMap.OprNum;
                    tmpProdStandardVariance.OprId           = _bomCalcTransMap.OprId;
                    tmpProdStandardVariance.WrkCtrType      = wrkCtrType;
                    tmpProdStandardVariance.InventCostLevel = inventCostLevel;
                    tmpProdStandardVariance.insert();
                }

                break;

            // Indirect
            case ItemCalcType::IndirectSurcharge,
                 ItemCalcType::IndirectRate,
                 ItemCalcType::IndirectInUnitBased,
                 ItemCalcType::IndirectOutUnitBased,
                 ItemCalcType::IndirectPurchUnitBased :

                select firstonly forupdate tmpProdStandardVariance
                    where tmpProdStandardVariance.CostGroupId       == _bomCalcTransMap.CostGroupId
                       && tmpProdStandardVariance.CalcType          == _bomCalcTransMap.CalcType
                       && tmpProdStandardVariance.Resource          == _bomCalcTransMap.Resource
                       && tmpProdStandardVariance.InventCostLevel   == inventCostLevel;

                if (!tmpProdStandardVariance)
                {
                    tmpProdStandardVariance.initFromBOMCalcTransMap(_bomCalcTransMap);
                    tmpProdStandardVariance.Resource        = _bomCalcTransMap.Resource;
                    tmpProdStandardVariance.InventCostLevel = inventCostLevel;
                    tmpProdStandardVariance.insert();
                }
                break;

            // CostGroup
            case ItemCalcType::CostGroup :

                select firstonly forupdate tmpProdStandardVariance
                    where tmpProdStandardVariance.CostGroupId       == _bomCalcTransMap.CostGroupId
                       && tmpProdStandardVariance.CalcType          == _bomCalcTransMap.CalcType
                       && tmpProdStandardVariance.Resource          == _bomCalcTransMap.Resource
                       && tmpProdStandardVariance.InventCostLevel   == inventCostLevel;

                if (!tmpProdStandardVariance)
                {
                    tmpProdStandardVariance.initFromBOMCalcTransMap(_bomCalcTransMap);
                    tmpProdStandardVariance.Resource        = _bomCalcTransMap.Resource;
                    tmpProdStandardVariance.InventCostLevel = inventCostLevel;
                    tmpProdStandardVariance.insert();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes internal calculation value objects.
    /// </summary>
    /// <param name="_transRefId">
    ///  The transaction reference id.
    /// </param>
    /// <param name="_transRefType">
    ///  The transaction reference type, either production or production flow.
    /// </param>
    /// <param name="_collectRefLevel">
    ///  The level of the production order within a sub production order stack.
    /// </param>
    /// <param name="_collectRefId">
    ///  The reference of the top production order.
    /// </param>
    protected void init(
        CostTransRefId      _transRefId,
        ProdTransRefType    _transRefType,
        Level               _collectRefLevel,
        CostTransRefId      _collectRefId
        )
    {
        TmpProdStandardVariance tmpProdStandardVarianceInit;

        transRefId      = _transRefId;
        transRefType    = _transRefType;
        collectRefLevel = _collectRefLevel;
        collectRefId    = _collectRefId;

        tmpProdStandardVariance = tmpProdStandardVarianceInit;

        transEstimateSet            = new Set(typeName2Type(extendedTypeStr(RecId)));
        transActualSet              = new Set(typeName2Type(extendedTypeStr(RecId)));

        isCostBreakdownActivated  = InventParameters::isCostBreakdownActivated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BOMCalcTable</c> record, based on the <c>InventItemPrice</c> record.
    /// </summary>
    /// <param name="_inventItemPrice">
    /// The <c>InventItemPrice</c> record that is used for finding the <c>BOMCalcTable</c> record that
    /// contains the estimate.
    /// </param>
    protected void initEstimate(
        InventItemPrice     _inventItemPrice
        )
    {
        inventItemPrice = _inventItemPrice;
        bomCalcTable    = BOMCalcTable::find(inventItemPrice.PriceCalcId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQty</Name>
				<Source><![CDATA[
/// <summary>
    /// Initializes the estimated quantity and actual quantity that is used for variance calculation.
    /// </summary>
    /// <param name="_actQty">
    /// The actual quantity value that is used for initialization.
    /// </param>
    /// <param name="_actQtyUnitId">
    /// The actual quantity unit ID.
    /// </param>
    protected void initQty(
        Qty                 _actQty,
        UnitOfMeasureSymbol _actQtyUnitId
        )
    {
        // Reset the quantities
        estQty = 0;
        actQty = 0;

        // Now fill them again
        estQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(inventItemPrice.ItemId,
                                                                                       inventItemPrice.InventDimId,
                                                                                       this.getEstimatedQtyPriceUnit(inventItemPrice),
                                                                                       inventItemPrice.UnitID,
                                                                                       _actQtyUnitId,
                                                                                       NoYes::Yes);

        if (_actQty)
        {
            actQty = _actQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotalVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the total variance record in the temporary table.
    /// </summary>
    protected void initTotalVariance()
    {
        tmpProdStandardVariance.InventCostLevel         = InventCostLevel::Total;
        if ( InventParameters::find().ProdStandardCostVariance == ProdStandardCostVariance::Summarized)
        {
            tmpProdStandardVariance.Split   = NoYes::No;
        }
        else
        {
            tmpProdStandardVariance.Split   = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadActual</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the actual cost that is used for variance calculation.
    /// </summary>
    protected void loadActual()
    {
        InventTableModule   inventTableModuleInvent;

        QueryRun queryRun = new QueryRun(this.buildActualQuery());

        while (queryRun.next())
        {
            tmpProdStandardVariance.clear();
            inventTableModuleInvent.clear();

            BOMCalcTransMap bomCalcTransMap = queryRun.getNo(1);
            PmfProdCalcTransMap prodCalcTrans = queryRun.getNo(1);

            InventQty  realConsump        = prodCalcTrans.RealConsump;
            AmountMST  realCostAmount     = prodCalcTrans.RealCostAmount;
            CostAmount realCostAdjustment = prodCalcTrans.RealCostAdjustment;

            // For subproduction orders, the level needs to be corrects
            prodCalcTrans.CollectRefLevel -= collectRefLevel;

            // //Everything above level 2 is cost accounted as level 2
            prodCalcTrans.CollectRefLevel = min(prodCalcTrans.CollectRefLevel, InventCostLevel::Multi);
            if (prodCalcTrans.CollectRefLevel == InventCostLevel::Multi)
            {
                // On level 2 only costGroup's should exist
                prodCalcTrans.CalcType = ItemCalcType::CostGroup;
            }

            if (prodCalcTrans.CalcType  == ItemCalcType::BOM   ||
                prodCalcTrans.CalcType  == ItemCalcType::Item  ||
                prodCalcTrans.CalcType  == ItemCalcType::Service)
            {
                inventTableModuleInvent = InventTable::find(prodCalcTrans.Resource).inventTableModuleInvent();

                if (inventTableModuleInvent.UnitId != prodCalcTrans.UnitId)
                {
                    EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(prodCalcTrans.Resource,
                                                                                                                                              prodCalcTrans.InventDimId,
                                                                                                                                              prodCalcTrans.UnitId,
                                                                                                                                              inventTableModuleInvent.UnitId,
                                                                                                                                              NoYes::Yes);
                    realConsump         = ecoResProductUnitConverter.convertValue(realConsump);

                    ecoResProductUnitConverter.parmApplyRounding(NoYes::No);

                    realCostAmount      = ecoResProductUnitConverter.convertValue(realCostAmount);
                    realCostAdjustment  = ecoResProductUnitConverter.convertValue(realCostAdjustment);
                }
            }

            this.findOrCreateVarianceTrans(bomCalcTransMap);

            if (tmpProdStandardVariance.RecId)
            {
                this.addTransActual(prodCalcTrans);

                tmpProdStandardVariance.RealConsump         += realConsump;
                tmpProdStandardVariance.RealCostAmount      += realCostAmount;
                tmpProdStandardVariance.RealCostAdjustment  += realCostAdjustment;
                tmpProdStandardVariance.UnitId              =  inventTableModuleInvent.UnitId;
                tmpProdStandardVariance.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the estimated cost that is used for variance calculation.
    /// </summary>
    /// <remarks>
    ///    The estimated cost is loaded from a previous BOM calculation.
    /// </remarks>
    protected void loadEstimate()
    {
        InventTableModule   inventTableModuleInvent;
        BOMCalcTrans        bomCalcTransLevel1;
        Set                 tmpRecQtyAddSet;            // Handles the population of the values for the cost breakdown lines

        // Roll up reference
        if (bomCalcTable)
        {
            QueryRun queryRun = new QueryRun(this.buildEstimateQuery());

            while (queryRun.next())
            {
                tmpProdStandardVariance.clear();
                inventTableModuleInvent.clear();

                // Get the next record
                BOMCalcTrans bomCalcTrans = queryRun.get(tableNum(BOMCalcTrans));

                // Remember the level 1 records
                if (bomCalcTrans.Level == InventCostLevel::Single)
                {
                    bomCalcTransLevel1 = bomCalcTrans.data();
                    tmpRecQtyAddSet = new Set(typeName2Type(extendedTypeStr(RecId)));
                }

                // always use the quantities of the level 1 record
                InventQty consumptionConstant = bomCalcTransLevel1.ConsumptionConstant;
                InventQty consumptionVariable = bomCalcTransLevel1.ConsumptionVariable;

                // Use the BOmCalc instance to get the cost amounts
                CostMarkup costMarkupQty = bomCalcTrans.CostMarkupQty;
                CostPrice costPriceQty = bomCalcTrans.CostPriceQty;

                // //Everything above level 2 is cost accounted as level 2
                bomCalcTrans.Level = min(bomCalcTrans.Level, InventCostLevel::Multi);
                if (bomCalcTrans.Level == InventCostLevel::Multi)
                {
                    // On level 2 only costGroup's should exist
                    bomCalcTrans.CalcType = ItemCalcType::CostGroup;

                    // Assign the resource and operation id from the top level
                    bomCalcTrans.Resource   = bomCalcTransLevel1.Resource;
                    bomCalcTrans.OprId      = bomCalcTransLevel1.OprId;
                }

                if (bomCalcTrans.CalcType   == ItemCalcType::BOM    ||
                    bomCalcTrans.CalcType   == ItemCalcType::Item   ||
                    bomCalcTrans.CalcType   == ItemCalcType::Service)
                {
                    inventTableModuleInvent = InventTable::find(bomCalcTrans.Resource).inventTableModuleInvent();

                    if (inventTableModuleInvent.UnitId != bomCalcTrans.UnitId)
                    {
                        EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(bomCalcTrans.Resource,
                                                                                                                                                  bomCalcTrans.InventDimId,
                                                                                                                                                  bomCalcTrans.UnitId,
                                                                                                                                                  inventTableModuleInvent.UnitId,
                                                                                                                                                  NoYes::Yes,
                                                                                                                                                  NoYes::No);

                        consumptionConstant = ecoResProductUnitConverter.convertValue(consumptionConstant);
                        consumptionVariable = ecoResProductUnitConverter.convertValue(consumptionVariable);
                        costMarkupQty       = ecoResProductUnitConverter.convertValue(costMarkupQty);
                        costPriceQty        = ecoResProductUnitConverter.convertValue(costPriceQty);
                    }
                }

                this.findOrCreateVarianceTrans(bomCalcTrans);

                if (tmpProdStandardVariance.RecId)
                {
                    // Only for the records for this level 1 record,
                    // where the qty has not been added, add it
                    if (!tmpRecQtyAddSet.in(tmpProdStandardVariance.RecId))
                    {
                        this.addTransEstimate(consumptionVariable, consumptionConstant, costMarkupQty, costPriceQty);
                    }
                    else
                    {
                        // for the level 2's only add the cost, but no additional qty
                        this.addTransEstimate(0, 0, costMarkupQty, costPriceQty);
                    }

                    tmpProdStandardVariance.UnitId          =  inventTableModuleInvent.UnitId;
                    tmpProdStandardVariance.update();

                    // Save the information that for this record the qty has already been added
                    tmpRecQtyAddSet.add(tmpProdStandardVariance.RecId);
                }
            }
        }
        else
        {
            // manual price, inject costgroup of produced item as level 1
            select firstonly forupdate tmpProdStandardVariance
                where  tmpProdStandardVariance.CostGroupId       == inventItemPrice.costGroupId()
                    && tmpProdStandardVariance.CalcType          == ItemCalcType::Production
                    && tmpProdStandardVariance.Resource          == inventItemPrice.ItemId
                    && tmpProdStandardVariance.InventDimId       == inventItemPrice.InventDimId
                    && tmpProdStandardVariance.InventCostLevel   == InventCostLevel::Single
                    && tmpProdStandardVariance.Split             == NoYes::No;

            if (!tmpProdStandardVariance)
            {
                tmpProdStandardVariance.CostGroupId     = inventItemPrice.costGroupId();
                tmpProdStandardVariance.CalcType        = ItemCalcType::Production;
                tmpProdStandardVariance.Resource        = inventItemPrice.ItemId;
                tmpProdStandardVariance.InventCostLevel = InventCostLevel::Single;
                tmpProdStandardVariance.Split           = NoYes::No;
                tmpProdStandardVariance.InventDimId     = inventItemPrice.InventDimId;
                tmpProdStandardVariance.insert();
            }

            this.addTransEstimate(0,0,0, inventItemPrice.pcsPrice());

            tmpProdStandardVariance.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpProdStandardVariance</Name>
				<Source><![CDATA[
    public TmpProdStandardVariance parmTmpProdStandardVariance()
    {
        return tmpProdStandardVariance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes from the variances temporary table the records that are not total variances.
    /// </summary>
    protected void removeDetails()
    {
        delete_from tmpProdStandardVariance
            where tmpProdStandardVariance.InventCostLevel != InventCostLevel::Total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the variance calculation can run.
    /// </summary>
    /// <returns>
    ///    true if the variance calculation can run; otherwise, false.
    /// </returns>
    protected boolean validate()
    {
        if (!transRefId)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>variancesByDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Distributes a calculated variance according to the financial dimensions of the transactions that
    ///    are included in the rolled up transaction that is used as a base for the calculation.
    /// </summary>
    /// <returns>
    ///    A temporary table that holds variances that are distributed by dimension.
    /// </returns>
    /// <remarks>
    ///    When the transactions are rolled up for variance calculation, certain details like dimension are
    ///    lost.After the calculation, the result must be distributed according to these lost dimension values
    ///    for posting.
    /// </remarks>
    public TmpProdStandardVariance variancesByDimension()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a variance calculation object based on the <c>ProdTransRefType</c> value.
    /// </summary>
    /// <param name="_transRefType">
    /// The type of variance calculation that is needed.
    /// </param>
    /// <returns>
    /// A variance calculation object that can be used to calculate variances.
    /// </returns>
    /// <remarks>
    ///  Use the following procedure to customize or extend the
    ///  <c>
    ///  ProdStandardVariance
    ///  </c>
    ///   class.
    ///  <list type="number">
    ///   <item>
    ///    <description>
    ///    Create a new class that derives from <c>ProdStandardVariance</c>.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    Overlayer the <c>construct</c> method on <c>ProdStandardVariance</c> so that it returns an instance
    ///    of the derived class.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    Override the methods from the <c>ProdStandardVariance</c> class that you want to customize or
    ///    extend in your derived class.
    ///    </description>
    ///   </item>
    ///  </list>
    ///  This procedure helps to ensure that your customizations are maintained if the base version of the
    ///  <c>
    ///  ProdStandardVariance
    ///  </c>
    ///   class is changed, minimizing code conflicts during an upgrade. For more information, see <see cref="Best Practices for Static Construct Methods" />
    ///  .
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// There are only 2 types of variance calculations: for production and for production flow.
    /// </exception>
    public static ProdStandardVariance construct(
        ProdTransRefType    _transRefType
        )
    {
        switch (_transRefType)
        {
            case ProdTransRefType::Production :
                return new ProdStandardVariance_Prod();
            case ProdTransRefType::ProductionFlow :
                return new ProdStandardVariance();
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeFromEstimateMapLinesWithZeroQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes from the estimated set variances that have standard cost quantity equal zero.
    /// </summary>
    /// <remarks>
    /// This method has been introduced in order to avoid incorrect calculations in the case of estimated qty = 0 (bom line with 0 qty). In that case the
    /// method <c>calcCostVariance</c> of the <c>TmpProdStandardVariance</c> table is unable to calculate variance which results in rounding variance postings.
    /// </remarks>
    private void removeFromEstimateMapLinesWithZeroQty()
    {
        TmpProdStandardVariance localTmpProdStandardVariance;

        localTmpProdStandardVariance.setTmpdata(tmpProdStandardVariance);

        while select localTmpProdStandardVariance
        {
            if (transEstimateSet.in(localTmpProdStandardVariance.RecId) &&
                localTmpProdStandardVariance.stdQtyAllowed() == 0)
            {
                transEstimateSet.remove(localTmpProdStandardVariance.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEstimatedQtyPriceUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns estimated quantity for an <c>InventItemPrice</c> record.
    /// </summary>
    /// <param name="_inventItemPrice">
    /// The <c>InventItemPrice</c> record.
    /// </param>
    /// <returns>
    /// The estimated quantity.
    /// </returns>
    public Qty getEstimatedQtyPriceUnit(InventItemPrice _inventItemPrice)
    {
        Qty tempPriceQty;

        if (_inventItemPrice.PriceCalcId)
        {
            tempPriceQty = BOMCalcTable::find(_inventItemPrice.PriceCalcId).Qty;
        }
        else
        {
            tempPriceQty = _inventItemPrice.PriceUnit();
        }

        return tempPriceQty;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>