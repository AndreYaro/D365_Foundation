<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpd_Picked</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventUpd_Picked</c> class sets the status of inventory transactions as "picked" when
///    printing out a sales order picking list.
/// </summary>
public class InventUpd_Picked extends InventUpdate implements WMSILocationLoadTrackingContext, WHSILocationLoadTrackingContext
{
    // new parameters
    InventQtyPicked                 picked;

    DateInvent                      dateInvent;
    WMSPickingRouteID               wmsPickingRouteID;

    InventDim                       pickInventDimCriteria;
    InventDimParm                   pickInventDimParm;

    InventDim                       reservInventDimCriteria;
    InventDimParm                   reservInventDimParm;

    InventDim                       unPickInventDim;

    InventMovement                  childMovement;

    InventQty                       estimated;
    UnitQty                         estimatedUnit;

    // update result
    InventQtyPicked                 updPicked;

    boolean                         keepExistingDim;

    PdsCWInventQty                  cwPicked;
    PdsCWInventQty                  cwCurPick;
    PdsCWInventQty                  cwEstimated;

    InventQty                       inventQtyAdjustment;
    InventQty                       inventQtyAdjustmentReserve;

    PdsBatchDispCheck_PickList      dispCheck;

    WMSLocationLoadCreateManager    wmsLocationLoadCreateManager;
    WHSLocationLoadChangeTracker    whsLocationLoadChangeTracker;
    boolean                         adjustWMSLocationLoad;

    InventTransIdSum                transIdSumReservation;

    boolean                         forceDimCriteriaOnTransSelect;
    UnknownNoYes                    autoReserveOnPickLess;
    boolean                         skipBatchChecks;
    boolean                         dontSelectReservedTransFirst;
    boolean                         forcePickOnOrderOnly;
    boolean                         skipOnHandCheckDuringTransPick;
    private boolean                 splitWithPessimisticLock;

    private InventDim               cwAdjustInventDim;

    private boolean useDimExistsJoinWithMaximumRowValues;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>pickMoreReservedInventTransUpdating</Name>
				<Source><![CDATA[
    /// <summary>
    /// The delegate is raised before updating a reserved inventory transaction with an increased picking quantity.
    /// </summary>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_addPicked">A pick quantity to add.</param>
    /// <param name = "_cwAddPicked">A CW pick quantity to add.</param>
    delegate void pickMoreReservedInventTransUpdating(InventTrans _inventTrans, InventQty _addPicked, PdsCWInventQty _cwAddPicked)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSLocationLoadChangeTracker</Name>
				<Source><![CDATA[
    public WHSLocationLoadChangeTracker parmWHSLocationLoadChangeTracker(WHSLocationLoadChangeTracker _whsLocationLoadChangeTracker = whsLocationLoadChangeTracker)
    {
        if (prmisDefault(_whsLocationLoadChangeTracker))
        {
            if (!whsLocationLoadChangeTracker)
            {
                whsLocationLoadChangeTracker = WHSLocationLoadChangeTracker::construct();
            }
        }
        else
        {
            whsLocationLoadChangeTracker = _whsLocationLoadChangeTracker;
        }

        return whsLocationLoadChangeTracker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWMSLocationLoadCreateManager</Name>
				<Source><![CDATA[
    public WMSLocationLoadCreateManager parmWMSLocationLoadCreateManager(WMSLocationLoadCreateManager _wmsLocationLoadCreateManager = wmsLocationLoadCreateManager)
    {
        wmsLocationLoadCreateManager = _wmsLocationLoadCreateManager;

        return wmsLocationLoadCreateManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipProductDimensionCheck</Name>
				<Source><![CDATA[
    public boolean canSkipProductDimensionCheck()
    {
        // Do not skip the dimension checks if we expect to create new transactions.
        return !(estimated || cwEstimated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    public boolean check()
    {
        boolean ok = true;

        if (picked && ! movement.checkDimPhysical(picked,pickInventDimCriteria,false))
        {
            ok = false;
        }

        if (!this.checkUpdateMovement(dateInvent))
        {
            ok = false;
        }

        if (!movement.checkCountingLocks(pickInventDimCriteria))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateMovement</Name>
				<Source><![CDATA[
    protected boolean checkUpdateMovement(TransDate _transDate)
    {
        boolean ok = true;

        if (!movement.checkUpdateStandard(_transDate))
        {
            ok = false;
        }

        if (!movement.checkUpdatePicked(this))
        {
            ok = false;
        }

        if (picked < 0 && !movement.checkCountingLocks(pickInventDimCriteria))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    protected void initUpdate()
    {
        estimated       = 0;
        estimatedUnit   = 0;

        cwEstimated     = 0;

        super();

        if (movement.pdsCWItem())
        {
            // The picking code doesn't use last box scenario adjustments with transactions on FV CW items
            // that have been manually split by the user (i.e. have exactly the same dimensions).
            // For this reason we need to sum them up before proceeding.
            if (PdsGlobal::pdsIsCWFullVisItem(movement.itemId()))
            {
                this.pdsSumUpFullVisInventTrans();
            }

            this.pdsCalculateInventQtyAdjustment();

            if (cwPicked > 0)
            {
                if (movement.transIdSum().pdsCWEstimatedIssue() > cwPicked)
                {
                    cwEstimated     = cwPicked - movement.transIdSum().pdsCWEstimatedIssue();
                    // Estimate additional quantity based on nominal conversion. The discrepancy between
                    // the actual and the nominal values will be added to adjustment quantity.
                    estimated       = PdsCatchWeight::inventQty(movement.itemId(), cwEstimated);
                    estimatedUnit   = this.calcEstimatedUnit(estimated);
                }

                // We still need to unpick the quantity that will be adjusted afterwards
                picked += inventQtyAdjustment;
            }

            if (picked <= 0)
            {
                pickInventDimCriteria = InventDim::findOrCreate(pickInventDimCriteria);
            }
        }
        else
        {
            if (picked > 0)
            {
                if (movement.transIdSum().estimatedIssue() > picked)
                {
                    estimated       = picked - movement.transIdSum().estimatedIssue();
                    estimatedUnit   = this.calcEstimatedUnit(estimated);
                }
            }
            else
            {
                pickInventDimCriteria = InventDim::findOrCreate(pickInventDimCriteria);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustWMSLocationLoad</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to adjust the load on a <c>wmsLocation</c> location when a physical transaction
    ///    occurs.
    /// </summary>
    /// <param name="_adjustWMSLocationLoad">
    ///    A Boolean value that determines whether to adjust the load on a <c>wmsLocation</c> location;
    ///    optional.
    /// </param>
    /// <returns>
    ///    true if the load on a <c>wmsLocation</c> location should be adjusted; otherwise, false.
    /// </returns>
    public boolean parmAdjustWMSLocationLoad(boolean _adjustWMSLocationLoad = adjustWMSLocationLoad)
    {
        adjustWMSLocationLoad = _adjustWMSLocationLoad;
        return adjustWMSLocationLoad;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoReserveOnPickLess</Name>
				<Source><![CDATA[
    public UnknownNoYes parmAutoReserveOnPickLess(UnknownNoYes _autoReserveOnPickLess = autoReserveOnPickLess)
    {
        autoReserveOnPickLess = _autoReserveOnPickLess;
        return autoReserveOnPickLess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChildMovement</Name>
				<Source><![CDATA[
    public InventMovement parmChildMovement(InventMovement _childMovement = childMovement)
    {
        childMovement = _childMovement;
        return childMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateInvent</Name>
				<Source><![CDATA[
    public DateInvent parmDateInvent(DateInvent _dateInvent = dateInvent)
    {
        dateInvent = _dateInvent;
        return dateInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForceDimCriteriaOnTransSelect</Name>
				<Source><![CDATA[
    public boolean  parmForceDimCriteriaOnTransSelect(boolean _forceDimCriteriaOnTransSelect = forceDimCriteriaOnTransSelect)
    {
        forceDimCriteriaOnTransSelect = _forceDimCriteriaOnTransSelect;

        return forceDimCriteriaOnTransSelect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKeepExistingDim</Name>
				<Source><![CDATA[
    public boolean parmKeepExistingDim(boolean _keepExistingDim = keepExistingDim)
    {
        keepExistingDim = _keepExistingDim;
        return keepExistingDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets or sets the cwPicked parameter.
    /// </summary>
    /// <param name="_cwPicked">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwPicked parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWPicked(
        PdsCWInventQty _cwPicked = cwPicked)
    {
        cwPicked = _cwPicked;

        return cwPicked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPicked</Name>
				<Source><![CDATA[
    public InventQty parmPicked(InventQty _picked = picked)
    {
        picked = _picked;
        return picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPickingRouteId</Name>
				<Source><![CDATA[
    protected WMSPickingRouteID parmPickingRouteId(WMSPickingRouteID _wmsPickingRouteID = wmsPickingRouteID)
    {
        wmsPickingRouteID = _wmsPickingRouteID;
        return wmsPickingRouteID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPickInventDimCriteria</Name>
				<Source><![CDATA[
    public InventDim parmPickInventDimCriteria(InventDim _inventDimCriteria  = pickInventDimCriteria)
    {
        pickInventDimCriteria = _inventDimCriteria;
        return pickInventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPickInventDimParm</Name>
				<Source><![CDATA[
    protected InventDimParm parmPickInventDimParm(InventDimParm _inventDimParm = pickInventDimParm)
    {
        pickInventDimParm = _inventDimParm;
        return pickInventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReservInventDimCriteria</Name>
				<Source><![CDATA[
    protected InventDim parmReservInventDimCriteria(InventDim _inventDimCriteria  = reservInventDimCriteria)
    {
        reservInventDimCriteria = _inventDimCriteria;
        return reservInventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReservInventDimParm</Name>
				<Source><![CDATA[
    protected InventDimParm parmReservInventDimParm(InventDimParm _inventDimParm = reservInventDimParm)
    {
        reservInventDimParm = _inventDimParm;
        return reservInventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUnPickInventDim</Name>
				<Source><![CDATA[
    public InventDim parmUnPickInventDim(InventDim _inventDim  = unPickInventDim)
    {
        unPickInventDim = _inventDim;
        return unPickInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustInventoryQuantityReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adjusts reservation of inventory quantity for the movement.
    /// </summary>
    /// <param name="_inventQtyReservation">
    ///     The quantity to reserve in inventory unit.
    /// </param>
    protected void pdsAdjustInventoryQuantityReservation(InventQty _inventQtyReservation)
    {
        if (movement.pdsCWItem() && _inventQtyReservation)
        {
            InventUpd_Reservation inventUpd_Reservation = InventUpd_Reservation::newMovement(movement, _inventQtyReservation, true, false, false, 0);
            inventUpd_Reservation.parmPdsCWForceActual(true);
            // Movement inventory dimensions may not contain all required dimensions for WHS items so reserve using adjustment dimensions.
            if (cwAdjustInventDim)
            {
                inventUpd_Reservation.parmInventDimCriteria(cwAdjustInventDim);
            }
            inventUpd_Reservation.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCalculateInventQtyAdjustment</Name>
				<Source><![CDATA[
    private void pdsCalculateInventQtyAdjustment()
    {
        ItemId          itemId = movement.itemId();
        InventTrans     inventTrans;
        InventQty       localPicked = picked;

        if (cwPicked > 0)
        {
            // Picking less

            InventQty sumPicked = movement.transIdSum().picked();
            PdsCWInventQty sumCWPicked = movement.transIdSum().pdsCWPicked();

            inventQtyAdjustment = -localPicked - PdsCatchWeight::adjustSplitInventQty(
                itemId,
                sumCWPicked,
                sumPicked,
                -cwPicked,
                -localPicked);
        }
        else
        {
            // Picking more
            PdsCWInventQty sumCWReserved;
            InventQty sumReserved;

            // WHS items can have reservation on parts of the physical dimensions so we need to search differently with less strict criteria.
            if (this.movement().isItemWHSEnabled())
            {
                InventTransIdSum_WHSMatchOrBlankDimensions inventTransIdSum_WHSMatchOrBlankDimensions = InventTransIdSum_WHSMatchOrBlankDimensions::newWHSMatchOrBlankDimensions(
                        movement.inventTransOriginId(),
                        movement.transChildType() != InventTransChildType::None,
                        movement.transChildType(),
                        movement.transChildRefId(),
                        reservInventDimCriteria);

                sumCWReserved = inventTransIdSum_WHSMatchOrBlankDimensions.pdsCWReserved();
                sumReserved = inventTransIdSum_WHSMatchOrBlankDimensions.reserved();
            }
            else
            {
                sumCWReserved = this.transIdSumReservation().pdsCWReserved();
                sumReserved = this.transIdSumReservation().reserved();
            }

            // Find the already adjusted inventory quantity
            select sum(Qty) from inventTrans
                where inventTrans.PdsCWQty == 0
                && inventTrans.StatusReceipt == StatusReceipt::None
                && inventTrans.StatusIssue == StatusIssue::OnOrder
                && inventTrans.InventTransOrigin == movement.inventTransOriginId();

            if (inventTrans.Qty)
            {
                // Already adjusted quantity can be picked, do don't take it into consideration,
                // when calculating the adjustment.
                localPicked -= inventTrans.Qty;
            }

            if (cwPicked >= sumCWReserved)
            {
                // The whole picked CW quantity is reserved

                inventQtyAdjustment = localPicked - PdsCatchWeight::adjustSplitInventQty(
                    itemId,
                    sumCWReserved,
                    sumReserved,
                    cwPicked,
                    localPicked);

                inventQtyAdjustmentReserve = inventQtyAdjustment < 0 ? inventQtyAdjustment : 0;
            }
            else
            {
                // The part of the picked CW quantity is reserved with preferred inventory dimensions,
                // the rest is on order, or reserved on other inventory dimensions

                PdsCWInventQty sumCWRemaining = movement.transIdSum().pdsCWEstimatedIssue() - sumCWReserved;
                InventQty sumRemaining = movement.transIdSum().estimatedIssue() - sumReserved;

                InventQty splitQty = localPicked - sumReserved;
                PdsCWInventQty splitCWQty = cwPicked - sumCWReserved;

                // Calculate how much of quantity above the reserved is outside the minimum and maximum range
                inventQtyAdjustment = PdsCatchWeight::inventQtyAdjustment(itemId , splitQty, splitCWQty);

                inventQtyAdjustmentReserve = inventQtyAdjustment < 0 ? inventQtyAdjustment : 0;
                splitQty -= inventQtyAdjustment;

                // Increase by the remaining that cannot be fulfilled by the sum of remaining on order
                // and reserved on different than preferred inventory dimensions
                inventQtyAdjustment += splitQty - PdsCatchWeight::adjustSplitInventQty(
                    itemId,
                    sumCWRemaining,
                    sumRemaining,
                    splitCWQty,
                    splitQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsProcessOnHandAdjustment</Name>
				<Source><![CDATA[
    private void pdsProcessOnHandAdjustment()
    {
        if (allowNegativePhysical
            || picked > 0 // There is no adjustment when reducing the pick quantity
            || cwPicked > 0
            || !movement.pdsCWItem())
        {
            return;
        }

        PdsCWInventQty sumCWQtyPhyReserved;
        InventQty sumQtyPhyReserved;

        // WHS items can have reservation on parts of the physical dimensions so we need to search differently with less strict criteria.
        if (this.movement().isItemWHSEnabled())
        {
            InventTransIdSum_WHSMatchOrBlankDimensions inventTransIdSum_WHSMatchOrBlankDimensions = InventTransIdSum_WHSMatchOrBlankDimensions::newWHSMatchOrBlankDimensions(
                        movement.inventTransOriginId(),
                        movement.transChildType() != InventTransChildType::None,
                        movement.transChildType(),
                        movement.transChildRefId(),
                        reservInventDimCriteria);

            sumCWQtyPhyReserved = inventTransIdSum_WHSMatchOrBlankDimensions.pdsCWReserved();
            sumQtyPhyReserved = inventTransIdSum_WHSMatchOrBlankDimensions.reserved();
        }
        else
        {
            sumCWQtyPhyReserved = this.transIdSumReservation().pdsCWReserved();
            sumQtyPhyReserved = this.transIdSumReservation().reserved();
        }

        PdsCWInventQty unreservedCWQtyToPick = min(0, cwPicked - sumCWQtyPhyReserved);
        InventQty unreservedQtyToPick = min(0, picked - sumQtyPhyReserved);

        if (unreservedCWQtyToPick || unreservedQtyToPick)
        {
            InventOnHandQty inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement, pickInventDimCriteria);
            PdsCatchWeightOnHandAdjustment pdsCatchWeightOnHandAdjustment = PdsCatchWeightOnHandAdjustment::newMovement(this.movement());
            pdsCatchWeightOnHandAdjustment.increaseQuantityIfNeeded(inventOnHandQty, unreservedQtyToPick, unreservedCWQtyToPick, pickInventDimCriteria.InventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSumUpFullVisInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sums up on order transactions associated with current movement.
    /// </summary>
    /// <remarks>
    ///     Works only for full visibility catch weight transactions.
    /// </remarks>
    private void pdsSumUpFullVisInventTrans()
    {
        InventTrans     inventTrans;
        InventDim       inventDim;
        InventDimParm   inventDimParm;

        if (!PdsGlobal::pdsIsCWFullVisItem(movement.itemId()))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // There is serial specified on the movement's inventory dimension criteria
        // but the transactions that we want to sum up don't have it set yet. Hence, we need to disable it.
        inventDimParm.data(this.parmPickInventDimParm());
        inventDimParm.InventSerialIdFlag = NoYes::No;

        select firstonly forupdate inventTrans
            where inventTrans.StatusIssue           == StatusIssue::OnOrder
                  && inventTrans.StatusReceipt      == StatusReceipt::None
                  && inventTrans.InventTransOrigin  == movement.inventTransOriginId()
            #InventDimExistsJoin(inventTrans.InventDimId,
                                 inventDim,
                                 this.parmPickInventDimCriteria(),
                                 inventDimParm);

        if (inventTrans)
        {
            inventTrans.updateSumUp();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transIdSumReservation</Name>
				<Source><![CDATA[
    private InventTransIdSum transIdSumReservation()
    {
        if (! transIdSumReservation)
        {
            transIdSumReservation = InventTransIdSum::newParameters(
                movement.inventTransOriginId(),
                movement.transChildType() != InventTransChildType::None,
                movement.transChildType(),
                movement.transChildRefId());

            transIdSumReservation.parmInventDimCriteria(reservInventDimCriteria);
            transIdSumReservation.parmInventDimParmCriteria(reservInventDimParm);
        }
        return transIdSumReservation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBatchDisposition</Name>
				<Source><![CDATA[
    private void checkBatchDisposition()
    {
        if (!skipBatchChecks && #PdsShelfEnabled )
        {
            if (movement.transQty() < 0)
            {
                InventTable inventTable = InventTable::find(movement.inventTable().ItemId);

                if (inventTable.isItemBatchActivated())
                {
                    InventBatch inventBatch;

                    if (pickInventDimCriteria.inventBatchId)
                    {
                        inventBatch = InventBatch::find(pickInventDimCriteria.inventBatchId, inventTable.ItemId);
                    }
                    else if (movement.inventdim().InventBatchId)
                    {
                        inventBatch = InventBatch::find(movement.inventdim().InventBatchId, inventTable.ItemId);
                    }
                    else
                    {
                        inventBatch = InventBatch::find(
                                    InventTrans::findTransId(movement.transId()).inventBatchId(), inventTable.ItemId);
                    }
                    
                    if (inventBatch
                            && inventBatch.PdsDispositionCode
                            && inventBatch.pdsDispositionStatus() == PdsStatus::Unavailable)
                    {
                        dispCheck = PdsBatchDispCheck_PickList::construct();
                        if (!dispCheck.validateCheck(movement.buffer(), inventBatch.InventBatchId))
                        {
                            throw error("@SYS18447");
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow()
    {
        InventInventoryDataServiceSoftReservationHelper::checkSoftReservation(movement);
        
        using (var telemetryTask = new InventUpdateInstrumentationTask(this))
        {
			ttsbegin;

			this.checkBatchDisposition();

			if (picked)
			{
				if (!this.checkUpdateMovement(dateInvent))
				{
					throw error("@SYS18447");
				}

				if (adjustWMSLocationLoad)
				{
					wmsLocationLoadCreateManager = WMSLocationLoadCreateManager::construct();
				}

				if (picked < 0)
				{
					if (estimated || cwEstimated)
					{
						this.updateEstimated(
									estimated,
									estimatedUnit,
									cwEstimated);
					}

                    if (this.movement().isItemWHSEnabled() && this.movement().pdsCWItem() && reservInventDimCriteria)
                    {
                        // Reservation dimensions may not match source line, so pass appropriate reservation dimensions to quantity adjustment.
                        cwAdjustInventDim.initFromInventDim(reservInventDimCriteria);
                        cwAdjustInventDim.clearLocationAndBelowDim(this.movement().itemId());
                        cwAdjustInventDim = InventDim::findOrCreate(cwAdjustInventDim);

                        this.pdsAdjustInventoryQuantity(inventQtyAdjustment, cwAdjustInventDim.inventDimId);
                    }
                    else
                    {
                        this.pdsAdjustInventoryQuantity(inventQtyAdjustment);
                    }
					this.pdsProcessOnHandAdjustment();
					this.pdsAdjustInventoryQuantityReservation(inventQtyAdjustmentReserve);

					this.updatePickMore();
				}
				else
				{
					this.updatePickLess();
					this.pdsAdjustInventoryQuantity(inventQtyAdjustment);
				}

				if (adjustWMSLocationLoad)
				{
					wmsLocationLoadCreateManager.insertRecords();
				}

				movement.updatePeggingRequirements();
			}

			ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomIssueInventTrans</Name>
				<Source><![CDATA[
    internal boolean validateCustomIssueInventTrans(
        StatusIssue                             _fromStatus,
        StatusIssue                             _toStatus,
        InventDimId                             _inventDimId,
        InventDim                               _inventDimCriteria,
        InventDimParm                           _inventDimParm,
        InventTransChildType                    _inventTransChildType,
        InventTransChildRefId                   _inventTransChildRefId,
        InventUpdateCustomTransIssueListItem    _listItem)
    {
        boolean result = true;
        
        if (picked > 0)
        {
            result = wmsPickingRouteID == '' || _listItem.inventTrans.PickingRouteID == wmsPickingRouteID;
        }

        return result && super(_fromStatus, _toStatus, _inventDimId, _inventDimCriteria, _inventDimParm, _inventTransChildType, _inventTransChildRefId, _listItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickInventTrans</Name>
				<Source><![CDATA[
    protected InventQtyPicked updatePickInventTrans(
        InventTrans         _inventTrans,
        InventQtyPicked     _addPicked,
        PdsCWInventQty      _cwAddPicked
        )
    {
        boolean                 checkOnhand;

        if (! movement.inventTable().checkRefInventTrans(_inventTrans))
        {
            throw error("@SYS18447");
        }

        InventItemOrderSetupMap inventItemOrderSetupMap = movement.inventItemOrderSetupMap(pickInventDimCriteria.InventDimId);
        if (!inventItemOrderSetupMap.checkInventLocationId(pickInventDimCriteria.InventLocationId,!movement.canBeOnAllInventLocations())
        ||  !inventItemOrderSetupMap.checkInventSiteId(pickInventDimCriteria.InventSiteId,!movement.canBeOnAllInventSites()))
        {
            throw error("@SYS18447");
        }

        InventDim inventDimFrom = _inventTrans.inventDim();

        if (keepExistingDim)
        {
            pickInventDimCriteria = inventDimFrom;
        }

        if (!skipBatchChecks && #PdsShelfEnabled)
        {
            if (!dispCheck)
            {
                dispCheck = PdsBatchDispCheck_PickList::construct();
                dispCheck.parmSuppressMessage(false);
            }

            if (!dispCheck.validateTransCheck(_inventTrans, movement.buffer(), pickInventDimCriteria.InventBatchId))
            {
                throw error("@SYS18447");
            }
        }

        if (!this.checkInventDimChangeOnInventTransUpdate(inventDimFrom, pickInventDimCriteria))
        {
            throw error("@SYS18447");
        }

        InventQty updateNowQuantity = this.transactionIssueQuantity(_inventTrans, _addPicked);
        PdsCWInventQty updateNowCWQuantity = this.transactionIssueCWQuantity(_inventTrans, _cwAddPicked);

        if (updateNowQuantity > _inventTrans.Qty || updateNowCWQuantity > _inventTrans.PdsCWQty)
        {
            InventQty splitQuantity = this.transactionIssueSplitQuantity(_inventTrans, updateNowQuantity, _addPicked);
            
            using (InventTransUpdateSplitWithPessimisticLockContext context = InventTransUpdateSplitWithPessimisticLockContext::construct())
            {
                context.parmSplitWithPessimisticLock(splitWithPessimisticLock);

                _inventTrans.updateSplit(splitQuantity, _cwAddPicked);
            }
        }

        if (_inventTrans.StatusIssue != StatusIssue::ReservPhysical && !this.parmSkipOnHandCheckDuringTransPick())
        {
            checkOnhand = true;
        }
        else if (pickInventDimCriteria.InventDimId != _inventTrans.InventDimId &&
            InventDim::mustCheckDimChange(movement.inventDimGroupSetup(), pickInventDimCriteria, inventDimFrom))
        {
            // Process dimension changes differently for WHS items
            if (WHSInventEnabled::exist(_inventTrans.ItemId))
            {
                if (allowNegativePhysical)
                {
                    this.parmSkipOnHandCheckDuringTransPick(true);
                }
                if (!this.whsCheckInventTransDimensionChange(_inventTrans, pickInventDimCriteria))
                {
                    throw error("@SYS18447");
                }
            }
            else
            {
                checkOnhand = true;
            }
        }

        if (checkOnhand)
        {
            InventOnHandQty inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement, pickInventDimCriteria);

            if (!inventOnHandQty.checkItemDraw(_inventTrans.Qty,
                                               allowNegativePhysical,
                                               true,
                                               _inventTrans.PdsCWQty))
            {
                throw error("@SYS18447");
            }
        }

        this.initPickInventTrans(_inventTrans, pickInventDimCriteria, inventDimFrom);

        movement.initInventTransPicked(_inventTrans,wmsPickingRouteID);
        movement.transIdSum().setInventTransStatus(_inventTrans,StatusReceipt::None,StatusIssue::Picked);

        InventUpdate::updateTransDimTransferReceipt(movement,_inventTrans, pickInventDimCriteria);
        InventTrans origInventTrans = _inventTrans.orig();

        movement.updateSerialNumIssue(_inventTrans, origInventTrans, pickInventDimCriteria);
        this.raiseOnHandChangingOnPhysicalStatusUpd(_inventTrans, origInventTrans, pickInventDimCriteria);

        _inventTrans.update();

        if (_inventTrans.ProjId)
        {
            InventTrans inventTransIssue;
            InventTransOrigin inventTransOrigin;

            update_recordset inventTransIssue
            setting
                InventDimId = _inventTrans.InventDimId
                where inventTransIssue.inventTransOrigin == _inventTrans.MarkingRefInventTransOrigin
                    && inventTransIssue.InventDimId != _inventTrans.InventDimId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTransIssue.MarkingRefInventTransOrigin
                    && inventTransOrigin.ReferenceCategory == InventTransType::Purch;
        }

        if (!movement.checkDimPhysical(_inventTrans.Qty, pickInventDimCriteria,true))
        {
            throw error("@SYS18447");
        }

        _addPicked  -= _inventTrans.Qty;
        updPicked   += _inventTrans.Qty;

        cwCurPick = _inventTrans.PdsCWQty;

        if (!this.parmSkipInventTransSumUp())
        {
            _inventTrans.updateSumUp();
        }

        return _addPicked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckInventTransDimensionChange</Name>
				<Source><![CDATA[
    private boolean whsCheckInventTransDimensionChange(InventTrans _inventTrans, InventDim _toInventDim)
    {
        using (WHSInventCheckDimChangeContext context = WHSInventCheckDimChangeContext::construct())
        {
            context.skipOnHandCheck = this.parmSkipOnHandCheckDuringTransPick();
            return WHSInvent::checkDimChange(_inventTrans, _toInventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPickInventTrans</Name>
				<Source><![CDATA[
    private void initPickInventTrans(InventTrans _inventTrans, InventDim _pickInventDimCriteria, InventDim _inventDimFrom)
    {
        _inventTrans.InventDimId = this.inventDimIdForPickInventTrans(_inventTrans, _pickInventDimCriteria, _inventDimFrom);
        _inventTrans.DateInvent = dateInvent;

        if (movement.mustClearChildRef())
        {
            _inventTrans.TransChildType   = InventTransChildType::None;
            _inventTrans.TransChildRefId  = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimIdForPickInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>InventDimId</c> for the picked <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">
    /// The picked <c>InventTrans</c> record.
    /// </param>
    /// <param name = "_pickInventDimCriteria">
    /// The <c>InventDim</c> criteria record.
    /// </param>
    /// <param name = "_inventDimFrom">
    /// The original <c>InventDim</c> record.
    /// </param>
    /// <returns>
    /// The <c>InventDimId</c> for the picked <c>InventTrans</c> record.
    /// </returns>
    protected InventDimId inventDimIdForPickInventTrans(InventTrans _inventTrans, InventDim _pickInventDimCriteria, InventDim _inventDimFrom)
    {
        return _pickInventDimCriteria.inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickLess</Name>
				<Source><![CDATA[
    protected void updatePickLess()
    {
        InventTrans                     inventTrans;
        InventDim                       inventDim;
        InventDimParm                   inventDimParmTo;
        InventDimParm                   inventDimParmFrom;

        InventQty                       addPicked = picked;
        boolean                         unPickToNewDim;

        PdsCWInventQty                  addPickedCW = cwPicked;

        if (unPickInventDim.InventDimId && !InventDim::isInventDimEqual(unPickInventDim,pickInventDimCriteria))
        {
            unPickToNewDim = true;
        }

        if (this.parmCustomInventTransListInitialized())
        {
            this.initializeInventTransToIssueListWithCustomInventTransList(StatusIssue::Picked, 
                                                                           StatusIssue::Picked, 
                                                                           pickInventDimCriteria.inventDimId,
                                                                           pickInventDimCriteria,
                                                                           pickInventDimParm,
                                                                           movement.transChildType(),
                                                                           movement.transChildRefId());
            this.getNextInventTransToIssue(inventTrans);
        }
        else
        {
            if (pickInventDimCriteria.InventDimId && pickInventDimParm.isAllFlagYes())
            {
                select forupdate inventTrans
                order by InventDimId desc
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                   && inventTrans.TransChildType        == movement.transChildType()
                   && inventTrans.TransChildRefId       == movement.transChildRefId()
                   && inventTrans.StatusReceipt         == StatusReceipt::None
                   && inventTrans.StatusIssue           == StatusIssue::Picked
                   && inventTrans.InventDimId           == pickInventDimCriteria.InventDimId
                   && (wmsPickingRouteID == '' || inventTrans.PickingRouteID == wmsPickingRouteID);
            }
            else
            {
                select forupdate forceplaceholders inventTrans
                order by InventDimId desc
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                   && inventTrans.TransChildType        == movement.transChildType()
                   && inventTrans.TransChildRefId       == movement.transChildRefId()
                   && inventTrans.StatusReceipt         == StatusReceipt::None
                   && inventTrans.StatusIssue           == StatusIssue::Picked
                   && (!wmsPickingRouteID      || inventTrans.PickingRouteID == wmsPickingRouteID)
                #InventDimExistsJoin(InventTrans.inventDimId,InventDim,PickInventDimCriteria,PickInventDimParm);
            }
        }

        while (inventTrans)
        {
            InventQty updateNowQuantity = this.transactionIssueQuantity(inventTrans, -addPicked);
            PdsCWInventQty updateNowCWQuantity = this.transactionIssueCWQuantity(inventTrans, -addPickedCW);

            if (updateNowQuantity > inventTrans.Qty || updateNowCWQuantity > inventTrans.PdsCWQty)
            {
                InventQty splitQuantity = this.transactionIssueSplitQuantity(inventTrans, updateNowQuantity, -addPicked);
                inventTrans.updateSplit(splitQuantity, -addPickedCW);
            }

            addPickedCW += inventTrans.PdsCWQty;
            addPicked   += inventTrans.Qty;
            updPicked   -= inventTrans.Qty;

            InventDim inventDimPickedFrom = InventDim::find(inventTrans.InventDimId);
            this.initializePickLessInventoryTransaction(inventTrans);
            movement.initInventTransPicked(inventTrans,'');

            InventUpdate::updateTransDimTransferReceipt(movement,inventTrans,inventTrans.inventDim());

            inventTrans origInventTrans = inventTrans.orig();
            movement.updateSerialNumReceipt(inventTrans, origInventTrans);

            this.raiseOnHandChangingOnPhysicalStatusUpd(inventTrans, origInventTrans, null, inventDimPickedFrom);
            inventTrans.update();

            //handle unpicking to new dimensions
            if (unPickToNewDim)
            {
                if (inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                {
                    inventDimParmFrom.setAllInventDim();

                    // Remove reservation if exists
                    this.updateDimReservePhysical(InventDim::find(inventTrans.InventDimId),-inventTrans.Qty);
                    movement.transIdSum().setInventTransStatus(inventTrans,StatusReceipt::None,StatusIssue::OnOrder);
                    inventTrans.InventDimId = movement.inventdim().InventDimId;

                    InventUpdate::updateTransDimTransferReceipt(movement,inventTrans,inventTrans.inventDim());

                    inventTrans.update();
                }

                InventDim inventDimUnPickTo = inventDimPickedFrom.data();
                #InventDimDevelop
                inventDimUnPickTo.InventLocationId = unPickInventDim.InventLocationId;
                inventDimUnPickTo.wmsLocationId    = unPickInventDim.wmsLocationId;
                inventDimUnPickTo.wmsPalletId      = unPickInventDim.wmsPalletId;
                // Added License Plate & Inventory Status
                inventDimUnPickTo.LicensePlateId= unPickInventDim.LicensePlateId;
                inventDimUnPickTo.InventStatusId= unPickInventDim.InventStatusId;

                inventDimUnPickTo.InventDimId = InventDim::findOrCreate(inventDimUnPickTo).InventDimId;

                if (!this.checkInventDimChangeOnInventTransUpdate(inventDimPickedFrom, inventDimUnPickTo))
                {
                    throw error("@SYS18447");
                }

                inventDimParmTo.initFromInventDim(inventDimUnPickTo);

                if (inventTrans.MarkingRefInventTransOrigin && !InventDim::isInventDimEqualFinancialDim(movement.inventDimGroupSetup(), inventDimPickedFrom, inventDimUnPickTo))
                {
                    throw error("@SYS105866");
                }

                if (!movement.checkDimPhysical(inventTrans.Qty, inventDimUnPickTo, true))
                {
                    throw error("@SYS18447");
                }

                // Transfer item from pick destination to new unpick destination
                InventUpd_Financial::updateVirtuelTransfer(inventTrans.ItemId,
                    inventDimPickedFrom.InventDimId,
                    inventDimUnPickTo.InventDimId,
                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                    -inventTrans.Qty,
                    false,
                    true,
                    -inventTrans.PdsCWQty
                    );

                if (inventTrans.InventDimFixed)
                {
                    // Check if fixed dim is still the same?
                    if (!InventDim::isInventDimFixedEqual(inventDimPickedFrom,inventDimUnPickTo,inventTrans.InventDimFixed))
                    {
                        throw error("@SYS105867");
                    }

                    inventTrans.InventDimId = inventDimUnPickTo.InventDimId;

                    movement.transIdSum().setInventTransStatus(inventTrans,StatusReceipt::None,StatusIssue::ReservPhysical);

                    InventUpdate::updateTransDimTransferReceipt(movement,inventTrans,inventTrans.inventDim());

                    inventTrans.update();
                }
            }

            if (childMovement)
            {
                inventTrans.TransChildType  = childMovement.transChildType();
                inventTrans.TransChildRefId = childMovement.transChildRefId();
                inventTrans.update();
            }

            //sum up must be done after all fields on inventtrans are set, to avoid updating the summed quantity
            inventTrans.updateSumUp();

            if (!addPicked && !addPickedCW)
            {
                break;
            }

            this.getNextInventTransToIssue(inventTrans);
        }

        this.verifyCustomInventTransUpdate(addPicked);

        if (addPicked || addPickedCW)
        {
            throw error(strFmt("@SYS53777",addPicked));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePickLessInventoryTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory transaction record.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction record.</param>
    protected void initializePickLessInventoryTransaction(InventTrans _inventTrans)
    {
        if (movement.canBeReserved()
            && autoReserveOnPickLess != UnknownNoYes::No
            && (autoReserveOnPickLess == UnknownNoYes::Yes || _inventTrans.InventDimFixed || movement.mustBeAutoReserved()))
        {
            if (movement.pdsCWItem() && movement.isItemWHSEnabled())
            {
                InventQty minWeight;

                WMSOrderUnpickUpdateCatchWeightUnpickQtyContext context = WMSOrderUnpickUpdateCatchWeightUnpickQtyContext::current();
                if (context && context.parmWmsOrderTransQty())
                {
                    minWeight = context.parmWmsOrderTransQty();
                }
                else
                {
                    // We only want to reserve min weight so decrease unpicked inventTrans so that it is min weight and delete remainder.
                    minWeight = WhsInvent::defaultCatchWeightReserveQuantity(_inventTrans.ItemId, _inventTrans.PdsCWQty);
                }

                // If min weight is less than transaction weight then we need to split the transaction.
                // Both values are negative so compare as greater than.
                if (minWeight > _inventTrans.Qty)
                {
                    if (minWeight)
                    {
                        InventTrans inventTransWeightDecrease = _inventTrans.updateSplit(minWeight, _inventTrans.PdsCWQty);
                        // Reduce values of inventory quantity on the source lines.
                        movement.pdsAdjustInventoryQuantity(-inventTransWeightDecrease.Qty);
                        movement.updateDoBuffer(); // Use do update because we are explicidly deleting the inventTrans below.

                        // Delete the transaction with excess weight.
                        inventTransWeightDecrease.delete(NoYes::No, NoYes::No); // Don't delete InventTransOrigin
                        movement.transIdSum(true); // Because we are deleting a transaction the totals must be recalculated.
                    }
                }
            }

            movement.transIdSum().setInventTransStatus(_inventTrans, StatusReceipt::None, StatusIssue::ReservPhysical);
        }
        else
        {
            this.updateDimReservePhysical(InventDim::find(_inventTrans.InventDimId),
                                          -_inventTrans.Qty,
                                          0,
                                          -_inventTrans.PdsCWQty
                                          );

            movement.transIdSum().setInventTransStatus(_inventTrans, StatusReceipt::None, StatusIssue::OnOrder);
            _inventTrans.InventDimId = movement.inventdim().InventDimId;
        }

        _inventTrans.DateInvent = dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickMore</Name>
				<Source><![CDATA[
    protected void updatePickMore()
    {
        InventQty       addPicked   = picked;
        PdsCWInventQty  cwAddPicked = cwPicked;

        if (!dontSelectReservedTransFirst && !this.parmForcePickOnOrderOnly())
        {
            [addPicked, cwAddPicked] = this.pickMoreReservedInventTrans(addPicked, cwAddPicked);
            if (addPicked && reservInventDimCriteria.inventLocation().WHSEnabled && movement.isItemWHSEnabled())
            {
                InventDim reserveInventDimCriteriaLocal;
              
                reserveInventDimCriteriaLocal.data(reservInventDimCriteria);
                reservInventDimCriteria.clearLocationAndBelowDim(movement.itemId());
                // Reconsider location above reservation for whs item.
                if (!InventDim::isInventDimEqual(reservInventDimCriteria, reserveInventDimCriteriaLocal))
                {
                    reservInventDimCriteria.inventDimId = '';
                    [addPicked, cwAddPicked] = this.pickMoreReservedInventTrans(addPicked, cwAddPicked);
                }

                if (addPicked 
                    && !this.parmForceDimCriteriaOnTransSelect())
                {
                    useDimExistsJoinWithMaximumRowValues = true;
                    [addPicked, cwAddPicked] = this.pickMoreOnOrderInventTrans(addPicked, cwAddPicked);
                }

                reservInventDimCriteria.data(reserveInventDimCriteriaLocal);
                useDimExistsJoinWithMaximumRowValues = false;
            }
        }

        if (addPicked && !this.parmForceDimCriteriaOnTransSelect())
        {
            [addPicked, cwAddPicked] = this.pickMoreOnOrderInventTrans(addPicked, cwAddPicked);
        }

        if (addPicked)
        {
            this.validateUnpickedQuantity(addPicked);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUnpickedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates an unpicked inventory quantity.
    /// </summary>
    /// <param name = "_addPicked">An unpicked inventory quantity.</param>
    protected void validateUnpickedQuantity(InventQty _addPicked)
    {
        if (!movement.transChildType() && InventTrans::qtyWMSOrder(movement.inventTransOriginId()))
        {
            error(strFmt("@SYS54900",-_addPicked,StatusIssue::OnOrder,StatusIssue::ReservOrdered,StatusIssue::ReservPhysical));
            throw error(strFmt("@SYS54901",-InventTrans::qtyWMSOrder(movement.inventTransOriginId())));
        }

        throw error(strFmt("@SYS54900",-_addPicked,StatusIssue::OnOrder,StatusIssue::ReservOrdered,StatusIssue::ReservPhysical));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickMoreReservedInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the reserved inventory transactions that can be used for the update.
    /// </summary>
    /// <returns>The reserved inventory transactions that can be used for the update.</returns>
    private InventTrans findPickMoreReservedInventTrans()
    {
        if (this.parmCustomInventTransListInitialized())
        {
            return this.findPickMoreCustomInventTrans();
        }

        return this.findPickMoreReservedQueryInventTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickMoreCustomInventTrans</Name>
				<Source><![CDATA[
    private InventTrans findPickMoreCustomInventTrans()
    {
        StatusIssue statusIssueFrom = StatusIssue::ReservPhysical;
        if (this.parmForcePickOnOrderOnly())
        {
            statusIssueFrom = StatusIssue::OnOrder;
        }

        StatusIssue statusIssueTo = StatusIssue::OnOrder;
        InventDimParm inventDimParm;
        if (this.parmForceDimCriteriaOnTransSelect())
        {
            statusIssueTo = StatusIssue::ReservOrdered;
            inventDimParm = reservInventDimParm;
        }

        this.initializeInventTransToIssueListWithCustomInventTransList(statusIssueFrom,
                                                                       statusIssueTo,
                                                                       reservInventDimCriteria.InventDimId,
                                                                       reservInventDimCriteria,
                                                                       inventDimParm,
                                                                       movement.transChildType(),
                                                                       movement.transChildRefId());

        InventTrans inventTrans;
        this.getNextInventTransToIssue(inventTrans);

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickMoreReservedQueryInventTrans</Name>
				<Source><![CDATA[
    private InventTrans findPickMoreReservedQueryInventTrans()
    {
        InventTrans inventTrans;
        InventDim inventDim;

        if (reservInventDimCriteria.InventDimId && reservInventDimParm.isAllFlagYes())
        {
            select forupdate inventTrans
                order by StatusIssue,InventDimId, Qty desc       // order by quantity to minimize splitting of transactions
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                   && inventTrans.TransChildType        == movement.transChildType()
                   && inventTrans.TransChildRefId       == movement.transChildRefId()
                   && inventTrans.StatusReceipt         == StatusReceipt::None
                   && inventTrans.StatusIssue           >= StatusIssue::ReservPhysical
                   && inventTrans.StatusIssue           <= StatusIssue::ReservOrdered
                   && inventTrans.InventDimId           == reservInventDimCriteria.InventDimId;
        }
        else
        {
            select forupdate forceplaceholders inventTrans
                order by StatusIssue,InventDimId, Qty desc       // order by quantity to minimize splitting of transactions
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                   && inventTrans.TransChildType        == movement.transChildType()
                   && inventTrans.TransChildRefId       == movement.transChildRefId()
                   && inventTrans.StatusReceipt         == StatusReceipt::None
                   && inventTrans.StatusIssue           >= StatusIssue::ReservPhysical
                   && inventTrans.StatusIssue           <= StatusIssue::ReservOrdered
                #InventDimExistsJoin(InventTrans.inventDimId, inventDim, reservInventDimCriteria, reservInventDimParm);
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMoreReservedInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks reserved inventory transactions.
    /// </summary>
    /// <param name = "_addPicked">An inventory quantity to pick.</param>
    /// <param name = "_cwAddPicked">A CW inventory quantity to pick.</param>
    /// <returns>A container with a quantity and a CW quantity left to pick.</returns>
    protected container pickMoreReservedInventTrans(InventQty _addPicked, PdsCWInventQty _cwAddPicked)
    {
        InventTrans inventTrans = this.findPickMoreReservedInventTrans();

        return this.updatePickMoreReservedInventTrans(inventTrans, _addPicked, _cwAddPicked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickMoreReservedInventTrans</Name>
				<Source><![CDATA[
    private container updatePickMoreReservedInventTrans(InventTrans _inventTrans, InventQty _addPicked, PdsCWInventQty _cwAddPicked)
    {
        while (_inventTrans)
        {
            this.pickMoreReservedInventTransUpdating(_inventTrans, _addPicked, _cwAddPicked);

            _addPicked = this.updatePickInventTrans(_inventTrans, _addPicked, _cwAddPicked);

            _cwAddPicked -= cwCurPick;

            if (!_addPicked)
            {
                break;
            }

            this.getNextInventTransToIssue(_inventTrans);
        }

        this.verifyCustomInventTransUpdate(_addPicked);

        return [_addPicked, _cwAddPicked];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickMoreOnOrderInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the on-order inventory transactions that can be used for the update.
    /// </summary>
    /// <returns>The on-order inventory transactions that can be used for the update.</returns>
    private InventTrans findPickMoreOnOrderInventTrans()
    {
        StatusIssue statusIssueFrom;

        if (this.parmForcePickOnOrderOnly())
        {
            statusIssueFrom = StatusIssue::OnOrder;
        }
        else
        {
            statusIssueFrom = StatusIssue::ReservPhysical;
        }

        if (this.parmCustomInventTransListInitialized())
        {
            return this.findPickMoreCustomInventTrans();
        }

        return this.findPickMoreOnOrderQueryInventTrans(statusIssueFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickMoreOnOrderQueryInventTrans</Name>
				<Source><![CDATA[
    protected InventTrans findPickMoreOnOrderQueryInventTrans(StatusIssue _statusIssueFrom)
    {
        InventTrans inventTrans;

        if (useDimExistsJoinWithMaximumRowValues)
        {
            InventDim inventDim;

            select forupdate forceplaceholders inventTrans
                order by StatusIssue,InventDimId, Qty desc
                where inventTrans.InventTransOrigin == movement.inventTransOriginId()
                   && inventTrans.TransChildType == movement.transChildType()
                   && inventTrans.TransChildRefId == movement.transChildRefId()
                   && inventTrans.StatusReceipt == StatusReceipt::None
                   && inventTrans.StatusIssue >= _statusIssueFrom
                    && inventTrans.StatusIssue <= StatusIssue::OnOrder
                #WHSInventDimExistsJoin(inventTrans.inventDimId, inventDim, reservInventDimCriteria);
        }
        else
        {
            select forupdate inventTrans
            // This MUST be sorted by status issue first, so if reserved quantity is included
            // it is processed ahead of on order quantity
            order by StatusIssue, InventDimId, Qty desc
                where inventTrans.InventTransOrigin == movement.inventTransOriginId()
                    && inventTrans.TransChildType   == movement.transChildType()
                    && inventTrans.TransChildRefId  == movement.transChildRefId()
                    && inventTrans.StatusReceipt    == StatusReceipt::None
                    && inventTrans.StatusIssue      >= _statusIssueFrom
                    && inventTrans.StatusIssue      <= StatusIssue::OnOrder;
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMoreOnOrderInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks on order inventory transactions.
    /// </summary>
    /// <param name = "_addPicked">An inventory quantity to pick.</param>
    /// <param name = "_cwAddPicked">A CW inventory quantity to pick.</param>
    /// <returns>A container with a quantity and CW quantity left to pick.</returns>
    protected container pickMoreOnOrderInventTrans(InventQty _addPicked, PdsCWInventQty _cwAddPicked)
    {
        InventTrans inventTrans = this.findPickMoreOnOrderInventTrans();

        return this.updatePickMoreOnOrderInventTrans(inventTrans, _addPicked, _cwAddPicked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickMoreOnOrderInventTrans</Name>
				<Source><![CDATA[
    private container updatePickMoreOnOrderInventTrans(InventTrans _inventTrans, InventQty _addPicked, PdsCWInventQty _cwAddPicked)
    {
        while (_inventTrans)
        {
            _addPicked = this.updatePickInventTrans(_inventTrans, _addPicked, _cwAddPicked);

            _cwAddPicked -= cwCurPick;

            if (!_addPicked)
            {
                break;
            }

            this.getNextInventTransToIssue(_inventTrans);
        }

        this.verifyCustomInventTransUpdate(_addPicked);

        return [_addPicked, _cwAddPicked];
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static protected InventUpd_Picked construct(InventMovement _movement)
    {
        InventUpd_Picked inventUpd_Picked = new InventUpd_Picked(_movement);

        return inventUpd_Picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    static public InventUpd_Picked newParameters(
        InventMovement        _movement,
        InventDim             _pickInventDimCriteria,
        InventDimParm         _pickInventDimParm,
        InventDim             _reservInventDimCriteria,
        InventDimParm         _reservInventDimParm,
        InventQtyPicked       _picked,
        WMSPickingRouteID     _pickingRouteId = '',
        InventQtyPicked      _cwPicked = 0
        )
    {
        InventUpd_Picked inventUpd_Picked = new InventUpd_Picked(_movement);
        inventUpd_Picked.setParmAllowDefault();

        inventUpd_Picked.parmPickInventDimCriteria(_pickInventDimCriteria);
        inventUpd_Picked.parmPickInventDimParm(_pickInventDimParm);
        inventUpd_Picked.parmReservInventDimCriteria(_reservInventDimCriteria);
        inventUpd_Picked.parmReservInventDimParm(_reservInventDimParm);

        inventUpd_Picked.parmDateInvent(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        inventUpd_Picked.parmPicked(_picked);
        inventUpd_Picked.parmAdjustWMSLocationLoad(true);

        inventUpd_Picked.parmPdsCWPicked(_cwPicked);

        inventUpd_Picked.parmPickingRouteId(_pickingRouteId);

        inventUpd_Picked.initUpdate();

        return inventUpd_Picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDontSelectReservedTransFirst</Name>
				<Source><![CDATA[
    public boolean parmDontSelectReservedTransFirst(boolean _dontSelectReservedTransFirst = dontSelectReservedTransFirst)
    {
        dontSelectReservedTransFirst = _dontSelectReservedTransFirst;

        return dontSelectReservedTransFirst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForcePickOnOrderOnly</Name>
				<Source><![CDATA[
    public boolean parmForcePickOnOrderOnly(boolean _forcePickOnOrderOnly = forcePickOnOrderOnly)
    {
        if (forcePickOnOrderOnly != _forcePickOnOrderOnly)
        {
            forcePickOnOrderOnly = _forcePickOnOrderOnly;

            movement.parmAutoReserveWhenAdjustingCatchWeight(!forcePickOnOrderOnly);
        }
        
        return forcePickOnOrderOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipBatchChecks</Name>
				<Source><![CDATA[
    public boolean  parmSkipBatchChecks(boolean _skipBatchChecks = skipBatchChecks)
    {
        skipBatchChecks = _skipBatchChecks;

        return skipBatchChecks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipOnHandCheckDuringTransPick</Name>
				<Source><![CDATA[
    public boolean parmSkipOnHandCheckDuringTransPick(boolean _skipOnHandCheckDuringTransPick = skipOnHandCheckDuringTransPick)
    {
        skipOnHandCheckDuringTransPick = _skipOnHandCheckDuringTransPick;

        return skipOnHandCheckDuringTransPick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSplitWithPessimisticLock</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmSplitWithPessimisticLock(boolean _splitWithPessimisticLock = splitWithPessimisticLock)
    {
        splitWithPessimisticLock = _splitWithPessimisticLock;
        return splitWithPessimisticLock;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>