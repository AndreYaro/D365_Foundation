<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjFundingLimitTrackingManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     This class is used to handle revenue tracking for project accounting module.
/// </summary>
class ProjFundingLimitTrackingManager
{
    private static real markupRatio = 1;


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocateFundingLimitTrackingFromList</Name>
				<Source><![CDATA[
    public static void allocateFundingLimitTrackingFromList(List _listOfRecords)
    {
        ListEnumerator              listEnum;
        ProjFundingLimitTracking    fundingLimitTracking;

        listEnum = _listOfRecords.getEnumerator();

        while (listEnum.moveNext())
        {
            fundingLimitTracking.data(listEnum.current());
            fundingLimitTracking.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>areTaxFieldsDeleted</Name>
				<Source><![CDATA[
    public static boolean areTaxFieldsDeleted(SourceDocumentLineItem _topSourceDocumentLineItem, AccountingDistribution _accountingDistribution = null)
    {
        PurchLine purchLine;
        PurchReqLine purchReqLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        if (!(_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem ||
             _topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem))
        {
            return false;
        }

        if (_topSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            purchLine = PurchLine::findBySourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

            if (purchLine.RecId == 0 && _accountingDistribution.RecId != 0)
            {
                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(_accountingDistribution);

                return false;
            }

            purchReqLine = PurchReqLine::findLineRefId(purchLine.PurchReqLineRefId);

            if (purchReqLine.RecId != 0 &&
               (purchLine.TaxItemGroup == "" || purchLine.TaxGroup == "") &&
               (purchReqLine.TaxItemGroup != "" && purchReqLine.TaxGroup != ""))
            {
                return true;
            }
        }

        if (_topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

            if (vendInvoiceInfoLine.RecId == 0 && _accountingDistribution.RecId != 0)
            {
                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(_accountingDistribution);

                return false;
            }

            purchLine = PurchLine::findInventTransId(vendInvoiceInfoLine.InventTransId);

            if (purchLine.RecId != 0 &&
               (vendInvoiceInfoLine.TaxItemGroup == "" || vendInvoiceInfoLine.TaxGroup == "") &&
               (purchLine.TaxItemGroup != "" && purchLine.TaxGroup != ""))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidDocumentReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the source document has a valid document reference.
    /// </summary>
    /// <param name = "_sourceDocumentHeaderRefId">The record id of the source document.</param>
    /// <returns>true if the source document has a valid document reference; otherwise, false.</returns>
    protected static boolean checkValidDocumentReference(RefRecId _sourceDocumentHeaderRefId)
    {
        boolean hasValidDocumentReference = true;

        SourceDocumentHeader sourceDocumentHeader = SourceDocumentHeader::find(_sourceDocumentHeaderRefId);

        if (!sourceDocumentHeader)
        {
            hasValidDocumentReference = false;
        }

        // Test for Vendor Invoice as there are a number of delete paths in the code
        if (hasValidDocumentReference && sourceDocumentHeader.SourceRelationType == tableNum(VendInvoiceInfoTable))
        {
            SourceDocument sourceDocument = SourceDocument::newFromSourceDocumentHeader(sourceDocumentHeader);

            // Test that source document still exists (cascade delete)
            // Use document date as VendInvoiceInfoTable does not set the documentNumber value correctly
            if (sourceDocument && sourceDocument.parmDocumentDate() == dateNull())
            {
                hasValidDocumentReference = false;
            }
        }

        return hasValidDocumentReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTrackingByAccountingDistRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes project funding limit tracking records for an accounting distribution record.
    /// </summary>
    /// <param name="recid">
    /// Record Id of the accounting distribution.
    /// </param>
    public static void clearTrackingByAccountingDistRecId(AccountingDistributionRecId recid)
    {
        ProjFundingLimitTracking    proFundingLimitTracking;

        ttsbegin;

        delete_from proFundingLimitTracking
            where proFundingLimitTracking.AccountingDistribution == recid;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjTransFromProjDist</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a ProjTran class based on a project accounting distribution record.
    /// </summary>
    /// <param name="_projectAccountingDistribution">
    ///     A project accounting distribution used to create a ProjTrans class.
    /// </param>
    /// <param name="_accountingDistribution">
    ///     Aaccounting distribution used to create a ProjTrans class.
    /// </param>
    /// <param name="saleAmountAjustment">
    ///     Amount used to adjust the sale amount.
    /// </param>
    /// <returns>
    ///     The ProjTrans class based on the project accounting distribution record provided.
    /// </returns>
    public static ProjTrans createProjTransFromProjDist(ProjectAccountingDistribution   _projectAccountingDistribution,
                                                        AccountingDistribution          _accountingDistribution,
                                                        AmountCur                       saleAmountAjustment = 0)
    {
        AmountCur                           transTurnover;
        ProjTrans_Virtual                   projTrans_Virtual;
        ProjTable                           projTableLocal;
        SourceDocumentLineItem              sourceDocumentLineItem;
        SourceDocumentLineItemIProduct      sourceDocumentLineItemIProduct;
        SourceDocumentLineItemIProject      sourceDocumentLineItemIProject;

        sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(_accountingDistribution.SourceDocumentLine);
        if (sourceDocumentLineItem)
        {
            sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
            if (sourceDocumentLineItem is SourceDocumentLineItemIProduct)
            {
                sourceDocumentLineItemIProduct = sourceDocumentLineItem as SourceDocumentLineItemIProduct;
            }

            changecompany (CompanyInfo::findRecId(_accountingDistribution.AccountingLegalEntity).DataArea)
            {
                projTableLocal = ProjTable::findRecId(_projectAccountingDistribution.ProjTable);
                if (projTableLocal)
                {
                    if (ProjectSourceDocumentLineItemHelper::implementsProject(sourceDocumentLineItem))
                    {
                        if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                            && _accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                            && ProjProcurementMiscChargesAndFundingLimitFlight::instance().isEnabled())
                        {
                            // Don't sum up the accounting distributions
                            transTurnover = _projectAccountingDistribution.TransactionCurrencyAmount;
                        }
                        else
                        {
                            transTurnover = ProjectAccountingDistribution::transactionCurrencySalesAmt(_accountingDistribution, _projectAccountingDistribution);
                        }

                        projTrans_Virtual = ProjTrans_Virtual::construct();
                        projTrans_Virtual.setActivityNumber(smmActivities::findWithRecId(_projectAccountingDistribution.SmmActivities).ActivityNumber);
                        projTrans_Virtual.setCategoryId(ProjCategory::findRecId(_projectAccountingDistribution.ProjCategory).CategoryId);
                        projTrans_Virtual.setCurrencyIdSales(ProjectAccountingDistribution::transactionSalesCurrency(_accountingDistribution, _projectAccountingDistribution));
                        if (sourceDocumentLineItemIProject)
                        {
                            projTrans_Virtual.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
                            projTrans_Virtual.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());
                        }
                        if (sourceDocumentLineItemIProduct)
                        {
                            projTrans_Virtual.setItemId(sourceDocumentLineItemIProduct.parmItemId());
                        }
                        projTrans_Virtual.setLinePropertyId(ProjLineProperty::findRecId(_projectAccountingDistribution.ProjLineProperty).LinePropertyId);
                        projTrans_Virtual.setProjId(projTableLocal.ProjId);
                        projTrans_Virtual.setTransDate(sourceDocumentLineItem.parmAccountingDate());
                        projTrans_Virtual.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem));
                        projTrans_Virtual.setTransTurnover(transTurnover + saleAmountAjustment);
                    }
                }
            }
        }

        return projTrans_Virtual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFundingLimitTracking</Name>
				<Source><![CDATA[
    public static void deleteFundingLimitTracking(Common _common)
    {
        ProjFundingLimitTracking        projFundingLimitTracking;
        ProjectAccountingDistribution   projectAccountingDistribution;
        AccountingDistribution          accountingDistribution;

        if (_common.TableId == tableNum(AccountingDistribution))
        {
            accountingDistribution = _common;
        }
        else if (_common.TableId == tableNum(ProjectAccountingDistribution))
        {
            projectAccountingDistribution = _common;
            accountingDistribution = AccountingDistribution::find(projectAccountingDistribution.AccountingDistribution);
        }
        else
        {
            throw error(Error::wrongUseOfFunction('deleteFundingLimitTracking'));
        }

        delete_from projFundingLimitTracking where projFundingLimitTracking.AccountingDistribution == accountingDistribution.RecId;

        if (accountingDistribution.ReferenceDistribution)
        {
            delete_from projFundingLimitTracking where projFundingLimitTracking.AccountingDistribution == accountingDistribution.ReferenceDistribution;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFundingLimitTrackingFromList</Name>
				<Source><![CDATA[
    public static void deleteFundingLimitTrackingFromList(List _listOfRecords)
    {
        ListEnumerator              listEnum;
        ProjFundingLimitTracking    fundingLimitTracking;

        listEnum = _listOfRecords.getEnumerator();

        while (listEnum.moveNext())
        {
            fundingLimitTracking.data(listEnum.current());
            fundingLimitTracking.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFundingLimitTrackingSourceDocLine</Name>
				<Source><![CDATA[
    public static void deleteFundingLimitTrackingSourceDocLine(RefRecId _sourceDocumentLineRefId)
    {
        SourceDocumentHeader                    sourceDocumentHeader;
        SourceDocumentLine                      sourceDocumentLine;
        Set                                     sourceDocumentLines;
        SetEnumerator                           setEnumerator;
        RefRecId                                currentSourceDocumentLine;
        AccountingDistributionList              accountingDistributions;
        AccountingDistributionListEnumerator    accountingDistributionListEnumerator;
        AccountingDistribution                  localAccountingDistribution;

        Set getSourceDocumentLinesSet(RefRecId _sourceDocumentLine)
        {
            Set                 ret;
            SourceDocumentLine  childSourceDocumentLine;
            Stack               stack;
            RefRecId            refRecId;

            ret = new Set(Types::Int64);

            if (_sourceDocumentLine)
            {
                stack = new Stack();
                stack.push([_sourceDocumentLine]);

                while (stack.qty())
                {
                    [refRecId] = stack.pop();

                    ret.add(refRecId);

                    while select ParentSourceDocumentLine, RecId
                        from childSourceDocumentLine
                        where childSourceDocumentLine.ParentSourceDocumentLine == refRecId
                    {
                        stack.push([childSourceDocumentLine.RecId]);
                    }
                }
            }

            return ret;
        }

        AccountingDistributionList getActiveDistributionsList(RefRecId _sourceDocumentLine)
        {
            AccountingDistribution      accountingDistribution;
            AccountingDistribution      reversingAccountingDistribution;
            AccountingDistributionList  ret;

            ret = AccountingDistributionList::construct();

            if (_sourceDocumentLine)
            {
                while select accountingDistribution
                    order by accountingDistribution.MonetaryAmount
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLine &&
                        accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                    notexists join reversingAccountingDistribution
                    where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                        reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                {
                    ret.addEnd(accountingDistribution);
                }
            }

            return ret;
        }

        boolean hasProject(RefRecId _sourceDocumentLine)
        {
            AccountingDistribution          accountingDistribution;
            ProjectAccountingDistribution   projectAccountingDistribution;

            select firstonly RecId from accountingDistribution
                where accountingDistribution.SourceDocumentLine == _sourceDocumentLine
            join RecId from projectAccountingDistribution
                where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;

            return accountingDistribution.RecId != 0;
        }

        // No reason to execute revenue tracking code if project is not part of the source document.
        if (hasProject(_sourceDocumentLineRefId))
        {
            sourceDocumentLine = SourceDocumentLine::find(_sourceDocumentLineRefId);
            if (sourceDocumentLine)
            {
                sourceDocumentHeader = SourceDocumentHeader::find(sourceDocumentLine.SourceDocumentHeader);
                // Don't call if source document header is missing -- cascade delete
                if (sourceDocumentHeader)
                {
                    sourceDocumentLines = getSourceDocumentLinesSet(_sourceDocumentLineRefId);
                    setEnumerator = sourceDocumentLines.getEnumerator();
                    while (setEnumerator.moveNext())
                    {
                        currentSourceDocumentLine = setEnumerator.current();
                        accountingDistributions = getActiveDistributionsList(currentSourceDocumentLine);

                        if (accountingDistributions)
                        {
                            accountingDistributionListEnumerator = accountingDistributions.getEnumerator();
                            while (accountingDistributionListEnumerator.moveNext())
                            {
                                localAccountingDistribution = accountingDistributionListEnumerator.current();
                                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(localAccountingDistribution);
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFundingLimitTrackingByTransId</Name>
				<Source><![CDATA[
    public static void deleteFundingLimitTrackingByTransId(ProjTransIdBase _transId)
    {
        if (_transId != '')
        {	
			ProjFundingLimitTracking projFundingLimitTracking;
			ttsbegin;
			delete_from projFundingLimitTracking where projFundingLimitTracking.TransId == _transId;
			ttscommit;
        }
        else
        {
            ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjFundingLimitTrackingManager));
            using (var activityContext = logger.projOpsFinActivity().projDeleteFundingLimitTrackingContext())
            {
                str callStack =  ProjOpsInstrumentationLogger::getCallStack(xSession::xppCallStack());

                logger.logInformation(strFmt("Callstack: %1", callStack));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTrackedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The amount tracked as committed for a funding limit.
    /// </summary>
    /// <param name="_fundingLimit">
    ///     The record Id of the funding limit.
    /// </param>
    /// <param name="_projSDLineTrackingType">
    ///     The type of tracking records to be summarized.
    /// </param>
    /// <returns>
    ///     The amount being tracked as committed for a specific funding limit.
    /// </returns>
    public static AmountCur getTrackedAmount(
        RefRecId                _fundingLimit,
        ProjSDLineTrackingType  _projSDLineTrackingType)
    {
        // This constant is used to round the tracking amount to measure whether if the output of the tracking amount should be zero.
        // If the spent amount is larger or equal to the limit amount and the tracking amount is close to less than a penny, then
        // the tracking amount will be zero. If the tracking amount is not round to zero in this scenario, then the funding source
        // will be attempted to be committed. And that will cause error as less than a penny will not be enough to commit.
        const real fundingLimitTrackingRoundingPrecision = 0.001;

        AmountCur trackedAmount;

        if (_fundingLimit)
        {
            ProjFundingLimitTracking projFundingLimitTracking;

            switch (_projSDLineTrackingType)
            {
                case ProjSDLineTrackingType::All :
                    select sum(Amount) from projFundingLimitTracking
                        where projFundingLimitTracking.ProjFundingLimit == _fundingLimit;
                    break;

                case ProjSDLineTrackingType::Standard :
                    select sum(Amount) from projFundingLimitTracking
                        where projFundingLimitTracking.ProjFundingLimit == _fundingLimit &&
                            projFundingLimitTracking.sdCreditLine == NoYes::No;
                    break;

                case ProjSDLineTrackingType::Credit :
                    select sum(Amount) from projFundingLimitTracking
                        where projFundingLimitTracking.ProjFundingLimit == _fundingLimit &&
                            projFundingLimitTracking.sdCreditLine == NoYes::Yes;
                    break;
            }

            ProjFundingLimit projFundingLimit;
            select firstonly AmountMST, LimitSpent from projFundingLimit
                where projFundingLimit.RecId == _fundingLimit;

            if (projFundingLimit.LimitSpent < projFundingLimit.AmountMst
                || round(projFundingLimitTracking.Amount, fundingLimitTrackingRoundingPrecision) != 0)
            {
                trackedAmount = projFundingLimitTracking.Amount;
            }
        }

        return trackedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTrackedAmountForPADistribution</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the amount tracked for a project accounting distribution.
    /// </summary>
    /// <param name="_projectAccountingDistribution">
    ///     The record Id of a <c>ProjectAccountingDistribution</c>.
    /// </param>
    /// <param name="_reversingEntry">
    ///     Return amount of reversing entries
    /// </param>
    /// <returns>
    ///     Returns the amount reserved for a given project accounting distribution record.
    /// </returns>
    public static AmountCur getTrackedAmountForPADistribution(
        RefRecId    _projectAccountingDistribution,
        NoYes       _reversingEntry = NoYes::No)
    {
        ProjFundingLimitTracking    projFundingLimitTracking;
        AmountCur                   retValue = 0.00;

        if (_projectAccountingDistribution)
        {
            select firstonly Amount from projFundingLimitTracking where projFundingLimitTracking.ProjectAccountingDistribution == _projectAccountingDistribution &&
                projFundingLimitTracking.Reversing == _reversingEntry;

            retValue = projFundingLimitTracking.Amount;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLimitErrorSourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether funding limit errors are reported by funding limit tracking.
    /// </summary>
    /// <param name="_sourceDocument">
    ///     The source doucment
    /// </param>
    /// <returns>
    ///     Returns true if any of the funding limit tracking records are morked as having a limit error, otherwise returns false.
    /// </returns>
    public static boolean hasLimitErrorSourceDocument(SourceDocumentHeaderRecId _sourceDocument)
    {
        ProjFundingLimitTracking    projFundingLimitTracking;

        if (_sourceDocument)
        {
            select firstonly RecId from projFundingLimitTracking
                where projFundingLimitTracking.SourceDocumentHeader == _sourceDocument &&
                      projFundingLimitTracking.LimitError == NoYes::Yes;
        }

        return projFundingLimitTracking.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLimitErrorSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether funding limit errors are reported by funding limit tracking.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    ///     The source doucment line
    /// </param>
    /// <returns>
    ///     Returns true if any of the funding limit tracking records are morked as having a limit error, otherwise returns false.
    /// </returns>
    public static boolean hasLimitErrorSourceDocumentLine(SourceDocumentLineRecId _sourceDocumentLine)
    {
        ProjFundingLimitTracking    projFundingLimitTracking;

        if (_sourceDocumentLine)
        {
            select firstonly RecId from projFundingLimitTracking
                where projFundingLimitTracking.SourceDocumentLine == _sourceDocumentLine &&
                      projFundingLimitTracking.LimitError == NoYes::Yes;
        }

        return projFundingLimitTracking.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPurchaseOrderBeenConfirmed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check whether the accounting distribution references a purchase order that was confirmed.
    /// </summary>
    /// <param name="_accountingDistribution">
    ///     The accounting distribution
    /// </param>
    /// <returns>
    ///     Returns if the account distribution is for a purchase order which has previously beend confirmed; otherwise false.
    /// </returns>
    public static boolean hasPurchaseOrderBeenConfirmed(AccountingDistribution  _accountingDistribution)
    {
        AccountingEvent                 accountingEvent;
        SourceDocumentHeader            sourceDocumentHeader;
        SourceDocumentLine              sourceDocumentLine;
        boolean                         retValue = false;

        if (_accountingDistribution)
        {
            sourceDocumentLine = SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine);
        }

        if (sourceDocumentLine)
        {
            select firstonly SourceRelationType, RecId from sourceDocumentHeader
                where sourceDocumentHeader.RecId == sourceDocumentLine.SourceDocumentHeader;

            if (sourceDocumentHeader.SourceRelationType == tableNum(PurchTable))
            {
                //
                // When a PO is confirmed an accounting event of "Complete is recorded.
                //
                select firstonly accountingEvent
                    where accountingEvent.SourceDocumentHeader == sourceDocumentHeader.RecId    &&
                          (accountingEvent.State == AccountingEventState::Complete ||
                           accountingEvent.State == AccountingEventState::Journalized);

                if (accountingEvent)
                {
                    retValue = true;
                }
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseOrderAccDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check whether an accounting distribution refers to a purchase order.
    /// </summary>
    /// <param name="_accountingDistribution">
    ///     The accounting distribution
    /// </param>
    /// <returns>
    ///     Returns true if the accounting distribution is for a purchase order; otherwise false.
    /// </returns>
    public static boolean isPurchaseOrderAccDistribution(AccountingDistribution  _accountingDistribution)
    {
        SourceDocumentLine              sourceDocumentLine;
        boolean                         retValue = false;

        if (_accountingDistribution)
        {
            sourceDocumentLine = SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine);
        }

        if (sourceDocumentLine)
        {
            retValue = ProjFundingLimitTrackingManager::isPurchaseOrderSourceDocLine(sourceDocumentLine);
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseOrderSourceDocLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the source document line references a purchase order.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    ///     The source document line
    /// </param>
    /// <returns>
    ///     Returns true if the source document line references a purchase order; otherwise false.
    /// </returns>
    private static boolean isPurchaseOrderSourceDocLine(SourceDocumentLine  _sourceDocumentLine)
    {
        SourceDocumentHeader            sourceDocumentHeader;
        boolean                         retValue = false;

        if (_sourceDocumentLine)
        {
            select firstonly SourceRelationType from sourceDocumentHeader
                where sourceDocumentHeader.RecId == _sourceDocumentLine.SourceDocumentHeader;

            if (sourceDocumentHeader.SourceRelationType == tableNum(PurchTable))
            {
                retValue = true;
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUsingDocumentMatching</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return if document matching is required for the specified source document line item.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    ///     The source document line item
    /// </param>
    /// <param name="_skipCheckActiveVendorInvoice">
    ///     boolean value indicating to check active vendor invoice documents.
    /// </param>
    /// <returns>
    ///     Returns true if document matching is required; otherwise false.
    /// </returns>
    /// <remarks>
    /// This function returns true in the multiple funding sources scenario.
    /// However, the funding limit tracking records will not be calculated correctly.
    /// We have updated main line scenario to support multiple funding source and hence this function will always return false.
    /// </remarks>
   public static boolean isUsingDocumentMatching(SourceDocumentLineItem _sourceDocumentLineItem, boolean _skipCheckActiveVendorInvoice = false)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoiceActiveDocLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return whether this source document line references an active vendor invoice document line .
    /// </summary>
    /// <param name="sourceDocumentLineRecId">
    ///     The source document line
    /// </param>
    /// <returns>
    ///     Returns true if the source document line references an active vendor invoice line ; otherwise false.
    /// </returns>
    public static boolean isVendorInvoiceActiveDocLine(RefRecId sourceDocumentLineRecId)
    {
        SourceDocumentLine      sourceDocumentLine;
        VendInvoiceInfoLine     vendInvoiceInfoLine;
        boolean                 retValue = false;

        if (sourceDocumentLineRecId)
        {
            select firstonly SourceRelationType from sourceDocumentLine where sourceDocumentLine.RecId == sourceDocumentLineRecId;

            if (sourceDocumentLine.SourceRelationType == tableNum(VendInvoiceInfoLine))
            {
                vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLineRecId);
                if (vendInvoiceInfoLine)
                {
                    retValue = vendInvoiceInfoLine.ParmId != '';
                }
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoiceActiveDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return whether this source document references an active vendor invoice document.
    /// </summary>
    /// <param name="_sourceDocumentHeaderRecId">
    ///     The source document
    /// </param>
    /// <returns>
    ///     Returns true if the source document references an active vendor invoice; otherwise false.
    /// </returns>
    public static boolean isVendorInvoiceActiveDocument(RefRecId _sourceDocumentHeaderRecId)
    {
        SourceDocumentHeader    sourceDocumentHeader;
        VendInvoiceInfoTable    vendInvoiceInfoTable;
        boolean                 retValue = false;

        if (_sourceDocumentHeaderRecId)
        {
            select firstonly SourceRelationType from sourceDocumentHeader where sourceDocumentHeader.RecId == _sourceDocumentHeaderRecId;

            if (sourceDocumentHeader.SourceRelationType == tableNum(VendInvoiceInfoTable))
            {
                vendInvoiceInfoTable = VendInvoiceInfoTable::findSourceDocumentHeader(_sourceDocumentHeaderRecId);
                if (vendInvoiceInfoTable)
                {
                    retValue = vendInvoiceInfoTable.ParmId != '';
                }
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoiceLineSavedOrBeingSaved</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the source document implementation for vendor invoice line represents a saved line or an active line that is currently being saved.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    ///     The source document line implementation.
    /// </param>
    /// <returns>
    ///     Returns true if the <c>ParmId</c> field on the <c>VendInvoiceInfoLine</c> table is empty; false, otherwise.
    /// </returns>
    public static boolean isVendorInvoiceLineSavedOrBeingSaved(SourceDocumentLineImplementation _sourceDocumentLineImplementation)
    {
        Common              common;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        boolean             retValue;

        common              = _sourceDocumentLineImplementation;

        if (common.TableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLine = common;

            if (vendInvoiceInfoLine.ParmId == "")
            {
                retValue = true;
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoiceSavedDocLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the source document line represents a saved vendor invoice line.
    /// </summary>
    /// <param name="sourceDocumentLineRecId">
    ///     The source document
    /// </param>
    /// <returns>
    ///     Returns true if the source document line reference Id is for a saved vendor invoice line.
    /// </returns>
    public static boolean isVendorInvoiceSavedDocLine(RefRecId sourceDocumentLineRecId)
    {
        SourceDocumentLine      sourceDocumentLine;
        VendInvoiceInfoLine     vendInvoiceInfoLine;
        boolean                 retValue = false;

        if (sourceDocumentLineRecId)
        {
            select firstonly SourceRelationType from sourceDocumentLine where sourceDocumentLine.RecId == sourceDocumentLineRecId;

            if (sourceDocumentLine.SourceRelationType == tableNum(VendInvoiceInfoLine))
            {
                vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLineRecId);
                if (vendInvoiceInfoLine)
                {
                    retValue = vendInvoiceInfoLine.ParmId == '';
                }
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoiceSavedDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the source document represents a saved vendor invoice.
    /// </summary>
    /// <param name="_sourceDocumentHeaderRecId">
    ///     The source document
    /// </param>
    /// <returns>
    ///     Returns true if the source document reference Id is for a saved vendor invoice.
    /// </returns>
    public static boolean isVendorInvoiceSavedDocument(RefRecId _sourceDocumentHeaderRecId)
    {
        SourceDocumentHeader    sourceDocumentHeader;
        VendInvoiceInfoTable    vendInvoiceInfoTable;
        boolean                 retValue = false;

        if (_sourceDocumentHeaderRecId)
        {
            select firstonly SourceRelationType from sourceDocumentHeader where sourceDocumentHeader.RecId == _sourceDocumentHeaderRecId;

            if (sourceDocumentHeader.SourceRelationType == tableNum(VendInvoiceInfoTable))
            {
                vendInvoiceInfoTable = VendInvoiceInfoTable::findSourceDocumentHeader(_sourceDocumentHeaderRecId);
                if (vendInvoiceInfoTable)
                {
                    retValue = vendInvoiceInfoTable.ParmId == '';
                }
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWithinFundingLimitProjAcctDist</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return is the amount is within funding limit for the contract.
    /// </summary>
    /// <param name="projectAccountingDistribution">
    ///     The project accounting distribution
    /// </param>
    /// <param name="accountingDistribution">
    ///     The accounting distribution
    /// </param>
    /// <returns>
    ///     Returns true if the amount is within funding limits, otherwise false.
    /// </returns>
    public static boolean isWithinFundingLimitProjAcctDist(
            ProjectAccountingDistribution   projectAccountingDistribution,
            AccountingDistribution          accountingDistribution)
    {
        ProjTrans                       projTrans;
        AccountingDistribution          adjAccountingDistribution;
        ProjectAccountingDistribution   adjProjectAccountingDist;
        AmountCur                       trackedAmount;
        AmountCur                       adjustmentAmount;
        boolean                         retValue = true;

        // if unit price and price adjustments, adjust the value to be tested
        if (accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice)
        {
            while select adjAccountingDistribution 
                where adjAccountingDistribution.ParentDistribution == accountingDistribution.RecId &&
                    (adjAccountingDistribution.MonetaryAmount == MonetaryAmount::Charge ||
                     adjAccountingDistribution.MonetaryAmount == MonetaryAmount::ChargeVariance ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::PriceAdjustment ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::Discount ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::DiscountVariance ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::TotalDiscount ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::TotalDiscountRounding ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::TotalDiscountVariance ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::CashDiscount ||
                    adjAccountingDistribution.MonetaryAmount == MonetaryAmount::CashDiscountVariance)
            {
                adjProjectAccountingDist = ProjectAccountingDistribution::findByAccountingDistribution(adjAccountingDistribution.RecId);
                adjustmentAmount += ProjectAccountingDistribution::transactionCurrencySalesAmt(adjAccountingDistribution, adjProjectAccountingDist);
            }
        }

        if (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
        {
            while select adjAccountingDistribution where adjAccountingDistribution.ParentDistribution == accountingDistribution.RecId &&
                                                        (adjAccountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
            {
                adjProjectAccountingDist = ProjectAccountingDistribution::findByAccountingDistribution(adjAccountingDistribution.RecId);
                adjustmentAmount += ProjectAccountingDistribution::transactionCurrencySalesAmt(adjAccountingDistribution, adjProjectAccountingDist);
            }
        }

        // These are checked as part of Tax or Unit Price
        if ((accountingDistribution.MonetaryAmount == MonetaryAmount::Charge && !ProjFundingLimitCheckforChargesFlight_ProjectPurch::instance().isEnabled()) || 
            accountingDistribution.MonetaryAmount == MonetaryAmount::ChargeVariance ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::PriceAdjustment ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::PriceVariance ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::Discount ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::DiscountVariance ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::TotalDiscount ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::TotalDiscountRounding ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::TotalDiscountVariance ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::CashDiscount ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::CashDiscountVariance ||
            accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
        {
            return true;
        }

        projTrans = ProjFundingLimitTrackingManager::createProjTransFromProjDist(projectAccountingDistribution, accountingDistribution, adjustmentAmount);
        if (projTrans)
        {
            // Reverse the original amount
            trackedAmount = ProjFundingLimitTrackingManager::getTrackedAmountForPADistribution(projectAccountingDistribution.RecId);
            if (trackedAmount != 0.0)
            {
                ProjFundingLimitTrackingManager::updateUsingProjAccountingDistribution(projectAccountingDistribution.orig(), accountingDistribution, ProjFundingLimitTrackingAction::Delete);
            }

            accountingDistribution = AccountingDistribution::find(projectAccountingDistribution.AccountingDistribution);
            if (accountingDistribution)
            {
                changecompany (CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea)
                {
                    retValue = ProjFundingEngine::isAmountWithinFundingLimits(projTrans, projectAccountingDistribution.ProjFundingSource, projTrans.transTurnover());
                }
            }

            // Reinstate the amounts
            if (trackedAmount != 0.0)
            {
                ProjFundingLimitTrackingManager::updateUsingProjAccountingDistribution(projectAccountingDistribution.orig(), accountingDistribution, ProjFundingLimitTrackingAction::Allocate, false);
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseFundingLimitForTaxNoRef</Name>
				<Source><![CDATA[
    public static List releaseFundingLimitForTaxNoRef(AccountingDistribution _accountingDistribution, boolean _deleteReversing = false)
    {
        SourceDocumentLineItem      sourceDocumentLineItem;
        AccountingDistribution      parentAccountingDistribution, refParentAccountingDistribution, childAccountingDistribution;
        ProjFundingLimitTracking    projFundingLimitTracking, revertProjFundingLimitTracking;
        List                        listReversedTaxLimit = new List(Types::Record);
        ListEnumerator              listEnumerator;

        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine));

        if (sourceDocumentLineItem is TaxSourceDocSublineItem)
        {
            parentAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ParentDistribution);

            Debug::assert(parentAccountingDistribution.RecId != 0);

            refParentAccountingDistribution = AccountingDistribution::find(parentAccountingDistribution.ReferenceDistribution);

            while select childAccountingDistribution 
                where childAccountingDistribution.ParentDistribution == refParentAccountingDistribution.RecId
            join projFundingLimitTracking 
                where projFundingLimitTracking.AccountingDistribution == childAccountingDistribution.RecId &&
                    projFundingLimitTracking.Reversing == NoYes::No
            {
                listReversedTaxLimit.addEnd(projFundingLimitTracking);
            }

            listEnumerator = listReversedTaxLimit.getEnumerator();
            while (listEnumerator.moveNext())
            {
                revertProjFundingLimitTracking.data(listEnumerator.current());
                delete_from projFundingLimitTracking where projFundingLimitTracking.RecId == revertProjFundingLimitTracking.RecId;

                if (_deleteReversing)
                {
                    delete_from projFundingLimitTracking where projFundingLimitTracking.SourceAccountingDistribution == _accountingDistribution.RecId;
                }
            }
        }

        return listReversedTaxLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseFundingLimitTracking</Name>
				<Source><![CDATA[
    public static List releaseFundingLimitTracking(AccountingDistribution _accountingDistribution)
    {
        List                            listRecords                     = new List(Types::Record);
        ProjectAccountingDistribution   retProjAccountingDistribution   = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.ReferenceDistribution);
        ProjFundingLimitTracking        fundingLimitTracking;

        while select forupdate fundingLimitTracking
                where fundingLimitTracking.AccountingDistribution == _accountingDistribution.ReferenceDistribution &&
                      fundingLimitTracking.ProjectAccountingDistribution == retProjAccountingDistribution.RecId &&
                      fundingLimitTracking.Reversing == NoYes::No
        {
            listRecords.addEnd(fundingLimitTracking);
        }

        delete_from fundingLimitTracking
                where fundingLimitTracking.AccountingDistribution == _accountingDistribution.ReferenceDistribution &&
                      fundingLimitTracking.ProjectAccountingDistribution == retProjAccountingDistribution.RecId &&
                      fundingLimitTracking.Reversing == NoYes::No;

        return listRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseTaxFundingLimitTracking</Name>
				<Source><![CDATA[
    public static List releaseTaxFundingLimitTracking(RefRecId _parentReferenceRecId)
    {
        List                            listRecords                     = new List(Types::Record);
        ListEnumerator                  listEnumerator;
        ProjectAccountingDistribution   projAccountingDistribution   = ProjectAccountingDistribution::findByAccountingDistribution(_parentReferenceRecId);
        ProjFundingLimitTracking        projFundingLimitTracking,revertProjFundingLimitTracking;

        while select projFundingLimitTracking where projFundingLimitTracking.AccountingDistribution == _parentReferenceRecId &&
                                                        projFundingLimitTracking.ProjectAccountingDistribution == projAccountingDistribution.RecId &&
                                                        projFundingLimitTracking.Reversing == NoYes::No
        {
            listRecords.addEnd(projFundingLimitTracking);
        }

        listEnumerator = listRecords.getEnumerator();
        while (listEnumerator.moveNext())
        {
            revertProjFundingLimitTracking.data(listEnumerator.current());
            delete_from projFundingLimitTracking where projFundingLimitTracking.RecId == revertProjFundingLimitTracking.RecId;
        }

        return listRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseCommitmentForAcctDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverts project funding commitments for a given accounting distribution record.
    /// </summary>
    /// <param name="_recID">
    /// Record Id of the accounting distribution record to be reverted.
    /// </param>
    static void reverseCommitmentForAcctDist(RefRecId _recID)
    {
        ProjFundingLimitTracking    projFundingLimitTrackingOriginal;
        ProjFundingLimitTracking    projFundingLimitTrackingReversing;

        select firstonly projFundingLimitTrackingOriginal
            where projFundingLimitTrackingOriginal.AccountingDistribution == _recID &&
                projFundingLimitTrackingOriginal.Reversing == NoYes::No;

        if (projFundingLimitTrackingOriginal)
        {
            ttsbegin;
            select firstonly forupdate projFundingLimitTrackingReversing
                where projFundingLimitTrackingReversing.AccountingDistribution == _recID &&
                    projFundingLimitTrackingReversing.Reversing == NoYes::Yes;

            if (!projFundingLimitTrackingReversing)
            {
                ProjFundingLimitTrackingManager::initalizeProjFundingLimitTracking(projFundingLimitTrackingReversing,
                    projFundingLimitTrackingOriginal.ProjFundingLimit, 
					-projFundingLimitTrackingOriginal.Amount,
					projFundingLimitTrackingOriginal.SourceDocumentHeader,
                    projFundingLimitTrackingOriginal.SourceDocumentLine,
                    projFundingLimitTrackingOriginal.AccountingDistribution,
                    projFundingLimitTrackingOriginal.ProjectAccountingDistribution,
					0,
                    NoYes::Yes,
                    projFundingLimitTrackingOriginal.sdCreditLine,
					NoYes::No);
				projFundingLimitTrackingReversing.insert();
            }
            else
            {
                projFundingLimitTrackingReversing.Amount = -projFundingLimitTrackingOriginal.Amount;
                projFundingLimitTrackingReversing.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseFundingLimitForNewDistribution</Name>
				<Source><![CDATA[
    public static List reverseFundingLimitForNewDistribution(List                   _list,
                                                                 AccountingDistribution _accountingDistribution)
    {
        ProjectAccountingDistribution   refProjAccountingDistribution;
        AccountingDistribution          parentAccountingDistribution;
        ProjFundingLimitTracking        fundingLimitTracking;
        ListEnumerator                  listEnumerator = _list.getEnumerator();
        List                            reversedTrackingList = new List(Types::Record);
        RefRecId                        referenceRecId;

        if (_accountingDistribution.ReferenceDistribution)
        {
            referenceRecId = _accountingDistribution.ReferenceDistribution;
        }
        else if (_accountingDistribution.ParentDistribution)
        {
            parentAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ParentDistribution);
            referenceRecId = parentAccountingDistribution.ReferenceDistribution;
        }

        refProjAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referenceRecId);

        while (listEnumerator.moveNext())
        {
            fundingLimitTracking.data(listEnumerator.current());
			fundingLimitTracking.AccountingDistribution = referenceRecId;
            fundingLimitTracking.ProjectAccountingDistribution = refProjAccountingDistribution.RecId;
            fundingLimitTracking.Reversing = NoYes::Yes;
            fundingLimitTracking.SourceAccountingDistribution = _accountingDistribution.RecId;
            fundingLimitTracking.Amount = fundingLimitTracking.Amount * (-1);
            fundingLimitTracking.insert();

            reversedTrackingList.addEnd(fundingLimitTracking);
        }

        return reversedTrackingList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxFundingLimitForNewDistribution</Name>
				<Source><![CDATA[
    public static void reverseTaxFundingLimitForNewDistribution(List                   _list,
                                                                    AccountingDistribution _accountingDistribution)
    {
        ProjFundingLimitTracking        fundingLimitTracking;
        ListEnumerator                  listEnumerator = _list.getEnumerator();
        AccountingDistribution          parent,reference, childTax;

        parent = AccountingDistribution::find(_accountingDistribution.ParentDistribution);
        reference = AccountingDistribution::find(parent.ReferenceDistribution);
        select firstonly RecId from childTax where childTax.ParentDistribution == reference.RecId;

        while (listEnumerator.moveNext())
        {
            fundingLimitTracking.data(listEnumerator.current());
            fundingLimitTracking.AccountingDistribution = childTax.RecId;
            fundingLimitTracking.SourceDocumentHeader = childTax.SourceDocumentHeader;
            fundingLimitTracking.SourceDocumentLine = childTax.SourceDocumentLine;
            fundingLimitTracking.Reversing = NoYes::Yes;
            fundingLimitTracking.SourceAccountingDistribution = _accountingDistribution.RecId;
            fundingLimitTracking.Amount = fundingLimitTracking.Amount * (-1);
            fundingLimitTracking.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLimitErrorFlag</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets all funding limit tracking records for a project accounting distribution with an error value.
    /// </summary>
    /// <param name="_projectAccountingDistribution">
    ///     The project accounting distribution
    /// </param>
    /// <param name="_limitError">
    ///     The limit error value
    /// </param>
    public static void setLimitErrorFlag(
            RefRecId    _projectAccountingDistribution,
            NoYes       _limitError)
    {
        ProjFundingLimitTracking    projFundingLimitTracking;

        if (_projectAccountingDistribution)
        {
            ttsbegin;

            update_recordset projFundingLimitTracking
                    setting LimitError = _limitError
                    where projFundingLimitTracking.ProjectAccountingDistribution == _projectAccountingDistribution &&
                          projFundingLimitTracking.Reversing == NoYes::No;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentLineStateRevenueTrack</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handle source document state change for revenue tracking.
    /// </summary>
    /// <param name="_targetAccountingStatus">
    ///     The new accounting status.
    /// </param>
    /// <param name="_sourceDocumentLine">
    ///     The source document line.
    /// </param>
    public static void sourceDocumentLineStateRevenueTrack(
            SourceDocumentLineAccountingStatus  _targetAccountingStatus,
            SourceDocumentLine                  _sourceDocumentLine)
    {
        SourceDocumentLineItem          sourceDocumentLineItem;
        SourceDocumentLineItemIProject  sourceDocumentLineItemProject;
        AccountingDistribution          accountingDistribution;
        boolean                         isDistributionFromBudgetReservationHierarchy;

        if (_sourceDocumentLine
                && (_targetAccountingStatus == SourceDocumentLineAccountingStatus::Completed
                    || _targetAccountingStatus == SourceDocumentLineAccountingStatus::Finalized))
        {
            if (ProjFundingLimitTrackingManager::isPurchaseOrderSourceDocLine(_sourceDocumentLine))
            {
                if (ProjFundingLimitTrackingManager::hasLimitErrorSourceDocumentLine(_sourceDocumentLine.RecId))
                {
                    throw error("@SYS4110061");
                }

                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(_sourceDocumentLine);

                if (sourceDocumentLineItem is SourceDocumentLineItemIProject)
                {
                    // No reason to execute revenue tracking code if project is not part of the source document.
                    sourceDocumentLineItemProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
                    if (sourceDocumentLineItemProject.parmProjectId())
                    {
                        switch (_targetAccountingStatus)
                        {
                            case SourceDocumentLineAccountingStatus::Completed :
                                ProjFundingLimitTrackingManager::sourceDocumentStatePOConfirm(_sourceDocumentLine.RecId);
                                break;

                            case SourceDocumentLineAccountingStatus::Finalized :
                                ProjFundingLimitTrackingManager::sourceDocumentStatePOLineFinalize(_sourceDocumentLine.RecId);
                                break;

                            default :
                                // No action
                        }
                    }
                }
            }
            else if (_targetAccountingStatus == SourceDocumentLineAccountingStatus::Finalized)
            {
                select firstOnly RecId from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLine.RecId;

                isDistributionFromBudgetReservationHierarchy = PublicSectorUtils::isBudgetReservationEnabled()
                        && BudgetReservationHeader_PSN::isDistributionFromBudgetReservationHierarchy(accountingDistribution.RecId);

                if (isDistributionFromBudgetReservationHierarchy
                        && (_sourceDocumentLine.SourceRelationType == tableNum(BudgetReservationLine_PSN)
                            || _sourceDocumentLine.SourceRelationType == tableNum(PurchReqLine)))
                {
                    BudgetReservationFinalize_PSN::reverseRemainingProjectCommitmentOnFinalize(_sourceDocumentLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentStatePOConfirm</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the revenue tracking table resulting from a confirmed purchase order event.
    /// </summary>
    /// <param name="_sourceDocumentLineRefId">
    ///     The source document line
    /// </param>
    private static void sourceDocumentStatePOConfirm(RefRecId _sourceDocumentLineRefId)
    {
        AccountingDistribution      accountingDistribution;
        AccountingDistribution      reversingAccountingDistribution;
        AccountingDistribution      childAccountingDistribution;
        AccountingDistribution      reversingChildAccountingDistribution;
        PurchLine                   purchLine;
        PurchReqLine                purchReqLine;
        SourceDocumentLine          sourceDocumentLine;

        SourceDocumentLineItem      sourceDocumentLineItem;
        boolean                     isUsingSourceDocumentMatching;

        if (_sourceDocumentLineRefId)
        {
            purchLine = PurchLine::findBySourceDocumentLine(_sourceDocumentLineRefId);
            if (purchLine)
            {
                if (purchLine.PurchReqLineRefId)
                {
                    //
                    // Delete the tracking based on the Purchase Requision as children source documents may have been removed
                    // Example: Taxes exist on the Purchase Requisiton, but were not included on the Purchase Order.
                    //
                    isUsingSourceDocumentMatching = ProjFundingLimitTrackingManager::isUsingDocumentMatching(SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(_sourceDocumentLineRefId)));

                    purchReqLine = PurchReqLine::findLineRefId(purchLine.PurchReqLineRefId);
                    if (purchReqLine)
                    {
                        sourceDocumentLine = SourceDocumentLine::findTopParentSourceDocumentLine(purchReqLine.SourceDocumentLine);
                        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);

                        while select RecId from accountingDistribution
                                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId                         &&
                                      accountingDistribution.ReferenceRole      != AccountingDistributionReferenceRole::Reversing
                                notexists join reversingAccountingDistribution
                                    where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId     &&
                                          reversingAccountingDistribution.ReferenceRole         == AccountingDistributionReferenceRole::Reversing
                        {
                            // Need to release all the children records
                            while select RecId from childAccountingDistribution
                                        where childAccountingDistribution.ParentDistribution == accountingDistribution.RecId    &&
                                               childAccountingDistribution.ReferenceRole     != AccountingDistributionReferenceRole::Reversing
                                        notexists join reversingChildAccountingDistribution
                                            where reversingChildAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId     &&
                                                  reversingChildAccountingDistribution.ReferenceRole         == AccountingDistributionReferenceRole::Reversing
                            {
                                if (isUsingSourceDocumentMatching)
                                {
                                    ProjFundingLimitTrackingManager::deleteFundingLimitTracking(childAccountingDistribution);
                                }
                                else
                                {
                                    ProjFundingLimitTrackingManager::reverseCommitmentForAcctDist(childAccountingDistribution.RecId);
                                }
                            }

                            if (isUsingSourceDocumentMatching)
                            {
                                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);
                            }
                            else
                            {
                                ProjFundingLimitTrackingManager::reverseCommitmentForAcctDist(accountingDistribution.RecId);
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentStatePOLineFinalize</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the revenue tracking table resulting from a finalize purchase order event.
    /// </summary>
    /// <param name="_sourceDocumentLineRefId">
    ///     The source document line
    /// </param>
    public static void  sourceDocumentStatePOLineFinalize(RefRecId _sourceDocumentLineRefId)
    {
        AccountingDistribution      accountingDistribution;
        AccountingDistribution      reversingAccountingDistribution;
        AccountingDistribution      childAccountingDistribution;
        AccountingDistribution      reversingChildAccountingDistribution;
        PurchLine                   purchLine;

        SourceDocumentLine          sourceDocumentLine;
        SourceDocumentLineItem      sourceDocumentLineItem;
        boolean                     isUsingSourceDocumentMatching;

        if (_sourceDocumentLineRefId)
        {
            purchLine = PurchLine::findBySourceDocumentLine(_sourceDocumentLineRefId);
            if (purchLine)
            {
                sourceDocumentLine = SourceDocumentLine::findTopParentSourceDocumentLine(_sourceDocumentLineRefId);
                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
                isUsingSourceDocumentMatching = ProjFundingLimitTrackingManager::isUsingDocumentMatching(sourceDocumentLineItem);

                // Release any remaining commitments the children records
                while select RecId from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLineRefId &&
                            accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                    notexists join reversingAccountingDistribution
                        where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                                reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                {
                    while select RecId, SourceDocumentLine from childAccountingDistribution
                        where childAccountingDistribution.ParentDistribution == accountingDistribution.RecId &&
                            childAccountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                        notexists join reversingChildAccountingDistribution
                            where reversingChildAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                                reversingChildAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                    {
                        // If the distribution is from budget reservation hierarchy, call the GBR specific method to finalize the PO amounts
                        if (PublicSectorUtils::isBudgetReservationEnabled()
                            && BudgetReservationHeader_PSN::isDistributionFromBudgetReservationHierarchy(childAccountingDistribution.RecId))
                        {
                            BudgetReservationFinalize_PSN::reverseRemainingProjectCommitmentOnFinalize(SourceDocumentLine::find(childAccountingDistribution.SourceDocumentLine));
                        }
                        else
                        {
                            ProjFundingLimitTrackingManager::deleteFundingLimitTracking(childAccountingDistribution);
                        }
                    }

                    // If the distribution is from budget reservation hierarchy and call the GBR specific method to finalize the PO amounts
                    if (PublicSectorUtils::isBudgetReservationEnabled()
                        && BudgetReservationHeader_PSN::isDistributionFromBudgetReservationHierarchy(accountingDistribution.RecId))
                    {
                        BudgetReservationFinalize_PSN::reverseRemainingProjectCommitmentOnFinalize(SourceDocumentLine::find(_sourceDocumentLineRefId));
                    }
                    else
                    {
                        ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevenueTrackingVendInvoiceInfoLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the  tracking of revenue from active to saved vendor invoice line.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    /// <c>VendInvoiceInfoLine</c> table buffer.
    /// </param>
    /// <remarks>
    /// If there is no saved document, the amounts are released by the delete method on source document.
    /// </remarks>
    public static void updateRevenueTrackingVendInvoiceInfoLine(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        VendInvoiceInfoLine             vendInvoiceInfoLineLocal;
        AccountingDistribution          accountingDistribution;
        ProjectAccountingDistribution   projectAccountingDistribution;
        SourceDocumentLineItem          sourceDocumentLineItem;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (FormDataUtil::getFormDataSource(_vendInvoiceInfoLine))
            {
                ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(_vendInvoiceInfoLine.SourceDocumentLine, ProjFundingLimitTrackingAction::Release, true, true);
            }
            else if (_vendInvoiceInfoLine.ParmId)
            {
                ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(_vendInvoiceInfoLine.SourceDocumentLine, ProjFundingLimitTrackingAction::Release);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsingAccDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the revenue tracking based on an accounting distribution.
    /// </summary>
    /// <param name="_accountingDistribution">
    ///     The accounting distribution
    /// </param>
    /// <param name="_action">
    ///     The revenue tracking action
    /// </param>
    /// <param name="_updateRefLine">
    ///     Update referenced document tracking.
    /// </param>
    /// <param name="_skipUpdateRefLineCheck">
    ///     Skip checks for updating referenced document tracking.
    /// </param>
    /// <param name="_forceDeleteTracking">
    ///     If true, force deletion of funding tracking records.
    /// </param>
    public static void updateUsingAccDistribution(
            AccountingDistribution          _accountingDistribution,
            ProjFundingLimitTrackingAction  _action,
            boolean                          _updateRefLine = true,
            boolean                          _skipUpdateRefLineCheck = false,
            boolean                          _forceDeleteTracking = false)
    {
        ProjectAccountingDistribution   projectAccountingDistribution;

        if (_accountingDistribution)
        {
            projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(_accountingDistribution.RecId);

            if (projectAccountingDistribution)
            {
                ProjFundingLimitTrackingManager::updateUsingProjAccountingDistribution(projectAccountingDistribution,
                                                                                           _accountingDistribution,
                                                                                           _action,
                                                                                           _updateRefLine,
                                                                                           _skipUpdateRefLineCheck,
                                                                                           _forceDeleteTracking);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsingProjAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the revenue tracking based on a project accounting distribution.
    /// </summary>
    /// <param name="projectAccountingDistribution">
    ///     The project accounting distribution
    /// </param>
    /// <param name="accountingDistribution">
    ///     The accounting distribution
    /// </param>
    /// <param name="action">
    ///     The revenue tracking action
    /// </param>
    /// <param name="_updateRefLine">
    ///     Update referenced document tracking.
    /// </param>
    /// <param name="skipUpdateRefLineCheck">
    ///     Skip checks for updating referenced document tracking.
    /// </param>
    /// <param name="_forceDeleteTracking">
    ///     If true, force deletion of funding tracking records.
    /// </param>
    /// <param name="_isDeletingSourceDocumentLine">
    ///     If true, source document line delete is being called.
    /// </param>
    public static void updateUsingProjAccountingDistribution(
            ProjectAccountingDistribution       projectAccountingDistribution,
            AccountingDistribution              accountingDistribution,
            ProjFundingLimitTrackingAction      action,
            boolean                             _updateRefLine = true,
            boolean                             skipUpdateRefLineCheck = false,
            boolean                             _forceDeleteTracking = false,
            boolean                         _isDeletingSourceDocumentLine = false)
    {
        AccountingDistribution          referencedAccountingDistribution;
        AccountingDistribution          topAccountingDistribution;
        ProjectAccountingDistribution   refProjectAccountingDistribution;
        ProjFundingLimit                projFundingLimit;
        ProjFundingLimitTracking        projFundingLimitTracking;
        ProjFundingLimitTracking        projFundingLimitTrackingCheck;
        ProjFundingLimitTracking        projFundingLimitTrackingRef;
        ProjFundingLimitTracking        projFundingLimitPOTrackingRef;
        ProjLineProperty                projLineProperty;
        ProjTrans                       projTrans;
        ProjSplitBill                   projSplitBill;
        SourceDocumentHeader            sourceDocumentHeader;
        SourceDocumentLineItem          sourceDocumentLineItem;
        SourceDocumentLineItem          taxSourceDocumentLineItem;
        QueryRun                        listOfLimits;
        AmountCur                       amountInContractCurrency;
        AmountCur                       amountOfLinkedFundingLimit;
        NoYes                           sdLineCredit        = NoYes::No;
        boolean                         updateRefLine       = _updateRefLine;

        boolean                          runOnlyOnce;
        boolean                          areTaxFieldsDeleted;
        SourceDocumentLineItemList       sourceDocumentLineItemList;
        AccDistProcessorProjectExtension accDistProcessorProjectExtension;
        List                             listReferenceFundingTracking = new List(Types::Record);
        Map                              mapReferenceFunding = new Map(Types::Int64, Types::Class);

        PurchLine                        purchLine;
        PurchParameters                  purchParameters;
        boolean                          isPurchLineFinalized;
        AccountingDistribution           taxAccountingDistribution;
        ProjFundingLimitTracking         projFundingLimitTrackingLoc;
        VendInvoiceInfoLine              vendInvoiceInfoLine;
        boolean                          doCreateTrackingAmountForBudgetReservation = true;
        SourceDocumentLine               referencedSourceDocumentLine;
        boolean                          isDistributionFromBudgetReservationHierarchy;
        boolean                          isFundingLimitDeleted;
        boolean                          isRetainScheduleInvoice;
        boolean                          calcVendorPaymentRetention;
        boolean                          calcVendorPaymentRetentionTax;
        boolean                          completedRetainedInvoiceByInventTransId;
        boolean                          retainInvoiceHasLineAmount;

        // For the case of retention, the calculation  of the amount in the tracking funding limit tracking table is
        // calculated by multiplication of accounting distribution allocation factor and retention percentage.
        // As for the case of tax, it is calculated by division of the total line amount times the receive amount to be invoiced.
        // Hence it is unavoidable to have rounding error and hence the rounding adjustment is required.
        // If this rounding adjustment is not used, then may cause tracking record not being deleted and invoice amount not 
        // being transfer to purchline tracking record. Then the tracking records will not be record correctly which impact the funding limit committed amount.
        const real adjustmentError = 0.01;

        isDistributionFromBudgetReservationHierarchy = PublicSectorUtils::isBudgetReservationEnabled()
            && BudgetReservationHeader_PSN::isDistributionFromBudgetReservationHierarchy(accountingDistribution.RecId);

        // The finalization of document is handled in other methods of this class for the distributions in budget reservation hierarchy.
        if (isDistributionFromBudgetReservationHierarchy && BudgetReservationHeader_PSN::isDocumentFinalizedOrInProcess(accountingDistribution.SourceDocumentHeader, accountingDistribution.FinalizeAccountingEvent))
        {
            return;
        }

        projTrans = ProjFundingLimitTrackingManager::createProjTransFromProjDist(projectAccountingDistribution, accountingDistribution);
        if (!projTrans)
        {
            return;
        }

        if (projTrans.transTurnover() == 0.0)
        {
            return;
        }

        sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);

        // Pending Free text invoices should not be tracked.
        if (sourceDocumentLineItem is CustInvoiceLineSourceDocLineItem &&
                ProjectSourceDocumentLineItemHelper::projOrigin(sourceDocumentLineItem) == ProjOrigin::FreeTextInvoice)
        {
            return;
        }

        if (ProjFundingLimitTrackingManager::isUsingDocumentMatching(sourceDocumentLineItem))
        {
            if (ProjFundingLimitTrackingManager::hasPurchaseOrderBeenConfirmed(accountingDistribution))
            {
                return;
            }

            if (_forceDeleteTracking)
            {
                if (sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                {
                    purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                    if (purchLine.isCanceled())
                    {
                        ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);

                        purchParameters = PurchParameters::find();
                        if (purchParameters.ChangeRequestEnabled)
                        {
                            if (accountingDistribution.ReferenceDistribution != 0)
                            {
                                ProjFundingLimitTrackingManager::releaseFundingLimitTracking(accountingDistribution);
                            }
                            else if (accountingDistribution.ParentDistribution != 0)
                            {
                                ProjFundingLimitTrackingManager::releaseFundingLimitForTaxNoRef(accountingDistribution, true);
                            }
                        }

                        return;
                    }
                    else if (ProjFundingLimitTrackingManager::hasPurchaseOrderBeenConfirmed(accountingDistribution))
                    {
                        return;
                    }
                }

                if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem || sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                {
                    areTaxFieldsDeleted = ProjFundingLimitTrackingManager::areTaxFieldsDeleted(sourceDocumentLineItem, accountingDistribution);
                    taxSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(accountingDistribution.SourceDocumentLine));

                    if (!_isDeletingSourceDocumentLine &&
                            areTaxFieldsDeleted &&
                            taxSourceDocumentLineItem != null &&
                            taxSourceDocumentLineItem is TaxSourceDocSublineItem)
                    {
                        runOnlyOnce = SysTransactionScopeCache::get('ProjFundingLimitTrackingManager.updateUsingProjAccountingDistribution', sourceDocumentLineItem.parmSourceDocumentLine().RecId, false);

                        if (!runOnlyOnce)
                        {
                            while select taxAccountingDistribution
                                where taxAccountingDistribution.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                            {
                                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(taxAccountingDistribution);
                            }

                            sourceDocumentLineItemList = SourceDocumentLineItemList::construct();
                            sourceDocumentLineItemList.addEnd(sourceDocumentLineItem);

                            //Reallocate funding sources for all distributions of the current source document
                            accDistProcessorProjectExtension = AccDistProcessorProjectExtension::construct();

                            accDistProcessorProjectExtension.processing(sourceDocumentLineItemList);
                            accDistProcessorProjectExtension.processed(sourceDocumentLineItemList);

                            SysTransactionScopeCache::set('ProjFundingLimitTrackingManager.updateUsingProjAccountingDistribution', sourceDocumentLineItem.parmSourceDocumentLine().RecId, true);
                        }
                    }
                    else
                    {
                        ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);
                    }
                }
            }

            return;
        }

        if (sourceDocumentLineItem is BudgetReservationSourceDocumentLineItem_PSN
            && BudgetReservationLine_PSN::findBySourceDocumentLine(sourcedocumentLineItem.parmSourceDocumentLine().RecId).isCanceled())
        {
            ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);
            action = ProjFundingLimitTrackingAction::Release;
        }

        if (accountingDistribution)
        {
            // Verify if this is a vendor payment retention transaction and set all the related variables.
            if ((sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem) || (sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem))
            {
                boolean isVendorInvoice;
                if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    isVendorInvoice = true;
                    vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                    purchLine = PurchLine::findRecId(vendInvoiceInfoLine.PurchLineRecId);
                }
                else
                {
                    purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                    vendInvoiceInfoLine = VendInvoiceInfoLine::findByPurchLineRefRecId(purchLine.RecId);
                }

                VendInvoiceInfoLine_Project projVendInvoiceInfoLine;
                select firstonly ProjSalesPrice from projVendInvoiceInfoLine
                    where projVendInvoiceInfoLine.VendInvoiceInfoLineRefRecId == vendInvoiceInfoLine.RecId;

                //Set markup percentage from either the purchase line or vendor invoice line depending on the document type.
                if (projVendInvoiceInfoLine && vendInvoiceInfoLine.PurchPrice)
                {
                    Price purchaseCostPrice = ProjectSourceDocumentLineItemHelper::getCostPriceWithDiscountApplied(vendInvoiceInfoLine.PurchPrice, vendInvoiceInfoLine.LineDisc, vendInvoiceInfoLine.LinePercent);
                    if (purchaseCostPrice)
                    {
                        markupRatio = projVendInvoiceInfoLine.ProjSalesPrice / purchaseCostPrice;
                    }
                }
                else if (purchLine.PurchPrice)
                {
                    Price purchaseCostPrice = ProjectSourceDocumentLineItemHelper::getCostPriceWithDiscountApplied(purchLine.PurchPrice, purchLine.LineDisc, purchLine.DiscPercent);
                    if (purchaseCostPrice)
                    {
                        markupRatio = purchLine.ProjSalesPrice / purchaseCostPrice;
                    }
                }

                // Determined if this invoice is associated with vendor payment retention terms.
                isRetainScheduleInvoice = vendInvoiceInfoLine.hasRetentionTerms();

                if (isRetainScheduleInvoice)
                {
                    if (isVendorInvoice)
                    {
                        retainInvoiceHasLineAmount = vendInvoiceInfoLine.LineAmount ? true : false;
                        calcVendorPaymentRetention = vendInvoiceInfoLine.isRetainedInvoiceSourceDocumentLineInCompletedState();
                        calcVendorPaymentRetentionTax = accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable;
                    }
                    
                    // Determine if this is the final invoice which all retainage amount will be released.
                    completedRetainedInvoiceByInventTransId = purchLine.isInvoiced()
                        && vendInvoiceInfoLine.hasAllRetainedAmountForThisInventTransBeenReleased()
                        && !vendInvoiceInfoLine.hasIncompleteRetainedInvoiceByInventTransId();
                }
            }

            // The tax non recoverable amount in Project accounting distribution amount is not correct amount for the project
            // retention scenario. For the project accounting distribution amount, the correct amount will require to minus the
            // child record TaxNonRecoverableVariance. However, when the code get to this logic, the TaxNonRecoverableVariance
            // record is not yet created. Hence the current tax amount is needed to be calculated based on the total tax amount
            // times the ratio of the actual amount to be invoice.
            if (calcVendorPaymentRetentionTax)
            {
                AmountCur taxAmount = ProjFundingLimitTrackingManager::calculateCurrentTaxAmount(accountingDistribution, vendInvoiceInfoLine, markupRatio);
                ProjTrans_Virtual projTransVirtual = projTrans as ProjTrans_Virtual;
                projTransVirtual.setTransTurnover(taxAmount);
                projTrans = projTransVirtual;
            }

            changecompany(CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea)
            {
                if (!ProjFundingLimit::existForContract(ProjTable::find(projTrans.projId()).ProjInvoiceProjId))
                {
                    return;
                }

                projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
                if (projLineProperty)
                {
                    // Only update limits for transaction To be Invoiced
                    if (!projLineProperty.ToBeInvoiced)
                    {
                        return;
                    }
                }

                if (!ProjInvoiceTable::isBillingRuleInvoiceable(projTrans.projId(), projTrans.categoryId(), projTrans.psaContractLineNum(), projTrans.transType()))
                {
                    return;
                }

                //
                // Use the topAccountingDistribution, it sign should match the source document
                // Children distributions may differ in the case of discounts, miscellaneous changes, variances
                //
                topAccountingDistribution = accountingDistribution;
                while (topAccountingDistribution.ParentDistribution != 0)
                {
                    topAccountingDistribution = AccountingDistribution::find(topAccountingDistribution.ParentDistribution);
                }

                if (topAccountingDistribution.TransactionCurrencyAmount < 0.0 &&
                    topAccountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                    !((sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem  ||
                        sourceDocumentLineItem is BudgetReservationSourceDocumentLineItem_PSN) &&
                    topAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Adjusting))
                {
                    sdLineCredit = NoYes::Yes;
                }

                //
                // Once a Purchase order has been confirmed the link to the Purchase Requistion needs to be ignored.
                //
                if (ProjFundingLimitTrackingManager::isPurchaseOrderAccDistribution(topAccountingDistribution))
                {
                    if (ProjFundingLimitTrackingManager::hasPurchaseOrderBeenConfirmed(topAccountingDistribution))
                    {
                        if (!isDistributionFromBudgetReservationHierarchy
                            || (isDistributionFromBudgetReservationHierarchy
                                && BudgetReservationHeader_PSN::hasBudgetReservationFinalized(topAccountingDistribution.RecId)))
                        {
                            updateRefLine = false;
                        }
                    }

                    if ((accountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice ||
                            accountingDistribution.MonetaryAmount != MonetaryAmount::PriceVariance) &&
                            _forceDeleteTracking)
                    {
                        updateRefLine = false;
                    }
                }

                // Convert Amount to Contract Currency
                amountInContractCurrency = ProjFundingEngine::curAmount2AmountOfContract(projTrans.projId(),
                                                                                        projTrans.transTurnover(),
                                                                                        projTrans.currencyIdSales(),
                                                                                        projTrans.transDate());
                //Update linked references
                // In the case of vendor payment retention, it should update the tax amount of the reversing entry even
                // The tax amount for the current invoice is zero. Reason is because the reversing entry is needed to be reset
                // to the tax amount which has been committed so far. In the case of reversing the final retention, 
                // the amount in contract currency can be zero which is a valid scenario.
                if (updateRefLine && (calcVendorPaymentRetentionTax || amountInContractCurrency != 0.0))
                {
                    select SourceRelationType from sourceDocumentHeader
                        where sourceDocumentHeader.RecId == accountingDistribution.SourceDocumentHeader;

                    if (accountingDistribution.ReferenceDistribution
                            && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                            && ((isDistributionFromBudgetReservationHierarchy && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Adjusting)
                                || !isDistributionFromBudgetReservationHierarchy))
                    {
                        referencedAccountingDistribution = AccountingDistribution::find(accountingDistribution.ReferenceDistribution);
                        refProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referencedAccountingDistribution.RecId);

                        referencedSourceDocumentLine = SourceDocumentLine::find(referencedAccountingDistribution.SourceDocumentLine);
                        
                        select firstonly projFundingLimitTrackingRef where projFundingLimitTrackingRef.ProjectAccountingDistribution == refProjectAccountingDistribution.RecId  &&
                            projFundingLimitTrackingRef.Reversing == NoYes::No;

                        if (projFundingLimitTrackingRef)
                        {
                            switch (action)
                            {
                                case ProjFundingLimitTrackingAction::Release :
                                    // Only create reversing entry for pending transactions
                                    ttsbegin;
                                    while select forupdate projFundingLimitTracking
                                        where projFundingLimitTracking.ProjectAccountingDistribution == refProjectAccountingDistribution.RecId
                                            && projFundingLimitTracking.Reversing == NoYes::Yes
                                            && projFundingLimitTracking.ProjFundingLimit == projFundingLimitTrackingRef.ProjFundingLimit
                                            && ((projFundingLimitTracking.SourceAccountingDistribution == accountingDistribution.RecId
                                                    && isDistributionFromBudgetReservationHierarchy)
                                                ||  !isDistributionFromBudgetReservationHierarchy)
                                    {
                                        select firstonly projFundingLimitTrackingCheck 
                                            where projFundingLimitTrackingCheck.ProjFundingLimit == projFundingLimitTracking.ProjFundingLimit
                                                && projFundingLimitTrackingCheck.ProjectAccountingDistribution == projectAccountingDistribution.RecId
                                                && projFundingLimitTrackingCheck.Reversing == NoYes::No;

                                        if (projFundingLimitTrackingCheck)
                                        {
                                            select firstonly Amount from projFundingLimitTrackingRef 
                                                where projFundingLimitTrackingRef.ProjFundingLimit == projFundingLimitTracking.ProjFundingLimit 
                                                    && projFundingLimitTrackingRef.ProjectAccountingDistribution == refProjectAccountingDistribution.RecId 
                                                    && projFundingLimitTrackingRef.Reversing == NoYes::No;

                                            amountOfLinkedFundingLimit = projFundingLimitTrackingRef.Amount;
                                            // If this is uncommitted tax, set amount in contrct currency as the full taxed amount.
                                            if (calcVendorPaymentRetentionTax)
                                            {
                                                projFundingLimitTracking.Amount  = -ProjFundingLimitTrackingManager::calculateCompletedTaxAmount(accountingDistribution);
                                            }
                                            else
                                            {
                                                projFundingLimitTracking.Amount += amountInContractCurrency;
                                            }
                                            if (((amountOfLinkedFundingLimit >= 0.0) &&
                                                (projFundingLimitTracking.Amount >= 0.0)) ||
                                                ((amountOfLinkedFundingLimit < 0.0) &&
                                                (projFundingLimitTracking.Amount <= 0.0)))
                                            {
                                                projFundingLimitTracking.delete();
                                            }
                                            else
                                            {
                                                projFundingLimitTracking.update();
                                            }
                                        }
                                    }
                                    ttscommit;
                                    break;

                                case ProjFundingLimitTrackingAction::Allocate :
                                    ttsbegin;
                                    while select projFundingLimitTrackingRef where  projFundingLimitTrackingRef.ProjectAccountingDistribution == refProjectAccountingDistribution.RecId  &&
                                        projFundingLimitTrackingRef.Reversing == NoYes::No
                                    {
                                        select forupdate firstonly projFundingLimitTracking
                                            where projFundingLimitTracking.ProjFundingLimit == projFundingLimitTrackingRef.ProjFundingLimit
                                                && projFundingLimitTracking.ProjectAccountingDistribution == refProjectAccountingDistribution.RecId
                                                && projFundingLimitTracking.Reversing == NoYes::Yes
                                                && ((projFundingLimitTracking.SourceAccountingDistribution == accountingDistribution.RecId
                                                    && isDistributionFromBudgetReservationHierarchy)
                                                    || !isDistributionFromBudgetReservationHierarchy);

                                        if (isDistributionFromBudgetReservationHierarchy)
                                        {
                                            if (sourceDocumentHeader.SourceRelationType == tableNum(BudgetReservationHeader_PSN))
                                            {
                                                amountOfLinkedFundingLimit = projFundingLimitTrackingRef.Amount;
                                            }
                                            else
                                            {
                                                amountOfLinkedFundingLimit = amountInContractCurrency;
                                            }
                                        }
                                        else
                                        {
                                            amountOfLinkedFundingLimit = projFundingLimitTrackingRef.Amount;
                                        }

                                        if (!projFundingLimitTracking
                                            || (sourceDocumentHeader.SourceRelationType == tableNum(PurchReqTable)
                                                && referencedSourceDocumentLine.SourceRelationType == tableNum(BudgetReservationLine_PSN)
                                                && !accountingDistribution.FinalizeAccountingEvent))
                                        {
											AmountCur amountToInsert;
											if (isDistributionFromBudgetReservationHierarchy)
                                            {
                                                amountToInsert = -amountOfLinkedFundingLimit;
                                            }
                                            else
                                            {
                                                if (sourceDocumentHeader.SourceRelationType == tableNum(PurchTable))
                                                {
                                                    if (amountOfLinkedFundingLimit > amountInContractCurrency)
                                                    {
                                                        amountToInsert = -amountInContractCurrency;
                                                    }
                                                    else
                                                    {
                                                        amountToInsert = -amountOfLinkedFundingLimit;
                                                    }
                                                }
                                                else
                                                {
                                                    amountToInsert = -amountInContractCurrency;
                                                }
                                            }

                                            // Reduce the amount with the invoiced tax amount
                                            if (calcVendorPaymentRetentionTax)
                                            {
                                                amountToInsert -= ProjFundingLimitTrackingManager::calculateCompletedTaxAmount(accountingDistribution);
                                            }

                                            projFundingLimitTracking.clear();
											ProjFundingLimitTrackingManager::initalizeProjFundingLimitTracking(projFundingLimitTracking,
                                                projFundingLimitTrackingRef.ProjFundingLimit,
												amountToInsert,
												referencedAccountingDistribution.SourceDocumentHeader,
												referencedAccountingDistribution.SourceDocumentLine,
												referencedAccountingDistribution.RecId,
												refProjectAccountingDistribution.RecId,
												accountingDistribution.RecId,
												NoYes::Yes,
												projFundingLimitTrackingRef.sdCreditLine,
												projFundingLimitTrackingRef.LimitError);
                                            projFundingLimitTracking.insert();
                                        }
                                        else
                                        {
                                            if (sourceDocumentHeader.SourceRelationType == tableNum(PurchTable))
                                            {
                                                select firstonly Amount from projFundingLimitPOTrackingRef 
                                                    where projFundingLimitPOTrackingRef.ProjFundingLimit == projFundingLimitTrackingRef.ProjFundingLimit &&
                                                        projFundingLimitPOTrackingRef.ProjectAccountingDistribution == refProjectAccountingDistribution.RecId &&
                                                        projFundingLimitPOTrackingRef.Reversing == NoYes::Yes;

                                                if (amountOfLinkedFundingLimit > (-projFundingLimitPOTrackingRef.Amount + amountInContractCurrency))
                                                {
                                                    projFundingLimitTracking.Amount = -(-projFundingLimitPOTrackingRef.Amount + amountInContractCurrency);
                                                }
                                                else
                                                {
                                                    projFundingLimitTracking.Amount = -amountOfLinkedFundingLimit;
                                                }
                                            }
                                            else if (!(sourceDocumentHeader.SourceRelationType == tableNum(PurchReqTable) 
                                                && referencedSourceDocumentLine.SourceRelationType == tableNum(BudgetReservationLine_PSN)
                                                && accountingDistribution.FinalizeAccountingEvent))
                                            {
                                                projFundingLimitTracking.Amount += -amountInContractCurrency;
                                                
                                                //
                                                // Validate that we don't reverse more than the orignal amount.
                                                // In the case of Purchase orders this is allow to maintian the maximum committed amount of the
                                                // Purchase Requisition until time of Purchase confirmation
                                                //
                                                if (((amountOfLinkedFundingLimit >= 0.0) &&
                                                    (projFundingLimitTracking.Amount < -amountOfLinkedFundingLimit)) ||
                                                    ((amountOfLinkedFundingLimit < 0.0) &&
                                                    (projFundingLimitTracking.Amount > -amountOfLinkedFundingLimit)))
                                                {
                                                    projFundingLimitTracking.Amount = -amountOfLinkedFundingLimit;
                                                }
                                            }
                                        projFundingLimitTracking.update();
                                    }
                                }
                                ttscommit;
                                break;
                            }
                        }
                    }
                }

                if (PublicSectorUtils::isBudgetReservationEnabled()
                    && (sourceDocumentHeader.SourceRelationType == tableNum(BudgetReservationHeader_PSN)
                        || referencedSourceDocumentLine.SourceRelationType == tableNum(BudgetReservationLine_PSN)))
                {
                    doCreateTrackingAmountForBudgetReservation = !accountingDistribution.FinalizeAccountingEvent
                        || (sourceDocumentHeader.SourceRelationType != tableNum(BudgetReservationHeader_PSN));
                }

                BudgetReservationHeader_PSN budgetReservationHeader_PSN;

                projSplitBill = ProjSplitBill::construct(projTrans);
                listOfLimits = projSplitBill.getTransLimits();
                listOfLimits.reset();
                while (listOfLimits.next())
                {
                    projFundingLimit = listOfLimits.get(tableNum(ProjFundingLimit));
                    if (projFundingLimit.FundingSource == projectAccountingDistribution.ProjFundingSource || projFundingLimit.FundingSource == 0)
                    {
                        switch (action)
                        {
                            case ProjFundingLimitTrackingAction::Release :
                            case ProjFundingLimitTrackingAction::Delete  :
                                ttsbegin;
                                select firstonly forupdate projFundingLimitTracking 
                                    where projFundingLimitTracking.ProjFundingLimit == projFundingLimit.RecId
                                        && projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId
                                        && projFundingLimitTracking.Reversing == NoYes::No;
                                if (projFundingLimitTracking
                                    && ((sourceDocumentHeader.SourceRelationType == tableNum(BudgetReservationHeader_PSN)
                                        && !AccountingEvent::findByAccountingEventType(sourceDocumentHeader.RecId, AccountingEventType::Finalize).RecId)
                                        || sourceDocumentHeader.SourceRelationType != tableNum(BudgetReservationHeader_PSN)))
                                {
                                    // Condition for the case of vendor payment retention scenario and if this is the final invoice for uncommitted tax.
                                    if (completedRetainedInvoiceByInventTransId && calcVendorPaymentRetentionTax)
                                    {
                                        // For the final invoice uncommitted tax transaction, then there shouldn't be any tax left.
                                        projFundingLimitTracking.Amount += -projFundingLimitTracking.Amount;
                                    }
                                    else
                                    {
                                        projFundingLimitTracking.Amount += -amountInContractCurrency;
                                    }

                                    if (abs(projFundingLimitTracking.Amount) <= adjustmentError)
                                    {
                                        if (sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                                        {
                                            purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);

                                            // Only when the purchase order is either invoiced or cancelled, the reversing transactions should also be deleted.
                                            if ((purchLine.isInvoiced() || purchLine.isCanceled()) && completedRetainedInvoiceByInventTransId)
                                            {
                                                if (purchLine.PurchReqId != '')
                                                {
                                                    delete_from projFundingLimitTrackingLoc
                                                        where projFundingLimitTrackingLoc.AccountingDistribution == projectAccountingDistribution.AccountingDistribution;
        
                                                    isFundingLimitDeleted = true;
                                                }
                                                else
                                                {
                                                    ProjFundingLimitTrackingManager::deleteFundingLimitTracking(projectAccountingDistribution);
                                                    isFundingLimitDeleted = true;
                                                }
                                            }
                                        }
        
                                        if (!isFundingLimitDeleted)
                                        {
                                            if (calcVendorPaymentRetention)
                                            {
                                                if (!calcVendorPaymentRetentionTax)
                                                {
                                                    // In the scenario of the retention amount is being released according to the received amount reach the percentage define by the retention rule,
                                                    // then just increment the retention amount to the purchase line funding limit tracking record.
                                                    if (completedRetainedInvoiceByInventTransId && retainInvoiceHasLineAmount)
                                                    {
                                                        amountInContractCurrency = -vendInvoiceInfoLine.PSAReleaseAmount;
                                                    }
                                                    else
                                                    {
                                                        VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = 
                                                            sourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                                                        
                                                        if (!ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled()
                                                            || !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                                                                ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled(),
                                                                purchLine.InventTransId))
                                                        {
                                                            amountInContractCurrency = vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                                                                accountingDistribution, amountInContractCurrency, false, false, calcVendorPaymentRetentionTax, false);
                                                        }
                                                    }

                                                    ProjFundingLimitTrackingManager::incrementAmountToReversingEntryForVendorInvoiceForVendInvoiceTrans(
                                                        accountingDistribution, projFundingLimitTracking, vendInvoiceInfoLine);
                                                }
                                                else
                                                {
                                                    ProjFundingLimitTrackingManager::incrementAmountToReversingEntryForVendorInvoiceForTaxTrans(
                                                        accountingDistribution, projFundingLimitTracking, vendInvoiceInfoLine);
                                                }
                                            }
                                            //lines with reversing = NoYes::Yes, created during expense report creation from the requisition is also deleted
                                            if (sourceDocumentLineItem is TrvRequisitionLineSourceDocLineItem &&
                                                accountingDistribution && _forceDeleteTracking)
                                            {
                                                ProjFundingLimitTrackingManager::deleteFundingLimitTracking(accountingDistribution);
                                            }
                                            else
                                            {
                                                projFundingLimitTracking.delete();
                                            }
                                        }
                                    }
                                    else
                                    {
                                        projFundingLimitTracking.update();
                                    }
                                }
                                ttscommit;
                                break;

                            case ProjFundingLimitTrackingAction::Allocate :
                                if (doCreateTrackingAmountForBudgetReservation)
                                {
                                    ttsbegin;
                                    select firstonly forupdate projFundingLimitTracking
                                        where projFundingLimitTracking.ProjFundingLimit    == projFundingLimit.RecId
                                            && projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId
                                            && (projFundingLimitTracking.Reversing == NoYes::No
                                                || (isDistributionFromBudgetReservationHierarchy
                                                    && projFundingLimitTracking.Reversing == NoYes::Yes
                                                    && projFundingLimitTracking.SourceAccountingDistribution == topAccountingDistribution.ReferenceDistribution));

                                    if (sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                                    {
                                        purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                                        
                                        // Purchase line will only be consider final if there is no retainage amount left.
                                        isPurchLineFinalized = (purchLine.IsFinalized == NoYes::Yes || purchLine.canFinalize(true)) &&
                                            (!isRetainScheduleInvoice || completedRetainedInvoiceByInventTransId) ? true : false;

                                    }
                                                                        
                                    if (isDistributionFromBudgetReservationHierarchy)
                                    {
                                        sourceDocumentHeader = SourceDocumentHeader::find(accountingDistribution.SourceDocumentHeader);

                                        budgetReservationHeader_PSN = BudgetReservationHeader_PSN::findBySourceDocumentHeader(SourceDocumentHeader.RecId);

                                        select firstonly forupdate projFundingLimitTrackingRef
                                            where projFundingLimitTrackingRef.Reversing == NoYes::Yes
                                                && (projFundingLimitTrackingRef.SourceAccountingDistribution == topAccountingDistribution.ReferenceDistribution
                                                    && topAccountingDistribution.ReferenceDistribution != 0)
                                                && projFundingLimitTrackingRef.ProjFundingLimit == projFundingLimit.RecId;
                                    }

                                    if (!isDistributionFromBudgetReservationHierarchy
                                        || (isDistributionFromBudgetReservationHierarchy
                                            && (((sourceDocumentHeader.SourceRelationType == tableNum(BudgetReservationHeader_PSN)
                                                || sourceDocumentHeader.SourceRelationType == tableNum(PurchReqTable))
                                                && (!projFundingLimitTrackingRef
                                                    || topAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Adjusting
                                                    || budgetReservationHeader_PSN.DocumentStatus == BudgetReservationDocumentStatus_PSN::Canceled))
                                                || (sourceDocumentHeader.SourceRelationType == tableNum(PurchTable)
                                                || sourceDocumentHeader.SourceRelationType == tableNum(VendInvoiceInfoTable)))))
                                    {
                                        if (!projFundingLimitTracking)
                                        {
                                            //Tracking record should not be created for a purchase order to be finalized.
                                            if (!isPurchLineFinalized)
                                            {
                                                NoYes isReversing = NoYes::No;
                                                RefRecId sourceAccountingDistribution = 0;
                                                if (isDistributionFromBudgetReservationHierarchy
                                                            && (topAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                                                                || amountInContractCurrency < 0))
                                                {
                                                    isReversing = NoYes::Yes;
                                                    sourceAccountingDistribution = topAccountingDistribution.ReferenceDistribution;
                                                }

                                                projFundingLimitTracking.clear();
                                                ProjFundingLimitTrackingManager::initalizeProjFundingLimitTracking(projFundingLimitTracking,
													projFundingLimit.RecId,
													amountInContractCurrency,
													accountingDistribution.SourceDocumentHeader,
													accountingDistribution.SourceDocumentLine,
													accountingDistribution.RecId,
													projectAccountingDistribution.RecId,
													sourceAccountingDistribution,
													isReversing,
                                                    sdLineCredit,
													NoYes::No);
												projFundingLimitTracking.insert();
                                            }
                                        }
                                        else
                                        {
                                            projFundingLimitTracking.Amount += amountInContractCurrency;
                                            projFundingLimitTracking.update();
                                        }
                                    }
                                    else
                                    {
                                        projFundingLimitTrackingRef.Amount = amountInContractCurrency;
                                        projFundingLimitTrackingRef.update();
                                    }
                                    ttscommit;
                                }
                                break;

                            case ProjFundingLimitTrackingAction::Commit :
                                // Update committed amount
                                ttsbegin;
                                projFundingLimit.selectForUpdate(true);
                                projFundingLimit.LimitSpent += amountInContractCurrency;
                                projFundingLimit.update();

                                // Remove tracking record
                                delete_from projFundingLimitTracking where projFundingLimitTracking.ProjFundingLimit == projFundingLimit.RecId &&
                                    projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId;
                                ttscommit;
                                break;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsingProjTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the revenuen tracking based on a project transaction.
    /// </summary>
    /// <param name="projTrans">
    ///     The project transaction
    /// </param>
    /// <param name="action">
    ///     The revenue tracking action
    /// </param>
    public static void updateUsingProjTrans(
            ProjTrans                       projTrans,
            ProjFundingLimitTrackingAction  action)
    {
        ProjFundingLimit                projFundingLimit;
        ProjFundingLimitTracking        projFundingLimitTracking;
        ProjLineProperty                projLineProperty;
        ProjSplitBill                   projSplitBill;
        ProjTable                       projTable;
        QueryRun                        listOfLimits;
        AmountCur                       amountInContractCurrency;
        NoYes                           sdLineCredit = NoYes::No;

        if (!projTrans)
        {
            return;
        }

        if (projTrans.transTurnover() == 0.0)
        {
            return;
        }

        projTable = ProjTable::find(projTrans.projId());
        if (projTable)
        {
            changecompany(projTable.companyInfo().DataArea)
            {
                if (!ProjFundingLimit::existForContract(ProjTable::find(projTrans.projId()).ProjInvoiceProjId))
                {
                    return;
                }

                projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
                if (projLineProperty)
                {
                    // Only update limits for transaction To be Invoiced
                    if (!projLineProperty.ToBeInvoiced)
                    {
                        return;
                    }
                }

                if (!ProjInvoiceTable::isBillingRuleInvoiceable(projTrans.projId(), projTrans.categoryId(), projTrans.psaContractLineNum()))
                {
                    return;
                }

                // Convert Amount to Contract Currency
                amountInContractCurrency = ProjFundingEngine::curAmount2AmountOfContract(projTrans.projId(),
                                                                                                projTrans.transTurnover(),
                                                                                                projTrans.currencyIdSales(),
                                                                                                projTrans.transDate());
                //No parent distribuiton use amount to determine if credit line
                if (projTrans.transTurnover() < 0.0)
                {
                    sdLineCredit = NoYes::Yes;
                }

                //
                //  Project Journal entrys do not have linked references, No need to track amount accross documents.
                //

                //
                //  Apply action to all of the funding limits which are affected.
                //
                projSplitBill = ProjSplitBill::construct(projTrans);
                listOfLimits = projSplitBill.getTransLimits();
                listOfLimits.reset();
                while (listOfLimits.next())
                {
                    projFundingLimit = listOfLimits.get(tableNum(ProjFundingLimit));
                    if (projFundingLimit.FundingSource == projTrans.fundingSource() || projFundingLimit.FundingSource == 0)
                    {
                        switch (action)
                        {
                            case ProjFundingLimitTrackingAction::Release :
                            case ProjFundingLimitTrackingAction::Delete :
                                //
                                // Release and Delete will be treated as the same action for Project Journals.
                                //
                                ttsbegin;
                                select firstonly forupdate projFundingLimitTracking 
                                    where projFundingLimitTracking.ProjFundingLimit == projFundingLimit.RecId 
                                        && projFundingLimitTracking.TransId == projTrans.transId();

                                if (projFundingLimitTracking)
                                {
                                    projFundingLimitTracking.Amount += -amountInContractCurrency;
                                    if ( projFundingLimitTracking.Amount == 0.0)
                                    {
                                        projFundingLimitTracking.delete();
                                    }
                                    else
                                    {
                                        projFundingLimitTracking.update();
                                    }
                                }
                                ttscommit;
                                break;

                            case ProjFundingLimitTrackingAction::Allocate :
                                ttsbegin;
                                select firstonly forupdate projFundingLimitTracking
                                    where projFundingLimitTracking.ProjFundingLimit == projFundingLimit.RecId 
                                        && projFundingLimitTracking.TransId == projTrans.transId() 
                                        && projFundingLimitTracking.Reversing == NoYes::No;

                                if (!projFundingLimitTracking)
                                {
                                    projFundingLimitTracking.clear();
									ProjFundingLimitTrackingManager::initalizeProjFundingLimitTracking(projFundingLimitTracking,
										projFundingLimit.RecId,
										amountInContractCurrency,
										0,
										0,
										0,
										0,
										0,
										NoYes::No,
										sdLineCredit,
										NoYes::No,
										projTrans.transId());
                                    projFundingLimitTracking.insert();
                                }
                                else
                                {
                                    projFundingLimitTracking.ProjFundingLimit = projFundingLimit.RecId;
                                    projFundingLimitTracking.Amount           += amountInContractCurrency;
                                    projFundingLimitTracking.update();
                                }
                                ttscommit;
                                break;

                            case ProjFundingLimitTrackingAction::Commit :
                                ttsbegin;
                                projFundingLimit.selectForUpdate(true);
                                projFundingLimit.LimitSpent += amountInContractCurrency;
                                projFundingLimit.update();

                                // Remove tracking record
                                delete_from projFundingLimitTracking where projFundingLimitTracking.ProjFundingLimit == projFundingLimit.RecId &&
                                                                               projFundingLimitTracking.TransId == projTrans.transId();
                                ttscommit;
                                break;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsingSourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the project revenue tracking based on a source document.
    /// </summary>
    /// <param name="sourceDocumentHeaderRefId">
    ///     The record id of the source document
    /// </param>
    /// <param name="action">
    ///     The revenue tracking action
    /// </param>
    /// <param name="updateRefLine">
    ///     Update referenced document tracking.
    /// </param>
    /// <param name="skipUpdateRefLineCheck">
    ///     Skip checks for updating referenced line.
    /// </param>
    /// <param name="_forceDeleteTracking">
    ///     If true, force deletion of funding tracking records.
    /// </param>
    /// <param name="_isDeletingSourceDocumentLine">
    ///     If true, source document line delete is being called.
    /// </param>
    public static void updateUsingSourceDocument(
            RefRecId                        sourceDocumentHeaderRefId,
            ProjFundingLimitTrackingAction  action,
            boolean                         updateRefLine = true,
            boolean                         skipUpdateRefLineCheck = false,
            boolean                         _forceDeleteTracking = false,
            boolean                         _isDeletingSourceDocumentLine = false)
    {
        if (ProjFundingLimitTrackingManager::checkValidDocumentReference(sourceDocumentHeaderRefId))
        {
            SourceDocumentLine  sourceDocumentLine;

            while select sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeaderRefId
                       && !sourceDocumentLine.ParentSourceDocumentLine
            {
                SourceDocumentLineItem sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);

                if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    InventTransId inventTransId = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLine.RecId).InventTransId;
                    if (inventTransId)
                    {
                        SalesLine salesLine;
                        select firstOnly RecId from salesLine
                            where salesLine.InventRefTransId == inventTransId
                               && salesLine.SalesType == SalesType::ItemReq
                               && salesLine.SalesStatus != SalesStatus::Invoiced;

                        // Vendor invoice referring to item requirement lines which are not consumed during PO product receipt, then funding tracking limits should not be deleted.
                        if (salesLine.RecId)
                        {
                            continue;
                        }
                    }
                }
                
                ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(sourceDocumentLine.RecId, action, updateRefLine, skipUpdateRefLineCheck, _forceDeleteTracking, _isDeletingSourceDocumentLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsingSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the project revenue tracking based on a source document line.
    /// </summary>
    /// <param name="_sourceDocumentLineRefId">
    ///     The source document line
    /// </param>
    /// <param name="_action">
    ///     The revenue tracking action
    /// </param>
    /// <param name="_updateRefLine">
    ///     Update referenced document tracking.
    /// </param>
    /// <param name="skipUpdateRefLineCheck">
    ///     Skip checks for updating referenced line.
    /// </param>
    /// <param name="_forceDeleteTracking">
    ///     If true, force deletion of funding tracking records.
    /// </param>
    /// <param name="_isDeletingSourceDocumentLine">
    ///     If true, source document line delete is being called.
    /// </param>
    public static void updateUsingSourceDocumentLine(
            RefRecId                        _sourceDocumentLineRefId,
            ProjFundingLimitTrackingAction  _action,
            boolean                         _updateRefLine = true,
            boolean                         skipUpdateRefLineCheck = false,
            boolean                         _forceDeleteTracking = false,
            boolean                         _isDeletingSourceDocumentLine = false)
    {
        SourceDocumentHeader                    sourceDocumentHeader;
        SourceDocumentLine                      sourceDocumentLine;
        Set                                     sourceDocumentLines;
        SetEnumerator                           setEnumerator;
        RefRecId                                currentSourceDocumentLine;
        AccountingDistributionList              accountingDistributions;
        AccountingDistributionListEnumerator    accountingDistributionListEnumerator;
        AccountingDistribution                  localAccountingDistribution;
        ProjectAccountingDistribution           localProjectAccountingDistribution;

        Set getSourceDocumentLinesSet(RefRecId _sourceDocumentLine)
        {
            Set                 ret;
            SourceDocumentLine  childSourceDocumentLine;
            Stack               stack;
            RefRecId            refRecId;

            ret = new Set(Types::Int64);

            if (_sourceDocumentLine)
            {
                stack = new Stack();
                stack.push([_sourceDocumentLine]);

                while (stack.qty())
                {
                    [refRecId] = stack.pop();

                    ret.add(refRecId);

                    while select ParentSourceDocumentLine, RecId
                        from childSourceDocumentLine
                        where childSourceDocumentLine.ParentSourceDocumentLine == refRecId
                    {
                        stack.push([childSourceDocumentLine.RecId]);
                    }
                }
            }

            return ret;
        }

        AccountingDistributionList getActiveDistributionsList(RefRecId _sourceDocumentLine)
        {
            AccountingDistribution      accountingDistribution;
            AccountingDistribution      reversingAccountingDistribution;
            AccountingDistributionList  ret;

            ret = AccountingDistributionList::construct();

            if (_sourceDocumentLine)
            {
                while select accountingDistribution
                    order by accountingDistribution.MonetaryAmount
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLine &&
                        accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                    notexists join reversingAccountingDistribution
                    where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId &&
                        reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
                {
                    ret.addEnd(accountingDistribution);
                }
            }

            return ret;
        }

        boolean hasProject(RefRecId _sourceDocumentLine)
        {
            AccountingDistribution          accountingDistribution;
            ProjectAccountingDistribution   projectAccountingDistribution;

            select firstonly RecId from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == _sourceDocumentLine
                join RecId from projectAccountingDistribution
                    where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;

            return accountingDistribution.RecId != 0;
        }

        // No reason to execute revenue tracking code if project is not part of the source document.
        if (hasProject(_sourceDocumentLineRefId))
        {
            sourceDocumentLine = SourceDocumentLine::find(_sourceDocumentLineRefId);
            if (sourceDocumentLine)
            {
                sourceDocumentHeader = SourceDocumentHeader::find(sourceDocumentLine.SourceDocumentHeader);
                // Don't call if source document header is missing -- cascade delete
                if (sourceDocumentHeader)
                {
                    sourceDocumentLines = getSourceDocumentLinesSet(_sourceDocumentLineRefId);
                    setEnumerator = sourceDocumentLines.getEnumerator();
                    while (setEnumerator.moveNext())
                    {
                        currentSourceDocumentLine = setEnumerator.current();
                        accountingDistributions = getActiveDistributionsList(currentSourceDocumentLine);

                        if (accountingDistributions)
                        {
                            accountingDistributionListEnumerator = accountingDistributions.getEnumerator();
                            while (accountingDistributionListEnumerator.moveNext())
                            {
                                localAccountingDistribution = accountingDistributionListEnumerator.current();
                                localProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(localAccountingDistribution.RecId);
                                if (localProjectAccountingDistribution)
                                {
                                    ProjFundingLimitTrackingManager::updateUsingProjAccountingDistribution(localProjectAccountingDistribution,
                                                                                                                localAccountingDistribution,
                                                                                                                _action,
                                                                                                                _updateRefLine,
                                                                                                                skipUpdateRefLineCheck,
                                                                                                                _forceDeleteTracking,
                                                                                                                _isDeletingSourceDocumentLine);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementAmountToReversingEntryForVendorInvoiceForVendInvoiceTrans</Name>
				<Source><![CDATA[
    private static void incrementAmountToReversingEntryForVendorInvoiceForVendInvoiceTrans(AccountingDistribution _accountingDistribution, ProjFundingLimitTracking _projFundingLimitTrack, 
        VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        // Increment retention amount to the reversing entry before this entry which source document header is referencing to VendInvoiceInfoTable is being removed.
        AccountingDistribution accDistribution = ProjFundingLimitTrackingManager::getAccountingDistribution(_projFundingLimitTrack);
        if (SourceDocumentHeader::find(accDistribution.SourceDocumentHeader).SourceRelationType == tableNum(VendInvoiceInfoTable))
        {
            ProjFundingLimitTracking fundingLimitTrackingForUpdate;

            if (SourceDocumentLine::find(accDistribution.SourceDocumentLine).SourceRelationType == tableNum(VendInvoiceTrans))
            {
                fundingLimitTrackingForUpdate = ProjFundingLimitTrackingManager::getPurchLineReversingProjFundingLimitTrackingRecord(_projFundingLimitTrack, _vendInvoiceInfoLine);

                if (fundingLimitTrackingForUpdate)
                {
                    fundingLimitTrackingForUpdate.Amount = -ProjFundingLimitTrackingManager::calculateCompletedInvoiceLineAmount(_accountingDistribution);
                    fundingLimitTrackingForUpdate.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementAmountToReversingEntryForVendorInvoiceForTaxTrans</Name>
				<Source><![CDATA[
    private static void incrementAmountToReversingEntryForVendorInvoiceForTaxTrans(AccountingDistribution _accountingDistribution, ProjFundingLimitTracking _projFundingLimitTrack, 
        VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        // Increment retention amount to the reversing entry before this entry which source document header is referencing to VendInvoiceInfoTable is being removed.
        AccountingDistribution accDistribution = ProjFundingLimitTrackingManager::getAccountingDistribution(_projFundingLimitTrack);
        if (SourceDocumentHeader::find(accDistribution.SourceDocumentHeader).SourceRelationType == tableNum(VendInvoiceInfoTable))
        {
            ProjFundingLimitTracking fundingLimitTrackingForUpdate;

            if (SourceDocumentLine::find(accDistribution.SourceDocumentLine).SourceRelationType == tableNum(TaxTrans))
            {
                fundingLimitTrackingForUpdate = ProjFundingLimitTrackingManager::getTaxUncommittedReversingProjFundingLimitTrackingRecord(_projFundingLimitTrack, _vendInvoiceInfoLine);

                if (fundingLimitTrackingForUpdate)
                {
                    fundingLimitTrackingForUpdate.Amount = -ProjFundingLimitTrackingManager::calculateCompletedTaxAmount(_accountingDistribution);
                    fundingLimitTrackingForUpdate.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDistribution</Name>
				<Source><![CDATA[
    private static AccountingDistribution getAccountingDistribution(ProjFundingLimitTracking _ProjfundingLimitTracking)
    {
        AccountingDistribution accDistribution;
        ProjectAccountingDistribution projAccDistribution;
        ProjFundingLimitTracking projFundLimitTracking;

        select firstonly accDistribution
            exists join projAccDistribution
                where projAccDistribution.AccountingDistribution == accDistribution.RecId
            exists join projFundLimitTracking
                where projFundLimitTracking.ProjectAccountingDistribution == projAccDistribution.RecId &&
                    projFundLimitTracking.RecId == _ProjfundingLimitTracking.RecId;

        return accDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchLineReversingProjFundingLimitTrackingRecord</Name>
				<Source><![CDATA[
    private static ProjFundingLimitTracking getPurchLineReversingProjFundingLimitTrackingRecord(ProjFundingLimitTracking _projFundingLimitTracking, VendInvoiceInfoLine _vendInfoiceInfoLine)
    {
        ProjFundingLimitTracking projFundLimitTracking;
        PurchLine purchLine;
        
        select firstonly forupdate projFundLimitTracking
            where projFundLimitTracking.ProjFundingLimit == _projFundingLimitTracking.ProjFundingLimit &&
                projFundLimitTracking.Reversing == NoYes::Yes
        exists join purchLine
            where purchLine.RecId == _vendInfoiceInfoLine.PurchLineRecId &&
                purchLine.SourceDocumentLine == projFundLimitTracking.SourceDocumentLine;

        return projFundLimitTracking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxUncommittedReversingProjFundingLimitTrackingRecord</Name>
				<Source><![CDATA[
    private static ProjFundingLimitTracking getTaxUncommittedReversingProjFundingLimitTrackingRecord(ProjFundingLimitTracking _projFundingLimitTracking, VendInvoiceInfoLine _vendInfoiceInfoLine)
    {
        ProjFundingLimitTracking projFundLimitTracking;
        PurchLine purchLine;
        TaxUncommitted  taxUncommitted;
        
        select firstonly forupdate projFundLimitTracking
            where projFundLimitTracking.ProjFundingLimit == _projFundingLimitTracking.ProjFundingLimit &&
                projFundLimitTracking.Reversing == NoYes::Yes
        exists join purchLine
            where purchLine.RecId == _vendInfoiceInfoLine.PurchLineRecId
        exists join taxUncommitted
            where taxUncommitted.SourceTableId == purchLine.TableId &&
                taxUncommitted.SourceRecId == purchLine.RecId &&
                taxUncommitted.SourceDocumentLine == projFundLimitTracking.SourceDocumentLine;
            
        return projFundLimitTracking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCompletedInvoiceLineAmount</Name>
				<Source><![CDATA[
    private static AmountCur calculateCompletedInvoiceLineAmount(AccountingDistribution _accountingDistribution)
    {
        ProjectAccountingDistribution projAccDistRef;
        AccountingDistribution accDistRef;
        SourceDocumentLine sourceDocumentLine;

        select sum(TransactionCurrencyAmount) from projAccDistRef
            exists join accDistRef
                where accDistRef.ReferenceDistribution == _accountingDistribution.ReferenceDistribution &&
                    accDistRef.RecId == projAccDistRef.AccountingDistribution
            exists join sourceDocumentLine
                where sourceDocumentLine.RecId == accDistRef.SourceDocumentLine &&
                    sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed;

        return projAccDistRef.TransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCompletedTaxAmount</Name>
				<Source><![CDATA[
    private static AmountCur calculateCompletedTaxAmount(AccountingDistribution _accountingDistribution)
    {
        ProjectAccountingDistribution projAccDistTaxRef;
        AccountingDistribution accDistTaxRef;
        SourceDocumentLine sourceDocumentLine;

        select sum(TransactionCurrencyAmount) from projAccDistTaxRef
            exists join accDistTaxRef
                where accDistTaxRef.ReferenceDistribution == _accountingDistribution.ReferenceDistribution
                    && accDistTaxRef.RecId == projAccDistTaxRef.AccountingDistribution
            exists join sourceDocumentLine
                where sourceDocumentLine.RecId == accDistTaxRef.SourceDocumentLine &&
                    sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed;

        ProjectAccountingDistribution projAccDistTaxVarianceChild;
        AccountingDistribution accDistTaxChild;
        AccountingDistribution accDistTaxParent;

        select sum(TransactionCurrencyAmount) from projAccDistTaxVarianceChild
            exists join accDistTaxChild
                where accDistTaxChild.RecId == projAccDistTaxVarianceChild.AccountingDistribution
            exists join accDistTaxParent
                where accDistTaxParent.RecId == accDistTaxChild.ParentDistribution &&
                    accDistTaxParent.ReferenceDistribution == _accountingDistribution.ReferenceDistribution
            exists join sourceDocumentLine
                where sourceDocumentLine.RecId == accDistTaxParent.SourceDocumentLine &&
                    sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed;

        // Add the variance tax.
        return projAccDistTaxRef.TransactionCurrencyAmount + projAccDistTaxVarianceChild.TransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCurrentTaxAmount</Name>
				<Source><![CDATA[
    private static AmountCur calculateCurrentTaxAmount(AccountingDistribution _accountingDistribution,
        VendInvoiceInfoLine _vendInvoiceInfoLine, Percent _markupRatio)
    {
        Amount currentTaxAmount;

        if (_markupRatio != 0 && _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
        {
            // Get the total tax amount for this purchase order from accounting distribution record.
            AccountingDistribution totalUnCommitedTaxAD;
            select firstonly TransactionCurrencyAmount from totalUnCommitedTaxAD
                where totalUnCommitedTaxAD.RecId == _accountingDistribution.ReferenceDistribution;

            AmountCur totalTaxAmount = totalUnCommitedTaxAD.TransactionCurrencyAmount;

            PurchLine purchLine = PurchLine::findInventTransId(_vendInvoiceInfoLine.InventTransId);
            AmountCur purchLineAmount = purchLine.LineAmount;

            if (purchLineAmount)
            {
                VendInvoiceInfoLine vendInvoiceInfoLine;
                SourceDocumentLine sourceDocumentLine;

                select firstonly LineAmount, PSARetainageAmount, PSAReleaseAmount from vendInvoiceInfoLine
                    where vendInvoiceInfoLine.RecId == _vendInvoiceInfoLine.RecId;
                
                if (ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled()
                    && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                        ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled(),
                        purchLine.InventTransId))
                {
                    currentTaxAmount = totalTaxAmount / purchLineAmount * vendInvoiceInfoLine.LineAmount * _markupRatio;
                }
                else
                {
                    // Calculate the current tax amount by multiplying markup percentage to the total of tax amount times the ratio of the current vendor invoice amount.
                    currentTaxAmount = totalTaxAmount / purchLineAmount *
                        (vendInvoiceInfoLine.LineAmount - vendInvoiceInfoLine.PSARetainageAmount + vendInvoiceInfoLine.PSAReleaseAmount) *
                        _markupRatio;
                }

                currentTaxAmount = CurrencyExchangeHelper::price(currentTaxAmount, _accountingDistribution.TransactionCurrency);
            }
        }

        return currentTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initalizeProjFundingLimitTracking</Name>
				<Source><![CDATA[
    public static void initalizeProjFundingLimitTracking(ProjFundingLimitTracking _projFundingLimitTracking,
		RefRecId _fundingLimit,
        AmountCur _amount,
        RefRecId _sourceDocumentHeader = 0,
		RefRecId _sourceDocumentLine = 0,
		RefRecId _accountingDistribution = 0,
        RefRecId _projectAccountingDistribution = 0,
        RefRecId _sourceAccountingDistribution = 0,
        NoYes _reversing = NoYes::No,
        NoYes _sdCreditLine = NoYes::No,
        NoYes _limitError = NoYes::No,
		ProjTransIdBase _transId = '')
    {
        _projFundingLimitTracking.Amount = _amount;
        _projFundingLimitTracking.AccountingDistribution = _accountingDistribution;
        _projFundingLimitTracking.LimitError = _limitError;
        _projFundingLimitTracking.ProjectAccountingDistribution = _projectAccountingDistribution;
        _projFundingLimitTracking.ProjFundingLimit = _fundingLimit;
        _projFundingLimitTracking.Reversing = _reversing;
        _projFundingLimitTracking.sdCreditLine = _sdCreditLine;
        _projFundingLimitTracking.SourceAccountingDistribution = _sourceAccountingDistribution;
        _projFundingLimitTracking.SourceDocumentHeader = _sourceDocumentHeader;
        _projFundingLimitTracking.SourceDocumentLine = _sourceDocumentLine;
        _projFundingLimitTracking.TransId = _transId;

	}

]]></Source>
			</Method>
			<Method>
				<Name>insertFundingLimitsTrackingByProjTran</Name>
				<Source><![CDATA[
    public static void insertFundingLimitsTrackingByProjTran(ProjTrans _projTrans,
                                    ProjFundingSourceRefId _fundingSourceRefId,
                                    AmountCur _amountInTrxCurrency,
									ProjTransIdBase _transId = '')
    {
        QueryRun                listOfLimits;
        ProjFundingLimit        projFundingLimit;
        RecId                   projFundingLimitRecId;
        ProjLineProperty        projLineProperty;
        ProjTable               projTable;
        AmountCur               amountInContractCurrency;

		if (!_projTrans)
        {
            return;
        }

        projTable = ProjTable::find(_projTrans.projId());

        // No funding limits exist for contract
        if (!ProjFundingLimit::existForContract(projTable.ProjInvoiceProjId))
        {
            return;
        }

        projLineProperty = ProjLineProperty::find(_projTrans.linePropertyId());
        if (projLineProperty)
        {
            // Only update limits for transaction To be Invoiced
            if (!projLineProperty.ToBeInvoiced)
            {
                return;
            }
        }

        if (!ProjInvoiceTable::isBillingRuleInvoiceable(projTable.ProjId, _projTrans.categoryId(), _projTrans.psaContractLineNum(), _projTrans.transType()))
        {
            return;
        }

        // Convert Amount to Contract Currency
        amountInContractCurrency = ProjFundingEngine::curAmount2AmountOfContract(_projTrans.projId(), _amountInTrxCurrency, _projTrans.currencyIdSales(), _projTrans.transDate());

        ProjSplitBill projSplitBill = ProjSplitBill::construct(_projTrans);
        listOfLimits = projSplitBill.getTransLimits();

        ProjTransIdBase transIdForInsert = _transId;
		if (transIdForInsert == '')
        {
            transIdForInsert = _projTrans.transId();
        }
        ProjFundingLimitTracking projFundingLimitTracking;
        while (listOfLimits.next())
        {
            projFundingLimit = listOfLimits.get(tableNum(ProjFundingLimit));
            if (projFundingLimit.FundingSource == _fundingSourceRefId || projFundingLimit.FundingSource == 0)
            {
                ttsbegin;
                ProjFundingLimitTrackingManager::initalizeProjFundingLimitTracking(projFundingLimitTracking, 
                    projFundingLimit.RecId, amountInContractCurrency,
					0,
					0,
					0,
					0,
					0,
					NoYes::No,
					NoYes::No,
					NoYes::No,
                    transIdForInsert);
                projFundingLimitTracking.insert();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>countOfOphanAccountingDistributionRecords</Name>
				<Source><![CDATA[
    public final static int64 countOfOphanAccountingDistributionRecords()
    {
        AccountingDistribution accountingDistribution;
        ProjFundingLimitTracking projFundingLimitTracking;
        
        select count(RecId) from projFundingLimitTracking
            notexists join accountingDistribution
                where projFundingLimitTracking.AccountingDistribution == accountingDistribution.RecId
                && projFundingLimitTracking.TransId == '';

        return projFundingLimitTracking.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrphanAccountingDistributionRecords</Name>
				<Source><![CDATA[
    public final static void deleteOrphanAccountingDistributionRecords()
    {
        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjFundingLimitTrackingManager));
            
        using (var activityContext = logger.projOpsFinActivity().ProjOrphanFundingLimitAccountingDistributionCleanup())
        {
            AccountingDistribution accountingDistribution;
            ProjFundingLimitTracking projFundingLimitTracking;

            // Set based operation is not being used as we want to collect some information
            // about the records being deleted. Unfortunately, the current data model does not
            // include the transaction origin to identify the source document which caused the issue.
            while select forupdate ProjFundingLimit, SourceDocumentLine from projFundingLimitTracking
                notexists join accountingDistribution
                where projFundingLimitTracking.AccountingDistribution == accountingDistribution.RecId
                && projFundingLimitTracking.TransId == ''
            {
                logger.logInformation(strFmt(ProjOpsFinancialsInstrumentationActivites::ProjOrphanFundingLimitAccountingDistributionCleanupLogMessageFmt, projFundingLimitTracking.ProjFundingLimit, projFundingLimitTracking.SourceDocumentLine, projFundingLimitTracking.AccountingDistribution));
                ttsbegin;
                projFundingLimitTracking.delete();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>countOfOphanSourceDocumentLineRecords</Name>
				<Source><![CDATA[
    public final static int64 countOfOphanSourceDocumentLineRecords()
    {
        SourceDocumentLine sourceDocumentLine;
        ProjFundingLimitTracking projFundingLimitTracking;
        
        select count(RecId) from projFundingLimitTracking
        notexists join sourceDocumentLine
            where projFundingLimitTracking.SourceDocumentLine == sourceDocumentLine.RecId
            && projFundingLimitTracking.TransId == '';

        return projFundingLimitTracking.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrphanSourceDocumentLineRecords</Name>
				<Source><![CDATA[
    public final static void deleteOrphanSourceDocumentLineRecords()
    {
        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjFundingLimitTrackingManager));
            
        using (var activityContext = logger.projOpsFinActivity().projOrphanFundingLimitSourceDocumentLineCleanup())
        {
            SourceDocumentLine sourceDocumentLine;
            ProjFundingLimitTracking projFundingLimitTracking;

            // Set based operation is not being used as we want to collect some information
            // about the records being deleted. Unfortunately, the current data model does not
            // include the transaction origin to identify the source document which caused the issue.
            while select forupdate ProjFundingLimit, SourceDocumentLine from projFundingLimitTracking
                notexists join sourceDocumentLine
                where projFundingLimitTracking.SourceDocumentLine == sourceDocumentLine.RecId
                && projFundingLimitTracking.TransId == ''
            {
                logger.logInformation(strFmt(ProjOpsFinancialsInstrumentationActivites::ProjOrphanFundingLimitSourceDocumentLineCleanupLogMessageFmt, projFundingLimitTracking.ProjFundingLimit, projFundingLimitTracking.SourceDocumentLine));
                ttsbegin;
                projFundingLimitTracking.delete();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>