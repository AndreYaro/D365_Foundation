<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjWBSTree</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProjWBSTree</c> class is internal class that represents tree of
/// Work breakdown structure task nodes.
/// </summary>
class ProjWBSTree
{
    Map childrenOf;
    Map nodes;
    Map activityNumberToElementNumber;
    Map hasAnyChild;
    HierarchyIdBase hierarchyId;
    ElementNumber rootElementNumber;
    Set isNotLoaded;
    boolean isDebugOn;
    CategoryId categoryId;
    boolean isTreeFullyLoaded;
    boolean isQuotation;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activityNumberToElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an <c>ElementNumber</c> object that corresponds to the given <c>smmActivityNumber</c>.
    /// </summary>
    /// <param name="_smmActivityNumber">
    /// The <c>smmActivityNumber</c> to use for look up.
    /// </param>
    /// <returns>
    /// The <c>ElementNumber</c> object.
    /// </returns>
    public ElementNumber activityNumberToElementNumber(smmActivityNumber _smmActivityNumber)
    {
        if (activityNumberToElementNumber.exists(_smmActivityNumber))
        {
            return activityNumberToElementNumber.lookup(_smmActivityNumber);
        }
        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a child node to the project WBS tree.
    /// </summary>
    /// <param name="_parentElementNumber">
    /// The number of the parent node.
    /// </param>
    /// <param name="_addedNode">
    /// The node to add.
    /// </param>
    public void addChild(ElementNumber _parentElementNumber, ProjWBSTreeNode _addedNode)
    {
        ProjWBSTreeNode newParentNode = this.getNodeByElementNumber(_parentElementNumber);
        List children = this.getChildrenOf(_parentElementNumber);

        hasAnyChild.insert(_parentElementNumber, true);
        newParentNode.parmIsExpanded(true);

        _addedNode.parmParentElementNumber(_parentElementNumber);
        _addedNode.parmSiblingNumber(this.maxChildSiblingNumber(_parentElementNumber) + 1);
        children.addStart(_addedNode.elementNumber());
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupChildrenAfterDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up in-memory representation of the hierarchy.
    /// </summary>
    /// <param name = "_rootNode">
    /// Root node of the hierarchy.
    /// </param>
    /// <returns>
    /// List of the activity numbers that have been deleted.
    /// </returns>
    /// <remarks>
    /// The takes as a precondition that hierarchy was already deleted from the db
    /// by the time method is called.
    /// </remarks>
    public List cleanupChildrenAfterDelete(ProjWBSTreeNode _rootNode)
    {
        List            childrenToDelete = new List(Types::String);
        List            deletedActivites = new List(Types::String);
        Enumerator      childrenToDeleteEnumerator;

        ElementNumber       currentElement;
        smmActivityNumber   currentActivity;

        childrenToDelete = this.getListOfElementNumbersOfSubtreeNodes(_rootNode);
        childrenToDeleteEnumerator = childrenToDelete.getEnumerator();
        childrenToDeleteEnumerator.reset();
        while (childrenToDeleteEnumerator.moveNext())
        {
            currentElement = childrenToDeleteEnumerator.current();
            currentActivity = this.elementNumberToActivityNumber(currentElement);
            deletedActivites.addEnd(currentActivity);
            activityNumberToElementNumber.remove(currentActivity);
            nodes.remove(currentElement);
        }

        return deletedActivites;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupPredecessorsAfterDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up dependencies in memory after deleting hierarchy from memory and DB.
    /// </summary>
    /// <param name = "_impactedNodes">
    /// A set of activities that were impacted by the deletion, i.e. have one or more of the deleted activities as dependencies.
    /// </param>
    /// <param name = "_deletedNodes">
    /// A list of activities that had been deleted.
    /// </param>
    public void cleanupPredecessorsAfterDelete(Set _impactedNodes, List _deletedNodes)
    {
        Enumerator impactedNodesEnumerator  = _impactedNodes.getEnumerator();
        Enumerator deletedNodesEnumerator;

        ProjWBSTreeNode impactedNode;

        while (impactedNodesEnumerator.moveNext())
        {
            impactedNode = this.getNodeByActivityNumber(impactedNodesEnumerator.current());

            if (!impactedNode)
            {
                continue;
            }

            deletedNodesEnumerator = _deletedNodes.getEnumerator();
            while (deletedNodesEnumerator.moveNext())
            {
                impactedNode.parmPredecessors().remove(deletedNodesEnumerator.current());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>elementNumberToActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the activity number that corresponds to the given element number.
    /// </summary>
    /// <param name="_elementNumber">
    /// Element number.
    /// </param>
    /// <returns>
    /// If element exists returns corresponding activity number, otherwise return an empty activity number.
    /// </returns>
    public smmActivityNumber elementNumberToActivityNumber(ElementNumber _elementNumber)
    {
        ProjWBSTreeNode node = this.getNodeByElementNumber(_elementNumber);

        if (node)
        {
            return node.activityNumber();
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandUpToInTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Expands the tree up to the given level.
    /// </summary>
    /// <param name="_level">
    /// The level to expand up to.
    /// </param>
    public void expandUpToInTree(Integer _level)
    {
        MapEnumerator   mEnum;
        ProjWBSTreeNode node;

        if (nodes.empty())
        {
            return;
        }

        mEnum = nodes.getEnumerator();
        while (mEnum.moveNext())
        {
            node = this.getNodeByElementNumber(mEnum.currentKey());
            if (node.parmLevel() < _level)
            {
                node.parmIsExpanded(true);
            }
            else
            if (node.parmLevel() == _level)
            {
                node.parmIsExpanded(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>failIfNotFound</Name>
				<Source><![CDATA[
    private void failIfNotFound(Map _map, str _key)
    {
        Object object = null;
        if (isDebugOn && !_map.exists(_key))
        {
            error(strFmt('%1 not found', _key));
            object.fail();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildrenOf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of children for the given <c>ElementNumber</c> object.
    /// </summary>
    /// <param name="_elementNumber">
    /// The given <c>ElementNumber</c>.
    /// </param>
    /// <returns>
    /// A <c>List</c> of children.
    /// </returns>
    public List getChildrenOf(ElementNumber _elementNumber)
    {
        this.failIfNotFound(childrenOf, _elementNumber);

        if (childrenOf.exists(_elementNumber))
        {
            return childrenOf.lookup(_elementNumber);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getListOfElementNumbersOfSubtreeNodes</Name>
				<Source><![CDATA[
    private List getListOfElementNumbersOfSubtreeNodes(ProjWBSTreeNode _rootNode)
    {
        List        result = new List(Types::String);
        Enumerator  childrenEnumerator;

        result.addStart(_rootNode.elementNumber());
        childrenEnumerator = result.getEnumerator();

        while (childrenEnumerator.moveNext())
        {
            result.appendList(this.getChildrenOf(childrenEnumerator.current()));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodeByActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a node by its activity number.
    /// </summary>
    /// <param name="_activityNumber">
    /// The given <c>smmActivityNumber</c>.
    /// </param>
    /// <returns>
    /// A <c>ProjWBSTreeNode</c>.
    /// </returns>
    public ProjWBSTreeNode getNodeByActivityNumber(smmActivityNumber _activityNumber)
    {
        return this.getNodeByElementNumber(this.activityNumberToElementNumber(_activityNumber));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodeByElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a node by its element number.
    /// </summary>
    /// <param name="_elementNumber">
    /// The given <c>ElementNumber</c>.
    /// </param>
    /// <returns>
    /// A <c>ProjWBSTreeNode</c>.
    /// </returns>
    public ProjWBSTreeNode getNodeByElementNumber(ElementNumber _elementNumber)
    {
        this.failIfNotFound(nodes, _elementNumber);

        if (nodes.exists(_elementNumber))
        {
            return nodes.lookup(_elementNumber);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets map of <c>ElementNumber</c> to <c>ProjWBSTreeNode</c> which contains all tree nodes.
    /// </summary>
    /// <returns>
    /// A <c>Map</c>.
    /// </returns>
    public Map getNodes()
    {
        return nodes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of children.
    /// </summary>
    /// <param name="_elementNumber">
    /// The <c>ElementNumber</c> to find children for.
    /// </param>
    /// <returns>
    /// Number of children.
    /// </returns>
    public int getNumberOfChildren(ElementNumber _elementNumber)
    {
        List children;

        if (isDebugOn && !childrenOf.exists(_elementNumber))
        {
            info('getNumberOfChildren: invalid element number: ' + _elementNumber);
        }

        children = childrenOf.lookup(_elementNumber);

        return children.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentNodeOf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parent node of an element.
    /// </summary>
    /// <param name="_elementNumber">
    /// The <c>ElementNumber</c> to get the parent of.
    /// </param>
    /// <returns>
    /// A <c>ProjWBSTreeNode</c>.
    /// </returns>
    public ProjWBSTreeNode getParentNodeOf(ElementNumber _elementNumber)
    {
        ProjWBSTreeNode node = this.getNodeByElementNumber(_elementNumber);
        if (nodes.exists(node.parmParentElementNumber()))
        {
            return nodes.lookup(node.parmParentElementNumber());
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPath</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>HierarchyPath</c> to the given element.
    /// </summary>
    /// <param name="_elementNumber">
    /// The <c>ElementNumber</c> to get the path for.
    /// </param>
    /// <returns>
    /// A <c>HierarchyPath</c>.
    /// </returns>
    public HierarchyPath getPath(ElementNumber _elementNumber)
    {
        HierarchyTreeTable hierarchyTreeTable;

        select firstOnly Path from hierarchyTreeTable
            where hierarchyTreeTable.ElementNumber == _elementNumber
                  && hierarchyTreeTable.HierarchyId == this.hierarchyId();

        return hierarchyTreeTable.Path;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousSibling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the previous sibling of a node.
    /// </summary>
    /// <param name="_node">
    /// The <c>ProjWBSTreeNode</c> to get the sibling for.
    /// </param>
    /// <returns>
    /// A <c>ProjWBSTreeNode</c>.
    /// </returns>
    public ProjWBSTreeNode getPreviousSibling(ProjWBSTreeNode _node)
    {
        List siblings = this.getSiblingsOf(_node);
        ListEnumerator siblingEnumerator;

        if (!siblings)
        {
            return null;
        }

        siblingEnumerator = siblings.getEnumerator();

        while (siblingEnumerator.moveNext())
        {
            if (siblingEnumerator.current() == _node.elementNumber())
            {
                if (siblingEnumerator.moveNext())
                {
                    return this.getNodeByElementNumber(siblingEnumerator.current());
                }
                break;
            }
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSiblingsOf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the siblings of a node.
    /// </summary>
    /// <param name="_node">
    /// The node to get the siblings for.
    /// </param>
    /// <returns>
    /// A list of siblings.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Invalid element number.
    /// </exception>
    public List getSiblingsOf(ProjWBSTreeNode _node)
    {
        if (childrenOf.exists(_node.parmParentElementNumber()))
        {
            return childrenOf.lookup(_node.parmParentElementNumber());
        }

        if (isDebugOn)
        {
            info('getSiblingsOf: invalid element number: ' + _node.parmParentElementNumber());
            throw error('getSiblingsOf: invalid element number: ' + _node.parmParentElementNumber());
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// test if the element has any children.
    /// </summary>
    /// <param name="_elementNumber">
    /// The tree element for which we determine if it has any children
    /// </param>
    /// <returns>
    /// true if the element has any children, false otherwise
    /// </returns>
    /// <remarks>
    /// Added the condition check to prevent AX from throwing the infolog "not found in the map"
    /// </remarks>

    public boolean hasChildren(ElementNumber _elementNumber)
    {
        this.failIfNotFound(hasAnyChild, _elementNumber);
        //
        if (hasAnyChild.exists(_elementNumber))
        {
            return hasAnyChild.lookup(_elementNumber);
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tree has a node.
    /// </summary>
    /// <param name="_elementNumber">
    /// <c>ElementNumber</c> of the node for which to check.
    /// </param>
    /// <returns>
    /// True if tree has the node; false otherwise.
    /// </returns>
    public boolean hasNode(ElementNumber _elementNumber)
    {
        return nodes.exists(_elementNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hierarchyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets hierarchy ID.
    /// </summary>
    /// <returns>
    /// A <c>HierarchyIdBase</c>.
    /// </returns>
    public HierarchyIdBase hierarchyId()
    {
        return hierarchyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPSAActivitySetupFromProjTable</Name>
				<Source><![CDATA[
    private void initPSAActivitySetupFromProjTable(PSAActivitySetup _psaActivitySetup, ProjTable _projTable)
    {
        _psaActivitySetup.Effort = _projTable.PSASchedEffort;
        _psaActivitySetup.PSASchedStart = _projTable.PSASchedStartDate;
        _psaActivitySetup.PSASchedEnd = _projTable.PSASchedEndDate;
        _psaActivitySetup.ActivityDuration = _projTable.PSASchedDuration;
        _psaActivitySetup.CalendarId = _projTable.PSASchedCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPSAActivitySetupFromSalesQuotTable</Name>
				<Source><![CDATA[
    private void initPSAActivitySetupFromSalesQuotTable(PSAActivitySetup _psaActivitySetup, SalesQuotationTable _salesQuotationTable)
    {
        _psaActivitySetup.PSASchedStart = _salesQuotationTable.PSAEstProjStartDate;
        _psaActivitySetup.PSASchedEnd = _salesQuotationTable.PSAEstProjEndDate;
        _psaActivitySetup.CalendarId = _salesQuotationTable.PSASchedCalendarId;
        _psaActivitySetup.modifiedField(fieldNum(PSAActivitySetup, PSASchedEnd));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNewNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a new node in the tree.
    /// </summary>
    /// <param name="_node">
    /// The node to insert.
    /// </param>
    /// <remarks>
    /// Pre-condition: _node must've already been initialized (e.g. element number, parent element number and sibling number must be set already)
    /// </remarks>
    public void insertNewNode(ProjWBSTreeNode _node)
    {
        List siblings;
        ListIterator listIterator;
        LineNum siblingNumber = _node.parmSiblingNumber();
        ProjWBSTreeNode newParentNode = this.getNodeByElementNumber(_node.parmParentElementNumber());

        hasAnyChild.insert(newParentNode.elementNumber(), true);
        newParentNode.parmIsExpanded(true);

        childrenOf.insert(_node.elementNumber(), new List(Types::String));
        nodes.insert(_node.elementNumber(), _node);
        activityNumberToElementNumber.insert(_node.activityNumber(), _node.elementNumber());
        hasAnyChild.insert(_node.elementNumber(), false);

        siblings = childrenOf.lookup(newParentNode.elementNumber());
        listIterator = new ListIterator(siblings);
        while (listIterator.more() && siblingNumber <= this.getNodeByElementNumber(listIterator.value()).parmSiblingNumber())
        {
            listIterator.next();
        }
        listIterator.insert(_node.elementNumber());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNodeExpanded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a node is expanded.
    /// </summary>
    /// <param name="_elementNumber">
    /// The element to check.
    /// </param>
    /// <returns>
    /// true if it's expanded, false otherwise.
    /// </returns>
    public boolean isNodeExpanded(ElementNumber _elementNumber)
    {
        return this.getNodeByElementNumber(_elementNumber).parmIsExpanded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQuotation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if this is a quotation.
    /// </summary>
    /// <returns>
    /// A boolean.
    /// </returns>
    public boolean isQuotation()
    {
        return isQuotation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the node is a root node.
    /// </summary>
    /// <param name="_elementNumber">
    /// Element number of node to check.
    /// </param>
    /// <returns>
    /// A boolean.
    /// </returns>
    public boolean isRoot(ElementNumber _elementNumber)
    {
        return (_elementNumber == rootElementNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reloads project WBS sub-tree from database into memory.
    /// </summary>
    /// <param name="_hierarchyTreeTable">
    /// Parent hierarchy element of the project tasks that will be reloaded.
    /// Passing null will indicate the entire project WBS must be reloaded.
    /// </param>
    /// <param name="_force">
    /// Whether or not existing in-memory tasks should be purged (true) or preserved (false) having
    /// only new tasks be reloaded.
    /// </param>
    public void loadSubTree(HierarchyTreeTable _hierarchyTreeTable = null, boolean _force = false)
    {
        HierarchyPath path;
        #Characters;

        if (_hierarchyTreeTable)
        {
            path = _hierarchyTreeTable.Path + _hierarchyTreeTable.ElementNumber + #sharp;
        }
        else
        {
            path = "";
        }

        if (_force)
        {
            isTreeFullyLoaded = false;

            if (_hierarchyTreeTable)
            {
                this.setChildrenOf(_hierarchyTreeTable.ElementNumber, new List(Types::String));
            }
            else
            {
                this.setChildrenOf(rootElementNumber, new List(Types::String));
            }

            if (!_hierarchyTreeTable || !_hierarchyTreeTable.ParentElementNumber)
            {
                this.processRoot();
            }

            this.loadTreeFromDatabase(path);
        }
        else if (isNotLoaded.in(_hierarchyTreeTable.ElementNumber))
        {
            this.loadTreeFromDatabase(path);
            isNotLoaded.remove(_hierarchyTreeTable.ElementNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTreeFromDatabase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads a WBS tree from the database.
    /// </summary>
    /// <param name="_subTreePath">
    /// A <c>HierarchyPath</c> of sub tree root which will be loaded from database.
    /// </param>
    /// <param name="shouldLoadFullTree">
    /// If true, full tree is loaded from database.
    /// </param>
    public void loadTreeFromDatabase(HierarchyPath _subTreePath = "", boolean shouldLoadFullTree = true)
    {
        HierarchyTreeTable  hierarchyTreeTable;
        smmActivities       smmActivities;
        PSAActivitySetup    psaActivitySetup;
        ProjActivity        projActivity;
        ProjDependency      projDependency;
        List                children;
        ProjWBSTreeNode     node;
        ProjWBSTreeNode     rootNode;
        HierarchyPath       subTreePathRange = _subTreePath + "*";
        Set                 nodesSet = new Set(Types::String);

        if (isTreeFullyLoaded)
        {
            return;  // If the tree was already fully loaded, there's no need to reload it.
        }
        if (shouldLoadFullTree)
        {
            isTreeFullyLoaded = true;
            isNotLoaded = new Set(Types::String);
            if (!_subTreePath)
            {
                childrenOf = new Map(Types::String, Types::Class);
                activityNumberToElementNumber = new Map(Types::String, Types::String);
            }
        }

        // First pass: create nodes and Map node keys
        while select ElementNumber, Name, ParentElementNumber, SiblingNumber, IsNodeExpanded, Path from hierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == hierarchyId
                  && hierarchyTreeTable.Path like subTreePathRange
            join ActivityNumber from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
                outer join Effort, NumberOfResources, PSASchedStart, PSASchedEnd, ActivityDuration, CostAtComplete, EffortAtComplete from psaActivitySetup
                    where psaActivitySetup.ActivityNumber == smmActivities.ActivityNumber
                outer join CategoryDefault from projActivity
                    where projActivity.ActivityNumber == smmActivities.ActivityNumber
        {
            childrenOf.insert(hierarchyTreeTable.ElementNumber, new List(Types::String));
            activityNumberToElementNumber.insert(smmActivities.ActivityNumber, hierarchyTreeTable.ElementNumber);
            if (!isQuotation)
            {
                categoryId = projActivity.CategoryDefault;
            }
            else
            {
                categoryId = psaActivitySetup.CategoryDefault;
            }

            nodes.insert(hierarchyTreeTable.ElementNumber,
                         new ProjWBSTreeNode(
                            hierarchyTreeTable.ElementNumber,
                            hierarchyTreeTable.ParentElementNumber,
                            hierarchyTreeTable.SiblingNumber,
                            smmActivities.ActivityNumber,
                            hierarchyTreeTable.Path,
                            hierarchyTreeTable.IsNodeExpanded,
                            hierarchyTreeTable.Name,
                            categoryId,
                            psaActivitySetup.Effort,
                            psaActivitySetup.PSASchedStart,
                            psaActivitySetup.PSASchedEnd,
                            psaActivitySetup.ActivityDuration,
                            psaActivitySetup.NumberOfResources,
                            new Set(Types::String),
                            0.0,
                            0.0,
                            psaActivitySetup.CostAtComplete,
                            0.0,
                            psaActivitySetup.EffortAtComplete));
            hasAnyChild.insert(hierarchyTreeTable.ElementNumber, false);

            if (!shouldLoadFullTree && !hierarchyTreeTable.IsNodeExpanded)
            {
                isNotLoaded.add(hierarchyTreeTable.ElementNumber);
            }
        }

        // Override is expanded for root, so it's always expanded
        rootNode = this.getNodeByElementNumber(rootElementNumber);
        if (rootNode)
        {
            rootNode.parmIsExpanded(true);
        }

        // Second pass: insert children mapped to their parents
        while select ElementNumber, ParentElementNumber from hierarchyTreeTable
            order by hierarchyTreeTable.SiblingNumber asc
            where hierarchyTreeTable.HierarchyId == hierarchyId
                  && hierarchyTreeTable.Path like subTreePathRange
            join ActivityNumber from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            outer join ProjDependency
                where ProjDependency.Successor == smmActivities.ActivityNumber
        {
            if (ProjDependency.Predecessor)
            {
                node = nodes.lookup(hierarchyTreeTable.ElementNumber);
                node.parmPredecessors().add(ProjDependency.Predecessor);
            }

            if (nodesSet.in(hierarchyTreeTable.ElementNumber))
            {
                continue;
            }
            else
            {
                nodesSet.add(hierarchyTreeTable.ElementNumber);
            }

            if (hierarchyTreeTable.ParentElementNumber != "")
            {
                hasAnyChild.insert(hierarchyTreeTable.ParentElementNumber, true);
                // If not root and not child of a collapsed node, add it as child of its parent.
                if (shouldLoadFullTree || this.isNodeExpanded(hierarchyTreeTable.ParentElementNumber))
                {
                    children = this.getChildrenOf(hierarchyTreeTable.ParentElementNumber);
                    if (children)
                    {
                        children.addStart(hierarchyTreeTable.ElementNumber);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxChildEndDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum end date for children of the given node.
    /// </summary>
    /// <param name="_node">
    /// The node whose children to check.
    /// </param>
    /// <returns>
    /// A <c>SchedFromDate</c>.
    /// </returns>
    public SchedFromDate maxChildEndDate(ProjWBSTreeNode _node)
    {
        SchedFromDate maxEndDate = dateNull();
        List children = this.getChildrenOf(_node.elementNumber());
        ListEnumerator child;
        ElementNumber childElementNumber;
        ProjWBSTreeNode childNode;

        child = children.getEnumerator();
        while (child.moveNext())
        {
            childElementNumber = child.current();
            childNode = this.getNodeByElementNumber(childElementNumber);
            if (maxEndDate == dateNull())
            {
                maxEndDate = childNode.parmEndDate();  // Initialize current maximum.
            }
            else if (childNode.parmEndDate() > maxEndDate)
            {
                maxEndDate = childNode.parmEndDate();
            }
        }

        return maxEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxChildSiblingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum sibling number of the children of the given node.
    /// </summary>
    /// <param name="_parentElementNumber">
    /// The parent element number.
    /// </param>
    /// <returns>
    /// A <c>LineNum</c>.
    /// </returns>
    public LineNum maxChildSiblingNumber(ElementNumber _parentElementNumber)
    {
        List children = this.getChildrenOf(_parentElementNumber);
        ListEnumerator childEnumerator;
        if (children.elements() > 0)
        {
            childEnumerator = children.getEnumerator();
            childEnumerator.moveNext();
            return this.getNodeByElementNumber(childEnumerator.current()).parmSiblingNumber();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minChildStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the earliest start date of all children nodes.
    /// </summary>
    /// <param name="_node">
    /// The parent node whose children get checked.
    /// </param>
    /// <returns>
    /// A <c>SchedFromDate</c>.
    /// </returns>
    public SchedFromDate minChildStartDate(ProjWBSTreeNode _node)
    {
        SchedFromDate minStartDate = dateNull();
        List children = this.getChildrenOf(_node.elementNumber());
        ListEnumerator child;
        ElementNumber childElementNumber;
        ProjWBSTreeNode childNode;

        child = children.getEnumerator();
        while (child.moveNext())
        {
            childElementNumber = child.current();
            childNode = this.getNodeByElementNumber(childElementNumber);
            if (childNode.parmStartDate() == dateNull())
            {
                continue;
            }

            if (minStartDate == dateNull())
            {
                minStartDate = childNode.parmStartDate();  // Initialize current minimum.
            }
            else if (childNode.parmStartDate() < minStartDate)
            {
                minStartDate = childNode.parmStartDate();
            }
        }

        return minStartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveChildrenFromNodeToNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves children nodes from specified node starting at specified sibling number.
    /// </summary>
    /// <param name="_fromTaskNode">
    /// Node which children are moved from.
    /// </param>
    /// <param name="_toTaskNode">
    /// Node where children are being moved to.
    /// </param>
    /// <param name="_startSiblingNumber">
    /// Sibling number of the child starting from which nodes are moved.
    /// </param>
    /// <returns>
    /// Maximum sibling number of the child of the node that acquires new children before move is performed.
    /// </returns>
    public LineNum moveChildrenFromNodeToNode(ProjWBSTreeNode _fromTaskNode, ProjWBSTreeNode _toTaskNode, LineNum _startSiblingNumber)
    {
        List fromChildren = this.getChildrenOf(_fromTaskNode.elementNumber());
        List toChildren = this.getChildrenOf(_toTaskNode.elementNumber());
        List tmp = new List(Types::Class);
        ListIterator childIterator = new ListIterator(fromChildren);
        ListEnumerator childEnumerator;
        ListEnumerator childNodeEnumerator;
        LineNum maxSibNum = -1;
        LineNum currSibNum;
        ProjWBSTreeNode childNode;
        ProjWBSTreeNode maxSibNumNode;

        if (fromChildren.elements() > 0)
        {
            while (childIterator.more())
            {
                childNode = this.getNodeByElementNumber(childIterator.value());
                if (childNode.parmSiblingNumber() >= _startSiblingNumber)
                {
                    childNode.parmParentElementNumber(_toTaskNode.elementNumber());  // Updating parent element number.
                    tmp.addStart(childNode);
                    childIterator.delete();
                }
                else
                {
                    break;
                }
            }

            if (tmp.elements() > 0)
            {
                hasAnyChild.insert(_toTaskNode.elementNumber(), true);
                _toTaskNode.parmIsExpanded(true);
            }

            if (toChildren.elements() > 0)
            {
                childEnumerator = toChildren.getEnumerator();
                childEnumerator.moveNext();
                maxSibNumNode = this.getNodeByElementNumber(childEnumerator.current());
                maxSibNum = maxSibNumNode.parmSiblingNumber();
            }
            else
            {
                maxSibNum = 0;
            }

            currSibNum = maxSibNum + 1;
            childNodeEnumerator = tmp.getEnumerator();
            while (childNodeEnumerator.moveNext())
            {
                childNode = childNodeEnumerator.current();
                childNode.parmSiblingNumber(currSibNum);
                currSibNum += 1;
                toChildren.addStart(childNode.elementNumber());
            }
        }

        hasAnyChild.insert(_fromTaskNode.elementNumber(), !this.getChildrenOf(_fromTaskNode.elementNumber()).empty());
        hasAnyChild.insert(_toTaskNode.elementNumber(), !this.getChildrenOf(_toTaskNode.elementNumber()).empty());

        return maxSibNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>ProjWBSTree</c>.
    /// </summary>
    /// <param name="_hierarchyId">
    /// The hierarchy ID.
    /// </param>
    /// <param name="_isDebugOn">
    /// A flag for debuging.
    /// </param>
    /// <param name="_forceFullLoad">
    /// A flag for forcing a full tree load.
    /// </param>
    public void new(HierarchyIdBase _hierarchyId, boolean _isDebugOn = false, boolean _forceFullLoad = true)
    {
        hierarchyId = _hierarchyId;
        childrenOf = new Map(Types::String, Types::Class);
        nodes = new Map(Types::String, Types::Class);
        activityNumberToElementNumber = new Map(Types::String, Types::String);
        hasAnyChild = new Map(Types::String, Types::Enum);
        isNotLoaded = new Set(Types::String);
        isDebugOn = _isDebugOn;
        isTreeFullyLoaded = false;

        this.processRoot();
        this.loadTreeFromDatabase("", _forceFullLoad);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRoot</Name>
				<Source><![CDATA[
    private void processRoot()
    {
        HierarchyTreeTable root;
        smmActivities smmActivities;
        PSAActivitySetup psaActivitySetup;
        ProjActivity projActivity;
        ProjTable projTable;
        SalesQuotationTable salesQuotationTable;

        while select firstOnly forUpdate root
            where root.HierarchyId == hierarchyId && root.ParentElementNumber == ""
        {
            rootElementNumber = root.ElementNumber;
            root.IsNodeExpanded = true;  // The root should always start expanded.

            projTable = HierarchyLinkTable::findAssociation(hierarchyId, tableNum(ProjTable));

            if (!projTable)
            {
                salesQuotationTable = HierarchyLinkTable::findAssociation(hierarchyId, tableNum(SalesQuotationTable));
            }

            isQuotation = salesQuotationTable ? true : false;

            // Create PSAActivitySetup record for root, if it doesn't exist already.
            if (!root.RefRecId)
            {
                root.SiblingNumber = 1;
                smmActivities.Category = smmActivityCategory::Task;
                smmActivities.Purpose = root.Name;
                smmActivities.setActivityNum();
                psaActivitySetup.ActivityNumber = smmActivities.ActivityNumber;
                projActivity.ActivityNumber = smmActivities.ActivityNumber;

                if (projTable)
                {
                    this.initPSAActivitySetupFromProjTable(psaActivitySetup, projTable);
                }
                else if (salesQuotationTable)
                {
                    this.initPSAActivitySetupFromSalesQuotTable(psaActivitySetup, salesQuotationTable);
                }

                ttsBegin;
                smmActivities.insert();
                psaActivitySetup.insert();
                projActivity.insert();
                root.RefRecId = smmActivities.RecId;
                root.update();
                ttsCommit;
            }
            else
            {
                select forUpdate firstOnly RecId from psaActivitySetup
                join RecId from smmActivities
                    where smmActivities.ActivityNumber == psaActivitySetup.ActivityNumber
                          && smmActivities.RecId == root.RefRecId;

                ttsBegin;
                root.update();
                ttsCommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pruneSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///  This method allows unloading resources associated with a sub-tree
    ///  when its root is collapsed.
    /// </summary>
    /// <param name="_elementNumber">
    ///  Sub-tree root element number.
    /// </param>
    /// <remarks>
    ///  Kept for extensibility reasons.
    /// </remarks>
    public void pruneSubTree(ElementNumber _elementNumber)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reInsertNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reinserts a node into the tree.
    /// </summary>
    /// <param name="_newParentElementNumber">
    /// The <c>ElementNumber</c> of new parent node.
    /// </param>
    /// <param name="_node">
    /// The node to insert.
    /// </param>
    /// <param name="_afterSiblingNumber">
    /// The sibling number of the sibling after which to insert the node.
    /// </param>
    public void reInsertNode(ElementNumber _newParentElementNumber, ProjWBSTreeNode _node, LineNum _afterSiblingNumber)
    {
        List siblings;
        ListIterator listIterator;
        ProjWBSTreeNode newParentNode = this.getNodeByElementNumber(_newParentElementNumber);
        #Characters;

        if (!this.hasChildren(newParentNode.elementNumber()))
        {
            // New parent will is a leaf task and will become a summary task
            newParentNode.parmNumberOfResources(0);
        }

        hasAnyChild.insert(newParentNode.elementNumber(), true);
        newParentNode.parmIsExpanded(true);

        siblings = childrenOf.lookup(_newParentElementNumber);
        listIterator = new ListIterator(siblings);
        while (listIterator.more() && this.getNodeByElementNumber(listIterator.value()).parmSiblingNumber() > _afterSiblingNumber)
        {
            listIterator.next();
        }
        listIterator.insert(_node.elementNumber());

        _node.parmSiblingNumber(_afterSiblingNumber + 1);
        _node.parmParentElementNumber(newParentNode.elementNumber());
        _node.parmPath(newParentNode.parmPath() + newParentNode.elementNumber() + #sharp);
        _node.parmLevel(newParentNode.parmLevel() + 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeChild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a child from a WBS tree.
    /// </summary>
    /// <param name="_node">
    /// The node to remove.
    /// </param>
    public void removeChild(ProjWBSTreeNode _node)
    {
        ProjWBSTreeNode     parentNode          = this.getParentNodeOf(_node.elementNumber());
        List                siblings            = this.getSiblingsOf(_node);
        ListIterator        listIterator        = new ListIterator(siblings);
        ProjWBSTreeNode     siblingNode;

        if (siblings)
        {
            listIterator = new ListIterator(siblings);

            if (siblings.elements() == 1)
            {
                hasAnyChild.insert(parentNode.elementNumber(), false);
            }

            while (listIterator.more())
            {
                if (listIterator.value() == _node.elementNumber())
                {
                    listIterator.delete();
                    break;
                }

                siblingNode = this.getNodeByElementNumber(listIterator.value());
                siblingNode.parmSiblingNumber(siblingNode.parmSiblingNumber() - 1);

                listIterator.next();
            }

            _node.parmParentElementNumber("");
            isNotLoaded.remove(_node.elementNumber());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rootElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the root element number.
    /// </summary>
    /// <returns>
    /// An <c>ElementNumber</c>.
    /// </returns>
    public ElementNumber rootElementNumber()
    {
        return rootElementNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChildrenOf</Name>
				<Source><![CDATA[
    private void setChildrenOf(ElementNumber _elementNumber, List _children)
    {
        childrenOf.insert(_elementNumber, _children);
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapWithNextSibling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Swaps node with its next sibling.
    /// </summary>
    /// <param name="_node">
    /// The node to swap.
    /// </param>
    /// <returns>
    /// The sibling of the given node.
    /// </returns>
    public ProjWBSTreeNode swapWithNextSibling(ProjWBSTreeNode _node)
    {
        List siblings = this.getSiblingsOf(_node);
        ListIterator listIterator;
        ListEnumerator listEnumerator;
        ElementNumber targetElementNumber = _node.elementNumber();
        ProjWBSTreeNode previousSiblingNode;
        LineNum tmpSiblingNumber;

        listEnumerator = siblings.getEnumerator();
        listIterator = new ListIterator(siblings);

        if (siblings.elements() > 1 && listIterator.value() != targetElementNumber)
        {
            listEnumerator.moveNext();
            while (listEnumerator.moveNext())
            {
                if (listEnumerator.current() == targetElementNumber)
                {
                    previousSiblingNode = this.getNodeByElementNumber(listIterator.value());
                    listIterator.insert(targetElementNumber);  // Insert new copy of target after previous sibling, S.
                    listIterator.next();  // Move to old copy of target.
                    listIterator.delete();  // Delete old copy of target.

                    tmpSiblingNumber = previousSiblingNode.parmSiblingNumber();
                    previousSiblingNode.parmSiblingNumber(_node.parmSiblingNumber());
                    _node.parmSiblingNumber(tmpSiblingNumber);
                    return previousSiblingNode;
                }
                listIterator.next();
            }
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapWithPreviousSibling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Swaps node with its previous sibling.
    /// </summary>
    /// <param name="_node">
    /// The node to swap.
    /// </param>
    /// <returns>
    /// The sibling of the given node.
    /// </returns>
    public ProjWBSTreeNode swapWithPreviousSibling(ProjWBSTreeNode _node)
    {
        List siblings = this.getSiblingsOf(_node);
        ListIterator listIterator;
        ElementNumber targetElementNumber = _node.elementNumber();
        ProjWBSTreeNode nextSiblingNode = null;
        LineNum tmpSiblingNumber;

        listIterator = new ListIterator(siblings);
        if (siblings.elements() > 1)
        {
            while (listIterator.more())
            {
                if (listIterator.value() == targetElementNumber)
                {
                    listIterator.delete();
                    if (listIterator.more())
                    {
                        nextSiblingNode = this.getNodeByElementNumber(listIterator.value());
                        listIterator.next();

                        tmpSiblingNumber = nextSiblingNode.parmSiblingNumber();
                        nextSiblingNode.parmSiblingNumber(_node.parmSiblingNumber());
                        _node.parmSiblingNumber(tmpSiblingNumber);
                    }
                    listIterator.insert(targetElementNumber);
                    break;
                }
                listIterator.next();
            }
        }

        return nextSiblingNode;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>