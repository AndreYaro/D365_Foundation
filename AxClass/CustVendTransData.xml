<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendTransData</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendTransData</c> class contains the base methods for customer and vendor transactions.
/// </summary>
/// <remarks>
/// This class and its inherited functionality provide the ability to inherit tables. See the
/// <c>CustVendStatistics.createCurrencyBalances</c> method for an example.
/// </remarks>
abstract public class CustVendTransData
{
    CustVendTrans custVendTrans;

    CustVendTransStatic custVendTransStatic;

    // these variable are set when using open transaction edit, date principle dialog
    SettleDatePrinc datePrinciple; // enum for type of date to use for exchange rate adj
    TransDate selectedDate; // selected date, only set if datePrinciple equals selected

    BankTransactionTypes bankTransactionTypes;
    boolean isGroupSettlement;

    SalesInvoicePostingType_RU salesInvoicePostingType;

    // <GTE>
    Map taxDocumentLedgerVoucherMap;
    // </GTE>

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amountExchAdj</Name>
				<Source><![CDATA[
    public AmountMST amountExchAdj()
    {
        return (custVendTrans.AmountMST + custVendTrans.ExchAdjustment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountExchAdjReportingCurrency</Name>
				<Source><![CDATA[
    public AmountMST amountExchAdjReportingCurrency()
    {
        return (custVendTrans.ReportingCurrencyAmount + custVendTrans.ExchAdjustmentReporting);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashledgerTransTxt</Name>
				<Source><![CDATA[
    abstract public LedgerTransTxt cashledgerTransTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpForEmptyVouchers</Name>
				<Source><![CDATA[
    private void cleanUpForEmptyVouchers(
        LedgerVoucherGroup _ledgerVoucherGroup,
        CustVendSettle _custVendSettle,
        Voucher _parentVoucher,
        TransDate _parentTransDate)
    {
        LedgerVoucher ledgerVoucher;
        LedgerVoucherList ledgerVoucherList;
        LedgerVoucherObject ledgerVoucherObject;
        CompanyId currentCompany;
        MapEnumerator enumerator;
        Map ledgerVouchers;
        boolean more;
        Set transDateSet;

        if (_custVendSettle.parmIsCashDiscountAdjustedForOverPayment() == false)
        {
            return;
        }

        transDateSet = new Set(Types::Date);

        ledgerVouchers = _ledgerVoucherGroup.getInternalCollection();

        enumerator = ledgerVouchers.getEnumerator();

        // Loop through all the ledger voucher and check if ledger transactions exist.
        // In the settlement scenario when an over payment is for the same amount as the cash discount,
        // the over payment will reverse the entries for the cash discount and net amount of taxTrans will be zero.
        while (enumerator.moveNext())
        {
            ledgerVoucher = enumerator.currentValue();

            currentCompany = ledgerVoucher.parmCompanyId();
            Debug::assert(currentCompany != ''); // this ledgerVoucher is invalid, the addVoucher method should have disallowed this entry

            changecompany(currentCompany)
            {
                ledgerVoucherList = ledgerVoucher.getInternalCollection();

                // loop through all the vouchers in a company
                more = ledgerVoucherList.first();

                while (more)
                {
                    ledgerVoucherObject = ledgerVoucherList.item();

                    TaxCashDisc::deleteTaxOnCashDiscountTrans(ledgerVoucherObject.parmSubledgerVoucher(), ledgerVoucherObject.parmAccountingDate());

                    more = ledgerVoucherList.next();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReverseTrans_RU</Name>
				<Source><![CDATA[
    public CustVendTrans createReverseTrans_RU(LedgerVoucher _ledgerVoucher,
                                               InventProfileType_RU _inventProfileType)
    {
        CustVendTrans custVendReverseTrans;
        return custVendReverseTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendInvoiceJour_RU</Name>
				<Source><![CDATA[
    abstract public CustVendInvoiceJour custVendInvoiceJour_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTable</Name>
				<Source><![CDATA[
    abstract CustVendTable custVendTable(boolean _forUpdate = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPostingProfile</Name>
				<Source><![CDATA[
    abstract public PostingProfile defaultPostingProfile()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>existInvoice</Name>
				<Source><![CDATA[
    abstract public boolean existInvoice()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastUnrealExchAdjTrans_W</Name>
				<Source><![CDATA[
    public CustVendTrans findLastUnrealExchAdjTrans_W(TransDate _transDate, CustVendTransSettlement _custVendTranSettlement)
    {
        CustVendTrans savedExchRateTrans = this.parmCustVendTransStatic().custVendTrans();
        CustVendTrans exchRateTrans = this.parmCustVendTransStatic().custVendTrans();

        void selectLastExchAdj()
        {
            select firstonly exchRateTrans
                order by TransDate desc, Correct
                where exchRateTrans.OffsetRecId == custVendTrans.RecId
                 && (exchRateTrans.TransType == LedgerTransType::ExchAdjustment
                 || exchRateTrans.TransType == LedgerTransType::AdvanceAdjustment_RU)
                 && exchRateTrans.TransDate <= _transDate
                 && exchRateTrans.LastExchAdj == exchRateTrans.TransDate
                 && !exchRateTrans.LastExchAdjVoucher
                 && ((exchRateTrans.ExchAdjustmentUnrealized
                 && !exchRateTrans.LastExchAdjRate)
                 || (exchRateTrans.ReportingExchAdjustmentUnrealized
                 && !exchRateTrans.LastExchAdjRateReporting));
        }

        selectLastExchAdj();
        savedExchRateTrans.data(exchRateTrans);

        if (_custVendTranSettlement)
        {
            exchRateTrans = _custVendTranSettlement.getCustVendTransTmp_W(custVendTrans);
            selectLastExchAdj();

            if (savedExchRateTrans.TransDate != exchRateTrans.TransDate)
            {
                return savedExchRateTrans.TransDate > exchRateTrans.TransDate ? savedExchRateTrans : exchRateTrans;
            }

            return savedExchRateTrans.Correct <= exchRateTrans.Correct ? savedExchRateTrans : exchRateTrans;
        }

        return exchRateTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymModeTable</Name>
				<Source><![CDATA[
    public abstract CustVendPaymModeTable findPaymModeTable(boolean _forUpdate = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleDate</Name>
				<Source><![CDATA[
    abstract public TransDate getSettleDate(LedgerJournalTrans ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnrealizedParameters_W</Name>
				<Source><![CDATA[
    abstract public container getUnrealizedParameters_W(CreatedTransactionId _createdTransactionId, TransDate _previousUnrealizedDate = dateNull())
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvanceInvoice_W</Name>
				<Source><![CDATA[
    public boolean isAdvanceInvoice_W()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrepaymentConverted_W</Name>
				<Source><![CDATA[
    public boolean isPrepaymentConverted_W()
    {
        boolean ret;
        CustVendTransPostingLog_RU custVendTransPostingLog;
        CustVendTrans custVendTransLocal
        ;
        if (custVendTrans.Prepayment)
        {
            select firstonly OffSetRecId, RecId from custVendTransPostingLog index hint TransIdx
                where custVendTransPostingLog.TransRecId == custVendTrans.RecId &&
                      custVendTransPostingLog.RefTableId == custVendTrans.TableId &&
                      custVendTransPostingLog.PostingLogType == CustVendTransPostingLogType_RU::Prepayment;

            if (custVendTransPostingLog.RecId)
            {
                ret = true;
            }
            else
            {
                custVendTransLocal = this.parmCustVendTransStatic().custVendTrans();
                select firstonly custVendTransLocal
                    where custVendTransLocal.AccountNum == custVendTrans.AccountNum &&
                          custVendTransLocal.TransDate == custVendTrans.TransDate &&
                          custVendTransLocal.Voucher == custVendTrans.Voucher &&
                          custVendTransLocal.Correct != custVendTrans.Correct;

                if (custVendTransLocal.RecId)
                {
                    select firstonly OffSetRecId, RecId from custVendTransPostingLog index hint TransIdx
                        where custVendTransPostingLog.TransRecId == custVendTransLocal.RecId &&
                              custVendTransPostingLog.RefTableId == custVendTransLocal.TableId &&
                              custVendTransPostingLog.PostingLogType == CustVendTransPostingLogType_RU::Prepayment;

                    if (custVendTransPostingLog.RecId)
                    {
                        ret = true;
                    }
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapReversedAmounts_RU</Name>
				<Source><![CDATA[
    public container mapReversedAmounts_RU()
    {
        Map map = new Map(Types::Date, Types::Container);
        Map periodMap = new Map(Types::Container, Types::Container);
        Set dateSet = new Set(Types::Date);
        SetEnumerator dateEnumerator;
        MapEnumerator periodEnumerator;
        CustVendSettlement custVendSettlementMain,custVendSettlementReversed;
        TransDate dateTo,dateFrom;
        AmountCur amountCur, tmpAmountCur;
        AmountMST amountMST, tmpAmountMST;
        #ISOCountryRegionCodes
        ;

        changecompany(custVendTrans.company())
        {
            if (! TaxParameters::find().ReverseSettlementDatePrinciple_W
             && ! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                return map.pack();
            }

            custVendSettlementMain = this.parmCustVendTransStatic().custVendSettlement();
            custVendSettlementReversed = custVendSettlementMain.data();

            while select TransDate, SettleAmountCur, SettleAmountMST from custVendSettlementReversed
                where custVendSettlementReversed.ReverseTrans_RU == NoYes::Yes &&
                            custVendSettlementReversed.TransRecId == custVendTrans.RecId
            join TransDate from custVendSettlementMain
                where custVendSettlementMain.TransRecId == custVendTrans.RecId &&
                            custVendSettlementReversed.ReversedRecId_RU == custVendSettlementMain.RecId &&
                            custVendSettlementReversed.RecId == custVendSettlementMain.ReversedRecId_RU
            {
                periodMap.insert([ custVendSettlementMain.TransDate,
                                   custVendSettlementReversed.TransDate,
                                   custVendSettlementMain.RecId],
                                 [ custVendSettlementReversed.SettleAmountCur,
                                   custVendSettlementReversed.SettleAmountMST ]);
                dateSet.add(custVendSettlementMain.TransDate);
                dateSet.add(custVendSettlementReversed.TransDate);
            }
            dateEnumerator = dateSet.getEnumerator();
            periodEnumerator = periodMap.getEnumerator();
            while (dateEnumerator.moveNext())
            {
                periodEnumerator.reset();
                amountCur = 0;
                amountMST = 0;

                while (periodEnumerator.moveNext())
                {
                    [ dateFrom, dateTo ] = periodEnumerator.currentKey();
                    if (dateEnumerator.current() > dateFrom &&
                        dateEnumerator.current() <= dateTo)
                    {
                        [ tmpAmountCur, tmpAmountMST ] = periodEnumerator.currentValue();
                        amountCur += tmpAmountCur;
                        amountMST += tmpAmountMST;
                    }
                }
                if (amountCur)
                {
                    map.insert(dateEnumerator.current(), [ amountCur, amountMST ]);
                }
            }
        }

        return map.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapReversedAmountsCur_RU</Name>
				<Source><![CDATA[
    public container mapReversedAmountsCur_RU()
    {
        Map map = new Map(Types::Date,Types::Real);
        Map periodMap = new Map(Types::Container,Types::Real);
        Set dateSet = new Set(Types::Date);
        SetEnumerator setEnumerator;
        MapEnumerator mapEnumerator;
        CustVendSettlement custVendSettlementMain,custVendSettlementReversed;
        TransDate dateTo,dateFrom;
        AmountCur amountCur;
        #ISOCountryRegionCodes
        ;

        changecompany(custVendTrans.company())
        {
            if (! TaxParameters::find().ReverseSettlementDatePrinciple_W
             && ! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                return map.pack();
            }

            custVendSettlementMain = this.parmCustVendTransStatic().custVendSettlement();
            custVendSettlementReversed = custVendSettlementMain.data();

            while select TransDate,SettleAmountCur from custVendSettlementReversed
                where custVendSettlementReversed.ReverseTrans_RU == NoYes::Yes &&
                      custVendSettlementReversed.TransRecId == custVendTrans.RecId
            join TransDate from custVendSettlementMain
                where custVendSettlementMain.TransRecId == custVendTrans.RecId &&
                      custVendSettlementReversed.ReversedRecId_RU == custVendSettlementMain.RecId &&
                      custVendSettlementReversed.RecId == custVendSettlementMain.ReversedRecId_RU
            {
                periodMap.insert([custVendSettlementMain.TransDate,custVendSettlementReversed.TransDate, custVendSettlementMain.RecId],custVendSettlementReversed.SettleAmountCur);
                dateSet.add(custVendSettlementMain.TransDate);
                dateSet.add(custVendSettlementReversed.TransDate);
            }
            setEnumerator = dateSet.getEnumerator();
            mapEnumerator = periodMap.getEnumerator();
            while (setEnumerator.moveNext())
            {
                mapEnumerator.reset();
                amountCur = 0;
                while (mapEnumerator.moveNext())
                {
                    [dateFrom,dateTo] = mapEnumerator.currentKey();
                    if (setEnumerator.current() > dateFrom &&
                        setEnumerator.current() <= dateTo)
                    {
                        amountCur += mapEnumerator.currentValue();
                    }
                }
                if (amountCur)
                {
                    map.insert(setEnumerator.current(),amountCur);
                }
            }
        }

        return map.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markForSettlement</Name>
				<Source><![CDATA[
    void markForSettlement(Common _settleWithCommon)
    {
        CustVendTransOpen custVendTransOpen = this.parmCustVendTransStatic().custVendTransOpen();
        SpecTransManager specTransManager;

        specTransManager = SpecTransManager::newFromSpec(_settleWithCommon);

        while select custVendTransOpen
            where custVendTransOpen.RefRecId == custVendTrans.RecId
        {
            if (specTransManager.exist(custVendTransOpen.DataAreaId, custVendTransOpen.TableId, custVendTransOpen.RecId) == false)
            {
                specTransManager.insert(custVendTransOpen.DataAreaId, custVendTransOpen.TableId, custVendTransOpen.RecId, custVendTransOpen.remainAmountCashDisc(), custVendTrans.CurrencyCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxDueDate</Name>
				<Source><![CDATA[
    public DueDate maxDueDate()
    {
        CustVendTransOpen custVendTransOpen = this.parmCustVendTransStatic().custVendTransOpen();
        CustVendSettlement custVendSettlement;
        DueDate dueDate;

        select count(RecId), maxof(DueDate)
            from custVendTransOpen
            where custVendTransOpen.RefRecId == custVendTrans.RecId;

        if (custVendTransOpen.RecId)
        {
            dueDate = custVendTransOpen.DueDate;
        }
        else
        {
            custVendSettlement = this.parmCustVendTransStatic().custVendSettlement();

            select maxof(DueDate) from custVendSettlement
                        where custVendSettlement.TransRecId == custVendTrans.RecId;

            dueDate = custVendSettlement.DueDate;
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxSettlementDate</Name>
				<Source><![CDATA[
    public TransDate maxSettlementDate(TransDate _transDate = dateNull())
    {
        CustVendSettlement custVendSettlement = this.parmCustVendTransStatic().custVendSettlement();

        if (custVendTrans.RecId)
        {
            select maxof(TransDate) from custVendSettlement
                where custVendSettlement.TransRecId == custVendTrans.RecId
                    && custVendSettlement.CanBeReversed == NoYes::Yes;
        }

        return max(custVendSettlement.TransDate, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxSettlementDate_W</Name>
				<Source><![CDATA[
    public TransDate maxSettlementDate_W(TransDate _transDate = dateNull())
    {
        CustVendSettlement custVendSettlement = this.parmCustVendTransStatic().custVendSettlement();

        if (custVendTrans.RecId)
        {
            select maxof(TransDate) from custVendSettlement
                where custVendSettlement.TransRecId == custVendTrans.RecId && custVendSettlement.CanBeReversed;
        }

        return max(custVendSettlement.TransDate, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>originalPaymTrans_RU</Name>
				<Source><![CDATA[
    public CustVendTrans originalPaymTrans_RU(boolean _checkJournal = true,
                                              CustVendTrans _custVendTrans = custVendTrans)
    {
        CustVendTransPostingLog_RU custVendTransPostingLog;
        CustVendTrans custVendTransLocal, originalTrans;
        Originaldocuments originaldocuments = Originaldocuments::construct(custVendTrans);
        if (_checkJournal)
        {
            if (custVendTrans.TableId == tableNum(CustTrans))
            {
                originaldocuments.findFromCustTrans();
            }
            else
            {
                originaldocuments.findFromVendTrans();
            }

            if (originaldocuments.numTrans_RU())
            {
                return custVendTrans;
            }
        }

        select firstonly OffSetRecId, RecId from custVendTransPostingLog index hint TransIdx
            where custVendTransPostingLog.TransRecId == custVendTrans.RecId &&
                  custVendTransPostingLog.RefTableId == custVendTrans.TableId &&
                  custVendTransPostingLog.PostingLogType == CustVendTransPostingLogType_RU::Prepayment;

        if (! custVendTransPostingLog.RecId)
        {
            custVendTransLocal = this.parmCustVendTransStatic().custVendTrans();
            select firstonly custVendTransLocal
                where custVendTransLocal.AccountNum == custVendTrans.AccountNum &&
                      custVendTransLocal.TransDate == custVendTrans.TransDate &&
                      custVendTransLocal.Voucher == custVendTrans.Voucher &&
                      custVendTransLocal.Correct != custVendTrans.Correct;

            if (! custVendTransLocal.RecId)
            {
                return custVendTrans;
            }
        }
        else
        {
            if (custVendTrans.TableId == tableNum(CustTrans))
            {
                custVendTransLocal = CustTrans::find(custVendTransPostingLog.OffSetRecId);
            }
            else
            {
                custVendTransLocal = VendTrans::find(custVendTransPostingLog.OffSetRecId);
            }
        }

        if (_custVendTrans.RecId != custVendTransLocal.RecId)
        {
            originalTrans = CustVendTransData::construct(custVendTransLocal).originalPaymTrans_RU(_checkJournal,custVendTrans);
        }
        else
        {
            originalTrans = custVendTrans;
        }

        return originalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankTransactionTypes</Name>
				<Source><![CDATA[
    public BankTransactionTypes parmBankTransactionTypes(BankTransactionTypes _bankTransactionTypes = bankTransactionTypes)
    {
        bankTransactionTypes = _bankTransactionTypes;

        return bankTransactionTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTrans</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTrans(CustVendTrans _custVendTrans = custVendTrans)
    {
        custVendTrans = _custVendTrans;

        return custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransStatic</Name>
				<Source><![CDATA[
    public CustVendTransStatic parmCustVendTransStatic(CustVendTransStatic _custVendTransStatic = custVendTransStatic)
    {
        custVendTransStatic = _custVendTransStatic;

        if (!custVendTransStatic)
            custVendTransStatic = CustVendTransStatic::newTrans(custVendTrans);

        return custVendTransStatic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDatePrinciple</Name>
				<Source><![CDATA[
    public SettleDatePrinc parmDatePrinciple(SettleDatePrinc _datePrinciple = datePrinciple)
    {
        datePrinciple = _datePrinciple;

        return datePrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsGroupSettlement_W</Name>
				<Source><![CDATA[
    public boolean parmIsGroupSettlement_W(boolean _isGroupSettlement = isGroupSettlement)
    {
        isGroupSettlement = _isGroupSettlement;

        return isGroupSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesInvoicePostingType_RU</Name>
				<Source><![CDATA[
    SalesInvoicePostingType_RU parmSalesInvoicePostingType_RU(SalesInvoicePostingType_RU _salesInvoicePostingType = salesInvoicePostingType)
    {
        salesInvoicePostingType = _salesInvoicePostingType;
        return salesInvoicePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectedDate</Name>
				<Source><![CDATA[
    public TransDate parmSelectedDate(TransDate _selectedDate = selectedDate)
    {
        selectedDate = _selectedDate;

        return selectedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainAmountCur</Name>
				<Source><![CDATA[
    public AmountCur remainAmountCur()
    {
        return custVendTrans.AmountCur - custVendTrans.SettleAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainAmountMST</Name>
				<Source><![CDATA[
    public AmountMST remainAmountMST()
    {
        AmountMST remainAmountMST;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        ;
        // <GEERU>
        if (custVendTrans.TransType == LedgerTransType::ExchAdjustment
            || (countryRegion_RU
                && custVendTrans.TransType == LedgerTransType::AdvanceAdjustment_RU))
        // </GEERU>
        {
            remainAmountMST = custVendTrans.AmountMST - custVendTrans.SettleAmountMST;
        }
        else
        {
            remainAmountMST = custVendTrans.AmountMST + custVendTrans.ExchAdjustment - custVendTrans.SettleAmountMST;
        }

        return remainAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainAmountReportingCurrency</Name>
				<Source><![CDATA[
    public AmountMSTSecondary remainAmountReportingCurrency()
    {
        AmountMSTSecondary remainAmountReportingCurrency;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        
        // <GEERU>
        if (custVendTrans.TransType == LedgerTransType::ExchAdjustment
            || (countryRegion_RU
                && custVendTrans.TransType == LedgerTransType::AdvanceAdjustment_RU))
        // </GEERU>
        {
            remainAmountReportingCurrency = custVendTrans.ReportingCurrencyAmount - custVendTrans.SettleAmountReporting;
        }
        else
        {
            remainAmountReportingCurrency = custVendTrans.ReportingCurrencyAmount + custVendTrans.ExchAdjustmentReporting - custVendTrans.SettleAmountReporting;
        }

        return remainAmountReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleTax1099</Name>
				<Source><![CDATA[
    protected void settleTax1099(CustVendSettlement _custVendSettlement,
                                 CustVendTrans _origTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogSettlementTxt</Name>
				<Source><![CDATA[
    abstract public TransTxt transactionLogSettlementTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogSettlementType</Name>
				<Source><![CDATA[
    abstract public TransactionLogType transactionLogSettlementType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDisc</Name>
				<Source><![CDATA[
    public CustVendTrans updateCashDisc(PaymTermId _paymTermId,
                                        LedgerVoucher _ledgerVoucher,
                                        LedgerPostingType _ledgerPostingType,
                                        DiscAmount _possibleCashDisc,
                                        CashDiscdate _cashDiscdate)
    {
        PaymTerm paymTerm = PaymTerm::find(_paymTermId);
        CustVendTrans custVendTransCashDisc = custVendTrans.data();
        TransactionTxt transactionTxt = TransactionTxt::construct();
        LedgerVoucherTransObject ledgerPostingTransaction;
        Common custTransLocal;
        Common vendTransLocal;

        LedgerDimensionAccount ledgerDimensionMerged;
        CurrencyExchangeHelper exchangeRateHelper;

        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        LedgerBondClient_RU ledgerBondClient;

        if (countryRegion_RU
            && _ledgerVoucher
            && _ledgerVoucher.findLedgerVoucherObject())
        {
            ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        }
        // </GEERU>

        if (paymTerm.CashLedgerDimension)
        {
            custVendTransCashDisc.DocumentNum = '';
            custVendTransCashDisc.DocumentDate = dateNull();
            custVendTransCashDisc.Invoice = '';
            custVendTransCashDisc.euroTriangulation = custVendTrans.euroTriangulation;
            custVendTransCashDisc.AmountCur = -custVendTrans.AmountCur;

            // Get a new voucher number for the cash transfer
            NumberSeq numberSeq;
            Num voucher;

            if (custVendTrans.TableId == tableNum(CustTrans))
            {
                numberSeq = NumberSeq::newGetVoucher(CustParameters::numRefCustPaymVoucher());
            }
            else
            {
                numberSeq = NumberSeq::newGetVoucher(VendParameters::numRefVendPaymentVoucher());
            }

            voucher = numberSeq.voucher();

            // Create the LedgerVoucherObject for the cash transfer
            _ledgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(voucher,
                                                                     custVendTrans.TransDate,
                                                                     this.parmCustVendTransStatic().sysModule(),
                                                                     custVendTrans.TransType));

            custVendTransCashDisc.Voucher = voucher;
            custVendTransCashDisc.AccountingEvent = 0;

            transactionTxt.setType(this.cashledgerTransTxt());
            transactionTxt.setVoucher(custVendTrans.Voucher);
            transactionTxt.setFormLetter(custVendTrans.Invoice);
            transactionTxt.setLanguage(custVendTrans.languageId());

            if (TransactionTextContext::isTypeSupported(this.cashledgerTransTxt()))
            {
                TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(this.cashledgerTransTxt());

                switch (this.cashledgerTransTxt())
                {
                    case LedgerTransTxt::CustCashPayment:
                        custTransLocal = custVendTransCashDisc;
                        transactionTextContext.setTableBuffer(custTransLocal as CustTrans);
                        break;
                    case LedgerTransTxt::VendCashPayment:
                        vendTransLocal = custVendTransCashDisc;
                        transactionTextContext.setTableBuffer(vendTransLocal as VendTrans);
                        break;
                }

                transactionTextContext.setTableBuffer(paymTerm);
                transactionTxt.setTransactionTextContext(transactionTextContext);
            }

            custVendTrans.Txt = transactionTxt.txt();
            custVendTransCashDisc.Txt = custVendTrans.Txt;

            if (_possibleCashDisc && _cashDiscdate >= custVendTrans.TransDate)
            {
                custVendTransCashDisc.AmountCur += _possibleCashDisc;
            }

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
            // </GEERU>

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(custVendTrans.summaryLedgerDimension(), custVendTrans.DefaultDimension);
            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(custVendTrans.ExchRate);
            exchangeRateHelper.parmExchangeRate2(custVendTrans.ExchRateSecond);
            custVendTrans.setExchangeHelperReportingExchRate(exchangeRateHelper);

            ledgerPostingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                _ledgerVoucher.findLedgerVoucherObject(),
                _ledgerPostingType,
                ledgerDimensionMerged,
                custVendTrans.CurrencyCode,
                custVendTransCashDisc.AmountCur,
                exchangeRateHelper);

            ledgerPostingTransaction.parmSourceRecId(custVendTrans.RecId);
            ledgerPostingTransaction.parmSourceTableId(custVendTrans.TableId);
            ledgerPostingTransaction.parmText(custVendTrans.Txt);

            _ledgerVoucher.addTrans(ledgerPostingTransaction);

            custVendTransCashDisc.AmountMST = ledgerPostingTransaction.parmAccountingCurrencyAmount();
            custVendTransCashDisc.ExchRate = custVendTrans.ExchRate;
            custVendTransCashDisc.ExchRateSecond = custVendTrans.ExchRateSecond;

            custVendTransCashDisc.ReportingCurrencyAmount = ledgerPostingTransaction.parmReportingCurrencyAmount();
            custVendTransCashDisc.ReportingCurrencyExchRate = custVendTrans.ReportingCurrencyExchRate;
            custVendTransCashDisc.ReportingCurrencyExchRateSecondary = custVendTrans.ReportingCurrencyExchRateSecondary;
            custVendTransCashDisc.ReportingCurrencyCrossRate = custVendTrans.ReportingCurrencyCrossRate;

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(paymTerm.CashLedgerDimension, custVendTrans.DefaultDimension);

            ledgerPostingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                _ledgerVoucher.findLedgerVoucherObject(),
                LedgerPostingType::LedgerJournal,
                ledgerDimensionMerged,
                custVendTrans.CurrencyCode,
                -custVendTransCashDisc.AmountCur,
                exchangeRateHelper);

            ledgerPostingTransaction.parmSourceRecId(custVendTrans.RecId);
            ledgerPostingTransaction.parmSourceTableId(custVendTrans.TableId);

            _ledgerVoucher.addTrans(ledgerPostingTransaction);

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
                ledgerBondClient.removeCurrentLogObject();
            }
            // </GEERU>
            
            // Update approved field to Yes for vendor payment transactions for invoice register
            // when payment is 'COD' and cash is 'Yes'

            if (paymTerm.PaymMethod == NetCurrent::COD
                && paymTerm.Cash == NoYes::Yes
                && LedgerJournalTable::find(_ledgerVoucher.parmJournalNumber()).JournalType == LedgerJournalType::PurchaseLedger)
            {
                custVendTransCashDisc.Approved = NoYes::Yes;
            }

            custVendTransCashDisc.insert();

            if (custVendTransCashDisc.TableId == tableNum(CustTrans))
            {
                CustTransIdRef::insertForCustTrans(custVendTransCashDisc, custVendTransCashDisc.Voucher, CustTransRefType::Other);
            }
        }
        else
        {
            custVendTransCashDisc.RecId = 0;
        }

        return custVendTransCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEmplAccount_RU</Name>
				<Source><![CDATA[
    public CustVendTrans updateEmplAccount_RU(LedgerVoucher _ledgerVoucher,
                                              LedgerPostingType _ledgerPostingType,
                                              DiscAmount _possibleCashDisc,
                                              CashDiscdate _cashDiscdate,
                                              EmplAccount_RU _emplAccount,
                                              PostingProfile _emplPostingProfile,
                                              ExchRate _exchRate,
                                              ExchrateSecondary _exchrateSecondary,
                                              boolean _postToGeneralLedger = true
                                              )
    {
        CustVendTrans custVendTransEmpl;
        return custVendTransEmpl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOffsetVoucher</Name>
				<Source><![CDATA[
    public void updateOffsetVoucher(
        SettlementType _settleVoucher,
        LedgerVoucher _parentLedgerVoucher,
        Common _offsetVoucherTable,
        boolean _balancePostingProfile = true
        ,DimSettlementType_RU _dimSettlementType = DimSettlementType_RU::None
        ,CustTrans _parentCustTrans = null
        )
    {
        #ISOCountryRegionCodes

        OffsetVoucher offsetVoucher;
        CustVendSettle custVendSettle;
        LedgerVoucherGroup ledgerVoucherGroup;
        LedgerVoucher settlementLedgerVoucher;
        LedgerJournalTrans ledgerJournalTransLoc;

        ledgerJournalTransLoc = _offsetVoucherTable as LedgerJournalTrans;
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        offsetVoucher = OffsetVoucher::construct(this.parmCustVendTransStatic().sysModule(),
                                                 _settleVoucher,
                                                 _offsetVoucherTable);
        // <GEERU>
        if (countryRegion_RU)
        {
            offsetVoucher.parmDimSettlementType_RU(_dimSettlementType);
        }
        // </GEERU>

        // Perform auto settlement
        offsetVoucher.updateNow(custVendTrans, _settleVoucher);

        ledgerVoucherGroup = LedgerVoucherGroup::construct();

        SysModule sysModule = this.parmCustVendTransStatic().sysModule();
        // <GEERU>
        if (countryRegion_RU &&
            sysModule == SysModule::Vend &&
            SpecTrans::existMarkedCurrencyDeal_RU(_offsetVoucherTable.company(), _offsetVoucherTable.TableId, _offsetVoucherTable.RecId))
        {
            custVendSettle = CustVendSettle::constructCurrencyDeal_RU(sysModule,
                                                                      offsetVoucher,
                                                                      ledgerVoucherGroup);
        }
        else
        // </GEERU>
        if (SpecTrans::existMarkedPayment(_offsetVoucherTable.company(), _offsetVoucherTable.TableId, _offsetVoucherTable.RecId))
        {
            custVendSettle = CustVendSettle::constructPayment(sysModule,
                                                              offsetVoucher,
                                                              ledgerVoucherGroup);
        }
        else
        {
            custVendSettle = CustVendSettle::newOffsetVoucher(sysModule,
                                                              offsetVoucher,
                                                              ledgerVoucherGroup);
        }
        // Set the datePrinciple and saveDate variables before calling settleNow.
        // These variables are set if coming from open transaction edit, and will have
        // default value when coming from payment posting.
        // <GEERU>
        if (countryRegion_RU)
        {
            custVendSettle.parmParentLedgerVoucher_RU(_parentLedgerVoucher);
        }
        else
        {
        // </GEERU>
            custVendSettle.datePrinciple(datePrinciple);
            custVendSettle.saveDate(selectedDate);

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                custVendSettle.parmBankTransactionTypes(bankTransactionTypes);
            }

        // <GEERU>
        }
        // </GEERU>

        if (_parentLedgerVoucher)
        {
            custVendSettle.parmRelatedJournalId(_parentLedgerVoucher.parmLedgerJournalId());
            custVendSettle.parmRelatedLedgerVoucher(_parentLedgerVoucher);
        }

        // <GIN>
        if (_parentCustTrans && TaxParameters::isServiceTaxEnable_IN())
        {
            custVendSettle.parmParentCustTrans_IN(_parentCustTrans);
        }
        // </GIN>

        if (TaxWithholdParameters_IN::needReverseTDSForVendor())
        {
            custVendSettle.parmOffsetTableId(_offsetVoucherTable.TableId);
        }

        custVendSettle.settleNow(_offsetVoucherTable.company(), _offsetVoucherTable.TableId, _offsetVoucherTable.RecId, _balancePostingProfile);
        if (!ledgerJournalTransLoc.Cancel)
        {
            // validate and post the ledger voucher group
            ledgerVoucherGroup.end();

            this.updateBudgetForCashDiscounts_PSN(ledgerVoucherGroup);

            if (countryRegion_RU)
            {
                CustVendSettlePostingLog_RU::createTransLink(custVendSettle.parmReversePostingLogSet_RU());
            }

            // Create transaction log records for cross company settlement
            ledgerVoucherGroup.createTransactionLog(this.transactionLogSettlementType(), this.transactionLogSettlementTxt());

            // if the _parentLedgerVoucher was passed is not null this means that this settlement is being done in the
            // same database transactions as the some other transaction, and these transaction must be linked.
            // The _parentLedgerVoucher is null this means that the settlement is not being done as part of a larger
            // transaction, this is not an error.
            if (_parentLedgerVoucher != null)
            {
                settlementLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(curext(), custVendSettle.findNumberSequenceCodeByCompany(curext()));

                if (settlementLedgerVoucher != null)
                {
                    settlementLedgerVoucher.createVoucherLinks(_parentLedgerVoucher.lastVoucher(), _parentLedgerVoucher.lastTransDate());

                    this.cleanUpForEmptyVouchers(ledgerVoucherGroup, custVendSettle, _parentLedgerVoucher.lastVoucher(), _parentLedgerVoucher.lastTransDate());

                    this.updateRelatedTaxBookSection_IT(_parentLedgerVoucher);
                }
            }
            else
            {
                this.cleanUpForEmptyVouchers(ledgerVoucherGroup, custVendSettle, '', dateNull());
            }
        }
        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxDocumentLedgerVoucherMap = custVendSettle.getTaxDocumentLedgerVoucherMap();
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedTaxBookSection_IT</Name>
				<Source><![CDATA[
    public void updateRelatedTaxBookSection_IT(LedgerVoucher _parentLedgerVoucher)
    {
        #ISOCountryRegionCodes

        TaxTrans taxTrans;
        LedgerTransVoucherLink ledgerTransVoucherLink;
        TaxBookSection taxBookSection;
        TaxBook taxBook;
        recId voucherGroupId;
        Voucher voucher;
        TransDate transDate;

        voucher = _parentLedgerVoucher.lastVoucher();
        transDate = _parentLedgerVoucher.lastTransDate();

        voucherGroupId = LedgerTransVoucherLink::findVoucherGroupId(voucher, transDate);

        //Determines, if TaxTrans records to update exist.
        //Normally, there are no records for settlement transactions. In this case no update required and, consequently, voucher number validation is not needed.
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && !TaxIntegrationUtils::isMultipleTaxIdEnabled())
        {
            select firstonly RecId from taxTrans
                exists join ledgerTransVoucherLink
                    where ledgerTransVoucherLink.VoucherGroupId == voucherGroupId
                       && ledgerTransVoucherLink.Voucher == taxTrans.Voucher
                       && ledgerTransVoucherLink.TransDate == taxTrans.TransDate;
        }
        else if (MultipleTaxIdReportingHelper::existsAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            while select TaxCode from taxTrans
                exists join ledgerTransVoucherLink
                    where ledgerTransVoucherLink.VoucherGroupId == voucherGroupId
                       && ledgerTransVoucherLink.Voucher == taxTrans.Voucher
                       && ledgerTransVoucherLink.TransDate == taxTrans.TransDate
            {
                if (MultipleTaxIdReportingHelper::isTaxCodeInCountryRegion(
                    taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration))
                {
                    break;
                }
            }

        }

        if (taxTrans.RecId != 0)
        {
            ttsbegin;

            taxBookSection = TaxBookSection::findVoucherSeries(
                            NumberSequenceTable::findByNaturalKey(_parentLedgerVoucher.parmVoucherSeriesCode()).RecId);
            taxBook = TaxBook::find(taxBookSection.TaxBook);

            if (taxBookSection && taxBook)
            {
                if (! TaxBookSection::checkTaxBookSection(taxBookSection.NumberSequenceTable, transDate, voucher))
                {
                    throw error("@SYS21533");
                }

                update_recordset taxTrans
                setting TaxBook = taxBook.RecId,
                        TaxBookSection = taxBookSection.RecId,
                        TaxPeriod = taxBook.TaxPeriod
                exists join ledgerTransVoucherLink
                    where ledgerTransVoucherLink.VoucherGroupId == voucherGroupId
                       && ledgerTransVoucherLink.Voucher == taxTrans.Voucher
                       && ledgerTransVoucherLink.TransDate == taxTrans.TransDate;
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettlement</Name>
				<Source><![CDATA[
    public CustVendSettlement updateSettlement(
        CustVendTransOpen _custVendTransOpen,
        DiscAmount _utilizedCashDisc = 0,
        PennyDiff _pennyDiff = 0,
        NoYes _canBeReversed = NoYes::No,
        boolean _setOffsetRecId = false,
        boolean _update = false,
        DimensionDefault _cashDiscDimension = custVendTrans.DefaultDimension,
        TransDate _settleDate = max(custVendTrans.TransDate, custVendTrans.LastExchAdj),
        Voucher _taxVoucher = '',
        RecId _offsetRecId = 0)
    {
        // <GEERU><GEECZ>
        #ISOCountryRegionCodes
        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        // </GEECZ></GEERU>

        CustVendTrans this_Orig = custVendTrans.orig();
        CustVendSettlement custVendSettlement = this.parmCustVendTransStatic().custVendSettlement();
        boolean insertRecord = false;
        // <GBR>
        LedgerJournalTransPayment_BR ledgerTransPayment_BR;
        SpecTrans specTransLoc;
        // </GBR>

        ttsbegin;

        if (_update)
        {
            select forupdate firstonly custVendSettlement
            order by RecId desc
            where custVendSettlement.TransRecId == custVendTrans.RecId &&
                  custVendSettlement.OffsetRecId == custVendTrans.OffsetRecId &&
                  custVendSettlement.OffsetCompany == custVendTrans.LastSettleCompany;

            if (custVendSettlement.RecId)
            {
                custVendSettlement.SettleAmountMST += custVendTrans.SettleAmountMST- this_Orig.SettleAmountMST;
                custVendSettlement.SettleAmountCur += custVendTrans.SettleAmountCur- this_Orig.SettleAmountCur;
                custVendSettlement.SettleAmountReporting += custVendTrans.SettleAmountReporting- this_Orig.SettleAmountReporting;
                custVendSettlement.UtilizedCashDisc += _utilizedCashDisc;
                custVendSettlement.PennyDiff += _pennyDiff;
                custVendSettlement.ExchAdjustment += custVendTrans.ExchAdjustment - this_Orig.ExchAdjustment;
                custVendSettlement.ExchAdjustmentReporting += custVendTrans.ExchAdjustmentReporting - this_Orig.ExchAdjustmentReporting;
                this.settleTax1099(custVendSettlement, this_Orig);
                // <GEERU><GEECZ>
                if (countryRegion_RUCZ
                    && _taxVoucher)
                {
                    custVendSettlement.TaxVoucher_RU = _taxVoucher;
                }
                // </GEECZ></GEERU>
                custVendSettlement.update();
            }
        }
        else
        {
            insertRecord = false;
            custVendSettlement.clear();

            if (custVendTrans.ExchAdjustment != this_Orig.ExchAdjustment
                || custVendTrans.ExchAdjustmentReporting != this_Orig.ExchAdjustmentReporting)
            {
                custVendSettlement.AccountNum = custVendTrans.AccountNum;
                custVendSettlement.OffsetCompany = custVendTrans.LastSettleCompany;
                custVendSettlement.OffsetAccountNum = custVendTrans.LastSettleAccountNum;
                custVendSettlement.OffsetTransVoucher = custVendTrans.LastSettleVoucher;
                custVendSettlement.TransDate = _settleDate;
                custVendSettlement.TransRecId = custVendTrans.RecId;
                custVendSettlement.TransOpen = _custVendTransOpen.RecId;
                custVendSettlement.TransType = custVendTrans.TransType;
                custVendSettlement.ExchAdjustment = custVendTrans.ExchAdjustment - this_Orig.ExchAdjustment;
                custVendSettlement.ExchAdjustmentReporting = custVendTrans.ExchAdjustmentReporting - this_Orig.ExchAdjustmentReporting;
                custVendSettlement.DueDate = _custVendTransOpen.DueDate;
                insertRecord = true;
            }

            if (custVendTrans.SettleAmountMST != this_Orig.SettleAmountMST
                || custVendTrans.SettleAmountCur != this_Orig.SettleAmountCur
                || custVendTrans.SettleAmountReporting != this_Orig.SettleAmountReporting
                || _utilizedCashDisc != 0)
            {
                custVendSettlement.AccountNum = custVendTrans.AccountNum;
                custVendSettlement.OffsetCompany = custVendTrans.LastSettleCompany;
                custVendSettlement.OffsetAccountNum = custVendTrans.LastSettleAccountNum;
                custVendSettlement.OffsetTransVoucher = custVendTrans.LastSettleVoucher;
                // <GEERU><GEECZ>
                if (countryRegion_RUCZ)
                {
                    custVendSettlement.OffsetRecId = _setOffsetRecId ? (_offsetRecId ? _offsetRecId : custVendTrans.OffsetRecId) : 0;
                }
                else
                {
                // </GEECZ></GEERU>
                    custVendSettlement.OffsetRecId = _setOffsetRecId ? custVendTrans.OffsetRecId : 0; //custVendSettlement.SettleAmountCur ? this.offsetRecid : 0;
                // <GEERU>
                }
                // </GEERU>
                custVendSettlement.TransDate = max(custVendTrans.TransDate, custVendTrans.LastSettleDate);
                custVendSettlement.TransRecId = custVendTrans.RecId;
                custVendSettlement.TransOpen = _custVendTransOpen.RecId;
                custVendSettlement.TransType = custVendTrans.TransType;
                custVendSettlement.SettleAmountMST = custVendTrans.SettleAmountMST - this_Orig.SettleAmountMST;
                custVendSettlement.SettleAmountCur = custVendTrans.SettleAmountCur - this_Orig.SettleAmountCur;
                custVendSettlement.SettleAmountReporting = custVendTrans.SettleAmountReporting - this_Orig.SettleAmountReporting;
                custVendSettlement.UtilizedCashDisc = _utilizedCashDisc;
                custVendSettlement.PennyDiff = _pennyDiff;
                custVendSettlement.CashDiscDate = _custVendTransOpen.CashDiscDate;
                custVendSettlement.DueDate = _custVendTransOpen.DueDate;
                custVendSettlement.LastInterestDate = _custVendTransOpen.LastInterestDate;
                custVendSettlement.CanBeReversed = _canBeReversed;
                custVendSettlement.CashDiscountLedgerDimension = _custVendTransOpen.CashDiscountLedgerDimension;

                if (_canBeReversed && (_utilizedCashDisc != 0))
                {
                    custVendSettlement.DefaultDimension = _cashDiscDimension;
                }
                // <GEERU><GEECZ>
                if (countryRegion_RUCZ)
                {
                    custVendSettlement.TaxVoucher_RU = _taxVoucher;
                }
                // </GEECZ></GEERU>

                insertRecord = true;
            }
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                select crosscompany specTransLoc
                where specTransLoc.SpecTableId == tablenum(LedgerJournalTrans) &&
                       specTransLoc.RefCompany == _custVendTransOpen.company() &&
                       specTransLoc.RefTableId == _custVendTransOpen.TableId &&
                       specTransLoc.RefRecId == _custVendTransOpen.RecId &&
                       specTransLoc.Payment == NoYes::No;

                if (specTransLoc)
                {
                    changecompany(specTransLoc.SpecCompany)
                    {
                        ledgerTransPayment_BR = LedgerJournalTransPayment_BR::find(specTransLoc.SpecRecId);
                    }
                }

                custVendSettlement.InterestAmount_BR = (ledgerTransPayment_BR && ledgerTransPayment_BR.FinInterestAmountCur_BR) ? _custVendTransOpen.InterestAmountPaymCur_BR : 0;
                custVendSettlement.FineAmount_BR = (ledgerTransPayment_BR && ledgerTransPayment_BR.FineAmountCur_BR) ? _custVendTransOpen.FineAmountPaymCur_BR : 0;
                custVendSettlement.InterestCode_BR = _custVendTransOpen.InterestCode_BR;
                custVendSettlement.FineCode_BR = _custVendTransOpen.FineCode_BR;
            }
            // </GBR>

            // <GEERU><GEECZ>
            if ((!countryRegion_RUCZ
                    && insertRecord)
                ||(countryRegion_RUCZ
                    && insertRecord
                    && !isGroupSettlement))
            // </GEECZ></GEERU>
            {
                custVendSettlement.insert();
            }
        }
        ttscommit;

        // <GEERU>
        return custVendSettlement;
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWithCustVendSettlement</Name>
				<Source><![CDATA[
    public void updateWithCustVendSettlement(
        CustVendSettlement _custVendSettlement,
        TransDate _settleDate)
    {
        CustVendTrans this_Orig = custVendTrans.orig();
        CustVendSettlement custVendSettlement = this.parmCustVendTransStatic().custVendSettlement();

        ttsbegin;

        custVendSettlement.clear();

        if (custVendTrans.ExchAdjustment != this_Orig.ExchAdjustment
            || custVendTrans.ExchAdjustmentReporting != this_Orig.ExchAdjustmentReporting)
        {
            custVendSettlement.AccountNum = custVendTrans.AccountNum;
            custVendSettlement.OffsetCompany = custVendTrans.LastSettleCompany;
            custVendSettlement.OffsetAccountNum = custVendTrans.LastSettleAccountNum;
            custVendSettlement.OffsetTransVoucher = custVendTrans.LastSettleVoucher;
            custVendSettlement.TransDate = _settleDate;
            custVendSettlement.TransRecId = custVendTrans.RecId;
            custVendSettlement.ExchAdjustment = custVendTrans.ExchAdjustment - this_Orig.ExchAdjustment;
            custVendSettlement.ExchAdjustmentReporting = custVendTrans.ExchAdjustmentReporting - this_Orig.ExchAdjustmentReporting;
            custVendSettlement.DueDate = _custVendSettlement.DueDate;
        }

        if (custVendTrans.SettleAmountMST != this_Orig.SettleAmountMST ||
            custVendTrans.SettleAmountCur != this_Orig.SettleAmountCur ||
            custVendTrans.SettleAmountReporting != this_Orig.SettleAmountReporting ||
            !custVendSettlement.AccountNum)
        {
            custVendSettlement.AccountNum = custVendTrans.AccountNum;
            custVendSettlement.OffsetCompany = custVendTrans.LastSettleCompany;
            custVendSettlement.OffsetAccountNum = custVendTrans.LastSettleAccountNum;
            custVendSettlement.OffsetTransVoucher = custVendTrans.LastSettleVoucher;
            custVendSettlement.TransDate = max(custVendTrans.TransDate, custVendTrans.LastSettleDate);
            custVendSettlement.TransRecId = custVendTrans.RecId;
            custVendSettlement.SettleAmountMST = custVendTrans.SettleAmountMST- this_Orig.SettleAmountMST;
            custVendSettlement.SettleAmountCur = custVendTrans.SettleAmountCur- this_Orig.SettleAmountCur;
            custVendSettlement.SettleAmountReporting = custVendTrans.SettleAmountReporting- this_Orig.SettleAmountReporting;

            custVendSettlement.CashDiscDate = _custVendSettlement.CashDiscDate;
            custVendSettlement.DueDate = _custVendSettlement.DueDate;
            custVendSettlement.LastInterestDate = _custVendSettlement.LastInterestDate;
            custVendSettlement.CashDiscountLedgerDimension = _custVendSettlement.CashDiscountLedgerDimension;
        }

        custVendSettlement.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendTransData construct(CustVendTrans _custVendTrans)
    {
        CustVendTransData custVendTransData;

        switch (_custVendTrans.TableId)
        {
            case tableNum(CustTrans) :
                custVendTransData = new CustTransData();
                break;

            case tableNum(VendTrans) :
                custVendTransData = new VendTransData();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        custVendTransData.parmCustVendTrans(_custVendTrans);

        return custVendTransData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedInvoiceLookup</Name>
				<Source><![CDATA[
    public static void correctedInvoiceLookup(FormStringControl _ctrl,
                                                     Common _callerTable,
                                                     CustVendAC _custVendAccount,
                                                     LedgerJournalACType _custVendAccountType)
    {
        Args args;
        Object formRun;
        args = new Args();
        args.name(formStr(CustVendCreditInvoicingLookup));
        formRun = classfactory.formRunClass(args);
        formRun.custVendAccount(_custVendAccount);
        formRun.custVendAccountType(_custVendAccountType);
        formRun.parmCallerTable(_callerTable);
        formRun.init();
        _ctrl.performFormLookup(formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetForCashDiscounts_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Base method for updating the budget for <c>CashDisc</c> records.
    /// </summary>
    /// <param name="_ledgerVoucherGroup">
    /// The <c>LedgerVoucherGroup</c> object that contains the transactions to process for budget control.
    /// </param>
    protected void updateBudgetForCashDiscounts_PSN(LedgerVoucherGroup _ledgerVoucherGroup)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDocumentLedgerVoucherMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax document ledger voucher map.
    /// </summary>
    /// <returns>Tax document ledger voucher map.</returns>
    public Map getTaxDocumentLedgerVoucherMap()
    {
        return taxDocumentLedgerVoucherMap;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>