<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailAttributeHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder;

/// <summary>
/// The <c>RetailAttributeHelper</c> class is a helper class
/// that contains method for looking up attribute related records,
/// opening rich attributes editing forms etc.
/// </summary>
public class RetailAttributeHelper
{

    #define.DefaultAttributeTypeName('DefaultStringType')

    public const str AttributeDefinitionRecIdKey = 'AttributeRecId';
    public const str AttributeDefinitionNameKey = 'AttributeName';
    public const str AttributeDefinitionTypeRecIdKey = 'AttributeTypeRecId';
    public const str AttributeDefinitionTypeKey = 'AttributeType';
    public const str AttributeDefinitionTypeBoundedRecIdKey = 'AttributeTypeBoundedRecId';
    public const str AttributeDefinitionIsFixedListKey = 'IsFixedList';
    public const str AttributeDefinitionIsMultiValuesKey = 'IsMultiValues';
    public const str AttributeDefinitionDefaultTextValueKey = 'DefaultTextValue';
    public const str AttributeDefinitionDefaultBooleanValueKey = 'DefaultBooleanValue';
    public const str AttributeDefinitionDefaultDateTimeValueKey = 'DefaultDateTimeValue';
    public const str AttributeDefinitionDefaultFloatValueKey = 'DefaultFloatValue';
    public const str AttributeDefinitionDefaultIntValueKey = 'DefaultIntValue';
    public const str AttributeDefinitionLowerBoundIntValueKey = 'LowerBoundIntValue';
    public const str AttributeDefinitionUpperBoundIntValueKey = 'UpperBoundIntValue';
    public const str AttributeDefinitionLowerBoundFloatValueKey = 'LowerBoundFloatValue';
    public const str AttributeDefinitionUpperBoundFloatValueKey = 'UpperBoundFloatValue';
    public const str AttributeDefinitionLowerBoundDateTimeValueKey = 'LowerBoundDateTimeValue';
    public const str AttributeDefinitionUpperBoundDateTimeValueKey = 'UpperBoundDateTimeValue';
    public const str AttributeDefinitionEnumerationValuesKey = 'AttrEnumerations';
    public const str AttributeDefinitionUoMRecIdKey = 'UnitOfMeasureRecId';
    public const str AttributeDefinitionUoMSymbolKey = 'UnitOfMeasureSymbol';
    public const str AttributeValueRecIdKey = 'AttributeValueRecId';
    public const str AttributeValueTextKey = 'TextValue';
    public const str AttributeValueBooleanKey = 'BooleanValue';
    public const str AttributeValueIntKey = 'IntValue';
    public const str AttributeValueDecimalKey = 'DecimalValue';
    public const str AttributeValueDateTimeKey = 'DateTimeValue';
    public const str AttributeValuesKey = 'AttributeValues';
    public const str AttrEnumDefinitionOrdinalNumberKey = 'EnumOrdinalNumber';
    public const str AttrEnumDefinitionTextValueKey = 'EnumTextValue';
    public const str InsertionRecordsKey = 'InsertionRecords';
    public const str RemovalRecordsKey = 'RemovalRecords';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createDefaultAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates an attribute value for the supplied attribute,
    /// with the attribute linked to an entity through the supplied
    /// instance table record id.
    /// The optional attribute group parameter is used to determine the
    /// default value, if it needs to be created.
    /// </summary>
    /// <param name="_instanceValueRecId">
    /// The records id of the linking table, that links the
    /// supplied attribute and some entity, for which the value
    /// is being looked up.
    /// </param>
    /// <param name="_attribute">
    /// The attribute to find or create a value for.
    /// </param>
    /// <param name="_attributeGroupAttribute">
    /// Optional. The <c>EcoResAttributeGroupAttribute</c> record
    /// to take the default value from, if set.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The attribute value.
    /// </returns>
    public static EcoResValue createDefaultAttributeValue(
        RecId _instanceValueRecId,
        EcoResAttribute _attribute,
        EcoResAttributeGroupAttribute _attributeGroupAttribute = null,
        boolean _forUpdate = false)
    {
        EcoResAttributeValue ecoResAttributeValue;

        // default from attribute group or attribute default
        ecoResAttributeValue = EcoResAttributeValue::findOrCreateDefault(
            _instanceValueRecId,
            _attribute.RecId,
            _attributeGroupAttribute);

        return EcoResValue::find(ecoResAttributeValue.Value, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editHtmlAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>RetailRichText</c> form for the supplied
    /// attribute value.
    /// </summary>
    /// <param name="_caller">
    /// The calling form.
    /// </param>
    /// <param name="_textValue">
    /// The attribute to open the form for.
    /// </param>
    /// <param name="_callerFormControl">
    /// Optional. The control whose datasource to refresh upon updates to the attribute value.
    /// </param>
    public static void editHtmlAttributeValue(FormRun _caller, EcoResTextValue _textValue, FormControl _callerFormControl = null)
    {
        Args                args;
        FormRun             formRun;

        // Open the RetailRichTextAttributeValue form
        args = new Args();
        args.name(formStr(RetailRichTextAttributeValue));
        args.caller(_caller);
        args.callerFormControl(_callerFormControl);
        args.record(_textValue);
        if (_caller.inViewMode())
        {
            args.openMode(OpenMode::View);
        }

        formRun = classfactory.formRunClass(args);

        if (formRun)
        {
            formRun.run();
            formRun.wait();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>editMediaAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>RetailRichText</c> form for the supplied
    /// attribute value.
    /// </summary>
    /// <param name="_caller">
    /// The calling form.
    /// </param>
    /// <param name="_textValue">
    /// The attribute to open the form for.
    /// </param>
    /// <param name="_mediaType">
    /// The rich media type of the supplied attribute.
    /// </param>
    /// <param name="_urlTemplateMap">
    /// Expanded url template map.
    /// </param>
    public static void editMediaAttributeValue(FormRun _caller, EcoResTextValue _textValue, RetailRichMediaType _mediaType, Map _urlTemplateMap = null)
    {
        Args                args;
        FormRun             formRun;

        // Open the RetailRichMediaAttributeValue form
        args = new Args();
        args.name(formStr(RetailRichMediaAttributeValue));
        args.caller(_caller);
        args.record(_textValue);
        args.parmEnumType(enumnum(RetailRichMediaType));
        args.parmEnum(_mediaType);

        args.parmObject(_urlTemplateMap);

        if (_caller.inViewMode())
        {
            args.openMode(OpenMode::View);
        }

        formRun = classfactory.formRunClass(args);

        if (formRun)
        {
            formRun.run();
            formRun.wait();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates an attribute value of the supplied attribute type,
    /// with the attribute linked to some entity through the supplied
    /// instance table record id.
    /// The attribute group parameter is used to look for the attribute of the supplied type in,
    /// and to determine the default value, if attribute needs to be created.
    ///
    /// Note the method will not create a value if it could not find an attribute
    /// of the specified type in the specified group! An exception will be thrown in this case.
    /// </summary>
    /// <param name="_instanceValueRecId">
    /// The records id of the linking table, that links the
    /// supplied attribute and some entity, for which the value
    /// is being looked up.
    /// </param>
    /// <param name="_attributeGroupRecId">
    /// The <c>EcoResAttributeGroup</c> record id of the attribute group
    /// to look the attribute in or create in. It is also used to determine the default value for
    /// the attribute.
    /// </param>
    /// <param name="_attributeTypeRecId">
    /// The attribute type of the attribute to find or create a value for.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The attribute value.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an exception if the method could not find an attribute
    /// of the specified type in the specified group.
    /// </exception>
    public static EcoResValue findOrCreateAttributeValue(
        RecId _instanceValueRecId,
        RecId _attributeGroupRecId,
        RecId _attributeTypeRecId,
        boolean _forUpdate = false)
    {
        EcoResValue attributeValue;
        EcoResAttribute ecoResAttribute =
            RetailAttributeHelper::getSingleAttributeInGroupByType(_attributeGroupRecId, _attributeTypeRecId);
        EcoResAttributeGroupAttribute ecoResAttributeGroupAttribute;

        if (!ecoResAttribute)
        {
            // The attribute must exist before calling the method
            throw error("@RET490147");
        }

        select ecoResAttributeGroupAttribute
            where ecoResAttributeGroupAttribute.AttributeGroup == _attributeGroupRecId
                && ecoResAttributeGroupAttribute.Attribute == ecoResAttribute.RecId;

        attributeValue =
                RetailAttributeHelper::createDefaultAttributeValue(
                    _instanceValueRecId,
                    ecoResAttribute,
                    ecoResAttributeGroupAttribute,
                    _forUpdate);

        return attributeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultTextValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns text attribute value for attribute group.
    /// </summary>
    /// <param name="_attributeGroupRecId">
    /// The attribute group record Id.
    /// </param>
    /// <param name="_ecoResAttributeTypeRecId">
    /// The attribute type record Id.
    /// </param>
    /// <returns>
    /// Text value if found.
    /// </returns>
    public static AttributeValueText getDefaultTextValue(RefRecId _attributeGroupRecId, RefRecId _ecoResAttributeTypeRecId)
    {
        EcoResAttribute ecoResAttribute = RetailAttributeHelper::getSingleAttributeInGroupByType(_attributeGroupRecId, _ecoResAttributeTypeRecId);
        EcoResAttributeGroupAttribute   ecoResAttributeGroupAttribute;

        ecoResAttributeGroupAttribute = EcoResAttributeGroupAttribute::findByGroupAndAttribute(_attributeGroupRecId, ecoResAttribute.RecId);

        return EcoResTextValue::find(ecoResAttributeGroupAttribute.DefaultValue).TextValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultTextValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the text attribute value for attribute group.
    /// </summary>
    /// <param name="_attributeGroupRecId">
    /// The attribute group record Id.
    /// </param>
    /// <param name="_ecoResAttributeTypeRecId">
    /// The attribute type record Id.
    /// </param>
    /// <param name="_attributeValue">
    /// The text attribute value.
    /// </param>
    public static void setDefaultTextValue(RefRecId _attributeGroupRecId, RefRecId _ecoResAttributeTypeRecId, str _attributeValue)
    {
        EcoResAttribute ecoResAttribute = RetailAttributeHelper::getSingleAttributeInGroupByType(_attributeGroupRecId, _ecoResAttributeTypeRecId);
        EcoResAttributeGroupAttribute   ecoResAttributeGroupAttribute;

        ecoResAttributeGroupAttribute = EcoResAttributeGroupAttribute::findByGroupAndAttribute(_attributeGroupRecId, ecoResAttribute.RecId);

        EcoResTextValue ecoResValue = EcoResTextValue::find(ecoResAttributeGroupAttribute.DefaultValue, true);
        if (ecoResValue)
        {
            ttsbegin;

            ecoResValue.TextValue = _attributeValue;
            ecoResValue.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRichMediaType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rich media type by attribute type.
    /// </summary>
    /// <param name="_attributeTypeRecId">
    /// Rec ID of attribute type.
    /// </param>
    /// <returns>
    /// The rich media type.
    /// </returns>
    public static RetailRichMediaType getRichMediaType(RecId _attributeTypeRecId)
    {
        RetailSharedParameters retailSharedParameters;

        if (!_attributeTypeRecId)
        {
            return RetailRichMediaType::None;
        }

        retailSharedParameters = RetailSharedParameters::find();

        switch (_attributeTypeRecId)
        {
            case retailSharedParameters.HtmlAttributeType:
                return RetailRichMediaType::Html;
            case retailSharedParameters.ImagesAttributeType:
                return RetailRichMediaType::Images;
            case retailSharedParameters.VideosAttributeType:
                return RetailRichMediaType::Videos;
            default:
                return RetailRichMediaType::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSingleAttributeInGroupByType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Looks for an attribute of the specified type within the specified group.
    /// If no or more than one attribute is found with the above criteria,
    /// the method returns an empty buffer.
    /// </summary>
    /// <param name="_attributeGroupRecId">
    /// The record id of the attribute group for the attribute beign looked up.
    /// </param>
    /// <param name="_attributeTypeRecId">
    /// The record id of the attribute type for the attribute beign looked up.
    /// </param>
    /// <returns>
    /// The attribute of the specified type within the specified group.
    /// </returns>
    public static EcoResAttribute getSingleAttributeInGroupByType(RefRecId _attributeGroupRecId, RefRecId _attributeTypeRecId)
    {
        EcoResAttributeGroup ecoResAttributeGroup;
        EcoResAttributeGroupAttribute ecoResAttributeGroupAttribute;
        EcoResAttribute ecoResAttribute;
        EcoResAttribute result;

        if (_attributeGroupRecId && _attributeTypeRecId)
        {
            select firstOnly10 ecoResAttribute
                where ecoResAttribute.AttributeType == _attributeTypeRecId
                exists join ecoResAttributeGroupAttribute
                where ecoResAttributeGroupAttribute.Attribute == ecoResAttribute.RecId
                    exists join ecoResAttributeGroup
                    where ecoResAttributeGroup.RecId == ecoResAttributeGroupAttribute.AttributeGroup
                        && ecoResAttributeGroup.RecId == _attributeGroupRecId;
            if (ecoResAttribute)
            {
                result.data(ecoResAttribute);
                next ecoResAttribute;
                if (ecoResAttribute)
                    result.clear();
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStandardAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves standard attribute value for a product.
    /// </summary>
    /// <param name="_standardAttributeID">
    /// Identifier of the standard attribute.
    /// </param>
    /// <param name="_product">
    /// Identifier of the product.
    /// </param>
    /// <param name="_internalOrg">
    /// Identifier of the internal org.
    /// </param>
    /// <param name="_catalog">
    /// Identifier of the catalog.
    /// </param>
    /// <returns>
    /// The value of the standard attribute for the product.
    /// </returns>
    public static AttributeValueText getStandardAttributeValue(RetailStandardAttributeID _standardAttributeID, RefRecId _product, RefRecId _internalOrg = 0, RefRecId _catalog = 0)
    {
        EcoResProductVariantColor ecoResProductVariantColor;
        EcoResProductVariantSize ecoResProductVariantSize;
        EcoResProductVariantStyle ecoResProductVariantStyle;
        EcoResProductVariantConfiguration ecoResProductVariantConfig;
        EcoResColor ecoResColor;
        EcoResSize ecoResSize;
        EcoResStyle ecoResStyle;
        EcoResConfiguration ecoResConfig;

        RetailCatalogProductCategoryAllCurrent allCatalogProductCategory;
        EcoResCategory category;
        EcoResProductCategory productCategory;
        RetailInternalOrganization internalOrg;
        EcoResCategoryHierarchyRole categoryHierarchyRole;

        str categories;

        switch (_standardAttributeID)
        {
            case RetailStandardAttributeID::ProductNumber:
                return EcoResProduct::find(_product).DisplayProductNumber;

            case RetailStandardAttributeID::ProductName:
                return EcoResProductTranslation::findByProductLanguage(_product, SystemParameters::getSystemLanguageId()).Name;

            case RetailStandardAttributeID::SearchName:
                return EcoResProduct::find(_product).SearchName;

            case RetailStandardAttributeID::Description:
                return EcoResProductTranslation::findByProductLanguage(_product, SystemParameters::getSystemLanguageId()).Description;

            case RetailStandardAttributeID::Color:
                select Name from ecoResColor
                    exists join ecoResProductVariantColor
                        where ecoResProductVariantColor.Color == ecoResColor.RecId
                           && ecoResProductVariantColor.DistinctProductVariant == _product;
                return ecoResColor.Name;

            case RetailStandardAttributeID::Style:
                select Name from ecoResStyle
                    exists join ecoResProductVariantStyle
                        where ecoResProductVariantStyle.Style == ecoResStyle.RecId
                           && ecoResProductVariantStyle.DistinctProductVariant == _product;
                return ecoResStyle.Name;

            case RetailStandardAttributeID::Size:
                select Name from ecoResSize
                    exists join ecoResProductVariantSize
                        where ecoResProductVariantSize.Size == ecoResSize.RecId
                           && ecoResProductVariantSize.DistinctProductVariant == _product;
                return ecoResSize.Name;

            case RetailStandardAttributeID::Config:
                select Name from ecoResConfig
                    exists join ecoResProductVariantConfig
                        where ecoResProductVariantConfig.Configuration == ecoResConfig.RecId
                           && ecoResProductVariantConfig.DistinctProductVariant == _product;
                return ecoResConfig.Name;

            case RetailStandardAttributeID::SalesTaxGroup:
                return InventTableModule::find(InventTable::findByProduct(_product).ItemId, ModuleInventPurchSales::Sales).TaxItemGroupId;

            case RetailStandardAttributeID::NavigationCategory:
                categories = '';
                if (_internalOrg == 0 && _catalog == 0)
                {
                    // Product
                    while select Name from category
                        exists join productCategory
                            where productCategory.Category == category.RecId
                                && productCategory.Product == _product
                        exists join categoryHierarchyRole
                            where categoryHierarchyRole.CategoryHierarchy == productCategory.CategoryHierarchy
                                && categoryHierarchyRole.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::RetailChannelNavigation
                    {
                        categories = categories + category.Name + ';';
                    }
                }

                if (_internalOrg != 0 && _catalog == 0)
                {
                    // Internal org
                    while select Name from category
                        exists join productCategory
                            where productCategory.Category == category.RecId
                                && productCategory.Product == _product
                        exists join internalOrg
                            where internalOrg.CategoryHierarchy == productCategory.CategoryHierarchy
                                && internalOrg.RecId == _internalOrg
                    {
                        categories = categories + category.Name + ';';
                    }
                }

                if (_internalOrg == 0 && _catalog != 0)
                {
                    // Shared attribute
                    while select Name from category
                        exists join allCatalogProductCategory
                            where allCatalogProductCategory.Category == category.RecId
                                && allCatalogProductCategory.Product == _product
                                && allCatalogProductCategory.Catalog == _catalog
                        exists join categoryHierarchyRole
                            where categoryHierarchyRole.CategoryHierarchy == allCatalogProductCategory.CategoryHierarchy
                                && categoryHierarchyRole.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::RetailChannelNavigation
                    {
                        categories = categories + category.Name + ';';
                    }
                }

                if (_internalOrg != 0 && _catalog != 0)
                {
                    // Catalog
                    while select Name from category
                        exists join allCatalogProductCategory
                            where allCatalogProductCategory.Category == category.RecId
                                && allCatalogProductCategory.Product == _product
                                && allCatalogProductCategory.Catalog == _catalog
                        exists join internalOrg
                            where internalOrg.CategoryHierarchy == allCatalogProductCategory.CategoryHierarchy
                                && internalOrg.RecId == _internalOrg
                    {
                        categories = categories + category.Name + ';';
                    }
                }

                if (categories != '')
                {
                    return subStr(categories, 1, strLen(categories) - 1);
                }

                return '';
            
            case RetailStandardAttributeID::None:
                return '';
            
            default:
                EventHandlerResult result = new EventHandlerResult();
                RetailAttributeHelper::getStandardAttributeValueDelegate(_standardAttributeID, _product, _internalOrg, _catalog, result);
                if (result.hasResult())
                {
                    return result.result();
                }
                else
                {
                    return '';
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStandardAttributeValueDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to retrieve standard attribute value for a product.
    /// </summary>
    /// <param name="_standardAttributeID">Identifier of the standard attribute.</param>
    /// <param name="_product">Identifier of the product.</param>
    /// <param name="_internalOrg">Identifier of the internal org.</param>
    /// <param name="_catalog">Identifier of the catalog.</param>
    /// <param name = "_result">Subscribers can use this to provide the result.</param>
    static delegate void getStandardAttributeValueDelegate(RetailStandardAttributeID _standardAttributeID,
        RefRecId _product,
        RefRecId _internalOrg,
        RefRecId _catalog,
        EventHandlerResult _result)
    {
        // Subscriber will provide proper implementation to this method
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStandardAttributeValueTranslation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves standard attribute value for a product.
    /// </summary>
    /// <param name="_standardAttributeID">
    /// Identifier of the standard attribute.
    /// </param>
    /// <param name="_product">
    /// Identifier of the product.
    /// </param>
    /// <param name="_language">
    /// Identifier of the language.
    /// </param>
    /// <param name="_internalOrg">
    /// Identifier of the internal org.
    /// </param>
    /// <param name="_catalog">
    /// Identifier of the catalog.
    /// </param>
    /// <returns>
    /// The value of the standard attribute for the product.
    /// </returns>
    public static AttributeValueText getStandardAttributeValueTranslation(RetailStandardAttributeID _standardAttributeID, RefRecId _product, LanguageId _language, RefRecId _internalOrg = 0, RefRecId _catalog = 0)
    {
        switch (_standardAttributeID)
        {
            case RetailStandardAttributeID::ProductName:
                return EcoResProductTranslation::findByProductLanguage(_product, _language).Name;

            case RetailStandardAttributeID::Description:
                return EcoResProductTranslation::findByProductLanguage(_product, _language).Description;

            default:
                EventHandlerResult result = new EventHandlerResult();
                RetailAttributeHelper::getStandardAttributeValueTranslationDelegate(_standardAttributeID, _product, _language, _internalOrg, _catalog, result);
                if (result.hasResult())
                {
                    return result.result();
                }
        }

        if (_language == LanguageTable::defaultLanguage())
        {
            return RetailAttributeHelper::getStandardAttributeValue(_standardAttributeID, _product, _internalOrg, _catalog);
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStandardAttributeValueTranslationDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to retrive standard attribute value for a product.
    /// </summary>
    /// <param name="_standardAttributeID">Identifier of the standard attribute.</param>
    /// <param name="_product">Identifier of the product.</param>
    /// <param name="_language">Identifier of the language.</param>
    /// <param name="_internalOrg">Identifier of the internal org.</param>
    /// <param name="_catalog">Identifier of the catalog.</param>
    /// <param name = "_result">Subscribers can use this to provide the result.</param>
    static delegate void getStandardAttributeValueTranslationDelegate(RetailStandardAttributeID _standardAttributeID,
        RefRecId _product,
        LanguageId _language,
        RefRecId _internalOrg,
        RefRecId _catalog,
        EventHandlerResult _result)
    {
        // Subscriber will provide proper implementation to this method
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAttributeTypeHtml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the HTML attribute type.
    /// </summary>
    /// <param name="_attributeTypeId">
    /// The record id of the attribute group for the attribute beign looked up.
    /// </param>
    /// <returns>
    /// True if attribute type is HTML;otherwise false.
    /// </returns>
    public static boolean isAttributeTypeHtml(RecId _attributeTypeId)
    {
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();

        return _attributeTypeId == retailSharedParameters.HtmlAttributeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAttributeTypeImages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the image attribute type.
    /// </summary>
    /// <param name="_attributeTypeId">
    /// The record id of the attribute group for the attribute beign looked up.
    /// </param>
    /// <returns>
    /// True if attribute type is image;otherwise false.
    /// </returns>
    public static boolean isAttributeTypeImages(RecId _attributeTypeId)
    {
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();

        return _attributeTypeId == retailSharedParameters.ImagesAttributeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAttributeTypeVideos</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the videos attribute type.
    /// </summary>
    /// <param name="_attributeTypeId">
    /// The record id of the attribute group for the attribute beign looked up.
    /// </param>
    /// <returns>
    /// True if attribute type is videos attribute type.
    /// </returns>
    public static boolean isAttributeTypeVideos(RecId _attributeTypeId)
    {
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();

        return _attributeTypeId == retailSharedParameters.VideosAttributeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRichAttributeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the attribute type is rich media type.
    /// </summary>
    /// <param name="_attributeTypeId">
    /// The record id of the attribute group for the attribute beign looked up.
    /// </param>
    /// <returns>
    /// True if attribute type is rich media type.
    /// </returns>
    public static boolean isRichAttributeType(RecId _attributeTypeId)
    {
        return RetailAttributeHelper::isAttributeTypeHtml(_attributeTypeId) ||
               RetailAttributeHelper::isAttributeTypeVideos(_attributeTypeId) ||
               RetailAttributeHelper::isAttributeTypeImages(_attributeTypeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeRetailMediaForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>RetailMedia From</c> form for the supplied
    /// attribute value.
    /// </summary>
    /// <param name="_caller">
    /// The calling form.
    /// </param>
    /// <param name="_textValue">
    /// The attribute to open the form for.
    /// </param>
    /// <param name="_mediaType">
    /// The rich media type of the supplied attribute.
    /// </param>
    /// <param name="_urlTemplateMap">
    /// Expanded url template map.
    /// </param>
    /// <param name="_callerEntityRecId">
    /// Caller entity RecordId, since its an optional parameter caller will pass only if required.
    /// </param>
    /// <param name="_catalog">
    /// The Catalog Record identifier.
    /// </param>
    /// <param name="_internalOrgRecId">
    /// The InternalOrganization RecId.
    /// </param>
    /// <param name="_productRecId">
    /// The Product RecId.
    /// </param>
    [SysObsolete('This routine is no longer supported, use RetailMediaHelper::openRetailMediaForm()', true, 31\01\2016)]
    public static void invokeRetailMediaForm(FormRun _caller, EcoResTextValue _textValue, RetailRichMediaType _mediaType, Map _urlTemplateMap = null, RecId _callerEntityRecId = 0,
                                                   RefRecId _catalog = 0, RetailInternalOrgRefRecId _internalOrgRecId = 0, RefRecId _productRecId = 0)
    {
        Args                args;
        FormRun             formRun;

        //Open the RetailMedia form
        args = new Args();
        args.name(formStr(RetailMedia));
        args.caller(_caller);
        args.record(_textValue);
        args.parmEnumType(enumnum(RetailRichMediaType));
        args.parmEnum(_mediaType);
        args.parmObject(_urlTemplateMap);
        str paramValue = int642Str(_callerEntityRecId) + ':' +  int642Str(_catalog) + ':' + int642Str(_internalOrgRecId) + ':' + int642Str(_productRecId);
        args.parm(paramValue);

        if (_caller.inViewMode())
        {
            args.openMode(OpenMode::View);
        }

        formRun = classfactory.formRunClass(args);

        if (formRun)
        {
            formRun.run();
            formRun.wait();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateRetailSalesOrderAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create or update retail sales order attribute values.
    /// </summary>
    /// <param name = "_channelRecordId">Channel record identifier.</param>
    /// <param name = "_storeId">Store identifier.</param>
    /// <param name = "_terminalId">Terminal identifier.</param>
    /// <param name = "_transactionId">Transaction identifier.</param>
    /// <param name = "_salesId">The sales order identifier.</param>
    /// <param name = "_dataAreaId">The data area identifier.</param>
    /// <param name = "_lineNum">Line number identifier.</param>
    /// <param name = "_attributeInfoCollection">List of attributes to be created or updated.</param>
    /// <param name = "_unshownAttributeNames">List of attribute names that is not part of any store's sales order attribute groups.</param>
    /// <exception cref="Exception::Error">
    /// Throws an exception if the attribute name doesn't exist.
    /// </exception>
    public static void createOrUpdateRetailSalesOrderAttributeValues(
        RefRecId _channelRecordId,
        RetailStoreId _storeId,
        RetailTerminalId _terminalId,
        RetailTransactionId _transactionId,
        SalesIdBase _salesId,
        DataAreaId _dataAreaId,
        HeaderOrLineNum _headerOrLineNum,
        AttributeValueInfoCollection _attributeInfoCollection,
        Set _unshownAttributeNames = new Set(Types::String))
    {
        RetailSalesTableInstanceValue retailSalesTableInstanceValue;
        RetailChannelAttributeGroup retailChannelAttributeGroup;
        EcoResAttributeGroupAttribute ecoResAttributeGroupAttribute;
        EcoResAttribute ecoResAttribute;
        EcoResAttributeType ecoResAttributeType;
        EcoResAttributeValue ecoResAttributeValue;
        RecId ecoResAttributeTypeTextRecId, retailSalesTableInstanceValueRecId;
        Set existingValues = new Set(Types::Int64);
        Set existingAttributes = new Set(Types::Int64);
        SetIterator unusedValuesIterator;
        SetIterator unusedAttributesIterator;

        if (_attributeInfoCollection.Count == 0 || _salesId == '' || _dataAreaId == '')
        {
            return;
        }

        retailSalesTableInstanceValue = RetailSalesTableInstanceValue::findBySalesTable(_salesId, _dataAreaId, true, _headerOrLineNum);

        if (!retailSalesTableInstanceValue.RecId)
        {
            // Create EcoResInstanceValue object if it doesn't exist. RetailSalesTableInstanceValue extends EcoResInstanceValue
            retailSalesTableInstanceValue.initValue();
            retailSalesTableInstanceValue.SalesId = _salesId;
            retailSalesTableInstanceValue.SalesDataAreaId = _dataAreaId;
            retailSalesTableInstanceValue.HeaderOrLineNum = _headerOrLineNum;
            retailSalesTableInstanceValue.insert();
        }
        else
        {
            // If EcoResInstanceValue/RetailSalesTableInstanceValue exists, place in a set all the current Attributes and Values for the instance.
            while select Attribute, Value from ecoResAttributeValue
                where ecoResAttributeValue.InstanceValue == retailSalesTableInstanceValue.RecId
            {
                existingValues.add(ecoResAttributeValue.Value);
                existingAttributes.add(ecoResAttributeValue.Attribute);
            }
        }

        RecId defaultAttrTypeRecId = EcoResAttributeType::findOrCreateAttributeType(
            #DefaultAttributeTypeName, AttributeDataType::Text, NoYes::No, NoYes::No);

        for (int i = 0; i < _attributeInfoCollection.get_Count(); i++)
        {
            AttributeValueInfo attributeInfo = _attributeInfoCollection.get_Item(i) as AttributeValueInfo;

            // Find the EcoResAttribute corresponding to the Attribute name
            // Insert the value for the first attribute found for the given name
            // Currently only supports text attributes.
            select firstOnly Modifier, AttributeGroup from retailChannelAttributeGroup
                where retailChannelAttributeGroup.Modifier == RetailChannelAttributeModifier::SalesOrder
                 join AttributeGroup, Attribute from ecoResAttributeGroupAttribute
                    where ecoResAttributeGroupAttribute.AttributeGroup == retailChannelAttributeGroup.AttributeGroup
                     join Name, AttributeType, RecId from ecoResAttribute
                        where ecoResAttributeGroupAttribute.Attribute == ecoResAttribute.RecId
                           && ecoResAttribute.Name == attributeInfo.Name
                        join DataType, IsEnumeration, RecId from ecoResAttributeType
                            where ecoResAttribute.AttributeType == ecoResAttributeType.RecId
                                && ecoResAttributeType.DataType == AttributeDataType::Text;
            if (!ecoResAttribute.RecId)
            {
                // Don't show warning message repeatedly for the same attribute name.
                if (!_unshownAttributeNames.in(attributeInfo.Name))
                {
                    // The valid attribute definition doesn't exist. Give warning to user.
                    warning(strFmt("@Retail:AttributeNotShownWarning", attributeInfo.Name));

                    _unshownAttributeNames.add(attributeInfo.Name);
                }

                // We can create attribute name each time this condition is satisfied,
                // but let's get the ones that we created previously to prevent
                // unnecessary duplicate row insertion.
                ecoResAttribute.RecId = EcoResAttribute::findOrCreateAttribute(attributeInfo.Name, defaultAttrTypeRecId);
            }

            // Insert EcoResTextValue if it doesn't exist yet.            
            EcoResTextValue ecoResTextValue;
            ecoResTextValue.TextValue = attributeInfo.TextValue;
            ecoResTextValue = ecoResTextValue.readFromHashAndValue();
            if (!ecoResTextValue.RecId)
            {
                ttsbegin;
                ecoResTextValue.initValue();
                ecoResTextValue.TextValue = attributeInfo.TextValue;
                ecoResTextValue.insert();
                ttscommit;
            }

            ecoResAttributeValue = ecoResAttributeValue::findByInstanceAttribute(retailSalesTableInstanceValue.RecId, ecoResAttribute.RecId, true);
            if (!ecoResAttributeValue.RecId)
            {
                ecoResAttributeValue.initValue();
                ecoResAttributeValue.InstanceValue = retailSalesTableInstanceValue.RecId;
                ecoResAttributeValue.Attribute = ecoResAttribute.RecId;
                ecoResAttributeValue.Value = ecoResTextValue.RecId;
                ecoResAttributeValue.insert();
            }
            else if (ecoResAttributeValue.Value != ecoResTextValue.RecId)
            {
                // If EcoResAttributeValue is found, reuse it. We need to change only if it points to a different value.
                ecoResAttributeValue.Value = ecoResTextValue.RecId;
                ecoResAttributeValue.update();
            }

            // Remove the used Values and Attributes from the original list (always doing so for simplicity)
            existingValues.remove(ecoResTextValue.RecId);
            existingAttributes.remove(ecoResAttribute.RecId);
        }

        // Disable delete action so ecoResTextValue is not deleted in the cascade, as ecoResTextValue (ecoResValue) might be re-used by several EcoResAttributeValue
        ecoResAttributeValue.skipDeleteActions(true);

        // Delete the AttributeValue (never Attributes) records of those original Attributes not used (thus removed).
        unusedAttributesIterator = new SetIterator(existingAttributes);
        while (unusedAttributesIterator.more())
        {
            RefRecId ecoResAttributeValueRecId = unusedAttributesIterator.value();

            delete_from ecoResAttributeValue
                where   ecoResAttributeValue.InstanceValue  == retailSalesTableInstanceValue.RecId
                    &&  ecoResAttributeValue.Attribute      == ecoResAttributeValueRecId;

            unusedAttributesIterator.next();
        }

        // Delete the original Value records not used (thus removed), but only if they became orphans.
        unusedValuesIterator = new SetIterator(existingValues);
        while (unusedValuesIterator.more())
        {
            RefRecId ecoResTextValueRecId = unusedValuesIterator.value();
            EcoResTextValue ecoResTextValue;

            select count(RecId) from ecoResAttributeValue where ecoResAttributeValue.Value == ecoResTextValueRecId;
            if (ecoResAttributeValue.RecId == 0)
            {
                delete_from ecoResTextValue where ecoResTextValue.RecId == ecoResTextValueRecId;
            }
                    
            unusedValuesIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeDefinitionsByAttributeGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of attribute definitions from attribute group record identifiers.
    /// </summary>
    /// <param name = "_attributeGroupRecIds">The attribute group record identifier.</param>
    /// <returns>List of attribute definitions that are part of given attribute group record identifiers.</returns>
    public static Map getAttributeDefinitionsByAttributeGroups(Set _attributeGroupRecIds)
    {

        if (_attributeGroupRecIds == null || _attributeGroupRecIds.elements() == 0)
        {
            // return empty collection if no record specified.
            return new Map(Types::Int64, Types::AnyType);
        }

        Query query = RetailAttributeHelper::getAttributeDeifintionsQueryByAttributeGroups(_attributeGroupRecIds);
        return RetailAttributeHelper::getAttributeDefinitionsByQuery(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeDeifintionsQueryByAttributeGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the query to retrieve attribute definitions by attribute group record identifiers.
    /// </summary>
    /// <param name = "_attributeGroupRecIds">The attribute group record identifier.</param>
    /// <returns>The query to retrieve attribute definitions.</returns>
    private static Query getAttributeDeifintionsQueryByAttributeGroups(Set _attributeGroupRecIds)
    {
        SetEnumerator attrGroupEnumerator;
        Query query = new Query();
        QueryBuildRange qbr;
        QueryBuildDataSource qbds;

        qbds = query.addDataSource(tableNum(RetailEcoResAttributeDefinitionsView));
        attrGroupEnumerator = _attributeGroupRecIds.getEnumerator();

        while (attrGroupEnumerator.moveNext())
        {
            // Add attribute group identifier to the query range.
            qbr = qbds.addRange(fieldNum(RetailEcoResAttributeDefinitionsView, AttributeGroupRecId));
            qbr.value(queryValue(attrGroupEnumerator.current()));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeDefinitionsByQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of attribute definitions from query.
    /// </summary>
    /// <param name = "_query">The query to retrieve attribute definitions.</param>
    /// <returns>List of attribute definitions that are retrieved by the query.</returns>
    internal static Map getAttributeDefinitionsByQuery(Query _query)
    {
        RetailEcoResAttributeDefinitionsView attributeDefinitionsTable;
        Map attributeDefinitions = new Map(Types::Int64, Types::AnyType);
        Map attributeDefinitionDetails, attrEnumDefinitionDetails;
        SetEnumerator attributeDefinitionsEnumerator;
        Set attrEnumTypeIdsSet = new Set(Types::Int64);
        Set attrRecIdEnumerationSet = new Set(Types::Int64);
        RefRecId attrEnumDefinitionRecId;

        QueryRun qr = new QueryRun(_query);

        // Iterate through the query result.
        while (qr.next())
        {
            attributeDefinitionsTable = qr.get(tableNum(RetailEcoResAttributeDefinitionsView));
   
            if (attributeDefinitions.exists(attributeDefinitionsTable.AttributeDefinitionRecId))
            {
                // Attribute definition is already on the dictionary, continue to next row.
                continue;
            }
   
            attributeDefinitionDetails = new Map(Types::String, Types::AnyType);
            attributeDefinitionDetails.insert(AttributeDefinitionRecIdKey, attributeDefinitionsTable.AttributeDefinitionRecId);
            attributeDefinitionDetails.insert(AttributeDefinitionNameKey, attributeDefinitionsTable.AttributeName);
            attributeDefinitionDetails.insert(AttributeDefinitionTypeKey, attributeDefinitionsTable.AttributeType);
            attributeDefinitionDetails.insert(AttributeDefinitionIsFixedListKey, attributeDefinitionsTable.IsFixedList == 1);
            attributeDefinitionDetails.insert(AttributeDefinitionTypeRecIdKey, attributeDefinitionsTable.AttributeTypeRecId);
            attributeDefinitionDetails.insert(AttributeDefinitionIsMultiValuesKey,
                strLwr(RetailAttributeHelper::getMetadataValue(attributeDefinitionsTable.Metadata, RetailSPChannelProdAttrMetadataHandler::IsMultiValueConst)) == 'true');
            attributeDefinitionDetails.insert(AttributeDefinitionDefaultTextValueKey, attributeDefinitionsTable.DefaultTextValue);
            attributeDefinitionDetails.insert(AttributeDefinitionDefaultBooleanValueKey, attributeDefinitionsTable.DefaultBooleanValue);
            attributeDefinitionDetails.insert(AttributeDefinitionDefaultDateTimeValueKey, attributeDefinitionsTable.DefaultDateTimeValue);
            attributeDefinitionDetails.insert(AttributeDefinitionDefaultFloatValueKey, attributeDefinitionsTable.DefaultFloatValue);
            attributeDefinitionDetails.insert(AttributeDefinitionDefaultIntValueKey, attributeDefinitionsTable.DefaultIntValue);
            attributeDefinitionDetails.insert(AttributeDefinitionTypeBoundedRecIdKey, attributeDefinitionsTable.AttributeTypeBoundedRecId);
            attributeDefinitionDetails.insert(AttributeDefinitionLowerBoundIntValueKey, attributeDefinitionsTable.LowerBoundIntValue);
            attributeDefinitionDetails.insert(AttributeDefinitionUpperBoundIntValueKey, attributeDefinitionsTable.UpperBoundIntValue);
            attributeDefinitionDetails.insert(AttributeDefinitionLowerBoundFloatValueKey, attributeDefinitionsTable.LowerBoundFloatValue);
            attributeDefinitionDetails.insert(AttributeDefinitionUpperBoundFloatValueKey, attributeDefinitionsTable.UpperBoundFloatValue);
            attributeDefinitionDetails.insert(AttributeDefinitionLowerBoundDateTimeValueKey, attributeDefinitionsTable.LowerBoundDateTimeValue);
            attributeDefinitionDetails.insert(AttributeDefinitionUpperBoundDateTimeValueKey, attributeDefinitionsTable.UpperBoundDateTimeValue);
            attributeDefinitionDetails.insert(AttributeDefinitionUoMRecIdKey, attributeDefinitionsTable.UnitOfMeasureRecId);
            attributeDefinitionDetails.insert(AttributeDefinitionUoMSymbolKey, attributeDefinitionsTable.UnitOfMeasureSymbol);

            // insert attribute definition details to the dictionary.
            attributeDefinitions.insert(
                attributeDefinitionsTable.AttributeDefinitionRecId, attributeDefinitionDetails);

            // If attribute definition has enumeration, add the attribute type record identifier to the Set collection.
            // We'll use this set as query parameter to get attribute enumeration definition details.
            if (attributeDefinitionsTable.IsFixedList)
            {
                // Different attribute definitions can refer to the same attribute types.
                // Check first before adding duplicate attribute type record identifier.
                if (!attrEnumTypeIdsSet.in(attributeDefinitionsTable.AttributeTypeRecId))
                {
                    attrEnumTypeIdsSet.add(attributeDefinitionsTable.AttributeTypeRecId);
                }

                attrRecIdEnumerationSet.add(attributeDefinitionsTable.AttributeDefinitionRecId);
            }
        }

        // Search for enumeration values if this set collection of attribute type identifier exists.
        if (attrEnumTypeIdsSet.elements())
        {
            attrEnumDefinitionDetails = RetailAttributeHelper::getAttributeEnumerationDefinitions(attrEnumTypeIdsSet);
            attributeDefinitionsEnumerator = attrRecIdEnumerationSet.getEnumerator();

            while (attributeDefinitionsEnumerator.moveNext())
            {
                // Add attribute enumeration definition details to the appropriate attribute definition.
                attributeDefinitionDetails = attributeDefinitions.lookup(attributeDefinitionsEnumerator.current());
                attrEnumDefinitionRecId = attributeDefinitionDetails.lookup(AttributeDefinitionTypeRecIdKey);

                if (!attrEnumDefinitionDetails.exists(attrEnumDefinitionRecId))
                {
                    // There is a chance that the attribute type has empty collection of enumeration values.
                    // In this case, insert empty set.
                    attributeDefinitionDetails.insert(AttributeDefinitionEnumerationValuesKey,
                        new Set(Types::AnyType));
                }
                else
                {
                    // Otherwise, insert the Set of enumeration values to the appropriate attribute definition.
                    attributeDefinitionDetails.insert(AttributeDefinitionEnumerationValuesKey,
                        attrEnumDefinitionDetails.lookup(attrEnumDefinitionRecId));
                }
            }
        }

        // Example of end result: dictionary of attribute definitions
        // [
        //      attrDefinitionRecId01 =>
        //          [
        //              'AttributeName' => 'AttrName01',
        //              'AttributeType' => 1,
        //              'IsFixedList' => false
        //          ],
        //      attrDefinitionRecId02 =>
        //          [
        //              'AttributeName' => 'AttrName02',
        //              'AttributeType' => 2,
        //              'IsFixedList' => true
        //          ]
        // ]
        return attributeDefinitions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeDefinitionsByAttributeGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of attribute definitions from attribute group.
    /// </summary>
    /// <param name = "_attributeGroupRecId">The attribute group record identifier.</param>
    /// <returns>List of attribute definitions that are part of given attribute group record identifier.</returns>
    public static Map getAttributeDefinitionsByAttributeGroup(RefRecId _attributeGroupRecId)
    {
        Set attributeGroupSet = new Set(Types::Int64);
        attributeGroupSet.add(_attributeGroupRecId);
        return RetailAttributeHelper::getAttributeDefinitionsByAttributeGroups(attributeGroupSet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of attribute values.
    /// </summary>
    /// <param name = "_instanceRecId">The instance record identifier.</param>
    /// <param name = "attributeDefinitionRecIds">List of attribute definition record identifiers for filtering.</param>
    /// <returns>A dictionary contains of attribute values.</returns>
    public static Map getAttributeValues(RefRecId _instanceRecId, Set _attributeDefinitionRecIds = null)
    {
        RetailEcoResInstanceAttributeValuesView attributeValuesTable;
        Map attributeValues = new Map(Types::Int64, Types::AnyType);
        Set attributeValueSet; // List of attribute value details, group by parent attribute definition record id.
        Map attributeValueDetails;

        if (_instanceRecId == 0)
        {
            // return empty collection if no record specified.
            return attributeValues;
        }

        while select attributeValuesTable
            where attributeValuesTable.InstanceRecId == _instanceRecId
        {
            if (_attributeDefinitionRecIds != null && !_attributeDefinitionRecIds.in(attributeValuesTable.AttributeDefinitionRecId))
            {
                // If parameter attribute definition record ids is given, we only get attribute values within this
                // list. Otherwise we try to get all the attribute values.
                // On this case, the attribute definition record id is not part of the list of given attr definition record ids,
                // so do nothing.
                continue;
            }
            else if (!attributeValues.exists(attributeValuesTable.AttributeDefinitionRecId))
            {
                attributeValueSet = new Set(Types::AnyType);
                attributeValues.insert(attributeValuesTable.AttributeDefinitionRecId, attributeValueSet);
            }
            else
            {
                attributeValueSet = attributeValues.lookup(attributeValuesTable.AttributeDefinitionRecId);
            }

            attributeValueDetails = new Map(Types::String, Types::AnyType);
            attributeValueDetails.insert(AttributeValueRecIdKey, attributeValuesTable.AttributeValueRecId);
            attributeValueDetails.insert(AttributeValueTextKey, attributeValuesTable.TextValue);
            attributeValueDetails.insert(AttributeValueBooleanKey, attributeValuesTable.BooleanValue);
            attributeValueDetails.insert(AttributeValueIntKey, attributeValuesTable.IntValue);
            attributeValueDetails.insert(AttributeValueDecimalKey, attributeValuesTable.FloatValue);
            attributeValueDetails.insert(AttributeValueDateTimeKey, attributeValuesTable.DateTimeValue);
            attributeValueSet.add(attributeValueDetails);
        }

        // Example of end result: dictionary of attribute values
        // [
        //      attrDefinitionRecId01 =>
        //          (
        //              [
        //                  'AttrValueRecId' => 123,
        //                  'TextValue' => 'text value'
        //              ],
        //              [
        //                  'AttrValueRecId' => 456,
        //                  'TextValue' => 'another value'
        //              ]
        //          ),
        //
        //      attrDefinitionRecId02 =>
        //          (
        //              [
        //                  'AttrValueRecId' => 1000,
        //                  'BooleanValue' => true
        //              ],
        //              [
        //                  'AttrValueRecId' => 2000,
        //                  'BooleanValue' => false
        //              ]
        //          )
        return attributeValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInstanceAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update attribute values for an instance value.
    /// </summary>
    /// <param name = "_instanceRecId">Instance record identifier.</param>
    /// <param name = "_newAttributeValues">The attribute values to be updated.</param>
    /// <param name = "_attributeDefinitionRecIds">List of attribute definition details.</param>
    /// <returns>A collection contains insertion records and removal records.</returns>
    public static Map updateInstanceAttributeValues(RefRecId _instanceRecId, Map _newAttributeValues, Set _attributeDefinitionRecIds = null)
    {
        Map oldAttributeValues;
        MapEnumerator oldAttributesEnumerator;
        SetEnumerator newAttributesEnumerator;
        Set oldAttrValues, newAttrValues;
        RefRecId attrKey;
        AttributeDataType dataType;
        anytype currValue;
        str errorMessages;
        SysDictEnum sysDictEnum = new SysDictEnum(enumNum(AttributeDataType));
        Map recordChanges = RetailAttributeHelper::instantiateRecordChangesDictionary();

        oldAttributeValues = RetailAttributeHelper::getAttributeValues(_instanceRecId, _attributeDefinitionRecIds);
        oldAttributesEnumerator = oldAttributeValues.getEnumerator();

        // Example:
        // Old attributes:
        //      [
        //          123 => Mercury, Venus, Earth, Mars
        //          456 => Water, Fire
        //          789 => Green, Yellow, Blue
        //          111 => House
        //      ]
        // New attributes:
        //      [
        //          123 => Earth, Mars, Jupiter, Saturn
        //          789 => Red, Purple
        //          899 => Chair, Table, Desk
        //          111 => Hotel
        //      ]
        // On this example,
        // attribute definition 123: Mercury and Venus will be removed. Jupiter and Saturn will be inserted.
        // attribute definition 456: All references on this attribute definition and attribute values will be removed.
        // attribute definition 789: Green, Yellow, Blue will be removed. Red and Purple will be inserted.
        // attribute definition 111: House will be removed. Hotel will be inserted.
        // attribute definition 899: All references on this attribute definition and attribute values will be inserted.

        ttsbegin;

        // iterate on old attribute Record.
        // From example, we'll iterate 123, 456, 789, 111.
        while (oldAttributesEnumerator.moveNext())
        {
            attrKey = oldAttributesEnumerator.currentKey();
            oldAttrValues = oldAttributesEnumerator.currentValue();

            if (!_newAttributeValues.exists(attrKey))
            {
                // From example, this occurs when 456 => Water, Fire is not found on new attributes.
                // Remove attribute values with this attribute definition RecId.

                RetailAttributeHelper::removeAttributeValues(_instanceRecId, attrKey, 0,
                    0, recordChanges.lookup(RemovalRecordsKey));
            }
            else
            {
                // From example, record 123, 789, and 111 should be on this clause.
                dataType = _newAttributeValues.lookup(attrKey).lookup(AttributeDefinitionTypeKey);
                newAttrValues = _newAttributeValues.lookup(attrKey).lookup(AttributeValuesKey);

                // iterate old attribute values with this attribute key.
                SetEnumerator oldAttrValuesSetEnum = oldAttrValues.getEnumerator();
                Map oldAttrValuesDict;

                // iterate on old attribute values.
                while (oldAttrValuesSetEnum.moveNext())
                {
                    oldAttrValuesDict = oldAttrValuesSetEnum.current();

                    switch (dataType)
                    {
                        case AttributeDataType::Text:
                            currValue = oldAttrValuesDict.lookup(AttributeValueTextKey);
                            break;
                        case AttributeDataType::TrueFalse:
                            currValue = oldAttrValuesDict.lookup(AttributeValueBooleanKey);
                            break;
                        case AttributeDataType::Integer:
                            currValue = oldAttrValuesDict.lookup(AttributeValueIntKey);
                            break;
                        case AttributeDataType::Decimal:
                            currValue = oldAttrValuesDict.lookup(AttributeValueDecimalKey);
                            break;
                        case AttributeDataType::DateTime:
                            currValue = oldAttrValuesDict.lookup(AttributeValueDateTimeKey);
                            break;
                        default:
                            currValue = RetailAttributeHelper::updateInstanceAttributeValuesDefault(_instanceRecId, _newAttributeValues);
                    }

                    if (!newAttrValues.in(currValue))
                    {
                        // From example,
                        // When we loop through record 123, Mercury and Venus is not found on new attributes.
                        // Same thing with record 789 (Green, Yellow, Blue) and 111 (House)

                        // Remove current attribute values
                        // since new attribute values does not provide
                        // existing values.
                        RefRecId attrValueForRemovalRecId = oldAttrValuesDict.lookup(AttributeValueRecIdKey);
                        RetailAttributeHelper::removeAttributeValues(_instanceRecId,
                            attrKey, attrValueForRemovalRecId, dataType, recordChanges.lookup(RemovalRecordsKey));
                    }
                    else
                    {
                        // From example, for record 123 we found matched Earth and Mars.
                        // No op, remove these values from the collection.
                        newAttrValues.remove(currValue);
                    }
                }

                // For the rest of new attribute values that are not removed,
                // these are values for insertion.
                // From example, record 123 now have Jupiter and Saturn.
                // Record 789 has Red and Purple
                // Record 111 has Hotel
                // All of these are new values, insert them to the table.
                errorMessages = RetailAttributeHelper::insertAttributeValues(_instanceRecId,
                     attrKey, dataType, newAttrValues, recordChanges.lookup(InsertionRecordsKey));

                if (errorMessages != '')
                {
                    ttsabort;
                    throw error(errorMessages);
                }
            }

            // Remove the new records that we've already modified.
            // In this case, we remove 123, 789, 111.
            _newAttributeValues.remove(attrKey);
        }

        newAttributesEnumerator = _newAttributeValues.keySet().getEnumerator();
        Map newAttributeValuesMap;

        // Since we removed record 123, 789, and 111,
        // new records are now only 899 => Chair, Table, Desk.
        // In this case, we will insert new records.
        while (newAttributesEnumerator.moveNext())
        {
            attrKey = newAttributesEnumerator.current();
            newAttributeValuesMap = _newAttributeValues.lookup(attrKey);
            errorMessages = RetailAttributeHelper::insertAttributeValues(_instanceRecId,
                attrKey,
                newAttributeValuesMap.lookup(AttributeDefinitionTypeKey),
                newAttributeValuesMap.lookup(AttributeValuesKey),
                recordChanges.lookup(InsertionRecordsKey));

            if (errorMessages != '')
            {
                ttsabort;
                throw error(errorMessages);
            }
        }

        // In the end, the attribute values should be the ones that
        // new attribute values represent.
        ttscommit;

        return recordChanges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInstanceAttributeValuesDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update default attribute values for an instance value.
    /// </summary>
    /// <returns>
    ///     A collection contains insertion records and removal records.
    /// </returns>
    [Replaceable]
    protected static Map updateInstanceAttributeValuesDefault(RefRecId _instanceRecId, Map _newAttributeValues, Set _attributeDefinitionRecIds = null)
    {
        ttsabort;
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBoundaryValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate a value that has boundary restriction.
    /// </summary>
    /// <param name = "_newValue">The value to be validated.</param>
    /// <param name = "_dataType">The attribute datatype.</param>
    /// <param name = "_lowerBoundValue">The lower boundary.</param>
    /// <param name = "_upperBoundValue">The upper boundary.</param>
    /// <param name = "_attributeName">The attribute name.</param>
    /// <returns>The error message when validation failed. When validation passed, error message is empty string.</returns>
    public static str validateBoundaryValue(anytype _newValue, AttributeDataType _dataType, anytype _lowerBoundValue, anytype _upperBoundValue, str _attributeName)
    {
        str errorMessage;
        str lowerBoundStr, upperBoundStr, newValueStr;
        boolean isValidBoundaryDataType = AttributeDataTypeDiscriminator::checkAttributeDataTypeDateTime(_dataType) || AttributeDataTypeDiscriminator::checkAttributeDataTypeDecimal(_dataType)
            || AttributeDataTypeDiscriminator::checkAttributeDataTypeInteger(_dataType);

        // No need to validate if any of these parameters are null.
        if (_newValue != null && _lowerBoundValue != null && _upperBoundValue != null
            && isValidBoundaryDataType && (_newValue < _lowerBoundValue || _newValue > _upperBoundValue))
        {
            if (AttributeDataTypeDiscriminator::checkAttributeDataTypeDateTime(_dataType))
            {
                lowerBoundStr = datetime2str(_lowerBoundValue, DateFlags::None);
                upperBoundStr = datetime2str(_upperBoundValue, DateFlags::None);
                newValueStr = datetime2str(_newValue, DateFlags::None);
            }
            else
            {
                lowerBoundStr = strFmt('%1', _lowerBoundValue);
                upperBoundStr = strFmt('%1', _upperBoundValue);
                newValueStr = strFmt('%1', _newValue);
            }

            errorMessage = strFmt('@Retail:AttrValidationBoundedFailedMessage',
                newValueStr, _attributeName, lowerBoundStr, upperBoundStr);
        }

        return errorMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAttributeValueBoundaries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate attribute value boundaries for type Int, Decimal, DateTime, and Text enumeration.
    /// </summary>
    /// <param name = "_attributeDefinition">The attribute definition.</param>
    /// <param name = "_attributeValues">The attribute values.</param>
    /// <returns>The error message when validation failed. When validation passed, error message is empty string.</returns>
    public static str validateAttributeValueBoundaries(Map _attributeDefinition, Map _attributeValues)
    {
        str errorMessage, attrDefinitionName;
        MapEnumerator attrValuesMapEnumerator;
        RefRecId attrDefinitionRecId, attrTypeBoundedRecId;
        Map attrDefinitionDetails, attrValueDetails;
        Set attrValuesSet;
        SetEnumerator attrValuesEnumerator;
        anytype lowerBoundValue, upperBoundValue, currentValue;
        AttributeDataType attrType;
        boolean isFixedList;
        Set attrEnumDefinitionSet;
        Map attrEnumDefinitionDetails;
        Set allowedEnumValues;
        str enumDefinitionValue, attrEnumValue;

        // No need to execute if any of these are null.
        if (_attributeDefinition == null || _attributeValues == null)
        {
            return errorMessage;
        }

        attrValuesMapEnumerator = _attributeValues.getEnumerator();

        // Enumerate through attribue values.
        while (attrValuesMapEnumerator.moveNext())
        {
            attrDefinitionRecId = attrValuesMapEnumerator.currentKey();

            // No validation available if the attribute definition is not part of attribute group.
            if (!_attributeDefinition.exists(attrDefinitionRecId))
            {
                continue;
            }

            attrDefinitionDetails = _attributeDefinition.lookup(attrDefinitionRecId);
            attrTypeBoundedRecId = attrDefinitionDetails.lookup(AttributeDefinitionTypeBoundedRecIdKey);
            attrType = attrDefinitionDetails.lookup(AttributeDefinitionTypeKey);
            attrDefinitionName = attrDefinitionDetails.lookup(AttributeDefinitionNameKey);
            isFixedList = attrDefinitionDetails.lookup(AttributeDefinitionIsFixedListKey);
            attrValueDetails = _attributeValues.lookup(attrDefinitionRecId);
            attrValuesSet = attrValueDetails.lookup(AttributeValuesKey);

            // Go inside this clause if attribute definition has record identifier for attribute type bounded.
            if (attrTypeBoundedRecId > 0)
            {
                // We only need to validate DateTime, Int, and Decimal since HQ supports only these 3 types.
                container con = RetailAttributeHelper::getBoundValuesForAttributeType(attrType, attrDefinitionDetails);
                lowerBoundValue = conPeek(con, 1);
                upperBoundValue = conPeek(con, 2);
            

                attrValuesEnumerator = attrValuesSet.getEnumerator();

                // Iterate through attribute values (this is grouped by attr definitino record identifier) and validate the boundaries.
                while (attrValuesEnumerator.moveNext())
                {
                    errorMessage += RetailAttributeHelper::validateBoundaryValue(
                        attrValuesEnumerator.current(), attrType, lowerBoundValue, upperBoundValue, attrDefinitionName);
                }

                // If error message is not empty, stop the execution and return the message.
                if (errorMessage != '')
                {
                    return errorMessage;
                }
            }
            else if (isFixedList)
            {
                allowedEnumValues = new Set(Types::String);
                attrEnumDefinitionSet = attrDefinitionDetails.lookup(AttributeDefinitionEnumerationValuesKey);
                attrValuesEnumerator = attrEnumDefinitionSet.getEnumerator();

                // For attribute type enumeration / fixed list, we need to list all of possible values.
                while (attrValuesEnumerator.moveNext())
                {
                    attrEnumDefinitionDetails = attrValuesEnumerator.current();
                    enumDefinitionValue = attrEnumDefinitionDetails.lookup(AttrEnumDefinitionTextValueKey);
                    allowedEnumValues.add(enumDefinitionValue);
                }

                // Iterate through attribute values (this is grouped by attr definition record identifier) and validate the boundaries.
                while (attrValuesEnumerator.moveNext())
                {
                    attrEnumValue = attrValuesEnumerator.current();

                    // Set error message when the value is not part of possible enumeration values.
                    if (!allowedEnumValues.in(attrEnumValue))
                    {
                        errorMessage += strFmt('@Retail:AttributeNotPartOfEnumError', attrEnumValue, attrDefinitionName);
                    }
                }

                // If error message is not empty, stop the execution and return the message.
                if (errorMessage != '')
                {
                    return errorMessage;
                }
            }
        }

        return errorMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBoundValuesForAttributeType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Extracts the lower and upper bounds of an attribute.
    /// </summary>
    /// <param name = "_attrType">
    ///     An attribute data type.
    /// </param>
    /// <param name = "_attrDefinitionDetails">
    ///     The attribute definition detail.
    /// </param>
    /// <returns>
    ///     A container having lowerBoundValue and upperBoundValue.
    /// </returns>
    protected static container getBoundValuesForAttributeType(AttributeDataType _attrType,  Map _attrDefinitionDetails)
    {
        anytype lowerBoundValue, upperBoundValue;
        switch (_attrType)
        {
            case AttributeDataType::DateTime:
                lowerBoundValue = _attrDefinitionDetails.lookup(AttributeDefinitionLowerBoundDateTimeValueKey);
                upperBoundValue = _attrDefinitionDetails.lookup(AttributeDefinitionUpperBoundDateTimeValueKey);
                break;
            case AttributeDataType::Integer:
                lowerBoundValue = _attrDefinitionDetails.lookup(AttributeDefinitionLowerBoundIntValueKey);
                upperBoundValue = _attrDefinitionDetails.lookup(AttributeDefinitionUpperBoundIntValueKey);
                break;
            case AttributeDataType::Decimal:
                lowerBoundValue = _attrDefinitionDetails.lookup(AttributeDefinitionLowerBoundFloatValueKey);
                upperBoundValue = _attrDefinitionDetails.lookup(AttributeDefinitionUpperBoundFloatValueKey);
                break;
        }
        container con = [lowerBoundValue, upperBoundValue];
        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMetadataValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the metadata value.
    /// </summary>
    /// <param name = "_metadataDetails">Xml format of metadata details.</param>
    /// <param name = "_metadataName">The xml attribute metadata name.</param>
    /// <returns>The value corresponds to the metadata name.</returns>
    private static str getMetadataValue(str _metadataDetails, str _metadataName)
    {
        XmlDocument xmlDoc = new XmlDocument();
        XmlElement propertyElmt;
        str attributeValue;
        xmlDoc.loadXml(_metadataDetails);
        propertyElmt = xmlDoc.documentElement();
        attributeValue = propertyElmt.getAttribute(_metadataName);

        return attributeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert attribute values and its references.
    /// </summary>
    /// <param name = "_instanceRecId">The instance record identifier.</param>
    /// <param name = "_attributeDefinitionRecId">The attribute definition record identifier.</param>
    /// <param name = "_dataType">The attribute data type.</param>
    /// <param name = "_attributeValues">List of attribute values to be inserted.</param>
    /// <param name="_insertionRecords">A collection of insertion records.</param>
    /// <returns>Error messages, if any.</returns>
    private static str insertAttributeValues(RefRecId _instanceRecId, RefRecId _attributeDefinitionRecId, AttributeDataType _dataType,
        Set _attributeValues, Map _insertionRecords)
    {
        EcoResAttributeValue erav;
        SetEnumerator setEnumerator;
        anytype currentValue;
        str errorMessages;
        SysDictEnum sysDictEnum = new SysDictEnum(enumNum(AttributeDataType));
        str eravTableName = tableId2Name(tableNum(EcoResAttributeValue));
        List attrValueListRecords = _insertionRecords.lookup(eravTableName);
        List listRecords;
        setEnumerator = _attributeValues.getEnumerator();

        while (setEnumerator.moveNext())
        {
            currentValue = setEnumerator.current();
            RefRecId newValueRecId = RetailAttributeHelper::getRecIdFromAttributeDataType(_dataType, _insertionRecords, currentValue);

            if (!newValueRecId)
            {
                str dataTypeText = sysDictEnum.value2Symbol(_dataType);
                errorMessages += strFmt('Attribute data type %1 has not yet supported',
                    dataTypeText != '' ? dataTypeText : int2Str(_dataType));
            }

            if (errorMessages == '')
            {
                // no error messages found, insert to EcoResAttributeValue table.
                erav.initValue();
                erav.InstanceValue = _instanceRecId;
                erav.Attribute = _attributeDefinitionRecId;
                erav.Value = newValueRecId;
                erav.insert();
                attrValueListRecords.addEnd(erav);
            }
        }

        // Example of dictionary of records to be inserted
        // [
        //      'EcoResAttributeValue' =>
        //          (
        //              Record01,
        //              Record02,
        //              Record03,
        //          ),
        //
        //      'EcoResBooleanValue' =>
        //          (
        //              Record04,
        //              Record05,
        //              Record06,
        //          ),
        //
        //      'EcoResTextValue' =>
        //          (
        //              Record07,
        //              Record08,
        //              Record09,
        //          )
        // ]
        return errorMessages;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecIdFromAttributeDataType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts attribute values and its references to tables based on <c>AttributeDataType</c>.
    /// </summary>
    /// <param name = "_dataType">
    ///     An attribute data type.
    /// </param>
    /// <param name = "_insertionRecords">
    ///     A collection of insertion records.
    /// </param>
    /// <param name = "_currentValue">
    ///     Current attribute value.
    /// </param>
    /// <returns>
    ///     A reference id.
    /// </returns>
    protected static RefRecId getRecIdFromAttributeDataType(AttributeDataType _dataType, Map _insertionRecords, anytype _currentValue)
    {
        List listRecords;
        RefRecId newValueRecId;

        switch (_dataType)
        {
            case AttributeDataType::Text:
                EcoResTextValue ertv;
                ertv.initValue();
                ertv.TextValue = _currentValue;
                ertv.insert();
                newValueRecId = ertv.RecId;
                str ertvTableName = tableId2Name(tableNum(EcoResTextValue));
                listRecords = _insertionRecords.lookup(ertvTableName);
                listRecords.addEnd(ertv);
                break;
            case AttributeDataType::TrueFalse:
                EcoResBooleanValue erbv;
                erbv.initValue();
                erbv.BooleanValue = _currentValue;
                erbv.insert();
                newValueRecId = erbv.RecId;
                str erbvTableName = tableId2Name(tableNum(EcoResBooleanValue));
                listRecords = _insertionRecords.lookup(erbvTableName);
                listRecords.addEnd(erbv);
                break;
            case AttributeDataType::Integer:
                EcoResIntValue eriv;
                eriv.initValue();
                eriv.IntValue = _currentValue;
                eriv.insert();
                newValueRecId = eriv.RecId;
                str erivTableName = tableId2Name(tableNum(EcoResIntValue));
                listRecords = _insertionRecords.lookup(erivTableName);
                listRecords.addEnd(eriv);
                break;
            case AttributeDataType::Decimal:
                EcoResFloatValue erfv;
                erfv.initValue();
                erfv.FloatValue = _currentValue;
                erfv.insert();
                newValueRecId = erfv.RecId;
                str erfvTableName = tableId2Name(tableNum(EcoResFloatValue));
                listRecords = _insertionRecords.lookup(erfvTableName);
                listRecords.addEnd(erfv);
                break;
            case AttributeDataType::DateTime:
                EcoResDateTimeValue erdtv;
                erdtv.initValue();
                erdtv.DateTimeValue = _currentValue;
                erdtv.insert();
                newValueRecId = erdtv.RecId;
                str erdtvTableName = tableId2Name(tableNum(EcoResDateTimeValue));
                listRecords = _insertionRecords.lookup(erdtvTableName);
                listRecords.addEnd(erdtv);
                break;
        }

        return newValueRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove attribute values and its reference. When attribute value record identifier is zero,
    /// then all the rows that has matched instance record identifier and attribute definition record identifier
    /// will be removed.
    /// </summary>
    /// <param name = "_instanceRecId">The instance record identifier.</param>
    /// <param name = "_attributeDefinitionRecId">Attribute definition record identifier.</param>
    /// <param name = "_attributeValueRecId">Optional. Attribute value record identifier.</param>
    /// <param name ="_dataType">The attribute data type.</param>
    /// <param name="_removalRecords">A collection contains table name and record identifiers to be removed.</returns>
    protected static void removeAttributeValues(RefRecId _instanceRecId, RefRecId _attributeDefinitionRecId, RefRecId _attributeValueRecId,
        AttributeDataType _dataType, Map _removalRecords)
    {
        EcoResAttributeValue erav;
        EcoResValue erv;
        RetailEcoResAttributeDefinitionsView attrDefinitionsView;
        RefRecId attrValueRecId;
        List eravRemovalList;

        // Get the appropriate data type if value is less or equal to zero.
        select firstonly attrDefinitionsView
                where attrDefinitionsView.AttributeDefinitionRecId == _attributeDefinitionRecId;
        _dataType = attrDefinitionsView.AttributeType;
        
        if (_attributeValueRecId <= 0)
        {
            // remove every row that corresponds with _instanceRecId and _attributeDefinitionRecId
            while select forupdate erav
                where erav.InstanceValue == _instanceRecId
                && erav.Attribute == _attributeDefinitionRecId
            {
                attrValueRecId = erav.Value;
                eravRemovalList = _removalRecords.lookup(tableId2Name(tableNum(EcoResAttributeValue)));
                eravRemovalList.addEnd(erav.RecId);
                erav.delete(); // delete row in EcoResAttributeValue

                // delete row in EcoResValue
                select forupdate erv
                    where erv.RecId == attrValueRecId;
                RetailAttributeHelper::addEcoResValueRemovalRecords(_dataType, attrValueRecId, _removalRecords);
                erv.delete();
            }
        }
        else
        {
            // delete only row corresponds with _attributeValueRecId
            select forupdate erav
                where erav.InstanceValue == _instanceRecId
                && erav.Attribute == _attributeDefinitionRecId
                && erav.Value == _attributeValueRecId;
            eravRemovalList = _removalRecords.lookup(tableId2Name(tableNum(EcoResAttributeValue)));
            eravRemovalList.addEnd(erav.RecId);
            erav.delete(); // delete row in EcoResAttributeValue

            // delete row in EcoResValue
            select forupdate erv
                    where erv.RecId == _attributeValueRecId;
            RetailAttributeHelper::addEcoResValueRemovalRecords(_dataType, _attributeValueRecId, _removalRecords);
            erv.delete();
        }

        // Example of dictionary of records to be removed
        // [
        //      'EcoResAttributeValue' =>
        //          (
        //              1234,
        //              4568,
        //              3233
        //          ),
        //
        //      'EcoResBooleanValue' =>
        //          (
        //              5123,
        //              5124,
        //              5125
        //          ),
        //
        //      'EcoResTextValue' =>
        //          (
        //              6899,
        //              6900,
        //              6901
        //          )
        // ]
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAllAttributeReferencesPerInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove attribute values and its reference as per EcoResInstance values.
    /// </summary>
    /// <param name = "_salesId">Sales Id</param>
    /// <param name = "_salesDataAreaId">DataAreaId</param>
    public static void removeAllAttributeReferencesPerInstance(SalesIdbase _salesId, DataAreaId _salesDataAreaId)
    {
        RefRecId  retailSaleTableInstanceRecId = RetailSalesTableInstanceValue::findBySalesTable(_salesId, _salesDataAreaId).RecId;
        EcoResAttributeValue  ecoResAttributeValue;
        RetailSalesTableInstanceValue  retailSalesTableInstanceValue;

        if (retailSaleTableInstanceRecId)
        {
            ttsbegin;
            retailSalesTableInstanceValue.skipDeleteActions(true);
            retailSalesTableInstanceValue.skipDataMethods(true);

            delete_from retailSalesTableInstanceValue
                where retailSalesTableInstanceValue.RecId == retailSaleTableInstanceRecId;

            while select Value from ecoResAttributeValue
                where ecoResAttributeValue.InstanceValue == retailSaleTableInstanceRecId
            {
                EcoResAttributeValue  ecoResAttributeValueLocal;
                EcoResValue  ecoResValue;
                
                select count(RecId) from ecoResAttributeValueLocal 
                    where ecoResAttributeValueLocal.Value == ecoResAttributeValue.Value &&
                          ecoResAttributeValueLocal.InstanceValue != retailSaleTableInstanceRecId;

                // Delete the Value records not used (thus removed), but only if they became orphans.
                if (ecoResAttributeValueLocal.RecId == 0)
                {
                    select forupdate ecoResValue where ecoResValue.RecId == ecoResAttributeValue.Value;
                    ecoResValue.delete();
                }
            }

            ecoResAttributeValue.skipDeleteActions(true);
            ecoResAttributeValue.skipDataMethods(true);

            delete_from ecoResAttributeValue
                where ecoResAttributeValue.InstanceValue == retailSaleTableInstanceRecId;
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addEcoResValueRemovalRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds record identifier attribute value table to be removed to the collection set.
    /// </summary>
    /// <param name = "_dataType">
    ///     An attribute data type.
    /// </param>
    /// <param name = "_attributeValueRecId">
    ///     An attribute value record identifier.
    /// </param>
    /// <param name = "_removalRecords">
    ///     The dictionary that contains removal records.
    /// </param>
    protected static void addEcoResValueRemovalRecords(AttributeDataType _dataType, RefRecId _attributeValueRecId, Map _removalRecords)
    {
        List removalSetRecords;

        switch (_dataType)
        {
            case AttributeDataType::Text:
                removalSetRecords = _removalRecords.lookup(tableId2Name(tableNum(EcoResTextValue)));
                break;
            case AttributeDataType::TrueFalse:
                removalSetRecords = _removalRecords.lookup(tableId2Name(tableNum(EcoResBooleanValue)));
                break;
            case AttributeDataType::DateTime:
                removalSetRecords = _removalRecords.lookup(tableId2Name(tableNum(EcoResDateTimeValue)));
                break;
            case AttributeDataType::Decimal:
                removalSetRecords = _removalRecords.lookup(tableId2Name(tableNum(EcoResFloatValue)));
                break;
            case AttributeDataType::Integer:
                removalSetRecords = _removalRecords.lookup(tableId2Name(tableNum(EcoResIntValue)));
                break;
        }

        removalSetRecords.addEnd(_attributeValueRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateRecordChangesDictionary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the record changes dictionary.
    /// </summary>
    /// <returns></returns>
    private static Map instantiateRecordChangesDictionary()
    {
        Map recordChanges = new Map(Types::String, Types::AnyType);
        Map insertionRecords = new Map(Types::String, Types::AnyType);
        Map removalRecords = new Map(Types::String, Types::AnyType);

        insertionRecords.insert(tableId2Name(tableNum(EcoResAttributeValue)), new List(Types::Record));
        insertionRecords.insert(tableId2Name(tableNum(EcoResTextValue)), new List(Types::Record));
        insertionRecords.insert(tableId2Name(tableNum(EcoResBooleanValue)), new List(Types::Record));
        insertionRecords.insert(tableId2Name(tableNum(EcoResFloatValue)), new List(Types::Record));
        insertionRecords.insert(tableId2Name(tableNum(EcoResIntValue)), new List(Types::Record));
        insertionRecords.insert(tableId2Name(tableNum(EcoResDateTimeValue)), new List(Types::Record));

        removalRecords.insert(tableId2Name(tableNum(EcoResAttributeValue)), new List(Types::Int64));
        removalRecords.insert(tableId2Name(tableNum(EcoResTextValue)), new List(Types::Int64));
        removalRecords.insert(tableId2Name(tableNum(EcoResBooleanValue)), new List(Types::Int64));
        removalRecords.insert(tableId2Name(tableNum(EcoResFloatValue)), new List(Types::Int64));
        removalRecords.insert(tableId2Name(tableNum(EcoResIntValue)), new List(Types::Int64));
        removalRecords.insert(tableId2Name(tableNum(EcoResDateTimeValue)), new List(Types::Int64));

        recordChanges.insert(InsertionRecordsKey, insertionRecords);
        recordChanges.insert(RemovalRecordsKey, removalRecords);

        return recordChanges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeEnumerationDefinitions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the attribute enumeration definition details.
    /// </summary>
    /// <param name = "_attrTypeRecIdsSet">The list of attribute type record identifier as query parameter.</param>
    /// <returns>The list attribute enumeration definitions.</returns>
    private static Map getAttributeEnumerationDefinitions(Set _attrTypeRecIdsSet)
    {
        EcoResEnumerationAttributeTypeValue ereatv;
        EcoResTextValue ertv;
        Map attrEnumDefinitions = new Map(Types::Int64, Types::AnyType);
        Set attrEnumDefinitionDetails;
        SetEnumerator attrTypeRecIdEnumerator;
        Map attrEnumValue;
        Query query = new Query();
        QueryRun qr;
        QueryBuildRange qbr;
        QueryBuildDataSource qbds;

        qbds = query.addDataSource(tableNum(EcoResEnumerationAttributeTypeValue));
        attrTypeRecIdEnumerator = _attrTypeRecIdsSet.getEnumerator();

        while (attrTypeRecIdEnumerator.moveNext())
        {
            // Add parameter range, attribute type record identifier.
            qbr = qbds.addRange(fieldNum(EcoResEnumerationAttributeTypeValue, AttributeType));
            qbr.value(queryValue(attrTypeRecIdEnumerator.current()));
        }

        qbds.addOrderByField(fieldNum(EcoResEnumerationAttributeTypeValue, AttributeType));
        qbds.addOrderByField(fieldNum(EcoResEnumerationAttributeTypeValue, OrdinalNumber));

        qbds = qbds.addDataSource(tableNum(EcoResTextValue));
        qbds.joinMode(JoinMode::InnerJoin);
        qbds.relations(false);
        qbds.addLink(fieldNum(EcoResEnumerationAttributeTypeValue, Value), fieldNum(EcoResTextValue, RecId));

        qr = new QueryRun(query);

        // Iterate through the result query.
        while (qr.next())
        {
            ereatv = qr.get(tableNum(EcoResEnumerationAttributeTypeValue));
            ertv = qr.get(tableNum(EcoResTextValue));
   
            if (attrEnumDefinitions.exists(ereatv.AttributeType))
            {
                // Attribute type record identifier already exists, get the mapping details with
                // the idenfier as key.
                attrEnumDefinitionDetails = attrEnumDefinitions.lookup(ereatv.AttributeType);
            }
            else
            {
                // No attribute type record identifier exists yet.
                // Construct a Set that will contain enum values and insert it to the mapping details.
                attrEnumDefinitionDetails = new Set(Types::AnyType);
                attrEnumDefinitions.insert(ereatv.AttributeType, attrEnumDefinitionDetails);
            }

            attrEnumValue = new Map(Types::String, Types::AnyType);
            attrEnumValue.insert(AttrEnumDefinitionOrdinalNumberKey, ereatv.OrdinalNumber);
            attrEnumValue.insert(AttrEnumDefinitionTextValueKey, ertv.TextValue);
            attrEnumDefinitionDetails.add(attrEnumValue);
        }

        // Example of end result: dictionary of attribute definitions
        // [
        //      attrTypeRecId01 =>
        //          [
        //              (
        //                  'OrdinalNumber' => '1',
        //                  'TextValue' => 'TextValue1'
        //              )
        //              (
        //                  'OrdinalNumber' => '2',
        //                  'TextValue' => 'TextValue2'
        //              )
        //          ],
        //      attrTypeRecId02 =>
        //          [
        //              (
        //                  'OrdinalNumber' => '1',
        //                  'TextValue' => 'AnotherTextValue1'
        //              )
        //              (
        //                  'OrdinalNumber' => '2',
        //                  'TextValue' => 'AnotherTextValue2'
        //              )
        //          ]
        // ]
        return attrEnumDefinitions;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>