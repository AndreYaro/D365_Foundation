<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceTransactionsJson</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections.ObjectModel;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using CRT = Microsoft.Dynamics.Commerce.Runtime;

/// <summary>
/// The <c>RetailTransactionServiceTransactionsJson</c> class contains methods for returning transaction related data in JSON format.
/// </summary>
class RetailTransactionServiceTransactionsJson
{
    #ISOCountryRegionCodes
    #EECountryRegionCodes

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addSalesOrderToList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given SalesOrder entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_List">
    /// The List the new Sales Order entry will be added to.
    /// </param>
    /// <param name="_salesTable">
    /// The SalesTable entry.
    /// </param>
    /// <param name="_partyTable">
    /// The optional associated DirPartyTable.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name = "_skipResultsWithoutTransactions">
    /// Whether or not to skip orders that do not have transactions (ie, due to pending P-Job).
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addSalesOrderToList(
        System.Collections.IList _List,
        SalesTable _salesTable,
        DirPartyTable _partyTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true,
        boolean _skipResultsWithoutTransactions = false)
    {
        RetailSalesTable rsTable;
        RetailTransactionTable rtTable;
        CustTable custTable;

        CRT.DataModel.SalesOrder result;
        CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate resultSurrogate;

        boolean isCallCenter;

        // Get additional summary values
        rsTable = RetailSalesTable::findSalesTable(_salesTable);
        custTable = custTable::findByPartyRecId(_partyTable.RecId);

        // Get the most recent Transaction associated with this order (if one exists)
        select firstOnly1 * from rtTable
        order by rtTable.transDate desc, rtTable.transTime desc
        where rtTable.salesOrderId == _salesTable.SalesId;

        // If we would skip, confirm whether or not the order is from Call Center.
        if (_skipResultsWithoutTransactions & !rtTable)
        {
            isCallCenter = RetailChannelTable::findByRecId(rsTable.RetailChannel).ChannelType == RetailChannelType::MCRCallCenter;
        }

        //If we aren't supposed to skip orders that don't have any Transactions (yet), or we found a matching transaction, add it to the list
        if ( (!_skipResultsWithoutTransactions) || rtTable || isCallCenter)
        {
            result = RetailTransactionServiceTransactionsJson::fillSalesOrderDetails(
                _salesTable,
                rsTable,
                custTable,
                rtTable,
                _includeDetails,
                _includeDiscountLines);

            resultSurrogate = CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate::FromSalesOrder(result);
            _List.Add(resultSurrogate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesOrderToListExtended</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given SalesOrder entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_List">
    /// The List the new Sales Order entry will be added to.
    /// </param>
    /// <param name="_salesTable">
    /// The SalesTable entry.
    /// </param>
    /// <param name="_rsoTable">
    /// The optional associated RetailSalesTable.
    /// </param>
    /// <param name="_custTable">
    /// The optional associated CustTable.
    /// </param>
    /// <param name="_transactionTable">
    /// The optional associated RetailTransactionTable.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name = "_skipResultsWithoutTransactions">
    /// Whether or not to skip orders that do not have transactions (ie, due to pending P-Job).
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addSalesOrderToListExtended(
        System.Collections.IList _List,
        SalesTable _salesTable,
        RetailSalesTable _rsoTable,
        CustTable _custTable,
        RetailTransactionTable _transactionTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true)
    {
        CRT.DataModel.SalesOrder result;
        CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate resultSurrogate;

        result = RetailTransactionServiceTransactionsJson::fillSalesOrderDetails(
            _salesTable,
            _rsoTable,
            _custTable,
            _transactionTable,
            _includeDetails,
            _includeDiscountLines);

        resultSurrogate = CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate::FromSalesOrder(result);

        // Gather extension properties from extensions
        List extensionProperties = new List(Types::Class);
        RetailTransactionServiceTransactionsJson::registerOrderExtensionProperties(_salesTable, extensionProperties);
        RetailTransactionServiceTransactionsJson::addSalesOrderSurrogateExtensionProperties(resultSurrogate, extensionProperties);

        _List.Add(resultSurrogate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesQuoteToList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given SalesQuotation entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_List">
    /// The List the new Sales Order entry will be added to.
    /// </param>
    /// <param name="_quoteTable">
    /// The SalesQuotationTable entry.
    /// </param>
    /// <param name="_partyTable">
    /// The optional associated DirPartyTable.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name = "_skipResultsWithoutTransactions">
    /// Whether or not to skip orders that do not have transactions (ie, due to pending P-Job).
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addSalesQuoteToList(
        System.Collections.IList _List,
        SalesQuotationTable _quoteTable,
        DirPartyTable _partyTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true,
        boolean _skipResultsWithoutTransactions = false)
    {
        RetailSalesQuotationTable rsqTable;
        CustTable custTable;

        CRT.DataModel.SalesOrder result;
        CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate resultSurrogate;

        // Get additional summary values
        rsqTable = RetailSalesQuotationTable::find(_quoteTable.QuotationId);
        custTable = custTable::findByPartyRecId(_partyTable.RecId);

        //If we aren't supposed to skip orders that don't have any Transactions (yet), or we found a matching transaction, add it to the list
        if ( (!_skipResultsWithoutTransactions) || rsqTable)
        {
            // Generate xml for transaction header
            result = RetailTransactionServiceTransactionsJson::fillQuoteDetails(
                _quoteTable,
                rsqTable,
                custTable,
                _includeDetails);

            resultSurrogate = CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate::FromSalesOrder(result);
            _List.Add(resultSurrogate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesQuoteToListExtended</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given SalesQuotation entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_List">
    /// The List the new Sales Order entry will be added to.
    /// </param>
    /// <param name="_quoteTable">
    /// The SalesQuotationTable entry.
    /// </param>
    /// <param name="_rsqTable">
    /// The optional associated RetailSalesQuotationTable.
    /// </param>
    /// <param name="_custTable">
    /// The optional associated CustTable.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name = "_skipResultsWithoutTransactions">
    /// Whether or not to skip orders that do not have transactions (ie, due to pending P-Job).
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addSalesQuoteToListExtended(
        System.Collections.IList _List,
        SalesQuotationTable _quoteTable,
        RetailSalesQuotationTable _rsqTable,
        CustTable _custTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true)
    {
        CRT.DataModel.SalesOrder result;
        CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate resultSurrogate;

        // Generate xml for transaction header
        result = RetailTransactionServiceTransactionsJson::fillQuoteDetails(
            _quoteTable,
            _rsqTable,
            _custTable,
            _includeDetails);

        resultSurrogate = CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate::FromSalesOrder(result);

        // Gather extension properties from extensions
        List extensionProperties = new List(Types::Class);
        RetailTransactionServiceTransactionsJson::registerQuoteExtensionProperties(_quoteTable, extensionProperties);
        RetailTransactionServiceTransactionsJson::addSalesOrderSurrogateExtensionProperties(resultSurrogate, extensionProperties);

        _List.Add(resultSurrogate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransactionToList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given Transaction entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_List">
    /// The List the new transaction entry will be added to.
    /// </param>
    /// <param name="_transactionTable">
    /// The transaction table entry.
    /// </param>
    /// <param name="_partyTable">
    /// The optional associated DirPartyTable entry.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addTransactionToList(
        System.Collections.IList _List,
        RetailTransactionTable _transactionTable,
        DirPartyTable _partyTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true)
    {
        RetailTransactionTaxTrans retailTransactionTaxTrans;
        RetailTransactionMarkupTrans chargeTable;

        CRT.DataModel.SalesOrder result;
        CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate resultSurrogate;

        // Get Transaction Key
        str getTransactionKey(RetailTransactionTable t)
        {
            return t.transactionId + t.store + t.terminal + int642str(t.Channel);
        }

        retailTransactionTaxTrans.Amount = _transactionTable.isGTETransaction() ?
            RetailTransactionTaxTransGTE::calculateTotalTaxAmountForRetailTransaction(_transactionTable) :
            RetailTransactionServiceTransactionsJson::calculateRegularTotalTaxAmountForRetailTransaction(_transactionTable);

        select sum(CalculatedAmount) from chargeTable
            where _transactionTable.TransactionId == chargeTable.TransactionId
                && _transactionTable.Channel == chargeTable.Channel
                && _transactionTable.Store == chargeTable.Store
                && _transactionTable.Terminal == chargeTable.TerminalId
                && _transactionTable.DataAreaId == chargeTable.DataAreaId;

        // Generate xml for transaction header
        result = RetailTransactionServiceTransactionsJson::fillRetailTransactionDetails(
            _transactionTable,
            retailTransactionTaxTrans,
            chargeTable,
            _partyTable,
            _includeDetails,
            _includeDetails);

        resultSurrogate = CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate::FromSalesOrder(result);

        // Gather extension properties from extensions
        List extensionProperties = new List(Types::Class);
        RetailTransactionServiceTransactionsJson::registerExtensionProperties(_transactionTable, extensionProperties);
        RetailTransactionServiceTransactionsJson::addSalesOrderSurrogateExtensionProperties(resultSurrogate, extensionProperties);

        _List.Add(resultSurrogate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesOrderDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>SalesOrder</c> having the data of the <c>SalesTable</c> table.
    /// </summary>
    /// <param name="_salesTable">
    /// Table buffer of <c>SalesTable</c> table.
    /// </param>
    /// <param name="_rsoTable">
    /// Table buffer of <c>RetailSalesTable</c> table.
    /// </param>
    /// <param name="_custTable">
    /// Table buffer of <c>CustTable</c> table.
    /// </param>
    /// <param name="_transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether to include line details and order attributes.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="includeDiscount">
    /// Whether to include the discount details, by default is false
    /// </param>
    /// <param name="_elementName">
    /// Name of the element to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>SalesTable</c> table.
    /// * Members must be in order of the SalesOrder DataContract
    /// Example:
    ///    <SalesOrder>
    ///      <AttributeValues />
    ///      <ChannelId />
    ///      <ChannelReferenceId />
    ///      <ChargeAmount />
    ///      <ChargeLines />
    ///      <CreatedDateTime />
    ///      <CustomerId />
    ///      <CustomerOrderTypeValue />
    ///      <DeliveryMode />
    ///      <GrossAmount />
    ///      <Id />
    ///      <InventoryLocationId />
    ///      <Name />
    ///      <NetAmountWithNoTax />
    ///      <PrepaymentAmountPaid />
    ///      <ReceiptEmail />
    ///      <ReceiptId />
    ///      <RequestedDeliveryDate />
    ///      <SalesId />
    ///      <SalesLines />
    ///      <Shipments />
    ///      <ShippingAddress />
    ///      <StaffId />
    ///      <StoreId />
    ///      <SubtotalAmount />
    ///      <TaxAmount />
    ///      <TerminalId />
    ///      <TotalAmount />
    ///      <TotalDiscount />
    ///      <TransactionType />
    ///      <TransactionTypeValue />
    ///      <DocumentStatusValue />
    ///      <RecordId />
    ///      <Status />
    ///      <StatusValue />
    ///    </SalesOrder>
    /// </returns>
    public static Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesOrder fillSalesOrderDetails(
        SalesTable _salesTable,
        RetailSalesTable _rsoTable,
        CustTable _custTable,
        RetailTransactionTable _transactionTable,
        boolean _includeDetails,
        boolean includeDiscount = false)
    {
        SalesTotals         salesTotals;
        AmountCur           totalAmount, totalTaxAmount, totalDiscountAmount, totalChargeAmount, subtotalAmount;
        AmountCur           prepaymentAmountPaid;
        LogisticsPostalAddress  deliveryAddress;
        SalesLine soLine;
        RetailSalesLine rsoLine;
        InventDim inventDim;
        MarkupTrans markupTrans;
        RetailSalesTableInstanceValue   retailSalesTableInstanceValue;
        EcoResAttribute                 ecoResAttribute;
        EcoResAttributeValue            ecoResAttributeValue;
        EcoResTextValue                 ecoResTextValue;
        RetailLoyaltyCard             retailLoyaltyCard;

        System.Collections.IList list;

        eventSource.EventWriteFillSalesOrderDetailsStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
        System.Diagnostics.Stopwatch salesOrderSW = new System.Diagnostics.Stopwatch();
        salesOrderSW.Start();

        // Retrieve the sum of all invoiced tax amounts for the given Sales Id.
        AmountCur taxAmountInvoiced(SalesId _salesId)
        {
            return (select sum(SumTax) from CustInvoiceJour where CustInvoiceJour.RefNum  == RefNum::SalesOrder && CustInvoiceJour.SalesId == _SalesId).SumTax;
        }

        eventSource.EventWriteSalesTotalsStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
        System.Diagnostics.Stopwatch totalsSW = new System.Diagnostics.Stopwatch();
        totalsSW.Start();

        SalesOrderTotals orderTotals;
        if (FeatureStateProvider::isFeatureEnabled(RetailEnableSalesOrderTotalsFeature::instance()))
        {
            orderTotals = SalesOrderTotals::find(_salesTable.SalesId);
        }

        if (orderTotals)
        {
            totalAmount         = orderTotals.OrderTotalAmount;
            totalTaxAmount      = orderTotals.OrderTotalTaxAmount;
            totalDiscountAmount = orderTotals.OrderTotalDiscountAmount;
            totalChargeAmount   = orderTotals.OrderTotalChargesAmount;
        }
        else
        {
            salesTotals     = SalesTotals::construct(_salesTable,SalesUpdate::All);
            salesTotals.calc();

            // totalAmount is the sales order balance due amount + previously invoiced amounts
            totalAmount     = salesTotals.totalAmount() + _salesTable.amountInvoiced();

            // totalTaxAmount is the sales order tax amount + any previously invoiced tax amounts.
            totalTaxAmount  = salesTotals.totalTaxAmount() + taxAmountInvoiced(_salesTable.SalesId);

            totalDiscountAmount = salesTotals.totalLineDisc();
            totalChargeAmount = salesTotals.totalMarkup();
        }
        totalsSW.Stop();
        eventSource.EventWriteSalesTotalsSalesTotalsFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), totalsSW.ElapsedMilliseconds);

        CRT.DataModel.SalesOrder contract = new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesOrder();

        if (_includeDetails)
        {
            eventSource.EventWriteFillHeaderAttributesStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
            System.Diagnostics.Stopwatch attributesSW = new System.Diagnostics.Stopwatch();
            attributesSW.Start();

            // Add attributes
            retailSalesTableInstanceValue = RetailSalesTableInstanceValue::findBySalesTable(_salesTable.SalesId, _salesTable.DataAreaId);

            // if this sales order has any attributes
            if ( retailSalesTableInstanceValue)
            {
                list = contract.AttributeValues;

                // Get all attributes (Name and Text value) for this sales order
                while select * from ecoResAttributeValue where ecoResAttributeValue.InstanceValue == retailSalesTableInstanceValue.RecId
                    join Name from ecoResAttribute where ecoResAttribute.RecId == ecoResAttributeValue.Attribute
                        join TextValue from ecoResTextValue where ecoResTextValue.RecId == ecoResAttributeValue.Value
                {
                    CRT.DataModel.AttributeTextValue v = new CRT.DataModel.AttributeTextValue();
                    v.Name = ecoResAttribute.Name;
                    v.TextValue = ecoResTextValue.TextValue;
                    list.Add(v);
                }
            }

            attributesSW.Stop();
            eventSource.EventWriteFillHeaderAttributesFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), attributesSW.ElapsedMilliseconds);
        }

        contract.ChannelId = _rsoTable.RetailChannel;
        contract.ChannelReferenceId = _rsoTable.ChannelReferenceId;
        contract.ChargeAmount = totalChargeAmount;

        if (_includeDetails)
        {
            eventSource.EventWriteFillHeaderChargesStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
            System.Diagnostics.Stopwatch chargesSW = new System.Diagnostics.Stopwatch();
            chargesSW.Start();

            list = contract.ChargeLines;

            // Add header level charges
            while select * from markupTrans
                where markupTrans.TransTableId == _salesTable.TableId
                && markupTrans.TransRecId == _salesTable.RecId
            {
                CRT.DataModel.ChargeLine c = RetailTransactionServiceTransactionsJson::fillMarkupTrans(markupTrans);
                list.Add(c);
            }

            chargesSW.Stop();
            eventSource.EventWriteFillHeaderChargesFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), chargesSW.ElapsedMilliseconds);
        }

        if (_salesTable.createdDateTime)
        {
            // salesTable createdDateTime is in UTC. specify the TimeSpan of 0 to indicate its UTC.
            contract.CreatedDateTime = new System.DateTimeOffset(_salesTable.createdDateTime, new System.TimeSpan(0, 0, 0));
        }

        contract.CurrencyCode = _salesTable.CurrencyCode;
        contract.CustomerId = _salesTable.CustAccount;
        contract.CustomerOrderTypeValue = RetailCustomerOrderType::Salesorder;
        contract.DeliveryMode = _salesTable.DlvMode;
        contract.GrossAmount = totalAmount;
        contract.Id = _transactionTable ? _transactionTable.TransactionId : ' ';
        contract.InventoryLocationId = _salesTable.InventLocationId;
        contract.LoyaltyCardId = RetailLoyaltyCard::find(_rsoTable.RetailLoyaltyCard).CardNumber;

        if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
        {
            // We will only calculate payment status when commerce payment is enabled.
            contract.PaymentStatus = _salesTable.mcrGetPaymStatus();
        }

        contract.Name = _custTable.name();
        if (contract.Name == '') contract.Name = _salesTable.SalesName;

        // total invoice amounts paid
        prepaymentAmountPaid = RetailPrePaymentTrans::paymentsMade(_salesTable.SalesId);
        contract.PrepaymentAmountPaid = prepaymentAmountPaid;
        contract.ReceiptEmail = _salesTable.Email;

        list = contract.ContactInformationCollection;
        if (_salesTable.Email)
        {
            CRT.DataModel.ContactInformation contactInformation = new CRT.DataModel.ContactInformation();
            contactInformation.ContactInformationTypeValue = enum2int(LogisticsElectronicAddressMethodType::Email);
            contactInformation.Value = _salesTable.Email;
            list.Add(contactInformation);
        }

        if (_salesTable.Phone)
        {
            CRT.DataModel.ContactInformation contactInformation = new CRT.DataModel.ContactInformation();
            contactInformation.ContactInformationTypeValue = enum2int(LogisticsElectronicAddressMethodType::Phone);
            contactInformation.Value = _salesTable.Phone;
            list.Add(contactInformation);
        }

        if (_salesTable.ReceiptDateRequested)
        {
            contract.RequestedDeliveryDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(_salesTable.ReceiptDateRequested, _rsoTable.RetailChannel);
        }

        if (_salesTable.ShippingDateConfirmed)
        {
            contract.ConfirmedShipDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(_salesTable.ShippingDateConfirmed, _rsoTable.RetailChannel);
        }

        contract.SalesId = _salesTable.SalesId;

        boolean allowPartialOrderEditingFeatureEnabled = RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement();

        if (_includeDetails)
        {
            eventSource.EventWriteFillSalesLinesStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
            System.Diagnostics.Stopwatch slSW = new System.Diagnostics.Stopwatch();
            slSW.Start();

            list = contract.SalesLines;

            while select soLine
                join inventDim where soLine.SalesId == _salesTable.SalesId
                    && inventDim.InventDimId == soLine.InventDimId
                outer join rsoLine where rsoLine.SalesLine == soLine.RecId
            {
                if (rsoLine && allowPartialOrderEditingFeatureEnabled && rsoLine.stockedInventoryQuantitiesNeverUpdated(soLine))
                {
                    RetailTransactionServiceTransactionsJson::updateLineQuantities(rsoLine);
                }

                CRT.DataModel.SalesLine s = RetailTransactionServiceTransactionsJson::fillSalesLineDetails(_salesTable, _rsoTable, soLine, rsoLine, inventDim, includeDiscount, allowPartialOrderEditingFeatureEnabled, _salesTable.RecId);
                list.Add(s);

                if (rsoLine && allowPartialOrderEditingFeatureEnabled && !s.IsVoided)
                {
                    if (contract.AggregateInventoryQuantities == null)
                    {
                        contract.AggregateInventoryQuantities = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryQuantities();
                    }

                    RetailTransactionServiceTransactionsJson::incrementAggregateQuantitiesFromSalesLine(contract.AggregateInventoryQuantities, s);
                }
            }

            slSW.Stop();
            eventSource.EventWriteFillSalesLinesFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), slSW.ElapsedMilliseconds);
        }
        var recallOrderOperationImprovementFeatureEnabled = RetailImprovedRecallOrderOperationInPosFeatureExposure::isEnabledInFeatureManagement();

        if ((allowPartialOrderEditingFeatureEnabled && !_includeDetails) || recallOrderOperationImprovementFeatureEnabled)
        {
            var aggregateQuantity = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryQuantities();
            var deliveryInformation = new Microsoft.Dynamics.Commerce.Runtime.DataModel.DeliveryInformation();

            var firstLine = true;
            LogisticsPostalAddressRecId address;
            DlvModeId deliveryMode;
            SalesShippingDateRequested deliveryDate;
            RetailPickupTimeslotStartTime pickupStartTime;
            RetailPickupTimeslotEndTime pickupEndTime;

            while select soLine
                where soLine.SalesId == _salesTable.SalesId
                outer join rsoLine where rsoLine.SalesLine == soLine.RecId
            {
                if (rsoLine)
                {
                    if (rsoLine.stockedInventoryQuantitiesNeverUpdated(soLine))
                    {
                        // Legacy data older than feature enablement will need updating once.
                        RetailTransactionServiceTransactionsJson::updateLineQuantities(rsoLine);
                    }

                    RetailTransactionServiceTransactionsJson::incrementAggregateQuantitiesFromRetailSalesLine(aggregateQuantity, soLine, rsoLine);
                }

                if (firstLine)
                {
                    deliveryMode = soLine.DlvMode;
                    address = soLine.DeliveryPostalAddress;
                    deliveryDate = soLine.ShippingDateRequested;
                    pickupStartTime = rsoLine.PickupStartTime;
                    pickupEndTime = rsoLine.PickupEndTime;

                    firstLine = false;
                }
                else
                {
                    // If any field is not same for all sales line, set the value to null, i.e. mixed result, should be viewed in lines.
                    if (deliveryMode != soLine.DlvMode)
                    {
                        deliveryMode = null;
                    }
                    if (address != soLine.DeliveryPostalAddress)
                    {
                        address = 0;
                    }
                    if (deliveryDate != soLine.ShippingDateRequested)
                    {
                        deliveryDate = dateNull();
                    }
                    if (pickupStartTime != rsoLine.PickupStartTime
                        || pickupEndTime != rsoLine.PickupEndTime)
                    {
                        pickupStartTime = 0;
                        pickupEndTime = 0;
                    }
                }
            }

            deliveryInformation.DeliveryMode = deliveryMode;
            if (deliveryDate !=  dateNull())
            {
                deliveryInformation.DeliveryDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(deliveryDate, _rsoTable.RetailChannel);
            }
            if (address)
            {
                deliveryAddress = LogisticsPostalAddress::findRecId(address);
                if (deliveryAddress)
                {
                    deliveryInformation.DeliveryAddress = RetailTransactionServiceTransactionsJson::fillSalesOrderAddress(deliveryAddress, _salesTable.DeliveryName, _custTable.Party);
                }
            }
            if (pickupStartTime != 0 || pickupEndTime != 0)
            {
                var startDateTime = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(deliveryDate, pickupStartTime));
                startDateTime = System.DateTime::SpecifyKind(startDateTime, System.DateTimeKind::Utc);
                var endDateTime = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(deliveryDate, pickupEndTime));
                endDateTime = System.DateTime::SpecifyKind(endDateTime, System.DateTimeKind::Utc);
                deliveryInformation.PickupTimeslotStartDateTime = new System.DateTimeOffset(startDateTime);
                deliveryInformation.PickupTimeslotEndDateTime = new System.DateTimeOffset(endDateTime);
            }

            System.Decimal returnedQty = _salesTable.getReturnedQty();
            aggregateQuantity.QuantityReturned = returnedQty;
            contract.AggregateInventoryQuantities = aggregateQuantity;
            contract.UnifiedDeliveryInformation = deliveryInformation;
        }

        if (_includeDetails)
        {
            if (RetailMustIncludeShipmentsInFillSalesOrderDetailsFlight::instance().isEnabled())
            {
                eventSource.EventWriteFillShipmentsDetailsStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
                System.Diagnostics.Stopwatch shipmentsSW = new System.Diagnostics.Stopwatch();
                shipmentsSW.Start();

                RetailTransactionServiceTransactionsJson::fillShipmentsDetails(_salesTable.SalesId, contract.Shipments);

                shipmentsSW.Stop();
                eventSource.EventWriteFillShipmentsDetailsFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), shipmentsSW.ElapsedMilliseconds);
            }

            deliveryAddress = LogisticsPostalAddress::findRecId(_salesTable.DeliveryPostalAddress);
            if (deliveryAddress)
            {
                contract.ShippingAddress = RetailTransactionServiceTransactionsJson::fillSalesOrderAddress(deliveryAddress, _salesTable.DeliveryName, _custTable.Party);
            }
        }

        if (_transactionTable)
        {
            contract.ReceiptId = _transactionTable.ReceiptId;
            contract.StaffId = _transactionTable.Staff;
            contract.StoreId = _transactionTable.Store;
            contract.TerminalId = _transactionTable.Terminal;

            subtotalAmount = RetailTransactionServiceTransactions::getTransactionSubtotalAmount(
                _transactionTable.TransactionId,
                _transactionTable.DataAreaId,
                _transactionTable.Channel,
                _transactionTable.Terminal);
            contract.SubtotalAmount = (subtotalAmount * -1);
            contract.NetAmountWithNoTax = (_transactionTable.netAmount * -1);
            contract.NetAmountWithTax = totalAmount;
        }

        contract.TaxAmount = totalTaxAmount;

        RetailTransactionServiceTransactionsJson::fillPaymentHistoryDetails(_salesTable.SalesId, contract.TenderLines);

        contract.TotalAmount = totalAmount;
        contract.TotalDiscount = totalDiscountAmount;

        if (_salesTable.SalesId != "")
        {
            // Assume it is a customer order
            contract.TransactionType = RetailTransactionType::CustomerOrder;
            contract.TransactionTypeValue = enum2int(RetailTransactionType::CustomerOrder);
        }
        else
        {
            contract.TransactionType = RetailTransactionType::PendingSalesOrder;
            contract.TransactionTypeValue = enum2int(RetailTransactionType::PendingSalesOrder);
        }

        contract.DocumentStatusValue = enum2int(_salesTable.DocumentStatus);
        contract.RecordId = _salesTable.RecId;

        contract.Status = _salesTable.SalesStatus;
        contract.StatusValue = RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(_salesTable.SalesStatus);

        if (RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement()
            || RetailImprovedRecallOrderOperationInPosFeatureExposure::isEnabledInFeatureManagement())
        {
            contract.DetailedOrderStatusValue = enum2int(RetailDetailedOrderInfoHelper::getDetailedOrderStatus(_salesTable));
        }

        contract.Comment = _salesTable.CustomerRef;

        salesOrderSW.Stop();
        eventSource.EventWriteFillSalesOrderDetailsFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), salesOrderSW.ElapsedMilliseconds);

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>ChargeLine</c> having the data of the <c>MarkupTrans</c> table.
    /// </summary>
    /// <param name="_markupTrans">
    /// Table buffer of <c>MarkupTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// ChargeLine object created from the <c>MarkupTrans</c> table.
    /// * Members must be in order of the ChargeLine DataContract
    /// Example:
    ///    <ChargeLine>
    ///      <ItemTaxGroupId />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <TaxLines />
    ///      <CalculatedAmount />
    ///      <ChargeCode />
    ///      <ChargeMethod />
    ///      <ChargeType />
    ///      <CurrencyCode />
    ///      <ModuleType />
    ///      <Value />
    ///    </ChargeLine>
    /// </returns>
    private static CRT.DataModel.ChargeLine fillMarkupTrans(MarkupTrans _markupTrans)
    {
        CRT.DataModel.ChargeLine line = new CRT.DataModel.ChargeLine();
        CRT.DataModel.TaxLine taxLine = new CRT.DataModel.TaxLine();
        System.Collections.IList list;

        line.ItemTaxGroupId = _markupTrans.TaxItemGroup;
        line.SalesTaxGroupId = _markupTrans.TaxGroup;
        line.TaxAmount = _markupTrans.TaxAmount;

        taxLine.Amount = _markupTrans.TaxAmount;
        list = line.TaxLines;
        list.Add(taxLine);

        line.CalculatedAmount = _markupTrans.CalculatedAmount;
        line.ChargeCode = _markupTrans.MarkupCode;
        line.ChargeMethod = _markupTrans.MarkupCategory;
        line.ChargeType = CRT.DataModel.ChargeType::ManualCharge;
        line.CurrencyCode = _markupTrans.CurrencyCode;
        line.ModuleType = _markupTrans.ModuleType;
        line.Value = _markupTrans.Value;

        return line;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>SalesLiner</c> having the data of the <c>SalesLine</c> table.
    /// </summary>
    /// <param name="_salesTable">
    /// Table buffer of <c>SalesTable</c> table.
    /// </param>
    /// <param name="_rsoTable">
    /// Table buffer of <c>RetailSalesTable</c> table.
    /// </param>
    /// <param name="_soLine">
    /// Table buffer of <c>SalesLine</c> table.
    /// </param>
    /// <param name="_rsoLine">
    /// Table buffer of <c>RetailSalesLine</c> table.
    /// </param>
    /// <param name="_inventDim">
    /// Table buffer of <c>InventDim</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="includeDiscount">
    /// Whether to include the discount details, by default is false.
    /// </param>
    /// <param name="includeAllQuantities">
    /// Whether to include the full set of inventory quantities (i.e., including
    /// QuantityNotProcessed, QuantityReserved, QuantityPicked, QuantityPacked, and QuantityInvoiced).
    /// Defaults to false.
    /// </param>
    /// <param name="_salesOrderRecId">
    /// The sales order rec id.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>SalesLine</c> table.
    /// * Members must be in order of the SalesLine DataContract
    /// Example:
    ///    <SalesLine>
    ///      <ItemId />
    ///      <ItemTaxGroupId />
    ///      <NetAmount />
    ///      <Price />
    ///      <Quantity />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <TaxLines />
    ///      <ChargeLines />
    ///      <DeliveryMode />
    ///      <InventoryDimensionId />
    ///      <InventoryLocationId />
    ///      <LineDiscount />
    ///      <LineNumber />
    ///      <ListingId />
    ///      <ShippingAddress />
    ///    </SalesLine>
    /// </returns>
    private static CRT.DataModel.SalesLine fillSalesLineDetails(SalesTable _salesTable, RetailSalesTable _rsoTable, SalesLine _soLine, RetailSalesLine _rsoLine, InventDim _inventDim, boolean includeDiscount = false, boolean includeAllQuantities = false, RecId _salesOrderRecId = 0)
    {
        LogisticsPostalAddress      deliveryAddress;
        MarkupTrans                 markupTrans;
        RetailSalesDiscountLine     salesLineDiscount;
        RetailPeriodicDiscount      retailDiscount;
        RetailTenderDiscount        tenderDiscount;
        MCRSalesLine                mcrSalesLine;

        DiscAmount lineDiscount = 0, periodicDiscount = 0, totalDiscount = 0, tenderDiscountAmount = 0;
        boolean hasDiscountLines = false;
        boolean needBackfill = _soLine.LineDisc 
            && !_rsoLine.LineDscAmount 
            && !_rsoLine.PeriodicDiscount 
            && !_rsoLine.TotalDiscount 
            && !_rsoLine.TenderDiscount;

        InventTable                 inventTable;
        InventDimCombination        inventDimCombination;
        RecId                       productId;
        InventDimParm               inventDimParm;
        InventDimId                 inventDimId;
        EcoResProduct               ecoResProduct;
        Int64                         listingId;

        eventSource.EventWriteFillSalesLineDetailsStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));
        System.Diagnostics.Stopwatch salesLineSW = new System.Diagnostics.Stopwatch();
        salesLineSW.Start();

        System.Collections.IList list;
        CRT.DataModel.SalesLine contract = new CRT.DataModel.SalesLine();

        contract.ItemId = _soLine.ItemId;
        contract.ItemTaxGroupId = _soLine.TaxItemGroup;
        contract.NetAmount = _soLine.LineAmount;
        contract.Price = _soLine.SalesPrice;
        contract.Quantity = _soLine.SalesQty;
        contract.SalesTaxGroupId = _soLine.TaxGroup;

        //Taxes
        list = contract.TaxLines;
        CRT.DataModel.TaxLine t = new CRT.DataModel.TaxLine();
        t.Amount = (_soLine.LineAmount - _soLine.lineAmountExclTax());
        list.Add(t);

        System.Diagnostics.Stopwatch chargesSW = new System.Diagnostics.Stopwatch();
        chargesSW.Start();
        eventSource.EventWriteFillSaleslLineChargesStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));

        //Add line level charges
        list = contract.ChargeLines;
        while select * from markupTrans
            where markupTrans.TransTableId == _soLine.TableId
            && markupTrans.TransRecId == _soLine.RecId
        {
            CRT.DataModel.ChargeLine c = RetailTransactionServiceTransactionsJson::fillMarkupTrans(markupTrans);
            list.Add(c);
        }

        chargesSW.Stop();
        eventSource.EventWriteFillSaleslLineChargesFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), chargesSW.ElapsedMilliseconds);

        contract.DeliveryMode = _soLine.DlvMode;

        if (_soLine.ShippingDateConfirmed)
        {
            contract.ConfirmedShipDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(_soLine.ShippingDateConfirmed, _rsoTable.RetailChannel);
        }

        if (includeDiscount)
        {
            System.Diagnostics.Stopwatch discountSW = new System.Diagnostics.Stopwatch();
            discountSW.Start();
            eventSource.EventWriteFillSalesLineDiscountStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));

            list = contract.DiscountLines;

            // add discount data
            while select salesLineDiscount
                where salesLineDiscount.InventTransId == _soLine.InventTransId
            outer join Name from retailDiscount
                where salesLineDiscount.PeriodicDiscountOfferId
                    && retailDiscount.OfferId == salesLineDiscount.PeriodicDiscountOfferId
                    && salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Periodic
            outer join Name from tenderDiscount
                where salesLineDiscount.PeriodicDiscountOfferId
                    && retailDiscount.OfferId == tenderDiscount.OfferId
                    && salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Tender
            {
                hasDiscountLines = true;
                if (needBackfill)
                {
                    if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Periodic)
                    {
                        periodicDiscount += salesLineDiscount.Amount;
                    }
                    else if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Customer)
                    {
                        if (salesLineDiscount.CustomerDiscountType != RetailCustomerDiscountType::TotalDiscount)
                        {
                            lineDiscount += salesLineDiscount.Amount;
                        }
                        else
                        {
                            totalDiscount += salesLineDiscount.Amount;
                        }
                    }
                    else if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Manual)
                    {
                        if (salesLineDiscount.ManualDiscountType == RetailManualDiscountType::LineDiscountAmount ||
                            salesLineDiscount.ManualDiscountType == RetailManualDiscountType::LineDiscountPercent)
                        {
                            lineDiscount += salesLineDiscount.Amount;
                        }
                        else
                        {
                            totalDiscount += salesLineDiscount.Amount;
                        }
                    }
                    if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Tender)
                    {
                        tenderDiscountAmount += salesLineDiscount.Amount;
                    }
                }
                // fill in discount data
                CRT.DataModel.DiscountLine d = RetailTransactionServiceTransactionsJson::fillSalesLineDiscountDetails(salesLineDiscount, retailDiscount, tenderDiscount, _soLine.LineNum, _soLine.SalesQty);
                list.Add(d);

                discountSW.Stop();
                eventSource.EventWriteFillSalesLineDiscountFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), discountSW.ElapsedMilliseconds);
            }

            if (needBackfill)
            {
                // make up a discount line if non exists.
                if (!hasDiscountLines)
                {
                    discountSW.Reset();
                    eventSource.EventWriteFillSalesLineDiscountStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json));

                    lineDiscount = _soLine.LineDisc * _soLine.SalesQty;

                    salesLineDiscount.initValue();
                    salesLineDiscount.InventTransId = _soLine.InventTransId;
                    salesLineDiscount.DiscountOriginType = RetailDiscountOriginType::Customer;
                    salesLineDiscount.CustomerDiscountType = RetailCustomerDiscountType::Line;
                    salesLineDiscount.Amount = _soLine.LineDisc;
                    if (_soLine.SalesQty)
                    {
                        salesLineDiscount.DiscountAmount = _soLine.LineDisc / _soLine.SalesQty;
                    }

                    retailDiscount.clear();

                    CRT.DataModel.DiscountLine d = RetailTransactionServiceTransactionsJson::fillSalesLineDiscountDetails(salesLineDiscount, retailDiscount, tenderDiscount, _soLine.LineNum, _soLine.SalesQty);
                    list.Add(d);

                    discountSW.Stop();
                    eventSource.EventWriteFillSalesLineDiscountFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), discountSW.ElapsedMilliseconds);
                }
            }
            else
            {
                lineDiscount = _rsoLine.LineDscAmount;
                periodicDiscount = _rsoLine.PeriodicDiscount;
                totalDiscount = _rsoLine.TotalDiscount;
                tenderDiscountAmount = _rsoLine.TenderDiscount;
            }
        }
        else
        {
            if (needBackfill)
            {
                lineDiscount = _soLine.LineDisc * _soLine.SalesQty;
            }
            else
            {
                lineDiscount = _rsoLine.LineDscAmount;
                periodicDiscount = _rsoLine.PeriodicDiscount;
                totalDiscount = _rsoLine.TotalDiscount;
                tenderDiscountAmount = _rsoLine.TenderDiscount;
            }
        }

        if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            RetailTransactionServiceTransactionsJson::fillSalesLinePriceDetails(contract, _soLine);
        }

        mcrSalesLine = _soLine.mcrSalesLine();
        contract.ElectronicDeliveryEmailAddress = mcrSalesLine.GiftCardRecipientEmail;

        contract.InventoryDimensionId = _soLine.InventDimId;
        contract.InventoryLocationId = _inventDim.InventLocationId;

        contract.IsPriceOverridden = _rsoLine.IsPriceOverridden;

        contract.LineDiscount = lineDiscount;
        contract.LinePercentageDiscount = _rsoLine.LinePercentageDiscount;
        contract.LineNumber = _soLine.LineNum;

        if (_rsoLine && _rsoLine.ListingId)
        {
            listingId = str2Int64(_rsoLine.ListingId);
        }
        else
        {
            productId = (select firstOnly Product
                from inventTable
                where inventTable.ItemId == _soLine.ItemId).Product;

            ecoResProduct = EcoResProduct::find(productId);

            if (ecoResProduct != null &&
                !ecoResProduct.isDistinctProduct())
            {
                inventDimParm.setAllProductDimensions();
                _inventDim.clearNotSelectedDim(inventDimParm);
                inventDimId = InventDim::findOrCreate(_inventDim).inventDimId;

                productId = (select firstOnly DistinctProductVariant
                    from inventDimCombination
                    where inventDimCombination.ItemId == _soLine.ItemId
                        && inventDimCombination.InventDimId == inventDimId).DistinctProductVariant;
            }

            listingId = productId;
        }
        contract.ListingId = listingId;
        contract.LineManualDiscountAmount = _rsoLine.LineManualDiscountAmount;
        contract.LineManualDiscountPercentage = _rsoLine.LineManualDiscountPercentage;
        contract.OriginalPrice = _rsoLine.OriginalPrice;
        contract.PeriodicDiscount = periodicDiscount;
        contract.PeriodicPercentageDiscount = _rsoLine.PeriodicPercentageDiscount;
        contract.TenderDiscountAmount = tenderDiscountAmount;
        contract.TenderDiscountPercentage = _rsoLine.TenderDiscountPercentage;

        //ProductId is a copy of ListingId
        contract.ProductId = listingId;

        // Historically this value is populated with the sales unit of measure,
        // instead of the inventory unit of measure (which is used in all other scenarios).
        contract.QuantityInvoiced = _soLine.invoicedInTotal();

        if (includeAllQuantities)
        {
            if (RetailFulfillmentQuantitiesInSalesUomFlight::instance().isEnabled())
            {
                contract.QuantityNotProcessed = _rsoLine.getQuantityNotProcessedInSalesUnit(_soLine);
                contract.QuantityReserved = _rsoLine.getQuantityPhysicallyReservedInSalesUnit(_soLine);
                contract.QuantityPacked = _rsoLine.getQuantityPackedInSalesUnit(_soLine);
                contract.QuantityPicked = _rsoLine.getQuantityPickedInSalesUnit(_soLine);
                contract.QuantityOrdered = _rsoLine.getQuantityOrderedInSalesUnit(_soLine);
                contract.QuantityCanceled = _rsoLine.getQuantityCanceledInSalesUnit(_soLine);
            }
            else
            {
                // These values are guaranteed to be in Inventory UoM.
                contract.QuantityNotProcessed = _rsoLine.QuantityNotProcessed;
                contract.QuantityReserved = _rsoLine.QuantityPhysicallyReserved;
                contract.QuantityPacked = _rsoLine.QuantityPacked;
                contract.QuantityPicked = _rsoLine.QuantityPicked;
                contract.QuantityOrdered = _soLine.QtyOrdered;
                contract.QuantityCanceled = _rsoLine.quantityCanceled(_soLine);
            }

            var _inventTable = _soLine.inventTable();
            contract.InventOrderUnitOfMeasure = _inventTable.inventUnitId();
            contract.UnitOfMeasureSymbol = _inventTable.salesUnitId();
            contract.SalesOrderUnitOfMeasure = contract.UnitOfMeasureSymbol;
        }

        deliveryAddress = LogisticsPostalAddress::findRecId(_soLine.DeliveryPostalAddress);
        if (deliveryAddress)
        {
            DirPartyRecId customerParty = CustTable::find(_salesTable.custAccount).Party;
            contract.ShippingAddress = RetailTransactionServiceTransactionsJson::fillSalesOrderAddress(deliveryAddress, _soLine.DeliveryName, customerParty);
        }

        contract.TotalDiscount = totalDiscount;
        contract.TotalPercentageDiscount = _rsoLine.TotalPctDiscount;

        salesLineSW.Stop();
        eventSource.EventWriteFillSalesLineDetailsFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Json), salesLineSW.ElapsedMilliseconds);

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineDiscountDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>DiscountLine</c> having the data of the <c>RetailSalesDiscountLine</c> table.
    /// </summary>
    /// <param name="discountLine">
    /// Table buffer of <c>RetailSalesDiscountLine</c> table.
    /// </param>
    /// <param name="retailDiscount">
    /// Table buffer of <c>RetailPeriodicDiscount</c> table.
    /// </param>
    /// <param name="retailDiscount">
    /// Table buffer of <c>RetailTenderDiscount</c> table.
    /// </param>
    /// <param name="lineNum">
    /// The line number
    /// </param>
    /// <param name="salesQty">
    /// The sales quantity
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionDiscountTrans</c> table.
    /// * Members must be in order of the DiscountLine DataContract
    /// Example:
    ///    <DiscountLine>
    ///      <SaleLineNumber />
    ///      <OfferId />
    ///      <OfferName />
    ///      <DealPrice />
    ///      <Amount />
    ///      <Percentage />
    ///      <EffectiveAmount />
    ///      <Percentage />
    ///      <DiscountLineTypeValue />
    ///      <ManualDiscountTypeValue />
    ///      <CustomerDiscountTypeValue />
    ///      <PeriodicDiscountTypeValue />
    ///      <DiscountApplicationGroup />
    ///      <ConcurrencyModeValue />
    ///      <IsCompoundable />
    ///      <DiscountCode />
    ///      <IsDiscountCodeRequired />
    ///      <ThresholdAmountRequired />
    ///    </DiscountLine>
    /// </returns>
    internal protected static CRT.DataModel.DiscountLine fillSalesLineDiscountDetails(
        RetailSalesDiscountLine  discountLine,
        RetailPeriodicDiscount   retailDiscount,
        RetailTenderDiscount     tenderDiscount,
        LineNum                  lineNum,
        SalesOrderedQty          salesQty)
    {
        DiscAmount discountAmount;

        CRT.DataModel.DiscountLine contract = new CRT.DataModel.DiscountLine();

        // Backfill discount amount for R2 customer orders.
        discountAmount = discountLine.DiscountAmount;
        if (!discountAmount && !discountLine.Percentage)
        {
            discountAmount = salesQty ? discountLine.Amount / salesQty : 0;
        }

        contract.Amount = discountAmount;
        contract.CustomerDiscountTypeValue = discountLine.CustomerDiscountType;
        contract.DealPrice = discountLine.DealPrice;
        contract.DiscountCode = discountLine.DiscountCode;
        contract.DiscountLineTypeValue = discountLine.DiscountOriginType;
        contract.EffectiveAmount = discountLine.Amount;
        contract.ManualDiscountTypeValue = discountLine.ManualDiscountType;
        contract.OfferId = discountLine.PeriodicDiscountOfferId;
        contract.OfferName = discountLine.DiscountOriginType == RetailDiscountOriginType::Periodic ? retailDiscount.Name : tenderDiscount.Name;
        contract.Percentage = discountLine.Percentage;
        contract.SaleLineNumber = lineNum;
        contract.BundleId = discountLine.BundleId;

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLinePriceDetails</Name>
				<Source><![CDATA[
    internal protected static void fillSalesLinePriceDetails(CRT.DataModel.SalesLine _contract, SalesLine _soLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesOrderAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the <c>CustomerAddress</c> having the data of the <c>LogisticsPostalAddress</c> table.
    /// </summary>
    /// <param name="_deliveryAddress">
    /// Table buffer of <c>LogisticsPostalAddress</c> table.
    /// </param>
    /// <param name="_deliveryName">
    /// Delivery Name
    /// </param>
    /// <param name="_customerParty">
    /// Party associated with the customer
    /// </param>
    /// <returns>
    /// Address object from the <c>LogisticsPostalAddress</c> table.
    /// * Members must be in order of the CustomerAddress DataContract
    /// Example:
    ///    <ShippingAddress>
    ///      <City />
    ///      <County />
    ///      <Name />
    ///      <DistrictName />
    ///      <State />
    ///      <Street />
    ///      <StreetNumber />
    ///      <ThreeLetterISORegionName />
    ///      <ZipCode />
    ///      <BuildingCompliment />
    ///      <FullAddress />
    ///      <Postbox />
    ///      <RecordId />
    ///    </ShippingAddress>
    /// </returns>
    private static CRT.DataModel.Address fillSalesOrderAddress(LogisticsPostalAddress _deliveryAddress, str _deliveryName, DirPartyRecId _customerParty)
    {
        CRT.DataModel.Address contract = new CRT.DataModel.Address();

        contract.BuildingCompliment = _deliveryAddress.BuildingCompliment;
        contract.City = _deliveryAddress.City;
        contract.County = _deliveryAddress.County;
        contract.DistrictName = _deliveryAddress.DistrictName;
        contract.FullAddress = _deliveryAddress.Address;
        contract.Name = _deliveryName;
        contract.Postbox = _deliveryAddress.PostBox;
        contract.RecordId = _deliveryAddress.RecId;
        contract.State = _deliveryAddress.State;
        contract.Street = _deliveryAddress.Street;
        contract.StreetNumber = _deliveryAddress.StreetNumber;
        contract.ThreeLetterISORegionName = _deliveryAddress.CountryRegionId;
        contract.ZipCode = _deliveryAddress.ZipCode;

        DirPartyLocation dirPartyLocation = RetailTransactionServiceTransactionsJson::GetDirPartyLocationPrimaryForCustomerPostalAddress(_deliveryAddress, _customerParty);

        if (RetailMustFillSalesTransDetailsInAddTransactionToListFlight::instance().isEnabled())
        {
            LogisticsLocationRole logisticsLocationRole = RetailTransactionServiceTransactionsJson::GetLogisticsLocationRoleForPostalAddress(_deliveryAddress);

            contract.IsPrimary = dirPartyLocation.IsPrimary;
            contract.LogisticsLocationRoleRecordId = logisticsLocationRole.RecId;
        }

        if (RetailDirPartyLocationChangesFlight::instance().isEnabled())
        {
            contract.DirectoryPartyLocationRecordId = dirPartyLocation.RecId;
        }

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillShipmentsDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the shipping information of delivered sales order.
    /// </summary>
    /// <param name="_salesId">
    /// Sales identifier.
    /// </param>
    /// <param name="_shipmentList">
    /// The list of shipments to be updated.
    /// </param>
    /// <remarks>
    /// Method runs the <c>RetailGetShipmentInfo</c> query and updates the given list of shipments.
    /// </remarks>
    private static void fillShipmentsDetails(str _salesId, System.Collections.IList _shipmentList)
    {
        Query query = new Query(queryStr(RetailGetShipmentInfo));

        // Add salesOrderId to where clause.
        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(CustPackingSlipJour)),
                            fieldNum(CustPackingSlipJour, SalesId)).value(queryValue(_salesId));

        QueryRun queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            CRT.DataModel.Shipment contract = new CRT.DataModel.Shipment();
            System.Collections.IList list = contract.ShipmentLines;

            CustPackingSlipJour custPackingSlipJour = queryRun.get(tableNum(CustPackingSlipJour));

            if (custPackingSlipJour.RecId)
            {
                SalesPackingSlipTrackingInformation salesPackingSlipTrackingInformation;
                ShipCarrierStaging   shipCarrierStaging;

                contract.DeliveryMode = custPackingSlipJour.DlvMode;
                contract.SalesId = custPackingSlipJour.SalesId;
                contract.CarrierId = custPackingSlipJour.ShipCarrierId;
                contract.ShipmentId = custPackingSlipJour.PackingSlipId;
                contract.TermsOfDelivery = custPackingSlipJour.DlvTerm;

                str packingSlipId = custPackingSlipJour.PackingSlipId;

                // Tracking number and tracking URL.
                // Look for information in SalesPackingSlipTrackingInformation, ShipCarrierTracking and ShipCarrierPackage tables in order.

                select firstOnly RecId, TrackingNumber, TrackingURL
                    from salesPackingSlipTrackingInformation
                    where salesPackingSlipTrackingInformation.PackingSlipId == packingSlipId;

                select firstOnly RecId, TrackingNumber, Weight, WeightText
                    from shipCarrierStaging
                    where shipCarrierStaging.PackingSlipId == packingSlipId;

                if (salesPackingSlipTrackingInformation.RecId)
                {
                    contract.TrackingNumber = salesPackingSlipTrackingInformation.TrackingNumber;
                    contract.TrackingUrl = salesPackingSlipTrackingInformation.TrackingURL;
                }
                else
                {
                    ShipCarrierTracking shipCarrierTracking;
                    select firstOnly RecId, TrackingNumber, URL
                        from shipCarrierTracking
                        where shipCarrierTracking.PackingSlipId == packingSlipId;

                    if (shipCarrierTracking.RecId)
                    {
                        contract.TrackingNumber = shipCarrierTracking.TrackingNumber;
                        contract.TrackingUrl = shipCarrierTracking.URL;
                    }
                    else
                    {
                        contract.TrackingNumber = shipCarrierStaging.TrackingNumber;
                    }
                }

                // Weight and weight Unit.
                // Look for information in ShipCarrierPackage, ShipCarrierTracking and CustPackingSlipJour tables in order.

                ShipCarrierPackage shipCarrierPackage;
                select firstOnly RecId, Weight, UnitId
                from shipCarrierPackage
                where shipCarrierPackage.PackingSlipId == packingSlipId;

                if (shipCarrierPackage.RecId)
                {
                    contract.ShippingWeight = shipCarrierPackage.Weight;
                    contract.WeightUnit = shipCarrierPackage.UnitId;
                }
                else if (shipCarrierStaging.RecId)
                {
                    contract.ShippingWeight = shipCarrierStaging.Weight;
                    contract.WeightUnit = shipCarrierStaging.WeightText;
                }
                else
                {
                    contract.ShippingWeight = custPackingSlipJour.Weight;
                }

                // ShipDate node.
                if (custPackingSlipJour.DeliveryDate)
                {
                    contract.ShipDate = new System.DateTimeOffset(Global::utcDateTime2SystemDateTime(custPackingSlipJour.deliveryDateTime()));
                }

                // DeliveryAddress node.
                LogisticsPostalAddress logisticsPostalAddress = LogisticsPostalAddress::findRecId(custPackingSlipJour.DeliveryPostalAddress);
                if (logisticsPostalAddress)
                {
                    DirPartyRecId customerParty = CustTable::find(custPackingSlipJour.OrderAccount).Party;
                    contract.DeliveryAddress = RetailTransactionServiceTransactionsJson::fillSalesOrderAddress(logisticsPostalAddress, custPackingSlipJour.DeliveryName, customerParty);
                }

                // Packing slip lines.
                CustPackingSlipTrans custPackingSlipTrans;
                while select PackingSlipId, Qty, Name, InventDimId, ItemId, Ordered, Remain, LineNum, InventTransId
                    from custPackingSlipTrans
                    where custPackingSlipTrans.PackingSlipId == packingSlipId
                {
                    CRT.DataModel.ShipmentLine contractLine = new CRT.DataModel.ShipmentLine();
                    contractLine.DeliveredQuantity = custPackingSlipTrans.Qty;
                    contractLine.Description = custPackingSlipTrans.Name;
                    contractLine.InventDimId = custPackingSlipTrans.InventDimId;
                    contractLine.InventoryTransactionId = custPackingSlipTrans.InventTransId;
                    contractLine.ItemId = custPackingSlipTrans.ItemId;
                    contractLine.OrderedQuantity = custPackingSlipTrans.Ordered;
                    contractLine.RemainingQuantity = custPackingSlipTrans.Remain;
                    contractLine.ShipmentLineId = RetailTransactionServiceUtilities::lineNumToString(custPackingSlipTrans.LineNum);
                    contractLine.ShipmentId = packingSlipId;
                    list.Add(contractLine);
                }

                _shipmentList.Add(contract);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPaymentHistoryDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method adds the Sales Order payment activity/history in the form of the <c>RetailTransactionPaymentTrans</c> table schema.
    /// </summary>
    /// <param name = "_salesId">The ID of the sales order.</param>
    /// <param name = "_tenderLines">The <c>IList</c> for payment history records.</param>
    private static void fillPaymentHistoryDetails(
        SalesId _salesId,
        System.Collections.IList _tenderLines)
    {
        RetailTransactionPaymentTrans tmpPaymentTrans;
        RetailChannelTable channelTable;
        RetailTransactionTable transactionTable;

        // refactor from CustomerOrder code
        LedgerJournalTrans  ledgerJournalTrans;
        AmountCur amount;

        // <GEERU>
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        // </GEERU>

        // Add payment history entry to collection
        void AddHistoryEntry(str _paymentType, AmountCur _amount, CurrencyCode _currency, TransDate _date)
        {
            // Fill a temporary RetailTransactionPaymentTrans record to feed the filPaymentTransDetails(...) method.
            tmpPaymentTrans.clear();
            tmpPaymentTrans.amountTendered = _amount;
            tmpPaymentTrans.amountMST = _amount;
            tmpPaymentTrans.currency = _currency;
            tmpPaymentTrans.transDate = _date;

            CRT.DataModel.TenderLine t = RetailTransactionServiceTransactionsJson::fillPaymentTransDetails(tmpPaymentTrans, channelTable);
            _tenderLines.Add(t);
        }

        //
        // This method is patterned after RetailTransactionServiceOrders::AddPaymentHistoryXml(...), which aggregates similar payment details for a given Sales Order.
        //

        //
        // 1. Get ONLY Payments created from POS.
        //
        while select tmpPaymentTrans
            exists join transactionTable
            where transactionTable.salesOrderId == _salesId
                && tmpPaymentTrans.Channel == transactionTable.Channel
                && tmpPaymentTrans.store == transactionTable.store
                && tmpPaymentTrans.terminal == transactionTable.terminal
                && tmpPaymentTrans.transactionId == transactionTable.transactionId
        {
            CRT.DataModel.TenderLine t = RetailTransactionServiceTransactionsJson::fillPaymentTransDetails(tmpPaymentTrans, channelTable);
            _tenderLines.Add(t);
        }

        //
        // 2. Get ONLY MCR payments created from call center.
        //
        while select
            PaymReference,
            PaymMode,
            AmountCurCredit,
            AmountCurDebit,
            Prepayment,
            CreatedDateTime,
            CurrencyCode,
            TransDate
            // <GEERU>
        ,Accounttype
            // </GEERU>
        from ledgerJournalTrans
        where LedgerJournalTrans.MCRPaymOrderID == _salesId
            && LedgerJournalTrans.TransactionType == LedgerTransType::Payment
        {
            // <GEERU>
            if (countryRegion_W && ledgerJournalTrans.AccountType != LedgerJournalAcType::Cust)
            {
                amount = (ledgerJournalTrans.AmountCurDebit - ledgerJournalTrans.AmountCurCredit);
            }
            else
            {
                // </GEERU>
                amount = (ledgerJournalTrans.AmountCurCredit - ledgerJournalTrans.AmountCurDebit);
                // <GEERU>
            }
            // </GEERU>

            AddHistoryEntry(
                ledgerJournalTrans.PaymMode,
                amount,
                ledgerJournalTrans.CurrencyCode,
                ledgerJournalTrans.TransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPaymentTransDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// </summary>
    /// <param name="_paymentTrans">
    /// Table buffer of <c>RetailTransactionPaymentTrans</c> table.
    /// </param>
    /// <param name="_channel">
    /// Table buffer of <c>RetailChannelTable</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionSalesTrans</c> table.
    /// * Members must be in order of the SalesLine DataContract
    /// Example:
    ///    <TenderLine>
    ///     <Amount/>
    ///     <AmountInCompanyCurrency/>
    ///     <AmountInTenderedCurrency/>
    ///     <CardTypeId/>
    ///     <CompanyCurrencyExchangeRate/>
    ///     <CreditMemoId/>
    ///     <Currency/>
    ///     <CustomerId/>
    ///     <ExchangeRate/>
    ///     <GiftCardId/>
    ///     <IsChangeLine/>
    ///     <IsHistorical/>
    ///     <IsVoidable/>
    ///     <LineNumber/>
    ///     <LoyaltyCardId/>
    ///     <TenderTypeId/>
    ///     <Authorization/>
    ///     <IsPreProcessed/>
    ///     <MaskedCardNumber/>
    ///     <TenderDate/>
    ///     <TransactionStatusValue/>
    ///    </TenderLine>
    /// </returns>
    private static CRT.DataModel.TenderLine fillPaymentTransDetails(
        RetailTransactionPaymentTrans _paymentTrans,
        RetailChannelTable _channel)
    {
        CRT.DataModel.TenderLine contract = new CRT.DataModel.TenderLine();

        // DataContractSerializer requires fields to be ordered (base types first, alphabetic)

        // TaxableItem fields

        contract.Amount = _paymentTrans.amountTendered;
        contract.AmountInCompanyCurrency = _paymentTrans.amountMST;
        contract.AmountInTenderedCurrency = _paymentTrans.amountTendered;
        contract.CardTypeId = _paymentTrans.cardTypeId;
        //addElement('CashBackAmount', '');   //decimal CashBackAmount
        contract.CompanyCurrencyExchangeRate = _paymentTrans.exchRateMST;
        contract.CreditMemoId = _paymentTrans.creditVoucherId;
        contract.Currency = _paymentTrans.currency;
        contract.CustomerId = _paymentTrans.cardOrAccount;
        contract.ExchangeRate = _paymentTrans.exchRate;
        contract.GiftCardId = _paymentTrans.giftCardId;
        contract.IsChangeLine = _paymentTrans.changeLine ? true : false;
        contract.IsHistorical = true;
        contract.IsVoidable = false;
        contract.LineNumber = _paymentTrans.lineNum;
        contract.LoyaltyCardId = _paymentTrans.loyaltyCardId;
        contract.TenderTypeId = _paymentTrans.tenderType;
        contract.StatusValue = _paymentTrans.transactionStatus; //int StatusValue (int value from enum TenderLineStatus)

        // From TenderLine
        contract.Authorization = _paymentTrans.paymentAuthorization;
        //addElement('IncomeExpenseAccountTypeValue', '');   //int IncomeExpenseAccountTypeValue (int value from enum IncomeExpenseAccountType)
        //addElement('IsPreProcessed', '');   //bool IsPreProcessed
        contract.MaskedCardNumber = _paymentTrans.cardOrAccount;

        contract.TenderDate = new System.DateTimeOffset(DateTimeUtil::newDateTime(_paymentTrans.transDate, _paymentTrans.transTime));

        contract.TransactionStatusValue = _paymentTrans.transactionStatus;   //int TransactionStatusValue (int value from enum TransactionStatus)

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillQuoteDetails</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesOrder fillQuoteDetails(
        SalesQuotationTable _salesQuotationTable,
        RetailSalesQuotationTable _rsqTable,
        CustTable _custTable,
        boolean _includeDetails)
    {
        SalesQuotationTotals    salesTotals;
        AmountCur               totalAmount, totalTaxAmount, totalDiscountAmount, totalChargeAmount;
        LogisticsPostalAddress  deliveryAddress;
        SalesQuotationLine      salesQuotationLine;
        RetailSalesQuotationLine rsqLine;

        InventDim               inventDim;

        CRT.DataModel.SalesOrder contract = new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesOrder();

        salesTotals     = SalesQuotationTotals::construct(_salesQuotationTable,SalesUpdate::All);
        salesTotals.calc();
        // totalAmount is the sales order balance due amount + previously invoiced amounts
        totalAmount     = salesTotals.totalAmount();
        totalTaxAmount  = salesTotals.totalTaxAmount();
        totalDiscountAmount = salesTotals.totalLineDisc();
        totalChargeAmount = salesTotals.totalMarkup();

        contract.ChargeAmount = totalChargeAmount;
        contract.ChannelReferenceId = _rsqTable.ChannelReferenceId;

        if (_salesQuotationTable.createdDateTime)
        {
            contract.CreatedDateTime = new System.DateTimeOffset(_salesQuotationTable.CreatedDateTime);
        }

        contract.CustomerId = _salesQuotationTable.CustAccount;
        contract.CustomerOrderTypeValue = RetailCustomerOrderType::Quotation;
        contract.DeliveryMode = _salesQuotationTable.DlvMode;
        contract.Id = _salesQuotationTable.QuotationId;
        contract.InventoryLocationId = _salesQuotationTable.InventLocationId;

        if (_salesQuotationTable.QuotationExpiryDate)
        {
            contract.QuotationExpiryDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(_salesQuotationTable.QuotationExpiryDate, _rsqTable.RetailChannel);
        }

        contract.Name = _custTable.name();
        if (contract.Name == '') contract.Name = _salesQuotationTable.QuotationName;

        contract.ReceiptEmail = _salesQuotationTable.Email;

        if (_salesQuotationTable.ReceiptDateRequested)
        {
            contract.RequestedDeliveryDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(_salesQuotationTable.ReceiptDateRequested, _rsqTable.RetailChannel);
        }

        contract.SalesId = _salesQuotationTable.QuotationId;

        contract.TaxAmount = totalTaxAmount;
        contract.TotalAmount = totalAmount;
        contract.TotalDiscount = totalDiscountAmount;

        // Assume it is a customer order
        contract.TransactionType = RetailTransactionType::CustomerOrder;
        contract.TransactionTypeValue = enum2int(RetailTransactionType::CustomerOrder);

        contract.RecordId = _salesQuotationTable.RecId;

        contract.Status = _salesQuotationTable.QuotationStatus;
        contract.StatusValue = RetailTransactionServiceTransactionsJson::convertQuotationStatusToRetailSalesStatus(_salesQuotationTable.QuotationStatus);
        contract.DocumentStatus = _salesQuotationTable.salesOrderDocumentStatus();
        contract.ChannelId = _rsqTable.RetailChannel;

        var recallOrderOperationImprovementFeatureEnabled = RetailImprovedRecallOrderOperationInPosFeatureExposure::isEnabledInFeatureManagement();
        if (recallOrderOperationImprovementFeatureEnabled)
        {
            var deliveryInformation = new Microsoft.Dynamics.Commerce.Runtime.DataModel.DeliveryInformation();

            var firstLine = true;
            LogisticsPostalAddressRecId address;
            DlvModeId deliveryMode;
            SalesShippingDateRequested deliveryDate;
            InventQty totalOrderedQuantity = 0;

            while select salesQuotationLine
                where salesQuotationLine.QuotationId == _salesQuotationTable.QuotationId && salesQuotationLine.QuotationStatus != SalesQuotationStatus::Cancelled
            {
                totalOrderedQuantity += salesQuotationLine.QtyOrdered;

                if (firstLine)
                {
                    deliveryMode = salesQuotationLine.DlvMode;
                    address = salesQuotationLine.DeliveryPostalAddress;
                    deliveryDate = salesQuotationLine.ShippingDateRequested;
                    firstLine = false;
                }
                else
                {
                    // If any field is not same for all quotation line, set the value to null, i.e. mixed result, should be viewed in lines.
                    if (deliveryMode != salesQuotationLine.DlvMode)
                    {
                        deliveryMode = null;
                    }
                    if (address != salesQuotationLine.DeliveryPostalAddress)
                    {
                        address = 0;
                    }
                    if (deliveryDate != salesQuotationLine.ShippingDateRequested)
                    {
                        deliveryDate = dateNull();
                    }
                }
            }

            deliveryInformation.DeliveryMode = deliveryMode;
            if (deliveryDate !=  dateNull())
            {
                deliveryInformation.DeliveryDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(deliveryDate, _rsqTable.RetailChannel);;
            }
            if (address)
            {
                deliveryAddress = LogisticsPostalAddress::findRecId(address);
                if (deliveryAddress)
                {
                    deliveryInformation.DeliveryAddress = RetailTransactionServiceTransactionsJson::fillSalesOrderAddress(deliveryAddress, _salesQuotationTable.DeliveryName, _custTable.Party);
                }
            }
            contract.UnifiedDeliveryInformation = deliveryInformation;

            var lineQuantityAggregate = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryQuantities();
            lineQuantityAggregate.QuantityOrdered = totalOrderedQuantity;
            contract.AggregateInventoryQuantities = lineQuantityAggregate;
        }

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRetailTransactionDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>RetailTransaction</c> having the data of the <c>RetailTransactionTable</c> table.
    /// </summary>
    /// <param name="transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="taxTable">
    /// Table buffer of <c>RetailTransactionTaxTrans</c> table.
    /// </param>
    /// <param name="chargeTable">
    /// Table buffer of <c>RetailTransactionMarkupTrans</c> table.
    /// </param>
    /// <param name="partyTable">
    /// Table buffer of <c>DirPartyTable</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_includePaymentDetails">
    /// Whether or not to include payment line details.
    /// </param>
    /// <param name="_elementName">
    /// Name of the element to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionTable</c> table.
    /// * Members must be in order of the SalesOrder DataContract
    /// Example:
    ///    <SalesOrder>
    ///      <AmountPaid />
    ///      <ChannelId />
    ///      <ChannelReferenceId />
    ///      <ChargeAmount />
    ///      <CreatedDateTime />
    ///      <CurrencyCode />
    ///      <CustomerId />
    ///      <DiscountAmount />
    ///      <EntryStatusValue />
    ///      <GrossAmount />
    ///      <HasLoyaltyPayment />
    ///      <Id />
    ///      <InvoiceComment />
    ///      <LoyaltyCardId />
    ///      <Name />
    ///      <NetAmountWithNoTax />
    ///      <PrepaymentAmountPaid />
    ///      <ReceiptEmail />
    ///      <ReceiptId />
    ///      <SalesId />
    ///      <SalesLines />
    ///      <ShiftId />
    ///      <StaffId />
    ///      <StoreId />
    ///      <SubtotalAmount />
    ///      <TaxAmount />
    ///      <TerminalId />
    ///      <TotalAmount />
    ///      <TotalDiscount />
    ///      <TransactionTypeValue />
    ///    </SalesOrder>
    /// </returns>
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesOrder fillRetailTransactionDetails(
        RetailTransactionTable transactionTable,
        RetailTransactionTaxTrans taxTable,
        RetailTransactionMarkupTrans chargeTable,
        DirPartyTable partyTable,
        boolean _includeDetails,
        boolean _includePaymentDetails)
    {
        RetailTransactionPaymentTrans paymentTable;
        RetailTransactionTenderDeclarationTrans tenderDeclare;
        RetailTransactionBankedTenderTrans tenderBank;
        RetailTransactionSafeTenderTrans tenderSafe;
        RetailChannelTable channelTable;

        XmlElement                  xmlRoot,xmlRecord;
        AmountCur                   prepaymentAmountPaid, subtotalAmount;
        boolean                     hasLoyaltyPayment;
        str                         utcTimeString;
        SalesStatus                 salesStatus;

        CRT.DataModel.SalesOrder contract = new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesOrder();

        // get the sales status from SalesTable based on salesID
        salesStatus = salesTable::find(transactionTable.salesOrderId).SalesStatus;
        contract.Status = salesStatus;
        contract.StatusValue = RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(salesStatus);

        // SalesTransaction fields
        contract.AmountPaid = transactionTable.PaymentAmount;
        contract.ChannelId = transactionTable.Channel;
        contract.ChannelReferenceId = transactionTable.ChannelReferenceId;
        contract.ChargeAmount = chargeTable.CalculatedAmount;
        contract.Comment = transactionTable.comment;

        // NOTE: Generate CreatedDateTime from TransDate+timeWhenTransClosed because the current CreatedDateTime column indicates the DateTime that the P-Job
        // inserted the record into the Headquarters database, rather than the original transaction's creation in the channel database.
        var createdDateTime = DateTimeUtil::newDateTime(transactionTable.transDate, transactionTable.timeWhenTransClosed, RetailChannelTable::findByRecId(transactionTable.Channel).ChannelTimeZone);
        contract.CreatedDateTime = new System.DateTimeOffset(createdDateTime, System.TimeZoneInfo::Utc.GetUtcOffset(createdDateTime));

        contract.CurrencyCode = transactionTable.currency;
        contract.RecordId = transactionTable.RecId;
        contract.CustomerId = transactionTable.CustAccount;
        contract.CustomerOrderTypeValue = transactionTable.TransactionOrderType;
        contract.DiscountAmount = transactionTable.DiscAmount;
        contract.EntryStatusValue = transactionTable.EntryStatus;
        contract.GrossAmount = (transactionTable.GrossAmount * -1);

        hasLoyaltyPayment = RetailLoyaltyCardRewardPointTrans::IsTransactionPaidByLoyalty(
            transactionTable.transactionId,
            transactionTable.store,
            transactionTable.terminal,
            transactionTable.Channel,
            transactionTable.dataAreaId);
        contract.HasLoyaltyPayment = hasLoyaltyPayment;

        contract.Id = transactionTable.TransactionId;
        contract.InvoiceComment = transactionTable.InvoiceComment;
        contract.LoyaltyCardId = transactionTable.loyaltyCardId;
        contract.Name = partyTable.Name;
        contract.NetAmountWithNoTax = (transactionTable.netAmount * -1);
        contract.NetAmountWithTax = (transactionTable.GrossAmount * -1);

        // total invoice amounts paid
        prepaymentAmountPaid = RetailPrePaymentTrans::paymentsMade(transactionTable.salesOrderId);

        contract.PrepaymentAmountPaid = prepaymentAmountPaid;
        contract.ReceiptEmail = transactionTable.receiptEmail;
        contract.ReceiptId = transactionTable.ReceiptId;
        contract.SalesId = transactionTable.salesOrderId;

        contract.ShiftId = (transactionTable.Shift) ? str2Int64(transactionTable.Shift) : 0;
        contract.StaffId = transactionTable.Staff;
        contract.StoreId = transactionTable.Store;

        subtotalAmount = RetailTransactionServiceTransactions::getTransactionSubtotalAmount(
            transactionTable.TransactionId,
            transactionTable.DataAreaId,
            transactionTable.Channel,
            transactionTable.Terminal);

        contract.SubtotalAmount = (subtotalAmount * -1);
        contract.TaxAmount = taxTable.Amount;

        contract.TerminalId = transactionTable.Terminal;

        if (transactionTable.Type == RetailTransactionType::Payment)
        {
            select sum(amountTendered) from paymentTable
            where paymentTable.DataAreaId == transactionTable.DataAreaId
                && paymentTable.Channel == transactionTable.Channel
                && paymentTable.Store == transactionTable.Store
                && paymentTable.Terminal == transactionTable.Terminal
                && paymentTable.TransactionId == transactionTable.TransactionId
                && ( paymentTable.TransactionStatus == RetailEntryStatus::None
                || paymentTable.TransactionStatus == RetailEntryStatus::Posted) ;

            contract.TotalAmount = paymentTable.amountTendered;
        }
        else if (transactionTable.Type == RetailTransactionType::TenderDeclaration)
        {
            select sum(amountTendered) from tenderDeclare
            where tenderDeclare.DataAreaId == transactionTable.DataAreaId
                && tenderDeclare.Channel == transactionTable.Channel
                && tenderDeclare.Store == transactionTable.Store
                && tenderDeclare.Terminal == transactionTable.Terminal
                && tenderDeclare.TransactionId == transactionTable.TransactionId
                && ( tenderDeclare.TransactionStatus == RetailEntryStatus::None
                || tenderDeclare.TransactionStatus == RetailEntryStatus::Posted) ;

            contract.TotalAmount = tenderDeclare.amountTendered;
        }
        else if (transactionTable.Type == RetailTransactionType::BankDrop)
        {
            select sum(amountTendered) from tenderBank
            where tenderBank.DataAreaId == transactionTable.DataAreaId
                && tenderBank.Channel == transactionTable.Channel
                && tenderBank.Store == transactionTable.Store
                && tenderBank.Terminal == transactionTable.Terminal
                && tenderBank.TransactionId == transactionTable.TransactionId
                && ( tenderBank.TransactionStatus == RetailEntryStatus::None
                || tenderBank.TransactionStatus == RetailEntryStatus::Posted) ;

            contract.TotalAmount = tenderBank.amountTendered;
        }
        else if (transactionTable.Type == RetailTransactionType::SafeDrop)
        {
            select sum(amountTendered) from tenderSafe
            where tenderSafe.DataAreaId == transactionTable.DataAreaId
                && tenderSafe.Channel == transactionTable.Channel
                && tenderSafe.Store == transactionTable.Store
                && tenderSafe.Terminal == transactionTable.Terminal
                && tenderSafe.TransactionId == transactionTable.TransactionId
                && ( tenderSafe.TransactionStatus == RetailEntryStatus::None
                || tenderSafe.TransactionStatus == RetailEntryStatus::Posted) ;

            contract.TotalAmount = tenderSafe.amountTendered;
        }
        else
        {
            contract.TotalAmount = (transactionTable.GrossAmount * -1);
        }

        // Fill in sales lines or customer account deposit lines.
        if (RetailMustFillSalesTransDetailsInAddTransactionToListFlight::instance().isEnabled() && _includeDetails)
        {
            // skipping type Payments for now since it's not needed for feature
            // this can be implemented in future
            if (transactionTable.Type != RetailTransactionType::Payment)
            {
                RetailTransactionSalesTrans transactionSalesTable;

                System.Collections.IList list = contract.SalesLines;

                // Select the sales lines for the current transaction
                while select * from transactionSalesTable order by TransDate desc
                where
                    transactionTable.TransactionId == transactionSalesTable.TransactionId
                    && transactionTable.Channel == transactionSalesTable.Channel
                    && transactionTable.Store == transactionSalesTable.Store
                    && transactionTable.Terminal == transactionSalesTable.Terminalid
                    && transactionTable.DataAreaId == transactionSalesTable.DataAreaId
                {
                    list.Add(RetailTransactionServiceTransactionsJson::fillSalesTransDetails(transactionSalesTable));
                }
            }
        }

        contract.TotalDiscount = (transactionTable.TotalDiscAmount);
        contract.TransactionTypeValue = enum2int(transactionTable.type);
        utcdatetime transactionUtcDateTime = DateTimeUtil::newDateTime(transactionTable.transDate, 0, RetailChannelTable::findByRecId(transactionTable.Channel).ChannelTimeZone);
        contract.TransactionDate = new System.DateTimeOffset(Global::utcDateTime2SystemDateTime(transactionUtcDateTime));
        contract.TransactionTime = transactionTable.transTime;

        if (RetailMustFillSalesTransDetailsInAddTransactionToListFlight::instance().isEnabled())
        {
            if (transactionTable.ShippingDateRequested)
            {
                contract.RequestedDeliveryDate = RetailTransactionServiceUtilities::dateToDateTimeWithOffset(transactionTable.ShippingDateRequested, transactionTable.Channel);
            }
        }

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesTransDetails</Name>
				<Source><![CDATA[
    private static CRT.DataModel.SalesLine fillSalesTransDetails(
        RetailTransactionSalesTrans _transactionSalesTrans,
        boolean _includeAttributes = false,
        boolean _includeDiscountLines = false,
        boolean _includeTaxLines = false,
        boolean _includeChargeLines = false,
        boolean _includeLoyaltyRewardPoints = false)
    {
        InventDimCombination inventDimComb;
        InventTable inventTable;
        CRT.DataModel.SalesLine salesLine = new CRT.DataModel.SalesLine();

        salesLine.ItemId = _transactionSalesTrans.itemId;
        salesLine.ItemTaxGroupId = _transactionSalesTrans.TaxItemGroup;
        salesLine.NetAmount = _transactionSalesTrans.NetAmount * -1;
        salesLine.NetAmountWithAllInclusiveTax = _transactionSalesTrans.NetAmountInclTax * -1;
        salesLine.Price = _transactionSalesTrans.Price;
        salesLine.Quantity = _transactionSalesTrans.Qty * -1;
        salesLine.SalesOrderUnitOfMeasure = _transactionSalesTrans.Unit;
        salesLine.SalesTaxGroupId = _transactionSalesTrans.TaxGroup;
        salesLine.TaxAmount = _transactionSalesTrans.TaxAmount * -1;
        salesLine.TaxExemptPriceInclusiveOriginalPrice = _transactionSalesTrans.TaxExemptPriceInclusiveOriginalPrice;
        salesLine.TaxExemptPriceInclusiveReductionAmount = _transactionSalesTrans.TaxExemptPriceInclusiveReductionAmount;

        if (_transactionSalesTrans.barcode)
        {
            salesLine.Barcode = _transactionSalesTrans.barcode;
        }

        salesLine.TaxRatePercent = _transactionSalesTrans.TaxRatePercent;

        salesLine.CatalogId = _transactionSalesTrans.Catalog;

        salesLine.Comment = _transactionSalesTrans.comment;
        salesLine.CommissionSalesGroup = _transactionSalesTrans.SalesGroup;
        salesLine.DeliveryMode = _transactionSalesTrans.DlvMode;
        salesLine.DiscountAmount = _transactionSalesTrans.discAmount;

        if (_transactionSalesTrans.VariantId)
        {
            select firstonly DistinctProductVariant, InventDimId from inventDimComb
                where inventDimComb.ItemId == _transactionSalesTrans.ItemId
                && inventDimComb.RetailVariantId == _transactionSalesTrans.VariantId
                && inventDimComb.DataAreaId == _transactionSalesTrans.DataAreaId;

            salesLine.InventoryDimensionId = inventDimComb.InventDimId;
        }

        salesLine.IsGiftCardLine = enum2int(_transactionSalesTrans.giftcard);
        salesLine.IsPriceOverridden = enum2int(_transactionSalesTrans.priceChange);

        salesLine.LineDiscount = _transactionSalesTrans.LineDscAmount;
        salesLine.LineManualDiscountAmount = _transactionSalesTrans.LineManualDiscountAmount;
        salesLine.LineManualDiscountPercentage = _transactionSalesTrans.LineManualDiscountPercentage;
        salesLine.LinePercentageDiscount = _transactionSalesTrans.LinePercentageDiscount;

        salesLine.LineId = RetailTransactionServiceUtilities::lineNumToString(_transactionSalesTrans.LineNum);

        if (_transactionSalesTrans.ListingId != '')
        {
            salesLine.ListingId = str2Int64(_transactionSalesTrans.ListingId);
        }
        else if (_transactionSalesTrans.VariantId)
        {
            salesLine.ListingId = inventDimComb.DistinctProductVariant ? inventDimComb.DistinctProductVariant : 0;
        }
        else
        {
            select firstonly Product from inventTable
                where inventTable.ItemId == _transactionSalesTrans.ItemId
                && inventTable.DataAreaId == _transactionSalesTrans.DataAreaId;
            salesLine.ListingId = inventTable.Product ? inventTable.Product : 0;
        }

        // ProductId is a copy of ListingId
        salesLine.ProductId = salesLine.ListingId;

        salesLine.NetPrice = _transactionSalesTrans.netPrice;
        salesLine.OriginalPrice = _transactionSalesTrans.OriginalPrice;

        salesLine.PeriodicDiscount = _transactionSalesTrans.PeriodicDiscAmount;
        salesLine.PeriodicPercentageDiscount = _transactionSalesTrans.PeriodicPercentageDiscount;

        if (_transactionSalesTrans.PickupEndTime > 0)
        {
            var startDateTime = DateTimeUtil::newDateTime(_transactionSalesTrans.ShippingDateRequested, _transactionSalesTrans.PickupStartTime);
            var endDateTime = DateTimeUtil::newDateTime(_transactionSalesTrans.ShippingDateRequested, _transactionSalesTrans.PickupEndTime);

            salesLine.PickupTimeslotStartDateTime = new System.DateTimeOffset(
                DateTimeUtil::year(startDateTime), // year,
                DateTimeUtil::month(startDateTime), // month
                DateTimeUtil::day(startDateTime), // day
                DateTimeUtil::hour(startDateTime), // hour
                DateTimeUtil::minute(startDateTime), // minute
                DateTimeUtil::second(startDateTime), // second
                0, // millisecond
                new System.TimeSpan(0, 0, 0));

            salesLine.PickupTimeslotEndDateTime = new System.DateTimeOffset(
                DateTimeUtil::year(endDateTime), // year,
                DateTimeUtil::month(endDateTime), // month
                DateTimeUtil::day(endDateTime), // day
                DateTimeUtil::hour(endDateTime), // hour
                DateTimeUtil::minute(endDateTime), // minute
                DateTimeUtil::second(endDateTime), // second
                0, // millisecond
                new System.TimeSpan(0, 0, 0));
        }

        // We are intentionally not populating salesLine.LastReturnProcessedTime and salesLine.ReturnQuantity
        // because it will require changes in CSU logic as well and it is not required for current usage

        var salesDate = DateTimeUtil::newDateTime(_transactionSalesTrans.transDate, _transactionSalesTrans.transTime, RetailChannelTable::findByRecId(_transactionSalesTrans.Channel).ChannelTimeZone);
        salesLine.SalesDate = new System.DateTimeOffset(salesDate, System.TimeZoneInfo::Utc.GetUtcOffset(salesDate));

        salesLine.SerialNumber = _transactionSalesTrans.InventSerialId;

        RetailTransactionServiceTransactionsJson::fillAddress(salesLine, _transactionSalesTrans);

        salesLine.StaffId = _transactionSalesTrans.staffId;
        salesLine.StatusValue = enum2int(_transactionSalesTrans.TransactionStatus);
        salesLine.TenderDiscountAmount = _transactionSalesTrans.TenderDiscountAmount;
        salesLine.TenderDiscountPercentage = _transactionSalesTrans.TenderDiscountPercentage;
        salesLine.TotalDiscount = _transactionSalesTrans.TotalDiscAmount;
        salesLine.TotalPercentageDiscount = _transactionSalesTrans.TotalDiscPct;
        salesLine.UnitQuantity = _transactionSalesTrans.UnitQty * -1;

        if (_includeTaxLines)
        {
            RetailTransactionServiceTransactionsJson::fillSalesTaxTransDetails(salesLine, _transactionSalesTrans);
        }

        if (_includeAttributes)
        {
            RetailTransactionServiceTransactionsJson::fillSalesAttributeTransDetails(salesLine, _transactionSalesTrans);
        }

        if (_includeChargeLines)
        {
            RetailTransactionServiceTransactionsJson::fillSalesMarkupTransDetails(salesLine, _transactionSalesTrans);
        }

        if (_includeDiscountLines)
        {
            RetailTransactionServiceTransactionsJson::fillSalesDiscountTransDetails(salesLine, _transactionSalesTrans);
        }

        if (_includeLoyaltyRewardPoints)
        {
            RetailTransactionServiceTransactionsJson::fillLoyaltyRewardPointLines(salesLine, _transactionSalesTrans);
        }

        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesTaxTransDetails</Name>
				<Source><![CDATA[
    private static void fillSalesTaxTransDetails(CRT.DataModel.SalesLine _salesLine, RetailTransactionSalesTrans _transactionSalesTable)
    {
        // skipping implementation for now since it's not needed for feature
        // this can be implemented in future if needed
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesAttributeTransDetails</Name>
				<Source><![CDATA[
    private static void fillSalesAttributeTransDetails(CRT.DataModel.SalesLine _salesLine, RetailTransactionSalesTrans _transactionSalesTable)
    {
        // skipping implementation for now since it's not needed for feature
        // this can be implemented in future if needed
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesMarkupTransDetails</Name>
				<Source><![CDATA[
    private static void fillSalesMarkupTransDetails(CRT.DataModel.SalesLine _salesLine, RetailTransactionSalesTrans _transactionSalesTable)
    {
        // skipping implementation for now since it's not needed for feature
        // this can be implemented in future if needed
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesDiscountTransDetails</Name>
				<Source><![CDATA[
    private static void fillSalesDiscountTransDetails(CRT.DataModel.SalesLine _salesLine, RetailTransactionSalesTrans _transactionSalesTable)
    {
        // skipping implementation for now since it's not needed for feature
        // this can be implemented in future if needed
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillLoyaltyRewardPointLines</Name>
				<Source><![CDATA[
    private static void fillLoyaltyRewardPointLines(CRT.DataModel.SalesLine _salesLine, RetailTransactionSalesTrans _transactionSalesTable)
    {
        // skipping implementation for now since it's not needed for feature
        // this can be implemented in future if needed
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillAddress</Name>
				<Source><![CDATA[
    private static void fillAddress(CRT.DataModel.SalesLine _salesLine, RetailTransactionSalesTrans _transactionSalesTable)
    {
        LogisticsPostalAddress deliveryAddress = LogisticsPostalAddress::findRecId(_transactionSalesTable.LogisticsPostalAddress);
        if (deliveryAddress)
        {
            DirPartyTable partyTable = DirPartyTable::findRec(CustTable::find(_transactionSalesTable.custAccount).Party);
            str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, partyTable.Name);
            _salesLine.ShippingAddress = RetailTransactionServiceTransactionsJson::fillSalesOrderAddress(deliveryAddress, deliveryName, partyTable.RecId);
        }
        else
        {
            RetailTransactionTable transactionTable = RetailTransactionTable::findByUniqueKey(_transactionSalesTable.transactionId, _transactionSalesTable.channel, _transactionSalesTable.store, _transactionSalesTable.terminalId);
            RetailTransactionAddressTrans addressTrans = RetailTransactionTransformer::getAddressLineFromTransaction(transactionTable, _transactionSalesTable.lineNum);
            LogisticsAddressing logisticsAddressing = LogisticsPostalAddressStringBuilder::buildAddressStringFromParameters(addressTrans.postalAddressStringBuilderParameters());
            if (addressTrans)
            {
                CRT.DataModel.Address contract = new CRT.DataModel.Address();
                contract.BuildingCompliment = addressTrans.BuildingCompliment;
                contract.City = addressTrans.City;
                contract.County = addressTrans.County;
                contract.DistrictName = addressTrans.DistrictName;
                contract.FullAddress = logisticsAddressing;
                contract.Name = addressTrans.DeliveryName;
                contract.RecordId = addressTrans.RecId;
                contract.State = addressTrans.State;
                contract.Street = addressTrans.Street;
                contract.StreetNumber = addressTrans.StreetNumber;
                contract.ThreeLetterISORegionName = addressTrans.CountryRegionId;
                contract.ZipCode = addressTrans.ZipCode;
                _salesLine.ShippingAddress = contract;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerExtensionProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension properties.
    /// </summary>
    /// <param name = "transactionTable">The transaction record.</param>
    /// <param name = "extensionRanges">List of the <c>CommerceProperty</c> for extension properties.</param>
    static delegate void registerExtensionProperties(RetailTransactionTable transactionTable, List extensionProperties)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerOrderExtensionProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension properties of sales order.
    /// </summary>
    /// <param name = "salesTable">The sales order record.</param>
    /// <param name = "extensionRanges">List of the <c>CommerceProperty</c> for extension properties.</param>
    static delegate void registerOrderExtensionProperties(SalesTable salesTable, List extensionProperties)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerQuoteExtensionProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension properties of quote order.
    /// </summary>
    /// <param name = "quoteTable">The quote order record.</param>
    /// <param name = "extensionProperties">List of the <c>CommerceProperty</c> for extension properties.</param>
    static delegate void registerQuoteExtensionProperties(SalesQuotationTable quoteTable, List extensionProperties)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesOrderSurrogateExtensionProperties</Name>
				<Source><![CDATA[
    private static void addSalesOrderSurrogateExtensionProperties(CRT.DataModel.DataContractSurrogates.SalesOrderSurrogate _salesOrderSurrogate, List _extensionProperties)
    {
        ListEnumerator extensionPropertyEnumerator = _extensionProperties.getEnumerator();
        while (extensionPropertyEnumerator.moveNext())
        {
            CRT.DataModel.CommerceProperty extensionProperty = extensionPropertyEnumerator.current();
            var extensionPropertyCollection = _salesOrderSurrogate.ExtensionProperties;
            extensionPropertyCollection.Add(extensionProperty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertQuotationStatusToRetailSalesStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert QuotationStatus to RetailSalesStatus.
    /// </summary>
    /// <param name = "_QuotationStatus">
    /// QuotationStatus to be converted to RetailSalesStatus.
    /// </param>
    /// <returns>
    /// Converted RetailSalesStatus.
    /// </returns>
    private static RetailSalesStatus convertQuotationStatusToRetailSalesStatus(SalesQuotationStatus _QuotationStatus)
    {
        switch(_QuotationStatus)
        {
            case SalesQuotationStatus::Sent:
                return RetailSalesStatus::Sent;

            case SalesQuotationStatus::Cancelled:
                return RetailSalesStatus::Canceled;

            case SalesQuotationStatus::Lost:
                return RetailSalesStatus::Lost;

            case SalesQuotationStatus::Confirmed:
                return RetailSalesStatus::Confirmed;

            default:
                return RetailSalesStatus::Created;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateRegularTotalTaxAmountForRetailTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total tax amount for retail transaction by <t>RetailTransactionTaxTrans</t> table.
    /// </summary>
    /// <param name = "_transactionTable">The transaction table entry.</param>
    /// <returns>Tax amount.</returns>
    private static Amount calculateRegularTotalTaxAmountForRetailTransaction(RetailTransactionTable _transactionTable)
    {
        RetailTransactionTaxTrans retailTransactionTaxTrans;

        // Get additional summary values
        select sum(Amount) from retailTransactionTaxTrans
        where _transactionTable.TransactionId == retailTransactionTaxTrans.TransactionId
            && _transactionTable.Channel == retailTransactionTaxTrans.Channel
            && _transactionTable.Store == retailTransactionTaxTrans.StoreId
            && _transactionTable.Terminal == retailTransactionTaxTrans.TerminalId
            && _transactionTable.DataAreaId == retailTransactionTaxTrans.DataAreaId;

        return retailTransactionTaxTrans.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a retail sales line, update its inventory quantity values
    /// and then refresh it to get the latest values.
    /// </summary>
    /// <param name = "_retailSalesLine">The line to update.</param>
    internal static void updateLineQuantities(RetailSalesLine _retailSalesLine)
    {
        RetailTransactionServiceFulfillment::updateFulfillmentStatus(_retailSalesLine.SalesLine);
        _retailSalesLine.reread();
        eventSource.EventWriteRetailSalesLineUpdateQuantitiesOnDemand(_retailSalesLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementAggregateQuantitiesFromSalesLine</Name>
				<Source><![CDATA[
    private static void incrementAggregateQuantitiesFromSalesLine(Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryQuantities lineQuantityAggregate, CRT.DataModel.SalesLine salesLine)
    {
        RetailTransactionServiceTransactionsJson::initializeNullQuantityValues(lineQuantityAggregate);

        lineQuantityAggregate.QuantityNotProcessed = lineQuantityAggregate.QuantityNotProcessed.get_Value() + salesLine.QuantityNotProcessed.GetValueOrDefault();
        lineQuantityAggregate.QuantityReserved = lineQuantityAggregate.QuantityReserved.get_Value() + salesLine.QuantityReserved.GetValueOrDefault();
        lineQuantityAggregate.QuantityPicked = lineQuantityAggregate.QuantityPicked.get_Value() + salesLine.QuantityPicked.GetValueOrDefault();
        lineQuantityAggregate.QuantityPacked = lineQuantityAggregate.QuantityPacked.get_Value() + salesLine.QuantityPacked.GetValueOrDefault();
        lineQuantityAggregate.QuantityInvoiced = lineQuantityAggregate.QuantityInvoiced.get_Value() + salesLine.QuantityInvoiced.GetValueOrDefault();
        lineQuantityAggregate.QuantityOrdered = lineQuantityAggregate.QuantityOrdered.get_Value() + salesLine.QuantityOrdered.GetValueOrDefault();
        lineQuantityAggregate.QuantityCanceled = lineQuantityAggregate.QuantityCanceled.get_Value() + salesLine.QuantityCanceled.GetValueOrDefault();
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementAggregateQuantitiesFromRetailSalesLine</Name>
				<Source><![CDATA[
    private static void incrementAggregateQuantitiesFromRetailSalesLine(Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryQuantities lineQuantityAggregate, SalesLine salesLine, RetailSalesLine retailSalesLine)
    {
        RetailTransactionServiceTransactionsJson::initializeNullQuantityValues(lineQuantityAggregate);

        if (RetailFulfillmentQuantitiesInSalesUomFlight::instance().isEnabled())
        {
            lineQuantityAggregate.QuantityNotProcessed = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityNotProcessed.get_Value()) + retailSalesLine.getQuantityNotProcessedInSalesUnit(salesLine);
            lineQuantityAggregate.QuantityReserved = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityReserved.get_Value()) + retailSalesLine.getQuantityPhysicallyReservedInSalesUnit(salesLine);
            lineQuantityAggregate.QuantityPicked = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityPicked.get_Value()) + retailSalesLine.getQuantityPickedInSalesUnit(salesLine);
            lineQuantityAggregate.QuantityPacked = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityPacked.get_Value()) + retailSalesLine.getQuantityPackedInSalesUnit(salesLine);
            lineQuantityAggregate.QuantityInvoiced = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityInvoiced.get_Value()) + retailSalesLine.getQuantityInvoicedInSalesUnit(salesLine);
            lineQuantityAggregate.QuantityOrdered = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityOrdered.get_Value()) + retailSalesLine.getQuantityOrderedInSalesUnit(salesLine);
            lineQuantityAggregate.QuantityCanceled = salesLine.unitConvertInvent2Sales(lineQuantityAggregate.QuantityCanceled.get_Value()) + retailSalesLine.getQuantityCanceledInSalesUnit(salesLine);
        }
        else
        {
            lineQuantityAggregate.QuantityNotProcessed = lineQuantityAggregate.QuantityNotProcessed.get_Value() + retailSalesLine.QuantityNotProcessed;
            lineQuantityAggregate.QuantityReserved = lineQuantityAggregate.QuantityReserved.get_Value() + retailSalesLine.QuantityPhysicallyReserved;
            lineQuantityAggregate.QuantityPicked = lineQuantityAggregate.QuantityPicked.get_Value() + retailSalesLine.QuantityPicked;
            lineQuantityAggregate.QuantityPacked = lineQuantityAggregate.QuantityPacked.get_Value() + retailSalesLine.QuantityPacked;
            lineQuantityAggregate.QuantityInvoiced = lineQuantityAggregate.QuantityInvoiced.get_Value() + retailSalesLine.QuantityInvoiced;
            lineQuantityAggregate.QuantityOrdered = lineQuantityAggregate.QuantityOrdered.get_Value() + salesLine.QtyOrdered;
            lineQuantityAggregate.QuantityCanceled = lineQuantityAggregate.QuantityCanceled.get_Value() + retailSalesLine.quantityCanceled(salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeNullQuantityValues</Name>
				<Source><![CDATA[
    private static void initializeNullQuantityValues(Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryQuantities lineQuantityAggregate)
    {
        // The quantity values are nullable, so by default each property is null.
        // Since we found at least one sales line, we can initialize them to zero.
        lineQuantityAggregate.QuantityNotProcessed = lineQuantityAggregate.QuantityNotProcessed.GetValueOrDefault(0);
        lineQuantityAggregate.QuantityReserved = lineQuantityAggregate.QuantityReserved.GetValueOrDefault(0);
        lineQuantityAggregate.QuantityPicked = lineQuantityAggregate.QuantityPicked.GetValueOrDefault(0);
        lineQuantityAggregate.QuantityPacked = lineQuantityAggregate.QuantityPacked.GetValueOrDefault(0);
        lineQuantityAggregate.QuantityInvoiced = lineQuantityAggregate.QuantityInvoiced.GetValueOrDefault(0);
        lineQuantityAggregate.QuantityOrdered = lineQuantityAggregate.QuantityOrdered.GetValueOrDefault(0);
        lineQuantityAggregate.QuantityCanceled = lineQuantityAggregate.QuantityCanceled.GetValueOrDefault(0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLogisticsLocationRoleForPostalAddress</Name>
				<Source><![CDATA[
    private static LogisticsLocationRole GetLogisticsLocationRoleForPostalAddress(LogisticsPostalAddress logisticsPostalAddress)
    {
        DirPartyLocation dirPartyLocation;
        DirPartyLocationRole dirPartyLocationRole;
        LogisticsLocationRole logisticsLocationRole;

        select firstonly logisticsLocationRole
            join dirPartyLocationRole
                where logisticsLocationRole.RecId == dirPartyLocationRole.LocationRole
            join dirPartyLocation
                where dirPartyLocationRole.PartyLocation == dirPartyLocation.RecId
                    && dirPartyLocation.IsPostalAddress
                    && dirPartyLocation.Location == logisticsPostalAddress.Location;

        return logisticsLocationRole;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDirPartyLocationPrimaryForCustomerPostalAddress</Name>
				<Source><![CDATA[
    private static DirPartyLocation GetDirPartyLocationPrimaryForCustomerPostalAddress(LogisticsPostalAddress logisticsPostalAddress, DirPartyRecId customerParty = 0)
    {
        DirPartyLocation dirPartyLocation;

        if (RetailDirPartyLocationChangesFlight::instance().isEnabled() && customerParty)
        {
            select firstonly dirPartyLocation
                where dirPartyLocation.IsPostalAddress
                    && dirPartyLocation.Location == logisticsPostalAddress.Location
                    && dirPartyLocation.Party == customerParty;
        }
        else
        {
            select firstonly dirPartyLocation
                where dirPartyLocation.IsPostalAddress
                    && dirPartyLocation.Location == logisticsPostalAddress.Location;
        }

        return dirPartyLocation;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>