<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransType</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerJournalTransType</c> class provides the <c>LedgerJournalTrans</c> strategies base
///    defaulting and validation.
/// </summary>
/// <remarks>
///    The <c>LedgerJournalTransType</c> class hierarchy implements the strategy pattern to provide
///    polymorphic defaulting and validation for journal account types and offset account types stored in
///    the <c>LedgerJournalTrans</c> table.
/// </remarks>
//
//  Internal Notes:
//
//      1) We always respect non-interactive mode (service) values.
//      In this mode the ledgerJournalTrans tracks table state, so we know what values the consumer set, so we only
//      default by trying to improve the values that the consumer did not set.
//
//      2) We try to respect interactive mode (client) defaults.
//      Table buffers do not hold state, so in the interative mode we do not understand if the field has been defaulted
//      before this class is invoked.  We have two scenarios that developers that should understand:
//
//          a) Initialize the table buffer.
//          We have exposed defaultField and defaultRow methods.  As of AX 5.0, these methods are called exclusively from the
//          non-interactive mode, but they are implemented so the interactive code can initialize the table buffer by
//          passing a few required fields.
//
//      Take Away:  Most defaulting logic only has to consider if the field has been set by the non-interactive mode.
//
//          b) Validate the table buffer
//          Interactive and non-interactive modes both execute the same validateField and validateRow logic.
//          In both cases we need to create table buffers of associated tables (initialize* methods).
//          Some of these methods in turn call some default methods (examples: defaultCompany and defaultOffsetCompany)
//          so we can initialize these buffers.  In the interative mode we do not have state information so we do not know
//          if these fields have been set.  For these two specific fields WE DO ASSUME they have been set by the user in the
//          interactive mode, so we do not overlay them.
//
//      Take Away:  If you have to validate a field that requires a new table buffer, then consider if you need to default
//                  a field before trying to find the table buffer.  If you do need to default the field, then make sure you do not
//                  overlay the interactive modes default values.  See defaultCompany as an example.
//
//      3) We did not code a replace voucher number method.
//      The approach of this class is to take vouchers only when they are needed, but it is possible these
//      vouchers may need to be replaced.  When a voucher number is taken during the getNewVoucher method,
//      it is taken on a user connection so it is independent from the root transaction.  When the root
//      transaction fails, the kernel will automatically re-use these vouchers.  Therefore, the create
//      sceario is handled by the kernel and we do not need to expose a replace voucher number method.
//
public abstract class LedgerJournalTransType
{
    #LedgerJournalFaults

    LedgerJournalOperation      operation;
    boolean                     isInteractiveContext;
    LedgerJournalName           ledgerJournalName;
    LedgerJournalTable          ledgerJournalTable;
    LedgerJournalTrans          ledgerJournalTrans;
    LedgerJournalTrans          previousLedgerJournalTrans;
    CurrencyCode                companyCurrencyCode;
    Voucher                     reservedVoucher;
    Voucher_CN                  reservedVoucher_CN;
    boolean                     isCacheStateValid;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>crossValidateCreditDebitAmounts</Name>
				<Source><![CDATA[
    protected boolean crossValidateCreditDebitAmounts()
    {
        boolean isValid = true;

        if (ledgerJournalTrans.AmountCurCredit != 0.0 && ledgerJournalTrans.AmountCurDebit != 0.0)
        {
            isValid = checkFailed("@SYS117889");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffCreditDebitAmounts</Name>
				<Source><![CDATA[
	/// <summary>
    /// Rounds off the credit and debit amounts for <c>LedgerJournalTrans</c> record
    /// </summary>
    protected void roundOffCreditDebitAmounts()
    {
        if (operation == LedgerJournalOperation::Create || operation == LedgerJournalOperation::Update)
        {
            if (ledgerJournalTrans.AmountCurCredit)
            {
                ledgerJournalTrans.AmountCurCredit = CurrencyExchange::round(ledgerJournalTrans.AmountCurCredit, ledgerJournalTrans.CurrencyCode);
            }
            if (ledgerJournalTrans.AmountCurDebit)
            {
                ledgerJournalTrans.AmountCurDebit = CurrencyExchange::round(ledgerJournalTrans.AmountCurDebit, ledgerJournalTrans.CurrencyCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultAcknowledgementDate</Name>
				<Source><![CDATA[
    protected void defaultAcknowledgementDate()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, AcknowledgementDate)))
            {
                this.defaultTransDate();
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, AcknowledgementDate), ledgerJournalTrans.TransDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultBankRemittanceType</Name>
				<Source><![CDATA[
    protected void defaultBankRemittanceType()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, BankRemittanceType)))
            {
                this.initializeLedgerJournalTable();

                if (ledgerJournalTable)
                {
                    this.defaultFieldValue(fieldNum(LedgerJournalTrans, BankRemittanceType), ledgerJournalTable.BankRemittanceType);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCompany</Name>
				<Source><![CDATA[
    protected void defaultCompany()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            // We respect the interactive mode default values.
            // See class internal notes 2.b
            if (this.isConsumerStateTracked())
            {
                if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Company)))
                {
                    this.defaultFieldValue(fieldNum(LedgerJournalTrans, Company), curext());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCurrencyCode</Name>
				<Source><![CDATA[
    protected void defaultCurrencyCode()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, CurrencyCode)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, CurrencyCode), this.determineDefaultCurrencyCode());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCustVendNegInstProtestReason</Name>
				<Source><![CDATA[
    protected void defaultCustVendNegInstProtestReason()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, CustVendNegInstProtestReason)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, CustVendNegInstProtestReason), CustVendNegInstProtestReason::None);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDefaultDimension</Name>
				<Source><![CDATA[
    protected void defaultDefaultDimension()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, DefaultDimension)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, DefaultDimension), this.determineDefaultDimension());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultExchRate</Name>
				<Source><![CDATA[
    protected void defaultExchRate()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ExchRate)))
            {
                this.defaultCompany();
                this.defaultCurrencyCode();
                this.defaultTransDate();
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ExchRate), this.determineDefaultExchRate());
            }
        }
        else if (operation == LedgerJournalOperation::Update)
        {
            LedgerJournalTrans original = ledgerJournalTrans.orig();

            // If the user changed the currency code or transDate, but the exchange rate was not updated - default
            // the exchange rate for the new currency.
            if ((original.CurrencyCode != ledgerJournalTrans.CurrencyCode || original.TransDate != ledgerJournalTrans.TransDate || original.Company != ledgerJournalTrans.Company) &&
                original.ExchRate == ledgerJournalTrans.ExchRate)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ExchRate), this.determineDefaultExchRate());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultExchRateSecond</Name>
				<Source><![CDATA[
    protected void defaultExchRateSecond()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ExchRateSecond)))
            {
                this.defaultCompany();
                this.defaultCurrencyCode();
                this.defaultTransDate();
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ExchRateSecond), this.determineDefaultExchRateSecond());
            }
        }
        else if (operation == LedgerJournalOperation::Update)
        {
            LedgerJournalTrans original = ledgerJournalTrans.orig();

            // If the user changed the currency code or transDate, but the secondary exchange rate was not updated - default
            // the secondary exchange rate for the new currency.
            if ((original.CurrencyCode != ledgerJournalTrans.CurrencyCode || original.TransDate != ledgerJournalTrans.TransDate || original.Company != ledgerJournalTrans.Company) &&
                original.ExchRateSecond == ledgerJournalTrans.ExchRateSecond)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ExchRateSecond), this.determineDefaultExchRateSecond());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies default values to the specified field.
    /// </summary>
    /// <param name="_fieldId">
    ///    The field identifier of the field.
    /// </param>
    public void defaultField(FieldId _fieldId)
    {
        ledgerJournalTrans.fieldState(_fieldId, FieldState::NotSet);

        FieldName fieldName = fieldId2name(tableNum(LedgerJournalTrans), _fieldId);

        MethodName methodName = 'default' + fieldName;

        SysDictClass sysDictClass = new SysDictClass(classIdGet(this));

        if (sysDictClass.hasObjectMethod(methodName))
        {
            sysDictClass.callObject(methodName, this);
        }

        ledgerJournalTrans.fieldState(_fieldId, FieldState::Defaulted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFreqCode</Name>
				<Source><![CDATA[
    protected void defaultFreqCode()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, FreqCode)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, FreqCode), PeriodUnit::Day);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLineNum</Name>
				<Source><![CDATA[
    protected void defaultLineNum()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, LineNum)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, LineNum), this.determineDefaultLineNum());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetAccount</Name>
				<Source><![CDATA[
    protected void defaultOffsetAccount()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            // The field state must be checked in scenarios where the field was directly set without
            // coming through the LedgerJournalTrans class. This is the case with data entities. In
            // these cases the only way to determine if it was set explicitly is through the field state.
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, OffsetLedgerDimension)) &&
                ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, OffsetLedgerDimension)) != FieldState::Set)
            {
                if (this.isConsumerStateTracked())
                {
                    //
                    // We do not understand the consumers intent that the service should default the offset account.
                    // Without understanding the consumers intent, better offset account defaulting logic could be written
                    // by looking at several LedgerJournalTrans lines, but we do not have that ability.  Therefore,
                    // when the consumer does not define the offset account we do not default it.
                    //
                    ledgerJournalTrans.OffsetLedgerDimension = 0;
                }
                else
                {
                    this.initializeLedgerJournalTable();

                    if (ledgerJournalTable.RecId != 0 && ledgerJournalTable.parmOffsetLedgerDimension())
                    {
                        this.defaultFieldValue(fieldNum(LedgerJournalTrans, OffsetLedgerDimension), ledgerJournalTable.parmOffsetLedgerDimension());
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies the default journal offset account type.
    /// </summary>
    /// <remarks>
    ///    This method is abstract because each journal has a specific default offset account type.
    /// </remarks>
    protected void defaultOffsetAccountType()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (this.isConsumerStateTracked())
            {
                if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, OffsetAccountType)))
                {
                    // Only ledger offset account types are supported.
                    this.defaultFieldValue(fieldNum(LedgerJournalTrans, OffsetAccountType), LedgerJournalACType::Ledger);
                }
            }
            else
            {
                this.initializeLedgerJournalTable();

                if (ledgerJournalTable.RecId != 0 )
                {
                    this.defaultFieldValue(fieldNum(LedgerJournalTrans, OffsetAccountType), ledgerJournalTable.OffsetAccountType);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetCompany</Name>
				<Source><![CDATA[
    protected void defaultOffsetCompany()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            // We respect the interactive mode default values.
            // See class internal notes 2.b
            if (this.isConsumerStateTracked())
            {
                if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, OffsetCompany)))
                {
                    this.defaultFieldValue(fieldNum(LedgerJournalTrans, OffsetCompany), curext());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetDefaultDimension</Name>
				<Source><![CDATA[
    protected void defaultOffsetDefaultDimension()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, OffsetDefaultDimension)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, OffsetDefaultDimension), this.determineDefaultOffsetDefaultDimension());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPaymentStatus</Name>
				<Source><![CDATA[
    protected void defaultPaymentStatus()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, PaymentStatus)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, PaymentStatus), CustVendPaymStatus::None);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPurchLedgerPosting</Name>
				<Source><![CDATA[
    protected void defaultPurchLedgerPosting()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, PurchLedgerPosting)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, PurchLedgerPosting), ArrivalPostingType::None);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReverseDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies the default <c>ReverseDate</c> value.
    /// </summary>
    protected void defaultReverseDate()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            this.initializeLedgerJournalTable();

            if (ledgerJournalTable.RecId != 0 && ledgerJournalTable.JournalType == LedgerJournalType::Daily)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReverseDate), this.determineDefaultReverseDate());

                if (ledgerJournalTrans.ReverseDate != dateNull())
                {
                    LedgerJournalEngine_Server::adjustRevDate(ledgerJournalTrans);
                }
            }
            else
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReverseDate), dateNull());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReverseEntry</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies a default <c>ReverseEntry</c> value.
    /// </summary>
    protected void defaultReverseEntry()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            this.initializeLedgerJournalTable();

            if (ledgerJournalTable.RecId != 0 && ledgerJournalTable.JournalType == LedgerJournalType::Daily)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReverseEntry), this.determineDefaultReverseEntry());
            }
            else
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReverseEntry), NoYes::No);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultRow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies default field values for a <c>LedgerJournalTrans</c> row.
    /// </summary>
    public void defaultRow()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            // Get the voucher up front since other methods compare voucher for the current line with previous line's voucher
            this.defaultVoucher();

            if (LedgerParameters::isChineseVoucher_CN())
            {
                this.defaultVoucher_CN();
            }

            this.defaultTransDate();
            this.defaultCompany();
            //DocumentDate                                   //min date
            //AccountNum                                     //empty space
            //AmountCurDebit                                 //zero
            //AmountCurCredit                                //zero
            this.defaultOffsetCompany();
            this.defaultOffsetAccountType();
            this.defaultOffsetAccount();
            this.defaultCurrencyCode();
            this.roundOffCreditDebitAmounts();
            this.defaultExchRate();
            this.defaultReportingCurrencyExchRate();
            this.defaultReportingCurrencySecondaryExchRate();
            this.defaultTaxGroup();
            this.defaultTaxItemGroup();
            //JournalNum;                                    //required
            this.defaultLineNum();
            this.defaultTxt();
            this.defaultCashDiscCode();
            this.defaultDefaultDimension();
            this.defaultOffsetDefaultDimension();
            this.defaultSettleVoucher();                     //enumeration default
            this.defaultPaymentStatus();                     //enumeration default
            //OffsetTxt                                      //NA
            this.defaultTransactionType();                   //enumeration default
            this.defaultFreqCode();                          //enumeration default
            this.defaultPurchLedgerPosting();                //enumeration default
            this.defaultExchRateSecond();
            this.defaultCustVendNegInstProtestReason();      //enumeration default
            this.defaultBankRemittanceType();                //enumeration default
            this.defaultAcknowledgementDate();
            this.defaultReverseEntry();
            this.defaultReverseDate();
            this.defaultApproved();
            this.defaultApprover();
            this.defaultPostingProfile();
            this.defaultCustVendBankAccountId();
            this.defaultTax1099FieldsRecId();
            this.defaultPaymMode();
            this.defaultPaymSpec();
            this.defaultVATNumJournal();
            this.defaultPayment();
            this.defaultDue();
            this.defaultDateCashDiscAndCashDiscAmount();
            this.deleteTaxUncommitted();
        }
        else if (operation == LedgerJournalOperation::Update)
        {
            this.roundOffCreditDebitAmounts();
            this.defaultExchRate();
            this.defaultExchRateSecond();
            this.defaultDue();
            this.defaultReportingCurrencyExchRate();
            this.defaultReportingCurrencySecondaryExchRate();

            LedgerJournalTrans original = ledgerJournalTrans.orig();
            this.initializeLedgerJournalTable();

            // If user changed voucher but voucher seq is not set to Manual, then voucher should retain existing value.
            if (NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).Manual == NoYes::No 
                && LedgerJournalTable::find(original.JournalNum).JournalName == ledgerJournalTable.JournalName)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Voucher), original.Voucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommitted</Name>
				<Source><![CDATA[
    private void deleteTaxUncommitted()
    {
        if (!ledgerJournalTable.Posted && ledgerJournalTrans.TaxGroup && ledgerJournalTrans.TaxItemGroup)
        {
            TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCashDiscCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for cash discount code field.
    /// </summary>
    protected void defaultCashDiscCode()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, CashDiscCode)) || ledgerJournalTrans.CashDiscCode == "")
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, CashDiscCode), this.determineCashDiscCode());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCashDiscCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cash discount code.
    /// </summary>
    /// <returns>
    /// The cash discount code.
    ///</returns>
    protected CashDiscCode determineCashDiscCode()
    {
        return ledgerJournalTrans.CashDiscCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDateCashDiscAndCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the DateCasehDisc and CashDiscAmount fields.
    /// </summary>
    protected void defaultDateCashDiscAndCashDiscAmount()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, DateCashDisc))
                || !ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, CashDiscAmount)))
            {
                container dateCashDiscAndCashDiscAmountAndDateCashDisc = this.determineDateCashDiscAndCashDiscAmount();

                if (conLen(dateCashDiscAndCashDiscAmountAndDateCashDisc) == 3)
                {
                    if (ledgerJournalTrans.DateCashDisc == dateNull())
                    {
                        this.defaultFieldValue(fieldNum(LedgerJournalTrans, DateCashDisc), conPeek(dateCashDiscAndCashDiscAmountAndDateCashDisc, 1));
                    }

                    if (!ledgerJournalTrans.CashDiscAmount)
                    {
                        this.defaultFieldValue(fieldNum(LedgerJournalTrans, CashDiscAmount), conPeek(dateCashDiscAndCashDiscAmountAndDateCashDisc, 2));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDateCashDiscAndCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default DateCashDisc and CashDiscAmount value.
    /// </summary>
    /// <returns>
    /// The default values of DateCashDisc and CashDiscAmount.
    ///</returns>
    protected container determineDateCashDiscAndCashDiscAmount()
    {
        return [ledgerJournalTrans.DateCashDisc, ledgerJournalTrans.CashDiscAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultSettleVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the settlement voucher field.
    /// </summary>
    protected void defaultSettleVoucher()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, SettleVoucher)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, SettleVoucher), SettlementType::None);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the tax group field.
    /// </summary>
    protected void defaultTaxGroup()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, TaxGroup)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, TaxGroup), this.determineDefaultTaxGroup());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the item tax group field.
    /// </summary>
    protected void defaultTaxItemGroup()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, TaxItemGroup)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, TaxItemGroup), this.determineDefaultTaxItemGroup());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the transaction type field.
    /// </summary>
    protected void defaultTransactionType()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            LedgerTransType defaultLedgerTransType = LedgerTransType::None;
            this.initializeLedgerJournalTable();

            if (ledgerJournalTable.RecId != 0 && ledgerJournalTable.JournalType == LedgerJournalType::Daily)
            {
                defaultLedgerTransType = LedgerTransType::GeneralJournal;
            }

            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, TransactionType)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, TransactionType), defaultLedgerTransType);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the transaction date field.
    /// </summary>
    protected void defaultTransDate()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, TransDate)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, TransDate), this.determineDefaultTransDate());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the Due field.
    /// </summary>
    protected void defaultDue()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Due)) || ledgerJournalTrans.Due == dateNull())
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Due), this.determineDueDateBasedOnTermsOfPayment());
            }
        }
        else if (operation == LedgerJournalOperation::Update)
        {
            if (this.validateMustUpdateDueDate())
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Due), this.determineDueDateBasedOnTermsOfPayment());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDueDateBasedOnTermsOfPayment</Name>
				<Source><![CDATA[
    private DueDate determineDueDateBasedOnTermsOfPayment()
    {
        DueDate dueDate;

        if (this.validateLedgerJournalTransDueDate())
        {
            ledgerJournalTrans.Due = ledgerJournalTrans.DocumentDate ? ledgerJournalTrans.DocumentDate : ledgerJournalTrans.TransDate;

            dueDate = PaymCalendarSourceLedgerJournalTrans::getUpdatedDueDate(ledgerJournalTrans, '');
        }
        else
        {
            dueDate = ledgerJournalTrans.Due;
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerJournalTransDueDate</Name>
				<Source><![CDATA[
    private boolean validateLedgerJournalTransDueDate()
    {
        boolean updateDueDate;

        // Previous LedgerJournalTrans Row can override the system date
        this.initializePreviousLedgerJournalTrans();

        if (ledgerJournalTrans.Due == dateNull() || previousLedgerJournalTrans.Due == ledgerJournalTrans.Due
            || ledgerJournalTrans.DocumentDate || ledgerJournalTrans.TransDate)
        {
            updateDueDate = true;
        }

        return updateDueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMustUpdateDueDate</Name>
				<Source><![CDATA[
    private boolean validateMustUpdateDueDate()
    {
        LedgerJournalTrans original = ledgerJournalTrans.orig();
        boolean mustUpdateDueDate;

        if ((original.TransDate != ledgerJournalTrans.TransDate || original.DocumentDate != ledgerJournalTrans.DocumentDate
            || original.Payment != ledgerJournalTrans.Payment) && original.Due == ledgerJournalTrans.Due)
        {
            mustUpdateDueDate = true;
        }

        return mustUpdateDueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default Due value.
    /// </summary>
    /// <returns>
    /// The default Due value.
    ///</returns>
    protected DueDate determineDue()
    {
        return ledgerJournalTrans.Due;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the PostingProfile field.
    /// </summary>
    protected void defaultPostingProfile()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, PostingProfile)) || !ledgerJournalTrans.PostingProfile)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, PostingProfile), this.determinePostingProfile());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default PostingProfile value.
    /// </summary>
    /// <returns>
    /// The default PostingProfile value.
    ///</returns>
    protected PostingProfile determinePostingProfile()
    {
        return ledgerJournalTrans.PostingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCustVendBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the CustVendBankAccountId field.
    /// </summary>
    protected void defaultCustVendBankAccountId()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, CustVendBankAccountId)) || !ledgerJournalTrans.CustVendBankAccountId)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, CustVendBankAccountId), this.determineCustVendBankAccountId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCustVendBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default CustVendBankAccountId value.
    /// </summary>
    /// <returns>
    /// The default CustVendBankAccountId value.
    ///</returns>
    protected BankAccountID determineCustVendBankAccountId()
    {
        return ledgerJournalTrans.CustVendBankAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTax1099FieldsRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the Tax1099FieldsRecId field.
    /// </summary>
    protected void defaultTax1099FieldsRecId()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Tax1099Fields)) || !ledgerJournalTrans.Tax1099Fields)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Tax1099Fields), this.determineTax1099Fields());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTax1099Fields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default Tax1099FieldsRecId value.
    /// </summary>
    /// <returns>
    /// The default Tax1099FieldsRecId value.
    ///</returns>
    protected Tax1099FieldsRecId determineTax1099Fields()
    {
        return ledgerJournalTrans.Tax1099Fields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the Payment field.
    /// </summary>
    protected void defaultPayment()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Payment)) || !ledgerJournalTrans.Payment)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Payment), this.determinePayment());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default Payment value.
    /// </summary>
    /// <returns>
    /// The default Payment value.
    ///</returns>
    protected PaymTermId determinePayment()
    {
        return ledgerJournalTrans.Payment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPaymMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the PaymMode field.
    /// </summary>
    protected void defaultPaymMode()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, PaymMode)) || !ledgerJournalTrans.PaymMode)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, PaymMode), this.determinePaymMode());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePaymMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default PaymMode value.
    /// </summary>
    /// <returns>
    /// The default PaymMode value.
    ///</returns>
    protected PaymMode determinePaymMode()
    {
        return ledgerJournalTrans.PaymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPaymSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the PaymSpec field.
    /// </summary>
    protected void defaultPaymSpec()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, PaymSpec)) || !ledgerJournalTrans.PaymSpec)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, PaymSpec), this.determinePaymSpec());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePaymSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default PaymSpec value.
    /// </summary>
    /// <returns>
    /// The default PaymSpec value.
    ///</returns>
    protected PaymMode determinePaymSpec()
    {
        return ledgerJournalTrans.PaymSpec;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultVATNumJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the VATNumJournal field.
    /// </summary>
    protected void defaultVATNumJournal()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, VATNumJournal)) || !ledgerJournalTrans.VATNumJournal)
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, VATNumJournal), this.determineVATNumJournal());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineVATNumJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default VATNumJournal value.
    /// </summary>
    /// <returns>
    /// The default VATNumJournal value.
    ///</returns>
    protected VATNumJournal determineVATNumJournal()
    {
        return ledgerJournalTrans.VATNumJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the description field.
    /// </summary>
    protected void defaultTxt()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Txt)))
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Txt), this.determineDefaultTxt());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value for the voucher field.
    /// </summary>
    protected void defaultVoucher()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            //
            // The voucher is typically determined by getting the next voucher number.  In this scenario, we need to ensure we
            // get the next voucher number once and ignore any consumer input.  Therefore, if the voucher number
            // was provided, its touched state is removed allowing the voucher number to be determined.
            //
            // It is possible the voucher number is not determined (manual).  In this case, the provided voucher number must
            // be preserved.  It is noteworthy that when the touched state is removed, the consumers original value is NOT
            // reset.  When the voucher number is determined, it will return the provided manual voucher number.
            //
            // Note:  Many methods can call this method, but only one voucher number will be taken.
            //
            // This implementation was chosen for two main reasons.  First, it was important to keep all the logic to determine
            // voucher numbers was important.  Second, it was important to keep the code as simple as possible for the majority of
            // scenarios (non-manual).
            //
            if (this.isConsumerStateTracked())
            {
                if (ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, Voucher)) != FieldState::Defaulted)
                {
                    this.initializeLedgerJournalTable();

                    if (ledgerJournalTrans.Voucher && NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).Manual)
                    {
                        ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, Voucher), FieldState::Defaulted);
                    }
                    else
                    {
                        ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, Voucher), FieldState::NotSet);
                    }
                }
            }

            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Voucher)))
            {
                Voucher voucher = this.determineDefaultVoucher();
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Voucher), voucher);

                // determine if check edit performance caches need flushing
                this.initializePreviousLedgerJournalTrans();

                if (previousLedgerJournalTrans.RecId && previousLedgerJournalTrans.Voucher != voucher)
                {
                    previousLedgerJournalTrans.flushAllowEditCaches();
                }
            }

            if (ledgerJournalTrans.Voucher == '')
            {
                LedgerJournalTransTypeInstrumentation::logJournalBlankVoucherWarning(ledgerJournalName.NewVoucher, ledgerJournalName.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultVoucher_CN</Name>
				<Source><![CDATA[
    protected void defaultVoucher_CN()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            //
            // The voucher is tyically determined by getting the next voucher number.  In this sceario, we need to ensure we
            // get the next voucher number once and ignore any consumer input.  Therefore, if the voucher number
            // was provided, its touched state is removed allowing the voucher number to be determined.
            //
            // It is possible the voucher number is not determined (manual).  In this case, the provided voucher number must
            // be preserved.  It is noteworthy that when the touched state is removed, the consumers original value is NOT
            // reset.  When the voucher number is determined, it will return the provided manual voucher number.
            //
            // Note:  Many methods can call this method, but only one voucher number will be taken.
            //
            // This implementation was chosen for two main reasons.  First, it was important to keep all the logic to determine
            // voucher numbers was important.  Second, it was important to keep the code as simple as possible for the majority of
            // scenarios (non-manual).
            //
            if (this.isConsumerStateTracked())
            {
                if (ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, Voucher_CN)) != FieldState::Defaulted)
                {
                    ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, Voucher_CN), FieldState::NotSet);
                }
            }

            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Voucher_CN)))
            {   
                previousLedgerJournalTrans.clear();
                Voucher_CN voucher_CN = this.determineDefaultVoucher_CN();
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Voucher_CN), voucher_CN);

                // determine if check edit performance caches need flushing
                this.initializePreviousLedgerJournalTrans();

                if (previousLedgerJournalTrans.RecId && previousLedgerJournalTrans.Voucher_CN != voucher_CN)
                {
                    previousLedgerJournalTrans.flushAllowEditCaches();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default currency code value.
    /// </summary>
    /// <returns>
    /// The default currency code value.
    /// </returns>
    protected CurrencyCode determineDefaultCurrencyCode()
    {
        CurrencyCode currencyCode;

        // Previous Line Currency Code
        this.initializePreviousLedgerJournalTrans();

        if (previousLedgerJournalTrans.RecId != 0)
        {
            this.defaultVoucher();

            if (previousLedgerJournalTrans.Voucher == ledgerJournalTrans.Voucher)
            {
                this.initializeLedgerJournalName();

                if (ledgerJournalName.RecId != 0)
                {
                    if (ledgerJournalName.NewVoucher == NewVoucher::Manually)
                    {
                        if (previousLedgerJournalTrans.CurrencyCode)
                        {
                            currencyCode = previousLedgerJournalTrans.CurrencyCode;
                        }
                    }
                    else
                    {
                        currencyCode = previousLedgerJournalTrans.CurrencyCode;
                    }

                    // The LedgerJournalTable.CurrencyCode can override the previous line currency code
                    this.initializeLedgerJournalTable();

                    if (ledgerJournalTable.RecId != 0 &&  ledgerJournalTable.CurrencyCode)
                    {
                        currencyCode = ledgerJournalTable.CurrencyCode;
                    }
                }
            }
        }

        if (!currencyCode)
        {
            this.initializeLedgerJournalTable();

            if (ledgerJournalTable.RecId != 0 &&  ledgerJournalTable.CurrencyCode)
            {
                currencyCode = ledgerJournalTable.CurrencyCode;
            }
        }

        if (!currencyCode)
        {
            this.initializeCompanyCurrency();

            if (companyCurrencyCode)
            {
                currencyCode = companyCurrencyCode;
            }
        }

        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default DefaultDimension value.
    /// </summary>
    /// <returns>
    /// The default DefaultDimension value.
    /// </returns>
    protected DimensionDefault determineDefaultDimension()
    {
        DimensionDefault defaultDimension;

        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0 && ledgerJournalTable.DefaultDimension)
        {
            defaultDimension = ledgerJournalTable.DefaultDimension;
        }

        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default exchange rate.
    /// </summary>
    /// <returns>
    /// The default exchange rate.
    /// </returns>
    protected ExchRate determineDefaultExchRate()
    {
        ExchRate exchRate;

        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0)
        {
            if (ledgerJournalTable.CurrencyCode)
            {
                if (ledgerJournalTable.FixedExchRate 
                    && ledgerJournalTable.ExchRate
                    && ledgerJournalTable.CurrencyCode == ledgerJournalTrans.CurrencyCode)
                {
                    exchRate = ledgerJournalTable.ExchRate;
                }
                else
                {
                    exchRate = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                }
            }
        }

        if (!exchRate)
        {
            if (this.validateCurrencyCode(false))
            {
                exchRate = ExchangeRateHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId), ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate).getExchangeRate1();
            }
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultExchRateSecond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default secondary exchange rate.
    /// </summary>
    /// <returns>
    /// The default secondary exchange rate.
    /// </returns>
    protected ExchrateSecondary determineDefaultExchRateSecond()
    {
        ExchrateSecondary   exchrateSecondary;

        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0)
        {
            if (ledgerJournalTable.CurrencyCode)
            {
                if (ledgerJournalTable.FixedExchRate
                    && ledgerJournalTable.ExchrateSecondary
                    && ledgerJournalTable.CurrencyCode == ledgerJournalTrans.CurrencyCode)
                {
                    exchrateSecondary = ledgerJournalTable.ExchrateSecondary;
                }
                else
                {
                    exchrateSecondary = ExchangeRateHelper::exchRateSecond(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                }
            }
        }

        if (!exchrateSecondary)
        {
            if (this.validateCurrencyCode(false))
            {
                exchrateSecondary = ExchangeRateHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId), ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate).getExchangeRate2();
            }
        }

        return exchrateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default line number value.
    /// </summary>
    /// <returns>
    /// The default line number value.
    /// </returns>
    protected LineNum determineDefaultLineNum()
    {
        LineNum     lineNum;

        // Performance Improvement.
        // If the line number is not defaulted, the LedgerJournalTrans.insert() method will make a call to
        // the database to determine the next line number.  We will most likely have the previous ledger journal
        // trans row for other reasons, so it makes sense to default the line number and save one unnecessary trip
        // to the database.
        this.initializePreviousLedgerJournalTrans();

        if (previousLedgerJournalTrans.RecId == 0 )
        {
            lineNum = 1;
        }
        else
        {
            lineNum = previousLedgerJournalTrans.LineNum + 1;
        }

        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultOffsetDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default OffsetDefaultDimension value.
    /// </summary>
    /// <returns>
    /// The default OffsetDefaultDimension value.
    /// </returns>
    protected DimensionDefault determineDefaultOffsetDefaultDimension()
    {
        // the base implementation should not be called
        throw error(strFmt("@SYS19306", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultReverseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default ReverseDate.
    /// </summary>
    /// <returns>The default ReverseDate value.</returns>
    protected TransDate determineDefaultReverseDate()
    {
        TransDate reverseDate;

        // If the previous entered voucher line, or the current line has a reverse date set,
        // update the reverse date for the voucher with the current line taking precedent
        if (previousLedgerJournalTrans.RecId != 0 && previousLedgerJournalTrans.Voucher == ledgerJournalTrans.Voucher
            && (previousLedgerJournalTrans.ReverseDate != dateNull() || ledgerJournalTrans.ReverseDate != dateNull()))
        {
            reverseDate = ledgerJournalTrans.ReverseDate == dateNull() ? previousLedgerJournalTrans.ReverseDate : ledgerJournalTrans.ReverseDate;
        }
        else if (ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ReverseDate)))
        {
            reverseDate = ledgerJournalTrans.ReverseDate;
        }
        else
        {
            // Default from header
            reverseDate = ledgerJournalTable.ReverseDate;
        }

        return reverseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultReverseEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default ReverseEntry value.
    /// </summary>
    /// <returns>The default ReverseEntry value.</returns>
    protected NoYes determineDefaultReverseEntry()
    {
        NoYes reverseEntry;

        // If the previous entered voucher line, or the current line has the reverse entry set,
        // update or retain the reverse entry for the voucher
        if (previousLedgerJournalTrans.RecId != 0 && previousLedgerJournalTrans.Voucher == ledgerJournalTrans.Voucher
            && (previousLedgerJournalTrans.ReverseEntry || ledgerJournalTrans.ReverseEntry))
        {
            reverseEntry = NoYes::Yes;
        }
        else if (ledgerJournalTrans.isFieldSet(fieldnum(LedgerJournalTrans, ReverseEntry)))
        {
            reverseEntry = ledgerJournalTrans.ReverseEntry;
        }
        else
        {
            // Default from header
            reverseEntry = ledgerJournalTable.ReverseEntry;
        }

        return reverseEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default TaxGroup value.
    /// </summary>
    /// <returns>
    /// The default TaxGroup value.
    /// </returns>
    protected TaxGroupJournal determineDefaultTaxGroup()
    {
        // the base implementation should not be called
        throw error(strFmt("@SYS19306", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default TaxItemGroup value.
    /// </summary>
    /// <returns>
    /// The default TaxItemGroup value.
    /// </returns>
    protected TaxGroupJournal determineDefaultTaxItemGroup()
    {
        // the base implementation should not be called
        throw error(strFmt("@SYS19306", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default TransDate value.
    /// </summary>
    /// <returns>
    /// The default TransDate value.
    /// </returns>
    protected TransDate determineDefaultTransDate()
    {
        TransDate   transDate;

        transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        // Previous LedgerJournalTrans Row can override the system date
        this.initializePreviousLedgerJournalTrans();

        if (previousLedgerJournalTrans.RecId != 0)
        {
            this.defaultVoucher();

            if (previousLedgerJournalTrans.Voucher == ledgerJournalTrans.Voucher)
            {
                this.initializeLedgerJournalName();

                if (ledgerJournalName.RecId != 0)
                {
                    if (ledgerJournalName.NewVoucher == NewVoucher::Manually)
                    {
                        if (previousLedgerJournalTrans.TransDate)
                        {
                            transDate = previousLedgerJournalTrans.TransDate;
                        }
                    }
                    else
                    {
                        transDate = previousLedgerJournalTrans.TransDate;
                    }
                }
            }
        }

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default Txt value.
    /// </summary>
    /// <returns>
    /// The default Txt value.
    /// </returns>
    protected LedgerJournalTransTxt determineDefaultTxt()
    {
        LedgerJournalTransTxt   ledgerJournalTransTxt;

        this.initializePreviousLedgerJournalTrans();

        if (previousLedgerJournalTrans.RecId != 0)
        {
            this.defaultVoucher();

            if (previousLedgerJournalTrans.Voucher == ledgerJournalTrans.Voucher)
            {
                this.initializeLedgerJournalName();

                if (ledgerJournalName.RecId != 0)
                {
                    if (ledgerJournalName.NewVoucher == NewVoucher::Manually)
                    {
                        if (previousLedgerJournalTrans.Txt)
                        {
                            ledgerJournalTransTxt = previousLedgerJournalTrans.Txt;
                        }
                    }
                    else
                    {
                        ledgerJournalTransTxt = previousLedgerJournalTrans.Txt;
                    }
                }
            }
        }

        return ledgerJournalTransTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default voucher value.
    /// </summary>
    /// <returns>
    /// The default voucher value.
    /// </returns>
    protected Voucher determineDefaultVoucher()
    {
        Voucher voucher;

        this.initializeLedgerJournalName();

        if (ledgerJournalName.RecId != 0)
        {
            switch (ledgerJournalName.NewVoucher)
            {
                case NewVoucher::BalanceSheet:

                    this.initializePreviousLedgerJournalTrans();

                    if (previousLedgerJournalTrans.RecId == 0)
                    {
                        // first line
                        reservedVoucher = this.getNewVoucher();
                        voucher = reservedVoucher;
                    }
                    else
                    {
                        if (!previousLedgerJournalTrans.parmLedgerDimension() && previousLedgerJournalTrans.Voucher)
                        {
                            // the account number was not entered so it can not balance
                            voucher = previousLedgerJournalTrans.Voucher;
                        }
                        else
                        {
                            if (this.isVoucherBalanced(previousLedgerJournalTrans.Voucher, previousLedgerJournalTrans.JournalNum))
                            {
                                // If consumer state is tracked (we are in the context of a service or import), then
                                // it is not acceptable to use the voucher number set on the buffer.  The field state
                                // is set to NotSet, despite there may be a value provided for that field.
                                if (ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Voucher)))
                                {
                                    // voucher balances - retrieve voucher number if it has been generated already
                                    voucher = ledgerJournalTrans.Voucher;
                                }

                                if (!voucher)
                                {
                                    reservedVoucher = this.getNewVoucher();
                                    voucher = reservedVoucher;
                                }

                                LedgerJournalTransTypeCache::resetJournalVoucherCache(previousLedgerJournalTrans.JournalNum, previousLedgerJournalTrans.Voucher);
                            }
                            else
                            {
                                // voucher does not balance yet
                                voucher = previousLedgerJournalTrans.Voucher;
                            }
                        }
                    }
                    break;

                case NewVoucher::OneVoucher:
                    this.initializePreviousLedgerJournalTrans();

                    if (previousLedgerJournalTrans.RecId == 0)
                    {
                        // first line
                        reservedVoucher = this.getNewVoucher();
                        voucher = reservedVoucher;
                    }
                    else
                    {
                        // all other lines should use the same voucher
                        voucher = previousLedgerJournalTrans.Voucher;
                    }
                    break;

                case NewVoucher::Manually:
                    voucher = ledgerJournalTrans.Voucher;
                    break;

                default:
                    break;
            }
        }

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultVoucher_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default Voucher_CN value.
    /// </summary>
    /// <returns>
    /// The default Voucher_CN value.
    /// </returns>
    protected Voucher determineDefaultVoucher_CN()
    {
        Voucher_CN voucher_CN;

        this.initializeLedgerJournalName();

        if (ledgerJournalName.RecId != 0)
        {
            switch (ledgerJournalName.NewVoucher)
            {
                case NewVoucher::BalanceSheet:

                    this.initializePreviousLedgerJournalTrans();

                    if (previousLedgerJournalTrans.RecId == 0)
                    {
                        // first line
                        this.defaultLedgerVoucherType_CN();
                        reservedVoucher_CN = this.getNewVoucher_CN();
                        voucher_CN = reservedVoucher_CN;
                    }
                    else
                    {
                        if (!previousLedgerJournalTrans.parmLedgerDimension() && previousLedgerJournalTrans.Voucher)
                        {
                            // the account number was not entered so it can not balance
                            this.defaultLedgerVoucherType_CN(previousLedgerJournalTrans.LedgerVoucherType_CN);
                            voucher_CN = previousLedgerJournalTrans.Voucher_CN;
                        }
                        else
                        {
                            if (this.isVoucherBalanced(previousLedgerJournalTrans.Voucher, previousLedgerJournalTrans.JournalNum))
                            {
                                // If consumer state is tracked (we are in the context of a service or import), then
                                // it is not acceptable to use the voucher number set on the buffer.  The field state
                                // is set to NotSet, despite there may be a value provided for that field.
                                if (ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Voucher_CN)))
                                {
                                    // voucher balances - retrieve voucher number if it has been generated already
                                    voucher_CN = ledgerJournalTrans.Voucher_CN;
                                }

                                if (!voucher_CN)
                                {
                                    this.defaultLedgerVoucherType_CN();
                                    reservedVoucher_CN = this.getNewVoucher_CN();
                                    voucher_CN = reservedVoucher_CN;
                                }
                            }
                            else
                            {
                                // voucher does not balance yet
                                this.defaultLedgerVoucherType_CN(previousLedgerJournalTrans.LedgerVoucherType_CN);
                                voucher_CN = previousLedgerJournalTrans.Voucher_CN;
                            }

                            LedgerJournalTransTypeCache::resetJournalVoucherCache(previousLedgerJournalTrans.JournalNum, previousLedgerJournalTrans.Voucher);
                        }
                    }
                    break;

                case NewVoucher::OneVoucher:
                    this.initializePreviousLedgerJournalTrans();

                    if (previousLedgerJournalTrans.RecId == 0)
                    {
                        // first line
                        this.defaultLedgerVoucherType_CN();
                        reservedVoucher_CN = this.getNewVoucher_CN();
                        voucher_CN = reservedVoucher_CN;
                    }
                    else
                    {
                        // all other lines should use the same voucher
                        this.defaultLedgerVoucherType_CN(previousLedgerJournalTrans.LedgerVoucherType_CN);
                        voucher_CN = previousLedgerJournalTrans.Voucher_CN;
                    }
                    break;

                case NewVoucher::Manually:
                    voucher_CN = ledgerJournalTrans.Voucher_CN;
                    break;

                default:
                    break;
            }
        }

        return voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewVoucher</Name>
				<Source><![CDATA[
    protected Voucher getNewVoucher()
    {
        Voucher     voucher;
        NumberSeq   numberSeq;
        boolean     makeDecisionLater;

        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0)
        {
            // Interactive Mode
            if (!this.isConsumerStateTracked())
            {
                makeDecisionLater = true;
            }

            numberSeq = NumberSeq::newGetVoucherFromId(ledgerJournalTable.NumberSequenceTable, makeDecisionLater);
            voucher = numberSeq.voucher();
        }

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewVoucher_CN</Name>
				<Source><![CDATA[
    protected Voucher getNewVoucher_CN()
    {
        Voucher_CN  voucher_CN;
        NumberSeq   numberSeq;
        RefRecId    numberSequenceTableRecId;
        boolean     makeDecisionLater;

        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0)
        {
            // Interactive Mode
            if (!this.isConsumerStateTracked())
            {
                makeDecisionLater = true;
            }

            numberSequenceTableRecId = LedgerVoucherType_CN::find(ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable;

            if (numberSequenceTableRecId != 0)
            {
                numberSeq = NumberSeq_Voucher_CN::newGetVoucherFromCode(numberSequenceTableRecId, ledgerJournalTrans.TransDate, makeDecisionLater);
            }

            if (numberSeq)
            {
                voucher_CN = numberSeq.voucher();
            }
        }

        return voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLedgerVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the Chinese ledger voucher type with the provided type, if not set.
    /// If no voucher type provided, defaults with the type which conforms to the voucher type rule.
    /// </summary>
    /// <param name="_ledgerVoucherType_CN">
    /// The Chinese ledger voucher type to default with.
    /// </param>
    private void defaultLedgerVoucherType_CN(LedgerVoucherTypeRefRecId_CN _ledgerVoucherType_CN = 0)
    {
        if (ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, LedgerVoucherType_CN)))
        {
            return;
        }

        if (_ledgerVoucherType_CN == 0)
        {
            LedgerVoucherTypeRule_CN ledgerVoucherTypeRule_CN = LedgerVoucherTypeRule_CN::newFromVoucher(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher);
            if (ledgerVoucherTypeRule_CN)
            {
                _ledgerVoucherType_CN = ledgerVoucherTypeRule_CN.getVoucherType().RecId;
            }
        }

        this.defaultFieldValue(fieldNum(LedgerJournalTrans, LedgerVoucherType_CN), _ledgerVoucherType_CN);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucherBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs currency conversion if required on the <c>LedgerJournalTrans</c> amounts.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name="_previousLedgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_voucher">
    /// A voucher number.
    /// </param>
    /// <returns>
    /// A <c>TmpVoucherSum</c> table buffer that contains the totals.
    /// </returns>
    private TmpVoucherSum getVoucherBalance(
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTrans _previousLedgerJournalTrans,
        Voucher _voucher)
    {
        TmpVoucherSum       tmpVoucherSum;
        Amount              debitAmount;
        Amount              creditAmount;

        if (_previousLedgerJournalTrans.AmountCurDebit)
        {
            if (_previousLedgerJournalTrans.CurrencyCode == Ledger::accountingCurrency())
            {
                debitAmount = _previousLedgerJournalTrans.AmountCurDebit;
            }
            else
            {
                debitAmount = _previousLedgerJournalTrans.calcDebitMST(true, _ledgerJournalTable);
            }
        }
        else
        {
            debitAmount = 0;
        }

        if (_previousLedgerJournalTrans.AmountCurCredit)
        {
            if (_previousLedgerJournalTrans.CurrencyCode == Ledger::accountingCurrency())
            {
                creditAmount = _previousLedgerJournalTrans.AmountCurCredit;
            }
            else
            {
                creditAmount = _previousLedgerJournalTrans.calcCreditMST(true, _ledgerJournalTable);
            }
        }
        else
        {
            creditAmount = 0;
        }

        tmpVoucherSum.Debit += debitAmount;
        tmpVoucherSum.Credit += creditAmount;

        if (_previousLedgerJournalTrans.OffsetLedgerDimension != 0)
        {
            // Credit and debit are reversed since this is an offset account
            tmpVoucherSum.Debit += creditAmount;
            tmpVoucherSum.Credit += debitAmount;
        }

        tmpVoucherSum.SumCur += _previousLedgerJournalTrans.AmountCurDebit - _previousLedgerJournalTrans.AmountCurCredit;

        tmpVoucherSum.Voucher = _voucher;

        return tmpVoucherSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCompanyCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the company currency code value.
    /// </summary>
    protected void initializeCompanyCurrency()
    {
        this.defaultCompany();
        this.validateCompany();

        if (!companyCurrencyCode || companyCurrencyCode != ledgerJournalTrans.CurrencyCode)
        {
            companyCurrencyCode = Ledger::accountingCurrency(CompanyInfo::findDataArea(curext()).RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the ledger journal name value.
    /// </summary>
    protected void initializeLedgerJournalName()
    {
        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0)
        {
            if (ledgerJournalName.JournalName != ledgerJournalTable.JournalName)
            {
                ledgerJournalName = LedgerJournalName::find(ledgerJournalTable.JournalName);
            }
        }

        if (ledgerJournalName.RecId == 0)
        {
            LedgerJournalTransTypeInstrumentation::logJournalNameRecIdZero();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the local <c>LedgerJournalTable</c> table buffer.
    /// </summary>
    protected void initializeLedgerJournalTable()
    {
        if (ledgerJournalTable.JournalNum != ledgerJournalTrans.JournalNum)
        {
            ledgerJournalTable = LedgerJournalTable::find(ledgerJournalTrans.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePreviousLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the local previous <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    protected void initializePreviousLedgerJournalTrans()
    {
        if (previousLedgerJournalTrans.RecId == 0)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(Project))
                && ledgerJournalName.JournalType == LedgerJournalType::Cost)
            {
                // Offset Account is mandatory for Expense Journal and where <c>AmountCurDebit</c> or <c>AmountCurCredit</c> should have values otherwise system does not allow to post the journal.
                select firstonly previousLedgerJournalTrans
                    order by LineNum desc
                    where previousLedgerJournalTrans.JournalNum == ledgerJournalTrans.JournalNum
                     && (previousLedgerJournalTrans.AmountCurDebit != 0 || previousLedgerJournalTrans.AmountCurCredit != 0);
            }
            else
            {
                select firstonly previousLedgerJournalTrans
                    order by LineNum desc
                    where previousLedgerJournalTrans.JournalNum == ledgerJournalTrans.JournalNum;
            }

            if (previousLedgerJournalTrans.RecId)
            {
                // Set the cache state flag to later determine if the voucher balance needs to be re-calculated,
                // or resume voucher balancing from stored cache values
                isCacheStateValid = LedgerJournalTransTypeCache::checkValidCacheState(previousLedgerJournalTrans);

                LedgerJournalTransTypeCache::setLedgerJournalTransactionId(ledgerJournalTrans.JournalNum, previousLedgerJournalTrans.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConsumerStateTracked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether consumer state is tracked.
    /// </summary>
    /// <returns>
    /// True if the consumer state is tracked; otherwise, false.
    /// </returns>
    /// <remarks>
    /// When this class is used in the context of a service, consumer state is tracked. When this class is used
    /// in the context of an AX client form, consumer state is not tracked. It is sometimes important to understand
    /// these contexts because logic that is used to provide default values can be different.
    /// </remarks>
    protected boolean isConsumerStateTracked()
    {
        if (!isInteractiveContext)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the journal line is an intercompany line.
    /// </summary>
    /// <returns>
    /// true if the journal line is an intercompany line; otherwise, false.
    /// </returns>
    protected boolean isInterCompany()
    {
        if (ledgerJournalTrans.Company &&
            ledgerJournalTrans.OffsetCompany &&
            ledgerJournalTrans.Company != ledgerJournalTrans.OffsetCompany)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVoucherBalanced</Name>
				<Source><![CDATA[
    private boolean isVoucherBalanced(Voucher _voucher, LedgerJournalId _journalNum)
    {
        TmpVoucherSum       tmpVoucherSum;
        Amount              voucherAmount;
        Amount              voucherTotalDebit;
        Amount              voucherTotalCredit;
        CurrencyCode        voucherRunningCurrencyCode;

        // Check if the balancing cache for the journal is in a valid state.  If it is not, reset
        // the cache, and the voucher balance must be re-calculated.
        if (isCacheStateValid == false)
        {
            // Reset the cache, and initialize the balance totals.
            LedgerJournalTransTypeCache::resetJournalVoucherCache(previousLedgerJournalTrans.JournalNum, previousLedgerJournalTrans.Voucher);
            LedgerJournalTransTypeCache::setLedgerJournalTransactionId(_journalNum, previousLedgerJournalTrans.RecId);

            tmpVoucherSum = LedgerJournalEngine_Server::createVoucherBalance(_voucher, _journalNum);

            voucherTotalDebit = tmpVoucherSum.Debit;
            voucherTotalCredit = tmpVoucherSum.Credit;

            voucherRunningCurrencyCode = Ledger::accountingCurrency();
        }
        else
        {
            voucherRunningCurrencyCode = LedgerJournalTransTypeCache::getVoucherRunningCurrencyCode(
                _journalNum,
                _voucher);

            if (!voucherRunningCurrencyCode)
            {
                voucherRunningCurrencyCode = previousLedgerJournalTrans.CurrencyCode;
                LedgerJournalTransTypeCache::setVoucherRunningCurrencyCode(_journalNum, _voucher, voucherRunningCurrencyCode);
            }

            voucherTotalDebit = LedgerJournalTransTypeCache::getVoucherRunningTotalDebit(_journalNum, _voucher);
            voucherTotalCredit = LedgerJournalTransTypeCache::getVoucherRunningTotalCredit(_journalNum, _voucher);

            if (voucherRunningCurrencyCode == previousLedgerJournalTrans.CurrencyCode)
            {
                // As long as all the lines use the same currency, the totals use the transaction currency
                // amount instead of using a currency translation because the currency translation reduces performance
                if (previousLedgerJournalTrans.OffsetLedgerDimension == 0)
                {
                    voucherTotalDebit += previousLedgerJournalTrans.AmountCurDebit;
                    voucherTotalCredit += previousLedgerJournalTrans.AmountCurCredit;
                }
            }
            else
            {
                // Different currencies exist, so unfortunately they need
                // to be calculated row-by-row to avoid rounding issues
                if (voucherRunningCurrencyCode == Ledger::accountingCurrency())
                {
                    // Convert the new amount to the accounting currency because a common currency is required to determine if it is balanced
                    tmpVoucherSum = this.getVoucherBalance(ledgerJournalTable, previousLedgerJournalTrans, _voucher);

                    voucherTotalDebit += tmpVoucherSum.Debit;
                    voucherTotalCredit += tmpVoucherSum.Credit;
                }
                else
                {
                    // Reset the running totals to be in the accounting currency for the records so
                    // far because multiple currencies are now being used.
                    tmpVoucherSum = LedgerJournalEngine_Server::createVoucherBalance(_voucher, _journalNum);

                    voucherTotalDebit = tmpVoucherSum.Debit;
                    voucherTotalCredit = tmpVoucherSum.Credit;

                    voucherRunningCurrencyCode = Ledger::accountingCurrency();
                }
            }
        }

        voucherAmount = (voucherTotalDebit - voucherTotalCredit);

        LedgerJournalTransTypeCache::setVoucherRunningCurrencyCode(_journalNum, _voucher, voucherRunningCurrencyCode);
        LedgerJournalTransTypeCache::setVoucherRunningTotalDebit(_journalNum, _voucher, voucherTotalDebit);
        LedgerJournalTransTypeCache::setVoucherRunningTotalCredit(_journalNum, _voucher, voucherTotalCredit);

        isCacheStateValid = true;

        if (previousLedgerJournalTrans.CurrencyCode != Ledger::accountingCurrency())
        {
            AmountMST maxRoundingDifferenceAccountingCurrency = this.maximumRoundingDifferenceInAccountingCurrency(
                LedgerParameters::find(),
                _journalNum);

            return LedgerJournalEngine::isVoucherAmountsInBalanceForMultiCurrency(maxRoundingDifferenceAccountingCurrency, voucherAmount, voucherTotalDebit, voucherTotalCredit);
        }
        else
        {
            return LedgerJournalEngine::isVoucherAmountsInBalance(0, voucherAmount, voucherTotalDebit, voucherTotalCredit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRoundingDifferenceInAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum rounding difference amount in accounting currency.
    /// </summary>
    /// <param name = "_ledgerParameters">The <c>LedgerParameters</c> table record to determine the default value.</param>
    /// <param name = "_ledgerJournalId">The journal number to provide journal level override; optional.</param>
    /// <returns>The maximum rounding difference amount threshold for accounting currency.</returns>
    /// <remarks>
    /// Extension point for chain of command.
    /// </remarks>
    protected AmountMST maximumRoundingDifferenceInAccountingCurrency(LedgerParameters _ledgerParameters, LedgerJournalId _ledgerJournalId)
    {
        return _ledgerParameters.MaxRoundingDifferenceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the AccountType value.
    /// </summary>
    /// <returns>
    /// true if the AccountType is valid; otherwise, false.
    /// </returns>
    protected boolean validateAccountType()
    {
        boolean isValid = true;

        this.initializeLedgerJournalTable();

        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::Daily :
                if (ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger &&
                    ledgerJournalTrans.AccountType != LedgerJournalACType::Bank &&
                    ledgerJournalTrans.AccountType != LedgerJournalACType::Vend &&
                    ledgerJournalTrans.AccountType != LedgerJournalACType::Cust &&
                    ledgerJournalTrans.AccountType != LedgerJournalACType::Project)
                {
                    if (this.isConsumerStateTracked())
                    {
                        isValid = checkFailed("@SYS117885");
                    }
                }
                break;

            default :
                break;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the Company value.
    /// </summary>
    /// <returns>
    /// true if the Company is valid; otherwise, false.
    /// </returns>
    protected boolean validateCompany()
    {
        TableId                 tableId;
        FieldId                 fieldId;
        boolean                 isValid = true;

        tableId = tableNum(LedgerJournalTrans);
        fieldId = fieldNum(LedgerJournalTrans, Company);

        if (ledgerJournalTrans.Company)
        {
            isValid = ledgerJournalTrans.checkDataAreaAccessible(ledgerJournalTrans.Company);

            if (isValid == false && this.isConsumerStateTracked())
            {
                throw error("@SYS98197");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the currency code value.
    /// </summary>
    /// <param name = "logFault">
    /// Determines if an error message should be logged; optional.
    /// </param>
    /// <returns>
    /// true if the currency code is valid; otherwise, false.
    /// </returns>
    protected boolean validateCurrencyCode(boolean logFault = true)
    {
        boolean isValid = true;

        if (!ledgerJournalTrans.CurrencyCode)
        {
            isValid = false;

            if (logFault)
            {
                return checkFailed("@SYS118080");
            }
        }

        if (isValid)
        {
            isValid = Currency::exist(ledgerJournalTrans.CurrencyCode);

            if (isValid == false && logFault == true)
            {
                return checkFailed(strFmt("@SYS117888", ledgerJournalTrans.CurrencyCode));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDimension</Name>
				<Source><![CDATA[
	/// <summary>
    /// Helper function for both the validateDefaultDimension and the validateOffsetDefaultDimension that 
    /// performs validation checks for both functions that would otherwise be duplicated in each.
    /// </summary>
    /// <param name = "_company">
    /// the company value
	/// </param>
    /// <param name = "_dimension">
	/// the dimension that is being verified
	/// </param>
    /// <returns>
    /// true if the dimension is valid
	/// </returns>
    private static boolean validateDimension(SelectableDataArea _company, DimensionDefault _dimension) 
	{
		boolean isValid = true;

        if (curExt() != _company)
        {
			changecompany(_company)
			{
				isValid = DimensionValidation::validateDefaultDimension(_dimension);
			}
        }
        else
        {
			isValid = DimensionValidation::validateDefaultDimension(_dimension);
        }

        return isValid;
	}

]]></Source>
			</Method>
			<Method>
				<Name>validateDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the DefaultDimension value.
    /// </summary>
    /// <returns>
    /// true if the DefaultDimension is valid; otherwise, false.
    /// </returns>
    protected boolean validateDefaultDimension()
    {
        boolean isValid = true;

        if (ledgerJournalTrans.DefaultDimension)
        {
            isValid = LedgerJournalTransType::validateDimension(ledgerJournalTrans.Company, LedgerJournalTrans.DefaultDimension);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the value for a specific field.
    /// </summary>
    /// <param name="_fieldId">
    ///    The field identifier that corresponds with the field being validated.
    /// </param>
    /// <returns>
    ///    true if the value is valid; otherwise, false.
    /// </returns>
    public boolean validateField(FieldId _fieldId)
    {
        FieldName fieldName;
        MethodName methodName;
        SysDictClass sysDictClass;
        boolean isValid = true;

        fieldName = fieldId2name(tableNum(LedgerJournalTrans), _fieldId);
        methodName = 'validate' + fieldName;
        sysDictClass = new SysDictClass(classIdGet(this));

        if (sysDictClass.hasObjectMethod(methodName))
        {
            isValid = sysDictClass.callObject(methodName, this);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the JournalNum value.
    /// </summary>
    /// <returns>
    /// true if the JournalNum is valid; otherwise, false.
    /// </returns>
    protected boolean validateJournalNum()
    {
        boolean isValid = true;

        if (!ledgerJournalTrans.JournalNum)
        {
            isValid = checkFailed("@SYS119225");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the LedgerDimension value.
    /// </summary>
    /// <param name = "logFault">
    /// Determines if an error message should be logged; optional.
    /// </param>
    /// <returns>
    /// Does not return since this is an abstract method.
    /// </returns>
    protected abstract boolean validateLedgerDimension(boolean logFault = true)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the LineNum value.
    /// </summary>
    /// <returns>
    /// true if the LineNum is valid; otherwise, false.
    /// </returns>
    protected boolean validateLineNum()
    {
        boolean             isValid = true;
        LedgerJournalTrans  localLedgerJournalTrans;

        if (ledgerJournalTrans.LineNum != 0)
        {
            select firstonly LineNum from localLedgerJournalTrans
                where localLedgerJournalTrans.JournalNum == ledgerJournalTrans.JournalNum &&
                localLedgerJournalTrans.LineNum == ledgerJournalTrans.LineNum;

            if (localLedgerJournalTrans.LineNum == ledgerJournalTrans.LineNum)
            {
                isValid = checkFailed(strFmt("@SYS119226", ledgerJournalTrans.LineNum));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOffsetAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the OffsetAccountType value.
    /// </summary>
    /// <returns>
    /// true if the OffsetAccountType is valid; otherwise, false.
    /// </returns>
    protected boolean validateOffsetAccountType()
    {
        boolean isValid = true;

        this.initializeLedgerJournalTable();

        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::Daily :
                if (ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Ledger &&
                    ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Bank &&
                    ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Cust &&
                    ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Vend &&
                    ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Project)
                {
                    if (this.isConsumerStateTracked())
                    {
                        isValid = checkFailed("@SYS118081");
                    }
                }
                break;

            default :
                break;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOffsetCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the OffsetCompany value.
    /// </summary>
    /// <returns>
    /// true if the OffsetCompany is valid; otherwise, false.
    /// </returns>
    protected boolean validateOffsetCompany()
    {
        boolean isValid = true;

        if (ledgerJournalTrans.OffsetCompany)
        {
            isValid = ledgerJournalTrans.checkDataAreaAccessible(ledgerJournalTrans.OffsetCompany);

            if (isValid == false && this.isConsumerStateTracked())
            {
                throw error("@SYS98197");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOffsetDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the OffsetDefaultDimension value.
    /// </summary>
    /// <returns>
    /// true if the OffsetDefaultDimension is valid; otherwise, false.
    /// </returns>
    protected boolean validateOffsetDefaultDimension()
    {
        boolean isValid = true;

        if (ledgerJournalTrans.OffsetDefaultDimension)
        {
            isValid = LedgerJournalTransType::validateDimension(ledgerJournalTrans.OffsetCompany, LedgerJournalTrans.OffsetDefaultDimension);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the OffsetLedgerDimension value.
    /// </summary>
    /// <param name = "logFault">
    /// Determines if an error message should be logged; optional.
    /// </param>
    /// <returns>
    /// true if the OffsetLedgerDimension is valid; otherwise, false.
    /// </returns>
    protected boolean validateOffsetLedgerDimension(boolean logFault = true)
    {
        boolean isValid = true;

        this.initializeLedgerJournalTable();

        if (ledgerJournalTable.RecId != 0)
        {
            if (ledgerJournalTable.FixedOffsetAccount && ledgerJournalTable.parmOffsetLedgerDimension())
            {
                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    isValid = (LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(ledgerJournalTable.parmOffsetLedgerDimension()) == LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(ledgerJournalTrans.parmOffsetLedgerDimension()));
                }
                else
                {
                    isValid = (ledgerJournalTable.parmOffsetLedgerDimension() == ledgerJournalTrans.parmOffsetLedgerDimension());
                }
                if (!isValid && logFault)
                {
                    checkFailed(strFmt("@SYS117884", ledgerJournalTrans.parmOffsetAccount()));
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cross validates field values for a <c>LedgerJournalTrans</c> row.
    /// </summary>
    /// <returns>
    ///    true if the valid; otherwise, false.
    /// </returns>
    public boolean validateRow()
    {
        boolean         isValid;
        tableId         tableId;
        fieldId         fieldId;

        isValid = this.crossValidateCreditDebitAmounts();

        isValid = isValid && this.isJournalDocumentEditable();

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the voucher value.
    /// </summary>
    /// <returns>
    /// true if the voucher is valid; otherwise, false.
    /// </returns>
    protected boolean validateVoucher()
    {
        boolean                     isValid = true;
        NumberSequenceTable         numberSequenceTable;
        NumberSequenceReference     numberSequenceReference;
        NumberSeq                   numberSeq;

        this.initializeLedgerJournalName();

        if (ledgerJournalName.NewVoucher == NewVoucher::BalanceSheet || ledgerJournalName.NewVoucher == NewVoucher::OneVoucher)
        {
            // Validate that a voucher number was generated.
            if (!ledgerJournalTrans.Voucher)
            {
                isValid = checkFailed("@SYS117894");
            }
        }
        else if (ledgerJournalName.NewVoucher == NewVoucher::Manually)
        {
            // Validate the user provided a voucher number.
            if (!ledgerJournalTrans.Voucher)
            {
                isValid = checkFailed(strFmt("@SYS117893", ledgerJournalName.JournalName));
            }
            else
            {
                // Validate the number sequence has been property configured.
                numberSequenceTable = NumberSequenceTable::find(ledgerJournalName.NumberSequenceTable);
                if (!numberSequenceTable)
                {
                    numberSequenceReference = NumberSeqReference::findReference(extendedTypeNum(Voucher));
                    throw error(strFmt("@SYS53911", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()));
                }

                // Validate the format.
                SysDictClass sysDictClass = new SysDictClass(className2Id(classStr(NumberSeq)));
                str methodName = "manualNumSeqCheckFormat";
                if (sysDictClass.hasStaticMethod(methodName))
                {
                    // For compatibility with previous platform version that does not contain "NumberSeq::manualNumSeqCheckFormat" method, the method is checked for existence and invoked by reflection.
                    isValid = sysDictClass.callStatic(methodName, ledgerJournalTrans.Voucher, numberSequenceTable);
                }
                else
                {
                    isValid = NumberSeq::numCheckFormat(ledgerJournalTrans.Voucher, numberSequenceTable);
                }

                if (!isValid)
                {
                    isValid = checkFailed(strFmt("@SYS117892", ledgerJournalTrans.Voucher, numberSequenceTable.Format));
                }

                if (isValid && numberSequenceTable.Continuous)
                {
                    // Validate the manual voucher number was reserved.
                    numberSeq = NumberSeq::newGetNumFromId(numberSequenceTable.RecId);

                    if (!numberSeq.reserve(ledgerJournalTrans.Voucher))
                    {
                        isValid = checkFailed(strFmt("@SYS117891", ledgerJournalTrans.Voucher, ledgerJournalName.JournalName));
                    }
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a list of <c>LedgerJournalTransType</c> derivatives.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    An instance of the <c>LedgerJournalTrans</c> table is used to construct the
    ///    <c>LedgerJournalTransType</c> derivatives.
    /// </param>
    /// <returns>
    ///    A list of <c>LedgerJournalTransType</c> derivatives.
    /// </returns>
    /// <remarks>
    ///    The <c>LedgerJournalTransType</c> derivatives are based on the account type and the offset account
    ///    type. The list may be null or contain one or two <c>LedgerJournalTransType</c> derivatives. The
    ///    list will be null when a <c>LedgerJournalTransType</c> derivative does not exist for the account
    ///    type or the offset account type. The list will contain one <c>LedgerJournalTransType</c> derivative
    ///    when the account type and the offset account type are equal and <c>LedgerJournalTransType</c>
    ///    derivative exists. The list will contain two <c>LedgerJournalTransType</c> derivatives when the
    ///    account type and the offset account type are different and derivatives exist for each. If the list
    ///    contains two elements, the first is a <c>LedgerJournalTransType</c> derivative related to account
    ///    type, and the second is a <c>LedgerJournalTransType</c> derivative related to an offset account
    ///    type.
    /// </remarks>
    public static List construct(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransType strategy;
        LedgerJournalOperation operation;
        boolean isInteractiveContext;
        List strategyCollection;

        operation = _ledgerJournalTrans.RecId == 0 ? LedgerJournalOperation::Create : LedgerJournalOperation::Update;

        isInteractiveContext = FormDataUtil::isFormDataSource(_ledgerJournalTrans) ? true : false;

        strategyCollection = new List(Types::Class);

        if (operation == LedgerJournalOperation::Create ||
            operation == LedgerJournalOperation::Update)
        {
            // Produce Account Type strategy first and Offset Account Type strategy second.
            // Defaulting logic of some fields is dependent on order of theese.

            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Ledger:
                    strategy = LedgerJournalTransType_Ledger::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                    strategyCollection.addEnd(strategy);
                    break;

                case LedgerJournalACType::Bank:
                    strategy = LedgerJournalTransType_Bank::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                    strategyCollection.addEnd(strategy);
                    break;

                case LedgerJournalACType::Vend:
                    strategy = LedgerJournalTransType_Vend::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                    strategyCollection.addEnd(strategy);
                    break;

                case LedgerJournalACType::Cust:
                    strategy = LedgerJournalTransType_Cust::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                    strategyCollection.addEnd(strategy);
                    break;

                // <GEERU>
                case LedgerJournalACType::RCash:
                    strategy = LedgerJournalTransType_RCash::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                    strategyCollection.addEnd(strategy);
                    break;
                // </GEERU>
            }

            if (_ledgerJournalTrans.AccountType != _ledgerJournalTrans.OffsetAccountType)
            {
                switch (_ledgerJournalTrans.OffsetAccountType)
                {
                    case LedgerJournalACType::Ledger:
                        strategy = LedgerJournalTransType_Ledger::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                        strategyCollection.addEnd(strategy);
                        break;

                    case LedgerJournalACType::Bank:
                        strategy = LedgerJournalTransType_Bank::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                        strategyCollection.addEnd(strategy);
                        break;

                    case LedgerJournalACType::Cust:
                        strategy = LedgerJournalTransType_Cust::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                        strategyCollection.addEnd(strategy);
                        break;

                    case LedgerJournalACType::Vend:
                        strategy = LedgerJournalTransType_Vend::construct(_ledgerJournalTrans, operation, isInteractiveContext);
                        strategyCollection.addEnd(strategy);
                        break;
                }
            }
        }

        return strategyCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default value of the field.
    /// </summary>
    /// <param name = "_fieldId">The field ID.</param>
    /// <param name = "_fieldValue">The field value.</param>
    protected void defaultFieldValue(FieldId _fieldId, anytype _fieldValue)
    {
        ledgerJournalTrans.(_fieldId) = _fieldValue;
        ledgerJournalTrans.fieldState(_fieldId, FieldState::Defaulted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultApprover</Name>
				<Source><![CDATA[
    ///<summary>
    /// Applies the default Approver name.
    /// </summary>
    protected void defaultApprover()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            this.initializeLedgerJournalTable();
  
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Approver)) && this.validateJournalType())
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Approver), HcmWorker::userId2Worker(curUserId()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultApproved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the default Approved status.
    /// </summary>
    protected void defaultApproved()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            this.initializeLedgerJournalTable();
  
            if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, Approved)) && this.validateJournalType())
            {
                this.defaultFieldValue(fieldNum(LedgerJournalTrans, Approved), NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateJournalType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the journal type.
    /// </summary>
    /// <returns>
    /// true, if journal type is valid; Otherwise, false.
    /// </returns>
    public boolean validateJournalType()
    {
        boolean validJournalType;
  
        if (ledgerJournalTable.JournalType  == LedgerJournalType::Daily                      ||
              ledgerJournalTable.JournalType  == LedgerJournalType::Payment                    ||
              ledgerJournalTable.JournalType  == LedgerJournalType::PayrollDisbursement        ||
              ledgerJournalTable.JournalType  == LedgerJournalType::CustPayment                ||
              ledgerJournalTable.JournalType  == LedgerJournalType::Netting                    ||
              ledgerJournalTable.JournalType  == LedgerJournalType::Periodic                   ||
              LedgerJournalName::isNegotiableInstrumentJournal(ledgerJournalTable.JournalType))
        {
            validJournalType = true;
        }
  
        return validJournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencyExchRate()
    { 
        if (operation == LedgerJournalOperation::Create)
        {
            this.defaultReportingCurrencyExchRateOnCreate();
        }
        else if (operation == LedgerJournalOperation::Update)
        {
            this.defaultReportingCurrencyExchRateOnUpdate();
        }
        else
        {
            this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate),
                                   this.determineDefaultReportingCurrencyExchRate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencyExchRateOnUpdate</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencyExchRateOnUpdate()
    {
        LedgerJournalTrans original = ledgerJournalTrans.orig();
            
        boolean isJournalCurrencyChanged = original.CurrencyCode != ledgerJournalTrans.CurrencyCode;
        boolean isJournalTransDateChanged = original.TransDate != ledgerJournalTrans.TransDate;
        boolean isJournalCompanyChanged = original.Company != ledgerJournalTrans.Company;
        boolean isJournalReportingExchRateChanged = original.ReportingCurrencyExchRate != ledgerJournalTrans.ReportingCurrencyExchRate;

        if ((isJournalCurrencyChanged || isJournalTransDateChanged || isJournalCompanyChanged)
            && !isJournalReportingExchRateChanged)
        {
            this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate),
                                   this.determineDefaultReportingCurrencyExchRate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencyExchRateOnCreate</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencyExchRateOnCreate()
    {
        if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate)))
        {
            this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate),
                                   this.determineDefaultReportingCurrencyExchRate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    private ReportingCurrencyExchRate determineDefaultReportingCurrencyExchRate()
    {
        ExchRate reportingExchRate;

        if (Ledger::isReportingCurrencySameAsAccountingCurrencyforLegalEntity(
            CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId))
        {
            reportingExchRate = ledgerJournalTrans.ExchRate;
        }
        else if (!reportingExchRate && !ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate)))
        {
            Ledger ledger = Ledger::findByLegalEntity(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId);
            if (ledger.ReportingCurrency)
            {
                ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(ledger.RecId, ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                exchangeRateHelper.parmToCurrency(ledger.ReportingCurrency);
                exchangeRateHelper.parmExchangeRateTypeRecId(ledger.ReportingCurrencyExchangeRateType);
                reportingExchRate = exchangeRateHelper.getExchangeRate1();
            }
        }
        else
        {
            reportingExchRate = ledgerJournalTrans.ReportingCurrencyExchRate;
        }

        return reportingExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalDocumentEditable</Name>
				<Source><![CDATA[
    private boolean isJournalDocumentEditable()
    {
        this.initializeLedgerJournalName();
        if (ledgerJournalTable && ledgerJournalTable.Approver && ledgerJournalName.ApproveActive)
        {
            if (!VendPaymTransferWithApprovalFlight::instance().isEnabled()
                || ledgerJournalName.JournalType != LedgerJournalType::Payment
                || !VendPaymTransferInProgress::registered(ledgerJournalTable.RecId))
            {
                return checkFailed("@GeneralLedger:InvalidEntityUpdateAfterApproval");
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencySecondaryExchRate</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencySecondaryExchRate()
    {
        if (operation == LedgerJournalOperation::Create)
        {
            this.defaultReportingCurrencySecondaryExchRateOnCreate();
        }
        else if (operation == LedgerJournalOperation::Update)
        {
            this.defaultReportingCurrencySecondaryExchRateOnUpdate();
        }
        else
        {
            this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRateSecondary),
                                   this.determineDefaultReportingCurrencySecondaryExchRate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencySecondaryExchRateOnCreate</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencySecondaryExchRateOnCreate()
    {
        if (!ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRateSecondary)))
        {
            this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRateSecondary),
                                   this.determineDefaultReportingCurrencySecondaryExchRate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencySecondaryExchRateOnUpdate</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencySecondaryExchRateOnUpdate()
    {
        LedgerJournalTrans original = ledgerJournalTrans.orig();

        boolean isJournalCurrencyChanged = original.CurrencyCode != ledgerJournalTrans.CurrencyCode;
        boolean isJournalTransDateChanged = original.TransDate != ledgerJournalTrans.TransDate;
        boolean isJournalCompanyChanged = original.Company != ledgerJournalTrans.Company;
        boolean isReportingExchRateSecondaryChanged = original.ReportingCurrencyExchRateSecondary != ledgerJournalTrans.ReportingCurrencyExchRateSecondary;

        if ((isJournalCurrencyChanged || isJournalTransDateChanged || isJournalCompanyChanged)
            && !isReportingExchRateSecondaryChanged)
        {
            this.defaultFieldValue(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRateSecondary),
                                   this.determineDefaultReportingCurrencySecondaryExchRate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultReportingCurrencySecondaryExchRate</Name>
				<Source><![CDATA[
    private ReportingCurrencyExchRate determineDefaultReportingCurrencySecondaryExchRate()
    {
        ExchrateSecondary reportingExchrateSecondary;

        if (Ledger::isReportingCurrencySameAsAccountingCurrencyforLegalEntity(
            CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId))
        {
            reportingExchrateSecondary = ledgerJournalTrans.ExchRateSecond;
        }
        else if (!reportingExchrateSecondary && !ledgerJournalTrans.isFieldSet(fieldNum(LedgerJournalTrans, ReportingCurrencyExchRateSecondary)))
        {
            Ledger ledger = Ledger::findByLegalEntity(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId);
            if (ledger.ReportingCurrency)
            {
                ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(ledger.RecId, ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                exchangeRateHelper.parmToCurrency(ledger.ReportingCurrency);
                exchangeRateHelper.parmExchangeRateTypeRecId(ledger.ReportingCurrencyExchangeRateType);
                reportingExchrateSecondary = exchangeRateHelper.getExchangeRate2();
            }
        }
        else
        {
            reportingExchrateSecondary = ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
        }

        return reportingExchrateSecondary;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>