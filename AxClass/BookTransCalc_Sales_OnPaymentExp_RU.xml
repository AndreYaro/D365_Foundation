<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BookTransCalc_Sales_OnPaymentExp_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
final class BookTransCalc_Sales_OnPaymentExp_RU extends BookTransCalc_Sales_RU
{
    SalesBookVATProcessParameters_RU        vatProcessParameters;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createLogTrans</Name>
				<Source><![CDATA[
    protected container createLogTrans(TransDate                  _settlementDate,
                                       RefRecId                   _transRecid,
                                       RefRecId                   _offsetRecId,
                                       CompanyId                  _transCompany,
                                       CompanyId                  _offsetCompany,
                                       RefRecId                   _settlementRecId,
                                       RefRecId                   _processLogTransRecId,
                                       SalesPurchBookTransType_RU _transType,
                                       Map                        _settledAmounts,
                                       Map                        _mapFactureAmountsDetails)
    {
        MapEnumerator                mapEnumerator;
        TaxCode                      taxCode;
        DimensionDefault             defaultDimension;
        BookStructSmallVATAmounts_RU usedAmounts,
                                     blockedAmounts,
                                     settledAmounts,
                                     factureAmounts;
        BookStructVATAmounts_RU      totalUsedAmounts, totalSettledAmounts;
        InventTransId                inventTransId;
        InvoiceId                    invoiceId;
        NumberSequenceGroupId        numberSequenceGroupId;
        PurchInternalInvoiceId       internalInvoiceId;
        container                    key;
        ;

        mapEnumerator        = _settledAmounts.getEnumerator();
        totalSettledAmounts  = new BookStructVATAmounts_RU();
        totalUsedAmounts     = new BookStructVATAmounts_RU();

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId] = mapEnumerator.currentKey();

            settledAmounts = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());

            switch (_transType)
            {
                case SalesPurchBookTransType_RU::PrepaymentStorno :
                    key = [taxCode, defaultDimension, ''];
                    break;

                default:
                    key = [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId];
                    break;
            }

            totalSettledAmounts.addSmallAmounts2(taxCode, settledAmounts);

            factureAmounts = BookStructSmallVATAmounts_RU::create(_mapFactureAmountsDetails.lookup(key));
            usedAmounts    = SalesBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                             taxCode,
                                                                             defaultDimension,
                                                                             inventTransId,
                                                                             _transRecid,
                                                                             _offsetRecId,
                                                                             _transCompany,
                                                                             _offsetCompany,
                                                                             _settlementRecId,
                                                                             _settlementDate,
                                                                             false,
                                                                             0,
                                                                             NoYes::No);

            totalUsedAmounts.addSmallAmounts2(taxCode, usedAmounts);

            blockedAmounts = SalesBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                             taxCode,
                                                                             defaultDimension,
                                                                             inventTransId,
                                                                             _transRecid,
                                                                             _offsetRecId,
                                                                             _transCompany,
                                                                             _offsetCompany,
                                                                             _settlementRecId,
                                                                             _settlementDate,
                                                                             true,
                                                                             0,
                                                                             NoYes::No);

            TmpSalesBookVATProcessLogTransOper_RU::createLines(tmpProcessLogTransOper,
                                                               factureJour.FactureId,
                                                               max(_settlementDate, factureJour.FactureDate),
                                                               operationRecId,
                                                               defaultDimension,
                                                               taxCode,
                                                               inventTransId,
                                                               _transType,
                                                               factureAmounts,
                                                               settledAmounts,
                                                               usedAmounts,
                                                               blockedAmounts,
                                                               SalesBookVATProcessLogTrans_RU::factureType2type(factureJour.ProcessingType),
                                                               _transRecid,
                                                               _offsetRecId,
                                                               _transCompany,
                                                               _offsetCompany,
                                                               _settlementRecId,
                                                               _processLogTransRecId,
                                                               closingDate,
                                                               _settlementDate);
        }

        return [totalSettledAmounts.pack(), totalUsedAmounts.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLogTransReverse</Name>
				<Source><![CDATA[
    protected container createLogTransReverse(FactureId_RU _factureId,
                                              RecId        _transRecId,
                                              RecId        _offsetRecId,
                                              CompanyId    _transCompany,
                                              CompanyId    _offsetCompany,
                                              RefRecId     _settlementRecId,
                                              TransDate    _settlementDate,
                                              RefRecId     _processLogTransRecId)
    {
        SalesBookVATProcessLogTransOper_RU  processLogTransOper;
        SalesBookVATProcessLogTrans_RU      processLogTrans;
        BookStructSmallVATAmounts_RU        bookStructSmallVATAmounts;
        BookStructVATAmounts_RU             totalUsedAmounts, totalSettledAmounts;
        Map                                 mapOperSettledAmounts = new Map(Types::Container, Types::Class);
        ;

        totalSettledAmounts  = new BookStructVATAmounts_RU();
        totalUsedAmounts     = new BookStructVATAmounts_RU();

        while select sum(AmountLiableToVAT), sum(TaxAmount) from processLogTransOper
            group by TaxCode, DefaultDimension, InventTransId
            where processLogTransOper.Blocked         == NoYes::No &&
                 processLogTransOper.CanceledRefRecId == 0
        exists join processLogTrans
            where processLogTrans.RecId                 == processLogTransOper.RefRecId &&
                  processLogTrans.FactureId             == _factureId                   &&
                  processLogTrans.InvoiceRecIdRef       == _transRecId                  &&
                  processLogTrans.PaymentRecIdRef       == _offsetRecId                 &&
                  processLogTrans.InvoiceCompany        == _transCompany                &&
                  processLogTrans.PaymentCompany        == _offsetCompany               &&
                  processLogTrans.SettlementDate        == _settlementDate              &&
                  processLogTrans.SettlementRecId       == _settlementRecId
        {
            bookStructSmallVATAmounts = new BookStructSmallVATAmounts_RU();
            bookStructSmallVATAmounts.subAmounts(processLogTransOper.amountInclVAT(), processLogTransOper.AmountLiableToVAT, processLogTransOper.TaxAmount);

            bookStructSmallVATAmounts.subAmounts2(SalesBookVATProcessLogTransOper_RU::usedAmountsForCorrectiveFactures(_factureId,
                                                                                                                       processLogTransOper.TaxCode,
                                                                                                                       processLogTransOper.DefaultDimension,
                                                                                                                       processLogTransOper.InventTransId,
                                                                                                                       _transRecId,
                                                                                                                       _offsetRecId,
                                                                                                                       _transCompany,
                                                                                                                       _offsetCompany,
                                                                                                                       _settlementRecId,
                                                                                                                       _settlementDate));
            mapOperSettledAmounts.insert([processLogTransOper.TaxCode,
                                          processLogTransOper.DefaultDimension,
                                          processLogTransOper.InventTransId],
                                          bookStructSmallVATAmounts);

            totalSettledAmounts.addSmallAmounts2(processLogTransOper.TaxCode, bookStructSmallVATAmounts);
        }

        while select processLogTransOper
            where processLogTransOper.Blocked          == NoYes::No &&
                  processLogTransOper.CanceledRefRecId == 0
        exists join processLogTrans
            where processLogTrans.RecId           == processLogTransOper.RefRecId &&
                  processLogTrans.FactureId       == _factureId                   &&
                  processLogTrans.InvoiceRecIdRef == _transRecId                  &&
                  processLogTrans.PaymentRecIdRef == _offsetRecId                 &&
                  processLogTrans.InvoiceCompany  == _transCompany                &&
                  processLogTrans.PaymentCompany  == _offsetCompany               &&
                  processLogTrans.SettlementDate  == _settlementDate              &&
                  processLogTrans.SettlementRecId == _settlementRecId
        {
            tmpProcessLogTransOper.clear();
            tmpProcessLogTransOper.initFromSBookVATProcessLogTransOper(processLogTransOper);
            tmpProcessLogTransOper.TaxAmount         = - tmpProcessLogTransOper.TaxAmount;
            tmpProcessLogTransOper.AmountLiableToVAT = - tmpProcessLogTransOper.AmountLiableToVAT;
            tmpProcessLogTransOper.SettledAmounts = mapOperSettledAmounts.lookup([processLogTransOper.TaxCode,
                                                                                  processLogTransOper.DefaultDimension,
                                                                                  processLogTransOper.InventTransId]).pack();
            tmpProcessLogTransOper.TransDate = max(_settlementDate, closingDate + 1);
            tmpProcessLogTransOper.RefRecId  = _processLogTransRecId;
            tmpProcessLogTransOper.insert();
        }

        return [totalSettledAmounts.pack(), totalUsedAmounts.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInvoice</Name>
				<Source><![CDATA[
    protected void processInvoice()
    {
        FactureCalcBalances_OnPayment_RU    factureCalcBalances = new FactureCalcBalances_OnPayment_RU(factureJour);
        BookStructVATAmounts_RU             totalFactureAmounts, totalUsedAmounts, totalSettledAmounts;
        MapEnumerator                       mapEnumerator;
        TransDate                           settlementDate,reverseDate;
        RecId                               transRecId, settlementRecId, reverseTransRecId,paymentTransRecId;
        CustTrans                           invoiceTrans, paymentTrans;
        Set                                 checkedTrans = new Set(typeName2Type(extendedTypeStr(RecId)));
        SalesPurchBookTransType_RU          transType;
        Map                                 mapFactureAmounts, mapMapFactureAmounts, mapFactureAmountsDetails;
        Map                                 countryGTDMap = new Map(typeName2Type(extendedTypeStr(RecId)), Types::String);
        CountryGTD_RU                       countryGTD;
        NoYes                               reverseTrans;
        container                           totalAmounts;
        CompanyId                           transCompany;
        CompanyId                           offsetCompany;
        ;

        setPrefix(BookDataCalc_Sales_Export_Process_RU::description());

        factureCalcBalances.calc();

        mapMapFactureAmounts = factureCalcBalances.mapMapFactureAmounts();

        mapEnumerator = this.reduceSettlementMap(factureCalcBalances.mapMapSettledAmounts()).getEnumerator();

        while (mapEnumerator.moveNext())
        {
            [settlementDate,
             settlementRecId,
             transRecId,
             paymentTransRecId,
             reverseTransRecId,
             reverseTrans,
             reverseDate,
             transCompany,
             offsetCompany] = mapEnumerator.currentKey();

            invoiceTrans = CustTrans::findByCompany(transCompany, transRecId);
            paymentTrans = CustTrans::findByCompany(offsetCompany, paymentTransRecId);

            if (this.isBadAmortisation(paymentTrans))
            {
                continue;
            }

            if (fullCheck && ! checkedTrans.in(transRecId))
            {
                if ( ! TaxReportPeriod::checkVATPeriod_RU(factureJour.FactureDate, invoiceTrans.TransDate))
                {
                    setPrefix(strFmt("@GLS102589", factureJour.FactureExternalId));

                    warning(strFmt("@GLS112979", invoiceTrans.Invoice, factureJour.FactureExternalId),
                            '',
                            new SysInfoAction_FormName_RU(factureJour, formStr(FactureJournal_RU)));
                }

                checkedTrans.add(transRecId);
            }

            mapFactureAmounts = factureCalcBalances.mapFactureAmounts();

            totalFactureAmounts  = BookStructVATAmounts_RU::create(mapFactureAmounts.lookup(transRecId));

            transType = totalFactureAmounts.amountInclVAT() > 0 ? SalesPurchBookTransType_RU::Invoice   :
                                                                  SalesPurchBookTransType_RU::CreditNote;

            if ( ! countryGTDMap.exists(transRecId))
            {
                countryGTDMap.insert(transRecId, this.appendGtd(invoiceTrans));
            }

            countryGTD = countryGTDMap.lookup(transRecId);

            mapFactureAmountsDetails = Map::create(mapMapFactureAmounts.lookup(transRecId));

            TmpSalesBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                          factureJour,
                                                          paymentTrans.TransDate,
                                                          settlementDate,
                                                          this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                          countryGTD,
                                                          transType,
                                                          transRecId,
                                                          paymentTrans.RecId,
                                                          invoiceTrans.TableId,
                                                          transCompany,
                                                          offsetCompany,
                                                          settlementRecId,
                                                          reverseTransRecId,
                                                          reverseDate);
            if (reverseTrans)
            {
                totalAmounts = this.createLogTransReverse(factureJour.FactureId,
                                                          transRecId,
                                                          paymentTransRecId,
                                                          transCompany,
                                                          offsetCompany,
                                                          reverseTransRecId,
                                                          reverseDate,
                                                          salesPurchBookDataMap.RecId);
            }
            else
            {
                // without parameter as it is in AP
                totalAmounts = this.createLogTrans(settlementDate,
                                                   transRecId,
                                                   paymentTransRecId,
                                                   transCompany,
                                                   offsetCompany,
                                                   settlementRecId,
                                                   salesPurchBookDataMap.RecId,
                                                   transType,
                                                   Map::create(mapEnumerator.currentValue()),
                                                   mapFactureAmountsDetails);
            }

            totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));

            TmpSalesBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                          totalFactureAmounts,
                                                          totalSettledAmounts,
                                                          totalUsedAmounts,
                                                          fromDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPrepaymentStorno</Name>
				<Source><![CDATA[
    protected void processPrepaymentStorno()
    {
        VendTrans                       invoiceTrans, paymentTrans;
        VendTrans_W                     vendTrans_W;
        BookStructVATAmounts_RU         totalUsedAmounts, totalSettledAmounts,totalFactureAmounts;
        Map                             mapFactureAmounts;
        CustVendCalcSettledAmounts_RU   custVendCalcSettledAmounts;
        MapEnumerator                   settledAmountsEnumerator;
        TransDate                       settlementDate, reverseDate;
        RecId                           transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                           reverseTrans;
        container                       totalAmounts;
        CompanyId                       transCompany;
        CompanyId                       paymentCompany;

        mapFactureAmounts = FactureJour_RU::factureAmounts(factureJour);

        select firstonly paymentTrans
                where paymentTrans.AccountNum            == factureJour.CustVendInvoiceAccount &&
                      paymentTrans.Voucher               == factureJour.Voucher                &&
                      paymentTrans.CurrencyCode          == factureJour.CurrencyCode           &&
                      paymentTrans.Prepayment            == NoYes::Yes
            exists join vendTrans_W
                where vendTrans_W.VendTrans              == paymentTrans.RecId                 &&
                      vendTrans_W.PrepaymentFactureId_W  == factureJour.FactureId;

        custVendCalcSettledAmounts = CustVendCalcSettledAmounts_RU::construct(paymentTrans, NoYes::No);
        // in fact it may be no tax transactions for vendor prepayment and tax information exists only in facture lines
        // due to this fact it is needed to calculate trans amounts map based on facture amounts in facture,
        // not on tax trans amounts as usual
        custVendCalcSettledAmounts.parmMapTransAmountsMST(mapFactureAmounts);
        custVendCalcSettledAmounts.calcSettledAmounts();

        settledAmountsEnumerator = this.reduceSettlementMap_VendPrep(custVendCalcSettledAmounts.mapMapSettledAmountsMST(), paymentTrans, mapFactureAmounts).getEnumerator();

        while (settledAmountsEnumerator.moveNext())
        {
            [settlementDate,
             settlementRecId,
             paymentTransRecId,
             transRecId,
             reverseTransRecId,
             reverseTrans,
             reverseDate,
             transCompany,
             paymentCompany] = settledAmountsEnumerator.currentKey();

            invoiceTrans = VendTrans::find(transRecId);

            if (this.isBadAmortisation(invoiceTrans))
            {
                continue;
            }

            TmpSalesBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                          factureJour,
                                                          paymentTrans.TransDate,
                                                          settlementDate,
                                                          this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                          '',
                                                          SalesPurchBookTransType_RU::PrepaymentStorno,
                                                          invoiceTrans.RecId,
                                                          paymentTrans.RecId,
                                                          invoiceTrans.TableId,
                                                          transCompany,
                                                          paymentCompany,
                                                          settlementRecId,
                                                          reverseTransRecId,
                                                          reverseDate);

            if (reverseTrans)
            {
                totalAmounts = this.createLogTransReverse(factureJour.FactureId,
                                                          transRecId,
                                                          paymentTransRecId,
                                                          transCompany,
                                                          paymentCompany,
                                                          reverseTransRecId,
                                                          reverseDate,
                                                          salesPurchBookDataMap.RecId);
            }
            else
            {
                totalAmounts = this.createLogTrans(settlementDate,
                                                   transRecId,
                                                   paymentTransRecId,
                                                   transCompany,
                                                   paymentCompany,
                                                   settlementRecId,
                                                   salesPurchBookDataMap.RecId,
                                                   SalesPurchBookTransType_RU::PrepaymentStorno,
                                                   settledAmountsEnumerator.currentValue(),
                                                   mapFactureAmounts);
            }

            totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));
            totalFactureAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            if (reverseTrans)
            {
                totalFactureAmounts.reverseAmounts();
            }

            TmpSalesBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                          totalFactureAmounts,
                                                          totalSettledAmounts,
                                                          totalUsedAmounts,
                                                          fromDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceSettlementMap</Name>
				<Source><![CDATA[
    protected Map reduceSettlementMap(Map _settlementMap, TransDate _fromDate = fromDate, boolean _vendPrepayment = false)
    {
        Map                            reducedMap = new Map(Types::Container, _settlementMap.valueType());
        TransDate                      settlementDate, reverseDate;
        RecId                          settlementRecId, transRecId, reverseTransRecId, paymentTransRecId;
        MapEnumerator                  settlementEnumerator = _settlementMap.getEnumerator();
        NoYes                          reverseTrans;
        SalesBookVATProcessLogTrans_RU processLogTrans;
        RecordSortedList               processLogTransList;
        CompanyId                      transCompany;
        CompanyId                      paymentCompany;
        ;

        while (settlementEnumerator.moveNext())
        {
            [settlementDate,
             settlementRecId,
             transRecId,
             paymentTransRecId,
             reverseTransRecId,
             reverseTrans,
             reverseDate,
             transCompany,
             paymentCompany] = settlementEnumerator.currentKey();

            if (max(max(settlementDate, factureJour.FactureDate), factureJour.StatusChangeDate) > toDate)
            {
                continue;
            }

            if (reverseTrans)
            {
                if (SalesBookVATProcessLogTransOper_RU::checkLogTransOper(factureJour.FactureId,
                                                                          transRecId,
                                                                          paymentTransRecId,
                                                                          transCompany,
                                                                          paymentCompany,
                                                                          reverseDate,
                                                                          reverseTransRecId))
                {
                    reducedMap.insert([settlementDate,
                                        settlementRecId,
                                        transRecId,
                                        paymentTransRecId,
                                        reverseTransRecId,
                                        reverseTrans,
                                        reverseDate,
                                        transCompany,
                                        paymentCompany], settlementEnumerator.currentValue());
                }
                if (reducedMap.exists([reverseDate,
                                       reverseTransRecId,
                                       transRecId,
                                       paymentTransRecId,
                                       settlementRecId,
                                       ! reverseTrans,
                                       reverseDate,
                                       transCompany,
                                       paymentCompany]))
                {
                    reducedMap.remove([reverseDate,
                                       reverseTransRecId,
                                       transRecId,
                                       paymentTransRecId,
                                       settlementRecId,
                                       ! reverseTrans,
                                       reverseDate,
                                       transCompany,
                                       paymentCompany]);
                }
            }
            else
            {
                if (! _vendPrepayment && max(max(settlementDate, factureJour.FactureDate), factureJour.StatusChangeDate) < _fromDate)
                {
                    if (! SalesBookVATProcessLogTransOper_RU::existsBlockedTrans(factureJour.FactureId,
                                                                                 transRecId,
                                                                                 paymentTransRecId,
                                                                                 transCompany,
                                                                                 paymentCompany,
                                                                                 settlementDate))
                    {
                        continue;
                    }
                }

                processLogTransList = SalesBookVATProcessLogTrans_RU::findFromSettlement(factureJour.FactureId,
                                                                                         transRecId,
                                                                                         paymentTransRecId,
                                                                                         transCompany,
                                                                                         paymentCompany,
                                                                                         settlementRecId,
                                                                                         settlementDate,
                                                                                         SalesBookVATProcessLogTrans_RU::factureType2type(factureJour.ProcessingType));
                processLogTrans.clear();
                processLogTransList.first(processLogTrans);
                if (processLogTrans.Reversed == NoYes::No)
                {
                    reducedMap.insert([settlementDate,
                                       settlementRecId,
                                       transRecId,
                                       paymentTransRecId,
                                       reverseTransRecId,
                                       reverseTrans,
                                       reverseDate,
                                       transCompany,
                                       paymentCompany], settlementEnumerator.currentValue());
                }
            }
        }

        return reducedMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceSettlementMap_VendPrep</Name>
				<Source><![CDATA[
    protected Map reduceSettlementMap_VendPrep(Map _settlementMap, VendTrans _paymentTrans = null, Map _mapFactureAmounts = null)
    {
        Map                             mapMapPrepaymentStornoAmounts, mapSettledAmounts;
        MapEnumerator                   mapMapEnumerator = this.reduceSettlementMap(_settlementMap, fromDate, true).getEnumerator();
        MapEnumerator                   mapEnumerator;
        TransDate                       settlementDate, reverseDate;
        RecId                           transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                           reverseTrans;
        TaxCode                         taxCode;
        DimensionDefault                defaultDimension;
        InventTransId                   inventTransId;
        PurchInternalInvoiceId          internalInvoiceId;
        InvoiceId                       invoiceId;
        NumberSequenceGroupId           numberSequenceGroupId;
        VendTrans                       vendTrans;
        CompanyId                       transCompany;
        CompanyId                       paymentCompany;
        BookStructSmallVATAmounts_RU    settledAmountsDetails;
        BookStructSmallVATAmounts_RU    usedAmountsDetails;
        BookStructSmallVATAmounts_RU    blockedAmountsDetails;
        BookStructSmallVATAmounts_RU    usedInPurchAmounts;
        BookStructSmallVATAmounts_RU    usedInSalesAmounts;
        BookStructSmallVATAmounts_RU    usedInTmpAmounts;
        BookStructSmallVATAmounts_RU    finalAmountsDetails;
        Map                             mapSettledAmountsDetails;

        mapMapPrepaymentStornoAmounts = new Map(Types::Container, Types::Class);

        while (mapMapEnumerator.moveNext())
        {
            [settlementDate,
             settlementRecId,
             paymentTransRecId,
             transRecId,
             reverseTransRecId,
             reverseTrans,
             reverseDate,
             transCompany,
             paymentCompany] = mapMapEnumerator.currentKey();

            if (settlementDate > toDate)
            {
                continue;
            }

            mapSettledAmounts = mapMapEnumerator.currentValue();
            mapEnumerator = mapSettledAmounts.getEnumerator();

            vendTrans = VendTrans::find(transRecId);
            mapSettledAmountsDetails = new Map(Types::Container, Types::Container);

            if (mapEnumerator.moveNext())
            {
                [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId] = mapEnumerator.currentKey();

                // settled amount include VAT
                settledAmountsDetails = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());

                // already posted amount include VAT
                usedAmountsDetails = SalesBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                                     taxCode,
                                                                                     defaultDimension,
                                                                                     inventTransId,
                                                                                     transRecId,
                                                                                     paymentTransRecId,
                                                                                     transCompany,
                                                                                     paymentCompany,
                                                                                     settlementRecId,
                                                                                     settlementDate,
                                                                                     false);

                settledAmountsDetails.subAmounts2(usedAmountsDetails);

                // blocked amount include VAT
                blockedAmountsDetails = SalesBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                                        taxCode,
                                                                                        defaultDimension,
                                                                                        inventTransId,
                                                                                        transRecId,
                                                                                        paymentTransRecId,
                                                                                        transCompany,
                                                                                        paymentCompany,
                                                                                        settlementRecId,
                                                                                        settlementDate,
                                                                                        true);

                settledAmountsDetails.subAmounts2(blockedAmountsDetails);

                // invoice amount already processed in incoming VAT processing
                usedInPurchAmounts = PurchBookVATProcessLogTransOper_RU::usedAmounts_InvoiceRecId(transRecId, transCompany, toDate, false);

                // invoice amount already processed in outgoing VAT processing
                usedInSalesAmounts = SalesBookVATProcessLogTransOper_RU::usedAmounts_InvoiceRecId(transRecId, transCompany, false, SalesBookVATRestoringType_RU::None, toDate);

                // invoice amount already allocated on another prepayments and shown in the form
                usedInTmpAmounts = tmpProcessLogTransOper.usedAmounts_InvoiceRecId(salesPurchBookDataMap, transRecId, transCompany, false, SalesBookVATRestoringType_RU::None);

                usedInPurchAmounts.subAmounts2(usedInSalesAmounts);
                usedInPurchAmounts.subAmounts2(usedInTmpAmounts);

                if (vendTrans.Invoice)
                {
                    finalAmountsDetails = settledAmountsDetails.amountInclVAT() > usedInPurchAmounts.amountInclVAT() ? usedInPurchAmounts : settledAmountsDetails;
                }
                else
                {
                    finalAmountsDetails = settledAmountsDetails;
                }

                if (finalAmountsDetails.amountInclVAT())
                {
                    finalAmountsDetails.addAmounts2(usedAmountsDetails);
                    finalAmountsDetails.addAmounts2(blockedAmountsDetails);

                    mapSettledAmountsDetails.insert(mapEnumerator.currentKey(), finalAmountsDetails.pack());
                    mapMapPrepaymentStornoAmounts.insert(mapMapEnumerator.currentKey(), mapSettledAmountsDetails);
                }
            }
        }

        return mapMapPrepaymentStornoAmounts;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>