<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRCustPaymTotals_Sales</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     The class <c>MCRCustPaymTotals_Sales</c> is responsible for managing a list of payments associated with a sales order.
/// </summary>
class McrCustPaymTotals_Sales extends MCRCustPaymTotals
{
    SalesTable salesTable;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if payments may be edited by the user.
    /// </summary>
    /// <returns>
    /// true when the payments may be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Overridden to only allow editing when the sales order status is
    ///     "open order".
    /// </remarks>
    public  boolean allowEdit()
    {
        salesTable = this.findSalesTable();
        return salesTable.SalesStatus == SalesStatus::Backorder
                && salesTable.mcrOrderStopped;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allPaymentsApproved</Name>
				<Source><![CDATA[
    public boolean allPaymentsApproved(boolean _ignore = false)
    {
        boolean                         ret = true;
        MCRCustPaymTable                mcrCustPaymTable;
        CustPaymSchedLine               custPaymSchedLine;
        MCRSalesTable                   mcrSalesTable = salesTable.mcrSalesTable();
        MCRInstallmentPlanSalesTable    installmentPlanSalesTable;

        installmentPlanSalesTable = MCRInstallmentPlanSalesTable::findSalesId(salesTable.SalesId);

        if (installmentPlanSalesTable.PaymSchedId
            && MCROrderParameters::find().InstallmentAuth == MCRInstallmentAuth::OrderDate)
        {
            custPaymSchedLine = CustPaymSchedLine::mcrFindFirstIntallmentSchedLine(salesTable.SalesId, installmentPlanSalesTable.PaymSchedId);

            select firstonly RecId, Status from mcrCustPaymTable
                where mcrCustPaymTable.RefTableId == custPaymSchedLine.TableId
                    && mcrCustPaymTable.RefRecId == custPaymSchedLine.RecId;
            // If a payment exists, check the status, if no payment exists
            //  the installment amount will post to the customers account.
            if (mcrCustPaymTable
                && (mcrCustPaymTable.Status == MCRCustPaymStatus::Declined
                    ||  mcrCustPaymTable.Status == MCRCustPaymStatus::NotSubmitted))
            {
                ret = false;
            }
        }

        if (ret)
        {
            ret = super(_ignore);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allPaymentsSubmitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if all payments have been submitted and the order
    ///     is not in the out of balance workbench.
    /// </summary>
    /// <returns>
    /// true if all payments have been submitted or it's in
    ///     the out of balance workbench; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Overrode to check out of balance flags on the sales order,
    ///     this validation must be here as it only applies to sales orders.
    /// </remarks>
    public boolean allPaymentsSubmitted()
    {
        // If the order is fully paid
        //  then all the payments have been submitted.
        if (this.skipOrderPaymentStatusesCheck())
        {
            // Skip super if the order is in the out of balance workbench, no need
            //  to check statuses of the orders payments
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipOrderPaymentStatusesCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to skip the check for order payment statuses.
    /// </summary>
    /// <returns>true if the order payment statuses should be skipped; otherwise, false.</returns>
    protected boolean skipOrderPaymentStatusesCheck()
    {
        return salesTable.mcrSalesTable().isOrderOutOfBalanceVerified();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicePaymAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the posted payment amount that can be applied toward the
    ///     specified invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The customer invoice journal record associated with the payments.
    /// </param>
    /// <returns>
    /// The posted payment amount that can be applied toward the
    ///     specified invoice.
    /// </returns>
    /// <remarks>
    /// The calculation is based upon the total posted payment amount that has
    ///     not been applied toward other invoices.
    ///     Note that in rare cases, such as cancelling a partially invoiced order,
    ///     the sum of payments applied toward all invoices might not equal the
    ///     final total posted payment amount.
    /// </remarks>
    public  AmountCur calcInvoicePaymAmount(CustInvoiceJour _custInvoiceJour)
    {
        CustInvoiceJour custInvoiceJour_Temp;

        Amount              postedPaymAmount;     // amount posted
        Amount              appliedPaymAmount;    // amount already applied to invoices
        Amount              unappliedPaymAmount;  // amount posted but not applied to invoices
        Amount              invoiceAmount;
        MCRInstallmentPlanSalesTable mcrInstallmentPlanSalesTable;

        salesTable = this.findSalesTable();

        if (_custInvoiceJour.SalesId != salesTable.SalesId)
        {
            throw error(strFmt("@MCR10769", funcName()) + strFmt("@Retail:SalesIDNotMatch", _custInvoiceJour.SalesId, salesTable.SalesId));
        }

        mcrInstallmentPlanSalesTable = MCRInstallmentPlanSalesTable::findSalesId(salesTable.SalesId);
        if (mcrInstallmentPlanSalesTable)
        {
            // Returns the correct amounts paid for installment billing
            postedPaymAmount += mcrInstallmentPlanSalesTable.getTotalPostedAmount();
        }
        else
        {
            // calculate the sum of posted payment transactions, ignoring "On account"
            postedPaymAmount = this.getTotalPostedPaymAmount(false);
        }

        // calculate sum of applied amounts for all other invoices for this sales
        //  order
        select sum(mcrPaymAmount) from custInvoiceJour_Temp
            where custInvoiceJour_Temp.SalesId == salesTable.SalesId
                  && custInvoiceJour_Temp.RecId != _custInvoiceJour.RecId;

        appliedPaymAmount = custInvoiceJour_Temp.mcrPaymAmount;

        unappliedPaymAmount = postedPaymAmount - appliedPaymAmount;

        invoiceAmount = _custInvoiceJour.InvoiceAmount + _custInvoiceJour.mcrGiftCardAmount_RU();

        // do not apply payments with opposite sign
        if (sign(invoiceAmount) != sign(unappliedPaymAmount))
        {
            return 0.0;
        }
        // apply lesser of (lesser magnitude) invoice amount or unapplied payment
        //  amount
        else if (abs(invoiceAmount) > abs(unappliedPaymAmount))
        {
            return unappliedPaymAmount;
        }
        else
        {
            return invoiceAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfOriginalOrderIsSettled</Name>
				<Source><![CDATA[
    private boolean checkIfOriginalOrderIsSettled(Num _orderId, CustTable _custTable)
    {
        CustTransOpen   custTransOpen;
        CustInvoiceJour custInvoiceJour;
        CustTrans       custTrans;

        select firstonly AmountCur from custTransOpen
            exists join custTrans
            where custTransOpen.RefRecId == custTrans.RecId
            exists join custInvoiceJour
            where custInvoiceJour.SalesId == _orderId
                && custInvoiceJour.InvoiceAccount == _custTable.AccountNum
                && custInvoiceJour.InvoiceId == custTrans.Invoice
                && custInvoiceJour.InvoiceDate == custTrans.TransDate
                && custInvoiceJour.LedgerVoucher == custTrans.Voucher;

        if (custTransOpen.AmountCur > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDropShipPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates drop shipments for the sales table record.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record to create drop shipments form.
    /// </param>
    /// <remarks>
    ///  Should only be called for orders with status to be picked.
    /// </remarks>
    private void createDropShipPurchaseOrder(SalesTable _salesTable)
    {
        PurchCreateFromSalesOrder purchCreate = PurchCreateFromSalesOrder::construct();

        if (PurchParameters::find().mcrAutoDropShip)
        {
            purchCreate.parmTransferAddress(true);
            purchCreate.tradeLineDlvType(TradeLineDlvType::DropShip);
            purchCreate.mcrDropShipment(NoYes::Yes);
            purchCreate.parmSalesTable(_salesTable);
            purchCreate.parmCallerRecord(_salesTable);
            purchCreate.parmPOTransDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

            // Only run create if there are drop ship lines.  This prevents
            // progress bar from appearing for orders that do not have any drop
            // ship lines.
            if (purchCreate.mcrDropShipCreateTmpFrmVirtual())
            {
                purchCreate.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the sales order associated with this list of payments.
    /// </summary>
    /// <param name="_forUpdate">
    /// A <c>Boolean</c> value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The sales order associated with this list of payments.
    /// </returns>
    private SalesTable findSalesTable(boolean _forUpdate = false)
    {
        return SalesTable::findRecId(refRecID, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the currency for all payments.
    /// </summary>
    /// <returns>
    /// The currency for all payments.
    /// </returns>
    public CurrencyCode getCurrency()
    {
        return SalesTable::findRecId(refRecID).CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the financial dimensions for all payments.
    /// </summary>
    /// <returns>
    /// The financial dimensions for all payments.
    /// </returns>
    public DimensionDefault getDimension()
    {
        return SalesTable::findRecId(refRecID).DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the invoice account for all payments.
    /// </summary>
    /// <returns>
    /// The invoice account for all payments.
    /// </returns>
    public CustAccount getInvoiceAccount()
    {
        return SalesTable::findRecId(refRecID).InvoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderID</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the order ID for all payments.
    /// </summary>
    /// <returns>
    /// The order ID for all payments.
    /// </returns>
    /// <remarks>
    /// The "order ID" is the sales ID for the sales order.
    /// </remarks>
    public Num getOrderID()
    {
        return SalesTable::findRecId(refRecID).SalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posting profile.
    /// </summary>
    /// <param name="_recalc">
    /// A boolean value that indicates to recalculate.
    /// </param>
    /// <returns>
    /// The posting profile.
    /// </returns>
    public PostingProfile getPostingProfile(boolean _recalc = false)
    {
        if (_recalc)
        {
            return SalesTable::mcrCalculatePostingProfile(salesTable, _recalc);
        }
        else
        {
            if (salesTable && salesTable.PostingProfile)
            {
                return salesTable.PostingProfile;
            }
            else
            {
                return CustParameters::find().PostingProfile;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalDiscount</Name>
				<Source><![CDATA[
    protected AmountCur getTotalDiscount()
    {
        // use order totals, or initialize
        if (!mcrSalesOrderTotals)
        {
            mcrSalesOrderTotals = new MCRSalesOrderTotals(salesTable);
        }

        return mcrSalesOrderTotals.getRemainingDisc();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInvoicedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates and returns the total invoiced amount, in the payment currency.
    /// </summary>
    /// <returns>
    /// The total invoiced amount, in the payment currency.
    /// </returns>
    /// <remarks>
    /// The total invoiced amount is the sum of all amounts invoiced so far.
    /// </remarks>
    public AmountCur getTotalInvoicedAmount()
    {
        // Get the order totals if they are not already calculated.
        if (!mcrSalesOrderTotals)
        {
            mcrSalesOrderTotals = new MCRSalesOrderTotals(SalesTable::findRecId(refRecID));
        }

        return mcrSalesOrderTotals.getInvoicedOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalPaymAmount</Name>
				<Source><![CDATA[
    public AmountCur getTotalPaymAmount(boolean includeInstallment = true)
    {
        AmountCur ret;
        MCRInstallmentPlanSalesTable mcrInstallmentPlanSalesTable;
        AmountCur       instAmount = 0;

        ret = super(includeInstallment);

        if (includeInstallment)
        {
            // The reftableid and refrecid downstream in this method for installment billing should
            // come from sales table and not the custpaymshcedline
            mcrInstallmentPlanSalesTable = MCRInstallmentPlanSalesTable::findRecId(mcrInstallmentPlanSalesTable_RecID);
            if (mcrInstallmentPlanSalesTable)
            {
                instAmount = mcrInstallmentPlanSalesTable.sumTotalAmount(salesTable);
            }
        }

        // Need to add in the amount paid on installment, if no installment exists
        // then nothing changes.
        return ret + instAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalPaymAmount_RefCheckUnposted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total payment amount for all payments of type refund check
    ///     that have not been posted.
    /// </summary>
    /// <returns>
    /// The total payment amount for all payments of type refund check
    ///     that have not been posted.
    /// </returns>
    /// <remarks>
    /// This method was created to be used in deciding
    ///     if the invoiced sales order should be settled.  In the case of refund checks
    ///     we don't want to attempt to settle the sales order until the refund check
    ///     that corresponds to is posted.  If we do there maybe instances where settlements
    ///     does something undesirable like generate an offsetting journal for the penny
    ///     difference or over/under payment.
    /// </remarks>
    private AmountCur getTotalPaymAmount_RefCheckUnposted()
    {
        MCRCustPaymTable    custPaymTable;
        LedgerJournalTable  ledgerJournalTableLocal;
        LedgerJournalTrans  ledgerJournalTrans;

        select sum(Amount) from custPaymTable
            join  mcrPaymOrderID, JournalNum
            from  ledgerJournalTrans
            join  JournalNum, Posted
            from  ledgerJournalTableLocal
            where custPaymTable.RefTableId                   == refTableID
                &&    custPaymTable.RefRecId                 == refRecID
                &&    ledgerJournalTrans.mcrRefPaymID        == custPaymTable.RecId
                &&    ledgerJournalTableLocal.JournalNum     == ledgerJournalTrans.JournalNum
                &&    custPaymTable.CustPaymType             == MCRCustPaymType::RefundCheck
                &&    ledgerJournalTableLocal.Posted         == NoYes::No;

        return custPaymTable.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalSalesAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates and returns the total sales amount, in the payment currency.
    ///
    /// </summary>
    /// <returns>
    /// The total sales amount, in the payment currency.
    /// </returns>
    /// <remarks>
    /// The total sales amount is the total amount that will have been invoiced
    ///     after invoicing has completed.  Thus, the returned value is the sum
    ///     of non-invoiced amounts and amounts that have already been invoiced.
    ///     The payment currency is the currency used for payment, which might differ
    ///     from the company default currency.
    /// </remarks>
    public AmountCur getTotalSalesAmount()
    {
        MCRSalesTable mcrSalesTable;
        salesTable = SalesTable::findRecId(refRecID);
        mcrSalesTable = salesTable.mcrSalesTable();

        // use order totals, or initialize
        if (!mcrSalesOrderTotals)
        {
            mcrSalesOrderTotals = new MCRSalesOrderTotals(salesTable);
        }

        // Return a different value if the sales order is continuity. There are several
        // combinations based on whether the sales order is a continuity parent or a continuity child.
        // Each situation is evaluated before returning the appropriate sales amount.
        if (mcrSalesTable.ContinuityOrder
            || mcrSalesTable.ContinuityChild)
        {
            if (mcrSalesTable.ContinuityOrder
                && ! mcrSalesTable.ContinuityChild)
            {
                if (mcrSalesTable.ContinuityLineEval    == MCRContinuityLineEval::PayAllNow
                    || mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::Blank)
                {
                    return mcrSalesOrderTotals.getTotalOrder();
                }
                if (mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::PayPartNowPartSched)
                {
                    return this.getTotalSalesAmtContinuity();
                }
                if (mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::PayAllLater)
                {
                    return mcrSalesOrderTotals.retZeroBillUpFrontWithSched();
                }
            }
            if (mcrSalesTable.ContinuityChild
                && (mcrSalesTable.ContinuityLineEval    == MCRContinuityLineEval::PayAllLater
                    || mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::Paid))
            {
                return mcrSalesOrderTotals.retZeroBillUpFrontWithSched();
            }
            else
            {
                if (mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::PayAllNow
                    || mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::Blank)
                {
                    return mcrSalesOrderTotals.getTotalOrder();
                }
                else
                {
                    return mcrSalesOrderTotals.getTotalContinuityOrder();
                }
            }
        }
        else
        {
            return mcrSalesOrderTotals.getTotalOrder();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalSalesAmtContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total sales amount for the continuity order.
    /// </summary>
    /// <returns>
    /// The total sales amount for the continuity order.
    /// </returns>
    /// <remarks>
    ///     If the order has continuity items on it, and if the payment is a
    ///     pay part now and pay part on a schedule, then the sales total, that
    ///     needs to be returned should be the sales total minues the pay later amount of continuity.
    /// </remarks>
    private AmountCur getTotalSalesAmtContinuity()
    {
        AmountCur continuityPayLater;
        AmountCur continuityPayLaterTax;
        AmountCur totalOrder;

        // Get the order totals if they are not already calculated.
        if (!mcrSalesOrderTotals)
        {
            mcrSalesOrderTotals = new MCRSalesOrderTotals(SalesTable::findRecId(refRecID));
        }

        totalOrder          = mcrSalesOrderTotals.getTotalOrder();
        continuityPayLater  = mcrSalesOrderTotals.getContinuityPayLater();
        if (continuityPayLater != 0)
        {
            continuityPayLaterTax = mcrSalesOrderTotals.getContinuityPayLaterTax();
            return totalOrder - (continuityPayLater + continuityPayLaterTax);
        }
        else
        {
            return totalOrder;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnpostedRefundCheckPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether there is an un-posted refund check payment on the sales order.
    /// </summary>
    /// <returns>
    /// true if there is an un-posted refund check on the sales order; otherwise, false.
    /// </returns>
    private boolean hasUnpostedRefundCheckPaym()
    {
        MCRCustPaymTable mcrCustPaymTable;

        salesTable = this.findSalesTable(true);
        select firstonly RecId from mcrCustPaymTable
            where mcrCustPaymTable.RefRecId == salesTable.RecId
                &&    mcrCustPaymTable.RefTableId == salesTable.TableId
                &&    mcrCustPaymTable.CustPaymType == MCRCustPaymType::RefundCheck;

        if (mcrCustPaymTable)
        {
            //  If the refund has already been posted to the ledger tables then
            //      this value
            if (this.getTotalPaymAmount_RefCheckUnposted() == 0)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Instantiates the <c>MCRCustPaymTotals</c> object using the passed in reference record ID.
    /// </summary>
    /// <param name="_refRecID">
    /// The reference record ID of the record the payment is associated with.
    /// </param>
    /// <param name="_mcrSalesOrderTotals">
    /// The sales order totals object on the sales order.
    /// </param>
    public void new(RecId _refRecID, MCRSalesOrderTotals _mcrSalesOrderTotals = null)
    {
        salesTable = SalesTable::findRecId(_refRecID);
        mcrInstallmentPlanSalesTable_RecID = MCRInstallmentPlanSalesTable::findSalesId(salesTable.SalesId).RecId;

        super(tableNum(SalesTable), _refRecID, _mcrSalesOrderTotals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentsMultipleOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts multiple payments for the sales order.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The customer invoice journal used in posting the payments.
    /// </param>
    /// <remarks>
    /// If invoicing is occuring in a summarized mode, the payments need to be posted for
    ///     payments that are not a prepay. In order to obtain the amount that needs to be
    ///     posted we have to loop through the <c>CustInvoiceTrans</c> records and gather up the
    ///     amounts to post.
    /// </remarks>
    public void postPaymentsMultipleOrders(CustInvoiceJour _custInvoiceJour)
    {
        CustInvoiceSalesLink                custInvoiceSalesLink;
        MCRSalesMultipleInvoiceTotals       mcrsmit;
        MCRCustPaymTotals                   custPaymTotals;
        AmountCur                           totalPostAmount;
        AmountCur                           invoiceAmount;
        int                                 numInvoices;
        real                                difference;
        MCRCustPaymTable                    custPaymTable;
        CustInvoiceJour custInvoiceJour = _custInvoiceJour;
        mcrsmit = MCRSalesMultipleInvoiceTotals::construct( custInvoiceJour);

        numInvoices = 0;

        // Post payment and settle for every order that is part of summary invoice
        while select InvoiceId, SalesId, OrigSalesId
            from  custInvoiceSalesLink
            where custInvoiceSalesLink.InvoiceId ==  custInvoiceJour.InvoiceId
               && custInvoiceSalesLink.SalesId   ==  custInvoiceJour.SalesId
            join RecId from salesTable
                where custInvoiceSalesLink.OrigSalesId == salesTable.SalesId
        {
            custPaymTotals  = MCRCustPaymTotals::construct(salesTable.TableId,
                                                           salesTable.RecId);
            // processes payments through the custPaymTable
            custPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(salesTable.RecId, salesTable.TableId);
            custPaymTotals.processPayments(MCRProcessPaymAction::PostAll, false, true, custPaymTable.RecId);
            totalPostAmount += custPaymTotals.getTotalPostedPaymAmount(false);
            custPaymTotals.settlePayments();
            numInvoices++;
        }

         custInvoiceJour.mcrPaymAmount = totalPostAmount;

        invoiceAmount = custInvoiceJour.InvoiceAmount + _custInvoiceJour.mcrGiftCardAmount_RU();
        difference = abs(totalPostAmount) - abs(invoiceAmount);
        difference = abs(difference);

        // May be rounding issues due to total discount.  Amount due is 0 if difference
        // is less than max over/under payment allowed or if less than 0.01 per invoice
        if (difference    <= this.getMaxOverUnderPaymAmount()
            || difference <= numInvoices * 0.01)
        {
             custInvoiceJour.mcrDueAmount = 0;
        }
        else
        {
             custInvoiceJour.mcrDueAmount = invoiceAmount - totalPostAmount;
        }

        if (custInvoiceJour.validateWrite())
        {
            custInvoiceJour.update();
        }
        else
        {
            throw error("@SYS104318");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOnAccountReturns</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process on account return payments.
    /// </summary>
    /// <param name="_orderID">
    /// The order ID of theorder.
    /// </param>
    /// <param name="_originalOrderId">
    /// The original sales ID of the order.
    /// </param>
    /// <param name="_custTable">
    /// The customer record associated with the order.
    /// </param>
    /// <param name="_custTrans">
    /// The customer transaction record associated with the order.
    /// </param>
    /// <param name="_custTransOpen">
    /// The customer transaction open record associated with the order.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// The customer transaction journal record associated with the order.
    /// </param>
    /// <param name="specTransManager">
    /// The <c>SpecTransManager</c> object associated with the order.
    /// </param>
    /// <remarks>
    /// When a return on account exists , this needs to be settled against
    ///     the original order. Mark the records that will be used for settling.
    /// </remarks>
    private void processOnAccountReturns(Num _orderID,
                                Num _originalOrderId,
                                CustTable _custTable,
                                CustTrans _custTrans,
                                CustTransOpen _custTransOpen,
                                CustInvoiceJour _custInvoiceJour,
                                SpecTransManager specTransManager)
    {
        AmountCur sumTransAmountCur;
        specTransManager.deleteAll();

        while select RecId, TableId, AmountCur from _custTransOpen
                    join CurrencyCode from _custTrans
                    join LedgerVoucher from _custInvoiceJour
                    where (_custInvoiceJour.SalesId == _orderID
                          || _custInvoiceJour.InvoiceId == _orderID
                          || _custInvoiceJour.SalesId == _originalOrderId)
                          && _custInvoiceJour.InvoiceAccount == _custTable.AccountNum
                          && _custTrans.Voucher == _custInvoiceJour.LedgerVoucher
                          && _custTrans.AccountNum == _custTable.AccountNum
                          && _custTransOpen.RefRecId == _custTrans.RecId
        {
            sumTransAmountCur += _custTransOpen.AmountCur;

            specTransManager.insert(_custTransOpen.DataAreaId,
                                    _custTransOpen.TableId,
                                    _custTransOpen.RecId,
                                    _custTransOpen.AmountCur,
                                    _custTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOnAcctReturnWithExchange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process on account payments on return order with exchange orders.
    /// </summary>
    /// <param name="_returnOrderID">
    /// The order ID of the return order.
    /// </param>
    /// <param name="_exchangeOrderId">
    /// The order ID of the exchange order.
    /// </param>
    /// <param name="_custTable">
    /// The customer record associated with the order.
    /// </param>
    /// <param name="_custTrans">
    /// The customer transaction record associated with the order.
    /// </param>
    /// <param name="_custTransOpen">
    /// The customer transaction open record associated with the order.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// The customer transaction journal record associated with the order.
    /// </param>
    /// <param name="specTransManager">
    /// The <c>SpecTransManager</c> object associated with the order.
    /// </param>
    /// <remarks>
    /// If the order is an exchange, settle with the return order if both
    ///     the return and the exchange have been invoiced.
    /// </remarks>
    private void processOnAcctReturnWithExchange(Num _returnOrderID, Num _exchangeOrderId, CustTable _custTable,
                                CustTrans _custTrans,
                                CustTransOpen _custTransOpen,
                                CustInvoiceJour _custInvoiceJour,
                                SpecTransManager specTransManager)

    {
        AmountCur sumTransAmountCur;
        specTransManager.deleteAll();

        while select RecId, TableId, AmountCur from _custTransOpen
                    join CurrencyCode from _custTrans
                    join LedgerVoucher from _custInvoiceJour
                    where (_custInvoiceJour.SalesId == _returnOrderID
                          || _custInvoiceJour.InvoiceId == _returnOrderID
                          || _custInvoiceJour.SalesId == _exchangeOrderId)
                          && _custInvoiceJour.InvoiceAccount == _custTable.AccountNum
                          && _custTrans.Voucher == _custInvoiceJour.LedgerVoucher
                          && _custTransOpen.RefRecId == _custTrans.RecId
        {
            sumTransAmountCur += _custTransOpen.AmountCur;

            specTransManager.insert(_custTransOpen.DataAreaId,
                             _custTransOpen.TableId,
                             _custTransOpen.RecId,
                             _custTransOpen.AmountCur,
                             _custTrans.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculatePaymAmounts</Name>
				<Source><![CDATA[
    public boolean recalculatePaymAmounts()
    {
        MCRInstallmentPlanSalesTable    mcrInstallmentPlanSalesTable;

        boolean ret;

        mcrInstallmentPlanSalesTable = MCRInstallmentPlanSalesTable::findSalesId(salesTable.SalesId);
        if (mcrInstallmentPlanSalesTable)
        {
            mcrInstallmentPlanSalesTable.createInstallmentPlan(salesTable);
        }

        // apply tender discounts
        if (RetailOrdersFeatureControl::isApplyRetailTenderDiscountToRetailOrdersFeatureEnabled())
        {
            RetailSalesOrderCalculator retailCalculator = RetailSalesOrderCalculator::construct(salesTable.SalesId);
            retailCalculator.setTenderDiscountOnOrderForPayment();
        }

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleBillUpFrontContChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles the bill up front continuity child orders.
    /// </summary>
    /// <remarks>
    /// The continuity children that are children of a bill up front parent
    ///     have already been paid for and should be settled when they are being invoiced.
    ///     Retrieve the <c>CustTransOpen</c> record of the child and the payment <c>CustTransOpen</c> from the
    ///     parent and settle the two.
    /// </remarks>
    public void settleBillUpFrontContChildren()
    {
        Num                 contParent;
        Num                 contChild;
        AmountCur           sumTransAmountCur;
        AmountCur           sumTransAmtCurPaym;
        LedgerJournalTable  ledgerJournalTable_local;
        LedgerJournalTrans  ledgerJournalTrans;
        CustTable           custTable;
        CustTransOpen       custTransOpen;
        CustTrans           custTrans;
        CustInvoiceJour     custInvoiceJour;

        contParent = SalesTableLinks::find(salesTable.SalesId).MainSalesId;
        contChild = salesTable.SalesId;
        custTable = CustTable::find(salesTable.InvoiceAccount);

        SpecTransExecutionContext context = SpecTransExecutionContext::newFromSource(custTable);
        SpecTransManager specTransManager = SpecTransManager::newFromSpec(context.parmSpecContext(), false);
        specTransManager.deleteAll();
        // Add in the amount of the continuity child
        while select RecId, TableId, AmountCur from custTransOpen
                    join CurrencyCode from custTrans
                    join LedgerVoucher from custInvoiceJour
                    where custInvoiceJour.SalesId == contChild
                          && custInvoiceJour.InvoiceAccount == custTable.AccountNum
                          && custTrans.Voucher == custInvoiceJour.LedgerVoucher
                          && custTransOpen.RefRecId == custTrans.RecId
        {
            sumTransAmountCur += custTransOpen.AmountCur;

            specTransManager.insert(custTransOpen.DataAreaId,
                             custTransOpen.TableId,
                             custTransOpen.RecId,
                             custTransOpen.AmountCur,
                             custTrans.CurrencyCode);
        }
        // Add in the amount of the continuity parent's payment.
        while select RecId, TableId, AmountCur from custTransOpen
            join CurrencyCode from custTrans
            join Voucher from ledgerJournalTrans
            join JournalNum from ledgerJournalTable_local
            where ledgerJournalTrans.mcrPaymOrderID == contParent
                  && ledgerJournalTrans.JournalNum == ledgerJournalTable_local.JournalNum
                  && custTrans.Voucher == ledgerJournalTrans.Voucher
                  && custTransOpen.RefRecId == custTrans.RecId
                  && custTransOpen.AccountNum == custTable.AccountNum
        {
            sumTransAmtCurPaym += custTransOpen.AmountCur;

            specTransManager.insert(custTransOpen.DataAreaId,
                         custTransOpen.TableId,
                         custTransOpen.RecId,
                         custTransOpen.AmountCur,
                         custTrans.CurrencyCode);
        }
        if (sumTransAmountCur != 0 && sumTransAmtCurPaym != 0)
        {
            CustTrans::settleTransaction(context, CustTransSettleTransactionParameters::construct());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleInstallmentsOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Settles the installment only order.
    /// </summary>
    /// <param name="_instalAdjs">
    /// Indicates there are installment adjustments; optional.
    /// </param>
    /// <remarks>
    ///     It is possible that an installment only order is partiall invoiced and at the
    ///     time of a partial invoice it is crucial to figure out what part of the installment
    ///     that is billed needs to be applied towards the partial.So we create the spec trans
    ///     records in two different ways - if it is a non partial invoice then all the payments
    ///     are used to create the spec trans and then match it up with the invoice else
    ///     you first figure out the invoice amount and then match it up with a portion of
    ///     the payment.
    /// </remarks>
    protected void settleInstallmentsOrder(boolean _instalAdjs = false)
    {
        CustTrans                   custTrans;
        CustTransOpen               custTransOpen;
        AmountCur                   sumTransAmountCur;
        CustInvoiceJour             custInvoiceJour;
        LedgerJournalTrans          ledgerJournalTrans;
        LedgerJournalTable          ledgerJournalTable_local;
        AmountCur                   invoiceAmount;
        AmountCur                   salesTotalAmount;
        boolean                     partialInvoice;
        MCRPaymSchedLink            mcrPaymSchedLink;

        // Determine if this is a partial invoice - if so only apply a part of the
        // installment that is paid
        invoiceAmount = this.getTotalInvoicedAmount();
        salesTotalAmount = this.getTotalSalesAmount();
        CustTable custTable = CustTable::find(this.getInvoiceAccount());
        SpecTransExecutionContext context = SpecTransExecutionContext::newFromSource(custTable);
        SpecTransManager specTransManager = SpecTransManager::newFromSpec(context.parmSpecContext(), false);

        if (salesTotalAmount != invoiceAmount)
        {
            partialInvoice = true;
        }

        while select RecId from custTrans
            where custTrans.mcrPaymOrderID == salesTable.SalesId
                && custTrans.CancelledPayment == NoYes::No
            join RecId from custTransOpen
            where custTransOpen.RefRecId == custTrans.RecId
                 && custTransOpen.DueDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
            exists join mcrPaymSchedLink
            where mcrPaymSchedLink.CustTransOpenRefRecId == custTransOpen.RecId
        {
            sumTransAmountCur += custTransOpen.AmountCur;

            specTransManager.insert(custTransOpen.DataAreaId,
                                custTransOpen.TableId,
                                custTransOpen.RecId,
                                custTransOpen.AmountCur,
                                custTrans.CurrencyCode);
        }

        if (partialInvoice == false)
        {
            while select RecId, TableId, AmountCur, DueDate from custTransOpen order by DueDate asc
                join CurrencyCode, mcrPaymOrderID, Closed, LastSettleVoucher from custTrans
                join Voucher from ledgerJournalTrans
                join JournalNum from ledgerJournalTable_local
                where ledgerJournalTrans.mcrPaymOrderID == salesTable.SalesId
                    && ledgerJournalTrans.JournalNum == ledgerJournalTable_local.JournalNum
                    && custTrans.Voucher == ledgerJournalTrans.Voucher
                    && custTransOpen.DueDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    && custTransOpen.RefRecId == custTrans.RecId
                    && custTransOpen.AccountNum == custTable.AccountNum
                    notexists join mcrPaymSchedLink
                    where mcrPaymSchedLink.CustTransOpenRefRecId == custTransOpen.RecId
            {
                sumTransAmountCur += custTransOpen.AmountCur;

                 specTransManager.insert(custTransOpen.DataAreaId,
                                     custTransOpen.TableId,
                                     custTransOpen.RecId,
                                     custTransOpen.AmountCur,
                                     custTrans.CurrencyCode);
            }
        }
        // Add invoice transactions to the offset voucher
        sumTransAmountCur = 0;
        while select CurrencyCode from custTrans
            where custTrans.mcrPaymOrderID == salesTable.SalesId
            join RecId, TableId, DataAreaId, AmountCur from custTransOpen
            where custTransOpen.RefRecId == custTrans.RecId
                && custTransOpen.AccountNum == custTable.AccountNum
                && custTransOpen.DueDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
            notexists join mcrPaymSchedLink
                    where mcrPaymSchedLink.CustTransOpenRefRecId == custTransOpen.RecId
            join LedgerVoucher from custInvoiceJour
            where (custInvoiceJour.SalesId == salesTable.SalesId
                  || custInvoiceJour.InvoiceId == salesTable.SalesId)
                  && custInvoiceJour.InvoiceAccount == custTable.AccountNum
                  && custTrans.Voucher == custInvoiceJour.LedgerVoucher

        {
            sumTransAmountCur += custTransOpen.AmountCur;

            specTransManager.insert(custTransOpen.DataAreaId,
                                    custTransOpen.TableId,
                                    custTransOpen.RecId,
                                    custTransOpen.AmountCur,
                                    custTrans.CurrencyCode);
        }

        if (partialInvoice == true)
        {
            while select RecId, TableId, AmountCur, DueDate from custTransOpen order by DueDate asc
                join CurrencyCode, mcrPaymOrderID, Closed, LastSettleVoucher from custTrans
                join Voucher from ledgerJournalTrans
                join JournalNum from ledgerJournalTable_local
                where ledgerJournalTrans.mcrPaymOrderID == salesTable.SalesId
                    && ledgerJournalTrans.JournalNum == ledgerJournalTable_local.JournalNum
                    && custTrans.Voucher == ledgerJournalTrans.Voucher
                    && custTransOpen.DueDate <= DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    && custTransOpen.RefRecId == custTrans.RecId
                    && custTransOpen.AccountNum == custTable.AccountNum
                exists join mcrPaymSchedLink
                where mcrPaymSchedLink.CustTransOpenRefRecId == custTransOpen.RecId
            {
                custTransOpen.AmountCur += sumTransAmountCur;
                specTransManager.insert(custTransOpen.DataAreaId,
                                     custTransOpen.TableId,
                                     custTransOpen.RecId,
                                     custTransOpen.AmountCur,
                                     custTrans.CurrencyCode);
            }
        }
        // settle the transactions
        CustTrans::settleTransaction(context, CustTransSettleTransactionParameters::construct());
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleOnAccountPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles on account payments.
    /// </summary>
    /// <remarks>
    /// On account payments need to be settled in case of returns and exchanges.
    ///     If the order is a return and does not have a corresponding exchange order,
    ///     settle the return amounts with the original order, if the return has
    ///     an exchange order, settle with the original order and then of any amount left
    ///     settle with the exchange.
    ///     If the order is an exchange it can only settle with the return if any amount
    ///     exists on the return.
    /// </remarks>
    public  void settleOnAccountPayments()
    {
        CustTable               custTable;
        CustTrans               custTrans;
        CustTransOpen           custTransOpen;
        CustInvoiceJour         custInvoiceJour;
        Num                     orderID = this.getOrderID();
        SalesId                 originalOrderId;
        SalesId                 exchangeOrderId;
        SalesId                 returnOrderId;
        MCRReturnSalesTable     mcrReturnSalesTable;

        custTable = CustTable::find(this.getInvoiceAccount());

        salesTable = SalesTable::find(orderID);
        mcrReturnSalesTable = salesTable.mcrReturnSalesTable();

        // create a specification offset voucher for the current customer
        SpecTransExecutionContext context = SpecTransExecutionContext::newFromSource(custTable);
        SpecTransManager specTransManager = SpecTransManager::newFromSpec(context.parmSpecContext(), false);

        // clear any marked transactions
        // Change the delete to delete all as delete does not deal with
        // the intercompany marked transactions
        specTransManager.deleteAll();

        // If this is a return order check if it has a corresponding exchange that is invoiced
        // if it does not then just adjust against the original order.
        if (salesTable.SalesType == SalesType::ReturnItem)
        {
            originalOrderId = mcrReturnSalesTable.OriginalSalesId;
            exchangeOrderId = salesTable.ReturnReplacementId;
            if (!exchangeOrderId)
            {
                if (SalesTable::find(orderID).SalesStatus == SalesStatus::Invoiced
                    || CustInvoiceJour::exist(orderID))
                {
                    this.processOnAccountReturns(orderID, originalOrderId, custTable, custTrans,
                                            custTransOpen, custInvoiceJour,
                                            specTransManager);
                }
            }
            else
            {
                // If there is an exchange order assoicated to the return
                // check to see if the apply credit is checked, if it is
                // check to see if if the exchange order is invoiced and if it is
                // then settle the exchange with the return, ensure that both exchange and the
                // return are invoice to apply payments against each other.
                if (mcrReturnSalesTable.ApplyCreditToExchange)
                {
                    if (this.checkIfOriginalOrderIsSettled(originalOrderId, custTable))
                    {
                        if ((SalesTable::find(orderID).SalesStatus == SalesStatus::Invoiced
                            || CustInvoiceJour::exist(orderID))
                            && salesTable.SalesType == SalesType::ReturnItem)
                        {
                            this.processOnAccountReturns(orderID, originalOrderId, custTable, custTrans,
                                            custTransOpen, custInvoiceJour,
                                            specTransManager);
                            CustTrans::settleTransaction(context, CustTransSettleTransactionParameters::construct());
                            // if there is a balance after having applied to the original
                            // apply to the exchange if an exchange is invoiced.
                            if ((SalesTable::find(exchangeOrderId).SalesStatus == SalesStatus::Invoiced
                                || CustInvoiceJour::exist(exchangeOrderId))
                                && (SalesTable::find(orderID).SalesStatus == SalesStatus::Invoiced
                                || CustInvoiceJour::exist(orderID)))
                            {
                                 this.processOnAcctReturnWithExchange(orderID, exchangeOrderId, custTable, custTrans,
                                                            custTransOpen, custInvoiceJour,
                                                            specTransManager);
                            }
                        }
                    }
                    else
                    {
                        if ((SalesTable::find(exchangeOrderId).SalesStatus == SalesStatus::Invoiced
                            || CustInvoiceJour::exist(exchangeOrderId))
                            && (SalesTable::find(orderID).SalesStatus == SalesStatus::Invoiced
                            || CustInvoiceJour::exist(orderID)))
                        {
                            this.processOnAcctReturnWithExchange(orderID, exchangeOrderId, custTable, custTrans,
                                                            custTransOpen, custInvoiceJour,
                                                            specTransManager);
                        }
                    }
                }
                else
                {
                    // If apply credit is not checked, then the return still needs to settle
                    // against the original order.
                    if ((SalesTable::find(orderID).SalesStatus == SalesStatus::Invoiced
                        || CustInvoiceJour::exist(orderID))
                        && (SalesTable::find(orderID).SalesStatus == SalesStatus::Invoiced
                        || CustInvoiceJour::exist(orderID)))
                    {
                        this.processOnAccountReturns(orderID, originalOrderId, custTable, custTrans,
                                            custTransOpen, custInvoiceJour,
                                            specTransManager);
                    }
                }
            }
        }
        else
        {
            // If this is an exchange order , find its return order and settle against it.
            if (mcrReturnSalesTable.IsExchange)
            {
                exchangeOrderId = salesTable.SalesId;

                returnOrderId = SalesTable::mcrFindReturnByExchId(exchangeOrderId).SalesId;

                if (SalesTable::find(returnOrderId).SalesStatus == SalesStatus::Invoiced
                    || CustInvoiceJour::exist((returnOrderId)))
                {
                    this.processOnAcctReturnWithExchange(returnOrderId, exchangeOrderId, custTable, custTrans,
                                                                custTransOpen, custInvoiceJour,
                                                                specTransManager);
                }
            }
        }
        CustTrans::settleTransaction(context, CustTransSettleTransactionParameters::construct());
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlePayments</Name>
				<Source><![CDATA[
    public  void settlePayments(boolean _paymAdjs = false)
    {
        MCRCustPaymTotals   custPaymTotals_OrigOrder;
        AmountCur           notOnAccount_OrigOrder;
        SalesTable          salesTable_Orig;
        // Summary invoicing with credit cards or cash was causing
        // exchange rate failure as the trade totals calc was being called without an
        // active sales order record.

        if (salesTable.RecId == 0)
        {
            return;
        }
        switch (salesTable.mcrEvalSalesOrderType())
        {
            case MCRSalesOrderType::RegularOrder:
            case MCRSalesOrderType::OrderAndContinuity:
            case MCRSalesOrderType::Continuityonly:
                super(_paymAdjs);
                salesTable_Orig = SalesTable::find(salesTable.mcrReturnSalesTable().OriginalSalesId);
                custPaymTotals_OrigOrder = MCRCustPaymTotals::construct(salesTable_Orig.TableId,
                                                                           salesTable_Orig.RecId);
                if (custPaymTotals_OrigOrder)
                {
                    notOnAccount_OrigOrder = custPaymTotals_OrigOrder.getTotalPaymAmount_notOnAccount();
                }

                if ((salesTable.returnItem() && salesTable_Orig) &&
                    (this.getTotalPaymAmount_notOnAccount() != 0 || notOnAccount_OrigOrder != 0))
                {
                    this.settleReturnwithOrigInvoice();
                }
            break;
            case MCRSalesOrderType::InstallmentOnly:
                this.settleInstallmentsOrder(true);
            break;
            case MCRSalesOrderType::OrderAndInstallment:
                super();
                this.settleInstallmentsOrder();
            break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleReturnwithOrigInvoice</Name>
				<Source><![CDATA[
    private void settleReturnwithOrigInvoice()

    {
        CustTransOpen custTransOpen;
        CustTrans   custTrans;
        CustInvoiceJour custInvoiceJour;
        AmountCur sumTransAmountCur;
        Num  originalOrderID;
        AmountCur amtToApply;
        CustTable   custTable;

        originalOrderID = salesTable.mcrReturnSalesTable().OriginalSalesId;
        custTable = CustTable::find(this.getInvoiceAccount());
        // create a specification offset voucher for the current customer
        SpecTransExecutionContext context = SpecTransExecutionContext::newFromSource(custTable);
        SpecTransManager specTransManager = SpecTransManager::newFromSpec(context.parmSpecContext(), false);

        // clear any marked transactions
        // Delete all instead of using delete on the spectransmanager as the
        // delete does not deal with intercompany records.
        specTransManager.deleteAll();

        while select RecId, TableId, AmountCur from custTrans
            join LedgerVoucher from custInvoiceJour
            where custInvoiceJour.SalesId == salesTable.SalesId
            &&  custInvoiceJour.InvoiceAccount == custTable.AccountNum
            &&  custTrans.Voucher == custInvoiceJour.LedgerVoucher
        {
            while select RefRecId, AccountNum, AmountCur, DataAreaId, TableId, RecId
                from  custTransOpen
                where custTransOpen.RefRecId   == custTrans.RecId
                &&    custTransOpen.AccountNum == custTable.AccountNum
            {
                sumTransAmountCur += custTransOpen.AmountCur;

                specTransManager.insert(custTransOpen.DataAreaId,
                                            custTransOpen.TableId,
                                            custTransOpen.RecId,
                                            custTransOpen.AmountCur,
                                            custTrans.CurrencyCode);
            }
        }
        if (sumTransAmountCur < 0)
        {
            amtToApply = sumTransAmountCur;
            // add the open invoice
            while select Voucher, RecId, TableId, AmountCur from custTrans
                join LedgerVoucher from custInvoiceJour
                where custInvoiceJour.SalesId == originalOrderID
                &&  custInvoiceJour.InvoiceAccount == custTable.AccountNum
                &&  custTrans.Voucher == custInvoiceJour.LedgerVoucher
            {
                select forupdate custTransOpen
                    where custTransOpen.RefRecId == custTrans.RecId;

                specTransManager.insert(custTransOpen.DataAreaId,
                                        custTransOpen.TableId,
                                        custTransOpen.RecId,
                                        0,
                                        custTrans.CurrencyCode);
                    break;
            }
        }
        CustTrans::settleTransaction(context, CustTransSettleTransactionParameters::construct());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransStatus</Name>
				<Source><![CDATA[
    public void setTransStatus()
    {
        salesTable = this.findSalesTable(true);

        // update the sales order status, based upon the status of the lines
        salesTable.updateBackStatus();

        ttsbegin;

        salesTable.reread();

        // if the sales order is ready to be picked
        if (salesTable.SalesStatus == SalesStatus::Backorder
            && salesTable.mcrOrderStopped == NoYes::No)
        {
            // create drop shipments
            this.createDropShipPurchaseOrder(salesTable);
        }

        ttscommit;

        // If any payments are declined or on hold, unreserve any
        // sales order lines that are reserved.
        if (MCROrderParameters::find().mcrUnReserveOnDeclinedPayment
            && this.getOverallPaymStatus() == MCRCustPaymStatus::Declined)
        {
            SalesTable::mcrUnReserveOrderLines(salesTable.SalesId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTotalPaymAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the total payment amount.
    /// </summary>
    /// <param name="_showErrors">
    /// A <c>Boolean</c> that indicates whether to display errors to the user if they occur.
    /// </param>
    /// <returns>
    /// true when the total payment amount is valid; otherwise, false.
    /// </returns>
    public  boolean validateTotalPaymAmount(boolean _showErrors = true)
    {
        boolean ret = true;

        // only check for call center orders.
        if (SalesTable::findRecId(refRecID).mcrIsCallCenter())
        {
            // If the order has already been released, there is no need to validate the total amount
            if (SalesTable::findRecId(refRecID).mcrSalesTable().OutOfBalanceReleased == MCROutOfBalanceReleaseType::None)
            {
                ret = super(_showErrors);
            }

            // If the order is out of balance need to check whether or not
            //      processing the SO is allowed.
            if (!ret)
            {
                ret = (SalesParameters::find().mcrAllowOutOfBalance == NoYes::Yes);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>