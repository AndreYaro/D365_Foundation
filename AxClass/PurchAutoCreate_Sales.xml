<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchAutoCreate_Sales</Name>
	<SourceCode>
		<Declaration><![CDATA[
class       PurchAutoCreate_Sales
extends     PurchAutoCreate
{
    /*
    A temporary table is received (TmpPurchLinePrice) containing a record for each PurchLine
    that is to be created. Notice that every time this class is called, it is assumed that all
    the records belongs to the same vendor.
    */

    TmpPurchLinePrice           tmpPurchLinePrice;
    SalesLine                   salesLine;
    SalesTable                  salesTable;
    AgreementLine               matchingAgreementLine;

    boolean                     transferAddress;
    boolean                     recalculateDlvDates;
    boolean                     searchForAgreements;
    boolean                     transferAddressFromAgreement;

    boolean                     dropShipment;
    TradeLineDlvType            tradeLineDlvType;
    TransDate                   poTransDate;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>autoCreateForICSO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Automatically creates the intercompany chain for the newly created intercompany sales order
    /// if the sales order is set for InterCompanyAutoCreateOrders = true.
    /// </summary>
    protected void autoCreateForICSO()
    {
        SalesTable icsoSalesTable = purchTable.interCompanySalesTable();
        if (icsoSalesTable && icsoSalesTable.InterCompanyAutoCreateOrders)
        {
            boolean chainCreated;

            changecompany(icsoSalesTable.DataAreaId)
            {
                if (!icsoSalesTable.existInterCompanySales() && !this.interCompanyCycleExists(icsoSalesTable))
                {
                    TradeInterCompany::autoCreateOrder(icsoSalesTable);

                    // If nested chain has been created recalculate delivery dates
                    if (icsoSalesTable.existInterCompanySales())
                    {
                        chainCreated = true;
                    }
                }
            }

            if (chainCreated)
            {
                SalesLine osoSalesLine;
                SalesLine icsoSalesLine;

                while select forupdate crosscompany osoSalesLine
                join   icsoSalesLine
                where  icsoSalesLine.SalesId                    == icsoSalesTable.SalesId
                    //Without + '' filter on dataAreaId will be added, which will make query return no result
                    && icsoSalesLine.InterCompanyInventTransId  == osoSalesLine.InventRefTransId + ''
                    && icsoSalesLine.DataAreaId                 == icsoSalesTable.DataAreaId
                    && osoSalesLine.DataAreaId                  == salesTable.DataAreaId
                {
                    this.recalculateSalesLineDatesForOriginalSalesLine(osoSalesLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateSalesLineDatesForOriginalSalesLine</Name>
				<Source><![CDATA[
    protected void recalculateSalesLineDatesForOriginalSalesLine(SalesLine _salesLine)
    {
        if (_salesLine.InterCompanyOrigin == IntercompanyOrigin::Source)
        {
            SalesCalcAvailableDlvDates salesCalcAvailableDlvDates;
            if (PurchAutoCreateDoNotRecalcOrigSalesLineDatesFlight::instance().isEnabled())
            {
                salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_salesLine);
                salesCalcAvailableDlvDates.validateWritePrompt(_salesLine,false,true);
                if (!salesCalcAvailableDlvDates.parmErrorText())
                {
                    SalesLine intercompanySalesLine = _salesLine.interCompanySalesLine();

                    changecompany(intercompanySalesLine.DataAreaId)
                    {
                        SalesCalcAvailableDlvDates localSalesCalcAvailableDlvDates = IntercompanySalesCalcAvailableDlvDates_SalesLine::newSalesLine(intercompanySalesLine, fieldNum(SalesLine, ReceiptDateRequested));
                        localSalesCalcAvailableDlvDates.validateWritePrompt(intercompanySalesLine, false, true);
                        if (intercompanySalesLine.ShippingDateRequested != intercompanySalesLine.orig().ShippingDateRequested)
                        {
                            intercompanySalesLine.selectForUpdate(true);
                            intercompanySalesLine.update();
                        }
                    }
                }
            }
            if (!PurchAutoCreateDoNotRecalcOrigSalesLineDatesFlight::instance().isEnabled() || salesCalcAvailableDlvDates.parmErrorText())
            {
                // Reset dates, so that date calculation does not override its result with actual sales line dates.
                _salesLine.ShippingDateRequested = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                _salesLine.ReceiptDateRequested = dateNull();

                SalesCalcAvailableDlvDates::initDateFields(_salesLine);
                _salesLine.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    void  create()
    {
        try
        {
            super();

            this.autoCreateForICSO();
        }

        catch (Exception::Error)
        {
            return;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchLine</c> to be created.
    /// </summary>
    /// <returns>The initialized line</returns>
    protected PurchLine initPurchLine()
    {
        PurchLine localPurchLine;

        localPurchLine.clear();        
        localPurchLine.initValue();        
        localPurchLine.DeliveryType  = tradeLineDlvType;
        localPurchLine.initFromPurchTable(purchTable);
        localPurchLine.ItemId        = salesLine.ItemId;
        localPurchLine.initFromInventTable(salesLine.inventTable());
        localPurchLine.initFromSalesLine(salesLine);

        if (EcoResProductUnitConverter::mustProductVariantsHaveSpecificConversion(salesLine.ItemId))
        {
            this.defaultPurchLineOnInventoryDimensionChange(localPurchLine, salesLine.inventTable());
        }

        if (tradeLineDlvType == TradeLineDlvType::DropShip)
        {
            localpurchLine.MCRDropShipment = dropShipment;
        }
        localPurchLine.PurchUnit     = tmpPurchLinePrice.PurchUnit;
        localPurchLine.PurchQty      = tradeLineDlvType == TradeLineDlvType::None ? tmpPurchLinePrice.PurchQty :
            EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                  salesLine.InventDimId,
                                                                                  salesLine.getPurchQty(),
                                                                                  salesLine.SalesUnit,
                                                                                  localPurchLine.PurchUnit,
                                                                                  NoYes::Yes);

        return localPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPurchLineOnInventoryDimensionChange</Name>
				<Source><![CDATA[
    private void defaultPurchLineOnInventoryDimensionChange(PurchLine _purchLine, InventTable _inventTable)
    {
        Set dimFields = InventDim::dimFieldList2Set(InventDimParm::allProductDim().selectedDimFields());
        var defaultingArguments =
            InventDistinctProductDimensionSpecificDefaultingArgsPurchLine::construct(_inventTable, true, true, true, false);

        // This ensures the defaulting will not overwrite the storage dimensions (site, warehouse) already set on the purchase order line
        defaultingArguments.parmKeepOrigin(true);

        var inventDistinctProductOrderDefaultingController = InventDistinctProductOrderDefaultingController::constructFromFieldSet(dimFields);

        inventDistinctProductOrderDefaultingController.inventDimModified(_purchLine.type(), _purchLine.inventDim(), defaultingArguments);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLine</Name>
				<Source><![CDATA[
    void createLine()
    {
        PurchOrderLineCreationInstrumentationActivities instrumentationActivities = this.instrumentationLogger().purchOrderLineCreationActivities();

        using (var activityContext = instrumentationActivities.createLine())
        {
            InterCompanyEndpointActionPolicy interCompanyEndpointActionPolicy = purchTable.interCompanyEndpointActionPolicy();
            
            ttsbegin;

            PurchLine localPurchLine = this.initPurchLine();

            if (localPurchLine.ProjId)
            {
                localPurchLine.ActivityNumber     = salesLine.ActivityNumber;
                localPurchLine.ProjLinePropertyId = salesLine.ProjLinePropertyId;
                localPurchLine.ProjSalesUnitId    = salesLine.SalesUnit;
                localPurchLine.ProjSalesPrice     = salesLine.SalesPrice;
                localPurchLine.ProjTaxItemGroupId = ProjParameters::taxItemGroupItem(salesLine.ProjCategoryId, salesLine.ItemId);
            }

            Qty remainQty = this.calcRemainQty(localPurchLine);

            localPurchLine.PdsCWQty = tradeLineDlvType == TradeLineDlvType::None ? tmpPurchLinePrice.PdsCWQty : salesLine.PdsCWRemainInventPhysical;
            Qty cwRemainQty = tmpPurchLinePrice.PdsCWQty - localPurchLine.PdsCWQty;
        
            InventDim inventDim = localPurchLine.inventDim();

            if (EcoResProductVariantItemSalesTaxGroupFeature::isFeatureEnabled()
                && (!EcoResProductVariantItemSalesTaxGroupNoBRFlight::instance().isEnabled() || !(BrazilParameters::isEnabled() && localPurchLine.CFOPTable_BR)))
            {
                localPurchLine.TaxItemGroup = InventTable::getTaxItemGroupId(ModuleInventPurchSales::Purch, localPurchLine.ItemId, inventDim.InventDimId);
            }

            InventTable inventTable = salesLine.inventTable();
            if (inventTable.purchInventSiteId(inventDim.InventSiteId, inventDim.inventDimId) != inventDim.InventSiteId)
            {
                inventDim.InventSiteId = inventTable.purchInventSiteId(inventDim.InventSiteId, inventDim.inventDimId);

                localPurchLine.setInventDimIdFromInventDim(inventDim);
            }

            inventDim = localPurchLine.inventDim();

            InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newInventTable(inventTable);
            if (inventTable.purchInventLocationId(inventDim.InventLocationId,
                                                  inventDim.InventDimId,
                                                  inventDim.InventSiteId) != inventDim.InventLocationId)
            {
                inventDim.InventLocationId = inventTable.purchInventLocationId(inventDim.InventLocationId,
                                                                                 inventDim.InventDimId,
                                                                                 inventDim.InventSiteId);

                inventDim.initFromInventLocation(inventDim.inventLocation());

                localPurchLine.setInventDimIdFromInventDim(inventDim);
            }

            boolean consistentInventDim = InventDim::isInventDimEqualConsistent(inventDimGroupSetup, salesLine.inventDim(), inventDim);

            if (!consistentInventDim)
            {
                if (localPurchLine.isDropShipment() || localPurchLine.isInterCompanyOrder())
                {
                    throw error("@SYS122773");
                }
                else
                {
                    localPurchLine.clearInventReference();
                    warning("@SYS127154");
                }
            }

            this.transferDeliveryAddress(localPurchLine);

            if (this.mustSyncPurchLine())
            {
                AxPurchLine axPurchLine = SalesLineType::construct(salesLine).syncPurchLine(salesLine, localPurchLine, true);
                axPurchLine.setTableFieldsForce();
                localPurchLine = axPurchLine.purchLine();
            }
            else
            {
                if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
                {
                    if (isConfigurationkeyEnabled(configurationKeyNum(SalesDeliveryDateControl))
                    && tradeLineDlvType != tradeLineDlvType::DropShip)
                    {
                        localPurchLine.DeliveryDate = salesLine.ShippingDateRequested;
                    }
                    else
                    {
                        localPurchLine.DeliveryDate = salesLine.ReceiptDateRequested;
                    }

                    localPurchLine.calculateRequestedShipAndReceiptDate(dateNull(), localPurchLine.DeliveryDate, SchedDirection::Backward);
                    localPurchLine.SkipShipReceiptDateCalculation = true;
                }
            }

            if (purchTable.isInterCompanyOrder())
            {
                localPurchLine.InterCompanyOrigin = InterCompanyOrigin::Derived;
            }

            if (localPurchLine.PurchQty + remainQty)
            {
                if (purchTable.InterCompanyOrder
                    && (!interCompanyEndpointActionPolicy.PriceDiscountSearch
                        || (localPurchLine.PurchQty < 0 && salesLine.interCompanyReturnItemInventTransId())))
                {
                    if (localPurchLine.PurchQty < 0 && salesLine.interCompanyReturnItemInventTransId())
                    {
                        VendInvoiceTrans vendInvoiceTrans = VendInvoiceTrans::findInventTransId(salesLine.interCompanyReturnItemInventTransId());
                        localPurchLine.PurchPrice     = vendInvoiceTrans.PurchPrice;
                        localPurchLine.PriceUnit      = vendInvoiceTrans.PriceUnit;
                        localPurchLine.PurchMarkup    = vendInvoiceTrans.PurchMarkup;
                        localPurchLine.LinePercent    = vendInvoiceTrans.LinePercent;
                        localPurchLine.LineDisc       = vendInvoiceTrans.LineDisc;
                        localPurchLine.MultiLnPercent = vendInvoiceTrans.MultiLnPercent;
                        localPurchLine.MultiLnDisc    = vendInvoiceTrans.MultiLnDisc;
                        localPurchLine.DiscAmount     = localPurchLine.discAmount();
                        localPurchLine.DiscPercent    = localPurchLine.discPercent();
                    }

                    if (!localPurchLine.salesPurchLineInterface().pdsPrice())
                    {
                        // If purchase price is not specified do not force line amount calculation. Only align LineAmount sign with
                        // PurchQty sign for cases with return orders having return cost price set to zero.
                        if (localPurchLine.PurchQty < 0 && sign(localPurchLine.PurchQty) != sign(localPurchLine.LineAmount))
                        {
                            localPurchLine.LineAmount = -localPurchLine.LineAmount;
                        }
                    }
                    else
                    {
                        localPurchLine.LineAmount = localPurchLine.calcLineAmountForced();
                    }
                }
                else
                {
                    //if searched in UI form
                    if (tmpPurchLinePrice.PriceSearched)
                        localPurchLine.initFromTmpPurchLinePrice(tmpPurchLinePrice);
                    else
                        localPurchLine.setPriceDisc(inventDim);
                }

                if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
                {
                    this.kittingCreateLine_delegate(localPurchLine, salesLine);
                }

                localPurchLine.SkipUpdate = InterCompanySkipUpdate::No;

                this.createPurchaseLine(localPurchLine);

                salesLine.reread();
            }
            else
            {
                if (salesLine.RemainSalesPhysical && !localPurchLine.PurchQty && localPurchLine.PurchUnit != salesLine.SalesUnit)
                {
                    throw error("@SYS127725");
                }
                else
                {
                    throw error("@SYS54003");
                }
            }

            if (localPurchLine.RecId)
            {
                boolean setSourcingIfInventRefNotEmpty = PurchAutoCreateSalesEmptyInventRefSkipSourcingFlight::instance().isEnabled();

                if (this.mustClearInventReference(localPurchLine, consistentInventDim))
                {
                    salesLine.clearInventReference();

                    if (setSourcingIfInventRefNotEmpty)
                    {
                        salesLine.clearSourcingFields();
                    }
                }
                else
                {
                    this.initSalesLineReferenceFields(localPurchLine);

                    if (setSourcingIfInventRefNotEmpty && this.mustUpdateSourcingInformation())
                    {
                        this.updateSourcingInformation(localPurchLine);
                    }
                }
                // Added condition to set fields if its a drop ship.
                if (tradeLineDlvType == TradeLineDlvType::DropShip)
                {
                    MCRSalesLineDropShipment mcrSalesLineDropShipment = salesLine.mcrSalesLineDropShipment();
                    mcrSalesLineDropShipment.DropShipStatus   = MCRDropShipStatus::POCreated;
                    mcrSalesLineDropShipment.DropShipment = NoYes::Yes;
                    SalesLine.mcrPackMCRSalesLineDropShipment(mcrSalesLineDropShipment);
                }

                // When the purchase order line has been created from the sales order header (new purchase order, new direct delivery or automatic creation)
                // then sourcing and delivery type information needs to be updated on the original sales order line
                if (!setSourcingIfInventRefNotEmpty && this.mustUpdateSourcingInformation())
                {
                    this.updateSourcingInformation(localPurchLine);
                }

                salesLine.SkipUpdate = InterCompanySkipUpdate::Internal;
                salesLine.update();

                if (salesLine.ProjId && salesLine.InventRefType == InventRefType::Purch)
                {
                    InventMovement inventMov_Sales = InventMovement::construct(salesLine);
                    if (inventMov_Sales.mustBeCostControlled() && inventMov_Sales.canCommittedCostBeReversed())
                    {
                        CostControlPostingItem costControlPostingItem = CostControlPosting::newCostControlPostingItem(inventMov_Sales);
                        costControlPostingItem.run(ProjCommittedCostUpdateAction::UpdateReverse);
                    }
                }

                if (localPurchLine.InventRefId
                &&  localPurchLine.InventRefId != purchTable.InterCompanyOriginalSalesId)
                {
                    if (PurchAutoCreateUpdRefErrorFlight::instance().isEnabled())
                    {
                        purchTable.selectForUpdate(true);
                    }

                    purchTable.interCompanyPurchSalesReferenceCreate(localPurchLine.InventRefId);
                    purchTable.update();
                }
            }

            if (remainQty)
            {
                if (PdsGlobal::pdsIsCWItem(localPurchLine.ItemId))
                {
                    localPurchLine.PdsCWQty += cwRemainQty;
                    localPurchLine.PurchQty = PdsCatchWeight::inventQty(localPurchLine.ItemId,
                                                            localPurchLine.PdsCWQty,
                                                            localPurchLine.PurchUnit);
                }
                else
                {
                    localPurchLine.PurchQty += remainQty;
                }

                localPurchLine.initPurchQty();
                InventMovement::bufferSetRemainQty(localPurchLine);

                if (tradeLineDlvType == tradeLineDlvType::DropShip)
                {
                    // In case drop ship fully shipped set receive now so entire quantity
                    // will be processed
                    localPurchLine.PurchReceivedNow = localPurchLine.PurchQty;
                }
                localPurchLine.update();
            }

            if (purchTable.InterCompanyOrder)
            {
                TradeInterCompany::synchronizeDocuRef(salesLine);
            }

            if (tmpPurchLinePrice.MatchingAgreementLine)
            {
                // Try to associate with suggested agreement line
                matchingAgreementLine = AgreementLine::find(tmpPurchLinePrice.MatchingAgreementLine);

                if (matchingAgreementLine)
                {
                    // Set up rollback data...
                    PurchLine purchLineRollbackBuffer;
                    purchLineRollbackBuffer.data(localPurchLine);

                    // Initialize from suggested agreement line
                    localPurchLine.initFromAgreementLine(matchingAgreementLine);

                    // Validate we still can associate with suggested agreement line
                    if (matchingAgreementLine.isLinkValid(localPurchLine,false))
                    {
                        // Perform actual association
                        ttsbegin;
                        localPurchLine.update();
                        ttscommit;
                    }
                    else
                    {
                        localPurchLine.data(purchLineRollbackBuffer);
                    }
                }
            }

            ttscommit;
            purchLine = localPurchLine;

            instrumentationActivities.logCreateLine(activityContext, purchTable, purchLine, salesLine, tradeLineDlvType, interCompanyEndpointActionPolicy);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourcingInformation</Name>
				<Source><![CDATA[
    private void updateSourcingInformation(PurchLine _purchLine)
    {
        salesLine.populateSourcingFields(purchTable, _purchLine, tradeLineDlvType, this.vendTable.AccountNum);

        if (SalesDirDelivRecalcDateFeature::instance().isEnabled()
            && recalculateDlvDates)
        {
            salesLine.recalculateDatesForDirectDelivery();
        }
        
        if (IntercompanySalesLineSourcingSetRecalcDlvDatesFlight::instance().isEnabled())
        {
            SalesDeliveryDateControlType deliveryDateControlType = SalesLine::getDeliveryDateControlType(salesLine);
            if (this.intercompanyDirectDeliverySalesLineHasDeliveryDateControl(salesLine, deliveryDateControlType))
            {
                SalesCalcAvailableDlvDates salesCalcAvailableDlvDates = IntercompanySalesCalcAvailableDlvDates_SalesLine::newSalesLine(salesLine, fieldNum(SalesLine, ReceiptDateRequested));
                        
                salesLine.ShippingDateRequested = InterCompanySyncPurchLineType::getRequestedShippingDate(salesLine, purchLine, salesCalcAvailableDlvDates);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRemainQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the remaining quantity.
    /// </summary>
    /// <param name = "_purchLine">
    /// Purchase order line record buffer.
    /// </param>
    /// <returns>
    /// The calculated quantity.
    /// </returns>
    protected Qty calcRemainQty(PurchLine _purchLine)
    {
        return tmpPurchLinePrice.PurchQty - _purchLine.PurchQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustClearInventReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory reference fields on the <c>SalesLine</c> record must be cleared.
    /// </summary>
    /// <param name = "_purchLine">
    /// Purchase order line record buffer.
    /// </param>
    /// <param name = "_consistentInventDim">
    /// A boolean which determines if the inventory dimension are consistent.
    /// </param>
    /// <returns>
    /// true if the inventory reference fields must be cleared; otherwise, false.
    /// </returns>
    protected boolean mustClearInventReference(PurchLine _purchLine, boolean _consistentInventDim)
    {
        boolean isCWItem = PdsGlobal::pdsIsCwItem(_purchLine.ItemId);

        return  (! _consistentInventDim
                 || (!isCWItem
                     && _purchLine.unitConvertPurch2Invent(_purchLine.PurchQty) <
                    ((salesLine.SalesQty < 0) ? salesLine.unitConvertSales2Invent(salesLine.SalesQty) : salesLine.unitConvertSales2Invent(salesLine.RemainSalesPhysical)))
                 || (isCWItem
                     && _purchLine.PdsCWQty <
                    ((salesLine.SalesQty < 0) ? salesLine.PdsCWQty : salesLine.PdsCWRemainInventPhysical)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSalesLineReferenceFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory reference fields based on the <c>_localPurchLine.</c>
    /// </summary>
    /// <param name = "_localPurchLine">A <c>PurchLine</c>.</param>
    protected void initSalesLineReferenceFields(PurchLine _localPurchLine)
    {
        salesLine.InventRefTransId  = _localPurchLine.InventTransId;
        salesLine.InventRefId       = _localPurchLine.PurchId;        
        salesLine.InventRefType     = InventRefType::Purch;

        this.initSalesLineCostPrice(_localPurchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSalesLineCostPrice</Name>
				<Source><![CDATA[
    private void initSalesLineCostPrice(PurchLine _localPurchLine)
    {
        salesLine.CostPrice = _localPurchLine.getPurchPriceInCompanyCurrency();

        UnitOfMeasureSymbol inventUnitId = salesLine.inventTable().inventUnitId();

        // Converts cost price in purch unit to cost price in inventory unit
        if (_localPurchLine.PurchUnit != inventUnitId
            && salesLine.CostPrice)
        {
            salesLine.CostPrice = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                salesLine.InventDimId,
                salesLine.CostPrice,
                inventUnitId,
                    _localPurchLine.PurchUnit,
                NoYes::Yes,
                NoYes::No);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateSourcingInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sourcing information must be updated.
    /// </summary>
    /// <returns>
    /// true if the sourcing information must be updated; otherwise, false.
    /// </returns>
    protected boolean mustUpdateSourcingInformation()
    {
        return !salesLine.SourcingVendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyDirectDeliverySalesLineHasDeliveryDateControl</Name>
				<Source><![CDATA[
    private boolean intercompanyDirectDeliverySalesLineHasDeliveryDateControl(SalesLine _salesLine, SalesDeliveryDateControlType _deliveryDateControlType)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(SalesDeliveryDateControl)) && _deliveryDateControlType != SalesDeliveryDateControlType::None 
            && _salesLine.isDirectDelivery() && _salesLine.isIntercompanyOrigin())
        {
            PurchLine icPOLine = _salesLine.intercompanyPurchLine();            
            if (icPOLine)
            {
                changeCompany(icPOLine.DataAreaId)
                {
                    PurchTable icPO = icPOLine.purchTable();
                    return icPO.InterCompanyOrigin == IntercompanyOrigin::Source;
                }
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSyncPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the purchase order line must be synchronized.
    /// </summary>
    /// <returns>
    /// true if the purchase order line must be synchronized; otherwise, false.
    /// </returns>
    protected boolean mustSyncPurchLine()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTmpPurchLinePriceQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build query object for temporary purchase prices and discounts.
    /// </summary>
    /// <returns>A query object.</returns>
    protected SysDaQueryObject buildTmpPurchLinePriceQuery()
    {
        return new SysDaQueryObject(tmpPurchLinePrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchLine</Name>
				<Source><![CDATA[
    void createPurchLine()
    {
        SysDaQueryObject queryObject = this.buildTmpPurchLinePriceQuery();
        
        SysDaSearchObject searchObject = new SysDaSearchObject(queryObject);
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();
        while (searchStatement.nextRecord(searchObject))
        {
            salesLine = SalesLine::findRecId(tmpPurchLinePrice.SalesLineRefRecId, true);
            setPrefix(#PreFixField(SalesLine, ItemId));
            this.createLine();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchTable</Name>
				<Source><![CDATA[
    void createPurchTable()
    {
        if (this.skipInitializePurchTable())
        {
            return;
        }

        super();

        if (tmpPurchLinePrice.MatchingAgreement)
        {
            PurchAgreementHeader purchAgreementHeader = PurchAgreementHeader::find(tmpPurchLinePrice.MatchingAgreement);

            // Initialize newly created purchTable instance with matching Purchase Agreement Header...
            purchTable.initFromPurchAgreementHeader(purchAgreementHeader, transferAddressFromAgreement);

            ttsbegin;
            // Update purchTable record
            purchTable.update();
            // Associate purchTable record with selected Purchase Agreement Header...
            purchTable.associateWithPurchAgreement(purchAgreementHeader);
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchaseLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a purchase line.
    /// </summary>
    /// <param name = "_purchLine">An instance of the purchase line record.</param>
    protected void createPurchaseLine(PurchLine _purchLine)
    {
        using (var activityContext = this.instrumentationLogger().purchOrderLineCreationActivities().createPurchLineFromSalesOrder())
        {
            const boolean validation                  = true;
            const boolean initFromPurchTable          = false;
            const boolean initFromItemOrCategory      = false;
            const boolean calcInventQty               = true;
            const boolean searchMarkup                = true;
            const boolean searchPrice                 = false;
            const boolean ignorePurchTableInventDim   = false;
            const boolean searchAgreementLine         = true;
            const boolean setRemain                   = true;
            const boolean skipPurchTableUpdate        = false;
            const boolean skipInterCompanyCalcDisc    = true;

            _purchLine.createLine(validation,
                              initFromPurchTable,
                              initFromItemOrCategory,
                              calcInventQty,
                              searchMarkup,
                              searchPrice,
                              ignorePurchTableInventDim,
                              searchAgreementLine,
                              setRemain,
                              skipPurchTableUpdate,
                              skipInterCompanyCalcDisc);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    void endUpdate()
    {
        InterCompanyEndpointActionPolicy    interCompanyEndpointActionPolicy;
        SalesTable                          salesTableLocal;
        SalesLine                           salesLineLocal;
        PurchLine                           purchLineLocal;

        if (!purchLine)
        {
            throw Exception::Error;
        }

        if (purchTable)
        {
            interCompanyEndpointActionPolicy = purchTable.interCompanyEndpointActionPolicy();

            if (purchTable.PurchaseType != PurchaseType::ReturnItem
            && (!purchTable.InterCompanyOrder
             ||  interCompanyEndpointActionPolicy.PriceDiscountSearch))
            {
                ttsbegin;

                purchTable = PurchTable::findRecId(purchTable.RecId,true);

                select firstonly tmpPurchLinePrice;

                if (!tmpPurchLinePrice.PriceSearched)
                    purchTable.PriceDiscHeading::updateMultiLineDiscount(purchLineLocal);

                purchTable.PriceDiscHeading::updateFinalDiscount(purchLineLocal);

                ttscommit;
            }

            if (purchTable.PurchaseType != PurchaseType::ReturnItem
            &&  purchTable.InterCompanyOrder
            &&  purchTable.InterCompanyCompanyId)
            {
                changecompany(purchTable.InterCompanyCompanyId)
                {
                    ttsbegin;
                    salesTableLocal                  = null;
                    salesTableLocal                  = SalesTable::find(purchTable.InterCompanySalesId,true);
                    interCompanyEndpointActionPolicy = null;
                    interCompanyEndpointActionPolicy = salesTableLocal.interCompanyEndpointActionPolicy();
                    if (interCompanyEndpointActionPolicy.PriceDiscountSearch)
                    {
                        salesLineLocal = null;
                        select firstonly salesLineLocal
                            where salesLineLocal.SalesId == salesTableLocal.SalesId;
                        salesTableLocal.PriceDiscHeading::updateMultiLineDiscount(salesLineLocal);
                        salesTableLocal.PriceDiscHeading::updateFinalDiscount(salesLineLocal);
                    }
                    ttscommit;
                }
            }

            if (salesTable
            &&  purchTable.InterCompanyOrder)
            {
                TradeInterCompany::synchronizeDocuRef(salesTable);
            }

            if (purchTable.InterCompanyOrder
            && !this.interCompanyNewSalesLine())
            {
                this.interCompanyPickingListAutoPrint();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCycleExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the same customer is present more than once in the intercompany chain.
    /// </summary>
    /// <param name = "_salesTable">The sales table.</param>
    /// <returns>true if the same customer is present more than once in the intercompany chain; otherwise, false.</returns>
    protected boolean interCompanyCycleExists(SalesTable _salesTable)
    {
        boolean     vendorFound = false;
        DataAreaId  iscoDataAreaId = _salesTable.DataAreaId;
        CustAccount icsoCustAccount = _salesTable.CustAccount;
        salesTable  parentTable = _salesTable.interCompanyPurchTable().interCompanySalesTableOriginal();

        while (!vendorFound && parentTable)
        {
            if (parentTable.DataAreaId == iscoDataAreaId && parentTable.CustAccount == icsoCustAccount)
            {
                vendorFound = true;
                info("@Intercompany:ErrorCircularReferenceDetectedInIntercompanyChain");
            }

            parentTable = parentTable.interCompanyPurchTable().interCompanySalesTableOriginal();
        }

        return vendorFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyNewSalesLine</Name>
				<Source><![CDATA[
    protected boolean interCompanyNewSalesLine()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPickingListAutoPrint</Name>
				<Source><![CDATA[
    void interCompanyPickingListAutoPrint()
    {
        SalesTable      salesTableLocal;
        SalesFormLetter salesFormLetter;
        changecompany(purchTable.InterCompanyCompanyId)
        {
            salesTableLocal = SalesTable::find(purchTable.InterCompanySalesId);
            if (salesTableLocal.isInterCompanyOrder()
            &&  salesTableLocal.interCompanyEndpointActionPolicy().PickinglistAutoPrint)
            {
                salesFormLetter = SalesFormLetter::construct(DocumentStatus::PickingList);
                salesFormLetter.interCompanyPosted(true);
                salesFormLetter.update(salesTableLocal,
                                       DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                       SalesUpdate::All,                // Quantity
                                       AccountOrder::None,
                                       false,                           // Proforma
                                       true,                            // PrintOut
                                       true);                           // Use print management
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccount</Name>
				<Source><![CDATA[
    VendInvoiceAccount invoiceAccount()
    {
        return vendTable.InvoiceAccount  ? vendTable.InvoiceAccount
                                         : vendTable.AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(TmpPurchLinePrice           _tmpPurchLinePrice,
             PurchCreateFromSalesOrder  _purchCreateFromSalesOrder = null)
    {
        super(_tmpPurchLinePrice, _purchCreateFromSalesOrder);
        tmpPurchLinePrice       = _tmpPurchLinePrice;

        if (_purchCreateFromSalesOrder)
        {
            recalculateDlvDates             = _purchCreateFromSalesOrder.parmRecalculateDlvDates();
            transferAddress                 = _purchCreateFromSalesOrder.parmTransferAddress();
            tradeLineDlvType                = _purchCreateFromSalesOrder.tradeLineDlvType();
            dropShipment                    = _purchCreateFromSalesOrder.mcrDropShipment();
            poTransDate                     = _purchCreateFromSalesOrder.parmPOTransDate();
            searchForAgreements             = _purchCreateFromSalesOrder.parmSearchForAgreements();
            transferAddressFromAgreement    = _purchCreateFromSalesOrder.parmTransferDeliveryAddressFromAgreement();
            matchingAgreementLine           =  AgreementLine::find(tmpPurchLinePrice.MatchingAgreementLine);

            switch (_purchCreateFromSalesOrder.parmCallerRecord().TableId)
            {
                case tablenum(SalesTable):
                    salesTable      = _purchCreateFromSalesOrder.parmSalesTable();
                    break;

                case tablenum(PurchTable):
                    select firstonly tmpPurchLinePrice;
                    salesTable              = SalesTable::find(tmpPurchLinePrice.SalesId);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchType</Name>
				<Source><![CDATA[
    public PurchaseType purchType()
    {
        return SalesTableType::construct(salesTable).purchaseType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchTable</Name>
				<Source><![CDATA[
    void setPurchTable()
    {
        if (this.skipInitializePurchTable())
        {
            return;
        }

        super();

        purchTable.initFromSalesTable(salesTable);

        if (isConfigurationkeyEnabled(configurationKeyNum(SalesDeliveryDateControl)))
        {
            if(tradeLineDlvType != tradeLineDlvType::DropShip && PurchAutoCreateDeliveryDateSORequestedShipDateToggle::instance().isEnabled())
            {
                purchTable.DeliveryDate = salesTable.ShippingDateRequested;
            }
            else
            {
                purchTable.DeliveryDate = salesTable.ReceiptDateRequested;
            }
            purchTable.ReceiptDateConfirmed = salesTable.ReceiptDateConfirmed;
            purchTable.ShippingDateConfirmed = salesTable.ShippingDateConfirmed;
            purchTable.ShippingDateRequested = salesTable.ShippingDateRequested;
        }
        else
        {
            purchTable.DeliveryDate = salesTable.DeliveryDate;
        }

        if (tradeLineDlvType != tradeLineDlvType::DropShip)
        {
            // If the InterCompanyDirectDelivery flag is set on SO header, then it has been sync'd to PO in initFromSalesTable above.
            // Since this is not direct delivery, this should be set back to No to prevent direct delivery behavior from PO header
            if (salesTable.InterCompanyDirectDelivery)
            {
                purchTable.InterCompanyDirectDelivery = NoYes::No;
            }
        }

        if (transferAddress)
        {
            boolean shouldDeliveryPostalAddressSetFromSalesTable = !isConfigurationkeyEnabled(configurationKeyNum(TradeMultiShipTo));
           
            if (!salesLine)
            {
                salesLine = SalesLine::findRecId(tmpPurchLinePrice.SalesLineRefRecId, true);
            }

            purchTable.DeliveryName          = salesLine.DeliveryName;
            purchTable.DeliveryPostalAddress = shouldDeliveryPostalAddressSetFromSalesTable ? salesTable.DeliveryPostalAddress: salesLine.DeliveryPostalAddress;
        }
        purchTable.MCRDropShipment = dropShipment;

        if (purchTable.OrderAccount != this.invoiceAccount())
        {
            purchTable.InvoiceAccount = this.invoiceAccount();
            purchTable.initInvoiceAccount();
        }

        if (purchTable.InterCompanyOrder)
        {
            purchTable.InterCompanyOrigin = InterCompanyOrigin::Derived;
        }

        if (purchTable.interCompanyEndpointActionPolicy())
        {
            SalesTableType syncSalesTableType = SalesTableType::construct(salesTable);
            if (SalesPurchSyncDeliveryInfoFeature::instance().isEnabled())
            {
                syncSalesTableType.parmIsDirectDeliveryCreation(tradeLineDlvType == TradeLineDlvType::DropShip);
            }

            AxPurchTable axPurchTable = syncSalesTableType.syncPurchTable(salesTable, purchTable);
            axPurchTable.setTableFieldsForce();
            purchTable = axPurchTable.purchTable();
        }
        else
        {
            if (SalesPurchSyncDeliveryInfoFeature::instance().isEnabled())
            {
                PurchParameters purchParameters = PurchParameters::find();

                if (purchParameters.isDeliveryInformationCreateAllowed(tradeLineDlvType))
                {
                    purchTable.DlvMode = salesTable.DlvMode;
                    purchTable.DlvTerm = salesTable.DlvTerm;
                }
            }
        }

        if (tradeLineDlvType == TradeLineDlvType::DropShip
            ||  purchTable.isInterCompanyOrder())
        {
            if (vendTable.canAutoCreatePurchOrder())
            {
                purchTable.ChangeRequestRequired = NoYes::No;
            }
            else
            {
                throw error(strfmt("@SYS300245", vendTable.AccountNum, vendTable.name()));
            }
        }

        this.parmAccountingDate(poTransDate);

        if (salesTable.ProjId)
        {
            purchTable.ProjId = salesTable.ProjId;
            purchTable.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(salesTable.DefaultDimension, purchTable.DefaultDimension);
        }

        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            purchTable.calculateRequestedShipAndReceiptDate(dateNull(), purchTable.DeliveryDate, SchedDirection::Backward);
            purchTable.SkipShipReceiptDateCalculation = true; 
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipInitializePurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an existing purchase table should be used instead of initializing a new one.
    /// </summary>
    /// <returns>true if an existing purchase table should be used; false, otherwise.</returns>
    protected boolean skipInitializePurchTable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVend</Name>
				<Source><![CDATA[
    void setVend()
    {
        if (this.vendAccount())
        {
            vendTable = VendTable::find(this.vendAccount());
        }

        if (!vendTable)
        {
            checkFailed(strFmt("@SYS17184",this.vendAccount()));
            throw error("@SYS23020");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferDeliveryAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the delivery address from the sales line to the purchase line.
    /// </summary>
    /// <param name = "_purchLine">A <c>PurchLine</c> instance.</param>
    protected void transferDeliveryAddress(PurchLine _purchLine)
    {
        if (transferAddress && !transferAddressFromAgreement)
        {
            _purchLine.DeliveryName          = salesLine.DeliveryName;
            _purchLine.DeliveryPostalAddress = salesLine.DeliveryPostalAddress;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendAccount</Name>
				<Source><![CDATA[
    VendAccount vendAccount()
    {
        select firstonly tmpPurchLinePrice;

        return tmpPurchLinePrice.AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>PurchAutoCreate_Sales</c> instance based on the given parameters.
    /// </summary>
    /// <param name = "_tmpPurchLinePrice">
    /// A <c>TmpPurchLinePrice</c> record.
    /// </param>
    /// <param name = "_purchCreateFromSalesOrder">
    /// A <c>PurchCreateFromSalesOrder</c> object.
    /// </param>
    /// <returns>
    /// A <c>PurchAutoCreate_Sales</c> instance.
    /// </returns>
    protected static PurchAutoCreate_Sales newFromParm(TmpPurchLinePrice _tmpPurchLinePrice,
                                                       PurchCreateFromSalesOrder _purchCreateFromSalesOrder)
    {
        switch (_purchCreateFromSalesOrder.parmCallerRecord().TableId)
        {
            case tableNum(SalesTable):
                if (_purchCreateFromSalesOrder.parmSalesTable().ProjId
                    && _purchCreateFromSalesOrder.parmSalesTable().SalesType == SalesType::ItemReq)
                {
                    return PurchAutoCreate_SalesProjectItemReq::newFromParm(_tmpPurchLinePrice, _purchCreateFromSalesOrder);
                }
                else
                {
                    return new PurchAutoCreate_Sales(_tmpPurchLinePrice,_purchCreateFromSalesOrder);
                }

            case tableNum(PurchTable):
                return new PurchAutoCreate_Sales(_tmpPurchLinePrice,_purchCreateFromSalesOrder);

            case tableNum(SalesLine):
                return new PurchAutoCreate_SalesLine(_tmpPurchLinePrice,_purchCreateFromSalesOrder);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>PurchAutoCreate_Sales</c> instance based on the given parameters.
    /// </summary>
    /// <param name = "_tmpPurchLinePrice">
    /// A <c>TmpPurchLinePrice</c> record.
    /// </param>
    /// <param name = "_purchCreateFromSalesOrder">
    /// A <c>PurchCreateFromSalesOrder</c> object.
    /// </param>
    /// <returns>
    /// A <c>PurchAutoCreate_Sales</c> instance.
    /// </returns>
    public static PurchAutoCreate_Sales construct(TmpPurchLinePrice _tmpPurchLinePrice = null,
                                                  PurchCreateFromSalesOrder _purchCreateFromSalesOrder = null)
    {
        PurchAutoCreate_Sales purchAutoCreate_Sales = PurchAutoCreate_Sales::newFromParm(_tmpPurchLinePrice, _purchCreateFromSalesOrder);

        if (!purchAutoCreate_Sales)
        {
            throw error(strFmt("@SYS19306",funcName()));
        }

        return purchAutoCreate_Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingCreateLine_delegate</Name>
				<Source><![CDATA[
    delegate void kittingCreateLine_delegate(PurchLine _purchLine, SalesLine _salesLine)
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>