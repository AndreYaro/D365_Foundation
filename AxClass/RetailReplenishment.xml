<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailReplenishment</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailReplenishment</c> class sets the parameters for the replenishment
/// and calculates the quantity to distribute.
/// </summary>
class RetailReplenishment extends RunBase
{
    RetailBuyersPushTable       buyersPush;
    Qty                         m_rQtyToDistribute;
    InventLocation              m_tInventLocation;
    RetailReplenishmentType     replenishmentType;

    int                         m_iNumberOfLines;
    real                        m_rQtyInSelectedLines;
    Percent                     m_rPercentToDistribute;
    date                        m_ValidToDate;
    boolean                     m_RespectAssortments;

    QueryRun                    m_oLineQry;
    RetailTmpInventLocation     tWarehouses;
    int                         locationsCount;
    str                         filter;

    real                        rTotalWeight;
    boolean                     rWeightOverwritten, rebuildRulePercentNeed;

    Map                         overwriteWeightPerReplenishmentLines;
    Map                         defaultGroupWeightPerReplenishmentLines;
    Map                         bUseLocationsPerReplenishmentLines;

    CommerceHQEventSource       eventSource = CommerceHQEventSource::Log;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcPercentageToDistribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the percentage of quantity to distribute.
    /// </summary>
    void calcPercentageToDistribute()
    {
        if (m_rQtyInSelectedLines == 0)
        {
            eventSource.EventWriteReplenishmentZeroQuantityInSelectedLines(funcName());
        }

        if (m_rQtyToDistribute && m_rQtyInSelectedLines)
        {
            m_rPercentToDistribute = (m_rQtyToDistribute / m_rQtyInSelectedLines) * 100;
        }
        else
        {
            m_rPercentToDistribute = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRulePercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculate RulePercent base on the infomation collected in preCalcRulePercent() method.
    /// </summary>
    /// <param name="_tReplenishmentLines">
    /// Current RetailReplenishmentRuleLines line.
    /// </param>
    /// <returns>
    /// Return the RetailPercent after adjustment.
    /// </returns>
    private RetailPercent calcRulePercent(RetailReplenishmentRuleLines _tReplenishmentLines)
    {
        RetailPercent rulePercent;

        if (rWeightOverwritten)
        {
            if (rebuildRulePercentNeed)
            {
                if (overwriteWeightPerReplenishmentLines.exists(_tReplenishmentLines.RecId))
                {
                    rulePercent = overwriteWeightPerReplenishmentLines.lookup(_tReplenishmentLines.RecId) / rTotalWeight * 100;
                }
                else
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }
            }
            else
            {
                rulePercent = _tReplenishmentLines.QtyPercent;
            }
        }
        else
        {
            if (rebuildRulePercentNeed)
            {
                if (defaultGroupWeightPerReplenishmentLines.exists(_tReplenishmentLines.RecId))
                {
                    rulePercent = defaultGroupWeightPerReplenishmentLines.lookup(_tReplenishmentLines.RecId) / rTotalWeight * 100;
                }
                else
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }
            }
            else
            {
                rulePercent = _tReplenishmentLines.DefaultPercent;
            }
        }

        return rulePercent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the temp table with locations with HierarchyId or LocationId and calculates the percentage.
    /// </summary>
    void calcTotals()
    {
        this.queryUpdate();
        this.locationsUpdate();
        this.calSelectedLinesQty();
        this.calcPercentageToDistribute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calSelectedLinesQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the receiving quantity.
    /// </summary>
    void calSelectedLinesQty()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>countNumberOfSelectedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of lines for the Purchase order.
    /// </summary>
    void countNumberOfSelectedLines()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set quantity to 0 for all lines of the current buyers push.
    /// </summary>
    void deleteForAll()
    {
        RetailBuyersPushLineQty     tfshBuyersPushLineQty;

        // set quantity to 0 for all lines of the current buyers push
        tfshBuyersPushLineQty.skipDataMethods(true);

        update_recordset tfshBuyersPushLineQty
            setting Qty = 0
            where tfshBuyersPushLineQty.BuyersPushId == this.parmBuyersPush().BuyersPushId;

        eventSource.EventWriteReplenishmentBuyersPushQuantityCleared(funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedForAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fixed for all distribution.
    /// </summary>
    void fixedForAll()
    {
        eventSource.EventWriteReplenishmentFixedForAllDistribution(funcName());

        this.weightDistribution(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBuyersPushLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects the record in <c>RetailBuyersPushLine</c> table based on the instance of the record passed as the parameter.
    /// </summary>
    /// <param name="_common">
    /// The instance of a table.
    /// </param>
    /// <returns>
    /// An instance of the table <c>RetailBuyersPushLine</c>.
    /// </returns>
    RetailBuyersPushLine getBuyersPushLine(Common _common)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Item number.
    /// </summary>
    /// <param name="_tCommon">
    /// An instance of <c>PurchLine</c> table.
    /// </param>
    /// <returns>
    /// Reference number for the item.
    /// </returns>
    ItemId getItem(Common    _tCommon)
    {
        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the instance of <c>PurchLine</c> table and finds the record of <c>PurchTable</c> table.
    /// </summary>
    /// <param name="_tCommon">
    /// An instance of <c>PurchLine</c> table.
    /// </param>
    /// <returns>
    /// Returns the <c>PurchTable</c> value.
    /// </returns>
    PurchTable getPurchTable(Common _tCommon)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity based on "ReceiveNow" parameter.
    /// </summary>
    /// <param name="_tCommon">
    /// An instance of a table.
    /// </param>
    /// <returns>
    /// Received quantity if "RecieveNow" is set; else remaining quantity.
    /// </returns>
    Qty getQty(Common    _tCommon)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssortmentAvailable</Name>
				<Source><![CDATA[
    private boolean isAssortmentAvailable(RetailBuyersPushLine _retailBuyersPushLine, InventLocationId _inventLocationId, DataAreaId _inventLocationDataAreaId = curext(), date validToDate = m_ValidToDate)
    {
        return _retailBuyersPushLine.isAssortedTo(_inventLocationId, _inventLocationDataAreaId, validToDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadWarehousesPerReplenishmentRuleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Load warehouses information per each replenishment line.
    /// </summary>
    /// <param name="_retailReplenishmentRuleType">
    /// Rule type of current replenishment line.
    /// </param>
    /// <param name="_relationId">
    /// Relation id to RetailStoretable.
    /// </param>
    /// <returns>
    /// Return the numbers of warehouses per current replenishment line.
    /// </returns>
    private Counter loadWarehousesPerReplenishmentRuleLine(RetailReplenishmentRuleType _retailReplenishmentRuleType, RefRecId _relationId)
    {
        RetailBuyersPushLineQty tRetailBuyersPushLineQty;
        InventLocation          inventLocation;
        RetailStoreTable        tStoreTable;
        Counter                 iNumOfLocations;

        delete_from tWarehouses;

        if (_retailReplenishmentRuleType == RetailReplenishmentRuleType::GroupType)
        {
            // get list of available warehouses for the replenishment hierarchy, save it to temp table and also get the number of warehouses
            iNumOfLocations = RetailReplenishmentHierarchy::getWarehousesList(_relationId, tWarehouses, this.parmBuyersPush().buyersPushId);
        }
        else
        {
            // if filter by store, determine the store specified, check if it's associated with the current buyer's push and populate temp table with this store
            select crossCompany RecId, inventLocation from tStoreTable
                join InventLocationId, FSHStore, dataAreaId, RetailWeightEx1, InventSiteId from inventLocation
                where tStoreTable.RecId == _relationId &&
                        inventLocation.InventLocationId == tStoreTable.inventLocation &&
                        inventLocation.dataAreaId == tStoreTable.inventLocationDataAreaId &&
                        inventLocation.FSHStore == NoYes::Yes;

            if (inventLocation.RecId > 0)
            {
                select buyersPushId, InventLocationId, WarehouseDataAreaId, RecId from tRetailBuyersPushLineQty
                    where tRetailBuyersPushLineQty.BuyersPushId == this.parmBuyersPush().BuyersPushId &&
                            tRetailBuyersPushLineQty.InventLocationId == inventLocation.InventLocationId &&
                            tRetailBuyersPushLineQty.WarehouseDataAreaId == inventLocation.dataAreaId;

                if (tRetailBuyersPushLineQty.RecId > 0)
                {
                    tWarehouses.InventLocationId = inventLocation.InventLocationId;
                    tWarehouses.InventLocationDataAreaId = inventLocation.dataAreaId;
                    tWarehouses.RetailWeightEx1 = inventLocation.RetailWeightEx1;
                    tWarehouses.InventSiteId = inventLocation.InventSiteId;
                    tWarehouses.insert();
                    iNumOfLocations = 1;
                }
            }
            else
            {
                iNumOfLocations = 0;
            }
        }

        return iNumOfLocations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locationsUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the temp locations table according to hierarchy and location filters.
    /// </summary>
    private void locationsUpdate()
    {
        InventLocation          inventLocation;
        RetailBuyersPushLineQty retailBuyersPushLineQty;
        RecId                   hierarchyNodeId = this.parmBuyersPush().ReplenishmentHierarchyNode;

        delete_from tWarehouses;
        locationsCount = 0;

        if (hierarchyNodeId)
        {
            // getWarehousesList returns the number of the warehouses found in the hierarchy specified for the current buyer's push
            locationsCount = RetailReplenishmentHierarchy::getWarehousesList(hierarchyNodeId, tWarehouses, this.parmBuyersPush().BuyersPushId);
        }
        else if (m_tInventLocation)
        {
            // if filter by store, determine the store specified and populate temp table with this store
            if (m_tInventLocation.RecId > 0)
            {
                // add warehouse only in case it has been added to the current buyer's push
                select crossCompany RetailBuyersPushLineQty
                    where RetailBuyersPushLineQty.BuyersPushId == this.parmBuyersPush().BuyersPushId &&
                          RetailBuyersPushLineQty.InventLocationId == m_tInventLocation.InventLocationId &&
                          RetailBuyersPushLineQty.WarehouseDataAreaId == m_tInventLocation.dataAreaId;

                if (RetailBuyersPushLineQty.RecId > 0)
                {
                    tWarehouses.clear();
                    tWarehouses.InventLocationId = m_tInventLocation.InventLocationId;
                    tWarehouses.InventLocationDataAreaId = m_tInventLocation.dataAreaId;
                    tWarehouses.RetailWeightEx1 = m_tInventLocation.RetailWeightEx1;
                    tWarehouses.InventSiteId = m_tInventLocation.InventSiteId;
                    tWarehouses.insert();

                    locationsCount = 1;
                }
                else
                {
                    locationsCount = 0;
                }
            }
        }
        else
        {
            // if there is no filter, fill temp table with all warehouses used in the current buyer's push
            while select crossCompany BuyersPushId, InventLocationId, WarehouseDataAreaId from RetailBuyersPushLineQty
                    group by InventLocationId, WarehouseDataAreaId
                    where RetailBuyersPushLineQty.BuyersPushId == this.parmBuyersPush().BuyersPushId
            {
                while select crossCompany InventLocationId, FSHStore, dataAreaId, RetailWeightEx1, InventSiteId from inventLocation
                    where inventLocation.FSHStore == NoYes::Yes &&
                          inventLocation.InventLocationId == RetailBuyersPushLineQty.InventLocationId &&
                          inventLocation.dataAreaId == RetailBuyersPushLineQty.WarehouseDataAreaId
                {
                    tWarehouses.clear();
                    tWarehouses.InventLocationId = inventLocation.InventLocationId;
                    tWarehouses.InventLocationDataAreaId = inventLocation.dataAreaId;
                    tWarehouses.RetailWeightEx1 = inventLocation.RetailWeightEx1;
                    tWarehouses.InventSiteId = inventLocation.InventSiteId;
                    tWarehouses.insert();

                    locationsCount++;
                }
            }
        }

        if (locationsCount == 0)
        {
            eventSource.EventWriteReplenishmentNoLocationsSelected(funcName());
        }
        else
        {
            eventSource.EventWriteReplenishmentLocationsUpdated(funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>locationWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the remaining quantity and location weight.
    /// </summary>
    void locationWeight()
    {
        eventSource.EventWriteReplenishmentLocationWeightDistribution(funcName());

        this.weightDistribution(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        m_RespectAssortments = false; // default
        m_ValidToDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());  // default for 1 day

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Number of lines in the replenishment.
    /// </summary>
    /// <returns>
    /// Number of lines in the replenishment.
    /// </returns>
    int numberOfLines()
    {
        return m_iNumberOfLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container ret;

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBuyersPush</Name>
				<Source><![CDATA[
    public RetailBuyersPushTable parmBuyersPush(RetailBuyersPushTable _buyersPush = buyersPush)
    {
        buyersPush = _buyersPush;

        return buyersPush;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBuyersPushLineFilter</Name>
				<Source><![CDATA[
    public str parmBuyersPushLineFilter(str _filter = "")
    {
        if (!prmisdefault(_filter))
        {
            filter = _filter;
        }

        return filter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQtyInSelectedLines</Name>
				<Source><![CDATA[
    public real parmQtyInSelectedLines(real _rQtyInSelectedLines = 0)
    {
        if (!prmisdefault(_rQtyInSelectedLines))
        {
            m_rQtyInSelectedLines = _rQtyInSelectedLines;
        }

        return m_rQtyInSelectedLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQtyToDistribute</Name>
				<Source><![CDATA[
    public Qty parmQtyToDistribute(Qty _rQtyToDistribute = 0)
    {
        if (!prmisdefault(_rQtyToDistribute))
        {
            m_rQtyToDistribute = _rQtyToDistribute;
        }

        return m_rQtyToDistribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percentToDistribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Percent to distribute the replenishment quantity.
    /// </summary>
    /// <returns>
    /// Percent to distribute the replenishment quantity.
    /// </returns>
    Percent percentToDistribute()
    {
        return m_rPercentToDistribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCalcRulePercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the rule percent need adjust if there exist overwritten weight or weight out of assortment.
    /// </summary>
    /// <param name="_tfshBuyersPushLine">
    /// Current RetailBuyersPushLine line.
    /// </param>
    /// <param name="_sReplenishmentRuleId">
    /// Current Replenishment rule id.
    /// </param>
    private void preCalcRulePercent(RetailBuyersPushLine _tfshBuyersPushLine, RetailReplenishmentRuleId _sReplenishmentRuleId)
    {
        RetailReplenishmentRuleLines   tReplenishmentLines;

        boolean   bUseLocations, locationGetsDistribution;
        Counter   iNumOfLocations;
        real      rGroupWeight;
        InventDim inventDim;

        overwriteWeightPerReplenishmentLines    = new Map(Types::Int64, Types::Real);
        defaultGroupWeightPerReplenishmentLines = new Map(Types::Int64, Types::Real);
        bUseLocationsPerReplenishmentLines      = new Map(Types::Int64, Types::Real);

        inventDim = InventDim::find(_tfshBuyersPushLine.InventDimId);

        // Check if the weight had been overwritten.
        rWeightOverwritten = false;
        select sum(QtyWeight) from tReplenishmentLines
            where tReplenishmentLines.RuleId == _sReplenishmentRuleId;

        rTotalWeight = 0;
        if (tReplenishmentLines.QtyWeight)
        {
            // Record the total overwritted weight.
            rTotalWeight       = tReplenishmentLines.QtyWeight;
            rWeightOverwritten = true;
        }

        rebuildRulePercentNeed = false;

        // Check if there exist warehouse out of the current assortment, and adjust the rulePercent if exist.
        while select * from tReplenishmentLines
            where tReplenishmentLines.RuleId == _sReplenishmentRuleId
        {
            iNumOfLocations = this.loadWarehousesPerReplenishmentRuleLine(tReplenishmentLines.Type, tReplenishmentLines.RelationId);

            bUseLocations = false;
            rGroupWeight  = 0;

            if (iNumOfLocations > 0)
            {
                while select tWarehouses
                {
                    locationGetsDistribution =
                        (tWarehouses.InventLocationId != inventDim.InventLocationId || tWarehouses.InventLocationDataAreaId != inventDim.dataAreaId) &&
                        (!m_RespectAssortments  ||
                        this.isAssortmentAvailable(_tfshBuyersPushLine, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId));

                    if (locationGetsDistribution)
                    {
                        rGroupWeight += tWarehouses.RetailWeightEx1;

                        if (tWarehouses.RetailWeightEx1)
                        {
                            bUseLocations = true;
                        }
                    }
                    else
                    {
                        // Need to rebuild rule percentage of this replenishment line if there exsit any warehouses not in assortment.
                        rebuildRulePercentNeed = true;
                    }
                }
            }
            else
            {
                // Need rebuild rule percentage if the replenishment line have weight but no warehouses for distribution.
                rebuildRulePercentNeed = true;
            }

            defaultGroupWeightPerReplenishmentLines.insert(tReplenishmentLines.RecId, rGroupWeight);
            bUseLocationsPerReplenishmentLines.insert(tReplenishmentLines.RecId, bUseLocations);

            if (rWeightOverwritten)
            {
                if (rGroupWeight > 0)
                {
                    overwriteWeightPerReplenishmentLines.insert(tReplenishmentLines.RecId, tReplenishmentLines.QtyWeight);
                }
                else
                {
                    if (iNumOfLocations == 0)
                    {
                        // Reduce the total overwrite weight cause no locations exist under current replenishment line.
                        rTotalWeight -= tReplenishmentLines.QtyWeight;
                    }

                    overwriteWeightPerReplenishmentLines.insert(tReplenishmentLines.RecId, tReplenishmentLines.QtyWeight);
                }
            }
            else
            {
                // Record the total default weight for all replenishment lines.
                rTotalWeight += rGroupWeight;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query based on the hierarchy and location filters.
    /// </summary>
    protected void queryBuild()
    {
        this.locationsUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the query based on the hierarchy and location filters.
    /// </summary>
    protected void queryUpdate()
    {
        this.locationsUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>replenish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects the type of Distribution for the replenishment.
    /// </summary>
    /// <param name="_respectAssortments">
    /// boolean indicates if assortments should be respected (default is false).
    /// </param>
    void replenish(boolean _respectAssortments = false)
    {
        RetailParameters                       parameters;
        RetailReplAssortmentsCoverageDays      coverageDays;

        ttsbegin;

        m_RespectAssortments = _respectAssortments;

        if (m_RespectAssortments)
        {   // Update m_ValidToDate from parameters
            parameters = RetailParameters::find();

            // Logic to filter by assortments (if required)
            coverageDays = parameters.ReplenishmentAssortmentsCoverageDays;

            // Assortment table uses date (not utcDateTime)

            // We will use today() + coverageDays as we need date, but
            // BP: Use DateTimeUtil::getSystemDateTime instead of systemDateGet or today. The today function uses the date of the machine.
            // The systemDateGet method uses the system date in Microsoft Dynamics AX. Only DateTimeUtil::getSystemDateTime compensates for the
            // time zone of the user.
            m_ValidToDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + coverageDays; // Today to Today + coverageDays

            eventSource.EventWriteReplenishmentAssortmentsRespected(funcName());
        }
        else
        {
            eventSource.EventWriteReplenishmentAssortmentsIgnored(funcName());
        }

        // It was determined best to clear for all when applying rules.
        this.deleteForAll();

        switch (this.parmBuyersPush().DistributionType)
        {
            case RetailDistributionTypeEx1::ReplenishmentRule:
                this.replenishmentRule();
            break;
            case RetailDistributionTypeEx1::LocationWeight:
                this.locationWeight();
            break;
            case RetailDistributionTypeEx1::FixedQty:
                this.fixedForAll();
            break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replenishmentRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity remaining and the quantity per location for the replenishment.
    /// </summary>
    /// <exception cref="Exception::Warning">
    /// Throws warning if replenishment group is missing from the product category or service category.
    /// </exception>
    void replenishmentRule()
    {
        RetailReplenishmentRuleId      sReplenishmentRuleId;
        RetailReplenishmentRuleTable   tReplenishmentTable;
        RetailReplenishmentRuleLines   tReplenishmentLines;

        Common                      tCommon;

        real                        rQtyRemaining;
        real                        rLineQty, rQtyPerLocation, rGroupWeight;
        Counter                     iNumOfLocations;
        boolean                     bUseLocations;
        Integer                     unitDecimals;
        real                        smallestUnit;
        boolean                     locationGetsDistribution;
        RetailBuyersPushLine        tfshBuyersPushLine;
        InventDim                   inventDim;
        RetailPercent               rulePercent;
        boolean                     displayItemRuleWarning = false;

        m_oLineQry.reset();

        eventSource.EventWriteReplenishmentRuleDistribution(funcName());
        while ( m_oLineQry.next() )
        {   // For each item...
            tCommon = m_oLineQry.getNo(1);

            if (filter && !strScan(filter , this.getItem(tCommon), 1, strLen(filter)))
            {
                // Continue if item is not in the filter
                continue;
            }

            // tCommon can be either buyers push line or purch line here
            tfshBuyersPushLine = this.getBuyersPushLine(tCommon);
            inventDim = InventDim::find(tfshBuyersPushLine.InventDimId);
            unitDecimals = UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(this.getItem(tCommon)).inventUnitId()));
            smallestUnit = power(10, -unitDecimals);
            sReplenishmentRuleId = RetailReplenishment::findReplenishmentRule(this.type(), this.getItem(tCommon), this.getPurchTable(tCommon));

            if (!sReplenishmentRuleId)
            {   // No rule exist for this item - skip...
                displayItemRuleWarning = true;
            }
            else
            {   // Process the item in accordance with the rule...
                tReplenishmentTable = RetailReplenishmentRuleTable::find(sReplenishmentRuleId);

                if (tReplenishmentTable.RecId)
                {
                    // Use manual specified quantity to distribute if the it's available on the buyer's push line.
                    // Otherwise, calculate quantity to distribute based on the percentage to distribute.
                    if (tfshBuyersPushLine.UserSpecified == NoYes::Yes)
                    {
                        rLineQty = tfshBuyersPushLine.UserSpecifiedQty;
                    }
                    else
                    {
                        rLineQty = this.getQty(tCommon) * m_rPercentToDistribute / 100;
                    }

                    if (rLineQty <= 0)
                    {
                        continue;
                    }

                    rQtyRemaining = rLineQty;

                    this.preCalcRulePercent(tfshBuyersPushLine, sReplenishmentRuleId);

                    // No more need for distribution if there is no total weight.
                    if (rTotalWeight > 0)
                    {
                        if (tfshBuyersPushLine.UserSpecified != NoYes::Yes)
                        {
                            RetailReplenishment::setBuyersPushLineUserSpecifiedQty(tfshBuyersPushLine.BuyersPushId, tfshBuyersPushLine.LineNum, rLineQty);
                        }
                    }
                    else
                    {
                        RetailReplenishment::setBuyersPushLineUserSpecifiedQty(tfshBuyersPushLine.BuyersPushId, tfshBuyersPushLine.LineNum, 0);
                        continue;
                    }

                    while select * from tReplenishmentLines
                        where tReplenishmentTable.RuleId == tReplenishmentLines.RuleId
                    {
                        iNumOfLocations = this.loadWarehousesPerReplenishmentRuleLine(tReplenishmentLines.Type, tReplenishmentLines.RelationId);

                        // Recalculate rule percent base on the weight overwriten and weight out of assortment situations.
                        rulePercent = this.calcRulePercent(tReplenishmentLines);

                        if (iNumOfLocations > 0)
                        {
                            if (defaultGroupWeightPerReplenishmentLines.exists(tReplenishmentLines.RecId))
                            {
                                rGroupWeight = defaultGroupWeightPerReplenishmentLines.lookup(tReplenishmentLines.RecId);
                            }
                            else
                            {
                                throw error(Error::wrongUseOfFunction(funcName()));
                            }

                            if (bUseLocationsPerReplenishmentLines.exists(tReplenishmentLines.RecId))
                            {
                                bUseLocations = bUseLocationsPerReplenishmentLines.lookup(tReplenishmentLines.RecId);
                            }
                            else
                            {
                                throw error(Error::wrongUseOfFunction(funcName()));
                            }

                            while select tWarehouses
                            {
                                if (rQtyRemaining < smallestUnit)
                                {
                                    break;
                                }

                                locationGetsDistribution =
                                    (tWarehouses.InventLocationId != inventDim.InventLocationId || tWarehouses.InventLocationDataAreaId != inventDim.dataAreaId) &&
                                    (!m_RespectAssortments  ||
                                    this.isAssortmentAvailable(tfshBuyersPushLine, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId));

                                if (locationGetsDistribution)
                                {
                                    if (bUseLocations)
                                    {
                                        rQtyPerLocation = roundZeroDec(rLineQty * tWarehouses.RetailWeightEx1 / rGroupWeight * rulePercent / 100,
                                                                       UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(this.getItem(tCommon)).inventUnitId())));
                                    }
                                    else
                                    {
                                        // For the case warehouses exist location need distribution but didn't exist weight.
                                        rQtyPerLocation = roundZeroDec(rLineQty / iNumOfLocations * rulePercent / 100,
                                                                       UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(this.getItem(tCommon)).inventUnitId())));
                                    }

                                    if (rQtyPerLocation > rQtyRemaining)
                                    {
                                        rQtyPerLocation = rQtyRemaining;
                                    }

                                    this.setLineQty(tCommon,
                                                    tWarehouses.InventLocationId,
                                                    tWarehouses.InventLocationDataAreaId,
                                                    rQtyPerLocation,
                                                    true);

                                    rQtyRemaining = rQtyRemaining - rQtyPerLocation;
                                }
                            }
                        }
                    }

                    if (rQtyRemaining > 0)
                    {   // Rounding...
                        eventSource.EventWriteReplenishmentRoundingForRemainedItems(funcName(), num2Str(rQtyRemaining, 0, 2, 1, 0));
                        while select * from tReplenishmentLines
                            where tReplenishmentTable.RuleId == tReplenishmentLines.RuleId
                               && rQtyRemaining > 0
                        {
                            iNumOfLocations = this.loadWarehousesPerReplenishmentRuleLine(tReplenishmentLines.Type, tReplenishmentLines.RelationId);

                            while select tWarehouses
                            {
                                if (rQtyRemaining < smallestUnit)
                                {
                                    break;
                                }

                                locationGetsDistribution =
                                    (tWarehouses.InventLocationId != inventDim.InventLocationId || tWarehouses.InventLocationDataAreaId != inventDim.dataAreaId) &&
                                    (!m_RespectAssortments  ||
                                    this.isAssortmentAvailable(tfshBuyersPushLine, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId));

                                if (locationGetsDistribution)
                                {
                                    if (rQtyRemaining >= 1)
                                    {
                                        this.setLineQty(tCommon,
                                                        tWarehouses.InventLocationId,
                                                        tWarehouses.InventLocationDataAreaId,
                                                        1,
                                                        true);

                                        rQtyRemaining = rQtyRemaining - 1;
                                    }
                                    else
                                    {
                                        this.setLineQty(tCommon,
                                                        tWarehouses.InventLocationId,
                                                        tWarehouses.InventLocationDataAreaId,
                                                        roundZeroDec(rQtyRemaining, UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(this.getItem(tCommon)).inventUnitId()))),
                                                        true);

                                        rQtyRemaining = 0;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {   // Infolog("Replenishment Rule {0} is Invalid", sReplenishmentRuleId)
                    eventSource.EventWriteReplenishmentInvalidRule(funcName(), sReplenishmentRuleId);
                    warning(strFmt("@RET260917", sReplenishmentRuleId));
                }

                progress.incCount();
            }
        }

        if (displayItemRuleWarning)
        {   // Display a warning after all processing is done
            eventSource.EventWriteReplenishmentNoRuleFound(funcName());
            warning("@RET793");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the value of the quantity in the replenishment buyers push line.
    /// </summary>
    /// <param name="_tCommon">
    /// The table instance.
    /// </param>
    /// <param name="_sInventLocationId">
    /// The given value for location Id.
    /// </param>
    /// <param name="_sInventLocationDataAreaId">
    /// The given value for location data area id.
    /// </param>
    /// <param name="_rQty">
    /// The current value for quantity.
    /// </param>
    /// <param name="_bUpdate">
    /// Boolean value to indicate if the record can be updated.
    /// </param>
    /// <remarks>
    /// Original signature included an unused _sInventSiteId parameter, which was removed in AX 2012 R3.
    /// </remarks>
    void setLineQty(Common              _tCommon,
                    InventLocationId    _sInventLocationId,
                    DataAreaId          _sInventLocationDataAreaId,
                    Qty                 _rQty,
                    boolean             _bUpdate = false)
    {
        RetailBuyersPushLine       tfshBuyersPushLine;
        RetailBuyersPushLineQty    tfshBuyersPushLineQty;

        tfshBuyersPushLine = this.getBuyersPushLine(_tCommon);

        ttsbegin;

        select forupdate crossCompany * from tfshBuyersPushLineQty
            where tfshBuyersPushLineQty.BuyersPushId        == tfshBuyersPushLine.BuyersPushId
               && tfshBuyersPushLineQty.LineNum             == tfshBuyersPushLine.LineNum
               && tfshBuyersPushLineQty.InventLocationId    == _sInventLocationId
               && tfshBuyersPushLineQty.WarehouseDataAreaId == _sInventLocationDataAreaId;

        if (tfshBuyersPushLineQty.RecId)
        {   // NOTE: A record should always be found...
            if (_bUpdate)
            {
                tfshBuyersPushLineQty.Qty +=  _rQty;
            }
            else
            {
                tfshBuyersPushLineQty.Qty =  _rQty;
            }

            tfshBuyersPushLineQty.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>storeFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value for the invent location.
    /// </summary>
    /// <param name="_inventLocation">
    /// The given value for invent location.
    /// </param>
    /// <returns>
    /// Assigned value of invent location
    /// </returns>
    InventLocation storeFilter(InventLocation _inventLocation = m_tInventLocation)
    {
        m_tInventLocation = _inventLocation;

        return m_tInventLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the replenishment type (buyers push or cross docking) of the current replenishment object.
    /// </summary>
    /// <returns>
    /// The replenishment type of the current replenishment object.
    /// </returns>
    /// <remarks>
    /// The method should be called only from inherited classes.
    /// </remarks>
    public RetailReplenishmentType type()
    {
        throw error("@RET4160569");
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean ret;

        ret = super(packedClass);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the distribution quantity and available quantity.
    /// </summary>
    /// <returns>
    /// false if distribution quantity is greater than available quantity.
    /// </returns>
    boolean validateQty()
    {
        boolean     ret = true;

        if ( this.parmQtyToDistribute() >  this.parmQtyInSelectedLines() )
        {
            ret = checkFailed("@RET794");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>weightDistribution</Name>
				<Source><![CDATA[
    private void weightDistribution(boolean _useWeight)
    {
        Common                  tCommon;
        real                    rQtyRemaining;
        real                    rLineQty, rLocationWeight, rQtyLocation;
        Integer                 unitDecimals;
        real                    smallestUnit;
        boolean                 locationGetsDistribution;
        RetailBuyersPushLine    tfshBuyersPushLine;
        InventDim               inventDim;
        real                    totalQtyRemaining = this.parmQtyToDistribute();

        m_oLineQry.reset();
        while (m_oLineQry.next()) // Iterate through each line (product)
        {
            tCommon         = m_oLineQry.getNo(1);
            unitDecimals    = UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(this.getItem(tCommon)).inventUnitId()));
            smallestUnit    = power(10, -unitDecimals);
            // tCommon can be either buyers push line or purch line here
            tfshBuyersPushLine = this.getBuyersPushLine(tCommon);

            if (filter && !strScan(filter , tfshBuyersPushLine.ItemId, 1, strLen(filter)))
            {
                // Continue if item is not in the filter
                continue;
            }

            // Use manual specified quantity to distribute if the it's available on the buyer's push line.
            // Otherwise, calculate quantity to distribute based on the percentage to distribute.
            if (tfshBuyersPushLine.UserSpecified == NoYes::Yes)
            {
                rLineQty = tfshBuyersPushLine.UserSpecifiedQty;
            }
            else
            {
                rLineQty = this.getQty(tCommon) * m_rPercentToDistribute / 100;
            }

            if (rLineQty <= 0)
            {
                continue;
            }

            rQtyRemaining = rLineQty;

            inventDim = InventDim::find(tfshBuyersPushLine.InventDimId);

            // Compute TotalWeight (because of assortments it must be done for each m_oLineQry instead of just one time
            rTotalWeight = 0;
            while select tWarehouses
            {
                locationGetsDistribution =
                    (tWarehouses.InventLocationId != inventDim.InventLocationId || tWarehouses.InventLocationDataAreaId != inventDim.dataAreaId) &&
                    (!m_RespectAssortments  ||
                    this.isAssortmentAvailable(tfshBuyersPushLine, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId));

                if (locationGetsDistribution)
                {
                    if (!_useWeight)
                    {
                        // if we don't want to use weights, and locations should get equal quantity of items, set all weight to 1
                        rTotalWeight += 1;
                    }
                    else
                    {
                        rTotalWeight += tWarehouses.RetailWeightEx1;
                    }
                }
            }

            // No more need for distribution if there is no total weight
            if (rTotalWeight > 0)
            {
                if (tfshBuyersPushLine.UserSpecified != NoYes::Yes)
                {
                    RetailReplenishment::setBuyersPushLineUserSpecifiedQty(tfshBuyersPushLine.BuyersPushId, tfshBuyersPushLine.LineNum, rLineQty);
                }
            }
            else
            {
                RetailReplenishment::setBuyersPushLineUserSpecifiedQty(tfshBuyersPushLine.BuyersPushId, tfshBuyersPushLine.LineNum, 0);
                continue;
            }

            // Set the quantity for each item
            while select tWarehouses
            {
                locationGetsDistribution =
                    (tWarehouses.InventLocationId != inventDim.InventLocationId || tWarehouses.InventLocationDataAreaId != inventDim.dataAreaId) &&
                    (!m_RespectAssortments  ||
                    this.isAssortmentAvailable(tfshBuyersPushLine, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId));

                if (locationGetsDistribution)
                {
                    if (!_useWeight)
                    {
                        rLocationWeight = 1;
                    }
                    else
                    {
                        rLocationWeight = tWarehouses.RetailWeightEx1;
                    }

                    rQtyLocation =  roundZeroDec((rLineQty * rLocationWeight / rTotalWeight), UnitOfMeasure::find(UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(this.getItem(tCommon)).inventUnitId())).DecimalPrecision);
                }
                else
                {
                    rQtyLocation = 0;
                }

                if (rQtyLocation > rQtyRemaining)
                {
                    rQtyLocation = rQtyRemaining;
                }

                rQtyRemaining = rQtyRemaining - rQtyLocation;

                if (rQtyLocation)
                {
                    this.setLineQty(tCommon, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId, rQtyLocation);
                }

                // this is to check how many items will be remained after distribution for all lines is made
                totalQtyRemaining -= rQtyLocation;
            }

            if (rQtyRemaining > 0)
            {   // Adjust for any remaining (due to rounding, etc)...

                eventSource.EventWriteReplenishmentAdjustmentForRemainingQuantity(funcName(), num2Str(rQtyRemaining, 0, 2, 1, 0));

                while select tWarehouses
                {   // adjust until no more remaining qty

                    if (rQtyRemaining < smallestUnit)
                    {   // Qty is smaller that the smallest unit... Stop.
                        break;
                    }

                    locationGetsDistribution =
                        (tWarehouses.InventLocationId != inventDim.InventLocationId || tWarehouses.InventLocationDataAreaId != inventDim.dataAreaId) &&
                        (!m_RespectAssortments  ||
                        this.isAssortmentAvailable(tfshBuyersPushLine, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId));

                    if (locationGetsDistribution)
                    {   // Distribution applies...

                        switch (this.parmBuyersPush().DistributionType)
                        {
                            case RetailDistributionTypeEx1::LocationWeight:
                                // Location Weight based distrubiton...

                                if (tWarehouses.RetailWeightEx1 != 0)
                                {   // Only adjust for warehouses that have a weight...
                                    if (rQtyRemaining >= 1)
                                    {   // Maximum adjustment
                                        this.setLineQty(tCommon, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId, 1, true);
                                        rQtyRemaining = rQtyRemaining - 1;
                                    }
                                    else
                                    {   // Adjust the remaining balance...
                                        // Rounded to the smallest unit
                                        this.setLineQty(tCommon, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId, round(rQtyRemaining, smallestUnit), true);
                                        rQtyRemaining = 0;
                                    }
                                }
                                break;
                            case RetailDistributionTypeEx1::FixedQty:
                                this.setLineQty(tCommon, tWarehouses.InventLocationId, tWarehouses.InventLocationDataAreaId, smallestUnit, true);
                                rQtyRemaining = rQtyRemaining - smallestUnit;
                                break;
                            default:
                                break;
                        }
                    }
                }
            }

            progress.incCount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialises the <c>RetailReplenishmentBuyersPush</c> class.
    /// </summary>
    /// <param name="_eType">
    /// The type of replenishment.
    /// </param>
    /// <param name="_rQtyToDistribute">
    /// The value for the quantity to be distributed.
    /// </param>
    /// <param name="_buyersPush">
    /// Buyers push table buffer variable.
    /// </param>
    /// <param name="_purchLine">
    /// An instance of <c>PurchLine</c> table.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailReplenishment</c> class.
    /// </returns>
    /// <remarks>
    /// Earlier distribution type hierarchy and location filter should be passed to this method as inputs.
    /// Now those parameters are the part of buyers push table,
    /// so we just need to pass RetailBuyersPushTable buffer variable that contain all the necessary information about distribution.
    /// </remarks>
    static RetailReplenishment construct(RetailReplenishmentType    _eType,
                                         Qty                        _rQtyToDistribute,
                                         RetailBuyersPushTable      _buyersPush,
                                         Common                     _purchLine)
    {
        RetailReplenishment        ofshReplenishment;
        CommerceHQEventSource      eventSource = CommerceHQEventSource::Log;

        switch (_eType)
        {
            case RetailReplenishmentType::BuyersPush:
                ofshReplenishment = new RetailReplenishmentBuyersPush(_rQtyToDistribute, _buyersPush);
                break;
            case RetailReplenishmentType::CrossDocking:
                ofshReplenishment = new RetailReplenishmentCrossDocking(_rQtyToDistribute, _buyersPush, _purchLine);
                break;
            default:
                throw error("@RET4160568");
        }

        ofshReplenishment.queryBuild();

        eventSource.EventWriteReplenishmentObjectCreated(funcName(), _buyersPush.DistributionType);

        return ofshReplenishment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossDockFromPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialises the <c>RetailReplenishmentBuyersPush</c> class and calculates the quantity for distribution.
    /// </summary>
    /// <param name="_tPurchTable">
    /// An instance of <c>PurchTable</c> table.
    /// </param>
    static void crossDockFromPlannedOrder(PurchTable _tPurchTable)
    {
        PurchLine              tPurchLine;
        RetailReplenishment    oReplenishment;
        RetailServiceCategory  tServiceCategory;
        InventLocation         tInventLocation;
        RetailBuyersPushTable  newBuyersPush;
        CommerceHQEventSource  eventSource = CommerceHQEventSource::Log;

        ttsbegin;

        newBuyersPush = RetailReplenishmentCrossDocking::createOrFindPushFromPurch(_tPurchTable);

        select firstonly * from tPurchLine
            index hint PurchLineIdx
            where tPurchLine.PurchId == _tPurchTable.PurchId;

        tServiceCategory = RetailServiceCategory::find(_tPurchTable.ServiceCategory);

        //If only one location - use location distribution
        tInventLocation = InventLocation::find(_tPurchTable.ReplenishmentLocation);
        newBuyersPush.LocationRecId = tInventLocation.RecId;
        if (tInventLocation.RecId > 0)
        {
            eventSource.EventWriteReplenishmentCreateInstanceWithStoreFilter(funcName(), RetailDistributionTypeEx1::LocationWeight, tInventLocation.InventLocationId);
            newBuyersPush.DistributionType = RetailDistributionTypeEx1::LocationWeight;
            oReplenishment = RetailReplenishment::construct(RetailReplenishmentType::CrossDocking, 0, newBuyersPush, tPurchLine);
        }
        else
        {
            eventSource.EventWriteReplenishmentCreateInstance(funcName(), RetailDistributionTypeEx1::LocationWeight);
            newBuyersPush.DistributionType = RetailDistributionTypeEx1::ReplenishmentRule;
            oReplenishment = RetailReplenishment::construct(RetailReplenishmentType::CrossDocking, 0, newBuyersPush, tPurchLine);
        }

        oReplenishment.locationsUpdate();
        oReplenishment.calSelectedLinesQty();
        oReplenishment.parmQtyToDistribute(oReplenishment.parmQtyInSelectedLines());
        oReplenishment.calcPercentageToDistribute();

        oReplenishment.replenish();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReplenishmentRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Id for the Replenishment.
    /// </summary>
    /// <param name="_type">
    /// Replenishment type (buyers push or cross docking)
    /// </param>
    /// <param name="_sItemId">
    /// Reference number for the Item.
    /// </param>
    /// <param name="_purchTable">
    /// Purchase order related to the replenishment. Optional.
    /// </param>
    /// <returns>
    /// Reference Id for the Replenishment.
    /// </returns>
    public static RetailReplenishmentRuleId findReplenishmentRule(RetailReplenishmentType _type, ItemId _sItemId, PurchTable _purchTable = null)
    {
        RetailReplenishmentRuleId       sReplenishmentRuleId;
        retailCategory                  retailCategoryId;
        RetailServiceCategory           tServiceCategory;
        CommerceHQEventSource           eventSource = CommerceHQEventSource::Log;

        if (_type == RetailReplenishmentType::CrossDocking)
        {
            // if cross docking, first check service category for replenishment rule
            if (_purchTable.ServiceCategory)
            {
                tServiceCategory = RetailServiceCategory::find(_purchTable.ServiceCategory);
            }

            if (tServiceCategory.ReplenishmentRuleId)
            {
                eventSource.EventWriteReplenishmentRuleTakenFromServiceCategory(funcName());
                
                return tServiceCategory.ReplenishmentRuleId;
            }
        }

        // search for the rule in the product category hierarchy
        // first, find the current category of the product
        retailCategoryId = EcoResCategory::find(
                                EcoResProductCategory::findByItemIdCategoryHierarchyRole(_sItemId, EcoResCategoryNamedHierarchyRole::Retail)
                                .Category)
                           .RecId;
        while (retailCategoryId > 0)
        {
            sReplenishmentRuleId = RetailAttributesLegalEntityLookup::findByCategory(retailCategoryId, CompanyInfo::findDataArea(curext()).RecId).ReplenishmentRule;
            // if current hierarchy node contains replenishment rule, return this rule
            // otherwise, get the parent category and check it
            if (sReplenishmentRuleId)
            {
                eventSource.EventWriteReplenishmentRuleTakenFromProductCategory(funcName(), retailCategoryId);
                return sReplenishmentRuleId;
            }
            else
            {
                retailCategoryId = EcoResCategory::find(retailCategoryId).ParentCategory;
            }
        }

        return sReplenishmentRuleId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBuyersPushLineUserSpecifiedQty</Name>
				<Source><![CDATA[
    private static void setBuyersPushLineUserSpecifiedQty(RetailBuyersPushId _buyersPushId, LineNum _lineNum, RetailUserSpecifiedQty _qty)
    {
        RetailBuyersPushLine buyersPushLine;

        ttsBegin;

        buyersPushLine = RetailBuyersPushLine::find(_buyersPushId, _lineNum, true);

        if (buyersPushLine)
        {
            buyersPushLine.UserSpecified = NoYes::Yes;
            buyersPushLine.UserSpecifiedQty = _qty;
            buyersPushLine.update();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>