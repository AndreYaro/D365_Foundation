<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetReservationPost_PSN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class handles the posting for the budget reservation document. 
/// </summary>
public class BudgetReservationPost_PSN extends RunBase
{
    BudgetReservationHeader_PSN budgetReservationHeader;
    BudgetTransactionCodeRecId  carryForwardBudgetTransactionCodeRecId;
    BudgetReservationLine_PSN   budgetReservationLine;
    BudgetTransactionMultiPost  budgetTransactionMultiPost;
    boolean                     foundAccountWithDisabledBudgetControl;
    Map                         ledgerDimensionsMap;
    RecordInsertList            budgetTransLineInsertList;
    Map                         budgetModelsMap;
    Map                         countBudgetTransLinesMap;
    boolean                     processCarryForwardReduction;
    boolean                     isBudgetResTypeEnabledForCarryForward;
    Map                         ledgerDimBudgetModelsMap;
    Map                         sourceDocumentFullyDistributedLineMap;
    AmountMST                   totalReduction;
    Map                         ledgerDimensionsAmountsToReduce;
    Set                         fundSet;
    AccountingDate              accountingDate;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCarryForwardBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the budget reservation being posted was processed through year-end with
    /// carry-forward and its amount does not increase the carry forward budget.
    /// </summary>
    /// <returns>
    /// true, if the budget reservation being posted was processed through year-end with
    /// carry-forward and its amount does not increase the carry forward budget; otherwise, false.
    /// </returns>
    private boolean checkCarryForwardBudget()
    {
        BudgetReservationLine_PSN budgetReservationLineLocal;
        AccountingDistribution accountingDistribution;
        AccountingEvent accountingEvent;
        boolean isValid = true;
    
        if (BudgetParameters::find().PreventIncreaseToCarryForwardEncumbrance == NoYes::Yes
            && budgetReservationHeader.CarriedForwardBudgetTransactionHeader)
        {
            while select LineAmount, LineNumber, Currency, SourceDocumentLine from budgetReservationLineLocal
                where budgetReservationLineLocal.BudgetReservationHeader_PSN == budgetReservationHeader.RecId
                exists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == budgetReservationLineLocal.SourceDocumentLine
                exists join accountingEvent
                    where accountingEvent.RecId == accountingDistribution.AccountingEvent
                        && (accountingEvent.Type == AccountingEventType::PeriodOpen
                            || accountingEvent.Type == AccountingEventType::Original)

            isValid = isValid && this.checkCarryForwardAmount(budgetReservationLineLocal);

        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCarryForwardAmount</Name>
				<Source><![CDATA[
    private boolean checkCarryForwardAmount(BudgetReservationLine_PSN _budgetReservationLineLocal)
    {
        boolean isValid = true;
        AmountCur carryForwardAmount;

        carryForwardAmount = BudgetEncumbranceCarryForwardBalance_PSN::getCarryforwardAmount(
            _budgetReservationLineLocal.SourceDocumentLine,
            _budgetReservationLineLocal.Currency);
    
        if (!_budgetReservationLineLocal.isLineReferenced()
            && _budgetReservationLineLocal.LineAmount > carryForwardAmount)
        {
            AmountCur differenceAmount;

            // The line amount is greater than the amount carried forward.
            differenceAmount = _budgetReservationLineLocal.LineAmount - carryForwardAmount;
    
            isValid = checkFailed(strFmt("@Budgeting_BudgetReservationPS:BudgetReservationPostingError",
                budgetReservationHeader.DocumentNumber,
                _budgetReservationLineLocal.LineNumber,
                differenceAmount,
                _budgetReservationLineLocal.Currency));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchReqReferenceIsValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a referenced purchase requisition line is valid for posting.
    /// </summary>
    /// <returns>
    /// true if the purchase requisition reference is valid.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An error is thrown if the purchase requisition is not valid for referencing.
    /// </exception>
    private boolean checkPurchReqReferenceIsValid()
    {
        BudgetReservationLine_PSN   budgetReservationLineLocal;
        SourceDocumentLine          sourceDocumentLineLocal;
        boolean                     isPurchReqLineReferenceValid = true;
    
        while select PurchReqLine, RecId from budgetReservationLineLocal
            where budgetReservationLineLocal.BudgetReservationHeader_PSN == budgetReservationHeader.RecId
                && budgetReservationLineLocal.PurchReqLine != 0
        exists join sourceDocumentLineLocal
            where sourceDocumentLineLocal.RecId == budgetReservationLineLocal.SourceDocumentLine
                && sourceDocumentLineLocal.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized
        {
    
            isPurchReqLineReferenceValid = BudgetReservation_PSN::isPurchaseRequisitionAvailableToReference(
                budgetReservationLineLocal.PurchReqLine,
                budgetReservationLineLocal.RecId,
                budgetReservationHeader,
                true,
                "@Budgeting_BudgetReservationPS:BudgetReservationPostClassCannotPostGBRError");
        }
    
        return isPurchReqLineReferenceValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>BudgetTransactionHeader</c> table record for a specified budget model.
    /// </summary>
    /// <param name="_budgetModelId">
    /// The budget model Id of the new budget transaction header record.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date of the new budget transaction header record.
    /// </param>
    /// <returns>
    /// A newly created <c>BudgetTransactionHeader</c> table record Id.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The creation process encountered an error and was not completed. Nothing was transferred.
    /// </exception>
    private RefRecId createBudgetTransactionHeader(
        BudgetModelId   _budgetModelId,
        TransDate       _transDate)
    {
        BudgetTransactionHeader budgetTransactionHeaderCreate;
        NumberSeq               numberSeq;
    
        numberSeq = NumberSeq::newGetNum(BudgetParameters::numRefBudgetTransactionId());
    
        budgetTransactionHeaderCreate.clear();
        budgetTransactionHeaderCreate.initValue();
        budgetTransactionHeaderCreate.editBudgetModel(true, _budgetModelId);
        budgetTransactionHeaderCreate.TransactionNumber = numberSeq.num();
        budgetTransactionHeaderCreate.setBudgetTransactionCode(carryForwardBudgetTransactionCodeRecId);
    
        if (_transDate == dateNull())
        {
            budgetTransactionHeaderCreate.Date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }
        else
        {
            budgetTransactionHeaderCreate.Date = _transDate;
        }
    
        budgetTransactionHeaderCreate.TransactionStatus     = BudgetTransactionStatus::Draft;
        budgetTransactionHeaderCreate.TransferSourceNumber  = budgetReservationHeader.DocumentNumber;
    
        if (budgetTransactionHeaderCreate.validateWrite())
        {
            ttsbegin;
    
            budgetTransactionHeaderCreate.write();
    
            budgetTransactionMultiPost.addBudgetTransactionHeaderToPost(budgetTransactionHeaderCreate.TransactionNumber);
    
            ttscommit;
    
            if (!budgetModelsMap.exists(_budgetModelId) && budgetTransactionHeaderCreate.RecId != 0)
            {
                budgetModelsMap.insert(_budgetModelId, budgetTransactionHeaderCreate.RecId);
            }
        }
        else
        {
            throw error("@SYS131643");
        }
    
        return budgetTransactionHeaderCreate.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a budget transaction line.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date of the new budget transaction line.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account of the new budget transaction line.
    /// </param>
    /// <param name="_lineAmount">
    /// The amount of the new budget transaction line.
    /// </param>
    /// <param name="_currency">
    /// The <c>CurrencyCode</c> value for which to calculate the accounting currency amount.
    /// </param>
    /// <returns>
    /// The <c>BudgetTransactionLine</c> table record.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An error is thrown if the budget transaction line fails validation.
    /// </exception>
    private BudgetTransactionLine createBudgetTransactionLine(
        TransDate               _transDate,
        LedgerDimensionBase     _ledgerAccount,
        AmountMST               _lineAmount,
        CurrencyCode            _currency = Ledger::accountingCurrency())
    {
        BudgetTransactionLine           budgetTransactionLineCreate;
        RefRecId                        budgetTransactionHeaderRecId;
        BudgetReservationLineNumber_PSN countBudgetTransactionLinesCreated;
        BudgetModel                     budgetModel;
        CurrencyCode                    ledgerCurrency = Ledger::accountingCurrency();
    
        budgetModel = this.findBudgetModelByLedgerDimensionAndDate(_ledgerAccount, _transDate);
    
        if (budgetModel.RecId != 0)
        {
            budgetTransactionHeaderRecId = this.findBudgetTransactionHeader(budgetModel.ModelId);
        }
    
        if (budgetTransactionHeaderRecId)
        {
            // Retrieve the exisiting budget transaction header line count.
            if (countBudgetTransLinesMap.exists(budgetTransactionHeaderRecId))
            {
                countBudgetTransactionLinesCreated = countBudgetTransLinesMap.lookup(budgetTransactionHeaderRecId);
            }
        }
        else
        {
            this.getCarryForwardBudgetTransaction();
            // If the budget transaction header is not found, create one and initialize the line count.
            budgetTransactionHeaderRecId = this.createBudgetTransactionHeader(budgetModel.ModelId, _transDate);
            countBudgetTransactionLinesCreated  = 0;
        }
    
        countBudgetTransactionLinesCreated += 1;
        countBudgetTransLinesMap.insert(budgetTransactionHeaderRecId, countBudgetTransactionLinesCreated);
    
        // Initialize the budget transaction line.
        budgetTransactionLineCreate.clear();
        budgetTransactionLineCreate.LineNumber                  = countBudgetTransactionLinesCreated;
        budgetTransactionLineCreate.BudgetTransactionHeader     = budgetTransactionHeaderRecId;
        budgetTransactionLineCreate.Date                        = _transDate;
        budgetTransactionLineCreate.LedgerDimension             = this.findAndUpdateLedgerDimensionBudgetMap(_ledgerAccount);
        budgetTransactionLineCreate.BudgetType                  = BudgetType::Expense;
        budgetTransactionLineCreate.TransactionCurrencyAmount   = -1 * _lineAmount;
        budgetTransactionLineCreate.TransactionCurrency         = _currency;
    
        if (_currency != ledgerCurrency)
        {
            budgetTransactionLineCreate.AccountingCurrencyAmount = BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                                                        budgetTransactionLineCreate.TransactionCurrencyAmount,
                                                                        budgetTransactionLineCreate.TransactionCurrency,
                                                                        budgetTransactionLineCreate.Date);
        }
        else
        {
            budgetTransactionLineCreate.AccountingCurrencyAmount    = budgetTransactionLineCreate.TransactionCurrencyAmount;
        }
    
        if (!(budgetTransactionLineCreate.validateWrite()
            && BudgetTransactionManager::validateLedgerDimension(budgetTransactionLineCreate.LedgerDimension, budgetTransactionLineCreate.Date)))
        {
            throw error("@SYS131643");
        }
    
        return budgetTransactionLineCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>BudgetTransactionLine</c> records.
    /// </summary>
    /// <param name="_budgetDetails">
    /// The <c>BudgetDetails</c> object contains the information for the new <c>BudgetTransactionLine</c> records to be created.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date of the <c>BudgetTransactionLine</c> records to be created.
    /// </param>
    /// <param name="_sourceDocumentLine">
    /// The <c>BudgetDetails</c> object contains the information for the new <c>BudgetTransactionLine</c> records to be created.
    /// </param>
    private void createBudgetTransactionLines(BudgetSourceInquiryDetails    _budgetDetails,
                                                AccountingDate              _accountingDate = DateTimeUtil::date(DateTimeUtil::utcNow()),
                                                SourceDocumentLine          _sourceDocumentLine = null)
    {
        LedgerDimensionBase         ledgerAccount;
        LedgerRecId                 currentLedgerRecId              = Ledger::current();
        LedgerDimensionBudget       ledgerDimensionBudgetId;
        boolean                     isReductionNeededForThisLine    = false;
        AmountCur                   ledgerAccountAmount;
        BudgetReservationLine_PSN   reservationLine;
    
        reservationLine = BudgetReservationLine_PSN::findBySourceDocumentLine(_sourceDocumentLine.RecId);
    
        _budgetDetails.resetCurrent();
    
        while (_budgetDetails.next())
        {
           
            isReductionNeededForThisLine = false;
    
            // Verify the budget control status of the accounts.
            ledgerAccount = _budgetDetails.currentSourceLedgerDimension();
    
            if (isBudgetResTypeEnabledForCarryForward)
            {
                // Reduce carry-forward is enabled for reservation type
                // therfore all lines must create a reduce carry-forward entry.
                isReductionNeededForThisLine = true;
            }
            else
            {
                // Reduce carry-forward is disabled for reservation type,
                // therefore each line's fund needs to be checked against the saved set
                // to determine if carry-forward reduction is needed for the line.
                ledgerDimensionBudgetId = this.findAndUpdateLedgerDimensionBudgetMap(ledgerAccount);
    
                if (this.isFundEnabledForCarryForwardReduction(ledgerDimensionBudgetId)
                    && this.hasReservationLineBeenThroughYearEnd(reservationLine))
                {
                    isReductionNeededForThisLine = true;
                }
            }
    
            if (isReductionNeededForThisLine)
            {
                if (ledgerDimensionsAmountsToReduce.exists(ledgerAccount))
                {
                    ledgerAccountAmount = ledgerDimensionsAmountsToReduce.lookup(ledgerAccount);
    
                    budgetTransLineInsertList.add(
                        this.createBudgetTransactionLine(
                        _accountingDate,
                        ledgerAccount,
                        ledgerAccountAmount,
                        reservationLine.Currency));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasReservationLineBeenThroughYearEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag of year end process for the budget reservation line.
    /// </summary>
    /// <param name = "_reservationLine">The record of the <c>BudgetReservationLine_PSN</c> table.</param>
    /// <returns>True if the budget reservation line needs the year end process; otherwise, false.</returns>
    protected boolean hasReservationLineBeenThroughYearEnd(BudgetReservationLine_PSN _reservationLine)
    {
        return _reservationLine.hasLineBeenThroughYearEnd();
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineAccountCarryFwdReductionAmts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the reduction amounts for the accounts that have reduced amounts.
    /// </summary>
    /// <param name="_budgetReservationLine">
    /// The individual <c>BudgetReservationLine_PSN</c> record to process.
    /// </param>
    private void determineAccountCarryFwdReductionAmts(BudgetReservationLine_PSN _budgetReservationLine)
    {
        AccountingDistribution      accountingDistributionLastEvent;
        AccountingDistribution      accountingDistributionChanged;
        AccountingDistribution      accountingDistributionNoEvent;
        AccountingEvent             accountingEvent;
        boolean                     isFirstTime = true;
        SourceDocumentLine          sourceDocumentLine = SourceDocumentLine::find(_budgetReservationLine.SourceDocumentLine);
        AmountCur                   reductionAmount;
    
        // retrieves the most recent accounting event for a distribution, so we can compare against what has been edited
        accountingEvent = this.getMostRecentAccountingEvent(sourceDocumentLine);
    
        if (accountingEvent.Type == AccountingEventType::PeriodClose
            || accountingEvent.Type == AccountingEventType::Cancel
            || accountingEvent.Type == AccountingEventType::Finalize)
        {
            return;
        }
    
        while select SourceDocumentLine, LedgerDimension, sum(TransactionCurrencyAmount) from accountingDistributionLastEvent
            group by accountingDistributionLastEvent.LedgerDimension, accountingDistributionLastEvent.SourceDocumentLine
            where accountingDistributionLastEvent.SourceDocumentLine        == _budgetReservationLine.SourceDocumentLine
                && accountingDistributionLastEvent.AccountingEvent          == accountingEvent.RecId
                && (accountingDistributionLastEvent.ReferenceDistribution   == 0
                || accountingEvent.Type                                     != AccountingEventType::Correction
                || accountingDistributionLastEvent.ReferenceRole            == AccountingDistributionReferenceRole::Matching)
                && accountingDistributionLastEvent.FinalizeAccountingEvent      == 0
            exists join accountingDistributionNoEvent
                where accountingDistributionNoEvent.AccountingEvent             == 0
                    && accountingDistributionNoEvent.SourceDocumentLine         == accountingDistributionLastEvent.SourceDocumentLine
        {
            //
            // The preceding query processes all the source document line accounting distributions for the most recent accounting event.
            // It filters out reversing correction entries from the accounting distribution table.
            // It also filters out finalized distributions.
            //
            
            if (!this.isFundEnabledForCarryForwardReduction(accountingDistributionLastEvent.LedgerDimension)
                && !isBudgetResTypeEnabledForCarryForward)
            {
                // the reservation type and the fund are both set to not reduce carry forward
                continue;
            }
    
            //
            // retrieves the new accounting distribution, which doesn't have an accounting event yet, and we do not want
            // referenced distributions which are the reversing out of the old entries.
            //
            select firstOnly sum(TransactionCurrencyAmount), LedgerDimension, SourceDocumentLine from accountingDistributionChanged
                group by LedgerDimension, sourcedocumentline
                where accountingDistributionChanged.AccountingEvent         == 0
                    && accountingDistributionChanged.SourceDocumentLine     == accountingDistributionLastEvent.SourceDocumentLine
                    && accountingDistributionChanged.LedgerDimension        == accountingDistributionLastEvent.LedgerDimension
                    && (accountingDistributionChanged.ReferenceDistribution == 0
                    || accountingDistributionChanged.ReferenceRole          == AccountingDistributionReferenceRole::Matching);
    
    
            if (!accountingDistributionChanged.LedgerDimension)
            {
                // account on changed GBR does not exist, create a full reduction BRE for account
                reductionAmount = accountingDistributionLastEvent.TransactionCurrencyAmount;
            }
            else
            {
                reductionAmount = accountingDistributionLastEvent.TransactionCurrencyAmount - accountingDistributionChanged.TransactionCurrencyAmount;
            }
    
            if (reductionAmount > 0)
            {
                ledgerDimensionsAmountsToReduce.insert(accountingDistributionChanged.LedgerDimension, reductionAmount);
    
                totalReduction += reductionAmount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndUpdateLedgerDimensionBudgetMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>LedgerDimensionBudget</c> record Id for a specified ledger account.
    /// </summary>
    /// <param name="_ledgerAccount">
    /// The ledger account.
    /// </param>
    /// <returns>
    /// A <c>LedgerDimensionBudget</c> record Id.
    /// </returns>
    private LedgerDimensionBudget findAndUpdateLedgerDimensionBudgetMap(LedgerDimensionBase _ledgerAccount)
    {
        LedgerDimensionBudget  ledgerDimensionBudget;
    
        if (ledgerDimensionsMap.exists(_ledgerAccount))
        {
            ledgerDimensionBudget = ledgerDimensionsMap.lookup(_ledgerAccount);
        }
        else
        {
            ledgerDimensionBudget = BudgetTransactionManager::saveBudgetLedgerDimension(_ledgerAccount);
    
            ledgerDimensionsMap.insert(_ledgerAccount, ledgerDimensionBudget);
        }
    
        return ledgerDimensionBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBudgetModelByLedgerDimensionAndDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>BudgetModel</c> table record for a specified ledger dimension and transaction date.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_date">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// A <c>BudgetModel</c> record buffer.
    /// </returns>
    private BudgetModel findBudgetModelByLedgerDimensionAndDate(
        LedgerDimensionBase _ledgerDimension,
        date _date)
    {
        BudgetModel     localBudgetModel;
        str             key;
    
        key = strFmt("%1#%2", _ledgerDimension, _date);
    
        if (ledgerDimBudgetModelsMap.exists(key))
        {
            localBudgetModel = ledgerDimBudgetModelsMap.lookup(key);
        }
        else
        {
            localBudgetModel = BudgetControlLedgerDimensionHelper::findBudgetModelByLedgerDimensionAndDate(
                Ledger::current(),
                _ledgerDimension,
                _date);
    
            ledgerDimBudgetModelsMap.insert(key, localBudgetModel);
        }
    
        return localBudgetModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBudgetTransactionHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>BudgetTransactionHeader</c> table record Id for a specified budget model.
    /// </summary>
    /// <param name="_modelId">
    /// The budget model ID.
    /// </param>
    /// <returns>
    /// A <c>BudgetTransactionHeader</c> record Id.
    /// </returns>
    private RefRecId findBudgetTransactionHeader(BudgetModelId _modelId)
    {
        RefRecId transactionHeaderRecId;
    
        if (budgetModelsMap.exists(_modelId))
        {
            transactionHeaderRecId = budgetModelsMap.lookup(_modelId);
        }
    
        return transactionHeaderRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCarryForwardBudgetTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the carry forward <c>BudgetTransactionHeader</c> table record associated
    /// with the current budget reservation's document number and initializes the related instance variables.
    /// </summary>
    /// <returns>
    /// The <c>BudgetTransactionHeader</c> table record Id.
    /// </returns>
    private RefRecId getCarryForwardBudgetTransaction()
    {
        BudgetTransactionHeader     carryForwardBudgetTransHeader;
        BudgetReservationHeader_PSN localBudgetReservationHeader;
    
        if (budgetReservationHeader.CarriedForwardBudgetTransactionHeader != 0)
        {
            select firstonly RecId, BudgetTransactionCode from carryForwardBudgetTransHeader
                exists join localBudgetReservationHeader
                where carryForwardBudgetTransHeader.PrimaryLedger == Ledger::current()
                    && carryForwardBudgetTransHeader.RecId == localBudgetReservationHeader.CarriedForwardBudgetTransactionHeader
                    && carryForwardBudgetTransHeader.BudgetTransactionType == BudgetTransactionType::CarryForwardBudget;
        }
    
        if (carryForwardBudgetTransHeader.RecId)
        {
            carryForwardBudgetTransactionCodeRecId  = carryForwardBudgetTransHeader.BudgetTransactionCode;
        }
    
        return carryForwardBudgetTransHeader.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMostRecentAccountingEvent</Name>
				<Source><![CDATA[
    private AccountingEvent getMostRecentAccountingEvent(SourceDocumentLine _sourceDocumentLine)
    {
        AccountingDistribution              accountingDistributionLastEvent;
        AccountingEvent                     lastAccountingEvent;
    
        select firstOnly AccountingEvent, TransactionCurrencyAmount from accountingDistributionLastEvent
            order by accountingDistributionLastEvent.Number desc
            where accountingDistributionLastEvent.SourceDocumentLine    ==  _sourceDocumentLine.RecId
        join lastAccountingEvent
            where lastAccountingEvent.RecId                             == accountingDistributionLastEvent.AccountingEvent;
    
        return lastAccountingEvent;
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BudgetReservationPost_PSN</c> object instance for creating
    /// a reduction budget carry-forward transaction.
    /// </summary>
    /// <param name="_budgetReservationHeader">
    /// A <c>BudgetReservationHeader_PSN</c> record to be processed.
    /// </param>
    private void initializeForDocument(BudgetReservationHeader_PSN _budgetReservationHeader)
    {
        budgetReservationHeader                 = _budgetReservationHeader;
        isBudgetResTypeEnabledForCarryForward   = BudgetReservationType_PSN::isCarryForwardReductionEnabled(budgetReservationHeader.BudgetReservationType_PSN);
        ledgerDimensionsMap                     = new Map(Types::Int64, Types::Int64);
        sourceDocumentFullyDistributedLineMap   = new Map(Types::Int64, Types::Record);
        ledgerDimensionsAmountsToReduce         = new Map(Types::Int64, Types::Real);
        this.populateBudgetResSrcDocLinesForPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFundEnabledForCarryForwardReduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method checks whether the fund is configured to reduce budget or not and also saves the fund to the set.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// Record Id value of the ledger dimension.
    /// </param>
    /// <returns>
    /// true if the fund is configured to reduce carry-forward budget; otherwise, false.
    /// </returns>
    private boolean isFundEnabledForCarryForwardReduction(LedgerDimensionAccount _ledgerDimension)
    {
        return LedgerFund::getFundFromLedgerAccount(_ledgerDimension).DoReduceCarryForwardBudget_PSN == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetReservationHeader</Name>
				<Source><![CDATA[
    public BudgetReservationHeader_PSN parmBudgetReservationHeader(BudgetReservationHeader_PSN _budgetReservationHeader = budgetReservationHeader)
    {
        budgetReservationHeader = _budgetReservationHeader;
    
        return budgetReservationHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBudgetResSrcDocLinesForPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the source document line set collection with the fully distributed <c>SourceDocumentLine</c> record associated with the current budget reservation header.
    /// </summary>
    private void populateBudgetResSrcDocLinesForPost()
    {
        SourceDocumentLine  sourceDocumentLineLocal;
    
        while select RecId from sourceDocumentLineLocal
            where sourceDocumentLineLocal.SourceDocumentHeader == budgetReservationHeader.SourceDocumentHeader
                && sourceDocumentLineLocal.AccountingStatus == SourceDocumentLineAccountingStatus::FullyDistributed
        {
             sourceDocumentFullyDistributedLineMap.insert(sourceDocumentLineLocal.RecId, sourceDocumentLineLocal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the budget reservation document to the general ledger.
    /// </summary>
    private void postToLedger()
    {
        this.processForLedgerData();

        if (SourceDocumentHeader::find(budgetReservationHeader.SourceDocumentHeader).AccountingStatus == SourceDocumentAccountingStatus::Completed)
        {
            info(strFmt("@Budgeting_BudgetReservationPS:BudgetReservationPostedSuccessfullyInfolog", budgetReservationHeader.DocumentNumber));
            TransactionLog::create(TransactionLogType::BudgetReservation_PSN, "@Budgeting_BudgetReservationPS:BudgetReservation");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processForLedgerData</Name>
				<Source><![CDATA[
    protected void processForLedgerData()
    {   
        ttsbegin;
    
        // Initialize the number sequence for voucher.
        NumberSeq numberSeq = NumberSeq::newGetVoucherFromId(BudgetParameters::numRefBudgetReservationVoucher_PSN().NumberSequenceId);
        Voucher voucher = numberSeq.voucher();
    
        budgetReservationHeader = BudgetReservationHeader_PSN::find(budgetReservationHeader.RecId, true);
        budgetReservationHeader.LedgerVoucher = voucher;
    
        if (accountingDate)
        {
            // the accounting date is stored because the default posting date is the session date, but they can change it
            BudgetReservation_PSN::correctionDistributionDateUpdate(accountingDate, 0, budgetReservationHeader.RecId);
            budgetReservationHeader.AccountingDate = accountingDate;
        }
        else if (BudgetReservationPeriodNotOpenAcctDateAdjustFlight::instance().isEnabled()
                && !this.isPeriodOpenForBudgetReservation())
        {
            SourceDocumentLine sourceDocumentLine;
            BudgetReservationLine_PSN budgetReservationLineLocal;

            // Submits "draft" lines to source document framework to transfer its state to
            // "fully-distributed" state, so that accounting distribution records can be created 
            // & distributed. The accounting date logic will be skipped, if the accounting 
            // distributions are not fully or partially distributed prior to the source document line 
            // transition to "completed" state while posting the document.The below method is 
            // being called to do the necessary transition. The logic in the framework that 
            // determines whether to update the accounting date is in the SourceDocumentLineState
            // class, isLineEligibleForAccountingDateUpdate method, which requires the line to be in
            // a partly or fully distributed state in order for the date to be changed.
            while select sourceDocumentLine
                where sourceDocumentLine.SourceDocumentHeader == budgetReservationHeader.SourceDocumentHeader
                && sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Draft
                join budgetReservationLineLocal
                    where budgetReservationLineLocal.SourceDocumentLine == sourceDocumentLine.RecId
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(budgetReservationLineLocal, false, SourceDocumentLineAccountingStatus::FullyDistributed);
            }
        }

        BudgetReservation_PSN budgetReservation_PSN = BudgetReservation_PSN::newFromBudgetReservationHeader_PSN(budgetReservationHeader);

        // Update the status fields on the document.
        budgetReservation_PSN.updateDocumentStatusFields(BudgetReservationDocumentAction_PSN::DocumentPost, false);

        if (accountingDate)
        {
            budgetReservationHeader.updateForPost();
        }
        else
        {
            budgetReservationHeader.update();
        }

        if (budgetReservationHeader.CarriedForwardBudgetTransactionHeader && budgetReservationHeader.CancelDate == dateNull())
        {
            this.processCarryForwardReductions();
        }

        // Process the source document.
        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(budgetReservationHeader, true, SourceDocumentAccountingStatus::Completed);

        // Finalize all associated purchase requisitions.
        budgetReservationHeader.finalizePurchaseRequisitionLines();
    
        ttscommit;

        if (accountingDate)
        {
            budgetReservationHeader.clearPostingCache();
        }  
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPeriodOpenForBudgetReservation</Name>
				<Source><![CDATA[
    private boolean isPeriodOpenForBudgetReservation()
    {
        FiscalCalendarPeriod currentReservationPeriod = FiscalCalendarPeriod::findPeriodByCalendarDate(Ledger::fiscalCalendar(), budgetReservationHeader.AccountingDate);
        LedgerFiscalCalendarPeriod currentLedgerPeriod;

        select firstOnly Status from currentLedgerPeriod
            where currentLedgerPeriod.FiscalCalendarPeriod == currentReservationPeriod.RecId
            && currentLedgerPeriod.Ledger == Ledger::current();

        return (currentLedgerPeriod.Status == FiscalPeriodStatus::Open);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCarryForwardReduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reduces the carry-forward budget on the budget reservation document if there is any left in the current fiscal year.
    /// </summary>
    /// <param name="_sourceDocumentLineRecId">
    /// The record Id of the <c>SourceDocumentLine</c> record to process for reduction of carry forward budgets.
    /// </param>
    private void processCarryForwardReduction(SourceDocumentLineRecId _sourceDocumentLineRecId)
    {
        SourceDocumentLine          currentSourceDocumentLine;
        BudgetSourceInquiryDetails  currentBudgetDetails;
    
        budgetTransactionMultiPost  = BudgetTransactionMultiPost::construct();
    
        // Initialize class level cache.
        budgetTransLineInsertList   = new RecordInsertList(tableNum(BudgetTransactionLine));
        budgetModelsMap             = new Map(Types::String, Types::Int64);
        countBudgetTransLinesMap    = new Map(Types::Int64, Types::Integer);
        ledgerDimBudgetModelsMap    = new Map(Types::String, Types::Record);

        ttsbegin;
    
        if (sourceDocumentFullyDistributedLineMap.elements() != 0)
        {
            if (sourceDocumentFullyDistributedLineMap.exists(_sourceDocumentLineRecId))
            {
                currentSourceDocumentLine = sourceDocumentFullyDistributedLineMap.lookup(_sourceDocumentLineRecId);
    
                currentBudgetDetails = BudgetSourceSourceDocumentLine::getBudgetSourceInquiryDetails(currentSourceDocumentLine);
    
                if (currentBudgetDetails)
                {
                    this.createBudgetTransactionLines(currentBudgetDetails, budgetReservationHeader.AccountingDate, currentSourceDocumentLine);
                }
            }
        }
    
        budgetTransLineInsertList.insertDatabase();
    
        ttscommit;
    
        // Post budget transactions.
        budgetTransactionMultiPost.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCarryForwardReductions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the <c>BudgetReservationHeader_PSN</c> table record by calling the method that will create the
    /// necessary budget transactions for reduction amounts.
    /// </summary>
    private void processCarryForwardReductions()
    {
        if (budgetReservationHeader.CancelDate != dateNull())
        {
            return;
        }
    
        this.initializeForDocument(budgetReservationHeader);
    
        while select LineAmount, LineNumber, Currency, SourceDocumentLine, LedgerDimension, BudgetReservationHeader_PSN from budgetReservationLine
            where budgetReservationLine.BudgetReservationHeader_PSN == budgetReservationHeader.RecId
        {
            ledgerDimensionsAmountsToReduce = new Map(Types::Int64, Types::Real);
            totalReduction                  = 0;
    
            this.determineAccountCarryFwdReductionAmts(budgetReservationLine);
    
            if (sourceDocumentFullyDistributedLineMap.elements() != 0)
            {
                this.processCarryForwardReduction(budgetReservationLine.SourceDocumentLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        if (this.validatePost())
        {
            this.postToLedger();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the budget reservation can be posted.
    /// </summary>
    /// <returns>
    /// true if the budget reservation can be posted; otherwise, false.
    /// </returns>
    private boolean validatePost()
    {
        boolean isValid = true;
    
        isValid = this.checkPostingDefinition() && this.checkPurchReqReferenceIsValid() && this.checkCarryForwardBudget();
    
        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>BudgetReservationPost_PSN</c> class and initalizes values on the new class instance.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>BudgetReservationPost_PSN</c> class.
    /// </returns>
    public static BudgetReservationPost_PSN construct()
    {
        return new BudgetReservationPost_PSN();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        BudgetReservationHeader_PSN budgetReservationHeader;
        BudgetReservationPost_PSN   budgetReservationPost;
    
        if (!_args || _args.record().RecId == 0)
        {
            throw error(strFmt("@SPS1272", funcName()));
        }
    
        budgetReservationHeader = _args.record() as BudgetReservationHeader_PSN;
        budgetReservationPost   = BudgetReservationPost_PSN::newFromBudgetReservationHeader_PSN(budgetReservationHeader);
        budgetReservationPost.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromBudgetReservationHeader_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>BudgetReservationPost_PSN</c> class and initalizes values on the new class instance.
    /// </summary>
    /// <param name="_budgetReservationHeader">
    /// The <c>BudgetReservationHeader_PSN</c> to post.
    /// </param>
    /// <returns>
    /// A new instance of the <c>BudgetReservationPost_PSN</c> class.
    /// </returns>
    public static BudgetReservationPost_PSN newFromBudgetReservationHeader_PSN(BudgetReservationHeader_PSN _budgetReservationHeader)
    {
        BudgetReservationPost_PSN budgetReservationPost_PSN;
    
        budgetReservationPost_PSN = new BudgetReservationPost_PSN();
        budgetReservationPost_PSN.parmBudgetReservationHeader(_budgetReservationHeader);
    
        return budgetReservationPost_PSN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate(AccountingDate _accountingDate = accountingDate)
    {
        accountingDate = _accountingDate;

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostingDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the transaction posting definition for budget reservation in the 
    /// <c>JournalizingDefinitionBudgetReservation_PSN</c> table.
    /// </summary>
    /// <returns>
    /// true if the transaction posting definition of budget reservation exists; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is a budget reservation specific implementation of the <c>getDefaultJournalizingDefinition</c>
    /// method of the <c>JournalizingDefinitionManager</c> class.
    /// </remarks>
    private boolean checkPostingDefinition()
    {
        JournalizingDefinitionBudgetReservation_PSN journalizingDefinitionBudgetReservation;
        JournalizingDefinition journalizingDefinition;
        boolean isValid = true;

        select firstonly RecId from journalizingDefinitionBudgetReservation
            exists join journalizingDefinition
            where journalizingDefinition.RecId == journalizingDefinitionBudgetReservation.JournalizingDefinition
                && journalizingDefinition.JournalizingDefinitionModuleValue == JournalizingDefinitionModuleId::BudgetReservation_PSN;

        if (!journalizingDefinitionBudgetReservation.RecId)
        {
            isValid = checkFailed("@SYS303883");
        }

        return isValid;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>