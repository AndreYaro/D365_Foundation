<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CreditCardProviderProcess</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The CreditCardProviderProcess class implements credit card processing for a connector.
/// </summary>
using Retail = Microsoft.Dynamics.Retail;
using RetailConst = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

public class CreditCardProviderProcess extends CreditCardProcess
{
    CreditCardCust creditCardCust;
    CreditCardProcessors creditCardProcessors;
    CreditCardAccountSetup accountSetup;
    CreditCardTypeSetup creditCardTypeSetup;
    CompanyInfo companyInfo;
    CreditCardPreAuthorization creditCardPreAuthorization;

    CreditCardProviderResult providerResult;

    // values from the current request, saved for use in processing the response
    str cardTokenRequest;
    CreditCardNumber creditCardNumber;

    boolean processSucceed;
    str displayedMessage;
    str responseMessage;

    private static CommerceHQEventSource eventWriter = CommerceHQEventSource::Log;

    #define.PurchaseCardTypeUnknown('U')
    #define.TaxDescription("Total Tax")
    #define.TaxTypeIdentifier("AlternateTax")
    #define.isTaxableYes('true')
    #define.isTaxableNo('false')
    #define.isSupportCardTokenizationYes('true')
    #CreditCard
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcTaxRate</Name>
				<Source><![CDATA[
    private TaxValue calcTaxRate(TaxAmountCur _tax, AmountCur _amountWithTax)
    {
        return _amountWithTax <= _tax ? 0 : (100.0 * _tax / (_amountWithTax - _tax));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForAddressVerification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if AVS is needed.
    /// </summary>
    /// <returns>
    /// true if AVS is needed.
    /// </returns>
    protected boolean checkForAddressVerification()
    {
        var checkAVS = false;

        // Address verification check is only done when preauthorization is enabled.
        if (creditCardPreAuthorization)
        {
            var addressVerification = CustTable::find(salesTable.CustAccount).CreditCardAddressVerification;

            if (addressVerification == CreditCardAddressVerification::Yes)
            {
                checkAVS = true;
            }
            else if (addressVerification == CreditCardAddressVerification::None)
            {
                checkAVS = accountSetup.AddressVerification;
            }
        }

        return checkAVS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCardVerificationValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if CVV is needed.
    /// </summary>
    /// <returns>
    /// true if CVV is needed.
    /// </returns>
    protected boolean checkForCardVerificationValue()
    {
        var checkCvc = false;

        // Credit card verification check is only done when preauthorization is enabled.
        if (creditCardPreAuthorization && this.parmGetCardVerificationValue())
        {
            var cardVerificaitonCheck = CustTable::find(salesTable.CustAccount).CreditCardCVC;

            if (cardVerificaitonCheck == CreditCardCVC::Yes)
            {
                checkCvc = true;
            }
            else if (cardVerificaitonCheck == CreditCardCVC::None)
            {
                checkCvc = accountSetup.CardVerificationCheck;
            }
        }

        return checkCvc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProcessResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a process response.
    /// </summary>
    /// <param name="_successDescriptionOverride">
    /// Transaction description on success.
    /// </param>
    /// <returns>
    /// true if the process executes successfully; otherwise false.
    /// </returns>
    public boolean createProcessResponse(str _successDescriptionOverride = '')
    {
        CreditCardApprovalRejectReason description = strLen(_successDescriptionOverride) ? _successDescriptionOverride : this.getRejectionReason();

        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;
            creditCard_ExtendedParameters.parmInitCreditCardAuthTrans_ProcessorErrorCode(firstErrorCode);
        }

        switch (this.parmOperation())
        {
            case CreditCardOperation::Authorize:
                CreditCard::recordAuthorization(providerResult,
                                            salesTable,
                                            this.parmCreditCardProcessor(),
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);

                if (RetailNonRecurringTokenFeatureExposure::isEnabled()
                    && mcrCustPaymTable.IsNonRecurring == NoYes::Yes
                    && this.processSucceed())
                {
                    var newCreditCardCust = CreditCard::createNonRecurringCreditCardFromAuthResponse(providerResult, mcrCustPaymTable.RecId, mcrCustPaymTable.CustAccount, this.parmCreditCardProcessor());
                    eventSource.EventWriteRetailNonRecurringTokenAuthorized(mcrCustPaymTable.RecId, newCreditCardCust.RecId, this.processSucceed());
                    RetailPaymentAccessTokenContext::instance().removeAccessCode(mcrCustPaymTable.RecId);
                }
                break;

            case CreditCardOperation::Reauthorize:
                CreditCard::recordReauthorization(providerResult,
                                            salesTable,
                                            this.parmCreditCardProcessor(),
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);
                break;

                break;
            case CreditCardOperation::CaptureAfterAuthorize:
                CreditCard::recordCapture(providerResult,
                                      salesTable,
                                      this.parmSalesInvoiceId(),
                                      this.parmCreditCardProcessor(),
                                      false,
                                      this.processSucceed(),
                                      description,
                                      cardTokenRequest,
                                      true,
                                      mcrCustPaymTable);
                break;
            case CreditCardOperation::AuthorizeAndCapture:
                CreditCard::recordCapture(providerResult,
                                      salesTable,
                                      this.parmSalesInvoiceId(),
                                      this.parmCreditCardProcessor(),
                                      true,
                                      this.processSucceed(),
                                      description,
                                      cardTokenRequest,
                                      true,
                                      mcrCustPaymTable);
                break;
            case CreditCardOperation::Refund:
                CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;
                creditCard_ExtendedParameters.parmRecordRefund_SalesInvoiceId(this.parmSalesInvoiceId());

                CreditCard::recordRefund(providerResult,
                                     salesTable,
                                     this.parmCreditCardProcessor(),
                                     this.processSucceed(),
                                     description,
                                     cardTokenRequest,
                                     true,
                                     mcrCustPaymTable);

                creditCard_ExtendedParameters.parmRecordRefund_SalesInvoiceId(null);
                break;
            case CreditCardOperation::Void:
                CreditCard::recordVoid(providerResult,
                                   salesTable,
                                   this.parmCreditCardProcessor(),
                                   this.processSucceed(),
                                   description,
                                   cardTokenRequest,
                                   true,
                                   mcrCustPaymTable);
                break;
            case CreditCardOperation::Balance:
                CreditCard::recordBalance(providerResult,
                                salesTable,
                                this.parmCreditCardProcessor(),
                                this.processSucceed(),
                                description,
                                cardTokenRequest,
                                true,
                                mcrCustPaymTable,
                                this.paramRetailExternalGiftCard());
                break;
            case CreditCardOperation::Activation:
                CreditCard::recordActivation(providerResult,
                                salesTable,
                                this.parmCreditCardProcessor(),
                                this.processSucceed(),
                                description,
                                cardTokenRequest,
                                true,
                                mcrCustPaymTable,
                                this.paramRetailExternalGiftCard());
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRequest</Name>
				<Source><![CDATA[
    private Retail.PaymentSDK.Portable.Request createRequest(CreditCardPaymentProperties _properties)
    {
        var request = new Retail.PaymentSDK.Portable.Request();

        request.set_Locale(currentUserLanguage());
        request.set_Properties(_properties.toArray());

        return request;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRejectionReason</Name>
				<Source><![CDATA[
    protected internal str getRejectionReason()
    {
        str reason = this.failedDescription();

        if (this.processSucceed())
        {
            if (salesTable)
            {
                reason = strFmt("@SYS327114", this.getSalesId());
            }
            else if (RetailMCRChannelTable::findForCurrentUser().MCREnableOrderCompletion)
            {
                if (custInvoiceTable)
                {
                    reason = strFmt("@MCR40436", custInvoiceTable.InvoiceId);
                }
                else if (ledgerJournalTrans)
                {
                    reason = strFmt("@MCR40415", ledgerJournalTrans.JournalNum, ledgerJournalTrans.LineNum);
                }
            }
        }

        return reason;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sales id for the associated sales order.
    /// </summary>
    /// <returns>
    /// A sales id.
    /// </returns>
    private str getSalesId()
    {
        str salesId;

        if (mcrCustPaymTable)
        {
            SalesTable paymentSalesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId);
 
            // For return orders, use the return order's sales id, not the original sales order's sales id
            if (paymentSalesTable && paymentSalesTable.SalesType == SalesType::ReturnItem)
            {
                salesId = paymentSalesTable.SalesId;
            }
            else
            {
                salesId = salesTable.SalesId;
            }
        }
        else
        {
            salesId = salesTable.SalesId;
        }

        return salesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the tax detail for level 2 or 3.
    /// </summary>
    /// <param name="_id">
    /// A tax identifier.
    /// </param>
    /// <param name="_description">
    /// The description of the tax.
    /// </param>
    /// <param name="_rate">
    /// The tax rate.
    /// </param>
    /// <param name="_tax">
    /// The value of the tax.
    /// </param>
    /// <param name="_taxNum">
    /// The sequence number for a tax detail line.
    /// </param>
    /// <returns>
    /// A property.
    /// </returns>
    protected CreditCardPaymentProperty createTaxDetail(str _id, str _description, TaxValue _rate, TaxAmountCur _tax, int _taxNum)
    {
        var taxProperties = CreditCardPaymentProperties::construct();
        str ns = RetailConst.GenericNamespace::get_TaxDetail();

        taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxTypeIdentifier(), _id));
        taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxDescription(), _description));
        if (_rate)
        {
            taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxRate(), _rate));
        }
        taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxAmount(), _tax));

        var taxDetail = CreditCardPaymentProperty::newName(RetailConst.GenericNamespace::get_TaxDetails(), this.NameAndSeq(RetailConst.TaxDetailProperties::get_TaxDetail(), _taxNum));
        taxDetail.parmPropertyListValue(taxProperties);

        return taxDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedDescription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the detailed exception with the response message.
    /// </summary>
    /// <returns>
    ///    The detailed exception message that has the response message.
    /// </returns>
    protected str failedDescription()
    {
        return this.processSucceed() ? '' : responseMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedDOLAPI</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a message identifying the API causing an error.
    /// </summary>
    /// <param name="_api">
    /// The name of the API.
    /// </param>
    /// <param name="_msg">
    /// An error message.
    /// </param>
    /// <returns>
    /// The formatted message.
    /// </returns>
    protected str failedDOLAPI(str _api, str _msg)
    {
        return strFmt("@SYS329019", _api, _msg);
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedReason</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the user visible response message.
    /// </summary>
    /// <returns>
    ///    An message.
    /// </returns>
    public str failedReason()
    {
        return displayedMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the text of the failure description.
    /// </summary>
    /// <param name="_status">
    /// The reason for a failure.
    /// </param>
    /// <remarks>
    /// The text is only set if the process failed.
    /// </remarks>
    public void failedStatus(str _status)
    {
        if (!this.processSucceed())
        {
            responseMessage = strFmt("@SYS327137", _status);
            displayedMessage = responseMessage;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fmtDate</Name>
				<Source><![CDATA[
    private str fmtDate(date _date)
    {
        return date2str(_date, 321, DateDay::Digits2, DateSeparator::Hyphen, DateMonth::Digits2, DateSeparator::Hyphen, DateYear::Digits4, DateFlags::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fmtDateTime</Name>
				<Source><![CDATA[
    private str fmtDateTime(utcdatetime _datetime)
    {
        return DateTimeUtil::toStr(_datetime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fmtNum</Name>
				<Source><![CDATA[
    private str fmtNum(real _num, int _decimalPlaces = 2)
    {
        return num2str(_num, 0, _decimalPlaces, 1, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReauthorizationRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties required for a reauthorization request.
    /// </summary>
    /// <returns>
    /// An instance of CreditCardPaymentProperties required for the reauthorization request.
    /// </returns>
    protected CreditCardPaymentProperties getReauthorizationRequest()
    {
        var props = this.getCardToken(creditCardTrans, false);
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        props = this.setTransactionalData(transNamespace, props);
        props.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));
        return props;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAuthRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties needed for an authorization request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    protected CreditCardPaymentProperties getAuthRequest()
    {
        var properties = this.getCardToken(creditCardTrans, true);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }
        
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        if (this.parmCardVerificationValue())
        {
            properties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_CardVerificationValue(), this.parmCardVerificationValue()));
        }

        this.setPurchaseLevelTypeAndDetails(properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCaptureRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties needed for a capture request.
    /// </summary>
    /// <param name="_properties">
    /// Properties from an authorization result to use in the request.
    /// </param>
    /// <returns>
    /// The properties needed.
    /// </returns>
    protected CreditCardPaymentProperties getCaptureRequest(CreditCardPaymentProperties _properties)
    {
        var properties = CreditCardPaymentProperties::fromProperties(_properties.toArray());
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        this.setPurchaseLevelTypeAndDetails(properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCardToken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the appropriate payment card properties.
    /// </summary>
    /// <param name="_creditCardAuthTrans">
    /// A <c>CreditCardAuthTrans</c> table record.
    /// </param>
    /// <param name="_useCard">
    /// Forces use of the card token from the <c>CreditCardCust</c> table.
    /// </param>
    /// <returns>
    /// The credit card properties.
    /// </returns>
    protected CreditCardPaymentProperties getCardToken(CreditCardAuthTrans _creditCardAuthTrans, boolean _useCard)
    {
        str cardToken;
        RetailPaymentAccessTokenArgs retailPaymentAccessTokenArgs;

        if (!creditCardNumber && _creditCardAuthTrans.CreditCardNumber)
        {
            creditCardNumber = _creditCardAuthTrans.CreditCardNumber;
        }

        // Always use the last card token from credit card history table if available
        if (_creditCardAuthTrans.CardTokenResult && !_useCard)
        {
            if (RetailNonRecurringTokenFeatureExposure::isEnabled()
                && mcrCustPaymTable
                && (this.parmOperation() == CreditCardOperation::Reauthorize
                || this.parmOperation() == CreditCardOperation::CaptureAfterAuthorize))
            {
                var latestRequthorization = CreditCardAuthTrans::findLatestReauthorization(mcrCustPaymTable.RecId);
                if (latestRequthorization.RecId)
                {
                    cardToken = latestRequthorization.CardTokenResult;
                }
                else
                {
                    cardToken = _creditCardAuthTrans.CardTokenResult;
                }
            }
            else
            {
                cardToken = _creditCardAuthTrans.CardTokenResult;
            }
        }
        else
        {
            if (salesTable.CreditCardCustRefId && !mcrCustPaymTable)
            {
                cardToken = this.extractTokenFromCreditCardCust(salesTable.CreditCardCustRefId, _creditCardAuthTrans.RecId);
            }
            // If MCRCustPaymTable exists the sales table CreditCardCustRefId will not be filled
            else if (mcrCustPaymTable.RecId != 0
                && mcrCustPaymTable.PaymInfoRecId != 0
                && mcrCustPaymTable.PaymInfoTableId == tableNum(CreditCardCust))
            {
                cardToken = this.extractTokenFromCreditCardCust(mcrCustPaymTable.PaymInfoRecId, _creditCardAuthTrans.RecId);
            }
            else if (mcrCustPaymTable.RecId != 0
                && mcrCustPaymTable.IsNonRecurring == NoYes::Yes
                && RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
            {
                retailPaymentAccessTokenArgs = RetailPaymentAccessTokenContext::instance().getAccessCode(mcrCustPaymTable.RecId);
                cardToken = retailPaymentAccessTokenArgs.parmCardPropertiesXmlString();
            }
        }

        if (!cardToken)
        {
            eventSource.EventWritePaymentsCardTokenNotFoundInCreditCardCust(mcrCustPaymTable.RecId, salesTable.RecId);
        }

        CreditCardPaymentProperties properties;
        if (RetailNonRecurringTokenFeatureExposure::isEnabled()
            && this.parmOperation() == CreditCardOperation::Authorize
            && RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
        {
            properties = CreditCardPaymentProperties::fromXmlString(cardToken);
            properties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_TransactionData(), RetailConst.TransactionDataProperties::get_PaymentAcceptResultAccessCode(), retailPaymentAccessTokenArgs.parmAccessCode()));
        }
        else
        {
            properties = CreditCardPaymentProperties::fromXmlString(cardToken);
            var property = properties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_Last4Digits());
            if (property && property.parmStringValue())
            {
                creditCardNumber = property.parmStringValue();
            }
        }
        
        this.updateGiftCardProperties(properties);

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCardVerificationValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Obtains the CVV value from the user.
    /// </summary>
    /// <returns>
    /// true if the user entered a CVV value.
    /// </returns>
    /// <remarks>
    /// The CVV value is available from parmCardVerificationValue.
    /// </remarks>
    protected boolean getCardVerificationValue()
    {
        var cvvEntered = true;

        if (this.parmOperation() == CreditCardOperation::Authorize && this.checkForCardVerificationValue())
        {
            var cvvEntry = new CreditCardCVVEntry(accountSetup);

            cvvEntry.parmSalesTable(salesTable);
            cvvEntry.parmCreditCardNumber(creditCardNumber);

            if (cvvEntry.prompt())
            {
                this.parmCardVerificationValue(cvvEntry.getCVV());
            }
            else
            {
                cvvEntered = false;
            }
        }

        return cvvEntered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClrExceptionMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exception message of the last exception thrown.
    /// </summary>
    /// <returns>
    /// The text of the last thrown exception.
    /// </returns>
    str getClrExceptionMessage()
    {
        var perm = new InteropPermission(InteropKind::ClrInterop);
        perm.assert();

        str exceptionMessage;
        str innerExceptionType;
        str innerExceptionStackTrace;

        System.Exception exception = CLRInterop::getLastException();
        if (exception)
        {
            exceptionMessage = exception.get_Message();

            System.Exception innerException = exception.get_InnerException();
            if (innerException)
            {
                exceptionMessage = innerException.get_Message();
                innerExceptionType = innerException.GetType().ToString();
                innerExceptionStackTrace = innerException.StackTrace;
            }

            eventWriter.EventWritePaymentProcessingException(exception.GetType().ToString(), exception.StackTrace, innerExceptionType, innerExceptionStackTrace);
        }

        CodeAccessPermission::revertAssert();

        processSucceed = false;

        return exceptionMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractTokenFromCreditCardCust</Name>
				<Source><![CDATA[
    private str extractTokenFromCreditCardCust(RefRecId _creditCardCustRecId, RefRecId _creditCardAuthTransRecId)
    {
        CreditCardCust creditCardRec = CreditCardCust::find(_creditCardCustRecId);

        if (creditCardRec && creditCardRec.TokenScope == RetailTokenScope::NonRecurring)
        {
            eventWriter.EventWriteNonRecurringTokenReuseAttempt(_creditCardAuthTransRecId, _creditCardCustRecId);
            processSucceed = false;
            this.displayedMessage = strFmt("@Retail:CannotReuseNonRecurringToken", salesTable.SalesId);
            this.responseMessage = this.displayedMessage;
        }

        return creditCardRec.CardToken;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGiftCardProperties</Name>
				<Source><![CDATA[
    private void updateGiftCardProperties(CreditCardPaymentProperties _properties)
    {
        CreditCardPaymentProperties giftProperties;

        if (this.paramRetailExternalGiftCard())
        {
            if (mcrCustPaymTable.isExternalGiftCardPayment())
            {
                giftProperties = this.paramRetailExternalGiftCard().generateMCRPaymentCardRequest(mcrCustPaymTable);
            }
            else
            {
                CreditCardAccountSetup creditCardAccountSetup = CreditCardAccountSetup::find(this.paramRetailExternalGiftCard().ActivationProcessorsRecId);
                giftProperties = this.paramRetailExternalGiftCard().generatePaymentCardRequest(creditCardAccountSetup);
            }
        }

        if (giftProperties)
        {
            // Combine properties card token with external gift card
            var enumerator = giftProperties.enumerator();

            while (enumerator.moveNext())
            {
                CreditCardPaymentProperty giftProperty = enumerator.current();

                var singleProperty = _properties.find(giftProperty.parmNamespace(), giftProperty.parmName());
                if (singleProperty)
                {
                    // Found, update
                    switch (singleProperty.parmValueType())
                    {
                        case CreditCardPropertyDataType::DateTime:
                            singleProperty.parmDateTimeValue(giftProperty.parmDateTimeValue());
                            break;
                        case CreditCardPropertyDataType::Decimal:
                            singleProperty.parmDecimalValue(giftProperty.parmDecimalValue());
                            break;
                        case CreditCardPropertyDataType::String:
                            singleProperty.parmStringValue(giftProperty.parmStringValue());
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    // Not found
                    _properties.add(giftProperty);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMiscCharge</Name>
				<Source><![CDATA[
    private CreditCardPaymentProperty getMiscCharge(MarkupTrans _markupTrans)
    {
        CreditCardPaymentProperties miscChargeProperties = CreditCardPaymentProperties::construct();
        miscChargeProperties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_MiscellaneousCharge(), RetailConst.MiscellaneousChargeProperties::get_ChargeType(), _markupTrans.Txt));
        miscChargeProperties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_MiscellaneousCharge(), RetailConst.MiscellaneousChargeProperties::get_ChargeAmount(), _markupTrans.getCalculatedAmountRepresentable()));

        CreditCardPaymentProperty miscCharge = CreditCardPaymentProperty::newName(RetailConst.GenericNamespace::get_MiscellaneousCharge(), RetailConst.MiscellaneousChargeProperties::get_MiscellaneousCharge());
        miscCharge.parmPropertyListValue(miscChargeProperties);

        return miscCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMiscCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a payment properties object that contains all markup charges associated with a invoice journal.
    /// If _taxDetails is passed it also updates the _taxDetails paymentProperties with the tax information for the markup charges.
    /// </summary>
    /// <param name="_source">
    /// Invoice journal to get the charges from.
    /// </param>
    /// <param name="_taxDetails">
    /// CreditCardPaymentProperties for the tax details.
    /// Defaults to Null.
    /// </param>
    /// <returns>
    /// The total amount of charges.
    /// </returns>
    private CreditCardPaymentProperties getMiscCharges(Common _common, CreditCardPaymentProperties _taxDetails = null)
    {
        CreditCardPaymentProperties miscCharges = CreditCardPaymentProperties::construct();

        MarkupTrans markupTrans;
        int miscChargeCount = 0;

        while select * from markupTrans
                where markupTrans.TransTableId == _common.TableId
                    && markupTrans.TransRecId == _common.RecId
        {
            if (markupTrans.CalculatedAmount != 0)
            {
                miscChargeCount++;

                CreditCardPaymentProperty miscCharge = this.getMiscCharge(markupTrans);
                miscCharge.parmName(this.NameAndSeq(miscCharge.parmName(), miscChargeCount));

                miscCharges.add(miscCharge);

                if (!prmIsDefault(_taxDetails))
                {
                    this.addTaxDetailsForRecord(_taxDetails, markupTrans);
                }
            }
        }

        return miscCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxDetailsForRecord</Name>
				<Source><![CDATA[
    private void addTaxDetailsForRecord(CreditCardPaymentProperties _taxDetails, Common _common)
    {
        TaxTrans taxTrans;

        while select * from taxTrans
            where taxTrans.SourceTableId == _common.TableId
                && taxTrans.SourceRecId == _common.RecId
        {
            //taxLineNum++;
            _taxDetails.add(this.createTaxDetail(#TaxTypeIdentifier, taxTrans.taxName(), taxTrans.TaxValue, taxTrans.SourceRegulateAmountCur * - 1, _taxDetails.count()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the payment connector by the passed connector name.
    /// </summary>
    /// <param name = "_connectorName">The connector name.</param>
    /// <returns>The payment connector, otherwise null.</returns>

    [Hookable(false)]
    protected Retail.PaymentSDK.Portable.IPaymentProcessor getProcessor(CreditCardConnectorName _connectorName)
    {
        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();

        Retail.PaymentSDK.Portable.IPaymentProcessor processor;
        System.Exception exception;
        
        eventWriter.EventWriteCreatePaymentProcessor(_connectorName);

        try
        {
            processor = new CreditCardPaymentProcessorFactory().getProcessor(_connectorName);
        }
        catch(Exception::CLRError)
        {
            processSucceed = false;
            responseMessage = this.getClrExceptionMessage();
            displayedMessage = "@SYS116968";
        }
        catch(exception)
        {
            eventWriter.EventWritePaymentProcessingException(exception.GetType().ToString(), exception.StackTrace, '', '');
            processSucceed = false;
            displayedMessage = "@SYS116968";
            if (!responseMessage)
            {
                responseMessage = displayedMessage;
            }
        }

        CodeAccessPermission::revertAssert();

        return processor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRefundRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties needed for an refund request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    protected CreditCardPaymentProperties getRefundRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }
        
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        this.setPurchaseLevelTypeAndDetails(properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoidRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the propeties needed for a void request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    protected CreditCardPaymentProperties getVoidRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }
        
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        this.setPurchaseLevelTypeAndDetails(properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the propeties needed for a balance request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getBalanceRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }
        
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivationRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the propeties needed for an activation request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getActivationRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }
        
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleAuthResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of an authorization operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    protected void handleAuthResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Authorize');
        CreditCardProviderAuthorizationResult authResult = _response ? CreditCardProviderAuthorizationResult::constructFromResponse(_response) : null;

        providerResult = authResult;

        if (resultOK && authResult && authResult.parmAuthorizationResult() != CreditCardAuthorizationResult::Success)
        {
            processSucceed = false;
            this.failedStatus(enum2str(authResult.parmAuthorizationResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleReauthorizationResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a reauthorize operation.
    /// </summary>
    /// <param name = "response">A response.</param>
    protected void handleReauthorizationResponse(Retail.PaymentSDK.Portable.Response response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(response, 'Reauthorize');
        CreditCardProviderReauthorizationResult reauthorizationResult = response ? CreditCardProviderReauthorizationResult::constructFromResponse(response) : null;
        providerResult = reauthorizationResult;

        if (resultOK && reauthorizationResult && reauthorizationResult.parmReauthorizationResult() != CreditCardAuthorizationResult::Success)
        {
            processSucceed = false;
            this.failedStatus(enum2str(reauthorizationResult.parmReauthorizationResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCaptureResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a capture operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    /// <param name="_authorization">
    /// An authorization.
    /// </param>
    protected void handleCaptureResponse(Retail.PaymentSDK.Portable.Response _response, CreditCardAuthorization _authorization)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Capture');

        if (_response.Properties != null)
        {
            CreditCardProviderCaptureResult captureResult = _response ? CreditCardProviderCaptureResult::constructFromResponse(_response, this.parmTotalAmountCur(), _authorization) : null;

            providerResult = captureResult;

            if (resultOK && captureResult && captureResult.parmCaptureResult() != CreditCardCaptureResult::Success)
            {
                processSucceed = false;
                this.failedStatus(enum2str(captureResult.parmCaptureResult()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRefundResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a refund operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    protected void handleRefundResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Refund');
        CreditCardProviderRefundResult refundResult = _response ? CreditCardProviderRefundResult::constructFromResponse(_response, this.parmTotalAmountCur()) : null;

        providerResult = refundResult;

        if (resultOK && refundResult && refundResult.parmRefundResult() != CreditCardRefundResult::Success)
        {
            processSucceed = false;
            this.failedStatus(enum2str(refundResult.parmRefundResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setup the standard properties needed to request a credit card operation.
    /// </summary>
    /// <param name="_requestProperties">
    /// The request properties.
    /// </param>
    /// <returns>
    /// A connector name.
    /// </returns>
    [Hookable(false)]
    protected CreditCardConnectorName handleRequest(CreditCardPaymentProperties _requestProperties)
    {
        cardTokenRequest = _requestProperties.toXmlString();

        return CreditCard::addMerchantAccountProperties(_requestProperties);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a credit card operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    /// <param name="_operation">
    /// Name of the operation.
    /// </param>
    /// <returns>
    /// true if the operation was successful.
    /// </returns>
    protected CreditCardProviderResultOK handleResponse(Retail.PaymentSDK.Portable.Response _response, str _operation)
    {
        if (accountSetup.IsTest)
        {
            info("@SYS329938");
        }

        firstErrorCode = 0;
        CreditCardPaymentErrors errors = CreditCardPaymentErrors::fromPaymentErrors(_response.get_Errors());
        CreditCardProviderResultOK resultOK = true;

        if (errors.count() > 0)
        {
            processSucceed = false;
            displayedMessage = "@SYS34720";
            responseMessage = this.failedDOLAPI(_operation, strReplace(errors.toString(), '\n', '; '));
            resultOK = false;
            firstErrorCode = errors.getError(1).parmCode();

            this.setCreditCardRequestResultForNetworkError(errors);
        }

        RetailEventNotificationAction::CreditCardProcessCompletion(this.processSucceed(), errors, this.parmOperation(), _operation == 'Authorize', salesTable);

        return resultOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCreditCardRequestResultForNetworkError</Name>
				<Source><![CDATA[
    protected internal void setCreditCardRequestResultForNetworkError(CreditCardPaymentErrors _errors)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleVoidResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a void operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    protected void handleVoidResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Void');
        CreditCardProviderVoidResult voidResult = _response ? CreditCardProviderVoidResult::constructFromResponse(_response) : null;

        providerResult = voidResult;

        if (resultOK && voidResult && voidResult.parmVoidResult() != CreditCardVoidResult::Success)
        {
            processSucceed = false;
            this.failedStatus(enum2str(voidResult.parmVoidResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleBalanceResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a balance operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleBalanceResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Balance');
        CreditCardProviderBalanceResult balanceResult = _response ? CreditCardProviderBalanceResult::constructFromResponse(_response) : null;

        providerResult = balanceResult;

        if (resultOK && balanceResult && balanceResult.parmBalanceResult() != CreditCardBalanceResult::Success)
        {
            processSucceed = false;
            this.failedStatus(enum2str(balanceResult.parmBalanceResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleActivationResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a activation operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleActivationResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Activation');
        CreditCardProviderActivationResult activationResult = _response ? CreditCardProviderActivationResult::constructFromResponse(_response) : null;

        providerResult = activationResult;

        if (resultOK && activationResult && activationResult.parmActivationResult() != CreditCardActivationResult::Success)
        {
            processSucceed = false;
            this.failedStatus(enum2str(activationResult.parmActivationResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize internal state.
    /// </summary>
    /// <param name="_record">
    /// A record.
    /// </param>
    /// <exception cref="Exception::Error">
    /// The record is not related to a sales order using a credit card for payment.
    /// </exception>
    protected void init(Common _record)
    {
        boolean skipcreditCardCustCheck = false;
        RetailExternalGiftCardTable retailExternalGiftCardTable;

        super(_record);

        if (salesTable.CreditCardCustRefId)
        {
            creditCardCust = CreditCardCust::find(salesTable.CreditCardCustRefId);
        }
        else if (mcrCustPaymTable.isExternalGiftCardPayment())
        {
            retailExternalGiftCardTable = RetailExternalGiftCardTable::findById(mcrCustPaymTable.PaymInfoRecId);

            if (retailExternalGiftCardTable)
            {
                this.initProcessor(retailExternalGiftCardTable.CreditCardProcessors);
                this.initCardType(Microsoft.Dynamics.Retail.PaymentSDK.Portable.CardType::GiftCard.ToString());
            }
        }
        else if (mcrCustPaymTable)
        {
            creditCardCust = creditCardCust::find(mcrCustPaymTable.PaymInfoRecId);

            if (!creditCardCust)
            {
                // Credit card cust record does not exist, probably deleted, try and use creditCardTrans if exists
                creditCardTrans = CreditCardAuthTrans::mcrFindAvailablePreApproval(mcrCustPaymTable.RecId);

                if (creditCardTrans)
                {
                    skipcreditCardCustCheck = true;
                }

                if (!skipcreditCardCustCheck
                    && (mcrCustPaymTable.IsNonRecurring == NoYes::Yes
                    && this.parmOperation() == CreditCardOperation::Authorize))
                {
                    if (RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
                    {
                        skipcreditCardCustCheck = true;
                    }
                    else
                    {
                        throw error("@Retail:RetailNonRecurringTokenAuthorizationCodeMissing");
                    }
                }
            }
        }
        else if (creditCardTrans)
        {
            if (creditCardTrans.ApprovalType == CreditCardOperation::Activation)
            {
                skipcreditCardCustCheck = true;
            }
        }

        if (!retailExternalGiftCardTable)
        {
            if (!creditCardCust && !skipcreditCardCustCheck)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            if (creditCardTrans && creditCardTrans.CreditCardProcessors)
            {
                this.initProcessor(creditCardTrans.CreditCardProcessors);
            }
            else if (RetailNonRecurringTokenFeatureExposure::isEnabled() && this.parmOperation() == CreditCardOperation::Authorize && mcrCustPaymTable.IsNonRecurring == NoYes::Yes)
            {
                if (!RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
                {
                    throw error("@Retail:RetailNonRecurringTokenAuthorizationCodeMissing");
                }
                else
                {
                    var creditCardProcessorsId = RetailPaymentAccessTokenContext::instance().getAccessCode(mcrCustPaymTable.RecId).parmCreditCardProcessorsId();
                    this.initProcessor(creditCardProcessorsId);
                }
            }
            else
            {
                this.initProcessor(creditCardCust.CreditCardProcessors);
            }

            if (creditCardTrans && creditCardTrans.CreditCardTypeName)
            {
                this.initCardType(creditCardTrans.CreditCardTypeName);
            }
            else if (RetailNonRecurringTokenFeatureExposure::isEnabled() && this.parmOperation() == CreditCardOperation::Authorize && mcrCustPaymTable.IsNonRecurring == NoYes::Yes)
            {
                if (!RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
                {
                    throw error("@Retail:RetailNonRecurringTokenAuthorizationCodeMissing");
                }
                else
                {
                    var cardTypeId = RetailPaymentAccessTokenContext::instance().getAccessCode(mcrCustPaymTable.RecId).parmCardTypeId();
                    this.initCardType(cardTypeId);
                }
            }
            else
            {
                this.initCardType(creditCardCust.CreditCardTypeName);
            }

            if (creditCardTrans && creditCardTrans.CreditCardNumber)
            {
                creditCardNumber = creditCardTrans.CreditCardNumber;
            }
            else
            {
                if (!salesTable.mcrIsCallCenter() || salesTable.CreditCardCustRefId )
                {
                    creditCardNumber = CreditCardCust::find(salesTable.CreditCardCustRefId).CardNumber;
                }
                else
                {
                    creditCardNumber = CreditCardCust::find(mcrCustPaymTable.PaymInfoRecId).CardNumber;
                }
            }
        }

        this.initializeCommonProperties();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initActivation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void initActivation(SalesTable _salesTable, RetailExternalGiftCard _retailExternalGiftCard)
    {
        super(_salesTable, _retailExternalGiftCard);
        this.initProcessor(_retailExternalGiftCard.ActivationProcessorsRecId);
        this.initCardType(Microsoft.Dynamics.Retail.PaymentSDK.Portable.CardType::GiftCard.ToString());

        this.initializeCommonProperties();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCardType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the card type to use.
    /// </summary>
    /// <param name="_name">
    /// The card type name.
    /// </param>
    protected void initCardType(CreditCardTypeName _name)
    {
        creditCardTypeSetup = CreditCardTypeSetup::find(creditCardProcessors, _name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the processor to use.
    /// </summary>
    /// <param name="_processor">
    /// The processor.
    /// </param>
    protected void initProcessor(CreditCardProcessorsId _processor)
    {
        creditCardProcessors = CreditCardProcessors::find(_processor);
        accountSetup = CreditCardAccountSetup::find(creditCardProcessors.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currency code from the transaction
    /// </summary>
    /// <returns>
    /// <c>CurrencyCode</c> based on the transaction that is passed in.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method requires a transaction table; throw error if one is not available.
    /// </exception>
    protected CurrencyCode mcrGetCurrencyCode()
    {
        anytype currencyCodeLocal;

        if (SalesTable)
        {
            currencyCodeLocal = salesTable.CurrencyCode;
        }
        else if (custInvoiceTable)
        {
            currencyCodeLocal = custInvoiceTable.CurrencyCode;
        }
        else if (ledgerJournalTrans)
        {
            currencyCodeLocal = ledgerJournalTrans.CurrencyCode;
        }
        else if (creditCardTrans)
        {
            currencyCodeLocal = creditCardTrans.CurrencyCode;
        }
        else if (custPaymSchedLine)
        {
            currencyCodeLocal = mcrCustPaymTable.CurrencyCode;
        }
        else
        {
            throw error("@SYS89176");
        }
        return currencyCodeLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the invoice account related to the transaction.
    /// </summary>
    /// <returns>
    /// <c>CustAccount</c> based on the transaction that is passed in.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method requires a transaction table; throw error if one is not available.
    /// </exception>
    protected CustAccount mcrGetInvoiceAccount()
    {
        CustAccount invoiceAccount;

        if (SalesTable)
        {
            invoiceAccount = salesTable.InvoiceAccount;
        }
        else if (custInvoiceTable)
        {
            invoiceAccount = custInvoiceTable.InvoiceAccount;
        }
        else if (ledgerJournalTrans)
        {
            invoiceAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(ledgerJournalTrans.LedgerDimension);
        }
        else if (CustPaymSchedLine)
        {
            invoiceAccount = mcrCustPaymTable.CustAccount;
        }
        else
        {
            throw error("@SYS89176");
        }
        return invoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction ID.
    /// </summary>
    /// <returns>
    /// <c>SalesId</c>, <c>InvoiceId</c>, or <c>JournalNum</c> based on the transaction that is passed in.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method requires a transaction table; throw error if one is not available.
    /// </exception>
    protected Num mcrGetTransactionId()
    {
        Num transactionId;
        MCRInstallmentPlanSalesTable mcrInstallmentPlanSalesTable;
        CustPaymSched custPaymSched;
        MCRContinuityCustHeader mcrContinuityCustHeader;

        if (SalesTable)
        {
            transactionId = salesTable.SalesId;
        }
        else if (custInvoiceTable)
        {
            transactionId = custInvoiceTable.InvoiceId;
        }
        else if (ledgerJournalTrans)
        {
            transactionId = ledgerJournalTrans.JournalNum;
        }
        else if (CustPaymSchedLine)
        {
            custPaymSched = CustPaymSched::mcrFindRecID(custPaymSchedLine.ParentRecID);
            if (CustPaymSched.MCRRefTableID == tableNum(MCRInstallmentPlanSalesTable))
            {
                mcrInstallmentPlanSalesTable = MCRInstallmentPlanSalesTable::findRecId(CustPaymSched.MCRRefRecID);
                if (mcrInstallmentPlanSalesTable)
                {
                    transactionId = mcrInstallmentPlanSalesTable.SalesId;
                }
            }
            else if (CustPaymSched.ExtTableId == tableNum(MCRContinuityCustHeader))
            {
                mcrContinuityCustHeader = MCRContinuityCustHeader::findRecId(custPaymSched.ExtRecId);
                if (mcrContinuityCustHeader)
                {
                    transactionId = mcrContinuityCustHeader.SalesId;
                }
            }
            else
            {
                throw error("@SYS89176");
            }
        }
        else
        {
            throw error("@SYS89176");
        }
        return transactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>NameAndSeq</Name>
				<Source><![CDATA[
    protected str NameAndSeq(str _name, int _seq)
    {
        return _name + int2str(_seq);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        try
        {
            Retail.SDKManager.Portable.PaymentProcessorManager::LoadAllAssemblies(CreditCardConnectorSetup::getConnectorsDirectories());
        }
        catch (Exception::CLRError)
        {
            processSucceed = false;
            responseMessage = this.getClrExceptionMessage();
            displayedMessage = "@SYP4910242" + " " + responseMessage;
            error(displayedMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditCardProcessor</Name>
				<Source><![CDATA[
    public CreditCardProcessorsId parmCreditCardProcessor()
    {
        return creditCardProcessors.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareSubmission</Name>
				<Source><![CDATA[
    /// <summary>
    /// Establishes the connection to the processor.
    /// </summary>
    /// <returns>
    /// true if successful.
    /// </returns>
    public boolean prepareSubmission()
    {
        return this.processSucceed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSucceed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports the overall success of the credit card operation.
    /// </summary>
    /// <returns>
    /// true if the operation is successful.
    /// </returns>
    public boolean processSucceed()
    {
        return processSucceed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCommonProperties</Name>
				<Source><![CDATA[
    private void initializeCommonProperties()
    {
        companyInfo = CompanyInfo::find();
        creditCardPreAuthorization = CustParameters::find().CreditCardPreAuthorization;
        processSucceed = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customer reference for L2/L3 transaction data.
    /// </summary>
    /// <returns>The customer reference.</returns>
    private str getCustomerReference()
    {
        str customerReference;
        if (salesTable)
        {
            customerReference = salesTable.SalesId;
        }
        else if (ledgerJournalTrans)
        {
            customerReference = ledgerJournalTrans.Voucher;
        }
        else if (custInvoiceTable)
        {
            customerReference = custInvoiceTable.InvoiceId;
        }
        return customerReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLevel2Data</Name>
				<Source><![CDATA[
    private CreditCardPaymentProperty setLevel2Data()
    {
        CreditCardPaymentProperties properties = CreditCardPaymentProperties::construct();

        void addLevel2Property(str _name, anytype _value)
        {
            this.addPaymentProperty(RetailConst.GenericNamespace::get_L2Data(), properties, _name, _value);
        }

        void addHeaderTaxDetail(CreditCardPaymentProperty _taxDetail)
        {
            CreditCardPaymentProperties taxDetails = CreditCardPaymentProperties::construct();

            taxDetails.add(_taxDetail);

            addLevel2Property(RetailConst.L2DataProperties::get_TaxDetails(), taxDetails);
        }

        CustTable custTable = CustTable::find(salesTable.InvoiceAccount);

        addLevel2Property(RetailConst.L2DataProperties::get_OrderDateTime(), salesTable.CreatedDateTime);

        if (RetailPaymentDataSupportCustRefPatameterFlight::instance().isEnabled())
        {
            addLevel2Property(RetailConst.L2DataProperties::get_OrderNumber(), this.getCustomerReference());
        }
        else
        {
            addLevel2Property(RetailConst.L2DataProperties::get_OrderNumber(), salesTable.SalesId);
        }

        addLevel2Property(RetailConst.L2DataProperties::get_InvoiceNumber(), this.parmSalesInvoiceId());
        addLevel2Property(RetailConst.L2DataProperties::get_OrderDescription(), salesTable.CustomerRef);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantContact(), HcmWorker::worker2Name(custTable.MainContactWorker));
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantTaxId(), companyInfo.CoRegNum);
        if (custInvoiceJour)
        {
            addLevel2Property(RetailConst.L2DataProperties::get_InvoiceDateTime(), custInvoiceJour.InvoiceDate);
            addLevel2Property(RetailConst.L2DataProperties::get_PurchaserId(), custInvoiceJour.InvoiceAccount);
        }
        else
        {
            addLevel2Property(RetailConst.L2DataProperties::get_PurchaserId(), salesTable.InvoiceAccount);
        }
        LogisticsPostalAddress logisticsPostalAddress = LogisticsPostalAddress::findRecId(custInvoiceJour.DeliveryPostalAddress);
        addLevel2Property(RetailConst.L2DataProperties::get_PurchaserTaxId(), custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, custInvoiceJour.InvoiceDate));
        addLevel2Property(RetailConst.L2DataProperties::get_ShipToCity(), logisticsPostalAddress.City);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipToCounty(), logisticsPostalAddress.County);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipToState_ProvinceCode(), logisticsPostalAddress.State);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipToPostalCode(), logisticsPostalAddress.ZipCode);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipToCountryCode(), logisticsPostalAddress.CountryRegionId);

        // Ship From: Use Warehouse address else use Company address
        InventLocation inventLocation = InventLocation::find(custInvoiceJour.InventLocationId);
        if (InventParameters::find().ShipCarrierReturnTo == ShipCarrierReturnTo::Warehouse && inventLocation)
        {
            logisticsPostalAddress = LogisticsPostalAddress::findRecId(inventLocation.RecId);
        }
        else
        {
            logisticsPostalAddress = companyInfo.postalAddress();
        }
        addLevel2Property(RetailConst.L2DataProperties::get_ShipFromCity(), logisticsPostalAddress.City);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipFromCounty(), logisticsPostalAddress.County);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipFromState_ProvinceCode(), logisticsPostalAddress.State);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipFromCountryCode(), logisticsPostalAddress.CountryRegionId);
        addLevel2Property(RetailConst.L2DataProperties::get_ShipFromPostalCode(), logisticsPostalAddress.ZipCode);

        addLevel2Property(RetailConst.L2DataProperties::get_DiscountAmount(), custInvoiceJour.EndDisc);
        addLevel2Property(RetailConst.L2DataProperties::get_TotalTaxAmount(), custInvoiceJour.SumTax);
        addLevel2Property(RetailConst.L2DataProperties::get_IsTaxable(), custInvoiceJour.SumTax != 0 ? #isTaxableYes : #isTaxableNo);

        if (custInvoiceJour.InvoiceAmount != 0)
        {
            addLevel2Property(RetailConst.L2DataProperties::get_TotalTaxRate(), 100.0 * custInvoiceJour.SumTax / custInvoiceJour.InvoiceAmount);
        }

        logisticsPostalAddress = companyInfo.postalAddress();
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantName(), companyInfo.Name);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantStreet(), logisticsPostalAddress.Street);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantCity(), logisticsPostalAddress.City);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantCounty(), logisticsPostalAddress.County);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantState(), logisticsPostalAddress.State);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantCountryCode(), logisticsPostalAddress.CountryRegionId);
        addLevel2Property(RetailConst.L2DataProperties::get_MerchantZip(), logisticsPostalAddress.ZipCode);

        addLevel2Property(RetailConst.L2DataProperties::get_RequesterName(), CreditCardCust::find(salesTable.CreditCardCustRefId).Name);
        addLevel2Property(RetailConst.L2DataProperties::get_TotalAmount(), this.parmTotalAmountCur());
        addLevel2Property(RetailConst.L2DataProperties::get_PurchaseCardType(), #PurchaseCardTypeUnknown);

        // Add tax details (just one)
        addHeaderTaxDetail(this.createTaxDetail(#TaxTypeIdentifier, #TaxDescription, custInvoiceJour.InvoiceAmount == 0 ? 0.0 : this.calcTaxRate(custInvoiceJour.SumTax, custInvoiceJour.InvoiceAmount), custInvoiceJour.SumTax, 1));

        // Add miscellaneous Charges, Freight and Handling are included in miscellaneous charges
        addLevel2Property(RetailConst.L2DataProperties::get_MiscellaneousCharges(), this.getMiscCharges(custInvoiceJour));

        return CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_PurchaseLevelData(), RetailConst.PurchaseLevelDataProperties::get_L2Data(), properties);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLevel3Data</Name>
				<Source><![CDATA[
    private CreditCardPaymentProperty setLevel3Data()
    {
        void addLevel3Property(CreditCardPaymentProperties _properties, str _name, anytype _value)
        {
            this.addPaymentProperty(RetailConst.GenericNamespace::get_L3Data(), _properties, _name, _value);
        }

        void addShippingLineInfo(CreditCardPaymentProperties _properties, CustInvoiceTrans _invoiceTrans)
        {
            WHSSubmittedDateTime pickupDateTime;
            str trackingNumbers;

            MarkupTrans markupTrans;
            TMSFreightBillMarkupTrans freightBillMarkupTrans;
            TMSFreightBillDetail freightBillDetail;
            TMSInvoiceLine invoiceLine;
            TMSFBInvMatch invMatch;

            while select ShipUTCDateTime from freightBillDetail
                order by freightBillDetail.ShipUTCDateTime
                outer join RecId from invMatch
                    where invMatch.FreightBillDetailRecId == freightBillDetail.RecId
                    outer join ShipCarrierTrackingNum from invoiceLine
                        where invoiceLine.RecId == invMatch.InvoiceLineRecId
                exists join freightBillMarkupTrans
                    where freightBillMarkupTrans.MarkupTransTableId == tableNum(markupTrans)
                        && freightBillMarkupTrans.FreightBillDetailTableId == tableNum(TMSFreightBillDetail)
                        && freightBillMarkupTrans.FreightBillDetailRecId == freightBillDetail.RecId
                exists join markupTrans
                    where markupTrans.TransTableId == _invoiceTrans.TableId
                        && markupTrans.TransRecId == _invoiceTrans.RecId
                        && markupTrans.RecId == freightBillMarkupTrans.MarkupTransRecId
            {
                pickupDateTime = pickupDateTime ? pickupDateTime : freightBillDetail.ShipUTCDateTime;

                if (invoiceLine && invoiceLine.ShipCarrierTrackingNum)
                {
                    trackingNumbers += (trackingNumbers ? ';' : '') + invoiceLine.ShipCarrierTrackingNum;
                }
            }

            if (pickupDateTime)
            {
                addLevel3Property(_properties, RetailConst.L3DataProperties::get_PickupDateTime(), pickupDateTime);
            }

            if (trackingNumbers)
            {
                addLevel3Property(_properties, RetailConst.L3DataProperties::get_CarrierShipmentNumber(), trackingNumbers);
            }
        }

        CreditCardPaymentProperty addLevel3DataByLine(CustInvoiceTrans _invoiceTrans, int _lineNum)
        {
            CreditCardPaymentProperties properties = CreditCardPaymentProperties::construct();

            addLevel3Property(properties, RetailConst.L3DataProperties::get_CommodityCode(), int642Str( _invoiceTrans.IntrastatCommodity));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_ProductCode(), _invoiceTrans.ItemId);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_SequenceNumber(), _invoiceTrans.ItemId);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_ProductName(), _invoiceTrans.Name);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_ProductSKU(), _invoiceTrans.ExternalItemId);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_Descriptor(), _invoiceTrans.Name);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_UnitOfMeasure(), _invoiceTrans.SalesUnit);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_UnitPrice(), this.fmtNum(_invoiceTrans.SalesPrice));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_Discount(), this.fmtNum(_invoiceTrans.LineDisc));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_DiscountRate(), this.fmtNum(_invoiceTrans.LinePercent));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_Quantity(), this.fmtNum(_invoiceTrans.Qty));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_NetTotal(), this.fmtNum(_invoiceTrans.LineAmount));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_TaxAmount(), this.fmtNum(_invoiceTrans.TaxAmount));

            addLevel3Property(properties, RetailConst.L3DataProperties::get_MerchantCatalogNumber(), _invoiceTrans.ItemId);

            // Ship From: Use Warehouse address else use Company address
            LogisticsPostalAddress logisticsPostalAddress;
            InventLocation inventLocation = InventLocation::find(_invoiceTrans.inventDim().InventLocationId);
            if (InventParameters::find().ShipCarrierReturnTo == ShipCarrierReturnTo::Warehouse && inventLocation)
            {
                logisticsPostalAddress = LogisticsPostalAddress::findRecId(inventLocation.RecId);
            }
            else
            {
                logisticsPostalAddress = companyInfo.postalAddress();
            }

            addLevel3Property(properties, RetailConst.L3DataProperties::get_PickupCity(), logisticsPostalAddress.City);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_PickupState(), logisticsPostalAddress.State);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_PickupZip(), logisticsPostalAddress.ZipCode);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_PickupCountry(), logisticsPostalAddress.CountryRegionId);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_PickupCounty(), logisticsPostalAddress.County);
            addLevel3Property(properties, RetailConst.L3DataProperties::get_PickupAddress(), logisticsPostalAddress.Street);

            addLevel3Property(properties, RetailConst.L3DataProperties::get_CostCenter(),
                    DimensionAttributeValueSetStorage::find(_invoiceTrans.DefaultDimension).getDisplayValueByDimensionAttribute(CustParameters::find().CreditCardCostCenterDimensionAttribute));
            addLevel3Property(properties, RetailConst.L3DataProperties::get_MerchantTaxID(), companyInfo.CoRegNum);

            addShippingLineInfo(properties, _invoiceTrans);

            CreditCardPaymentProperties taxDetails = CreditCardPaymentProperties::construct();
            //taxLineNum = 0;

            this.addTaxDetailsForRecord(taxDetails, _invoiceTrans);

            var lineMarkupProperties = this.getMiscCharges(_invoiceTrans, taxDetails);

            addLevel3Property(properties, RetailConst.L3DataProperties::get_TaxDetails(), taxDetails);

            // Add Miscellaneous Charges, freight and handling are included
            addLevel3Property(properties, RetailConst.L3DataProperties::get_MiscellaneousCharges(), lineMarkupProperties);

            return CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_PurchaseLevelData(), this.NameAndSeq(RetailConst.PurchaseLevelDataProperties::get_L3DataItems(), _lineNum), properties);
        }

        CreditCardPaymentProperties lines = CreditCardPaymentProperties::construct();
        CustInvoiceTrans invoiceTrans;

        int lineNum = 0;

        while select invoiceTrans
            order by
                invoiceTrans.LineNum, invoiceTrans.RecId
            where
                invoiceTrans.SalesId == custInvoiceJour.SalesId &&
                invoiceTrans.InvoiceId == custInvoiceJour.InvoiceId &&
                invoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate &&
                invoiceTrans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
        {
            lineNum++;
            lines.add(addLevel3DataByLine(invoiceTrans, lineNum));
        }

        return CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_PurchaseLevelData(), RetailConst.PurchaseLevelDataProperties::get_L3Data(), lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPaymentProperty</Name>
				<Source><![CDATA[
    private void addPaymentProperty(System.String _dataLevel, CreditCardPaymentProperties _properties, str _name, anytype _value)
    {
        if (_value)
        {
            _properties.add(CreditCardPaymentProperty::newValue(_dataLevel, _name, _value));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchaseLevelTypeAndDetails</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void setPurchaseLevelTypeAndDetails(CreditCardPaymentProperties _properties)
    {
        Retail.PaymentSDK.Portable.PurchaseLevel purchaseLevel =
            CreditCardProviderProcess::getPurchaseLevel(creditCardTypeSetup, salesTable.CurrencyCode);

        if (purchaseLevel == Retail.PaymentSDK.Portable.PurchaseLevel::Level2)
        {
            _properties.add(this.setLevel2Data());
        }
        else if (purchaseLevel == Retail.PaymentSDK.Portable.PurchaseLevel::Level3)
        {
            _properties.add(this.setLevel2Data());
            _properties.add(this.setLevel3Data());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the total sales amount.
    /// </summary>
    void setSalesTotals()
    {
        AmountCur freightEstimate;

        if (this.parmOperation() == CreditCardOperation::Authorize)
        {
            freightEstimate = roundUp(this.checkFreight(this.parmTotalAmountCur()), 0.01);
        }

        this.parmTotalAmountCur(this.parmTotalAmountCur() + freightEstimate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>submit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the actual credit card operation.
    /// </summary>
    /// <returns>
    /// true on success.
    /// </returns>
    public boolean submit()
    {
        void processAuthorize()
        {
            CreditCardPaymentProperties properties = this.getAuthRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }

            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleAuthResponse(processor.Authorize(this.createRequest(properties), null));
        }

        void processCapture(CreditCardPaymentProperties _properties, CreditCardAuthorization _authorization)
        {
            CreditCardPaymentProperties properties = this.getCaptureRequest(_properties);
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }

            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleCaptureResponse(processor.Capture(this.createRequest(properties)), _authorization);
        }

        void processRefund()
        {
            CreditCardPaymentProperties properties;
            Retail.PaymentSDK.Portable.IPaymentProcessor processor;

            if (!creditCardTrans && mcrCustPaymTable && !mcrCustPaymTable.allowAlternatePaymentMethod())
            {
                processSucceed = false;
                responseMessage = "@SYS327119";
            }
            else if (!CreditCard::sameCard(salesTable, creditCardTrans) && mcrCustPaymTable && !mcrCustPaymTable.allowAlternatePaymentMethod())
            {
                processSucceed = false;
                responseMessage = "@SYS327136"; // Credit card refunds can be processed only for the same card as the original sales order.
                displayedMessage = responseMessage;
            }
            else
            {
                properties = this.getRefundRequest();
                if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
                {
                    return;
                }

                processor = this.getProcessor(this.handleRequest(properties));

                this.handleRefundResponse(processor.Refund(this.createRequest(properties), null));
            }
        }

        void processVoid()
        {
            CreditCardPaymentProperties properties = this.getVoidRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleVoidResponse(processor.Void(this.createRequest(properties)));
        }

        void processBalance()
        {
            CreditCardPaymentProperties properties = this.getBalanceRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleBalanceResponse(processor.BalanceOnGiftCard(this.createRequest(properties), null));
        }

        void processActivation()
        {
            CreditCardPaymentProperties properties = this.getActivationRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleActivationResponse(processor.ActivateGiftCard(this.createRequest(properties), null));
        }

        void processReauthorize()
        {
            // get request properties for reauthorization e.g. this.getReauthorizationRequest()
            CreditCardPaymentProperties properties = this.getReauthorizationRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }

            // get the connector name e.g. this.handleRequest()
            CreditCardConnectorName connectorName = this.handleRequest(properties);

            // get the IPaymentProcessor instance e.g. this.getProcessor()
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(connectorName);

            // create the request using properties e.g. this.createRequest()
            Retail.PaymentSDK.Portable.Request request = this.createRequest(properties);

            // call the /Reauthorize SDK method e.g. processor.Reauthorize()
            Retail.PaymentSDK.Portable.Response response = processor.Reauthorize(request, null);

            // handle the reauthorization response e.g. this.handleReauthorizationResponse()
            this.handleReauthorizationResponse(response);
        }

        if (this.parmOperation() != CreditCardOperation::Refund && this.parmTotalAmountCur() < 0)
        {
            processSucceed = false;
            responseMessage = "@SYS327120";
            return true;
        }

        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);
        System.Exception exception;

        eventWriter.EventWritePaymentOperationProcessingStart(enum2Str(this.parmOperation()), salesTable.RecId, mcrCustPaymTable.RecId, creditCardTrans.RecId, creditCardCust.RecId);
        perm.assert();

        try
        {
            switch (this.parmOperation())
            {
                case CreditCardOperation::Authorize:
                    processAuthorize();
                    break;
                case CreditCardOperation::CaptureAfterAuthorize:
                    var properties = this.getCardToken(creditCardTrans, false);

                    //we are checking the non-recurring token flight since we did not check processSucceed before
                    if (this.processSucceed() || !RetailNonRecurringTokenFeatureExposure::isEnabled())
                    {
                        processCapture(properties, creditCardTrans.Authorization);
                    }
                    break;
                case CreditCardOperation::Refund:
                    processRefund();
                    break;
                case CreditCardOperation::Void:
                    processVoid();
                    break;
                case CreditCardOperation::AuthorizeAndCapture:
                    processAuthorize();
                    if (this.processSucceed())
                    {
                        this.recordAuthorizationForIncrementalCapture();
                        processCapture(providerResult.parmProperties(), providerResult.parmAuthorization());
                    }
                    break;
                case CreditCardOperation::Balance:
                    processBalance();
                    break;
                case CreditCardOperation::Activation:
                    processActivation();
                    break;
                case CreditCardOperation::Reauthorize:
                    processReauthorize();
                    break;
                default:
                    processSucceed = false;
                    responseMessage = strFmt("@SYS122465", this.parmOperation()); // "Current version doesn't handle credit card '%1'."
                    break;
            }
        }
        catch(Exception::CLRError)
        {
            processSucceed = false;
            responseMessage = this.getClrExceptionMessage();
            displayedMessage = "@SYS116968";
        }
        catch(exception)
        {
            eventWriter.EventWritePaymentProcessingException(exception.GetType().ToString(), exception.StackTrace, '', '');
            processSucceed = false;
            displayedMessage = "@SYS34720";
            if (!responseMessage)
            {
                responseMessage = displayedMessage;
            }
        }

        CodeAccessPermission::revertAssert();

        eventWriter.EventWritePaymentOperationProcessingEnd(enum2Str(this.parmOperation()), this.processSucceed());

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordAuthorizationForIncrementalCapture</Name>
				<Source><![CDATA[
    private void recordAuthorizationForIncrementalCapture()
    {
        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            // Need to record authorization in CreditCardAuthTrans
            this.parmOperation(CreditCardOperation::Authorize);
            // Do not have access to description so empty string will use default description.
            this.createProcessResponse('');

            // Now process capture, with its own tracking id.
            this.parmMCRPaymentTrackingId(this.getMCRPaymentTrackingId());
            // Originally was using CaptureAfterAuthorize but this might impact customization.
            this.parmOperation(CreditCardOperation::AuthorizeAndCapture);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFailedDescription</Name>
				<Source><![CDATA[
    private void updateFailedDescription(RefRecId _creditCardAuthTransRecId, str _additionalDescription)
    {
        if (_additionalDescription)
        {
            ttsbegin;

            CreditCardAuthTrans ccAuthTransUpdate = CreditCardAuthTrans::find(_creditCardAuthTransRecId, true);
            ccAuthTransUpdate.Description += ' ' + _additionalDescription;
            ccAuthTransUpdate.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the sales table.
    /// </summary>
    /// <returns>
    ///    true if the sales table is updated successfully; otherwise, false.
    /// </returns>
    public boolean updateSalesTable()
    {
        return CreditCard::updateSalesTable(salesTable.RecId, providerResult, this.processSucceed());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAVSLevelNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines address verification level needed based on customer or credit card processor settings.
    /// </summary>
    /// <param name = "_custTable">The customer table record.</param>
    /// <param name = "_accountSetup">The credit card processor settings record.</param>
    /// <returns></returns>
    protected CreditCardMSAVSDetailCode getAVSLevelNeeded(CustTable _custTable, CreditCardAccountSetup _accountSetup)
    {
        if (_custTable.CreditCardAddressVerification == CreditCardAddressVerification::Yes)
        {
            switch (_custTable.CreditCardAddressVerificationLevel)
            {
                case CreditCardAddressVerificationLevel::Accept:
                    return CreditCardMSAVSDetailCode::None;
                case CreditCardAddressVerificationLevel::AccountHolderName:
                    return CreditCardMSAVSDetailCode::AccountHolderName;
                case CreditCardAddressVerificationLevel::BillingAddress:
                    return CreditCardMSAVSDetailCode::BillingAddress;
                case CreditCardAddressVerificationLevel::BillingPostalCode:
                    return CreditCardMSAVSDetailCode::BillingPostalCode;
            }
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        else
        {
            return _accountSetup.AddressVerificationLevel;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVoidNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if void of authorization is needed, either when AVS result is not returned or when sufficient level wasn't reached.
    /// </summary>
    /// <param name = "_addressVerificationResult">Address verification result.</param>
    /// <returns>The boolean value indicating if void of authorization is needed.</returns>
    protected boolean isVoidNeeded(CreditCardAddressVerificationResult _addressVerificationResult)
    {
        boolean voidPreAuth = false;

        CustTable custTable = CustTable::find(salesTable.CustAccount);

        if (_addressVerificationResult == CreditCardAddressVerificationResult::Returned)
        {
            CreditCardMSAVSDetailCode avsLevelNeeded = this.getAVSLevelNeeded(custTable, accountSetup);

            CreditCardMSAVSDetailCode avsDetailValue = providerResult.parmAvsDetail();

            voidPreAuth = avsDetailValue < avsLevelNeeded;
        }
        else
        {
            if (custTable.CreditCardAddressVerification == CreditCardAddressVerification::Yes)
            {
                voidPreAuth = custTable.CreditCardAddressVerificationVoid;
            }
            else
            {
                voidPreAuth = accountSetup.AddressVerificationVoidUnknown;
            }
        }

        return voidPreAuth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAVSDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returnes AVS result description in a readable way.
    /// </summary>
    /// <param name = "_addressVerificationResult">Address verification result.</param>
    /// <returns>Description text.</returns>
    protected str getAVSDescription(CreditCardAddressVerificationResult _addressVerificationResult)
    {
        str avsDescription = "@SYS327115";

        // Set the AVS description.
        switch (_addressVerificationResult)
        {
            case CreditCardAddressVerificationResult::Returned:
                CreditCardMSAVSDetailCode avsDetailValue = providerResult.parmAvsDetail();
                switch (avsDetailValue)
                {
                    case CreditCardMSAVSDetailCode::None:
                        avsDescription = strFmt(avsDescription, "@SYS327139");
                        break;
                    case CreditCardMSAVSDetailCode::AccountHolderName:
                        avsDescription = strFmt(avsDescription, "@SYS327116");
                        break;
                    case CreditCardMSAVSDetailCode::BillingAddress:
                        avsDescription = strFmt(avsDescription, "@SYS327117");
                        break;
                    case CreditCardMSAVSDetailCode::BillingPostalCode:
                        avsDescription = strFmt(avsDescription, "@SYS327118");
                        break;
                }
                break;
            case CreditCardAddressVerificationResult::NotReturned:
                avsDescription = strFmt(avsDescription, "@SYS327121");
                break;
            case CreditCardAddressVerificationResult::None:
                avsDescription = strFmt(avsDescription, "@SYS327122");
                break;
            case CreditCardAddressVerificationResult::VerificationNotSupported:
                avsDescription = strFmt(avsDescription, "@SYS327123");
                break;
            case CreditCardAddressVerificationResult::SystemUnavailable:
                avsDescription = strFmt(avsDescription, "@SYS327124");
                break;
        }
        return avsDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAVS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensure AVS reached the requested level.
    /// </summary>
    /// <returns>
    /// true if the AVS was successful.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An unknown AVS level was encountered.
    /// </exception>
    protected boolean validateAVS()
    {
        if (this.processSucceed() && this.parmOperation() == CreditCardOperation::Authorize && this.checkForAddressVerification())
        {
            // Get the successful authorization.
            CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::findValidPreApproval(salesTable.SalesId);

            str avsDescription = this.getAVSDescription(creditCardAuthTrans.AddressVerificationResult);

            if (this.isVoidNeeded(creditCardAuthTrans.AddressVerificationResult))
            {
                // The authorization was processed successfully but AVS failed.
                // The processor settings were setup to void on AVS failure.
                CreditCardProcess::doVoidAuth(creditCardAuthTrans, false, avsDescription);

                processSucceed = false;

                responseMessage = "@SYS327125";

                displayedMessage = responseMessage;
            }

            // Update the description with the AVS details.
            this.updateFailedDescription(creditCardAuthTrans.RecId, avsDescription);

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCvc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensure the CVV value was correct.
    /// </summary>
    /// <returns>
    /// true if successful.
    /// </returns>
    protected boolean validateCvc()
    {
        if (!this.processSucceed() || this.parmOperation() != CreditCardOperation::Authorize || !this.checkForCardVerificationValue())
        {
            return true;
        }

        CreditCardMSCVCResultCode cvcResult = providerResult.parmCvcResult();
        if (cvcResult == CreditCardMSCVCResultCode::Success)
        {
            return true;
        }

        // If CVV is blank and blank is allow, consider it success
        if (strLen(strRTrim(this.parmCardVerificationValue())) == 0 && accountSetup.CardVerificationCheckAllowBlank)
        {
            return true;
        }

        CreditCardAuthTrans authTrans = CreditCardAuthTrans::findValidPreApproval(salesTable.SalesId);

        processSucceed = false;

        str description = strFmt("@SYS327113", new DictEnum(enumNum(CreditCardMSCVCResultCode)).value2Label(cvcResult));

        // The preauth was processed successfully but CVV failed.
        CreditCardProcess::doVoidAuth(authTrans, false, description);

        responseMessage = "@SYS327138";
        displayedMessage = description;

        // Update the description with the CVC details
        this.updateFailedDescription(authTrans.RecId, description);

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check AVS and CVV values if needed.
    /// </summary>
    /// <returns>
    /// true if successful.
    /// </returns>
    protected boolean validateTransaction()
    {
        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();

        if (this.validateCvc())
        {
            this.validateAVS();
        }

        CodeAccessPermission::revertAssert();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CreditCardProviderProcess construct()
    {
        return new CreditCardProviderProcess();
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertSystemDecimalToAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a decimal value to type amount.
    /// </summary>
    /// <param name="_value">
    ///    The decimal value that must be converted.
    /// </param>
    /// <returns>
    ///    The decimal number converted to amount type.
    /// </returns>
    public static Amount convertSystemDecimalToAmount(System.Decimal _value)
    {
        if (_value)
        {
            return any2real(_value.ToString());
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsoCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert an AX currency code to an ISO currency code.
    /// </summary>
    /// <param name="_currencyCode">
    /// A currency code.
    /// </param>
    /// <returns>
    /// An ISO currency code.
    /// </returns>
    public static CurrencyCodeISO getIsoCurrency(CurrencyCode _currencyCode)
    {
        return (select CurrencyCodeISO from currency where currency.CurrencyCode == _currencyCode).CurrencyCodeISO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the required purchase detail level.
    /// </summary>
    /// <param name="_creditCardTypeSetup">
    /// A <c>CreditCardTypeSetup</c> table record.
    /// </param>
    /// <param name="_currencyCode">
    /// A currency code.
    /// </param>
    /// <returns>
    /// The purchase detail level.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An unknown purchase detail level was encountered.
    /// </exception>
    public static Retail.PaymentSDK.Portable.PurchaseLevel getPurchaseLevel(CreditCardTypeSetup _creditCardTypeSetup, CurrencyCode _currencyCode)
    {
        CreditCardTypeCurrency creditCardTypeCurrency = CreditCardTypeCurrency::find(_creditCardTypeSetup, _currencyCode);

        if (creditCardTypeCurrency.DataSupport == CreditCardCurrencyDataSupport::None)
        {
            switch (_creditCardTypeSetup.DataSupport)
            {
                case CreditCardDataSupport::Level1:
                    return Retail.PaymentSDK.Portable.PurchaseLevel::Level1;
                case CreditCardDataSupport::Level2:
                    return Retail.PaymentSDK.Portable.PurchaseLevel::Level2;
                case CreditCardDataSupport::Level3:
                    return Retail.PaymentSDK.Portable.PurchaseLevel::Level3;
            }
        }
        else
        {
            switch (creditCardTypeCurrency.DataSupport)
            {
                case CreditCardCurrencyDataSupport::Level1:
                    return Retail.PaymentSDK.Portable.PurchaseLevel::Level1;
                case CreditCardCurrencyDataSupport::Level2:
                    return Retail.PaymentSDK.Portable.PurchaseLevel::Level2;
                case CreditCardCurrencyDataSupport::Level3:
                    return Retail.PaymentSDK.Portable.PurchaseLevel::Level3;
            }
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    /// Carries out all steps that are necessary to complete a credit card operation.
    /// Short circuits and returns a success if the total amount is zero and we have chosen to skip processing for zero amounts.
    /// </summary>
    /// <param name="_showSuccessMessage">
    ///    A Boolean value that specifies whether to display a message upon successful completion of the
    ///    operation.
    /// </param>
    /// <param name="_successDescriptionOverride">
    ///    A description that is logged for successful completion.
    /// </param>
    /// <returns>
    ///    true if the operation completed successfully; otherwise, false.
    /// </returns>
    public boolean process(boolean _showSuccessMessage = true, str _successDescriptionOverride = '')
    {
        if (accountSetup.DisallowZeroAmount && this.parmTotalAmountCur() == 0
            && this.operation != CreditCardOperation::Activation
            && this.operation != CreditCardOperation::Balance)
        {
            return true;
        }

        return super(_showSuccessMessage, _successDescriptionOverride);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionalData</Name>
				<Source><![CDATA[
    private CreditCardPaymentProperties setTransactionalData(str _transNamespace, CreditCardPaymentProperties _properties)
    {
        CustAccount invoiceAccount;
        CurrencyCode currencyCodeLocal;
        Num transactionId;

        if (salesTable)
        {
            invoiceAccount = salesTable.CustAccount;
            currencyCodeLocal = salesTable.CurrencyCode;
            transactionId = salesTable.SalesId;
        }
        else if (RetailMCRChannelTable::findForCurrentUser().MCREnableOrderCompletion)
        {
            // set the variables based on transaction to add to the properties
            invoiceAccount = this.mcrGetInvoiceAccount();
            currencyCodeLocal = this.mcrGetCurrencyCode();
            transactionId = this.mcrGetTransactionId();
        }

        if (this.parmMCRPaymentTrackingId() != '')
        {
            _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_PaymentTrackingId(), this.parmMCRPaymentTrackingId()));
        }

        if (this.parmAdjustAuthorizationAmount() != 0)
        {
            _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_IncrementalOffsetAmount(), this.parmAdjustAuthorizationAmount()));
        }

        if (this.parmIncrementalOffsetReference() != '')
        {
            _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_IncrementalOffsetReference(), this.parmIncrementalOffsetReference()));
        }

        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_CurrencyCode(), CreditCardProviderProcess::getIsoCurrency(currencyCodeLocal)));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_Description(), xInfo::productName()));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_ExternalCustomerId(), invoiceAccount));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_ExternalInvoiceNumber(), transactionId));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_ExternalReferenceId(), CreditCardPaymentProperty::clrString2Str(System.Guid::NewGuid().ToString())));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_IsTestMode(), accountSetup.IsTest));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_SupportCardTokenization(), #isSupportCardTokenizationYes));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::IndustryType, enum2Str(Retail.PaymentSDK.Portable.IndustryType::DirectMarketing)));

        return this.setTransactionalDataCustom(_transNamespace, _properties);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionalDataCustom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows custom credit card properties to be set.
    /// </summary>
    /// <param name = "_transNamespace">XML formatted string.</param>
    /// <param name = "_properties">Instance of <c>CreditCardPaymentProperties</c> class.</param>
    /// <returns>returns the instance of <c>CreditCardPaymentProperties</c> class.</returns>
    protected CreditCardPaymentProperties setTransactionalDataCustom(str _transNamespace, CreditCardPaymentProperties _properties)
    {
        return _properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resendLastRequest</Name>
				<Source><![CDATA[
    protected internal boolean resendLastRequest()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>