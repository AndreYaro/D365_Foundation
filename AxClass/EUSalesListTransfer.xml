<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EuSalesListTransfer</Name>
	<SourceCode>
		<Declaration><![CDATA[
class EuSalesListTransfer extends RunBaseBatch implements BatchRetryable
{
    TaxTrans           taxTrans;
    CustInvoiceJour    custInvoiceJour;
    ProjInvoiceJour    projInvoiceJour;
    CustSettlement     custSettlement;
    VendInvoiceJour    vendInvoiceJour;
    VendSettlement     vendSettlement;

    EUSalesList        euSalesList;
    QueryRun           qeuSalesList;

    boolean            includeItemSales;
    boolean            includeServiceSales;
    boolean            includeInvestmentSales;
    boolean            includeNotAssignedSales;
    boolean            includeItemPurchases;
    boolean            includeServicePurchases;
    boolean            includeInvestmentPurchases;
    boolean            includeNotAssignedPurchases;
    boolean            filterByVATDate;

    Set                invoiceJourSet;
    boolean            multiLineHandled;

    protected TaxRegistrationRecId taxRegistrationRecId;

    private boolean includeItemTransferOrder;
    private boolean includeServiceTransferOrder;
    private boolean includeInvestmentTransferOrder;
    private boolean includeNotAssignedTransferOrder;

    private boolean transferAmountsFromTaxTrans;

    private boolean includeItemTransferOrderArrival;
    private boolean includeServiceTransferOrderArrival;
    private boolean includeInvestmentTransferOrderArrival;
    private boolean includeNotAssignedTransferOrderArrival;

    #DEFINE.CurrentVersion(2)
    #LOCALMACRO.CurrentList
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>categorizeAmountMST</Name>
				<Source><![CDATA[
    protected container categorizeAmountMST(container _amounts, EUSalesListType _salesListType, AmountMST _amountMST, ModuleSalesPurch _moduleSalesPurch = ModuleSalesPurch::Sales)
    {
        AmountMST   itemAmountMST;
        AmountMST   serviceAmountMST;
        AmountMST   investmentAmountMST;
        AmountMST   notAssignedAmountMST;
        boolean     includeItem         = includeItemSales;
        boolean     includeService      = includeServiceSales;
        boolean     includeInvestment   = includeInvestmentSales;
        boolean     includeNotAssigned  = includeNotAssignedSales;

        if (_moduleSalesPurch == ModuleSalesPurch::Purch)
        {
            includeItem        = includeItemPurchases;
            includeService     = includeServicePurchases;
            includeInvestment  = includeInvestmentPurchases;
            includeNotAssigned = includeNotAssignedPurchases;
        }

        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        switch (_salesListType)
        {
            case EUSalesListType::Item              :
            //<GEELV>
            case EUSalesListType::GoodsP4Sect33_LV  :
                //</GEELV>
                if (includeItem)
                {
                    itemAmountMST += _amountMST;
                }
                break;
            case EUSalesListType::Service:
                if (includeService)
                {
                    serviceAmountMST += _amountMST;
                }
                break;
            case EUSalesListType::Investment:
                if (includeInvestment)
                {
                    investmentAmountMST += _amountMST;
                }
                break;
            default:
                if (includeNotAssigned)
                {
                    notAssignedAmountMST += _amountMST;
                }
                break;
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInvoiceTransAmounts</Name>
				<Source><![CDATA[
    protected internal container getCustInvoiceTransAmounts(container _amounts, CustInvoiceTrans _custInvoiceTrans, EUSalesListType _euSalesListType, Amount _amount)
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if (transferAmountsFromTaxTrans ||
            (custInvoiceJour.InvoiceAmountMST + taxTrans.TaxAmount) != -taxTrans.TaxBaseAmount)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.processMultiLineJournal(
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST]);

            // This CustInvoiceJour (not just CustInvoiceTrans) record has been handled
            multiLineHandled = true;
        }
        else
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.markupTransAmounts(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _custInvoiceTrans.TableId,
                _custInvoiceTrans.RecId);

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.categorizeAmountMST(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _euSalesListType,
                _amount);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>custInvoiceJourAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the accounting currency amounts by <c>EUSalesListType</c> object for the lines of a
    ///    <c>CustInvoiceJour</c> record.
    /// </summary>
    /// <param name="_custInvoiceJour">
    ///    The <c>CustInvoiceJour</c> record.
    /// </param>
    /// <param name="_reversing">
    ///    Indicates type of the transactions to be selected; optional.
    /// </param>
    /// <returns>
    ///    A container with four accounting currency amounts in this order: Item, Service, Investment, and
    ///    NotAssigned.
    /// </returns>
    public container custInvoiceJourAmounts(CustInvoiceJour _custInvoiceJour = custInvoiceJour, boolean _reversing = false)
    {
        CustInvoiceTrans    custInvoiceTrans;
        TaxItemGroupHeading taxItemGroupHeading;
        TaxDocumentRowTransaction taxDocRowTrans;
        TaxDocumentRowTransaction_W taxDocRowTrans_w;
        TaxGroupData        taxGroupData;
        TaxTable            taxTable;
        TaxOnItem           taxOnItem;
        AmountMST           itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        RecId               previousRecId;
        TaxTrans            taxTransLocal;
        
        multiLineHandled = false;

        if(TaxDocumentUtils::existTaxDocumentForJournal(tableNum(CustInvoiceJour), _custInvoiceJour.RecId))
        {
            // if the invoice was posted with GTE framework
            while select LineAmountMST, TaxGroup, TaxItemGroup from custInvoiceTrans
              order by custInvoiceTrans.RecId
              where custInvoiceTrans.SalesId             == _custInvoiceJour.SalesId
                 && custInvoiceTrans.InvoiceDate         == _custInvoiceJour.InvoiceDate
                 && custInvoiceTrans.InvoiceId           == _custInvoiceJour.InvoiceId
                 && custInvoiceTrans.NumberSequenceGroup == _custInvoiceJour.NumberSequenceGroup
                 && ((custInvoiceTrans.ReversedRecId     == 0 && !_reversing)      || (custInvoiceTrans.ReversedRecId != 0 && _reversing))
                 && (custInvoiceTrans.ParentRecId        == _custInvoiceJour.RecId || !custInvoiceTrans.ParentRecId)
                join TaxCode, NotEUSalesList   from taxTable
                    where taxTable.TaxCode == taxTrans.TaxCode
                        && taxTable.NotEUSalesList == 0
                join RecId from taxDocRowTrans
                    where taxDocRowTrans.TransactionJourLineTableId == tableNum(CustInvoiceTrans)
                        && taxDocRowTrans.TransactionJourLIneRecId == custInvoiceTrans.RecId
                join euSalesListType from taxDocRowTrans_w
                    where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
                join TaxBaseAmountCur from taxTransLocal
                    where taxTransLocal.SourceTableId == custInvoiceTrans.TableId
                        && taxTransLocal.SourceRecId == custInvoiceTrans.RecId
                        && taxTransLocal.TaxID == taxTrans.TaxID
            {
                if (previousRecId != custInvoiceTrans.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getCustInvoiceTransAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        custInvoiceTrans,
                        taxDocRowTrans_w.EUSalesListType,
                        -taxTransLocal.TaxBaseAmountCur);

                    if(multiLineHandled)
                    {
                        break;
                    }
                    previousRecId = custInvoiceTrans.RecId;
                }
            }
        }
        else
        {
            // if the invoice was posted without GTE framework
            while select LineAmountMST, TaxGroup, TaxItemGroup from custInvoiceTrans
              order by custInvoiceTrans.RecId
              where custInvoiceTrans.SalesId             == _custInvoiceJour.SalesId
                 && custInvoiceTrans.InvoiceDate         == _custInvoiceJour.InvoiceDate
                 && custInvoiceTrans.InvoiceId           == _custInvoiceJour.InvoiceId
                 && custInvoiceTrans.NumberSequenceGroup == _custInvoiceJour.NumberSequenceGroup
                 && ((custInvoiceTrans.ReversedRecId     == 0 && !_reversing)      || (custInvoiceTrans.ReversedRecId != 0 && _reversing))
                 && (custInvoiceTrans.ParentRecId        == _custInvoiceJour.RecId || !custInvoiceTrans.ParentRecId)
                join euSalesListType           from taxItemGroupHeading
                    where taxItemGroupHeading.TaxItemGroup == custInvoiceTrans.TaxItemGroup
                        || taxItemGroupHeading.TaxItemGroup == taxTrans.TaxItemGroup
                join TaxCode                   from taxOnItem
                    where taxOnItem.TaxItemGroup           == taxItemGroupHeading.TaxItemGroup
                join TaxCode, NotEUSalesList   from taxTable
                    where taxTable.TaxCode                 == taxOnItem.TaxCode
                        && taxTable.NotEUSalesList          == 0
                join TaxGroup, TaxCode         from taxGroupData
                    where taxGroupData.TaxCode             == taxTable.TaxCode
                        && (taxGroupData.TaxGroup           == custInvoiceTrans.TaxGroup
                        || taxGroupData.TaxGroup        == taxTrans.TaxGroup)
            {
                if (previousRecId != custInvoiceTrans.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getCustInvoiceTransAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        custInvoiceTrans,
                        taxItemGroupHeading.euSalesListType,
                        custInvoiceTrans.LineAmountMST);

                    if(multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = custInvoiceTrans.RecId;
                }
            }

        }

        if (!multiLineHandled)
        {
            if (custInvoiceJour.EndDisc)
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.distributeDiscount(
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                    custInvoiceJour.EndDiscMST,
                    custInvoiceJour.SalesBalanceMST);
            }

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.markupTransAmounts(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _custInvoiceJour.TableId,
                _custInvoiceJour.RecId);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransferJourAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the amounts by <c>EUSalesListType</c> object for the lines of a <c>InventTransferJour</c> record.
    /// </summary>
    /// <param name="_inventTransferJour">
    ///    The <c>InventTransferJour</c> record.
    /// </param>
    /// <returns>
    ///    A container with four accounting currency amounts in this order: Item, Service, Investment, and NotAssigned.
    /// </returns>
    public container inventTransferJourAmounts(InventTransferJour _inventTransferJour)
    {
        TaxItemGroupHeading taxItemGroupHeading;
        TaxTrans taxTransLocal;
        AmountCur itemAmountCur;
        AmountCur serviceAmountCur;
        AmountCur investmentAmountCur;
        AmountCur notAssignedAmountCur;
        TaxTable taxTable;

        boolean includeItem = (includeItemTransferOrder && _inventTransferJour.UpdateType == InventTransferUpdateType::Shipment)
                        || (includeItemTransferOrderArrival && _inventTransferJour.UpdateType == InventTransferUpdateType::Receive);

        boolean includeService = (includeServiceTransferOrder && _inventTransferJour.UpdateType == InventTransferUpdateType::Shipment)
                        || (includeServiceTransferOrderArrival && _inventTransferJour.UpdateType == InventTransferUpdateType::Receive);

        boolean includeInvestment = (includeInvestmentTransferOrder && _inventTransferJour.UpdateType == InventTransferUpdateType::Shipment)
                        || (includeInvestmentTransferOrderArrival && _inventTransferJour.UpdateType == InventTransferUpdateType::Receive);

        boolean includeNotAssigned = (includeNotAssignedTransferOrder && _inventTransferJour.UpdateType == InventTransferUpdateType::Shipment)
                        || (includeNotAssignedTransferOrderArrival && _inventTransferJour.UpdateType == InventTransferUpdateType::Receive);

        while select TaxBaseAmountCur from taxTransLocal
            where taxTransLocal.Voucher == _inventTransferJour.VoucherId
                && taxTransLocal.TransDate == _inventTransferJour.TransDate
            join EUSalesListType from taxItemGroupHeading
                where taxItemGroupHeading.TaxItemGroup == taxTranslocal.TaxItemGroup
            join NotEUSalesList from taxTable
                where taxTable.TaxCode == taxTranslocal.TaxCode
                    && taxTable.NotEUSalesList == NoYes::No
        {
            Amount baseAmount = _inventTransferJour.UpdateType == InventTransferUpdateType::Shipment ?
                -taxTransLocal.TaxBaseAmountCur :
                taxTransLocal.TaxBaseAmountCur;

            switch (taxItemGroupHeading.EUSalesListType)
            {
                case EUSalesListType::Item:
                case EUSalesListType::GoodsP4Sect33_LV:
                    if (includeItem)
                    {
                        itemAmountCur += baseAmount;
                    }
                    break;
                case EUSalesListType::Service:
                    if (includeService)
                    {
                        serviceAmountCur += baseAmount;
                    }
                    break;
                case EUSalesListType::Investment:
                    if (includeInvestment)
                    {
                        investmentAmountCur += baseAmount;
                    }
                    break;
                default:
                    if (includeNotAssigned)
                    {
                        notAssignedAmountCur += baseAmount;
                    }
                    break;
            }
        }

        return [itemAmountCur, serviceAmountCur, investmentAmountCur, notAssignedAmountCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>custSettlementsAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the accounting currency amounts of the lines that are connected to a
    ///    <c>CustSettlement</c> record.
    /// </summary>
    /// <param name="_custInvoiceJour">
    ///    The <c>CustInvoiceJour</c> record that is connected to the <c>CustSettlement</c> record, if one
    ///    exists.
    /// </param>
    /// <param name="_projInvoiceJour">
    ///    The <c>ProjInvoiceJour</c> record that is connected to the <c>CustSettlement</c> record, if one
    ///    exists.
    /// </param>
    /// <returns>
    ///    A container that the <c>Item</c>, <c>Service</c>, <c>Investment</c>, and <c>NotAssigned</c> values
    ///    in that order that represent accounting currency amounts.
    /// </returns>
    public container custSettlementsAmounts(CustInvoiceJour _custInvoiceJour, ProjInvoiceJour _projInvoiceJour)
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST, totalAmountMST, utilizedCashDiscMST;
        real item, service, investment, notAssigned;

        if (_custInvoiceJour)
        {
            totalAmountMST = _custInvoiceJour.InvoiceAmountMST - _custInvoiceJour.SumTaxMST;
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.custInvoiceJourAmounts(_custInvoiceJour);
        }
        else if (_projInvoiceJour)
        {
            totalAmountMST = _projInvoiceJour.amountMST(_projInvoiceJour.InvoiceAmount);
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.projInvoiceJourAmounts(_projInvoiceJour);
        }

        if (totalAmountMST)
        {
            if (transferAmountsFromTaxTrans || FeatureStateProvider::isFeatureEnabled(EUSalesListTransAmountsFromTaxTrans_Feature::instance()))
            {
                CustTrans custTransCashDiscount;

                select firstonly Voucher, TransDate from custTransCashDiscount
                    where custTransCashDiscount.OffsetRecId == custSettlement.TransRecId
                        && custTransCashDiscount.Voucher == custSettlement.SettlementVoucher
                        && custTransCashDiscount.TransType == LedgerTransType::CashDiscount;

                if (custTransCashDiscount)
                {
                    utilizedCashDiscMST = this.calcCashDiscount(custTransCashDiscount.Voucher, custTransCashDiscount.TransDate);
                }
            }

            if (!utilizedCashDiscMST)
            {
                utilizedCashDiscMST = CurrencyExchangeHelper::amountCur2MST(custSettlement.UtilizedCashDisc, custSettlement.custVendTrans().CurrencyCode, CustTrans::findVoucherDateType(custSettlement.SettlementVoucher, custSettlement.TransDate, LedgerTransType::CashDiscount).ExchRate);
            }

            item = itemAmountMST / totalAmountMST;
            service = serviceAmountMST / totalAmountMST;
            investment = investmentAmountMST / totalAmountMST;
            notAssigned = notAssignedAmountMST / totalAmountMST;

            itemAmountMST = utilizedCashDiscMST * item;
            serviceAmountMST = utilizedCashDiscMST * service;
            investmentAmountMST = utilizedCashDiscMST * investment;
            notAssignedAmountMST = utilizedCashDiscMST * notAssigned;
        }

        return [-itemAmountMST, -serviceAmountMST, -investmentAmountMST, -notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>date2Quarter</Name>
				<Source><![CDATA[
    Quarter date2Quarter(date _date)
    {
        int     intQuarter = date2Qtr(_date);
        Quarter quarter;

        switch (intQuarter)
        {
            case 1:
                quarter = Quarter::Q1;
                break;
            case 2:
                quarter = Quarter::Q2;
                break;
            case 3:
                quarter = Quarter::Q3;
                break;
            case 4:
                quarter = Quarter::Q4;
                break;
        }

        return quarter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        DialogRunbase dialog = Dialog::newFormnameRunbase(formstr(EUSalesListSelection), this);
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeDiscount</Name>
				<Source><![CDATA[
    protected container distributeDiscount(container _amounts, AmountMST _discountAmountMST, AmountMST _totalAmountMST)
    {
        real item, service, investment, notAssigned;
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;

        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if (_totalAmountMST)
        {
            item = itemAmountMST / _totalAmountMST;
            service = serviceAmountMST / _totalAmountMST;
            investment = investmentAmountMST / _totalAmountMST;
            notAssigned = notAssignedAmountMST / _totalAmountMST;

            itemAmountMST -= _discountAmountMST * item;
            serviceAmountMST -= _discountAmountMST * service;
            investmentAmountMST -= _discountAmountMST * investment;
            notAssignedAmountMST -= _discountAmountMST * notAssigned;
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCountryRegionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets item number from customers invoice journal.
    /// </summary>
    /// <returns>
    /// countryRegionId, from invoice account or delivery postal address.
    /// </returns>
    protected LogisticsAddressCountryRegionId getCountryRegionId()
    {
        LogisticsAddressCountryRegionId countryRegionId = custInvoiceJour.ReturnItemNum ? LogisticsPostalAddress::findRecId(custInvoiceJour.InvoicePostalAddress).CountryRegionId
                                                        : LogisticsPostalAddress::findRecId(custInvoiceJour.DeliveryPostalAddress).CountryRegionId;

        return countryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryFilterValues</Name>
				<Source><![CDATA[
    public container getQueryFilterValues()
    {
        QueryBuildDataSource custQBDS;
        QueryBuildDataSource projQBDS;
        QueryBuildDataSource vendQBDS;
        QueryBuildDataSource taxQBDS;

        Query query;
        container values;

        query = qeuSalesList.query();
        custQBDS = qeuSalesList.query().dataSourceTable(tableNum(CustInvoiceJour));
        projQBDS = qeuSalesList.query().dataSourceTable(tableNum(ProjInvoiceJour));
        vendQBDS = qeuSalesList.query().dataSourceTable(tableNum(VendInvoiceJour));

        values = [SysQuery::findOrCreateRange(custQBDS, fieldNum(CustInvoiceJour, InvoiceDate)).value(),
                    SysQuery::findOrCreateRange(custQBDS, fieldNum(CustInvoiceJour, Listcode)).value(),
                    SysQuery::findOrCreateRange(projQBDS, fieldNum(ProjInvoiceJour, InvoiceDate)).value(),
                    SysQuery::findOrCreateRange(projQBDS, fieldNum(ProjInvoiceJour, ListCodeId)).value(),
                    SysQuery::findOrCreateRange(vendQBDS, fieldNum(VendInvoiceJour, InvoiceDate)).value(),
                    SysQuery::findOrCreateRange(vendQBDS, fieldNum(VendInvoiceJour, Listcode)).value()];

        if (TaxParameters::reportUseVatDueDate_W())
        {
            taxQBDS = qeuSalesList.query().dataSourceTable(tableNum(TaxTrans_W));
            values += SysQuery::findOrCreateRange(taxQBDS, fieldNum(TaxTrans_W, VatDueDate_W)).value();

            if (taxQBDS.findRange(fieldNum(TaxTrans_W, VatDueDate_W)).value())
            {
                taxQBDS.joinMode(JoinMode::InnerJoin);
                filterByVATDate = true;
            }
        }
        else
        {
            values += "";
        }

        if (TaxIntegrationUtils::isTaxInTransferOrderEnabled())
        {
            QueryBuildDataSource inventTransferQBDS = qeuSalesList.query().dataSourceTable(tableNum(InventTransferJour));

            values += [SysQuery::findOrCreateRange(inventTransferQBDS, fieldNum(InventTransferJour, TransDate)).value(),
                    SysQuery::findOrCreateRange(inventTransferQBDS, fieldNum(InventTransferJour, Listcode)).value()];
        }

        return values;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxCodesToInclude</Name>
				<Source><![CDATA[
    private str getTaxCodesToInclude()
    {
        TaxTable        taxTable;
        str             taxCodes;

        while select TaxCode from taxTable
              where  taxTable.NotEUSalesList == NoYes::No
        {
            taxCodes += queryValue(taxTable.TaxCode) + ',';
        }

        return subStr(taxCodes,1,strLen(taxCodes)-1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromCustInvoiceJour</Name>
				<Source><![CDATA[
    void loadFromCustInvoiceJour()
    {
        EUSalesList reversedEuSalesList;
        CustInvoiceJour reversedCustInvoiceJour;
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;

        if (!custInvoiceJour.euSalesList
            && custInvoiceJour.invoiceIdDisplay()
            && !custInvoiceJour.ReversedRecId)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.custInvoiceJourAmounts(custInvoiceJour);

            if (itemAmountMST || serviceAmountMST || investmentAmountMST || notAssignedAmountMST)
            {
                LogisticsAddressCountryRegionId countryRegionId = this.getCountryRegionId();

                // <GEEU>
                if (filterByVATDate)
                {
                    euSalesList.TransDate        = custInvoiceJour.vatDueDate_W();
                }
                else
                {
                    euSalesList.TransDate        = custInvoiceJour.InvoiceDate;
                }
                // </GEEU>
                euSalesList.AccountNum           = custInvoiceJour.InvoiceAccount;
                euSalesList.CountryRegionId      = this.resolveCountryRegionId(countryRegionId, custInvoiceJour.PartyTaxID);
                
                VATNum vatNum = custInvoiceJour.vatNum ? custInvoiceJour.vatNum : CustTable::find(custInvoiceJour.InvoiceAccount).getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, custInvoiceJour.InvoiceDate);
                euSalesList.VATNum               = this.resolveVATNum(vatNum, custInvoiceJour.PartyTaxID);

                euSalesList.AmountMST            = itemAmountMST;
                euSalesList.ServiceAmountMST     = serviceAmountMST;
                euSalesList.InvestmentAmountMST  = investmentAmountMST;
                euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
                euSalesList.Status               = ListStatus::Include;
                euSalesList.Invoice              = custInvoiceJour.InvoiceId;
                euSalesList.Listcode             = custInvoiceJour.Listcode;
                euSalesList.TransQuarter         = this.quarter();
                euSalesList.TransYear            = this.year();
                euSalesList.SeqNum               += 1;
                euSalesList.TaxID                = taxTrans.TaxID;
                euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
                euSalesList.insert();

                if (!invoiceJourSet.in([custInvoiceJour.RecId, tableNum(CustInvoiceJour)]))
                {
                    custInvoiceJour.euSalesList = euSalesList.DispatchId;
                    custInvoiceJour.update();

                    invoiceJourSet.add([custInvoiceJour.RecId, tableNum(CustInvoiceJour)]);
                }
            }
        }
        else if (custInvoiceJour.ReversedRecId != 0 && !custInvoiceJour.euSalesList && custInvoiceJour.invoiceIdDisplay())
        {
            //If this journal record is a reversal, the original EuSalesList record can be found and used
            select count(RecId), sum(AmountMST), sum(ServiceAmountMST), sum(InvestmentAmountMST), sum(NotAssignedAmountMST) from reversedEuSalesList
                exists join reversedCustInvoiceJour
                    where reversedCustInvoiceJour.InvoiceId == reversedEuSalesList.Invoice
                        && reversedCustInvoiceJour.euSalesList == reversedEuSalesList.DispatchId
                        && reversedCustInvoiceJour.RecId == custInvoiceJour.ReversedRecId;

            if (reversedEuSalesList.RecId != 1) // Cannot recognize correct invoice or invoice has not been loaded yet due to the tax transaction's sorting order
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.custInvoiceJourAmounts(custInvoiceJour, true);
                if (!itemAmountMST && !serviceAmountMST && !investmentAmountMST && !notAssignedAmountMST)
                {
                    return;
                }
            }
            else
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = [-reversedEuSalesList.AmountMST,
                                                                                                    -reversedEuSalesList.ServiceAmountMST,
                                                                                                    -reversedEuSalesList.InvestmentAmountMST,
                                                                                                    -reversedEuSalesList.NotAssignedAmountMST];
            }

            euSalesList.TransDate            = custInvoiceJour.InvoiceDate;
            euSalesList.AccountNum           = custInvoiceJour.InvoiceAccount;
            euSalesList.CountryRegionId      = this.resolveCountryRegionId(LogisticsPostalAddress::findRecId(custInvoiceJour.DeliveryPostalAddress).CountryRegionId, custInvoiceJour.PartyTaxID);
            euSalesList.VATNum               = this.resolveVATNum(custInvoiceJour.VATNum, custInvoiceJour.PartyTaxID);
            euSalesList.AmountMST            = itemAmountMST;
            euSalesList.ServiceAmountMST     = serviceAmountMST;
            euSalesList.InvestmentAmountMST  = investmentAmountMST;
            euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
            euSalesList.Status               = ListStatus::Include;
            euSalesList.Invoice              = custInvoiceJour.InvoiceId;
            euSalesList.Listcode             = custInvoiceJour.Listcode;
            euSalesList.TransQuarter         = this.quarter();
            euSalesList.TransYear            = this.year();
            euSalesList.SeqNum               += 1;
            euSalesList.TaxID                = taxTrans.TaxID;
            euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
            euSalesList.insert();

            if (!invoiceJourSet.in([custInvoiceJour.RecId, tableNum(CustInvoiceJour)]))
            {
                custInvoiceJour.euSalesList = euSalesList.DispatchId;
                custInvoiceJour.update();
                    
                invoiceJourSet.add([custInvoiceJour.RecId, tableNum(CustInvoiceJour)]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromCustSettlement</Name>
				<Source><![CDATA[
    void loadFromCustSettlement()
    {
        CustTrans custTrans;
        CustInvoiceJour localCustInvoiceJour;
        ProjInvoiceJour localProjInvoiceJour;
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;

        custTrans = CustTrans::find(custSettlement.TransRecId);
        localCustInvoiceJour = CustInvoiceJour::findFromCustTrans(custTrans.Invoice, custTrans.TransDate, custTrans.AccountNum);
        localProjInvoiceJour = ProjInvoiceJour::find(custTrans.Invoice, custTrans.TransDate);

        if (localCustInvoiceJour)
        {
            QueryBuildRange qbrListCodeCust = qeuSalesList.query().dataSourceTable(tableNum(CustInvoiceJour)).findRange(fieldNum(CustInvoiceJour, Listcode));
            if (qbrListCodeCust && qbrListCodeCust.value())
            {
                Query query = new Query();
                query.addDataSource(tableNum(CustInvoiceJour)).addRange(fieldNum(CustInvoiceJour, RecId)).value(queryValue(localCustInvoiceJour.RecId));
                query.dataSourceTable(tableNum(CustInvoiceJour)).addRange(fieldNum(CustInvoiceJour, Listcode)).value(qbrListCodeCust.value());

                QueryRun queryRun = new QueryRun(query);
                queryRun.next();
                localCustInvoiceJour = queryRun.get(tableNum(CustInvoiceJour));
            }
        }

        if (localProjInvoiceJour)
        {
            QueryBuildRange qbrListCodeProj = qeuSalesList.query().dataSourceTable(tableNum(ProjInvoiceJour)).findRange(fieldNum(ProjInvoiceJour, ListCodeId));
            if (qbrListCodeProj && qbrListCodeProj.value())
            {
                Query query = new Query();
                query.addDataSource(tableNum(ProjInvoiceJour)).addRange(fieldNum(ProjInvoiceJour, RecId)).value(queryValue(localProjInvoiceJour.RecId));
                query.dataSourceTable(tableNum(ProjInvoiceJour)).addRange(fieldNum(ProjInvoiceJour, ListCodeId)).value(qbrListCodeProj.value());

                QueryRun queryRun = new QueryRun(query);
                queryRun.next();
                localProjInvoiceJour = queryRun.get(tableNum(ProjInvoiceJour));
            }
        }

        if (custSettlement.UtilizedCashDisc && !custSettlement.euSalesList && (localCustInvoiceJour || localProjInvoiceJour))
        {
            //If TaxTrans is nothing, find the original
            if (taxTrans.RecId == 0)
            {
                this.findTaxTransForCustSettlement(custTrans.Voucher, custTrans.TransDate);
            }

            if (localProjInvoiceJour.RecId != 0)
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.custSettlementsAmounts(null, localProjInvoiceJour);

                euSalesList.CountryRegionId      = this.resolveCountryRegionId(LogisticsPostalAddress::findRecId(localProjInvoiceJour.DeliveryPostalAddress).CountryRegionId, localProjInvoiceJour.PartyTaxID);
                euSalesList.VATNum               = this.resolveVATNum(localProjInvoiceJour.VATNum, localProjInvoiceJour.PartyTaxID);
            }
            else if (localCustInvoiceJour.RecId != 0)
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.custSettlementsAmounts(localCustInvoiceJour, null);

                LogisticsAddressCountryRegionId countryRegionId = localCustInvoiceJour.ReturnItemNum ? LogisticsPostalAddress::findRecId(localCustInvoiceJour.InvoicePostalAddress).CountryRegionId
                                                  : LogisticsPostalAddress::findRecId(localCustInvoiceJour.DeliveryPostalAddress).CountryRegionId;

                euSalesList.CountryRegionId = this.resolveCountryRegionId(countryRegionId, localCustInvoiceJour.PartyTaxID);

                VATNum vatNum = localCustInvoiceJour.vatNum ? localCustInvoiceJour.vatNum : CustTable::find(custSettlement.AccountNum).getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, localCustInvoiceJour.InvoiceDate);
                euSalesList.VATNum = this.resolveVATNum(vatNum, localCustInvoiceJour.PartyTaxID);
            }

            if (itemAmountMST || serviceAmountMST || investmentAmountMST || notAssignedAmountMST)
            {
                if (localCustInvoiceJour)
                {
                    euSalesList.Listcode         = localCustInvoiceJour.Listcode;
                }
                else if (localProjInvoiceJour)
                {
                    euSalesList.Listcode         = localProjInvoiceJour.ListcodeId;
                }
                else
                {
                    euSalesList.Listcode             = Listcode::EUTrade;
                }
                euSalesList.Status               = ListStatus::Include;
                euSalesList.Invoice              = custTrans.Invoice;
                euSalesList.TransDate            = custSettlement.TransDate;
                euSalesList.AccountNum           = custSettlement.AccountNum;
                euSalesList.TransQuarter         = this.quarter();
                euSalesList.TransYear            = this.year();
                euSalesList.AmountMST            = itemAmountMST;
                euSalesList.ServiceAmountMST     = serviceAmountMST;
                euSalesList.InvestmentAmountMST  = investmentAmountMST;
                euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
                euSalesList.IsSettlement         = true;
                euSalesList.SeqNum               += 1;
                euSalesList.TaxID                = taxTrans.TaxID;
                euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
                euSalesList.insert();

                if (!invoiceJourSet.in([custSettlement.RecId, tableNum(CustSettlement)]))
                {
                    custSettlement.euSalesList = euSalesList.DispatchId;
                    custSettlement.update();

                    invoiceJourSet.add([custSettlement.RecId, tableNum(CustSettlement)]);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromProjInvoiceJour</Name>
				<Source><![CDATA[
    void loadFromProjInvoiceJour()
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;

        if (projInvoiceJour.ProjInvoiceId && !projInvoiceJour.euSalesList)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.projInvoiceJourAmounts();

            if (itemAmountMST || serviceAmountMST || investmentAmountMST || notAssignedAmountMST)
            {
                euSalesList.TransDate            = projInvoiceJour.InvoiceDate;
                euSalesList.AccountNum           = projInvoiceJour.InvoiceAccount;
                euSalesList.CountryRegionId      = this.resolveCountryRegionId(LogisticsPostalAddress::findRecId(projInvoiceJour.DeliveryPostalAddress).CountryRegionId, projInvoiceJour.PartyTaxID);
                euSalesList.vatNum               = this.resolveVATNum(projInvoiceJour.VATNum, projInvoiceJour.PartyTaxID);
                euSalesList.AmountMST            = itemAmountMST;
                euSalesList.ServiceAmountMST     = serviceAmountMST;
                euSalesList.InvestmentAmountMST  = investmentAmountMST;
                euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
                euSalesList.Status               = ListStatus::Include;
                euSalesList.Invoice              = projInvoiceJour.ProjInvoiceId;
                euSalesList.Listcode             = projInvoiceJour.ListCodeId;
                euSalesList.TransQuarter         = this.quarter();
                euSalesList.TransYear            = this.year();
                euSalesList.SeqNum               += 1;
                euSalesList.TaxID                = taxTrans.TaxID;
                euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
                euSalesList.insert();

                if (!invoiceJourSet.in([projInvoiceJour.RecId, tableNum(ProjInvoiceJour)]))
                {
                    projInvoiceJour.euSalesList = euSalesList.DispatchId;
                    projInvoiceJour.update();

                    invoiceJourSet.add([projInvoiceJour.RecId, tableNum(ProjInvoiceJour)]);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromVendInvoiceJour</Name>
				<Source><![CDATA[
    void loadFromVendInvoiceJour()
    {
        AmountMST  itemAmountMST;
        AmountMST  serviceAmountMST;
        AmountMST  investmentAmountMST;
        AmountMST  notAssignedAmountMST;

        if (!vendInvoiceJour.euSalesList && vendInvoiceJour.InvoiceId)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.vendInvoiceJourAmounts(vendInvoiceJour);
            if (itemAmountMST || serviceAmountMST || investmentAmountMST || notAssignedAmountMST)
            {
                // <GEEU>
                if (filterByVATDate)
                {
                    euSalesList.TransDate        = vendInvoiceJour.vatDueDate_W();
                }
                else
                {
                    euSalesList.TransDate        = vendInvoiceJour.InvoiceDate;
                }
                // </GEEU>
                euSalesList.AccountNum           = vendInvoiceJour.InvoiceAccount;
                euSalesList.CountryRegionId      = this.resolveCountryRegionId(vendInvoiceJour.vendTable_OrderAccount().postalAddress().CountryRegionId, vendInvoiceJour.PartyTaxID);

                VATNum vatNum = vendInvoiceJour.vatNum ? vendInvoiceJour.vatNum : vendInvoiceJour.vendTable_InvoiceAccount().getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, vendInvoiceJour.InvoiceDate);
                euSalesList.vatNum               = this.resolveVATNum(vatNum, vendInvoiceJour.PartyTaxID);

                euSalesList.AmountMST            = itemAmountMST;
                euSalesList.ServiceAmountMST     = serviceAmountMST;
                euSalesList.InvestmentAmountMST  = investmentAmountMST;
                euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
                euSalesList.Status               = ListStatus::Include;
                euSalesList.Invoice              = vendInvoiceJour.InvoiceId;
                euSalesList.Listcode             = vendInvoiceJour.Listcode;
                euSalesList.TransQuarter         = this.quarter();
                euSalesList.TransYear            = this.year();
                euSalesList.Direction            = ModuleSalesPurch::Purch;
                euSalesList.SeqNum               += 1;
                euSalesList.TaxID                = taxTrans.TaxID;
                euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
                euSalesList.insert();

                if (!invoiceJourSet.in([vendInvoiceJour.RecId, tableNum(VendInvoiceJour)]))
                {
                    vendInvoiceJour.euSalesList = euSalesList.DispatchId;
                    vendInvoiceJour.update();

                    invoiceJourSet.add([vendInvoiceJour.RecId, tableNum(VendInvoiceJour)]);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromVendSettlement</Name>
				<Source><![CDATA[
    void loadFromVendSettlement()
    {
        VendTrans           vendTrans;
        VendInvoiceJour     localVendInvoiceJour;
        AmountMST           itemAmountMST;
        AmountMST           serviceAmountMST;
        AmountMST           investmentAmountMST;
        AmountMST           notAssignedAmountMST;

        vendTrans               = VendTrans::find(vendSettlement.TransRecId);
        localVendInvoiceJour    = VendInvoiceJour::findFromVendTrans(vendTrans.Invoice, vendTrans.TransDate, vendTrans.AccountNum);

        if (localVendInvoiceJour)
        {
            QueryBuildRange qbrListCodeVend = qeuSalesList.query().dataSourceTable(tableNum(VendInvoiceJour)).findRange(fieldNum(VendInvoiceJour, Listcode));
            if (qbrListCodeVend && qbrListCodeVend.value())
            {
                Query query = new Query();
                query.addDataSource(tableNum(VendInvoiceJour)).addRange(fieldNum(VendInvoiceJour, RecId)).value(queryValue(localVendInvoiceJour.RecId));
                query.dataSourceTable(tableNum(VendInvoiceJour)).addRange(fieldNum(VendInvoiceJour, Listcode)).value(qbrListCodeVend.value());

                QueryRun queryRun = new QueryRun(query);
                queryRun.next();
                localVendInvoiceJour = queryRun.get(tableNum(VendInvoiceJour));
            }
        }

        if (vendSettlement.UtilizedCashDisc
            && !vendSettlement.euSalesList
            && localVendInvoiceJour
            && this.existsTaxTransForVendSettlement(vendTrans.Voucher, vendTrans.TransDate))
        {
            if (localVendInvoiceJour.RecId != 0)
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.vendSettlementsAmounts(localVendInvoiceJour);

                euSalesList.CountryRegionId      = this.resolveCountryRegionId(localVendInvoiceJour.vendTable_OrderAccount().postalAddress().CountryRegionId, localVendInvoiceJour.PartyTaxID);

                VATNum vatNum = localVendInvoiceJour.vatNum ? localVendInvoiceJour.vatNum : VendTable::find(vendSettlement.AccountNum).getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, localVendInvoiceJour.InvoiceDate);
                euSalesList.VATNum               = this.resolveVATNum(vatNum, localVendInvoiceJour.PartyTaxID);
            }

            if (itemAmountMST || serviceAmountMST || investmentAmountMST || notAssignedAmountMST)
            {
                euSalesList.Listcode             = localVendInvoiceJour.Listcode ? localVendInvoiceJour.Listcode : Listcode::EUTrade;
                euSalesList.Status               = ListStatus::Include;
                euSalesList.Invoice              = vendTrans.Invoice;
                euSalesList.TransDate            = vendSettlement.TransDate;
                euSalesList.AccountNum           = vendSettlement.AccountNum;
                euSalesList.TransQuarter         = this.quarter();
                euSalesList.TransYear            = this.year();
                euSalesList.AmountMST            = itemAmountMST;
                euSalesList.ServiceAmountMST     = serviceAmountMST;
                euSalesList.InvestmentAmountMST  = investmentAmountMST;
                euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
                euSalesList.Direction            = ModuleSalesPurch::Purch;
                euSalesList.IsSettlement         = true;
                euSalesList.SeqNum               += 1;
                euSalesList.TaxID                = taxTrans.TaxID;
                euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
                euSalesList.insert();

                if (!invoiceJourSet.in([vendSettlement.RecId, tableNum(VendSettlement)]))
                {
                    vendSettlement.euSalesList = euSalesList.DispatchId;
                    vendSettlement.update();

                    invoiceJourSet.add([vendSettlement.RecId, tableNum(VendSettlement)]);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromInventTransferJour</Name>
				<Source><![CDATA[
    private void loadFromInventTransferJour(InventTransferJour _inventTransferJour)
    {
        AmountMST  itemAmountMST;
        AmountMST  serviceAmountMST;
        AmountMST  investmentAmountMST;
        AmountMST  notAssignedAmountMST;

        if (!_inventTransferJour.euSalesList && _inventTransferJour.TransferId)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.inventTransferJourAmounts(_inventTransferJour);
            if (itemAmountMST || serviceAmountMST || investmentAmountMST || notAssignedAmountMST)
            {
                euSalesList.TransDate = _inventTransferJour.TransDate;
                euSalesList.AccountNum = '';
                euSalesList.CountryRegionId = this.resolveCountryRegionId(null, _inventTransferJour.PartyTaxID);
                euSalesList.VATNum = this.resolveVATNum(null, _inventTransferJour.PartyTaxID);

                euSalesList.AmountMST = itemAmountMST;
                euSalesList.ServiceAmountMST = serviceAmountMST;
                euSalesList.InvestmentAmountMST = investmentAmountMST;
                euSalesList.NotAssignedAmountMST = notAssignedAmountMST;
                euSalesList.Status = ListStatus::Include;
                euSalesList.Invoice = _inventTransferJour.TransferId;
                euSalesList.Listcode = _inventTransferJour.Listcode;
                euSalesList.TransQuarter = this.quarter();
                euSalesList.TransYear = this.year();

                euSalesList.Direction = _inventTransferJour.UpdateType == InventTransferUpdateType::Shipment ? ModuleSalesPurch::Sales : ModuleSalesPurch::Purch;

                euSalesList.SeqNum += 1;
                euSalesList.TaxID = taxTrans.TaxID;
                euSalesList.TaxReportingCurrencyCode = taxTrans.CurrencyCode;
                euSalesList.insert();

                if (!invoiceJourSet.in([_inventTransferJour.RecId, tableNum(InventTransferJour)]))
                {
                    _inventTransferJour.euSalesList = euSalesList.DispatchId;
                    _inventTransferJour.update();

                    invoiceJourSet.add([_inventTransferJour.RecId, tableNum(InventTransferJour)]);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupTransAmount</Name>
				<Source><![CDATA[
    private container getMarkupTransAmount(container _amounts, MarkupTrans _markupTrans, EUSalesListType _euSalesListType, ModuleSalesPurch _moduleSalesPurch)
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if (_markupTrans.isMarkupOfTypeCustVend() || _markupTrans.markupTypeItem())
        {
            AmountMST markupAmountMST = CurrencyExchangeHelper::mstAmount(_markupTrans.CalculatedAmount,
                                                                        _markupTrans.CurrencyCode,
                                                                        _markupTrans.TransDate);

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.categorizeAmountMST(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        _euSalesListType,
                        markupAmountMST,
                        _moduleSalesPurch);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTransAmounts</Name>
				<Source><![CDATA[
    protected container markupTransAmounts(container _amounts, TableId _tableId, RecId _recordId, ModuleSalesPurch _moduleSalesPurch = ModuleSalesPurch::Sales)
    {
        MarkupTrans         markupTrans;
        TaxItemGroupHeading taxItemGroupHeading;
        TaxDocumentRowTransaction taxDocRowTrans;
        TaxDocumentRowTransaction_W taxDocRowTrans_w;
        TaxOnItem           taxOnItem;
        TaxTable            taxTable;
        TaxGroupData        taxGroupData;
        AmountMST           itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        RecId               previousRecId;

        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if(TaxDocumentUtils::existTaxDocumentForJournal(_tableId, _recordId))
        {
            // if the invoice was posted with GTE framework
            while select CalculatedAmount, CurrencyCode, TransDate, MarkupCode, ModuleType from markupTrans
            where (markupTrans.TransTableId == _tableId && markupTrans.TransRecId == _recordId)
               || (markupTrans.OrigTableId == _tableId && markupTrans.OrigRecId == _recordId)
               && !markupTrans.IsDeleted
            join RecId from  taxDocRowTrans
                where taxDocRowTrans.TransactionJourLineTableId == _tableId
                    && taxDocRowTrans.TransactionJourLineRecId == _recordId
            join euSalesListType from taxDocRowTrans_w
                where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
            join NotEUSalesList  from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                   && taxTable.NotEUSalesList == 0
            {
                if (previousRecId != markupTrans.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getMarkupTransAmount(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        markupTrans,
                        taxDocRowTrans_w.euSalesListType,
                        _moduleSalesPurch);

                    previousRecId = markupTrans.RecId;
                }
            }
        }
        else
        {
            // if the invoice was posted without GTE framework
            while select CalculatedAmount, CurrencyCode, TransDate, MarkupCode, ModuleType from markupTrans
                where (markupTrans.TransTableId == _tableId && markupTrans.TransRecId == _recordId)
                   || (markupTrans.OrigTableId == _tableId && markupTrans.OrigRecId == _recordId)
                   && !markupTrans.IsDeleted
                join euSalesListType from taxItemGroupHeading
                    where taxItemGroupHeading.TaxItemGroup == markupTrans.TaxItemGroup
                join TaxCode, TaxItemGroup from taxOnItem
                    where taxOnItem.TaxItemGroup           == taxItemGroupHeading.TaxItemGroup
                join NotEUSalesList  from taxTable
                    where taxTable.TaxCode                 == taxOnItem.TaxCode
                        && taxTable.NotEUSalesList          == 0
                join TaxGroup, TaxCode         from taxGroupData
                    where taxGroupData.TaxCode             == taxTable.TaxCode
                        && taxGroupData.TaxGroup            == markupTrans.TaxGroup
            {
                if (previousRecId != markupTrans.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getMarkupTransAmount(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        markupTrans,
                        taxItemGroupHeading.euSalesListType,
                        _moduleSalesPurch);

                    previousRecId = markupTrans.RecId;
                }
            }
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        Query query = new Query(queryStr(EUSalesListTransfer));

        super();

        includeItemSales        = true;
        includeServiceSales     = true;
        includeInvestmentSales  = true;
        includeNotAssignedSales = true;

        qeuSalesList = new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, qeuSalesList.pack()];
        packed = this.appendVariableToPack(packed, varStr(includeItemSales), includeItemSales);
        packed = this.appendVariableToPack(packed, varStr(includeServiceSales), includeServiceSales);
        packed = this.appendVariableToPack(packed, varStr(includeInvestmentSales), includeInvestmentSales);
        packed = this.appendVariableToPack(packed, varStr(includeNotAssignedSales), includeNotAssignedSales);
        packed = this.appendVariableToPack(packed, varStr(includeItemPurchases), includeItemPurchases);
        packed = this.appendVariableToPack(packed, varStr(includeServicePurchases), includeServicePurchases);
        packed = this.appendVariableToPack(packed, varStr(includeInvestmentPurchases), includeInvestmentPurchases);
        packed = this.appendVariableToPack(packed, varStr(includeNotAssignedPurchases), includeNotAssignedPurchases);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(EUSalesListTransfer) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransAmounts</Name>
				<Source><![CDATA[
    protected internal container getTaxTransAmounts(container _amounts, TaxTrans _taxTrans, EUSalesListType _euSalesListType, Amount _amount, ModuleSalesPurch _moduleSalesPurch)
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if (_taxTrans.SourceTableId != tableNum(MarkupTrans) ||  markupTrans::findRecId(_taxTrans.SourceRecId).isMarkupOfTypeCustVend() || markupTrans::findRecId(_taxTrans.SourceRecId).markupTypeItem())
        {
            _taxTrans.TaxBaseAmount = _moduleSalesPurch == ModuleSalesPurch::Sales? -_taxTrans.TaxBaseAmount : _taxTrans.TaxBaseAmount;

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.categorizeAmountMST(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        _euSalesListType,
                        _amount,
                        _moduleSalesPurch);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processMultiLineJournal</Name>
				<Source><![CDATA[
    protected internal container processMultiLineJournal(container _amounts, ModuleSalesPurch _moduleSalesPurch = ModuleSalesPurch::Sales)
    {
        AmountMST           itemAmountMST;
        AmountMST           serviceAmountMST;
        AmountMST           investmentAmountMST;
        AmountMST           notAssignedAmountMST;
        TaxTrans            taxTransLocal;
        TaxDocumentRowTransaction taxDocRowTrans;
        TaxDocumentRowTransaction_W taxDocRowTrans_w;
        TaxItemGroupHeading taxItemGroupHeading;
        TaxGroupData        taxGroupData;
        TaxTable            taxTable;
        TaxOnItem           taxOnItem;
        RecId               previousSourceRecId;
        TaxOrigin           previousTaxOrigin;
        TaxCode previousTaxCode;
        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
        Voucher                     voucher;
        TransDate transDate;

        // find old voucher number in table ledgerJournalVoucherChanged
        select firstOnly FromVoucher, FromDate, RecId from ledgerJournalVoucherChanged
            where ledgerJournalVoucherChanged.ToVoucher == taxTrans.Voucher;

        voucher = ledgerJournalVoucherChanged ? ledgerJournalVoucherChanged.FromVoucher : taxTrans.Voucher;
        transDate = ledgerJournalVoucherChanged ? ledgerJournalVoucherChanged.FromDate : taxTrans.TransDate;

        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        while select TaxBaseAmount, TaxBaseAmountCur, Voucher, TransDate, TaxCode, TaxGroup, TaxItemGroup, SourceRecId, TaxOrigin, SourceTableId from taxTransLocal
            order by taxTransLocal.SourceRecId, taxTransLocal.TaxOrigin, taxTransLocal.TaxCode
            where taxTransLocal.Voucher == voucher
                && taxTransLocal.TransDate == transDate
                && taxTransLocal.TaxID == taxTrans.TaxID
        {
            //Tax item groups mapped to multiple Tax codes create multiple TaxTrans records. Avoid duplicate values by checking source.
            if(TaxDocumentUtils::existTaxDocumentForJournal(taxTransLocal.SourceTableId, taxTransLocal.SourceRecId)
                && (previousSourceRecId != taxTransLocal.SourceRecId || previousTaxOrigin != taxTransLocal.TaxOrigin))
            {
                select taxDocRowTrans
                    where taxDocRowTrans.TransactionJourLineTableId == taxTransLocal.SourceTableId
                        && taxDocRowTrans.TransactionJourLIneRecId == taxTransLocal.SourceRecId
                    join taxDocRowTrans_w
                        where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
                    join NotEUSalesList  from taxTable
                        where taxTable.TaxCode                 == taxTrans.TaxCode
                           && taxTable.NotEUSalesList          == 0;

                if(taxDocRowTrans.RecId)
                {
                    taxTransLocal.TaxBaseAmountCur = _moduleSalesPurch == ModuleSalesPurch::Sales? -taxTransLocal.TaxBaseAmountCur : taxTransLocal.TaxBaseAmountCur;
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getTaxTransAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        taxTransLocal,
                        taxDocRowTrans_w.EUSalesListType,
                        taxTransLocal.TaxBaseAmountCur,
                        _moduleSalesPurch);
                }
                previousSourceRecId = taxTransLocal.SourceRecId;
                previousTaxOrigin   = taxTransLocal.TaxOrigin;
            }
            else
            {
                if(previousSourceRecId != taxTransLocal.SourceRecId || previousTaxOrigin != taxTransLocal.TaxOrigin || previousTaxCode == taxTransLocal.TaxCode)
                {
                    select RecId, euSalesListType  from taxItemGroupHeading
                        where taxItemGroupHeading.TaxItemGroup == taxTransLocal.TaxItemGroup
                    join TaxCode                   from taxOnItem
                        where taxOnItem.TaxItemGroup           == taxItemGroupHeading.TaxItemGroup
                    join TaxCode, NotEUSalesList   from taxTable
                        where taxTable.TaxCode                 == taxOnItem.TaxCode
                            && taxTable.NotEUSalesList          == 0
                    join TaxGroup, TaxCode         from taxGroupData
                        where taxGroupData.TaxCode             == taxTable.TaxCode
                            && taxGroupData.TaxGroup            == taxTransLocal.TaxGroup;

                    if(taxItemGroupHeading.RecId)
                    {
                        taxTransLocal.TaxBaseAmount = _moduleSalesPurch == ModuleSalesPurch::Sales? -taxTransLocal.TaxBaseAmount : taxTransLocal.TaxBaseAmount;
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getTaxTransAmounts(
                            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                            taxTransLocal,
                            taxItemGroupHeading.euSalesListType,
                            taxTransLocal.TaxBaseAmount,
                            _moduleSalesPurch);
                    }
                    previousSourceRecId = taxTransLocal.SourceRecId;
                    previousTaxOrigin   = taxTransLocal.TaxOrigin;
                    previousTaxCode = taxTransLocal.TaxCode;
                }
            }
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjInvoiceAmounts</Name>
				<Source><![CDATA[
    private container getProjInvoiceAmounts(container _amounts, Common _projInvoiceLine, EUSalesListType _euSalesListType, Amount _amount)
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if (transferAmountsFromTaxTrans)
        {
            if (!multiLineHandled)
            {
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.processMultiLineJournal(
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST]);

                multiLineHandled = true;
            }
        }
        else
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.markupTransAmounts(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _projInvoiceLine.TableId,
                _projInvoiceLine.RecId);

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.categorizeAmountMST(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _euSalesListType,
                _amount);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceJourAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the accounting currency amounts by <c>EUSalesListType</c> object for the lines of a
    ///    <c>ProjInvoiceJour</c> record.
    /// </summary>
    /// <param name="_projInvoiceJour">
    ///    The <c>ProjInvoiceJour</c> record.
    /// </param>
    /// <returns>
    ///    A container with four accounting currency amounts in this order: Item, Service, Investment, and
    ///    NotAssigned.
    /// </returns>
    public container projInvoiceJourAmounts(ProjInvoiceJour _projInvoiceJour = projInvoiceJour)
    {
        ProjInvoiceItem         projInvoiceItem;
        ProjInvoiceItemDetail   projInvoiceItemDetail;
        ProjInvoiceOnAcc        projInvoiceOnAcc;
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetail;

        ProjInvoiceEmpl         projInvoiceEmpl;
        ProjInvoiceCost         projInvoiceCost;
        ProjInvoiceRevenue      projInvoiceRevenue;
        TaxItemGroupHeading     taxItemGroupHeading;
        TaxTable                taxTable;
        TaxTrans                taxTransLocal;
        TaxGroupData            taxGroupData;
        TaxOnItem               taxOnItem;
        AmountMST               itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        AmountMST               amountMST;
        RecId                   previousRecId;

        TaxDocumentRowTransaction taxDocRowTrans;
        TaxDocumentRowTransaction_W taxDocRowTrans_w;
        TaxEngineProjItemJourHeader taxEngineProjItemJourHeader;
        TaxEngineProjOnAcctJourHeader taxEngineProjOnAccJourHeader;
        TaxEngineProjEmplJourHeader taxEngineProjEmplJourHeader;
        TaxEngineProjCostJourHeader taxEngineProjCostJourHeader;
        TaxEngineProjRevenueJourHeader taxEngineProjRevenueJourHeader;

        multiLineHandled = false;

        if(TaxDocumentUtils::existTaxDocumentForJournal(tableNum(ProjInvoiceJour), _projInvoiceJour.RecId))
        {
            // if the invoice was posted with GTE framework
            //Item Journals
            while select TaxItemGroupId, CurrencyId, InvoiceDate from projInvoiceItem
                order by projInvoiceItem.RecId
                where projInvoiceItem.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
            join taxEngineProjItemJourHeader
                where taxEngineProjItemJourHeader.ProjInvoiceJour == _projInvoiceJour.RecId
            join RecId from taxDocRowTrans
                where taxDocRowTrans.TransactionJourLineTableId == tableNum(ProjInvoiceItem)
                    && taxDocRowTrans.TransactionJourLIneRecId == projInvoiceItem.RecId
            join euSalesListType from taxDocRowTrans_w
                where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
            join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxBaseAmountCur from taxTransLocal
                where taxTransLocal.SourceTableId == projInvoiceItem.TableId
                    && taxTransLocal.SourceRecId == projInvoiceItem.RecId
                    && taxTransLocal.TaxID == taxTrans.TaxID
            {
                if (previousRecId != projInvoiceItem.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceItem,
                        taxDocRowTrans_w.euSalesListType,
                        -taxTransLocal.TaxBaseAmountCur);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceItem.RecId;
                }
            }

            previousRecId = 0;

            //On Account Journals
            while select TaxItemGroupId, CurrencyId, InvoiceDate from  projInvoiceOnAcc
                  where projInvoiceOnAcc.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
            join taxEngineProjOnAccJourHeader
                where taxEngineProjOnAccJourHeader.ProjInvoiceJour == _projInvoiceJour.RecId
            join RecId from taxDocRowTrans
                where taxDocRowTrans.TransactionJourLineTableId == tableNum(ProjInvoiceOnAcc)
                    && taxDocRowTrans.TransactionJourLIneRecId == projInvoiceOnAcc.RecId
            join euSalesListType from taxDocRowTrans_w
                where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
            join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxBaseAmountCur from taxTransLocal
                where taxTransLocal.SourceTableId == projInvoiceOnAcc.TableId
                    && taxTransLocal.SourceRecId == projInvoiceOnAcc.RecId
                    && taxTransLocal.TaxID == taxTrans.TaxID
            {
                if (previousRecId != projInvoiceOnAcc.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceOnAcc,
                        taxDocRowTrans_w.euSalesListType,
                        -taxTransLocal.TaxBaseAmountCur);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceOnAcc.RecId;
                }
            }

            previousRecId = 0;

            //Hour Journals
            while select TaxItemGroupId, CurrencyId, InvoiceDate from  projInvoiceEmpl
                  where projInvoiceEmpl.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
            join taxEngineProjEmplJourHeader
                where taxEngineProjEmplJourHeader.ProjInvoiceJour == _projInvoiceJour.RecId
            join RecId from taxDocRowTrans
                where taxDocRowTrans.TransactionJourLineTableId == tableNum(ProjInvoiceEmpl)
                    && taxDocRowTrans.TransactionJourLIneRecId == projInvoiceEmpl.RecId
            join euSalesListType from taxDocRowTrans_w
                where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
            join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxBaseAmountCur from taxTransLocal
                where taxTransLocal.SourceTableId == projInvoiceEmpl.TableId
                    && taxTransLocal.SourceRecId == projInvoiceEmpl.RecId
                    && taxTransLocal.TaxID == taxTrans.TaxID
            {
                if (previousRecId != projInvoiceEmpl.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceEmpl,
                        taxDocRowTrans_w.euSalesListType,
                        -taxTransLocal.TaxBaseAmountCur);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceEmpl.RecId;
                }
            }

            previousRecId = 0;

            //Expense Journals
            while select TaxItemGroupId, CurrencyId, InvoiceDate from  projInvoiceCost
                  where projInvoiceCost.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
            join taxEngineProjCostJourHeader
                where taxEngineProjCostJourHeader.ProjInvoiceJour == _projInvoiceJour.RecId
            join RecId from taxDocRowTrans
                where taxDocRowTrans.TransactionJourLineTableId == tableNum(ProjInvoiceCost)
                    && taxDocRowTrans.TransactionJourLIneRecId == projInvoiceCost.RecId
            join euSalesListType from taxDocRowTrans_w
                where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
            join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxBaseAmountCur from taxTransLocal
                where taxTransLocal.SourceTableId == projInvoiceCost.TableId
                    && taxTransLocal.SourceRecId == projInvoiceCost.RecId
                    && taxTransLocal.TaxID == taxTrans.TaxID
            {
                if (previousRecId != projInvoiceCost.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceCost,
                        taxDocRowTrans_w.euSalesListType,
                        -taxTransLocal.TaxBaseAmountCur);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceCost.RecId;
                }
            }

            previousRecId = 0;

            //Fee Journals
            while select TaxItemGroupId, CurrencyId, InvoiceDate from  projInvoiceRevenue
                  where projInvoiceRevenue.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
            join taxEngineProjRevenueJourHeader
                where taxEngineProjRevenueJourHeader.ProjInvoiceJour == _projInvoiceJour.RecId
            join RecId from taxDocRowTrans
                where taxDocRowTrans.TransactionJourLineTableId == tableNum(ProjInvoiceRevenue)
                    && taxDocRowTrans.TransactionJourLIneRecId == projInvoiceRevenue.RecId
            join euSalesListType from taxDocRowTrans_w
                where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
            join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxBaseAmountCur from taxTransLocal
                where taxTransLocal.SourceTableId == projInvoiceRevenue.TableId
                    && taxTransLocal.SourceRecId == projInvoiceRevenue.RecId
                    && taxTransLocal.TaxID == taxTrans.TaxID
            {
                if (previousRecId != projInvoiceRevenue.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceRevenue,
                        taxDocRowTrans_w.euSalesListType,
                        -taxTransLocal.TaxBaseAmountCur);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceRevenue.RecId;
                }
            }
        }
        else
        {
            // if the invoice was posted without GTE framework
            //Item Journals
            while select LineAmount from projInvoiceItemDetail
              order by projInvoiceItemDetail.RecId
              join TaxItemGroupId, CurrencyId, InvoiceDate from projInvoiceItem
                  where projInvoiceItemDetail.InvoiceRefRecId == projInvoiceItem.RecId
                     && projInvoiceItem.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
              join euSalesListType from taxItemGroupHeading
                where taxItemGroupHeading.TaxItemGroup == projInvoiceItem.TaxItemGroupId
              join TaxCode from taxOnItem
                where taxOnItem.TaxItemGroup == taxItemGroupHeading.TaxItemGroup
              join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxOnItem.TaxCode
                    && taxTable.NotEUSalesList == 0
              join TaxGroup, TaxCode from taxGroupData
                where taxGroupData.TaxCode == taxTable.TaxCode
                    && taxGroupData.TaxGroup == projInvoiceItem.TaxGroupId
            {
                if (previousRecId != projInvoiceItemDetail.RecId)
                {
                    amountMST =  CurrencyExchangeHelper::amountCur2MST(projInvoiceItemDetail.LineAmount, projInvoiceItem.CurrencyId, projInvoiceJour.ExchRate);

                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceItem,
                        taxItemGroupHeading.euSalesListType,
                        amountMST);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceItemDetail.RecId;
                }
            }

            previousRecId = 0;

            //On Account Journals
            while select Amount from  projInvoiceOnAccDetail
                order by projInvoiceOnAccDetail.RecId
            join TaxItemGroupId, CurrencyId, InvoiceDate from  projInvoiceOnAcc
                where projInvoiceOnAccDetail.InvoiceRefRecId == projInvoiceOnAcc.RecId
                    && projInvoiceOnAcc.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
            join euSalesListType from  taxItemGroupHeading
                where taxItemGroupHeading.TaxItemGroup == projInvoiceOnAcc.TaxItemGroupId
            join TaxCode from  taxOnItem
                where taxOnItem.TaxItemGroup == taxItemGroupHeading.TaxItemGroup
            join TaxCode, NotEUSalesList from  taxTable
                where taxTable.TaxCode == taxOnItem.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxGroup, TaxCode from  taxGroupData
                where taxGroupData.TaxCode == taxTable.TaxCode
                    && taxGroupData.TaxGroup == projInvoiceOnAcc.TaxGroupId
            {
                if (previousRecId != projInvoiceOnAccDetail.RecId)
                {
                    amountMST =  CurrencyExchangeHelper::amountCur2MST(projInvoiceOnAccDetail.Amount, projInvoiceOnAcc.CurrencyId, projInvoiceJour.ExchRate);

                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceOnAcc,
                        taxItemGroupHeading.euSalesListType,
                        amountMST);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceOnAccDetail.RecId;
                }
            }

            previousRecId = 0;

            //Hour Journals
            while select LineAmount, CurrencyId, InvoiceDate from projInvoiceEmpl
                order by projInvoiceEmpl.RecId
                where projInvoiceEmpl.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                    && projInvoiceEmpl.InvoiceDate == _projInvoiceJour.InvoiceDate
            join euSalesListType from taxItemGroupHeading
                where taxItemGroupHeading.TaxItemGroup == projInvoiceEmpl.TaxItemGroupId
            join TaxCode from taxOnItem
                where taxOnItem.TaxItemGroup == taxItemGroupHeading.TaxItemGroup
            join TaxCode, NotEUSalesList from taxTable
                where taxTable.TaxCode == taxOnItem.TaxCode
                    && taxTable.NotEUSalesList == 0
            join TaxGroup, TaxCode from taxGroupData
                where taxGroupData.TaxCode == taxTable.TaxCode
                    && taxGroupData.TaxGroup == projInvoiceEmpl.TaxGroupId
            {
                if (previousRecId != projInvoiceEmpl.RecId)
                {
                    amountMST =  CurrencyExchangeHelper::amountCur2MST(projInvoiceEmpl.LineAmount, projInvoiceEmpl.CurrencyId, projInvoiceJour.ExchRate);

                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceEmpl,
                        taxItemGroupHeading.euSalesListType,
                        amountMST);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceEmpl.RecId;
                }
            }

            previousRecId = 0;

            //Expense Journals
            while select LineAmount, CurrencyId, InvoiceDate from projInvoiceCost
              order by projInvoiceCost.RecId
              where projInvoiceCost.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                 && projInvoiceCost.InvoiceDate == _projInvoiceJour.InvoiceDate
              join euSalesListType from taxItemGroupHeading
                  where taxItemGroupHeading.TaxItemGroup == projInvoiceCost.TaxItemGroupId
              join TaxCode from taxOnItem
                  where taxOnItem.TaxItemGroup == taxItemGroupHeading.TaxItemGroup
              join TaxCode, NotEUSalesList from taxTable
                  where taxTable.TaxCode == taxOnItem.TaxCode
                     && taxTable.NotEUSalesList == 0
              join TaxGroup, TaxCode from taxGroupData
                  where taxGroupData.TaxCode == taxTable.TaxCode
                     && taxGroupData.TaxGroup == projInvoiceCost.TaxGroupId
            {
                if (previousRecId != projInvoiceCost.RecId)
                {
                    amountMST =  CurrencyExchangeHelper::amountCur2MST(projInvoiceCost.LineAmount, projInvoiceCost.CurrencyId, projInvoiceJour.ExchRate);

                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceCost,
                        taxItemGroupHeading.euSalesListType,
                        amountMST);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceCost.RecId;
                }
            }

            previousRecId = 0;

            //Fee Journals
            while select LineAmount, CurrencyId, InvoiceDate from projInvoiceRevenue
              order by projInvoiceRevenue.RecId
              where projInvoiceRevenue.ProjInvoiceId == _projInvoiceJour.ProjInvoiceId
                 && projInvoiceRevenue.InvoiceDate == _projInvoiceJour.InvoiceDate
              join euSalesListType from taxItemGroupHeading
                  where taxItemGroupHeading.TaxItemGroup == projInvoiceRevenue.TaxItemGroupId
              join TaxCode from taxOnItem
                  where taxOnItem.TaxItemGroup == taxItemGroupHeading.TaxItemGroup
              join TaxCode, NotEUSalesList from taxTable
                  where taxTable.TaxCode == taxOnItem.TaxCode
                     && taxTable.NotEUSalesList == 0
              join TaxGroup, TaxCode from taxGroupData
                  where taxGroupData.TaxCode == taxTable.TaxCode
                     && taxGroupData.TaxGroup == projInvoiceRevenue.TaxGroupId
            {
                if (previousRecId != projInvoiceRevenue.RecId)
                {
                    amountMST =  CurrencyExchangeHelper::amountCur2MST(projInvoiceRevenue.LineAmount, projInvoiceRevenue.CurrencyId, projInvoiceJour.ExchRate);

                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getProjInvoiceAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        projInvoiceRevenue,
                        taxItemGroupHeading.euSalesListType,
                        amountMST);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = projInvoiceRevenue.RecId;
                }
            }
        }

        if (projInvoiceJour.EndDisc)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.distributeDiscount(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                projInvoiceJour.EndDisc,
                projInvoiceJour.salesorderbalance);
        }

        if (!multiLineHandled)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.markupTransAmounts(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _projInvoiceJour.TableId,
                _projInvoiceJour.RecId);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>quarter</Name>
				<Source><![CDATA[
    EUSalesListQuarter quarter()
    {
        return this.date2Quarter(euSalesList.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current <c>EUSalesList</c> query.
    /// </summary>
    /// <param name="_query">
    /// The query that will overwrite the original; optional.
    /// </param>
    /// <returns>
    /// The current <c>EUSalesList</c> query.
    /// </returns>
    public Query query(Query _query = qeuSalesList.query())
    {
        return qeuSalesList.query(_query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    /// The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used if a query prompt is the dialog, and if a select menu item is added to a dialog
    /// box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in
    /// the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    QueryRun queryRun()
    {
        boolean reportDiscount = this.isReportDiscount();

        qeuSalesList.query().dataSourceTable(tableNum(CustSettlement), 1).enabled(reportDiscount);
        qeuSalesList.query().dataSourceTable(tableNum(VendSettlement)).enabled(reportDiscount);

        return  qeuSalesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        NumberSeq            num;
        ListSeqNum           seqNum;
        ListDispatchId       dispatchId;
        boolean              reportDisc = this.isReportDiscount();
        boolean              transferPurchases = IntrastatParameters::find().euSalesListTransferPurchases;
        boolean              transferSales;
        Query                query = qeuSalesList.query();
        QueryBuildDataSource custQBDS = query.dataSourceTable(tableNum(CustInvoiceJour));

        // atleast one purchse transfer option should be marked, otherwise purchases can be skipped
        transferPurchases = transferPurchases && (includeItemPurchases || includeServicePurchases || includeInvestmentPurchases || includeNotAssignedPurchases) ;

        // atleast one sales transfer option should be marked, otherwise sales can be skipped
        transferSales = includeItemSales || includeServiceSales || includeInvestmentSales || includeNotAssignedSales;

        boolean transferTransferOrder = includeItemTransferOrder || includeServiceTransferOrder || includeInvestmentTransferOrder || includeNotAssignedTransferOrder;
        boolean transferTransferOrderArrival = includeItemTransferOrderArrival
            || includeServiceTransferOrderArrival
            || includeInvestmentTransferOrderArrival
            || includeNotAssignedTransferOrderArrival;

        transferAmountsFromTaxTrans = FeatureStateProvider::isFeatureEnabled(EUSalesListTransAmountsFromTaxTrans_Feature::instance());

        this.progressInit("@SYS8801", 0, #Avifilemove, 0);
        progress.updateInterval(0);
        progress.setCount(0);

        ttsbegin;
        num = NumberSeq::newGetNum(IntrastatParameters::numRefListDispatchId(),true);
        euSalesList.SeqNum = EUSalesList::maxAllSeqNum();

        query.clearQueryFilters();

        query.dataSourceTable(tableNum(TaxTrans)).update(true);

        if (taxRegistrationRecId)
        {
            query.dataSourceTable(tableNum(TaxTrans)).addRange(fieldNum(TaxTrans, TaxId)).value(queryValue(taxRegistrationRecId));
        }

        query.dataSourceTable(tableNum(TaxTrans)).addRange(fieldNum(TaxTrans,TaxCode)).value(this.getTaxCodesToInclude());
        query.dataSourceTable(tableNum(TaxTrans)).addRange(fieldNum(TaxTrans,Source))
                    .value(enum2str(TaxModuleType::Project)+','
                           +enum2str(TaxModuleType::Sales)+','
                           +enum2str(TaxModuleType::Voucher)+','
                           +enum2str(TaxModuleType::FreeTxtInvoice)+','
                           +enum2str(TaxModuleType::Purch)+','
                           +enum2str(TaxModuleType::PurchInvoice)+','
                           +enum2Str(TaxModuleType::SalesInvoice) + ','
                           +enum2Str(TaxModuleType::TransferOrderReceive) + ','
                           +enum2Str(TaxModuleType::TransferOrderShipment));

        query.dataSourceTable(tableNum(CustInvoiceJour)).update(true);
        query.dataSourceTable(tableNum(ProjInvoiceJour)).update(true);
        query.dataSourceTable(tableNum(VendInvoiceJour)).update(true);
        if (reportDisc)
        {
            query.dataSourceTable(tableNum(CustSettlement)).enabled(true);
            query.dataSourceTable(tableNum(CustSettlement)).update(true);

            query.dataSourceTable(tableNum(CustSettlement)).addRange(fieldNum(CustSettlement, TransDate)).value(custQBDS.rangeField(fieldNum(CustInvoiceJour, InvoiceDate)).value());

            if (transferPurchases)
            {
                query.dataSourceTable(tableNum(VendSettlement)).enabled(true);
                query.dataSourceTable(tableNum(VendSettlement)).update(true);
            }
        }

        if (TaxIntegrationUtils::isTaxInTransferOrderEnabled())
        {
            query.dataSourceTable(tableNum(InventTransferJour)).enabled(true);
            query.dataSourceTable(tableNum(InventTransferJour)).update(true);

            if (!IntrastatParameters::find().euSalesListTransferPurchases)
            {
                query.dataSourceTable(tableNum(InventTransferJour)).addRange(fieldNum(InventTransferJour, UpdateType))
                    .value(queryValue(InventTransferUpdateType::Shipment));
            }
        }

        // DispatchId should be unique to the transfer
        dispatchId = num.num();
        
        TaxRegistrationRecId prevTaxId;
        TransDate prevTransDate;
        Voucher prevVoucher;

        invoiceJourSet = new Set(Types::Container);

        while (qeuSalesList.next())
        {
            seqNum = euSalesList.SeqNum;

            euSalesList.clear();
            euSalesList.DispatchId = dispatchId;
            // SeqNum will be incremented right before the record is inserted.
            euSalesList.SeqNum = seqNum;

            taxTrans = qeuSalesList.get(tableNum(TaxTrans));

            if (transferSales)
            {
                if (qeuSalesList.changed(tableNum(CustInvoiceJour)) || (prevTaxId != taxTrans.TaxID  && prevTransDate == taxTrans.TransDate && prevVoucher == taxTrans.Voucher))
                {
                    custInvoiceJour = qeuSalesList.get(tableNum(CustInvoiceJour));
                    if (custInvoiceJour.RecId)
                    {
                        projInvoiceJour = null;
                        vendInvoiceJour = null;
                        this.loadFromCustInvoiceJour();
                    }
                }

                if (taxTrans.Source != TaxModuleType::FreeTxtInvoice
                    && (qeuSalesList.changed(tableNum(ProjInvoiceJour))
                        || (prevTaxId != taxTrans.TaxID
                            && prevTransDate == taxTrans.TransDate
                            && prevVoucher == taxTrans.Voucher
                           )
                       )
                   )
                {
                    projInvoiceJour = qeuSalesList.get(tableNum(ProjInvoiceJour));
                    if (projInvoiceJour.RecId)
                    {
                        custInvoiceJour    = null;
                        vendInvoiceJour    = null;
                        this.loadFromProjInvoiceJour();
                    }
                }
            }

            if (transferPurchases && (qeuSalesList.changed(tableNum(VendInvoiceJour)) || (prevTaxId != taxTrans.TaxID  && prevTransDate == taxTrans.TransDate && prevVoucher == taxTrans.Voucher)))
            {
                vendInvoiceJour = qeuSalesList.get(tableNum(VendInvoiceJour));
                if (vendInvoiceJour.RecId)
                {
                    custInvoiceJour    = null;
                    projInvoiceJour    = null;
                    this.loadFromVendInvoiceJour();
                }
            }

            if (reportDisc)
            {
                if (transferSales && (qeuSalesList.changed(tableNum(CustSettlement)) || (prevTaxId != taxTrans.TaxID  && prevTransDate == taxTrans.TransDate && prevVoucher == taxTrans.Voucher)))
                {
                    custSettlement = qeuSalesList.get(tableNum(CustSettlement));
                    if (custSettlement.RecId)
                    {
                        vendSettlement = null;
                        this.loadFromCustSettlement();
                    }
                }

                if (transferPurchases && (qeuSalesList.changed(tableNum(VendSettlement)) || (prevTaxId != taxTrans.TaxID  && prevTransDate == taxTrans.TransDate && prevVoucher == taxTrans.Voucher)))
                {
                    vendSettlement = qeuSalesList.get(tableNum(VendSettlement));
                    if (vendSettlement.RecId)
                    {
                        custSettlement = null;
                        this.loadFromVendSettlement();
                    }
                }
            }

            if (transferTransferOrder && taxTrans.Source == TaxModuleType::TransferOrderShipment)
            {
                if (qeuSalesList.changed(tableNum(InventTransferJour)) || (prevTaxId != taxTrans.TaxID  && prevTransDate == taxTrans.TransDate && prevVoucher == taxTrans.Voucher))
                {
                    InventTransferJour inventTransferJour = qeuSalesList.get(tableNum(InventTransferJour));
                    if (inventTransferJour.RecId)
                    {
                        this.loadFromInventTransferJour(inventTransferJour);
                    }
                }
            }

            if (transferTransferOrderArrival && taxTrans.Source == TaxModuleType::TransferOrderReceive)
            {
                if (qeuSalesList.changed(tableNum(InventTransferJour)) || (prevTaxId != taxTrans.TaxID  && prevTransDate == taxTrans.TransDate && prevVoucher == taxTrans.Voucher))
                {
                    InventTransferJour inventTransferJour = qeuSalesList.get(tableNum(InventTransferJour));
                    if (inventTransferJour.RecId)
                    {
                        this.loadFromInventTransferJour(inventTransferJour);
                    }
                }
            }

            prevTaxId = taxTrans.TaxID;
            prevTransDate = taxTrans.TransDate;
            prevVoucher = taxTrans.Voucher;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryInclusions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets ranges on the <c>EUSalesListTransfer</c> query.
    /// </summary>
    /// <param name="_itemsSales">
    /// A Boolean value that indicates whether to calculate the item type sale.
    /// </param>
    /// <param name="_servicesSales">
    /// A Boolean value that indicates whether to calculate the service type sale.
    /// </param>
    /// <param name="_investmentsSales">
    /// A Boolean value that indicates whether to calculate the investment type sale.
    /// </param>
    /// <param name="_notAssignedSales">
    /// A Boolean value that indicates whether to calculate the not assigned type sale.
    /// </param>
    /// <param name="_itemsPurchases">
    /// A Boolean value that indicates whether to calculate the item type purchase.
    /// </param>
    /// <param name="_servicesPurchases">
    /// A Boolean value that indicates whether to calculate the service type purchase.
    /// </param>
    /// <param name="_investmentsPurchases">
    /// A Boolean value that indicates whether to calculate the investment type purchase.
    /// </param>
    /// <param name="_notAssignedPurchases">
    /// A Boolean value that indicates whether to calculate the not assigned type purchase.
    /// </param>
    public void setQueryInclusions(boolean  _itemsSales,
                               boolean  _servicesSales,
                               boolean  _investmentsSales,
                               boolean  _notAssignedSales,
                               boolean  _itemsPurchases,
                               boolean  _servicesPurchases,
                               boolean  _investmentsPurchases,
                               boolean  _notAssignedPurchases)
    {
        includeItemSales            = _itemsSales;
        includeServiceSales         = _servicesSales;
        includeInvestmentSales      = _investmentsSales;
        includeNotAssignedSales     = _notAssignedSales;
        includeItemPurchases        = _itemsPurchases;
        includeServicePurchases     = _servicesPurchases;
        includeInvestmentPurchases  = _investmentsPurchases;
        includeNotAssignedPurchases = _notAssignedPurchases;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryInventTransferInclusions</Name>
				<Source><![CDATA[
    public void setQueryInventTransferInclusions(
        boolean _itemsInventTransfer,
        boolean _serviceInventTransfer,
        boolean _investmentInventTranfer,
        boolean _notAssignedInventTransfer)
    {
        includeItemTransferOrder = _itemsInventTransfer;
        includeServiceTransferOrder = _serviceInventTransfer;
        includeInvestmentTransferOrder = _investmentInventTranfer;
        includeNotAssignedTransferOrder = _notAssignedInventTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryInventTransferInclusionsArrival</Name>
				<Source><![CDATA[
    public void setQueryInventTransferInclusionsArrival(
        boolean _itemsInventTransfer,
        boolean _serviceInventTransfer,
        boolean _investmentInventTranfer,
        boolean _notAssignedInventTransfer)
    {
        includeItemTransferOrderArrival = _itemsInventTransfer;
        includeServiceTransferOrderArrival = _serviceInventTransfer;
        includeInvestmentTransferOrderArrival = _investmentInventTranfer;
        includeNotAssignedTransferOrderArrival = _notAssignedInventTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container packedClass)
    {
        Integer version = RunBase::getVersion(packedClass);
        container packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version, packedQuery] = packedClass;
                if (packedQuery)
                {
                    qeuSalesList = new QueryRun(packedQuery);
                }

                includeItemSales = this.extractPackedVariable(packedClass, varStr(includeItemSales));
                includeServiceSales = this.extractPackedVariable(packedClass, varStr(includeServiceSales));
                includeInvestmentSales = this.extractPackedVariable(packedClass, varStr(includeInvestmentSales));
                includeNotAssignedSales = this.extractPackedVariable(packedClass, varStr(includeNotAssignedSales));
                includeItemPurchases = this.extractPackedVariable(packedClass, varStr(includeItemPurchases));
                includeServicePurchases = this.extractPackedVariable(packedClass, varStr(includeServicePurchases));
                includeInvestmentPurchases = this.extractPackedVariable(packedClass, varStr(includeInvestmentPurchases));
                includeNotAssignedPurchases = this.extractPackedVariable(packedClass, varStr(includeNotAssignedPurchases));
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceTransAmounts</Name>
				<Source><![CDATA[
    private container getVendInvoiceTransAmounts(container _amounts, VendInvoiceTrans _vendInvoiceTrans, EUSalesListType _euSalesListType, Amount _amount)
    {
        AmountMST itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST;
        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = _amounts;

        if (transferAmountsFromTaxTrans)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.processMultiLineJournal(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST], ModuleSalesPurch::Purch);

            multiLineHandled = true;
        }
        else
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.markupTransAmounts(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _vendInvoiceTrans.TableId,
                _vendInvoiceTrans.RecId,
                ModuleSalesPurch::Purch);

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.categorizeAmountMST(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _euSalesListType,
                _amount,
                ModuleSalesPurch::Purch);
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendInvoiceJourAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the accounting currency amounts by using the <c>EUSalesListType</c> object for the lines
    ///    of a <c>VendInvoiceJour</c> record.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    ///    The <c>VendInvoiceJour</c> record.
    /// </param>
    /// <returns>
    ///    A container that contains four accounting currency amounts in this order: Item, Service,
    ///    Investment, and NotAssigned.
    /// </returns>
    public container vendInvoiceJourAmounts(VendInvoiceJour _vendInvoiceJour = vendInvoiceJour)
    {
        VendInvoiceTrans    vendInvoiceTrans;
        TaxItemGroupHeading taxItemGroupHeading;
        TaxDocumentRowTransaction taxDocRowTrans;
        TaxDocumentRowTransaction_W taxDocRowTrans_w;
        TaxGroupData        taxGroupData;
        TaxTable            taxTable;
        TaxTrans            taxTransLocal;
        TaxOnItem           taxOnItem;
        AmountMST           itemAmountMST;
        AmountMST           serviceAmountMST;
        AmountMST           investmentAmountMST;
        AmountMST           notAssignedAmountMST;
        RecId               previousRecId;
        boolean             vendinvoiceTransExists;

        multiLineHandled = false;

        if(TaxDocumentUtils::existTaxDocumentForJournal(tableNum(VendInvoiceJour), _vendInvoiceJour.RecId))
        {
            // if the invoice was posted with GTE framework
            while select LineAmountMST, TaxGroup, TaxItemGroup from vendInvoiceTrans
                order by vendInvoiceTrans.RecId
                where vendInvoiceTrans.PurchID             == _vendInvoiceJour.PurchId
                    && vendInvoiceTrans.InvoiceDate         == _vendInvoiceJour.InvoiceDate
                    && vendInvoiceTrans.InvoiceId           == _vendInvoiceJour.InvoiceId
                    && vendInvoiceTrans.NumberSequenceGroup == _vendInvoiceJour.NumberSequenceGroup
                join TaxCode, NotEUSalesList                 from taxTable
                      where taxTable.TaxCode                      == taxTrans.TaxCode
                         && taxTable.NotEUSalesList               == 0
                join RecId from  taxDocRowTrans
                    where taxDocRowTrans.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
                        && taxDocRowTrans.TransactionJourLIneRecId == vendInvoiceTrans.RecId
                join euSalesListType from taxDocRowTrans_w
                    where taxDocRowTrans_w.TaxDocumentRowTransactionRecId == taxDocRowTrans.RecId
                join TaxBaseAmountCur from taxTransLocal
                    where taxTransLocal.SourceTableId == vendInvoiceTrans.TableId
                        && taxTransLocal.SourceRecId == vendInvoiceTrans.RecId
                        && taxTransLocal.TaxID == taxTrans.TaxID
            {
                vendinvoiceTransExists = true;
                if (previousRecId != vendInvoiceTrans.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getVendInvoiceTransAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        vendInvoiceTrans,
                        taxDocRowTrans_w.EUSalesListType,
                        taxTransLocal.TaxBaseAmountCur);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = vendInvoiceTrans.RecId;
                }
            }
        }
        else
        {
            // if the invoice was posted in the old way
            while select LineAmountMST, TaxGroup, TaxItemGroup from vendInvoiceTrans
                order by vendInvoiceTrans.RecId
                where vendInvoiceTrans.PurchID             == _vendInvoiceJour.PurchId
                    && vendInvoiceTrans.InvoiceDate         == _vendInvoiceJour.InvoiceDate
                    && vendInvoiceTrans.InvoiceId           == _vendInvoiceJour.InvoiceId
                    && vendInvoiceTrans.NumberSequenceGroup == _vendInvoiceJour.NumberSequenceGroup
                join euSalesListType           from taxItemGroupHeading
                    where taxItemGroupHeading.TaxItemGroup == vendInvoiceTrans.TaxItemGroup
                join TaxCode                   from taxOnItem
                    where taxOnItem.TaxItemGroup           == taxItemGroupHeading.TaxItemGroup
                join TaxCode, NotEUSalesList   from taxTable
                    where taxTable.TaxCode                 == taxOnItem.TaxCode
                        && taxTable.NotEUSalesList          == 0
                join TaxGroup, TaxCode         from taxGroupData
                    where taxGroupData.TaxCode             == taxTable.TaxCode
                        && taxGroupData.TaxGroup            == vendInvoiceTrans.TaxGroup
            {
                vendinvoiceTransExists = true;
                if (previousRecId != vendInvoiceTrans.RecId)
                {
                    [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.getVendInvoiceTransAmounts(
                        [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                        vendInvoiceTrans,
                        taxItemGroupHeading.euSalesListType,
                        vendInvoiceTrans.LineAmountMST);

                    if (multiLineHandled)
                    {
                        break;
                    }

                    previousRecId = vendInvoiceTrans.RecId;
                }
            }
        }

        if (!vendinvoiceTransExists)//transacations from vendor journals
        {
            if (!taxTrans)
            {
                taxTrans = TaxTrans::find(_vendInvoiceJour.LedgerVoucher, _vendInvoiceJour.InvoiceDate);
            }

            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.processMultiLineJournal(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                ModuleSalesPurch::Purch);

            multiLineHandled = true;
        }

        if (vendInvoiceJour.EndDisc != 0)
        {
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.distributeDiscount(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _vendInvoiceJour.EndDiscMST,
                _vendInvoiceJour.amountMST(_vendInvoiceJour.SalesBalance));
        }

        if (!multiLineHandled)
        {
            //During multi-line handling, misc charges are already taken into account.
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.markupTransAmounts(
                [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST],
                _vendInvoiceJour.TableId,
                _vendInvoiceJour.RecId,
                ModuleSalesPurch::Purch);
        }
        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendSettlementsAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the accounting currency amounts of the lines that are connected to a
    /// <c>VendSettlement</c> record.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// The <c>VendInvoiceJour</c> record that is connected to the <c>CustSettlement</c> record.
    /// </param>
    /// <returns>
    /// A container that contains four accounting currency amounts in this order: Item, Service,
    /// Investment, NotAssigned.
    /// </returns>
    public container vendSettlementsAmounts(VendInvoiceJour _vendInvoiceJour)
    {
        AmountMST itemAmountMST;
        AmountMST serviceAmountMST;
        AmountMST investmentAmountMST;
        AmountMST notAssignedAmountMST;
        AmountMST totalAmountMST;
        AmountMST utilizedCashDiscMST;

        real      item;
        real      service;
        real      investment;
        real      notAssigned;

        if (_vendInvoiceJour)
        {
            totalAmountMST = _vendInvoiceJour.InvoiceAmountMST - _vendInvoiceJour.SumTax;
            [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST] = this.vendInvoiceJourAmounts(_vendInvoiceJour);
        }

        if (totalAmountMST)
        {
            if (transferAmountsFromTaxTrans || FeatureStateProvider::isFeatureEnabled(EUSalesListTransAmountsFromTaxTrans_Feature::instance()))
            {
                VendTrans vendTransCashDiscount;
                select firstonly Voucher, TransDate from vendTransCashDiscount
                    where vendTransCashDiscount.OffsetRecId == vendSettlement.TransRecId
                        && vendTransCashDiscount.Voucher == vendSettlement.SettlementVoucher
                        && vendTransCashDiscount.TransType == LedgerTransType::CashDiscount;

                if (vendTransCashDiscount)
                {
                    utilizedCashDiscMST = this.calcCashDiscount(vendTransCashDiscount.Voucher, vendTransCashDiscount.TransDate);
                }
            }

            if (!utilizedCashDiscMST)
            {
                utilizedCashDiscMST  = CurrencyExchangeHelper::amountCur2MST(vendSettlement.UtilizedCashDisc, vendSettlement.custVendTrans().CurrencyCode);
            }

            item                 = itemAmountMST / totalAmountMST;
            service              = serviceAmountMST / totalAmountMST;
            investment           = investmentAmountMST / totalAmountMST;
            notAssigned          = notAssignedAmountMST / totalAmountMST;

            itemAmountMST        = utilizedCashDiscMST * item;
            serviceAmountMST     = utilizedCashDiscMST * service;
            investmentAmountMST  = utilizedCashDiscMST * investment;
            notAssignedAmountMST = utilizedCashDiscMST * notAssigned;
        }

        return [itemAmountMST, serviceAmountMST, investmentAmountMST, notAssignedAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>year</Name>
				<Source><![CDATA[
    EUSalesListYear year()
    {
        return year(euSalesList.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearRange</Name>
				<Source><![CDATA[
    public static void clearRange(QueryBuildDataSource _qbds, FieldId _field)
    {
        _qbds.findRange(_field).value('');
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static EUSalesListTransfer construct()
    {
        EUSalesListTransfer transfer = SysExtensionAppClassFactory::getClassFromSysAttribute(
            classStr(EUSalesListTransfer),
            new EUSaleslistCountryRegionAttribute(SysCountryRegionCode::countryInfo()));

        return transfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertFiltersToRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts each <c>QueryFilter</c> object on a query to a <c>QueryBuildRange</c> object.
    /// </summary>
    /// <param name="_query">
    /// The query on which to convert filters to ranges.
    /// </param>
    public static void convertFiltersToRanges(Query _query)
    {
        QueryFilter qf;
        int filterCount;

        for (filterCount = 1; filterCount <= _query.queryFilterCount(); filterCount++)
        {
            qf = _query.queryFilter(filterCount);
            SysQuery::findOrCreateRange(qf.dataSource(), fieldName2id(qf.dataSource().table(), qf.field())).value(qf.value());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertRangesToFilters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts each <c>QueryBuildRange</c> object on a query to a <c>QueryFilter</c> object.
    /// </summary>
    /// <param name="_query">
    /// The query on which to convert ranges to filters.
    /// </param>
    public static void convertRangesToFilters(Query _query)
    {
        QueryBuildRange qbr;
        int rangeCount;

        QueryBuildDataSource custQBDS = _query.dataSourceTable(tableNum(CustInvoiceJour));
        QueryBuildDataSource projQBDS = _query.dataSourceTable(tableNum(ProjInvoiceJour));
        QueryBuildDataSource vendQBDS = _query.dataSourceTable(tableNum(VendInvoiceJour));
        QueryBuildDataSource transferQBDS = _query.dataSourceTable(tableNum(InventTransferJour));
        _query.clearQueryFilters();

        for (rangeCount = 1; rangeCount <= custQBDS.rangeCount(); rangeCount++)
        {
            qbr = custQBDS.range(rangeCount);
            EUSalesListTransfer::findOrCreateQueryFilterWithValue(_query, custQBDS, qbr.fieldName(), qbr.value());
        }

        for (rangeCount = 1; rangeCount <= projQBDS.rangeCount(); rangeCount++)
        {
            qbr = projQBDS.range(rangeCount);
            EUSalesListTransfer::findOrCreateQueryFilterWithValue(_query, projQBDS, qbr.fieldName(), qbr.value());
        }

        for (rangeCount = 1; rangeCount <= vendQBDS.rangeCount(); rangeCount++)
        {
            qbr = vendQBDS.range(rangeCount);
            EUSalesListTransfer::findOrCreateQueryFilterWithValue(_query, vendQBDS, qbr.fieldName(), qbr.value());
        }

        if (TaxParameters::reportUseVatDueDate_W())
        {
            QueryBuildDataSource taxTransWQBDS = _query.dataSourceTable(tableNum(TaxTrans_W));

            for (rangeCount = 1; rangeCount <= taxTransWQBDS.rangeCount(); rangeCount++)
            {
                qbr = taxTransWQBDS.range(rangeCount);
                EUSalesListTransfer::findOrCreateQueryFilterWithValue(_query, taxTransWQBDS, qbr.fieldName(), qbr.value());
            }
        }

        if (TaxIntegrationUtils::isTaxInTransferOrderEnabled())
        {
            for (rangeCount = 1; rangeCount <= transferQBDS.rangeCount(); rangeCount++)
            {
                qbr = transferQBDS.range(rangeCount);
                EUSalesListTransfer::findOrCreateQueryFilterWithValue(_query, transferQBDS, qbr.fieldName(), qbr.value());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static public ClassDescription description()
    {
        return "@SYS345193";
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateQueryFilterWithValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates a <c>QueryFilter</c> object on the specified query for the specified field.
    /// </summary>
    /// <param name="_query">
    /// The query to use to find or create the <c>QueryFilter</c> object.
    /// </param>
    /// <param name="_queryBuildDataSource">
    /// The data source to use to find or create the <c>QueryFilter</c> object.
    /// </param>
    /// <param name="_fieldName">
    /// The name of the field on which to filter.
    /// </param>
    /// <param name="_filterValue">
    /// The value to which the filter will be set.
    /// </param>
    /// <returns>
    /// The existing <c>QueryFilter</c> object; otherwise, a new <c>QueryFilter</c> object.
    /// </returns>
    public static str findOrCreateQueryFilterWithValue(
        Query _query,
        QueryBuildDataSource _queryBuildDataSource,
        FieldName _fieldName,
        str _filterValue = '')
    {
        QueryFilter queryFilter;

        if (_queryBuildDataSource)
        {
            queryFilter = _query.findQueryFilter(_queryBuildDataSource, _fieldName);

            if (!queryFilter)
            {
                queryFilter = _query.addQueryFilter(_queryBuildDataSource, _fieldName);
            }
        }

        if (_filterValue != '')
        {
            queryFilter.value(_filterValue);
        }

        return queryFilter.value();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVATNumTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the tax code from the VAT number.
    /// </summary>
    /// <param name="_vatNum">
    ///    The VAT Number from which to retrieve the tax code.
    /// </param>
    /// <returns>
    ///    The sales tax code when the first two characters form a valid tax code; otherwise, a blank string.
    /// </returns>
    /// <remarks>
    ///    It checks the first two characters of the VAT number to determine whether they form a valid sales
    ///    tax code.
    /// </remarks>
    static EUSalesListTax getVATNumTaxCode(VATNum _vatNum)
    {
        TaxCountryRegionParameters  taxCountryRegionParameters;
        VATNum                      vatNum;
        EUSalesListTax              salesTaxCode;
        #TaxIntervatBE

        if (_vatNum)
        {
            vatNum          = strKeep(_vatNum, #AlphaNumeric);
            salesTaxCode    = subStr(vatNum, 1, 2);

            select firstonly SalesTaxCode from taxCountryRegionParameters
                where taxCountryRegionParameters.SalesTaxCode == salesTaxCode;

            if (taxCountryRegionParameters.SalesTaxCode)
            {
                return taxCountryRegionParameters.SalesTaxCode;
            }
        }

        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDomesticVATDutableEnterpriseNum_BE</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the enterprise number contains the valid tax code.
    /// </summary>
    /// <param name="_taxEnterpriseNumber">
    ///    The enterprise number from which to retrieve the tax code.
    /// </param>
    /// <returns>
    ///    true if enterprise number contains valid tax code; otherwise, false.
    /// </returns>
    public static boolean isDomesticVATDutableEnterpriseNum_BE(TaxEnterpriseNumber _taxEnterpriseNumber)
    {
        #TaxIntervatBE
        TaxEnterpriseNumber taxEnterpriseNumber = strKeep(_taxEnterpriseNumber, #AlphaNumeric);

        // Remove eventual 'BTW' / 'TVA'
        taxEnterpriseNumber = TaxEnterpriseBranchNumber_BE::removeBTWTVA(taxEnterpriseNumber);

        return(strUpr(EUSalesListTransfer::getVATNumTaxCode(taxEnterpriseNumber)) ==
               strUpr(TaxCountryRegionParameters::find((CompanyInfo::find().postalAddress().CountryRegionId)).SalesTaxCode));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDomesticVATDutableVATNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the VAT number contains the valid tax code.
    /// </summary>
    /// <param name="_vatNum">
    ///    The VAT number from which to retrieve the tax code.
    /// </param>
    /// <returns>
    ///    true if VAT Number contains valid tax code; otherwise, false.
    /// </returns>
    public static boolean isDomesticVATDutableVATNum(VATNum _vatNum)
    {
        return strUpr(EUSalesListTransfer::getVATNumTaxCode(_vatNum)) ==
               strUpr(TaxCountryRegionParameters::find(CompanyInfo::find().postalAddress().CountryRegionId).SalesTaxCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        EUSalesListTransfer  listTransfer;
        FormDataSource       euSalesList_ds;

        listTransfer    = EUSalesListTransfer::construct();

        euSalesList_ds  = FormDataUtil::getFormDataSource(args.record());

        if (listTransfer.prompt())
        {
            listTransfer.runOperation();
        }

        euSalesList_ds.executeQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxRegistrationRecId</Name>
				<Source><![CDATA[
    public TaxRegistrationRecId parmTaxRegistrationRecId(TaxRegistrationRecId _taxRegistrationRecId)
    {
        taxRegistrationRecId = _taxRegistrationRecId;
        return taxRegistrationRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveCountryRegionId</Name>
				<Source><![CDATA[
    protected LogisticsAddressCountryRegionId resolveCountryRegionId(LogisticsAddressCountryRegionId _defaultCountryRegionId, TaxRegistrationRecId _partyTaxId)
    {
        return _defaultCountryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveVATNum</Name>
				<Source><![CDATA[
    protected VATNum resolveVATNum(VATNum _defaultVatNum, TaxRegistrationRecId _partyTaxId)
    {
        return _defaultVatNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCashDiscount</Name>
				<Source><![CDATA[
    private AmountCur calcCashDiscount(Voucher _voucher, TransDate _transDate)
    {
        TaxTrans taxTransLoc;
        TaxTable taxTable;
        InventTransId prevInventTransId;
        TaxGroup prevTaxGroup;
        TaxItemGroup prevTaxItemGroup;
        AmountCur utilizedCashDisc;

        while select sum(TaxBaseAmountCur) from taxTransLoc
            group by InventTransId, TaxGroup, TaxItemGroup, TaxCode
            where taxTransLoc.Voucher == _voucher
                && taxTransLoc.TransDate == _transDate
            exists join taxTable
                where taxTable.TaxCode == taxTransLoc.TaxCode
                    && taxTable.NotEUSalesList == NoYes::No
        {
            // Excluding TaxCode from the validation to skip records with "next" TaxCode and avoid adding the same TaxBaseAmountCur twice or more
            if (prevInventTransId == taxTransLoc.InventTransId &&
                prevTaxGroup == taxTransLoc.TaxGroup &&
                prevTaxItemGroup == taxTransLoc.TaxItemGroup)
            {
                continue;
            }

            utilizedCashDisc += taxTransLoc.TaxBaseAmountCur;

            prevInventTransId = taxTransLoc.InventTransId;
            prevTaxGroup = taxTransLoc.TaxGroup;
            prevTaxItemGroup = taxTransLoc.TaxItemGroup;
        }

        return utilizedCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxTransForCustSettlement</Name>
				<Source><![CDATA[
    protected void findTaxTransForCustSettlement(Voucher _voucher, TransDate _transDate)
    {
        taxTrans = TaxTrans::find(_voucher, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsTaxTransForVendSettlement</Name>
				<Source><![CDATA[
    protected boolean existsTaxTransForVendSettlement(Voucher _voucher, TransDate _transDate)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReportDiscount</Name>
				<Source><![CDATA[
    private boolean isReportDiscount()
    {
        if (taxRegistrationRecId)
        {
            EUSalesListReportDiscountSetup euSalesListReportDiscountSetup = EUSalesListReportingParameter::findByTaxRegistrationRecIdAndReport(
                taxRegistrationRecId,
                ReportingParameterReportCallerName::EUSalesList).EUSalesListReportDiscountSetup;

            if (euSalesListReportDiscountSetup != EUSalesListReportDiscountSetup::Default)
            {
                return euSalesListReportDiscountSetup == EUSalesListReportDiscountSetup::Yes;
            }
        }
            
        return IntrastatParameters::find().EUSalesListReportDisc;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>