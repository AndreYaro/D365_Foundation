<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetSplit</Name>
	<SourceCode>
		<Declaration><![CDATA[
class AssetSplit extends RunBase
{
    //<GEEU>
    #isoCountryRegionCodes
    //</GEEU>

    AssetId         assetId;
    AssetBookId     bookId;
    AssetTransDate  transDate;
    Percent         percent;
    LedgerJournalNameId     journalName;

    // variables that do not need to be packed/unpacked
    AssetBook       assetBook;
    LineNum         lineNum;
    Voucher         voucher;
    LedgerJournalId journalNum;
    private LedgerJournalTable ledgerJournal;

    private AssetReversalRelatedVoucherManager assetReversalRelatedVoucherManager;
    private boolean isOneVoucherFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetOneVoucherFeature::instance());
    private boolean isAssetSplitReportingCurrencyFeatureEnabled =
        (Ledger::reportingCurrency() != ''
        && Ledger::reportingCurrency() != Ledger::accountingCurrency())
        && FeatureStateProvider::isFeatureEnabled(AssetSplitReportingCurrencyFeature::instance());
    private boolean isBreakUpTransactionsByYearFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetSplitBreakUpTransactionsByYearFeature::instance());
    private boolean isAssetSplitDerivedJournalFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetSplitDerivedJournalFeature::instance());

    #define.CurrentVersion(1)
    #localMacro.CurrentList
        assetBook,
        assetId,
        bookId,
        transDate,
        percent,
        journalName
    #endMacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>assetBook</Name>
				<Source><![CDATA[
    AssetBook assetBook()
    {
        return assetBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an <c>AssetSplit</c> instance.
    /// </summary>
    /// <returns>An <c>AssetSplit</c> instance.</returns>
    public static AssetSplit construct()
    {
        return new AssetSplit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>LedgerJournalTrans</c> and <c>LedgerJournalTrans_Asset</c> transactions for the given
    ///    parameters.
    /// </summary>
    /// <param name="_paymentAmount">
    ///    The amount of the transaction.
    /// </param>
    /// <param name="_assetBook">
    ///    The asset book of the transaction.
    /// </param>
    /// <param name="_assetTransType">
    ///    The type of the asset transaction journal.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the asset transaction journal; optional.
    /// </param>
    /// <remarks>
    ///     Attention: This method can only be removed after the feature AssetSplitReportingCurrencyFeature has isEnabledByDefault = True and canDisable = False for 1 one major release
    /// </remarks>
    [SysObsolete('This method will be deprecated in a future release, use createTransWithContract instead.', false, 17\02\2022)]
    public void createTrans(AmountCur              _paymentAmount,
                            AssetBook              _assetBook,
                            AssetTransTypeJournal  _assetTransType,
                            TransDate              _transDate = transDate)
    {
        AssetTable assetTable = AssetTable::find(_assetBook.AssetId);

        TransactionTxt transactionTxt = this.createTransactionTxt(_assetBook, _transDate, assetTable);
        
        AssetBookTable assetBookTable = _assetBook.assetBookTable();
        AssetPostToGeneralLedger postToGeneralLedger = assetBookTable.postToGeneralLedger();

        LedgerJournalTrans ledgerJournalTrans = this.populateLedgerJournalTrans(_paymentAmount, _assetBook, _assetTransType, _transDate, assetTable, transactionTxt, assetBookTable, postToGeneralLedger);

        LedgerJournalTrans_Asset ledgerJournalTrans_Asset = this.populateLedgerJournalTrans_Asset(_paymentAmount, _assetBook, _assetTransType, _transDate, ledgerJournalTrans);

        this.insertLedgerJournalTrans(ledgerJournalTrans, ledgerJournalTrans_Asset, postToGeneralLedger, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>LedgerJournalTrans</c> and <c>LedgerJournalTrans_Asset</c> transactions for the given
    ///    parameters.
    /// </summary>
    /// <param name="_accountingCurrencyAmount">
    ///    The accounting currecny amount of the asset transaction journal line.
    /// </param>
    /// <param name="_assetBook">
    ///    The asset book of the transaction.
    /// </param>
    /// <param name="_assetTransType">
    ///    The type of the asset transaction journal.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the asset transaction journal; optional.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    ///    The reporting currency amount of the asset transaction journal; optional.
    /// </param>
    /// 
    [SysObsolete('This method will be deprecated in a future release, use createTransWithContract instead.', false, 02\05\2023)]
    public void createTransV2(
        AmountCur _accountingCurrencyAmount,
        AssetBook _assetBook,
        AssetTransTypeJournal _assetTransType,
        TransDate _transDate = transDate,
        AmountCur _reportingCurrencyAmount = 0.00)
    {
        AssetSplitTransContract contract = AssetSplitTransContract::construct(_accountingCurrencyAmount, _assetBook, _assetTransType, _transDate, _reportingCurrencyAmount);
        this.createTransWithContract(contract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransWithContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>LedgerJournalTrans</c> and <c>LedgerJournalTrans_Asset</c> transactions for the given contract.
    /// </summary>
    /// <param name = "_contract">The <c>AssetSplitTransContract</c> containing the parameters to use to create the transactions.</param>
    public void createTransWithContract(AssetSplitTransContract _contract)
    {
        AssetTable assetTable = AssetTable::find(_contract.parmAssetBook().AssetId);

        TransactionTxt transactionTxt = this.createTransactionTxt(_contract.parmAssetBook(), _contract.parmTransDate(), assetTable);
        
        AssetBookTable assetBookTable = _contract.parmAssetBook().assetBookTable();
        AssetPostToGeneralLedger postToGeneralLedger = assetBookTable.postToGeneralLedger();

        LedgerJournalTrans ledgerJournalTrans = this.populateLedgerJournalTrans(_contract.parmAccountingCurrencyAmount(), _contract.parmAssetBook(), _contract.parmAssetTransType(), _contract.parmTransDate(), assetTable, transactionTxt, assetBookTable, postToGeneralLedger);

        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
        if (isAssetSplitReportingCurrencyFeatureEnabled)
        {
            ledgerJournalTrans_Asset = this.populateLedgerJournalTrans_AssetV2(_contract.parmAccountingCurrencyAmount(), _contract.parmAssetBook(), _contract.parmAssetTransType(), _contract.parmTransDate(), ledgerJournalTrans, _contract.parmReportingCurrencyAmount());
        }
        else
        {
            ledgerJournalTrans_Asset = this.populateLedgerJournalTrans_Asset(_contract.parmAccountingCurrencyAmount(), _contract.parmAssetBook(), _contract.parmAssetTransType(), _contract.parmTransDate(), ledgerJournalTrans);
        }
        
        ledgerJournalTrans_Asset.IsPriorYear = _contract.parmIsPriorYear();

        if (AssetDepreciationPeriodFlight::instance().isEnabled())
        {
            ledgerJournalTrans_Asset.PeriodFromDate = _contract.parmAssetDepreciationPeriod().parmPeriodFromDate();
            ledgerJournalTrans_Asset.PeriodToDate = _contract.parmAssetDepreciationPeriod().parmPeriodToDate();
            ledgerJournalTrans_Asset.OriginalTransDate = _contract.parmTransDate();
            ledgerJournalTrans_Asset.OriginalIsPriorYear = _contract.parmIsPriorYear();
        }

        this.insertLedgerJournalTrans(ledgerJournalTrans, ledgerJournalTrans_Asset, postToGeneralLedger, _contract.parmTransDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionTxt</Name>
				<Source><![CDATA[
    private TransactionTxt createTransactionTxt(AssetBook _assetBook, transDate _transDate, AssetTable _assetTable)
    {
        TransactionTxt transactionTxt = TransactionTxt::construct(LedgerTransTxt::FixedAssetsPostingLedger);
        transactionTxt.setDate(_transDate);
        transactionTxt.setVoucher(voucher);
        transactionTxt.setKey1(_assetBook.AssetId);
        transactionTxt.setKey2(_assetTable.AssetGroup);

        if (TransactionTextContext::isTypeSupported(LedgerTransTxt::FixedAssetsPostingLedger))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::FixedAssetsPostingLedger);
            transactionTextContext.setTableBuffer(_assetBook.assetTable());
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerJournalTrans</Name>
				<Source><![CDATA[
    private void insertLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset, AssetPostToGeneralLedger _postToGeneralLedger, TransDate _transDate)
    {
        // Update the dimension
        LedgerJournalEngine ledgerJournalEngine = new LedgerJournalEngine();

        if (_postToGeneralLedger)
        {
            ledgerJournalEngine.initDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }

        _ledgerJournalTrans.insert();

        _ledgerJournalTrans_Asset.RefRecId = _ledgerJournalTrans.RecId;
        _ledgerJournalTrans_Asset.insert();

        if (isAssetSplitDerivedJournalFeatureEnabled
            && ledgerJournal.JournalType == LedgerJournalType::Assets)
        {
            LedgerJournalEngine::createDefsForAssetBookTableDerivedJourn(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }

        if (isOneVoucherFeatureEnabled)
        {
            this.addReversalRelatedVoucher(voucher, _transDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates a <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name="_paymentAmount">
    ///    The amount of the transaction.
    /// </param>
    /// <param name="_assetBook">
    ///    The asset book of the transaction.
    /// </param>
    /// <param name="_assetTransType">
    ///    The type of the asset transaction journal.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the asset transaction journal.
    /// </param>
    /// <param name = "_assetTable">
    ///    The <c>AssetTable</c> record for the asset associated with the asset book.
    /// </param>
    /// <param name = "_transactionTxt">
    ///    A <c>TransactionTxt</c> instance.
    /// </param>
    /// <param name = "_assetBookTable">
    ///    The <c>AssetBookTable</c> record associated with the asset book.
    /// </param>
    /// <param name = "_postToGeneralLedger">
    ///    A <c>AssetPostToGeneralLedger</c> enumeration value that represents if posting to general ledger should happen.
    /// </param>
    /// <returns>
    ///    A <c>LedgerJournalTrans</c> table buffer with fields populated.
    /// </returns>
    protected LedgerJournalTrans populateLedgerJournalTrans(AmountCur _paymentAmount,
        AssetBook _assetBook,
        AssetTransTypeJournal _assetTransType,
        TransDate _transDate,
        AssetTable _assetTable,
        TransactionTxt _transactionTxt,
        AssetBookTable _assetBookTable,
        AssetPostToGeneralLedger _postToGeneralLedger)
    {
        LedgerJournalTrans ledgerJournalTrans;

        ledgerJournalTrans.JournalNum           = journalNum;
        ledgerJournalTrans.Voucher              = voucher;
        ledgerJournalTrans.parmAccount(_assetBook.AssetId, LedgerJournalACType::FixedAssets);
        ledgerJournalTrans.PostingProfile       = _assetTable.postingProfile(_assetBook.BookId);
        ledgerJournalTrans.TransactionType      = LedgerTransType::FixedAssets;
        ledgerJournalTrans.TransDate            = _transDate;
        ledgerJournalTrans.CurrencyCode         = Ledger::accountingCurrency();
        ledgerJournalTrans.ExchRate             = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
        ledgerJournalTrans.Txt                  = _transactionTxt.txt();
        ledgerJournalTrans.Company              = curext();
        ledgerJournalTrans.DefaultDimension     = _assetBook.DefaultDimension;

        ledgerJournalTrans.OffsetCompany        = curext();
        ledgerJournalTrans.OffsetDefaultDimension = 0;
        ledgerJournalTrans.OffsetAccountType    = LedgerJournalACType::Ledger;

        if (_postToGeneralLedger)
        {
            LedgerDimensionDefaultAccount defaultAccount = _assetTable.assetOffsetLedgerDimension(ledgerJournalTrans.PostingProfile,
                                                                                         AssetPost::assetTransTypeJournal2AssetTransType(_assetTransType),
                                                                                         _assetBook.BookId);

            ledgerJournalTrans.parmOffsetLedgerDimension(ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.getOffsetCompany()));
        }

        if (_paymentAmount > 0)
        {
            ledgerJournalTrans.AmountCurDebit   = CurrencyExchangeHelper::amount(_paymentAmount, ledgerJournalTrans.CurrencyCode);
        }
        else
        {
            ledgerJournalTrans.AmountCurCredit  = CurrencyExchangeHelper::amount(-_paymentAmount, ledgerJournalTrans.CurrencyCode);
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTrans_Asset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates a <c>LedgerJournalTrans_Asset</c> table buffer.
    /// </summary>
    /// <param name="_paymentAmount">
    ///    The amount of the transaction.
    /// </param>
    /// <param name="_assetBook">
    ///    The asset book of the transaction.
    /// </param>
    /// <param name="_assetTransType">
    ///    The type of the asset transaction journal.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the asset transaction journal.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    ///    A populated <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///    A <c>LedgerJournalTrans_Asset</c> table buffer with fields populated.
    /// </returns>
    /// <remarks>
    ///     Attention: This method can only be removed after the feature AssetSplitReportingCurrencyFeature has isEnabledByDefault = True and canDisable = False for 1 one major release
    /// </remarks>
    [SysObsolete('This method will be deprecated in a future release, use populateLedgerJournalTrans_AssetV2 instead.', false, 17\02\2022)]
    protected LedgerJournalTrans_Asset populateLedgerJournalTrans_Asset(AmountCur _paymentAmount, AssetBook _assetBook, AssetTransTypeJournal _assetTransType, TransDate _transDate, LedgerJournalTrans _ledgerJournalTrans)
    {
        // Setup LedgerJournalTrans_Asset
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;

        ledgerJournalTrans_Asset.BookId         = _assetBook.BookId;
        ledgerJournalTrans_Asset.TransType      = _assetTransType;
        ledgerJournalTrans_Asset.AssetId        = _ledgerJournalTrans.parmAccount();
        ledgerJournalTrans_Asset.Company        = _ledgerJournalTrans.Company;
        ledgerJournalTrans_Asset.AssetTransSubType = AssetTransactionSubType::Split;

        return ledgerJournalTrans_Asset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTrans_AssetV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates a <c>LedgerJournalTrans_Asset</c> table buffer.
    /// </summary>
    /// <param name="_paymentAmount">
    ///    The amount of the transaction.
    /// </param>
    /// <param name="_assetBook">
    ///    The asset book of the transaction.
    /// </param>
    /// <param name="_assetTransType">
    ///    The type of the asset transaction journal.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the asset transaction journal.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    ///    A populated <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    ///    The reporting currency amount of the asset transaction journal; optional.
    /// </param>
    /// <returns>
    ///    A <c>LedgerJournalTrans_Asset</c> table buffer with fields populated.
    /// </returns>
    protected LedgerJournalTrans_Asset populateLedgerJournalTrans_AssetV2(AmountCur _paymentAmount,
        AssetBook _assetBook,
        AssetTransTypeJournal _assetTransType,
        TransDate _transDate,
        LedgerJournalTrans _ledgerJournalTrans,
        AmountCur _reportingCurrencyAmount = 0.00)
    {
        // Setup LedgerJournalTrans_Asset
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;

        ledgerJournalTrans_Asset.BookId         = _assetBook.BookId;
        ledgerJournalTrans_Asset.TransType      = _assetTransType;
        ledgerJournalTrans_Asset.AssetId        = _ledgerJournalTrans.parmAccount();
        ledgerJournalTrans_Asset.Company        = _ledgerJournalTrans.Company;
        ledgerJournalTrans_Asset.AssetTransSubType = AssetTransactionSubType::Split;

        if (_reportingCurrencyAmount > 0)
        {
            ledgerJournalTrans_Asset.AmountDebitReportingCurrency = CurrencyExchangeHelper::amount(_reportingCurrencyAmount, Ledger::reportingCurrency());
        }
        else
        {
            ledgerJournalTrans_Asset.AmountCreditReportingCurrency = CurrencyExchangeHelper::amount(-_reportingCurrencyAmount, Ledger::reportingCurrency());
        }

        return ledgerJournalTrans_Asset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        FormRun     dialogForm;
        Args        args = new Args(formStr(AssetSplit));

        args.caller(this);

        dialogForm = classfactory.formRunClass(args);
        dialogForm.init();

        return dialogForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last choice that is stored in the last value table.
    /// </summary>
    /// <remarks>
    ///    If no record can be found or the <c>RunBase.unpack</c> method returns false, the
    ///    <c>RunBase.initParmDefault</c> method will be called. Normally this method should not be overridden.
    /// </remarks>
    public void getLast()
    {
        // We do not want to call super here as we do not want to get the record from SysLastValue.
       //super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdatedSplitValueModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the existing asset book.
    /// </summary>
    /// <param name = "_assetId">
    /// A fixed asset number.
    /// </param>
    /// <param name = "_bookId">
    /// An asset book ID.
    /// </param>
    /// <returns>
    /// An <c>AssetBook</c> record.
    /// </returns>
    protected AssetBook getUpdatedSplitValueModel(AssetId _assetId, AssetBookId _bookId)
    {
        AssetBook splitAssetBook;

        splitAssetBook = AssetBook::find(_assetId, _bookId, true);
        splitAssetBook.Depreciation                  = assetBook.Depreciation;
        splitAssetBook.DepreciationStartDate         = assetBook.DepreciationStartDate;
        splitAssetBook.ServiceLife                   = assetBook.ServiceLife;
        splitAssetBook.LifeTime                      = assetBook.LifeTime;
        splitAssetBook.LifeTimeRest                  = assetBook.LifeTimeRest;
        splitAssetBook.UsedFromDate                  = assetBook.LastDepreciationDate ? assetBook.UsedFromDate : assetBook.UsedFromDate;
        splitAssetBook.DepreciationConvention        = assetBook.DepreciationConvention;

        splitAssetBook.AcquisitionDate               = assetBook.AcquisitionDate;
        splitAssetBook.LastDepreciationDateExtraOrd  = assetBook.LastDepreciationDateExtraOrd;
        splitAssetBook.ExceedingNetBookValue         = assetBook.ExceedingNetBookValue;
        splitAssetBook.NegativeNetBookValue          = assetBook.NegativeNetBookValue;
        splitAssetBook.RevaluationGroupId            = assetBook.RevaluationGroupId;
        splitAssetBook.ReserveTypeId                 = assetBook.ReserveTypeId;

        splitAssetBook.ConsumptionFactorId           = assetBook.ConsumptionFactorId;
        splitAssetBook.ConsumptionUnitId             = assetBook.ConsumptionUnitId;
        splitAssetBook.DepreciationAmountUnit        = assetBook.DepreciationAmountUnit;
        splitAssetBook.ConsumptionQtyEstimated       = assetBook.ConsumptionQtyEstimated;

        splitAssetBook.VendAccount                   = assetBook.VendAccount;
        splitAssetBook.PurchId                       = assetBook.PurchId;
        splitAssetBook.VendInvoiceId                 = assetBook.VendInvoiceId;

        // <GEECZ>
        splitAssetBook.DepreciationGroupId_W		 = assetBook.DepreciationGroupId_W;
        // </GEECZ>

        splitAssetBook.update();

        return splitAssetBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInstance</Name>
				<Source><![CDATA[
    protected void initInstance(AssetBook _assetBook)
    {
        assetBook   = _assetBook;
        transDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetId</Name>
				<Source><![CDATA[
    AssetId parmAssetId(AssetId _assetId = assetId)
    {
        assetId = _assetId;

        return assetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBookId</Name>
				<Source><![CDATA[
    AssetBookId parmBookId(AssetBookId _bookId = bookId)
    {
        bookId = _bookId;

        return bookId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalName</Name>
				<Source><![CDATA[
    LedgerJournalNameId parmJournalName(LedgerJournalNameId _journalName = journalName)
    {
        journalName = _journalName;

        return journalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPercent</Name>
				<Source><![CDATA[
    Percent parmPercent(Percent _percent = percent)
    {
        percent = _percent;

        return percent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    AssetTransDate parmTransDate(AssetTransDate _transDate = transDate)
    {
        transDate = _transDate;

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes([
            [#isoHU, GlobalizationConstants::FeatureReferenceEEU00049],
            [#isoCZ, GlobalizationConstants::FeatureReferenceEEU00049] ],
            funcName()
        );

        AssetSumCalc_Trans assetSumCalc_Trans = AssetSumCalc_Trans::newAssetYear(assetBook.AssetId, assetBook.BookId);
        Amount acquisitionValue = this.getSplitAmount(assetSumCalc_Trans.acquisitionValue() + assetSumCalc_Trans.acquisitionAdjValue());
        Amount depreciationValue = this.getSplitAmount(assetSumCalc_Trans.depreciationValue() + assetSumCalc_Trans.depreciationAdjValue());

        // <GEEPL>
        Amount depreciationValueNotCost;
        boolean isPolandContryContext = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);

        if (isPolandContryContext)
        {
            acquisitionValue  = CurrencyExchangeHelper::amount(acquisitionValue);
            depreciationValueNotCost = this.getSplitAmount(assetSumCalc_Trans.depreciationValueNotCost_PL());
        }
        // </GEEPL>

        ttsbegin;

        this.runInternal(assetSumCalc_Trans, acquisitionValue, depreciationValue, depreciationValueNotCost, isPolandContryContext);

        ttscommit;

        info(strFmt("@SYS67586", journalName, journalNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInternal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    /// <param name = "_assetSumCalc_Trans">
    ///    An <c>AssetSumCalc_Trans</c> instance.
    /// </param>
    /// <param name = "_acquisitionValue">
    ///    The acquisition amount.
    /// </param>
    /// <param name = "_depreciationValue">
    ///    The depreciation amount.
    /// </param>
    /// <param name = "_depreciationValueNotCost">
    ///    The Polish non-taxable amount of the depreciation.
    /// </param>
    /// <param name = "_isPolandContryContext">
    ///    A boolean indicating if the current country context is Poland.
    /// </param>
    protected void runInternal(AssetSumCalc_Trans _assetSumCalc_Trans, Amount _acquisitionValue, Amount _depreciationValue, Amount _depreciationValueNotCost, boolean _isPolandContryContext)
    {
        ledgerJournal = this.populateLedgerJournalTable();
        ledgerJournal.insert();

        assetReversalRelatedVoucherManager = this.createAssetReversalRelatedVoucherManager();

        // Calculation of acquisition value of the split component, commented the earlier code.
        JournalVoucherNum journalVoucherNum = new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(journalNum)));
        voucher = journalVoucherNum.getNew(true);

        AssetBook assetBookSplit = this.getUpdatedSplitValueModel(assetId, bookId);

        AssetSumCalc assetSumTransReportingCurrency;
        Amount acquisitionValueReporting, depreciationValueReporting;

        if (isAssetSplitReportingCurrencyFeatureEnabled)
        {
            // Reporting currency is only specified for the "split from" asset. The "split to" asset will use current exchange rate.
            assetSumTransReportingCurrency = AssetSumCalc_Trans::newAssetYearByCurrency(assetBook.AssetId,
                assetBook.BookId,
                assetBook.AcquisitionDate,
                AssetYear::All,
                AssetSumCalcType::Reporting);

            acquisitionValueReporting = this.getSplitAmount(assetSumTransReportingCurrency.acquisitionValue() + assetSumTransReportingCurrency.acquisitionAdjValue());
            depreciationValueReporting = this.getSplitAmount(assetSumTransReportingCurrency.depreciationValue() + assetSumTransReportingCurrency.depreciationAdjValue());

            if (isBreakUpTransactionsByYearFeatureEnabled)
            {
                this.createTransWithContract(AssetSplitTransContract::construct(-_acquisitionValue, assetBook, AssetTransTypeJournal::AcquisitionAdj, transDate, -acquisitionValueReporting));
            }
            else
            {
                this.createTransV2(-_acquisitionValue, assetBook, AssetTransTypeJournal::AcquisitionAdj, transDate, -acquisitionValueReporting);
            }
        }
        else
        {
            if (isBreakUpTransactionsByYearFeatureEnabled)
            {
                this.createTransWithContract(AssetSplitTransContract::construct(-_acquisitionValue, assetBook, AssetTransTypeJournal::AcquisitionAdj, transDate));
            }
            else
            {
                this.createTrans(-_acquisitionValue, assetBook, AssetTransTypeJournal::AcquisitionAdj);
            }
        }

        this.createForTransactionType(journalVoucherNum, _acquisitionValue, assetBookSplit, AssetTransTypeJournal::Acquisition);

        if (!isOneVoucherFeatureEnabled)
        {
            voucher = this.getNewVoucher(journalVoucherNum, voucher);
        }

        this.saveReversalRelatedVouchers();
        assetReversalRelatedVoucherManager = this.createAssetReversalRelatedVoucherManager();

        // If asset has already depreciated.
        if (assetBook.LastDepreciationDate)
        {
            if (this.isAssetSplitByYear())
            {
                this.createDepreciationTransactionsByYear(journalVoucherNum, assetBookSplit, _depreciationValue, depreciationValueReporting);
            }
            else
            {
                if (_isPolandContryContext)
                {
                    _depreciationValue -= _depreciationValueNotCost;
                }

                if (_depreciationValue)
                {
                    this.createForTransactionType(journalVoucherNum, -_depreciationValue, assetBook, AssetTransTypeJournal::DepreciationAdj, assetBook.LastDepreciationDate, -depreciationValueReporting);

                    if (_isPolandContryContext)
                    {
                        this.createForTransactionType(journalVoucherNum, _depreciationValue, assetBookSplit, AssetTransTypeJournal::AccumulatedDepreciation_PL, assetBook.LastDepreciationDate);
                    }
                    else
                    {
                        this.createForTransactionType(journalVoucherNum, _depreciationValue, assetBookSplit, AssetTransTypeJournal::Depreciation, assetBook.LastDepreciationDate);
                    }

                    if (isOneVoucherFeatureEnabled)
                    {
                        journalVoucherNum.used(voucher);
                    }
                }
            }
        }

        Amount writeUpValue                = this.getSplitAmount(_assetSumCalc_Trans.writeUpAdjValue());
        Amount writeDownValue              = this.getSplitAmount(_assetSumCalc_Trans.writeDownAdjValue());
        Amount extraOrdinaryDepreciation   = this.getSplitAmount(_assetSumCalc_Trans.extraDepreciationValue());
        Amount revaluation                 = this.getSplitAmount(_assetSumCalc_Trans.revaluationValue());
        Amount provisionForReserve         = this.getSplitAmount(_assetSumCalc_Trans.capitalReserveValue());
        Amount transferFromReserve         = this.getSplitAmount(_assetSumCalc_Trans.capitalReserveTransferValue());

        Amount writeUpValueReporting;
        Amount writeDownValueReporting;
        Amount extraOrdinaryDepreciationReporting;
        Amount revaluationReporting;
        Amount provisionForReserveReporting;
        Amount transferFromReserveReporting;

        if (isAssetSplitReportingCurrencyFeatureEnabled)
        {
            writeUpValueReporting = this.getSplitAmount(assetSumTransReportingCurrency.writeUpAdjValue());
            writeDownValueReporting = this.getSplitAmount(assetSumTransReportingCurrency.writeDownAdjValue());
            extraOrdinaryDepreciationReporting = this.getSplitAmount(assetSumTransReportingCurrency.extraDepreciationValue());
            revaluationReporting = this.getSplitAmount(assetSumTransReportingCurrency.revaluationValue());
            provisionForReserveReporting = this.getSplitAmount(assetSumTransReportingCurrency.capitalReserveValue());
            transferFromReserveReporting = this.getSplitAmount(assetSumTransReportingCurrency.capitalReserveTransferValue());
        }

        if (writeDownValue)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                this.createJournalTransactionsV2(writeDownValue, assetBookSplit, AssetTransTypeJournal::WriteDownAdj, writeDownValueReporting);
            }
            else
            {
                this.createJournalTransactions(writeDownValue, assetBookSplit, AssetTransTypeJournal::WriteDownAdj);
            }
        }

        if (extraOrdinaryDepreciation)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                this.createJournalTransactionsV2(extraOrdinaryDepreciation, assetBookSplit, AssetTransTypeJournal::ExtraordinaryDepreciation, extraOrdinaryDepreciationReporting);
            }
            else
            {
                this.createJournalTransactions(extraOrdinaryDepreciation, assetBookSplit, AssetTransTypeJournal::ExtraordinaryDepreciation);
            }
        }

        if (revaluation != 0)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                this.createJournalTransactionsV2(revaluation, assetBookSplit, AssetTransTypeJournal::Revaluation, revaluationReporting);
            }
            else
            {
                this.createJournalTransactions(revaluation, assetBookSplit, AssetTransTypeJournal::Revaluation);
            }
        }

        if (transferFromReserve)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                this.createJournalTransactionsV2(transferFromReserve, assetBookSplit, AssetTransTypeJournal::CapitalReserveTransfer, transferFromReserveReporting);
            }
            else
            {
                this.createJournalTransactions(transferFromReserve, assetBookSplit, AssetTransTypeJournal::CapitalReserveTransfer);
            }
        }

        if (writeUpValue)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                this.createJournalTransactionsV2(writeUpValue, assetBookSplit, AssetTransTypeJournal::WriteUpAdj, writeUpValueReporting);
            }
            else
            {
                this.createJournalTransactions(writeUpValue, assetBookSplit, AssetTransTypeJournal::WriteUpAdj);
            }
        }

        if (provisionForReserve)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                this.createJournalTransactionsV2(provisionForReserve, assetBookSplit, AssetTransTypeJournal::CapitalReserve, provisionForReserveReporting);
            }
            else
            {
                this.createJournalTransactions(provisionForReserve, assetBookSplit, AssetTransTypeJournal::CapitalReserve);
            }
        }

        // Create the Bonus depreciation transaction.
        Amount bonusValue = this.getSplitAmount(_assetSumCalc_Trans.bonusDepreciationValue());

        if (bonusValue)
        {
            if (isAssetSplitReportingCurrencyFeatureEnabled)
            {
                Amount bonusValueReporting = this.getSplitAmount(assetSumTransReportingCurrency.bonusDepreciationValue());
                this.createJournalTransactionsV2(bonusValue, assetBookSplit, AssetTransTypeJournal::BonusDepreciation, bonusValueReporting);
            }
            else
            {
                this.createJournalTransactions(bonusValue, assetBookSplit, AssetTransTypeJournal::BonusDepreciation);
            }
        }

        //<GEEPL>
        if (_isPolandContryContext)
        {
            Amount openingAccumulatedDepreciation = this.getSplitAmount(_assetSumCalc_Trans.openingAccumulatedDepreciation_PL());

            if (openingAccumulatedDepreciation)
            {
                if (isAssetSplitReportingCurrencyFeatureEnabled)
                {
                    Amount openingAccumulatedDepreciationReporting = this.getSplitAmount(assetSumTransReportingCurrency.openingAccumulatedDepreciation_PL());
                    this.createJournalTransactionsV2(openingAccumulatedDepreciation, assetBookSplit, AssetTransTypeJournal::AccumulatedDepreciation_PL, openingAccumulatedDepreciationReporting);
                }
                else
                {
                    this.createJournalTransactions(openingAccumulatedDepreciation, assetBookSplit, AssetTransTypeJournal::AccumulatedDepreciation_PL);
                }
            }

            if (_depreciationValueNotCost)
            {
                if (isAssetSplitReportingCurrencyFeatureEnabled)
                {
                    Amount depreciationValueNotCostReporting = this.getSplitAmount(assetSumTransReportingCurrency.depreciationValueNotCost_PL());
                    this.createJournalTransactionsV2(_depreciationValueNotCost, assetBookSplit, AssetTransTypeJournal::NotCostAllocatedPart_PL, depreciationValueNotCostReporting);
                }
                else
                {
                    this.createJournalTransactions(_depreciationValueNotCost, assetBookSplit, AssetTransTypeJournal::NotCostAllocatedPart_PL);
                }
            }
        }
        //</GEEPL>

        journalVoucherNum.used(voucher);

        this.saveReversalRelatedVouchers();

        AssetInstrumentationLogger::createLogger(AssetInstrumentationConstants::AssetOneVoucherFeatureLog)
            .logOneVoucherScenario(
                AssetInstrumentationConstants::Split,
                isOneVoucherFeatureEnabled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDepreciationTransactionsByYear</Name>
				<Source><![CDATA[
    private void createDepreciationTransactionsByYear(JournalVoucherNum _journalVoucherNum, AssetBook assetBookSplit, Amount _depreciationAllYears, Amount _depreciationValueReportingAllYears)
    {
        Amount priorYearsDepreciationValue = this.calculatePriorYearDepreciation(AssetSumCalcType::MST);
        
        // This years value is the difference between all year and prior years.
        // Can't use the assetSumCalc "This year" because this doesn't include transactions
        // that are in year(s) beyond, and these need to be included.
        Amount currentYearDepreciationValue = _depreciationAllYears - priorYearsDepreciationValue;

        Amount priorYearsDepreciationValueReporting;
        Amount currentYearDepreciationValueReporting;

        if (isAssetSplitReportingCurrencyFeatureEnabled)
        {
            // Reporting currency is only specified for the "split from" asset. The "split to" asset will use current exchange rate.
            priorYearsDepreciationValueReporting = this.calculatePriorYearDepreciation(AssetSumCalcType::Reporting);
            currentYearDepreciationValueReporting = _depreciationValueReportingAllYears - priorYearsDepreciationValueReporting;
        }

        if (priorYearsDepreciationValue)
        {
            AssetDepreciationPeriod assetPriorYearDepreciationPeriod = this.getPriorYearAssetDepreciationPeriod(assetBook);

            this.createForTransactionType(_journalVoucherNum, -priorYearsDepreciationValue, assetBook, AssetTransTypeJournal::DepreciationAdj, assetBook.LastDepreciationDate, -priorYearsDepreciationValueReporting, NoYes::Yes, assetPriorYearDepreciationPeriod);
            this.createForTransactionType(_journalVoucherNum, priorYearsDepreciationValue, assetBookSplit, AssetTransTypeJournal::Depreciation, assetBook.LastDepreciationDate, 0.00, NoYes::Yes, assetPriorYearDepreciationPeriod);
        }

        if (currentYearDepreciationValue)
        {
            AssetDepreciationPeriod assetCurrentYearDepreciationPeriod = this.getCurrentYearAssetDepreciationPeriod(assetBook);

            this.createForTransactionType(_journalVoucherNum, -currentYearDepreciationValue, assetBook, AssetTransTypeJournal::DepreciationAdj, assetBook.LastDepreciationDate, -currentYearDepreciationValueReporting, NoYes::No, assetCurrentYearDepreciationPeriod);
            this.createForTransactionType(_journalVoucherNum, currentYearDepreciationValue, assetBookSplit, AssetTransTypeJournal::Depreciation, assetBook.LastDepreciationDate, 0.00, NoYes::No, assetCurrentYearDepreciationPeriod);
        }

        if (isOneVoucherFeatureEnabled)
        {
            _journalVoucherNum.used(voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentYearAssetDepreciationPeriod</Name>
				<Source><![CDATA[
    private AssetDepreciationPeriod getCurrentYearAssetDepreciationPeriod(AssetBook _assetBook)
    {
        AssetDepreciationPeriod ret = AssetDepreciationPeriod::construct();
        
        if (!this.isAssetSplitByYear()
            || !AssetDepreciationPeriodFlight::instance().isEnabled())
        {
            return ret;
        }
        
        TransDate periodFromDate;
        AssetDepreciationProfile depreciationProfile = _assetBook.depreciationProfile();

        if (depreciationProfile.DepreciationYear == AssetDepreciationYear::Calendar)
        {
            periodFromDate = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), _assetBook.LastDepreciationDate);
        }
        else
        {
            RefRecId calendarRecId = AssetBookTable::find(_assetBook.BookId).getFiscalCalendar();
            periodFromDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, _assetBook.LastDepreciationDate);
        }

        ret.parmPeriodFromDate(periodFromDate);
        ret.parmPeriodToDate(_assetBook.LastDepreciationDate);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPriorYearAssetDepreciationPeriod</Name>
				<Source><![CDATA[
    private AssetDepreciationPeriod getPriorYearAssetDepreciationPeriod(AssetBook _assetBook)
    {
        AssetDepreciationPeriod ret = AssetDepreciationPeriod::construct();
        
        if (!this.isAssetSplitByYear()
            || !AssetDepreciationPeriodFlight::instance().isEnabled())
        {
            return ret;
        }
        
        TransDate periodToDate;
        AssetDepreciationProfile depreciationProfile = _assetBook.depreciationProfile();

        if (depreciationProfile.DepreciationYear == AssetDepreciationYear::Calendar)
        {
            periodToDate = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), _assetBook.LastDepreciationDate) - 1;
        }
        else
        {
            RefRecId calendarRecId = AssetBookTable::find(_assetBook.BookId).getFiscalCalendar();
            periodToDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId, _assetBook.LastDepreciationDate) - 1;
        }
        
        ret.parmPeriodToDate(periodToDate);
        ret.parmPeriodFromDate(DateTimeUtil::date(DateTimeUtil::addYears(periodToDate, -1)) +1);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePriorYearDepreciation</Name>
				<Source><![CDATA[
    private Amount calculatePriorYearDepreciation(AssetSumCalcType _calcType)
    {
        AssetDepreciationProfile depreciationProfile = assetBook.depreciationProfile();
        boolean isCalendarBasedMethod = depreciationProfile.DepreciationYear == AssetDepreciationYear::Calendar;

        AssetSumCalc_Trans assetSumPriorYears = AssetSumCalc_Trans::newAssetYearByCurrency(assetBook.AssetId, assetBook.BookId, assetBook.LastDepreciationDate, AssetYear::PriorYears, _calcType);
        assetSumPriorYears.parmIsUsedCalendar(isCalendarBasedMethod);

        // Also find any transactions that are in the current year, but are prior year transactions.
        AssetSumCalc_Trans assetSumWithIsPriorYearSet = AssetSumCalc_Trans::newAssetYearByCurrency(assetBook.AssetId, assetBook.BookId, assetBook.LastDepreciationDate, AssetYear::ThisYear, _calcType);
        assetSumWithIsPriorYearSet.parmIsUsedCalendar(isCalendarBasedMethod);
        assetSumWithIsPriorYearSet.parmIsPriorYear(true);
        assetSumWithIsPriorYearSet.parmMaintainCurrentYearDateRange(true);

        Amount totalPriorYearDepreciation = assetSumPriorYears.depreciationValue() + assetSumPriorYears.depreciationAdjValue() + assetSumWithIsPriorYearSet.depreciationValue() + assetSumWithIsPriorYearSet.depreciationAdjValue();
        Amount priorYearsDepreciationValue = this.getSplitAmount(totalPriorYearDepreciation);

        // It's possible for this value and currentYearDepreciationValue to both round up from .5 to 1.0. This causes the total depreciation to be off by 1.0.
        // Instead, round first, then subtract so that the total depreciation is correct.
        Amount roundedPriorYearsDepreciationValue = CurrencyExchangeHelper::amount(priorYearsDepreciationValue, Ledger::accountingCurrency());

        return roundedPriorYearsDepreciationValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssetSplitByYear</Name>
				<Source><![CDATA[
    private boolean isAssetSplitByYear()
    {
        boolean result = false;

        if (AssetSplitBreakUpTransactionsByYearFeature::isEnabled())
        {
            boolean isIsoJP = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]);
            boolean isJPDepreciationMethod = isIsoJP && AssetDepreciationProfile::isDepMethod_JP(assetBook.depreciationProfile().Method);
            
            // This is currently limited only to JP depreciation methods.
            result = isJPDepreciationMethod;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createForTransactionType</Name>
				<Source><![CDATA[
    private void createForTransactionType(
        JournalVoucherNum _journalVoucherNum,
        AmountCur _accountingCurrencyAmount,
        AssetBook _assetBook,
        AssetTransTypeJournal _assetTransType,
        TransDate _transDate = transDate,
        AmountCur _reportingCurrencyAmount = 0.00,
        NoYes isPriorYear = NoYes::No,
        AssetDepreciationPeriod _assetDepreciationPeriod = null)
    {
        if (isOneVoucherFeatureEnabled)
        {
            voucher = this.getNewVoucher(_journalVoucherNum, voucher);
        }

        if (isBreakUpTransactionsByYearFeatureEnabled)
        {
            AssetSplitTransContract contract = AssetSplitTransContract::construct(_accountingCurrencyAmount, _assetBook, _assetTransType, _transDate, _reportingCurrencyAmount);
            contract.parmIsPriorYear(isPriorYear);

            if (_assetDepreciationPeriod != null
                && _assetDepreciationPeriod.isPeriodDefined())
            {
                contract.parmAssetDepreciationPeriod(_assetDepreciationPeriod);
            }

            this.createTransWithContract(contract);
        }
        else if (isAssetSplitReportingCurrencyFeatureEnabled)
        {
            this.createTransV2(_accountingCurrencyAmount, _assetBook, _assetTransType, _transDate, _reportingCurrencyAmount);
        }
        else
        {
            this.createTrans(_accountingCurrencyAmount, _assetBook, _assetTransType, _transDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates a <c>LedgerJournalTable</c> table buffer.
    /// </summary>
    /// <returns>
    ///    A <c>LedgerJournalTable</c> table buffer with fields populated.
    /// </returns>
    protected LedgerJournalTable populateLedgerJournalTable()
    {
        LedgerJournalTable ledgerJournalTable;
        journalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();

        ledgerJournalTable.JournalNum = journalNum;
        ledgerJournalTable.JournalName = journalName;
        LedgerJournalName ledgerJournalName = LedgerJournalName::find(ledgerJournalTable.JournalName);

        ledgerJournalTable.Name = "@SYS67430";
        ledgerJournalTable.VoucherAllocatedAtPosting = ledgerJournalName.VoucherAllocatedAtPosting;

        if (ledgerJournalName.VoucherAllocatedAtPosting)
        {
            ledgerJournalTable.NumberSequenceTable = LedgerParameters::numRefLedgerTempVoucher().numberSequenceTable().RecId;
        }
        else
        {
            ledgerJournalTable.NumberSequenceTable = ledgerJournalName.NumberSequenceTable;
        }

        ledgerJournalTable.parmOffsetLedgerDimension(ledgerJournalName.parmOffsetLedgerDimension());
        ledgerJournalTable.JournalType = ledgerJournalName.JournalType;
        ledgerJournalTable.DocumentNum = ledgerJournalName.DocumentNum;
        ledgerJournalTable.FixedExchRate = ledgerJournalName.FixedExchRate;
        ledgerJournalTable.DetailSummaryPosting = ledgerJournalName.DetailSummary;
        ledgerJournalTable.FixedOffsetAccount = ledgerJournalName.FixedOffsetAccount;
        ledgerJournalTable.CurrencyCode = ledgerJournalName.CurrencyCode;
        ledgerJournalTable.CurrentOperationsTax = AssetBookTable::find(assetBook.BookId).CurrentOperationsTax;
        ledgerJournalTable.setDefaultDimension(ledgerJournalName);

        // Perform workflow approvals defaulting.
        ledgerJournalTable.initWFApprovalStatus(ledgerJournalName);

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>LedgerJournalTrans</c> and <c>LedgerJournalTrans_Asset</c> transactions.
    /// </summary>
    /// <param name = "_amount">
    ///    The transaction amount.
    /// </param>
    /// <param name = "_assetBookSplit">
    ///    An <c>AssetBook</c> record.
    /// </param>
    /// <param name = "_assetTransTypeJournal">
    ///    An <c>AssetTransTypeJournal</c> enumeration value.
    /// </param>
    [SysObsolete('This method will be deprecated in a future release, use createJournalTransactionsV2 instead.', false, 17\02\2022)]
    protected void createJournalTransactions(Amount _amount, AssetBook _assetBookSplit, AssetTransTypeJournal _assetTransTypeJournal)
    {
        JournalVoucherNum journalVoucherNum;

        if (isOneVoucherFeatureEnabled)
        {
            journalVoucherNum = new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(journalNum)));
        }

        // Journal line on main component.
        this.createForTransactionType(journalVoucherNum, -_amount, assetBook, _assetTransTypeJournal);

        // Journal line on split component.
        this.createForTransactionType(journalVoucherNum, _amount, _assetBookSplit, _assetTransTypeJournal);

        if (isOneVoucherFeatureEnabled)
        {
            journalVoucherNum.used(voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalTransactionsV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>LedgerJournalTrans</c> and <c>LedgerJournalTrans_Asset</c> transactions.
    /// </summary>
    /// <param name = "_amount">
    ///    The transaction amount.
    /// </param>
    /// <param name = "_assetBookSplit">
    ///    An <c>AssetBook</c> record.
    /// </param>
    /// <param name = "_assetTransTypeJournal">
    ///    An <c>AssetTransTypeJournal</c> enumeration value.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    ///    The reporting currency amount of the asset transaction journal; optional.
    /// </param>
    protected void createJournalTransactionsV2(
        Amount _amount,
        AssetBook _assetBookSplit,
        AssetTransTypeJournal _assetTransTypeJournal,
        AmountCur _reportingCurrencyAmount = 0.00)
    {
        JournalVoucherNum journalVoucherNum;

        if (isOneVoucherFeatureEnabled)
        {
            journalVoucherNum = new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(journalNum)));
        }

        // Journal line on main component.
        this.createForTransactionType(journalVoucherNum, -_amount, assetBook, _assetTransTypeJournal, transDate, -_reportingCurrencyAmount);

        // Journal line on split component.
        this.createForTransactionType(journalVoucherNum, _amount, _assetBookSplit, _assetTransTypeJournal);

        if (isOneVoucherFeatureEnabled)
        {
            journalVoucherNum.used(voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the last choice by using the <c>RunBase.pack</c> method.
    /// </summary>
    /// <remarks>
    ///    This method should not ordinarily be overridden.
    /// </remarks>
    public void saveLast()
    {
        // We do not want to call super here as we do not want to save the record to SysLastValue.
        //super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList] = _packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object _calledFrom = null)
    {
        boolean ret = true;

        if (!this.checkAssetExists())
        {
            ret = checkFailed(strFmt("@SYS67413", assetId));     // Asset does not exist
        }

        if (!this.checkAssetBookToExists())
        {
            ret = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookDoesNotExistForFixedAsset", bookId, assetId));     // Value model for asset does not exist
        }

        if (!this.checkAssetBookPostToGeneralLedger())
        {
            ret = checkFailed("@FixedAssets:FA_ErrorMessage_AssetSplitWithSamePostToGeneralLedger");
        }

        if (this.checkAssetBookToAssetStatusIsSoldOrScrapped())
        {
            ret = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookHasBeenSoldOrScrapped", assetId, bookId));
        }

        if (this.checkAssetBookAssetStatusIsSoldOrScrapped())
        {
            ret = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookHasBeenSoldOrScrapped", assetBook.AssetId, assetBook.BookId));
        }

        if (!transDate)
        {
            ret = checkFailed(strFmt("@SYS128707", date2StrUsr(transDate, DateFlags::FormatAll)));
        }

        if (!this.checkPercentage())
        {
            ret = checkFailed("@SYS67342");
        }

        if (!journalName)
        {
            ret = checkFailed(strFmt("@SYS21496", journalName));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the asset exists.
    /// </summary>
    /// <returns>
    /// true if the asset exists; otherwise, false.
    /// </returns>
    protected boolean checkAssetExists()
    {
        return AssetTable::exist(assetId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetBookToExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the asset book To exists.
    /// </summary>
    /// <returns>
    /// true if the asset book To exists; otherwise, false.
    /// </returns>
    protected boolean checkAssetBookToExists()
    {
        return AssetBook::exist(assetId, bookId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetBookPostToGeneralLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the post to general ledger value matches for the asset books.
    /// </summary>
    /// <returns>
    /// true if the post to general ledger value matches for the asset books; otherwise, false.
    /// </returns>
    protected boolean checkAssetBookPostToGeneralLedger()
    {
        AssetBook assetBookTo = AssetBook::find(assetId, bookId);

        return assetBookTo.assetBookTable().postToGeneralLedger() == assetBook.assetBookTable().postToGeneralLedger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetBookToAssetStatusIsSoldOrScrapped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the asset status for the To asset book is Sold or Scrapped.
    /// </summary>
    /// <returns>
    /// true if the asset status for the To asset book is Sold or Scrapped; otherwise, false.
    /// </returns>
    protected boolean checkAssetBookToAssetStatusIsSoldOrScrapped()
    {
        AssetBook assetBookTo = AssetBook::find(assetId, bookId);

        return (assetBookTo.Status == AssetStatus::Sold || assetBookTo.Status == AssetStatus::Scrapped);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetBookAssetStatusIsSoldOrScrapped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the asset status for the asset book is Sold or Scrapped.
    /// </summary>
    /// <returns>
    /// true if the asset status for the asset book is Sold or Scrapped; otherwise, false.
    /// </returns>
    protected boolean checkAssetBookAssetStatusIsSoldOrScrapped()
    {
        return (assetBook.Status == AssetStatus::Sold || assetBook.Status == AssetStatus::Scrapped);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the percentage value is valid.
    /// </summary>
    /// <returns>
    /// true if the percentage value is valid; otherwise, false.
    /// </returns>
    protected boolean checkPercentage()
    {
        return (percent > 0 && percent <= 100);
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static public ClassDescription description()
    {
        return "@SYS67430";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        AssetSplit assetSplit;

        if (args.dataset() != tableNum(AssetBook))
        {
            throw error(strFmt("@SYS25516", AssetSplit::description()));
        }

        assetSplit = AssetSplit::construct();
        assetSplit.initInstance(args.record());

        if (assetSplit.prompt())
        {
            assetSplit.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesAssetSplitJournalExist</Name>
				<Source><![CDATA[
    internal static boolean doesAssetSplitJournalExist()
    {
        return (select firstonly RecId from LedgerJournalTable
                    where ledgerJournalTable.Name == "@SYS67430"
                        && ledgerJournalTable.Posted).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesAssetSplitJournalExistForAssetBook</Name>
				<Source><![CDATA[
    internal static boolean doesAssetSplitJournalExistForAssetBook(AssetId _assetId, AssetBookId _bookId)
    {
        AssetTrans assetTrans;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;

        select firstonly RecId from assetTrans
            where assetTrans.AssetId == _assetId
                && assetTrans.BookId == _bookId
            exists join ledgerJournalTrans
            where ledgerJournalTrans.Voucher == assetTrans.Voucher
                && ledgerJournalTrans.TransDate == assetTrans.TransDate
            exists join ledgerJournalTable
            where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
            exists join ledgerJournalTrans_Asset
            where ledgerJournalTrans_Asset.RefRecId == ledgerJournalTrans.RecId
                && (ledgerJournalTrans_Asset.AssetTransSubType == AssetTransactionSubType::Split
                    || ledgerJournalTable.Name == "@SYS67430");

        return assetTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssetReversalRelatedVoucherManager</Name>
				<Source><![CDATA[
    private AssetReversalRelatedVoucherManager createAssetReversalRelatedVoucherManager()
    {
        if (isOneVoucherFeatureEnabled)
        {
            assetReversalRelatedVoucherManager = AssetReversalRelatedVoucherManager::construct();
        }

        return assetReversalRelatedVoucherManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReversalRelatedVoucher</Name>
				<Source><![CDATA[
    private void addReversalRelatedVoucher(
        Voucher _voucher,
        TransDate _transDate)
    {
        if (assetReversalRelatedVoucherManager)
        {
            assetReversalRelatedVoucherManager.addVoucher(_voucher, _transDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveReversalRelatedVouchers</Name>
				<Source><![CDATA[
    private void saveReversalRelatedVouchers()
    {
        if (isOneVoucherFeatureEnabled
            && assetReversalRelatedVoucherManager)
        {
            assetReversalRelatedVoucherManager.save();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewVoucher</Name>
				<Source><![CDATA[
    private Voucher getNewVoucher(JournalVoucherNum journalVoucherNum, Voucher oldVoucher)
    {
        journalVoucherNum.used(oldVoucher);
        journalVoucherNum = new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(journalNum)));
        voucher = journalVoucherNum.getNew(true);
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitAmount</Name>
				<Source><![CDATA[
    private Amount getSplitAmount(Amount _amount)
    {
        return (_amount * Percent / 100);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>