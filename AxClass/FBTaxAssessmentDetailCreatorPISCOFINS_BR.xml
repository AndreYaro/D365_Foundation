<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FBTaxAssessmentDetailCreatorPISCOFINS_BR</Name>
	<SourceCode>
		<Declaration><![CDATA[
class FBTaxAssessmentDetailCreatorPISCOFINS_BR extends FBTaxAssessmentDetailCreator_BR
{
    FiscalOrganization_BR               rootFiscalOrganization;
    FBContribAssessmentRegimen_BR       contribAssessmentRegimen;
    FBBookingPeriod_BR                  branchBookingPeriod;
    FBRevenueSourcePISCOFINS_BR         revenueSourceDeterminer;
    FBContribCreditBalanceController_BR contribCreditBalanceController;
    FBTaxAssessmentWhtBalanceControl_BR taxAssessmentWhtBalanceControl;
    RecordSortedList                    creditTypeTaxTransList;
    boolean                             shouldAdjustPennyDiff;
    FBContribAssetAssessment_BR         contribAssetAssessment;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustPennyDiff</Name>
				<Source><![CDATA[
    private void adjustPennyDiff()
    {
        FBContribCreditTypeTaxTrans_BR          creditTypeTaxTrans, creditTypeTaxTransToBeUpdated;
        FBTaxAssessmentCalculatorPISCOFINS_BR   taxAssessmentCalculator;

        // Post processing
        // Check possible round error
        select sum(TaxAmount) from creditTypeTaxTrans
            where   creditTypeTaxTrans.FBTaxAssessment_BR   == fbTaxAssessment.RecId;

        taxAssessmentCalculator = FBTaxAssessmentCalculator_BR::construct(fbTaxAssessment) as FBTaxAssessmentCalculatorPISCOFINS_BR;
        taxAssessmentCalculator.calculate();

        if (creditTypeTaxTrans.TaxAmount != taxAssessmentCalculator.getCreditsWithAdjustments())
        {
            select forUpdate firstOnly creditTypeTaxTransToBeUpdated
                order by CreditType
                where   creditTypeTaxTransToBeUpdated.FBTaxAssessment_BR    == fbTaxAssessment.RecId
                    &&  creditTypeTaxTransToBeUpdated.CreditOrigin          == FBContribCreditOrigin_BR::OwnOperation;

            creditTypeTaxTransToBeUpdated.TaxAmount += taxAssessmentCalculator.getCreditsWithAdjustments() - creditTypeTaxTrans.TaxAmount;
            creditTypeTaxTransToBeUpdated.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bookPostedFixedAssetTransactions</Name>
				<Source><![CDATA[
    protected void bookPostedFixedAssetTransactions(FBBookingPeriodRecId_BR _fbBookingPeriodRecId)
    {
        FBContribAssetTrans_BR    contribAssetTrans;

        update_recordSet contribAssetTrans
        setting FBContribAssetAssessment_BR = contribAssetAssessment.RecId
            where   contribAssetTrans.FBBookingPeriod_BR            == _fbBookingPeriodRecId
                &&  contribAssetTrans.FBContribAssetAssessment_BR   != contribAssetAssessment.RecId;

        contribAssetAssessment = FBContribAssetAssessment_BR::updateBalances(contribAssetAssessment.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bookPostedTaxAdjustments</Name>
				<Source><![CDATA[
    protected void bookPostedTaxAdjustments()
    {
        FBTaxAssessmentAdjustment_BR    taxAssessmentAdjustment;

        update_recordSet taxAssessmentAdjustment
        setting FBTaxAssessment_BR = fbTaxAssessment.recId
            where   taxAssessmentAdjustment.VoucherDataArea         == branchBookingPeriod.FiscalEstablishmentDataArea
                &&  taxAssessmentAdjustment.TaxType_BR              == fbTaxAssessment.TaxType
                &&  taxAssessmentAdjustment.TransDate               >= fbTaxAssessment.FromDate
                &&  taxAssessmentAdjustment.TransDate               <= fbTaxAssessment.ToDate
                &&  taxAssessmentAdjustment.FBTaxAssessment_BR      != fbTaxAssessment.recId
                &&  taxAssessmentAdjustment.FiscalEstablishmentId   == branchBookingPeriod.FiscalEstablishmentId
                &&  taxAssessmentAdjustment.Voucher                 != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>bookTaxBaseAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes tax base amount adjustments to booking period.
    /// </summary>
    protected void bookTaxBaseAdjustments()
    {
        FBTaxAssessmentAdjustment_BR taxAssessmentAdjustment;
        FBGeneralAdjustmentCodePISCOFINS_BR generalAdjustmentCodePISCOFINS;

        update_recordSet taxAssessmentAdjustment
        setting FBTaxAssessment_BR = fbTaxAssessment.recId
            where taxAssessmentAdjustment.TaxType_BR == fbTaxAssessment.TaxType
                &&  taxAssessmentAdjustment.TransDate >= fbTaxAssessment.FromDate
                &&  taxAssessmentAdjustment.TransDate <= fbTaxAssessment.ToDate
                &&  taxAssessmentAdjustment.FBTaxAssessment_BR != fbTaxAssessment.recId
            exists join generalAdjustmentCodePISCOFINS
                where generalAdjustmentCodePISCOFINS.RecId == taxAssessmentAdjustment.FBGeneralAdjustmentCode_BR
                    && (generalAdjustmentCodePISCOFINS.AdjustmentType == FBGeneralAdjustmentTypePISCOFINS_BR::DebitBaseIncrease
                        || generalAdjustmentCodePISCOFINS.AdjustmentType == FBGeneralAdjustmentTypePISCOFINS_BR::DebitBaseDecrease);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAssetAssessment</Name>
				<Source><![CDATA[
    private void constructAssetAssessment()
    {
        BrazilParameters brazilParameters;

        contribAssetAssessment = FBContribAssetAssessment_BR::findByBookingPeriod(fbTaxAssessment.FBBookingPeriod_BR, true);

        if (!contribAssetAssessment)
        {
            brazilParameters = BrazilParameters::find();

            contribAssetAssessment.FromDate             = fbTaxAssessment.FromDate;
            contribAssetAssessment.ToDate               = fbTaxAssessment.ToDate;
            contribAssetAssessment.FBBookingPeriod_BR   = fbTaxAssessment.FBBookingPeriod_BR;
            contribAssetAssessment.PISTaxValue          = brazilParameters.BasicTaxValuePISNonCumulative;
            contribAssetAssessment.COFINSTaxValue       = brazilParameters.BasicTaxValueCOFINSNonCumulative;
        }

        if (fbTaxAssessment.TaxType == TaxType_BR::PIS)
        {
            if (contribAssetAssessment.PISTaxAssessment != fbTaxAssessment.RecId)
            {
                contribAssetAssessment.PISTaxAssessment = fbTaxAssessment.RecId;
            }
        }
        else
        {
            if (contribAssetAssessment.COFINSTaxAssessment != fbTaxAssessment.RecId)
            {
                contribAssetAssessment.COFINSTaxAssessment = fbTaxAssessment.RecId;
            }
        }

        contribAssetAssessment.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructRevenueSourceDeterminer</Name>
				<Source><![CDATA[
    private void constructRevenueSourceDeterminer()
    {
        revenueSourceDeterminer = FBRevenueSourceFactory_BR::instance('Default');
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllAssessmentDetails</Name>
				<Source><![CDATA[
    public void createAllAssessmentDetails()
    {
        FiscalEstablishment_BR  fiscalEstablishment;

        ttsbegin;

        if (rootFiscalOrganization)
        {
            while select crossCompany RecId, FiscalOrganization_BR, FiscalEstablishmentId, DataAreaId from fiscalEstablishment
                where fiscalEstablishment.FiscalOrganization_BR == rootFiscalOrganization.RecId
                join branchBookingPeriod
                    where   fiscalEstablishment.FiscalEstablishmentId   == branchBookingPeriod.FiscalEstablishmentId
                        &&  fiscalEstablishment.dataAreaId              == branchBookingPeriod.FiscalEstablishmentDataArea
                        &&  branchBookingPeriod.PeriodMonth             == bookingPeriod.PeriodMonth
                        &&  branchBookingPeriod.PeriodYear              == bookingPeriod.PeriodYear
            {
                changeCompany(fiscalEstablishment.dataAreaId)
                {
                    this.createDetailsForFiscalDocuments(branchBookingPeriod.RecId);
                    this.createDetailsForFiscalReceipts(branchBookingPeriod.RecId);
                    this.createDetailsForTaxWithholdTrans(branchBookingPeriod.RecId);
                    this.createDetailsForNonFiscalOperations(branchBookingPeriod.RecId);

                    this.bookPostedTaxAdjustments();
                    this.bookTaxBaseAdjustments();
                    this.bookPostedFixedAssetTransactions(branchBookingPeriod.RecId);
                }
            }

            changeCompany(rootFiscalOrganization.FiscalEstablishmentDataArea)
            {
                this.updateCreditBalanceFromPreviousPeriod();
                this.updateCreditBalanceFromCurrentPeriod();
                contribCreditBalanceController.distributeRemainingCredit();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCreditControlDetail</Name>
				<Source><![CDATA[
    private void createCreditControlDetail()
    {
        FBContribCreditTypeTaxTrans_BR      creditTypeTaxTrans;
        FBContribCreditControlDetail_BR     creditControlDetail;

        while select sum(TaxAmount) from creditTypeTaxTrans
            group by creditTypeTaxTrans.CreditType, creditTypeTaxTrans.CreditOrigin, creditTypeTaxTrans.CreditOriginCNPJ
            where creditTypeTaxTrans.FBTaxAssessment_BR == fbTaxAssessment.RecId
        {
            creditControlDetail.clear();
            creditControlDetail.CreditOrigin            = creditTypeTaxTrans.CreditOrigin;
            creditControlDetail.CreditOriginCNPJ        = creditTypeTaxTrans.CreditOriginCNPJ;
            creditControlDetail.CreditType              = creditTypeTaxTrans.CreditType;
            creditControlDetail.FBTaxAssessment_BR      = fbTaxAssessment.RecId;
            creditControlDetail.PeriodMonth             = bookingPeriod.PeriodMonth;
            creditControlDetail.PeriodYear              = bookingPeriod.PeriodYear;
            creditControlDetail.PreviousCreditBalance   = creditTypeTaxTrans.TaxAmount;
            creditControlDetail.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDetailsForFiscalDocuments</Name>
				<Source><![CDATA[
    private void createDetailsForFiscalDocuments(RecId _fbBookingPeriodRecId)
    {
        FiscalDocument_BR                       fiscalDocument;
        FiscalDocumentLine_BR                   fiscalDocumentLine;
        FiscalDocumentTaxTrans_BR               fiscalDocumentTaxTrans;
        FBBookingPeriodFiscalDocument_BR        bookingPeriodFiscalDocument;
        FBTaxTrans_BR                           fbTaxTrans;
        FBTaxTrans_BR                           existingFbTaxTrans;
        FBContribAssessmentRegimen_BR           transAssessmentRegimen;
        LogisticsPostalAddress                  logisticsPostalAddress;
        boolean                                 includeIncomingDocs;

        includeIncomingDocs = contribAssessmentRegimen != FBContribAssessmentRegimen_BR::Cumulative;

        while select AccountingDate, Direction, FiscalDocumentNumber, FiscalEstablishment, DataAreaId , Model, RecId, Voucher, ThirdPartyPostalAddress
            from fiscalDocument
            where   fiscalDocument.AccountingDate   >= fbTaxAssessment.FromDate
                &&  fiscalDocument.AccountingDate   <= fbTaxAssessment.ToDate
                &&  (includeIncomingDocs || (!includeIncomingDocs && fiscalDocument.Direction == FiscalDocDirection_BR::Outgoing))
            join FBBookingPeriod_BR
                from bookingPeriodFiscalDocument
                where   bookingPeriodFiscalDocument.FBBookingPeriod_BR  == _fbBookingPeriodRecId
                    &&  bookingPeriodFiscalDocument.FiscalDocument_BR   == fiscalDocument.RecId
                    && (bookingPeriodFiscalDocument.FiscalSituation     == FBFiscalDocumentSituation_BR::Regular
                        || bookingPeriodFiscalDocument.FiscalSituation  == FBFiscalDocumentSituation_BR::Complementary
                        || bookingPeriodFiscalDocument.FiscalSituation  == FBFiscalDocumentSituation_BR::SpecialLegislation)
            join cfop, RecId, LineAmount, FinancialLedgerDimension, ItemId, FiscalClassification
                from fiscalDocumentLine
                where fiscalDocumentLine.FiscalDocument == fiscalDocument.RecId
            join FiscalValue, RecId, RetainedTax, TaxationOrigin, TaxationCode, TaxBaseAmount, TaxBaseAmountExempt, TaxBaseAmountOther, TaxAmount, Type, TaxValue, TaxNonRecoverablePct
                from fiscalDocumentTaxTrans
                where   fiscalDocumentTaxTrans.FiscalDocumentLine   == fiscalDocumentLine.RecId
                    &&  fiscalDocumentTaxTrans.Type                 == fbTaxAssessment.TaxType
                    &&  fiscalDocumentTaxTrans.RetainedTax          == false
            notexists join existingFbTaxTrans
                where existingFbTaxTrans.FiscalDocumentTaxTrans_BR  == fiscalDocumentTaxTrans.RecId
        {
            fbTaxTrans.clear();
            fbTaxTrans.TaxValue = fiscalDocumentTaxTrans.TaxValue;

            if (fiscalDocumentTaxTrans.FiscalValue == TaxFiscalValue_BR::WithCreditDebit)
            {
                fbTaxTrans.TaxValue -= fiscalDocumentTaxTrans.TaxNonRecoverablePct;
            }

            fbTaxTrans.TaxType                     = fiscalDocumentTaxTrans.Type;
            fbTaxTrans.FBTaxAssessment_BR          = fbTaxAssessment.RecId;
            fbTaxTrans.FiscalDocument_BR           = fiscalDocument.RecId;
            fbTaxTrans.FiscalEstablishmentId       = fiscalDocument.FiscalEstablishment;
            fbTaxTrans.FiscalEstablishmentDataArea = fiscalDocument.dataAreaId;
            fbTaxTrans.CFOP                        = fiscalDocumentLine.cfop;
            fbTaxTrans.LineAmount                  = fiscalDocumentLine.LineAmount;
            fbTaxTrans.FinancialLedgerDimension    = fiscalDocumentLine.FinancialLedgerDimension;

            fbTaxTrans.FiscalDocumentTaxTrans_BR   = fiscalDocumentTaxTrans.RecId;
            fbTaxTrans.TaxationCode                = fiscalDocumentTaxTrans.TaxationCode;
            fbTaxTrans.TaxBaseAmount               = fiscalDocumentTaxTrans.TaxBaseAmount;
            fbTaxTrans.TaxBaseAmountExempt         = fiscalDocumentTaxTrans.TaxBaseAmountExempt;
            fbTaxTrans.TaxBaseAmountOther          = fiscalDocumentTaxTrans.TaxBaseAmountOther;
            fbTaxTrans.TaxAmount                   = fiscalDocumentTaxTrans.TaxAmount;

            fbTaxTrans.Voucher                     = fiscalDocument.Voucher;
            fbTaxTrans.VoucherDataArea             = fiscalDocument.dataAreaId;
            fbTaxTrans.VoucherTransDate            = fiscalDocument.AccountingDate;

            using (FBRevenueSourcePISCOFINSContext_BR revSourceContext = FBRevenueSourcePISCOFINSContext_BR::construct())
            {
                revSourceContext.parmItemId(fiscalDocumentLine.ItemId);
                revSourceContext.parmTaxFiscalClassificationId_BR(fiscalDocumentLine.FiscalClassification);
                fbTaxTrans.RevenueSourcePISCOFINS = revenueSourceDeterminer.getRevenueSource(fbTaxAssessment.TaxType, fiscalDocumentTaxTrans.TaxationCode);
            }

            if (fiscalDocument.Direction == FiscalDocDirection_BR::Outgoing && TaxationCodeTable_BR::isTaxationCodeExcludedFromRevenue(fbTaxTrans.TaxType, fbTaxTrans.TaxationCode))
            {
                fbTaxTrans.PisCofinsRevenueClassification   = FBPISCofinsRevenueClassification_BR::None;
                fbTaxTrans.Classification                   = FBTaxAssessmentClassification_BR::Informative;
            }
            else
            {
                transAssessmentRegimen                      = this.getTransAssessmentRegimen(fiscalDocumentTaxTrans.Type, fbTaxTrans.TaxValue);
                logisticsPostalAddress                      = LogisticsPostalAddress::findRecId(fiscalDocument.ThirdPartyPostalAddress);

                fbTaxTrans.PisCofinsRevenueClassification   = this.getRevenueClassification(fbTaxTrans.CFOP, fiscalDocument.Direction, logisticsPostalAddress);
                fbTaxTrans.Classification                   = this.getClassificationForDocuments(fiscalDocumentTaxTrans.FiscalValue, transAssessmentRegimen, fiscalDocumentTaxTrans.Type, fbTaxTrans.TaxValue, fiscalDocument.Direction);
            }

            fbTaxTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDetailsForFiscalReceipts</Name>
				<Source><![CDATA[
    private void createDetailsForFiscalReceipts(RecId _fbBookingPeriodRecId)
    {
        RetailZReport_BR                        retailZReport;
        RetailFiscalReceipt_BR                  retailFiscalReceipt;
        RetailFiscalReceiptLine_BR              retailFiscalReceiptLine;
        RetailFiscalReceiptTaxTrans_BR          retailFiscalReceiptTaxTrans;
        FBBookingPeriodFiscalDocument_BR        bookingPeriodFiscalDocument;
        FBTaxTrans_BR                           existingFbTaxtrans;
        FBTaxTrans_BR                           fbTaxTrans;
        FBTaxAssessmentClassification_BR        classification;
        FBContribAssessmentRegimen_BR           transAssessmentRegimen;

        while select RecId
            from retailZReport
                where  retailZReport.AccountingDate                     >= fbTaxAssessment.FromDate
                    && retailZReport.AccountingDate                     <= fbTaxAssessment.ToDate
                    && retailZReport.IsStatementPosted                  == NoYes::Yes
            join RecId, Voucher, AccountingDate, DataAreaId, FiscalEstablishment
                from retailFiscalReceipt
                where  retailFiscalReceipt.FiscalPrinterSerialNumber    == retailZReport.FiscalPrinterSerialNumber
                    && retailFiscalReceipt.AdditionalFiscalMemoryIndex  == retailZReport.AdditionalFiscalMemoryIndex
                    && retailFiscalReceipt.ZReportNumber                == retailZReport.ZReportNumber
                    && retailFiscalReceipt.Status                       == FiscalDocumentStatus_BR::Approved
                    && retailFiscalReceipt.IsStatementPosted            == NoYes::Yes
            join RecId, cfop, LineAmount, LineDiscountAmount
                from retailFiscalReceiptLine
                where retailFiscalReceiptLine.StoreId                   == retailFiscalReceipt.StoreId
                    && retailFiscalReceiptLine.TerminalId               == retailFiscalReceipt.TerminalId
                    && retailFiscalReceiptLine.TransactionId            == retailFiscalReceipt.TransactionId
                    && retailFiscalReceiptLine.CancelledQuantity        == 0
            join RecId, TaxAmount, TaxBaseAmount, FiscalValue, TaxationCode, TransactionId, StoreId, TerminalId, TaxType, TaxValue
                from retailFiscalReceiptTaxTrans
                where  retailFiscalReceiptTaxTrans.StoreId              == retailFiscalReceiptLine.StoreId
                    && retailFiscalReceiptTaxTrans.TerminalId           == retailFiscalReceiptLine.TerminalId
                    && retailFiscalReceiptTaxTrans.TransactionId        == retailFiscalReceiptLine.TransactionId
                    && retailFiscalReceiptTaxTrans.LineNum              == retailFiscalReceiptLine.LineNum
                    && retailFiscalReceiptTaxTrans.TaxType              == fbTaxAssessment.TaxType
            exists join RecId
                from bookingPeriodFiscalDocument
                where bookingPeriodFiscalDocument.FBBookingPeriod_BR    == _fbBookingPeriodRecId
                    && bookingPeriodFiscalDocument.RetailZReport_BR     == retailZReport.RecId
                    && bookingPeriodFiscalDocument.FiscalSituation      == FBFiscalDocumentSituation_BR::Regular
            notexists join existingFbTaxtrans
                where existingFbTaxtrans.RetailFiscalReceiptTaxTrans_BR  == retailFiscalReceiptTaxTrans.RecId
        {
            transAssessmentRegimen = this.getTransAssessmentRegimen(retailFiscalReceiptTaxTrans.TaxType, retailFiscalReceiptTaxTrans.TaxValue);

            classification = this.getClassificationForDocuments(retailFiscalReceiptTaxTrans.FiscalValue, transAssessmentRegimen, retailFiscalReceiptTaxTrans.TaxType, retailFiscalReceiptTaxTrans.TaxValue, FiscalDocDirection_BR::Outgoing);

            fbTaxTrans.clear();
            fbTaxTrans.TaxType                         = fbTaxAssessment.TaxType;
            fbTaxTrans.FBTaxAssessment_BR              = fbTaxAssessment.RecId;
            fbTaxTrans.RetailFiscalReceiptTaxTrans_BR  = retailFiscalReceiptTaxTrans.RecId;
            fbTaxTrans.FiscalEstablishmentId           = retailFiscalReceipt.FiscalEstablishment;
            fbTaxTrans.FiscalEstablishmentDataArea     = retailFiscalReceipt.dataAreaId;
            fbTaxTrans.Classification                  = classification;
            fbTaxTrans.TaxAmount                       = retailFiscalReceiptTaxTrans.TaxAmount;
            fbTaxTrans.TaxValue                        = retailFiscalReceiptTaxTrans.TaxValue;
            fbTaxTrans.FinancialLedgerDimension        = FBSpedFileCreator_Contrib_BR::getFinancialDimensionByItemId(InventAccountType::SalesIssue, retailFiscalReceiptLine.ItemId);

            switch (retailFiscalReceiptTaxTrans.FiscalValue)
            {
                case TaxFiscalValue_BR::WithCreditDebit:
                    fbTaxTrans.TaxBaseAmount            = retailFiscalReceiptTaxTrans.TaxBaseAmount;
                    break;

                case TaxFiscalValue_BR::WithoutCreditDebitExempt:
                    fbTaxTrans.TaxBaseAmountExempt      = retailFiscalReceiptTaxTrans.TaxBaseAmount;
                    break;

                case TaxFiscalValue_BR::WithoutCreditDebitOther:
                    fbTaxTrans.TaxBaseAmountOther       = retailFiscalReceiptTaxTrans.TaxBaseAmount;
                    break;
            }

            fbTaxTrans.TaxationCode                    = retailFiscalReceiptTaxTrans.TaxationCode;
            fbTaxTrans.CFOP                            = retailFiscalReceiptLine.CFOP;
            fbTaxTrans.LineAmount                      = retailFiscalReceiptLine.LineAmount - retailFiscalReceiptLine.LineDiscountAmount;

            fbTaxTrans.Voucher                         = retailFiscalReceipt.Voucher;
            fbTaxTrans.VoucherDataArea                 = retailFiscalReceipt.dataAreaId;
            fbTaxTrans.VoucherTransDate                = retailFiscalReceipt.AccountingDate;

            using (FBRevenueSourcePISCOFINSContext_BR revSourceContext = FBRevenueSourcePISCOFINSContext_BR::construct())
            {
                fbTaxTrans.RevenueSourcePISCOFINS = revenueSourceDeterminer.getRevenueSource(fbTaxAssessment.TaxType, retailFiscalReceiptTaxTrans.TaxationCode);
            }

            fbTaxTrans.PisCofinsRevenueClassification = this.getRevenueClassification(fbTaxTrans.CFOP, FiscalDocDirection_BR::Outgoing, null);

            fbTaxTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDetailsForNonFiscalOperations</Name>
				<Source><![CDATA[
    private void createDetailsForNonFiscalOperations(RecId _fbBookingPeriodRecId)
    {
        FBTaxTrans_BR                       fbTaxTrans;
        FBNonFiscalOperationTaxTrans_BR     fbNonFiscalOpTaxTrans;
        FBNonFiscalOperation_BR             fbNonFiscalOperation;
        Query                               query;
        QueryBuildDataSource                nonFiscalOpQbds, nonFiscalOpTaxTransQbds, fbTaxTransQbds;
        QueryRun                            queryRun;
        TaxFiscalValue_BR                   fiscalValue;
        FiscalEstablishment_BR              fiscalEstablishment;
        LogisticsPostalAddress              logisticsPostalAddress;
        FBContribAssessmentRegimen_BR       transAssessmentRegimen;
        FiscalDocDirection_BR               direction;

        query = new Query();
        query.allowCrossCompany(true);

        nonFiscalOpQbds = query.addDataSource(tableNum(FBNonFiscalOperation_BR));
        nonFiscalOpQbds.addRange(fieldNum(FBNonFiscalOperation_BR, FBBookingPeriod_BR)).value(SysQuery::value(_fbBookingPeriodRecId));

        nonFiscalOpTaxTransQbds = nonFiscalOpQbds.addDataSource(tableNum(FBNonFiscalOperationTaxTrans_BR));
        nonFiscalOpTaxTransQbds.relations(true);
        nonFiscalOpTaxTransQbds.addRange(fieldNum(FBNonFiscalOperationTaxTrans_BR, Type)).value(SysQuery::value(fbTaxAssessment.TaxType));
        nonFiscalOpTaxTransQbds.joinMode(JoinMode::InnerJoin);

        fbTaxTransQbds = nonFiscalOpTaxTransQbds.addDataSource(tableNum(FBTaxTrans_BR));
        fbTaxTransQbds.relations(true);
        fbTaxTransQbds.joinMode(JoinMode::NoExistsJoin);

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            fbNonFiscalOperation    = queryRun.get(tableNum(FBNonFiscalOperation_BR));
            fbNonFiscalOpTaxTrans   = queryRun.get(tableNum(FBNonFiscalOperationTaxTrans_BR));
            fiscalValue             = this.getFiscalValueByTaxationCode(fbNonFiscalOpTaxTrans.TaxationCode);
            fiscalEstablishment     = FiscalEstablishment_BR::find(fbNonFiscalOperation.FiscalEstablishment_BR);
            direction               = fbNonFiscalOpTaxTrans.direction(fbNonFiscalOperation.AccountType);

            transAssessmentRegimen = this.getTransAssessmentRegimen(fbNonFiscalOpTaxTrans.Type, fbNonFiscalOpTaxTrans.TaxValue);

            fbTaxTrans.clear();
            fbTaxTrans.TaxType                          = fbTaxAssessment.TaxType;
            fbTaxTrans.FBTaxAssessment_BR               = fbTaxAssessment.RecId;
            fbTaxTrans.FBNonFiscalOperation_BR          = fbNonFiscalOperation.RecId;
            fbTaxTrans.FBNonFiscalOperationTaxTrans_BR  = fbNonFiscalOpTaxTrans.RecId;
            fbTaxTrans.FiscalEstablishmentId            = fiscalEstablishment.FiscalEstablishmentId;
            fbTaxTrans.FiscalEstablishmentDataArea      = fiscalEstablishment.dataAreaId;
            fbTaxTrans.LineAmount                       = fbNonFiscalOperation.TotalAmount;
            fbTaxTrans.Classification                   = this.getClassificationForDocuments(fiscalValue, transAssessmentRegimen, fbNonFiscalOpTaxTrans.Type, fbNonFiscalOpTaxTrans.TaxValue, direction);
            fbTaxTrans.TaxationCode                     = fbNonFiscalOpTaxTrans.TaxationCode;
            fbTaxTrans.TaxAmount                        = fbNonFiscalOpTaxTrans.TaxAmount;
            fbTaxTrans.TaxValue                         = fbNonFiscalOpTaxTrans.TaxValue;
            fbTaxTrans.FinancialLedgerDimension         = fbNonFiscalOperation.LedgerDimension;

            switch (fiscalValue)
            {
                case TaxFiscalValue_BR::WithCreditDebit:
                    fbTaxTrans.TaxBaseAmount        = fbNonFiscalOpTaxTrans.TaxBaseAmount;
                    break;

                case TaxFiscalValue_BR::WithoutCreditDebitExempt:
                    fbTaxTrans.TaxBaseAmountExempt  = fbNonFiscalOpTaxTrans.TaxBaseAmount;
                    break;

                case TaxFiscalValue_BR::WithoutCreditDebitOther:
                    fbTaxTrans.TaxBaseAmountOther   = fbNonFiscalOpTaxTrans.TaxBaseAmount;
                    break;
            }

            logisticsPostalAddress  = fbNonFiscalOperation.postalAddress();

            if (direction == FiscalDocDirection_BR::Outgoing && TaxationCodeTable_BR::isTaxationCodeExcludedFromRevenue(fbTaxTrans.TaxType, fbTaxTrans.TaxationCode))
            {
                fbTaxTrans.PisCofinsRevenueClassification   = FBPISCofinsRevenueClassification_BR::None;
                fbTaxTrans.Classification                   = FBTaxAssessmentClassification_BR::Informative;
            }
            else
            {
                fbTaxTrans.PisCofinsRevenueClassification   = this.getRevenueClassification('', direction, logisticsPostalAddress);
                fbTaxTrans.Classification                   = this.getClassificationForDocuments(fiscalValue, transAssessmentRegimen, fbNonFiscalOpTaxTrans.Type, fbNonFiscalOpTaxTrans.TaxValue, direction);
            }

            fbTaxTrans.Voucher                          = fbNonFiscalOperation.Voucher;
            fbTaxTrans.VoucherDataArea                  = fbNonFiscalOperation.FiscalEstablishmentDataArea;
            fbTaxTrans.VoucherTransDate                 = fbNonFiscalOperation.TransDate;

            using (FBRevenueSourcePISCOFINSContext_BR revSourceContext = FBRevenueSourcePISCOFINSContext_BR::construct())
            {
                fbTaxTrans.RevenueSourcePISCOFINS = revenueSourceDeterminer.getRevenueSource(fbTaxAssessment.TaxType, fbNonFiscalOpTaxTrans.TaxationCode);
            }

            fbTaxTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDetailsForTaxWithholdTrans</Name>
				<Source><![CDATA[
    private void createDetailsForTaxWithholdTrans(RecId _fbBookingPeriodRecId)
    {
        FBTaxWithholdTrans_BR               fbTaxWithholdTrans;
        FBTaxTrans_BR                       fbTaxTrans;
        Query                               query;
        QueryBuildDataSource                fbTaxWithholdTransQbds, fbTaxTransQbds;
        QueryRun                            queryRun;
        TaxAmount                           taxAmount;

        query = new Query();
        query.allowCrossCompany(true);

        fbTaxWithholdTransQbds = query.addDataSource(tableNum(FBTaxWithholdTrans_BR));
        fbTaxWithholdTransQbds.addRange(fieldNum(FBTaxWithholdTrans_BR, FBBookingPeriod_BR)).value(SysQuery::value(_fbBookingPeriodRecId));

        fbTaxTransQbds = fbTaxWithholdTransQbds.addDataSource(tableNum(FBTaxTrans_BR));
        fbTaxTransQbds.relations(true);
        fbTaxTransQbds.addRange(fieldNum(FBTaxTrans_BR, TaxType)).value(SysQuery::value(fbTaxAssessment.TaxType));
        fbTaxTransQbds.joinMode(JoinMode::NoExistsJoin);

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            fbTaxWithholdTrans = queryRun.get(tableNum(FBTaxWithholdTrans_BR));

            fbTaxTrans.clear();
            fbTaxTrans.TaxType                  = fbTaxAssessment.TaxType;
            fbTaxTrans.FBTaxAssessment_BR       = fbTaxAssessment.RecId;
            fbTaxTrans.FBTaxWithholdTrans_BR    = fbTaxWithholdTrans.RecId;
            fbTaxTrans.FiscalEstablishmentId    = fbTaxWithholdTrans.FiscalEstablishment;
            fbTaxTrans.FiscalEstablishmentDataArea = fbTaxWithholdTrans.dataAreaId;
            fbTaxTrans.Classification           = this.getClassificationForTaxWithholdTrans(fbTaxWithholdTrans.AssessmentRegimen);

            if (fbTaxAssessment.TaxType == TaxType_BR::PIS)
            {
                taxAmount = fbTaxWithholdTrans.PisWithholdAmount;
            }
            else
            {
                taxAmount = fbTaxWithholdTrans.CofinsWithholdAmount;
            }

            fbTaxTrans.PisCofinsRevenueClassification = FBPISCofinsRevenueClassification_BR::None;
            fbTaxTrans.TaxAmount                = taxAmount;
            fbTaxTrans.TaxBaseAmount            = fbTaxWithholdTrans.TaxWithholdBaseAmount;
            fbTaxTrans.Voucher                  = fbTaxWithholdTrans.VoucherId;
            fbTaxTrans.VoucherDataArea          = fbTaxWithholdTrans.dataAreaId;
            fbTaxTrans.VoucherTransDate         = fbTaxWithholdTrans.TransDate;
            fbTaxTrans.FinancialLedgerDimension = fbTaxWithholdTrans.FinancialLedgerDimension;

            fbTaxTrans.insert();

            taxAssessmentWhtBalanceControl.updateCreditFromTaxWithholdTrans(fbTaxWithholdTrans.CustWhtContributionType, taxAmount, fbTaxWithholdTrans.AssessmentRegimen);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCreditBaseSource</Name>
				<Source><![CDATA[
    private FBNonFiscalOpCreditSourceCode_BR determineCreditBaseSource(
        CFOPId_BR _cfop,
        FBNonFiscalOperationRecId_BR _fbNonFiscalOpRecId,
        TransDate _transDate,
        TaxServiceCodeId_BR _serviceCode = '')
    {
        FBNonFiscalOperation_BR fbNonFiscalOperation;

        if (_fbNonFiscalOpRecId)
        {
            select firstonly CreditSourceCode from fbNonFiscalOperation
                where fbNonFiscalOperation.RecId == _fbNonFiscalOpRecId;

            return fbNonFiscalOperation.CreditSourceCode;
        }

        if (FeatureStateProvider::isFeatureEnabled(FBSpedContributionsCreditBaseSourceDateEffectiveFeature::instance()))
        {
            return FBCFOPCreditBaseSource_BR::findCreditBaseSourceByCFOPServiceCodeOnDate(_cfop, _transDate, _serviceCode);
        }
        else
        {
            return FBCFOPCreditBaseSource_BR::findCreditBaseSourceByCFOPServiceCode(_cfop, _serviceCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCreditTypeSufix</Name>
				<Source><![CDATA[
    private str determineCreditTypeSufix(CFOPId_BR _cfop, TaxValue _taxValue)
    {
        BrazilParameters            brazilParameters;

        if (_cfop && strStartsWith(_cfop, '3'))
        {
            return '08';
        }

        brazilParameters = BrazilParameters::find();

        if (fbTaxAssessment.TaxType == TaxType_BR::PIS)
        {
            if (_taxValue == brazilParameters.BasicTaxValuePISNonCumulative)
            {
                return '01';
            }
            else
            {
                return '02';
            }
        }
        else if (fbTaxAssessment.TaxType == TaxType_BR::COFINS)
        {
            if (_taxValue == brazilParameters.BasicTaxValueCOFINSNonCumulative)
            {
                return '01';
            }
            else
            {
                return '02';
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssessmentRegimenByTaxValue</Name>
				<Source><![CDATA[
    private FBContribAssessmentRegimen_BR getAssessmentRegimenByTaxValue(TaxType_BR _taxType, TaxValue _taxValue)
    {
        BrazilParameters parameters;
        parameters = BrazilParameters::find();

        if (_taxType == TaxType_BR::PIS)
        {
            switch (_taxValue)
            {
                case parameters.BasicTaxValuePISCumulative:
                    return FBContribAssessmentRegimen_BR::Cumulative;
                case parameters.BasicTaxValuePISNonCumulative:
                    return FBContribAssessmentRegimen_BR::NonCumulative;
                default:
                    return FBContribAssessmentRegimen_BR::NonCumulative; // When the values don't match, we will assume NonCumulative
            }
        }
        else if (_taxType == TaxType_BR::COFINS)
        {
            switch (_taxValue)
            {
                case parameters.BasicTaxValueCOFINSCumulative:
                    return FBContribAssessmentRegimen_BR::Cumulative;
                case parameters.BasicTaxValueCOFINSNonCumulative:
                    return FBContribAssessmentRegimen_BR::NonCumulative;
                default:
                    return FBContribAssessmentRegimen_BR::NonCumulative; // When the values don't match, we will assume NonCumulative
            }
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClassificationForDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the tax assessment classification of a document.
    /// </summary>
    /// <param name="_fiscalValue">
    /// Document's fiscal value
    /// </param>
    /// <param name="_transContribAssessmentRegimen">
    /// Document's assessment regimen
    /// </param>
    /// <param name="_taxType">
    /// Tax type
    /// </param>
    /// <param name="_taxValue">
    /// Tax value
    /// </param>
    /// <param name="_direction">
    /// Document's direction
    /// </param>
    /// <returns>
    /// The tax assessment classification according to the fiscal value, Contrib assessment regimen and document direction.
    /// </returns>
    /// <remarks>
    /// This method should be used for fiscal documents, fiscal receipts and non fiscal operations.
    /// </remarks>
    public FBTaxAssessmentClassification_BR getClassificationForDocuments(  TaxFiscalValue_BR               _fiscalValue,
                                                                            FBContribAssessmentRegimen_BR   _transContribAssessmentRegimen,
                                                                            TaxType_BR                      _taxType,
                                                                            TaxValue                        _taxValue,
                                                                            FiscalDocDirection_BR           _direction)
    {
        BrazilParameters brazilParameters = BrazilParameters::find();

        switch (_transContribAssessmentRegimen)
        {
            case FBContribAssessmentRegimen_BR::Cumulative:
                switch (_fiscalValue)
                {
                    case TaxFiscalValue_BR::WithCreditDebit:
                        switch (fbTaxAssessment.ContribContributionType)
                        {
                            case FBContribAssessmentContributionType_BR::BasicTaxValue:
                                if (    (_taxType == TaxType_BR::PIS    && _taxValue == brazilParameters.BasicTaxValuePISCumulative)
                                    ||  (_taxType == TaxType_BR::COFINS && _taxValue == brazilParameters.BasicTaxValueCOFINSCumulative))
                                {
                                    return FBTaxAssessmentClassification_BR::CumulativeContribution;
                                }
                                return FBTaxAssessmentClassification_BR::Informative;

                            case FBContribAssessmentContributionType_BR::SpecificTaxValue:
                                return FBTaxAssessmentClassification_BR::CumulativeContribution;

                            default:
                                throw error(Error::wrongUseOfFunction(funcname()));
                        }
                    case TaxFiscalValue_BR::WithoutCreditDebitExempt:
                        return FBTaxAssessmentClassification_BR::CumulativeExempt;
                    case TaxFiscalValue_BR::WithoutCreditDebitOther:
                        return FBTaxAssessmentClassification_BR::CumulativeNonRecoverable;
                    default:
                        throw error(Error::wrongUseOfFunction(funcname()));
                }
            case FBContribAssessmentRegimen_BR::NonCumulative:
                switch (_fiscalValue)
                {
                    case TaxFiscalValue_BR::WithCreditDebit:
                        switch (fbTaxAssessment.ContribContributionType)
                        {
                            case FBContribAssessmentContributionType_BR::BasicTaxValue:
                                if (    (_taxType == TaxType_BR::PIS    && _taxValue == brazilParameters.BasicTaxValuePISNonCumulative)
                                    ||  (_taxType == TaxType_BR::COFINS && _taxValue == brazilParameters.BasicTaxValueCOFINSNonCumulative))
                                {
                                    return _direction == FiscalDocDirection_BR::Outgoing ? FBTaxAssessmentClassification_BR::DocumentDebit
                                                                                         : FBTaxAssessmentClassification_BR::DocumentCredit;
                                }
                                return FBTaxAssessmentClassification_BR::Informative;

                            case FBContribAssessmentContributionType_BR::SpecificTaxValue:
                                return _direction == FiscalDocDirection_BR::Outgoing ? FBTaxAssessmentClassification_BR::DocumentDebit
                                                                                     : FBTaxAssessmentClassification_BR::DocumentCredit;
                            default:
                                throw error(Error::wrongUseOfFunction(funcname()));
                        }
                    case TaxFiscalValue_BR::WithoutCreditDebitExempt:
                        return FBTaxAssessmentClassification_BR::TaxExempt;
                    case TaxFiscalValue_BR::WithoutCreditDebitOther:
                        return FBTaxAssessmentClassification_BR::TaxNonRecoverable;
                    default:
                        throw error(Error::wrongUseOfFunction(funcname()));
                }
            default:
                return FBTaxAssessmentClassification_BR::Informative;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClassificationForTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the tax assessment classification of a withholding tax.
    /// </summary>
    /// <param name="_contribAssessmentRegimen">
    /// TaxWithhold assessment regimen.
    /// </param>
    /// <returns>
    /// The tax assessment classification of a withholding tax according to the Contrib assessment regimen.
    /// </returns>
    public FBTaxAssessmentClassification_BR getClassificationForTaxWithholdTrans(FBContribAssessmentRegimen_BR _contribAssessmentRegimen)
    {
        return _contribAssessmentRegimen == FBContribAssessmentRegimen_BR::Cumulative ? FBTaxAssessmentClassification_BR::CumulativeWithholding
                                                                                      : FBTaxAssessmentClassification_BR::NonCumulativeWithholding;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCumWhtBalanceFromPreviousPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the cumulative withholding credit balance amount from previous period
    /// </summary>
    /// <returns>
    /// The cumulative withholding credit balance amount from previous period
    /// </returns>
    protected AmountMST getCumWhtBalanceFromPreviousPeriod()
    {
        AmountMST                               previousCreditBalance = 0;
        FBTaxAssessmentCalculatorPISCOFINS_BR   taxAssessmentCalculator;
        FBTaxAssessment_BR                      previousTaxAssessment;

        previousTaxAssessment = fbTaxAssessment.previousTaxAssessment();

        if (previousTaxAssessment)
        {
            taxAssessmentCalculator = previousTaxAssessment.getCalculator() as FBTaxAssessmentCalculatorPISCOFINS_BR;
            taxAssessmentCalculator.calculate();

            previousCreditBalance = taxAssessmentCalculator.getCumulativeWithholdingCreditAvailable() - taxAssessmentCalculator.getCumulativeWithholdings();
        }

        return previousCreditBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFiscalValueByTaxationCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a PIS/COFINS taxation code, this method determines the fiscal value.
    /// </summary>
    /// <param name="_taxationCode">
    /// PIS/COFINS taxation code.
    /// </param>
    /// <returns>
    /// Fiscal value related to the taxation code.
    /// </returns>
    public TaxFiscalValue_BR getFiscalValueByTaxationCode(TaxationCode_BR _taxationCode)
    {
        TaxationCodeTable_BR taxationCode;

        select firstonly FiscalValue from taxationCode
            where   taxationCode.TaxationCode   == _taxationCode
                &&  taxationCode.TaxType        == fbTaxAssessment.TaxType;

        return taxationCode.FiscalValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonCumWhtBalanceFromPreviousPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the non cumulative withholding credit balance amount from previous period
    /// </summary>
    /// <returns>
    /// The non cumulative withholding credit balance amount from previous period
    /// </returns>
    protected AmountMST getNonCumWhtBalanceFromPreviousPeriod()
    {
        AmountMST                               previousCreditBalance = 0;
        FBTaxAssessmentCalculatorPISCOFINS_BR   taxAssessmentCalculator;
        FBTaxAssessment_BR                      previousTaxAssessment;

        previousTaxAssessment = fbTaxAssessment.previousTaxAssessment();

        if (previousTaxAssessment)
        {
            taxAssessmentCalculator = previousTaxAssessment.getCalculator() as FBTaxAssessmentCalculatorPISCOFINS_BR;
            taxAssessmentCalculator.calculate();

            previousCreditBalance = taxAssessmentCalculator.getNonCumulativeWhtCredits() + taxAssessmentCalculator.getNonCumWhtCreditFromPreviousPeriod() - taxAssessmentCalculator.getUsedNonCumulativeWhtCredit();
        }

        return previousCreditBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevenueClassification</Name>
				<Source><![CDATA[
    private FBPISCofinsRevenueClassification_BR getRevenueClassification(CFOPId_BR _cfop, FiscalDocDirection_BR _direction, LogisticsPostalAddress _logisticsPostalAddress)
    {
        CFOPTable_BR cfop;
        FiscalEstablishment_BR fiscalEstablishment;

        fiscalEstablishment = bookingPeriod.fiscalEstablishment();

        if (_cfop)
        {
            cfop = CFOPTable_BR::findByCFOPId(_cfop);
        }

        if (_direction == FiscalDocDirection_BR::Incoming)
        {
            return FBPISCofinsRevenueClassification_BR::None;
        }
        else if (_direction == FiscalDocDirection_BR::Outgoing
            && cfop && cfop.CustVendLocation == CustVendLocation_BR::OutsideCountry)
        {
            return FBPISCofinsRevenueClassification_BR::ExternalMarket;
        }
        else if (_direction == FiscalDocDirection_BR::Outgoing
                && _logisticsPostalAddress && _logisticsPostalAddress.CountryRegionId != fiscalEstablishment.postalAddress().CountryRegionId)
        {
            return FBPISCofinsRevenueClassification_BR::ExternalMarket;
        }
        else
        {
            return FBPISCofinsRevenueClassification_BR::InternalMarket;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransAssessmentRegimen</Name>
				<Source><![CDATA[
    private FBContribAssessmentRegimen_BR getTransAssessmentRegimen(TaxType_BR _taxType, TaxValue _taxValue)
    {
        if (contribAssessmentRegimen == FBContribAssessmentRegimen_BR::Both)
        {
            return this.getAssessmentRegimenByTaxValue(_taxType, _taxValue);
        }
        else
        {
            return contribAssessmentRegimen;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditTypeDetail</Name>
				<Source><![CDATA[
    private void insertCreditTypeDetail(FBContribCreditTypeCode_BR          _creditType,
                                        FBContribCreditOrigin_BR            _creditOrigin,
                                        CNPJNum_BR                          _creditOriginCnpj,
                                        FBNonFiscalOpCreditSourceCode_BR    _creditBaseSourceValue,
                                        TaxationCode_BR                     _taxationCode,
                                        TaxValue                            _taxValue,
                                        AmountMST                           _originalTaxBaseAmount,
                                        AmountMST                           _nonCumulativeTaxBaseAmount,
                                        AmountMST                           _taxBaseAmount,
                                        AmountMST                           _taxAmount)
    {
        FBContribCreditTypeTaxTrans_BR  creditTypeTaxTrans;

        creditTypeTaxTrans.FBTaxAssessment_BR       = fbTaxAssessment.RecId;
        creditTypeTaxTrans.CreditType               = _creditType;
        creditTypeTaxTrans.CreditOrigin             = _creditOrigin;
        creditTypeTaxTrans.CreditOriginCNPJ         = _creditOriginCnpj;
        creditTypeTaxTrans.CreditBaseSourceValue    = _creditBaseSourceValue;
        creditTypeTaxTrans.TaxValue                 = _taxValue;
        creditTypeTaxTrans.TaxationCode             = _taxationCode;

        if (creditTypeTaxTransList.find(creditTypeTaxTrans))
        {
            creditTypeTaxTrans.TaxAmount                    += _taxAmount;
            creditTypeTaxTrans.TaxBaseAmount                += _taxBaseAmount;
            creditTypeTaxTrans.OriginalTaxBaseAmount        += _originalTaxBaseAmount;
            creditTypeTaxTrans.NonCumulativeTaxBaseAmount   += _nonCumulativeTaxBaseAmount;
            creditTypeTaxTrans.CumulativeTaxBaseAmount      += _originalTaxBaseAmount - _nonCumulativeTaxBaseAmount;
            creditTypeTaxTransList.ins(creditTypeTaxTrans, true);

            return;
        }

        creditTypeTaxTrans.TaxAmount                    += _taxAmount;
        creditTypeTaxTrans.TaxBaseAmount                += _taxBaseAmount;
        creditTypeTaxTrans.OriginalTaxBaseAmount        += _originalTaxBaseAmount;
        creditTypeTaxTrans.NonCumulativeTaxBaseAmount   += _nonCumulativeTaxBaseAmount;
        creditTypeTaxTrans.CumulativeTaxBaseAmount      += _originalTaxBaseAmount - _nonCumulativeTaxBaseAmount;
        creditTypeTaxTransList.ins(creditTypeTaxTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(FBTaxAssessment_BR _fbTaxAssessment)
    {
        FiscalEstablishment_BR fiscalEstablishment;

        super(_fbTaxAssessment);

        contribCreditBalanceController  = FBContribCreditBalanceController_BR::construct(_fbTaxAssessment);
        taxAssessmentWhtBalanceControl  = FBTaxAssessmentWhtBalanceControl_BR::construct(_fbTaxAssessment);
        fiscalEstablishment             = bookingPeriod.fiscalEstablishment();
        rootFiscalOrganization          = FiscalOrganization_BR::find(fiscalEstablishment.FiscalOrganization_BR);
        contribAssessmentRegimen        = fbTaxAssessment.ContribAssessmentRegimen;

        this.constructRevenueSourceDeterminer();
        this.constructAssetAssessment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCreditAdjustments</Name>
				<Source><![CDATA[
    private void processCreditAdjustments()
    {
        FBTaxAssessmentAdjustment_BR            taxAdjustment;
        FBGeneralAdjustmentCodePISCOFINS_BR     pisCofinsAdjustmentCode;
        FBContribCreditType_BR                  fbContribCreditType;
        FBTaxTrans_BR                           fbTaxTrans;

        while select TaxAmount, TaxBaseAmount, TaxValue, TaxationCode from fbTaxTrans
                where fbTaxTrans.FBTaxAssessment_BR                 == fbTaxAssessment.RecId
            join ContribCreditBaseSource, DeductionCNPJ, FBContribCreditType_BR from taxAdjustment
                where   fbTaxTrans.FBTaxAssessmentAdjustment_BR     == taxAdjustment.RecId
                    &&  taxAdjustment.IsCancelled                   == NoYes::No
            join AdjustmentType from pisCofinsAdjustmentCode
                where   taxAdjustment.FBGeneralAdjustmentCode_BR    == pisCofinsAdjustmentCode.RecId
        {
            switch (pisCofinsAdjustmentCode.AdjustmentType)
            {
                case FBGeneralAdjustmentTypePISCOFINS_BR::CreditIncrease:
                    fbContribCreditType = FBContribCreditType_BR::find(taxAdjustment.FBContribCreditType_BR);

                    this.insertCreditTypeDetail(fbContribCreditType.Code,
                                                FBContribCreditOrigin_BR::OwnOperation,
                                                '',
                                                FBNonFiscalOpCreditSourceCode_BR::OtherCreditOperations,
                                                fbTaxTrans.TaxationCode,
                                                fbTaxTrans.TaxValue,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxAmount);
                    break;

                case FBGeneralAdjustmentTypePISCOFINS_BR::CreditDecrease:
                    fbContribCreditType = FBContribCreditType_BR::find(taxAdjustment.FBContribCreditType_BR);

                    this.insertCreditTypeDetail(fbContribCreditType.Code,
                                                FBContribCreditOrigin_BR::OwnOperation,
                                                '',
                                                FBNonFiscalOpCreditSourceCode_BR::OtherCreditOperations,
                                                fbTaxTrans.TaxationCode,
                                                fbTaxTrans.TaxValue,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxBaseAmount,
                                                -fbTaxTrans.TaxBaseAmount,
                                                -fbTaxTrans.TaxAmount);
                    break;

                case FBGeneralAdjustmentTypePISCOFINS_BR::CreditTransfer:
                    fbContribCreditType = FBContribCreditType_BR::find(taxAdjustment.FBContribCreditType_BR);

                    this.insertCreditTypeDetail(fbContribCreditType.Code,
                                                FBContribCreditOrigin_BR::TransferredFromLegalEntity,
                                                taxAdjustment.DeductionCNPJ,
                                                FBNonFiscalOpCreditSourceCode_BR::OtherCreditOperations,
                                                fbTaxTrans.TaxationCode,
                                                fbTaxTrans.TaxValue,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxBaseAmount,
                                                fbTaxTrans.TaxAmount);
                    break;

                case FBGeneralAdjustmentTypePISCOFINS_BR::AssetCreditAppropriation:
                    fbContribCreditType = FBContribCreditType_BR::find(taxAdjustment.FBContribCreditType_BR);

                    this.processCreditTaxTransByTaxationCode(   fbTaxTrans.TaxationCode,
                                                                fbContribCreditType ? subStr(fbContribCreditType.Code, 2, 2) : '01',
                                                                taxAdjustment.ContribCreditBaseSource,
                                                                fbTaxTrans.TaxValue,
                                                                fbTaxTrans.TaxBaseAmount,
                                                                fbTaxTrans.TaxBaseAmount);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCreditTaxTransByTaxationCode</Name>
				<Source><![CDATA[
    private void processCreditTaxTransByTaxationCode(   TaxationCode_BR                     _taxationCode,
                                                        str                                 _creditTypeSufix,
                                                        FBNonFiscalOpCreditSourceCode_BR    _creditBaseSource,
                                                        TaxValue                            _taxValue,
                                                        AmountMST                           _taxBaseAmount,
                                                        AmountMST                           _originalTaxBaseAmount)
    {
        FBContribCreditTypeCode_BR  creditType;
        AmountMST                   taxAmount;
        AmountMST                   taxBaseAmountGroup100, taxBaseAmountGroup200, taxBaseAmountGroup300;
        AmountMST                   taxableRevenueAmount, nonTaxableRevenueAmount, externalMarketRevenueAmount;
        container                   revenueAmountsAndNonCumulativeRate;

        revenueAmountsAndNonCumulativeRate = FBContribCreditBalanceControl_BR::getRevenueAmountAndNonCumulativeRate(fbTaxAssessment.RecId);

        taxableRevenueAmount        = conPeek(revenueAmountsAndNonCumulativeRate, 1);
        nonTaxableRevenueAmount     = conPeek(revenueAmountsAndNonCumulativeRate, 2);
        externalMarketRevenueAmount = conPeek(revenueAmountsAndNonCumulativeRate, 3);

        CurrencyCode currencyCode = Ledger::accountingCurrency();

        switch (_taxationCode)
        {
            case '50':
            case '60':
                creditType = '1' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(_taxBaseAmount * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, _taxBaseAmount, taxAmount);

                break;
            case '51':
            case '61':
                creditType = '2' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(_taxBaseAmount * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, _taxBaseAmount, taxAmount);

                break;
            case '52':
            case '62':
                creditType = '3' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(_taxBaseAmount * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, _taxBaseAmount, taxAmount);

                break;
            case '53':
            case '63':
                if (taxableRevenueAmount + nonTaxableRevenueAmount == 0)
                {
                    taxBaseAmountGroup100 = 0;
                    taxBaseAmountGroup200 = 0;

                    shouldAdjustPennyDiff = false;
                }
                else
                {
                    taxBaseAmountGroup100 = CurrencyExchange::round(_taxBaseAmount * taxableRevenueAmount / (taxableRevenueAmount + nonTaxableRevenueAmount), currencyCode);
                    taxBaseAmountGroup200 = _taxBaseAmount - taxBaseAmountGroup100;
                }

                creditType = '1' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup100 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup100, taxAmount);

                creditType = '2' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup200 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup200, taxAmount);

                break;
            case '54':
            case '64':
                if (taxableRevenueAmount + externalMarketRevenueAmount == 0)
                {
                    taxBaseAmountGroup100 = 0;
                    taxBaseAmountGroup300 = 0;

                    shouldAdjustPennyDiff = false;
                }
                else
                {
                    taxBaseAmountGroup100 = CurrencyExchange::round(_taxBaseAmount * taxableRevenueAmount / (taxableRevenueAmount + externalMarketRevenueAmount), currencyCode);
                    taxBaseAmountGroup300 = _taxBaseAmount - taxBaseAmountGroup100;
                }

                creditType = '1' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup100 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup100, taxAmount);

                creditType = '3' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup300 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup300, taxAmount);

                break;
            case '55':
            case '65':
                if (nonTaxableRevenueAmount + externalMarketRevenueAmount == 0)
                {
                    taxBaseAmountGroup200 = 0;
                    taxBaseAmountGroup300 = 0;

                    shouldAdjustPennyDiff = false;
                }
                else
                {
                    taxBaseAmountGroup200 = CurrencyExchange::round(_taxBaseAmount * nonTaxableRevenueAmount / (nonTaxableRevenueAmount + externalMarketRevenueAmount), currencyCode);
                    taxBaseAmountGroup300 = _taxBaseAmount - taxBaseAmountGroup200;
                }

                creditType = '2' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup200 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup200, taxAmount);

                creditType = '3' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup300 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup300, taxAmount);

                break;
            case '56':
            case '66':
                if (taxableRevenueAmount + nonTaxableRevenueAmount + externalMarketRevenueAmount == 0)
                {
                    taxBaseAmountGroup100 = 0;
                    taxBaseAmountGroup200 = 0;
                    taxBaseAmountGroup300 = 0;

                    shouldAdjustPennyDiff = false;
                }
                else
                {
                    taxBaseAmountGroup100 = CurrencyExchange::round(_taxBaseAmount * taxableRevenueAmount / (taxableRevenueAmount + nonTaxableRevenueAmount + externalMarketRevenueAmount), currencyCode);
                    taxBaseAmountGroup200 = CurrencyExchange::round(_taxBaseAmount * nonTaxableRevenueAmount / (taxableRevenueAmount + nonTaxableRevenueAmount + externalMarketRevenueAmount), currencyCode);
                    taxBaseAmountGroup300 = _taxBaseAmount - taxBaseAmountGroup100 - taxBaseAmountGroup200;
                }

                creditType = '1' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup100 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup100, taxAmount);

                creditType = '2' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup200 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup200, taxAmount);

                creditType = '3' + _creditTypeSufix;
                taxAmount = CurrencyExchange::round(taxBaseAmountGroup300 * _taxValue / 100, currencyCode);
                this.insertCreditTypeDetail(creditType, FBContribCreditOrigin_BR::OwnOperation, '', _creditBaseSource, _taxationCode, _taxValue, _originalTaxBaseAmount, _taxBaseAmount, taxBaseAmountGroup300, taxAmount);

                break;
            default:
                // Wrong taxation code configuration
                shouldAdjustPennyDiff = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIncomingDocuments</Name>
				<Source><![CDATA[
    private void processIncomingDocuments()
    {
        AmountMST originalTaxBaseAmount, nonCumulativeTaxBaseAmount;
        FBTaxTrans_BR fbTaxTrans;
        str creditTypeSufix;
        FBNonFiscalOpCreditSourceCode_BR creditBaseSource;
        real nonCumulativeRevenueRate;
        container revenueAmountsAndNonCumulativeRate;
        FiscalDocumentLine_BR fiscalDocumentLine;
        FiscalDocumentTaxTrans_BR fiscalDocumentTaxTrans;

        revenueAmountsAndNonCumulativeRate = FBContribCreditBalanceControl_BR::getRevenueAmountAndNonCumulativeRate(fbTaxAssessment.RecId);

        nonCumulativeRevenueRate = conPeek(revenueAmountsAndNonCumulativeRate, 6);

        while select crosscompany sum(TaxBaseAmount), sum(TaxBaseAmountExempt), sum(TaxBaseAmountOther) from fbTaxTrans
			group by
                fbTaxTrans.TaxationCode,
                fbTaxTrans.CFOP,
                fbTaxTrans.TaxValue,
                fbTaxTrans.FBNonFiscalOperation_BR,
                fiscalDocumentLine.ServiceCode
			where fbTaxTrans.FBTaxAssessment_BR == fbTaxAssessment.RecId
			    && fbTaxTrans.Classification == FBTaxAssessmentClassification_BR::DocumentCredit
			outer join fiscalDocumentTaxTrans
				where fiscalDocumentTaxTrans.RecId == fbTaxTrans.FiscalDocumentTaxTrans_BR
			outer join fiscalDocumentLine
				where fiscalDocumentLine.RecId == fiscalDocumentTaxTrans.FiscalDocumentLine
        {
            creditTypeSufix = this.determineCreditTypeSufix(fbTaxTrans.CFOP, fbTaxTrans.TaxValue);
            creditBaseSource = this.determineCreditBaseSource(fbTaxTrans.CFOP, fbTaxTrans.FBNonFiscalOperation_BR, fbTaxAssessment.ToDate, fiscalDocumentLine.ServiceCode);
            originalTaxBaseAmount = fbTaxTrans.TaxBaseAmount + fbTaxTrans.TaxBaseAmountExempt + fbTaxTrans.TaxBaseAmountOther;

            CurrencyCode currencyCode = Ledger::accountingCurrency();

            nonCumulativeTaxBaseAmount = CurrencyExchange::round(originalTaxBaseAmount * nonCumulativeRevenueRate, currencyCode);

            this.processCreditTaxTransByTaxationCode(fbTaxTrans.TaxationCode, creditTypeSufix, creditBaseSource, fbTaxTrans.TaxValue, nonCumulativeTaxBaseAmount, originalTaxBaseAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditBalanceFromCurrentPeriod</Name>
				<Source><![CDATA[
    public void updateCreditBalanceFromCurrentPeriod()
    {
        FBContribCreditTypeTaxTrans_BR  creditTypeTaxTrans;
        FBContribCreditControlDetail_BR creditControlDetail;

        // Delete old data
        delete_from creditTypeTaxTrans
            where creditTypeTaxTrans.FBTaxAssessment_BR == fbTaxAssessment.RecId;

        delete_from creditControlDetail
            // Manual entries from previous periods should not be deleted
            where   creditControlDetail.PeriodMonth == bookingPeriod.PeriodMonth
                &&  creditControlDetail.PeriodYear  == bookingPeriod.PeriodYear
                &&  creditControlDetail.FBTaxAssessment_BR  == fbTaxAssessment.RecId;

        // Curret data
        shouldAdjustPennyDiff = true;

        creditTypeTaxTransList = new RecordSortedList(tableNum(FBContribCreditTypeTaxTrans_BR));
        creditTypeTaxTransList.sortOrder(   fieldNum(FBContribCreditTypeTaxTrans_BR, FBTaxAssessment_BR),
                                            fieldNum(FBContribCreditTypeTaxTrans_BR, CreditType),
                                            fieldNum(FBContribCreditTypeTaxTrans_BR, CreditOrigin),
                                            fieldNum(FBContribCreditTypeTaxTrans_BR, CreditOriginCnpj),
                                            fieldNum(FBContribCreditTypeTaxTrans_BR, CreditBaseSourceValue),
                                            fieldNum(FBContribCreditTypeTaxTrans_BR, TaxValue),
                                            fieldNum(FBContribCreditTypeTaxTrans_BR, TaxationCode));

        // Process incoming documents
        // This method updates the variable "shouldAdjustPennyDiff" in case of revenue = 0 for a specific credit type distribution
        this.processIncomingDocuments();

        // Process credit adjustments
        this.processCreditAdjustments();

        creditTypeTaxTransList.insertDatabase();

        if (shouldAdjustPennyDiff)
        {
            this.adjustPennyDiff();
        }

        // Update balances related to fixed asset credit
        FBContribAssetAssessment_BR::updateBalances(contribAssetAssessment.RecId);

        // History data
        // Create history tables based on the credit type transactions created previously
        this.createCreditControlDetail();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditBalanceFromPreviousPeriod</Name>
				<Source><![CDATA[
    public void updateCreditBalanceFromPreviousPeriod()
    {
        FBTaxTrans_BR       fbTaxTrans;

        ttsBegin;

        // Update the history tables
        contribCreditBalanceController.updateCreditBalanceFromPreviousPeriod();

        // Update tax transactions
        // Credit from previous period
        // It is necessary to select the record that is not related to manual entries
        select forupdate firstOnly fbTaxTrans
            where   fbTaxTrans.Classification                   == FBTaxAssessmentClassification_BR::CreditBalanceFromPreviousPeriod
                &&  fbTaxTrans.FBTaxAssessment_BR               == fbTaxAssessment.RecId
                &&  fbTaxTrans.FBContribCreditControlDetail_BR  == 0;

        fbTaxTrans.TaxAmount = this.getCreditBalanceFromPreviousPeriod();

        if (fbTaxTrans)
        {
            fbTaxTrans.update();
        }
        else
        {
            if (fbTaxTrans.TaxAmount != 0)
            {
                fbTaxTrans.TaxType              = fbTaxAssessment.TaxType;
                fbTaxTrans.Classification       = FBTaxAssessmentClassification_BR::CreditBalanceFromPreviousPeriod;
                fbTaxTrans.FBTaxAssessment_BR   = fbTaxAssessment.RecId;

                FBBookingPeriod_BR fbBookingPeriod = fbTaxAssessment.bookingPeriod();
                fbTaxTrans.FiscalEstablishmentId = fbBookingPeriod.FiscalEstablishmentId;
                fbTaxTrans.FiscalEstablishmentDataArea = fbBookingPeriod.FiscalEstablishmentDataArea;

                fbTaxTrans.insert();
            }
        }

        // Withholding credit from previous period
        if (    fbTaxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::Cumulative
            ||  fbTaxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::Both)
        {
            select forupdate firstOnly fbTaxTrans
                where   fbTaxTrans.Classification                       == FBTaxAssessmentClassification_BR::CumulativeWhtFromPreviousPeriod
                    &&  fbTaxTrans.FBTaxAssessment_BR                   == fbTaxAssessment.RecId
                    &&  fbTaxTrans.FBTaxWithholdTransCreditDetail_BR    == 0;

            fbTaxTrans.TaxAmount = this.getCumWhtBalanceFromPreviousPeriod();

            if (fbTaxTrans)
            {
                fbTaxTrans.update();
            }
            else
            {
                if (fbTaxTrans.TaxAmount != 0)
                {
                    fbTaxTrans.TaxType              = fbTaxAssessment.TaxType;
                    fbTaxTrans.Classification       = FBTaxAssessmentClassification_BR::CumulativeWhtFromPreviousPeriod;
                    fbTaxTrans.FBTaxAssessment_BR   = fbTaxAssessment.RecId;

                    fbTaxTrans.insert();
                }
            }
        }

        if (    fbTaxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::NonCumulative
            ||  fbTaxAssessment.ContribAssessmentRegimen == FBContribAssessmentRegimen_BR::Both)
        {
            select forupdate firstOnly fbTaxTrans
                where   fbTaxTrans.Classification                       == FBTaxAssessmentClassification_BR::NonCumulativeWhtFromPreviousPeriod
                    &&  fbTaxTrans.FBTaxAssessment_BR                   == fbTaxAssessment.RecId
                    &&  fbTaxTrans.FBTaxWithholdTransCreditDetail_BR    == 0;

            fbTaxTrans.TaxAmount = this.getNonCumWhtBalanceFromPreviousPeriod();

            if (fbTaxTrans)
            {
                fbTaxTrans.update();
            }
            else
            {
                if (fbTaxTrans.TaxAmount != 0)
                {
                    fbTaxTrans.TaxType              = fbTaxAssessment.TaxType;
                    fbTaxTrans.Classification       = FBTaxAssessmentClassification_BR::NonCumulativeWhtFromPreviousPeriod;
                    fbTaxTrans.FBTaxAssessment_BR   = fbTaxAssessment.RecId;

                    fbTaxTrans.insert();
                }
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>