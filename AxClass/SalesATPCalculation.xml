<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesATPCalculation</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SalesATPCalculation</c> class is responsible for performing available to promise calculations.
/// </summary>
class SalesATPCalculation
{
    ItemId                             itemId;
    InventDimId                        inventDimId;
    MarginIssue                        marginIssue;
    SalesATPSettingsMap                salesATPSettingsMap;
    CalendarId                         issueMarginCalendarId;
    InventTransId                      derivedPurchLineInventTransId;
    InventTransId                      replacedSalesLineInventTransId;
    private SalesShippingDateRequested shippingDateRequested;
    private SalesDeliveryScheduleFormContext deliverySchecduleFormContext;
    protected boolean                  useSupplyForcastInATPCheckIsEnabled;
    [SysObsolete('This class member is deprecated because it is not used in this class anymore.', false, 28\04\2024)]
    protected boolean                  optimizedQueryForProcessSupplyDemandIsEnabled = true;
    protected boolean                  deliveryScheduleFormContextFeatureIsEnabled;    

    private SalesInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmShippingDateRequested</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the requested shipping date sales line.
    /// Used in <c>SalesATPCalculationShelfLife</c> to determine the available batches in the on-hand calculation.
    /// </summary>
    /// <param name = "_shippingDateRequested">The requested shipping date of the sales line.</param>
    /// <returns>The requested shipping date of the sales line.</returns>
    public SalesShippingDateRequested parmShippingDateRequested(SalesShippingDateRequested _shippingDateRequested = shippingDateRequested)
    {
        this.shippingDateRequested = _shippingDateRequested;
        return this.shippingDateRequested;
    }

]]></Source>
			</Method>
			<Method>
				<Name>atpLeadTimeFromSimulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the Available To Promise (ATP) lead time based on precalculated ATP simulation.
    /// </summary>
    /// <param name="_qtyOrdered">
    /// The quantity for which the ATP lead time is calculated.
    /// </param>
    /// <param name="_effectiveOrderDate">
    /// The effective order date of the sales order line.
    /// </param>
    /// <param name="_simulatedATP">
    /// The simulated ATP for upcoming days.
    /// </param>
    /// <returns>
    /// The ATP lead time.
    /// </returns>
    public SalesATPTimeFence atpLeadTimeFromSimulation(
        InventQty                   _qtyOrdered,
        TransDate                   _effectiveOrderDate,
        SalesTmpATP                 _simulatedATP)
    {
        SalesATPTimeFence           daysDifference;
        SalesATPTimeFence           atpLeadTime;

        select firstonly _simulatedATP
            order by atpDate
            where _simulatedATP.atpQty >= _qtyOrdered;

        if (_simulatedATP.RecId)
        {
            //there is a promise date from an inbound order
            //the daysDifference is the days difference between the order date and the promise date
            daysDifference = max(_simulatedATP.atpDate - _effectiveOrderDate, 0);
        }
        else
        {
            //there is no promise date
            //the days difference is the time fence (starting following day)
            daysDifference = salesATPSettingsMap.atpTimeFence + 1;
        }

        // The parameter to walk the issue margin using working days is set
        // and the order is using ATP + Issue margin
        if (salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATPPlusIssueMargin
            && marginIssue && ReqParameters::find().MarginCalendarDays)
        {
            WorkCalendarSched workCalendarSched = new WorkCalendarSched();
            TransDate atpDate = workCalendarSched.schedDate(
                SchedDirection::Forward,
                //when to start traversing
                _effectiveOrderDate + daysDifference,
                //walked in calendar days
                marginIssue,
                true,
                issueMarginCalendarId);

            atpLeadTime = atpDate - _effectiveOrderDate;
        }
        else
        {
            //
            // leadTime is always added to the final result of ATP delivery date calculation.
            // By adding the leadTime, "ATP + Issue margin" delivery date control method is implemented.
            //
            atpLeadTime = daysDifference + marginIssue;
        }

        return atpLeadTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>atpLeadTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the Available To Promise (ATP) lead time.
    /// </summary>
    /// <param name="_qtyOrdered">
    /// The quantity for which the ATP lead time is calculated.
    /// </param>
    /// <param name="_effectiveOrderDate">
    /// The effective order date of the sales order line.
    /// </param>
    /// <param name="_inventTransId">
    /// The <c>InventTransId</c> value of the <c>SalesLine</c> record from where the lead time is
    /// calculated. The <c>InventTransId</c> value is not included in the calculation; optional.
    /// </param>
    /// <returns>
    /// The ATP lead time.
    /// </returns>
    public SalesATPTimeFence atpLeadTime(
        InventQty                   _qtyOrdered,
        TransDate                   _effectiveOrderDate,
        InventTransId               _inventTransId = '')
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().atpLeadTime())
        {
            SalesTmpATP                 salesTmpATPLocal;

            salesTmpATPLocal.setTmpData(this.calcSalesTmpATP(_inventTransId));

            return this.atpLeadTimeFromSimulation(_qtyOrdered, _effectiveOrderDate, salesTmpATPLocal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSalesTmpATP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the Available To Promise (ATP) on the temporary records of the <c>SalesTmpATP</c> table.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventory transaction ID of the sales order line, if called from a sales order line, is not to
    /// be included in this calculation; optional.
    /// </param>
    /// <param name="_orderQty">
    /// The order quantity, needed for chart binding.
    /// </param>
    /// <returns>
    /// The <c>SalesTmpATP</c> record.
    /// </returns>
    /// <remarks>
    /// The <c>SalesTmpATP.ATP</c> field is filled in this method.
    /// </remarks>
    public SalesTmpATP calcSalesTmpATP(InventTransId _inventTransId = '', Qty _orderQty = 0)
    {
        SalesTmpATP                 salesTmpATP;
        SalesTmpATP                 salesTmpATPMin;

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calcSalesTmpATP())
        {
            // Set the records in the SalesTmpATP regarding onhand, issues, receipts but not ATP
            salesTmpATP.setTmpData(this.calculation(_inventTransId));

            salesTmpATPMin.setTmpData(salesTmpATP);

            int64 recordsUpdated;

            while select forupdate salesTmpATP
                order by atpDate
            {
                // find future minimum cumulated net receipt quantity ( = projected on hand).
                // this select only needs to be executed in the first loop and whenever the minimum date is not a future date anymore.
                if (!salesTmpATPMin.atpDate || salesTmpATPMin.atpDate >= salesTmpATP.atpDate)
                {
                    select firstonly ProjectedOnhand, atpDate from salesTmpATPMin
                        order by ProjectedOnhand, atpDate desc
                        where salesTmpATPMin.atpDate > salesTmpATP.atpDate;
                }

                //ATP qty is projected on hand, unless there is a future period that 'borrows' some or all of the current quantity.
                //In that case the quantity is reduced accordingly.
                salesTmpATP.atpQty = max(0,salesTmpATP.ProjectedOnhand);

                if (salesTmpATPMin.atpDate && salesTmpATPMin.ProjectedOnhand < salesTmpATP.ProjectedOnhand)
                {
                    salesTmpATP.atpQty = max(0,salesTmpATP.atpQty - (salesTmpATP.ProjectedOnhand - salesTmpATPMin.ProjectedOnhand));
                }

                salesTmpATP.UnavailableOnHand = max(0, salesTmpATP.ProjectedOnhand) - salesTmpATP.ATPQty;
                salesTmpATP.OrderQty = _orderQty;
                salesTmpATP.update();

                recordsUpdated++;
            }

            activityContext
                .addCustomProperty('HasInventTransId', any2Str(_inventTransId != ''))
                .addCustomProperty('HasOrderedQuantity', any2Str(_orderQty != 0))
                .addCustomProperty('RecordsUpdated', int642Str(recordsUpdated));
        }

        return salesTmpATP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates on hand inventory quantity for all records in specified <paramref name="_salesTmpATP" />
    /// parameter table buffer.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// A table buffer for which on hand inventory quantity will be calculated.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Inventory dimensions criteria that is used to calculate on-hand inventory quantity.
    /// </param>
    /// <param name="_inventDimParm">
    /// Inventory dimension parameters that is used to calculate on-hand inventory quantity.
    /// </param>
    /// <remarks>
    /// In order to reflect an actual on hand inventory level, this method should be called after both
    /// actual and planned orders have been processed for every record in the specified <paramref
    /// name="_salesTmpATP" /> parameter table buffer.
    /// </remarks>
    protected void calculateOnHand(
        SalesTmpATP         _salesTmpATP,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calculateOnHand())
        {
            // Setting the projected onhand in the SalesTmpATP table and setting those SalesTmpATP with no issues or receipts.
            InventQtyPhysicalOnhand onHand = this.currentOnHand(
                itemId,
                _inventDimCriteria,
                _inventDimParm,
                DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpTimeFence);

            for (int i = 0; i <= salesATPSettingsMap.atpTimeFence; i++)
            {
                select firstonly forupdate _salesTmpATP
                    where _salesTmpATP.atpDate == DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + i;

                onHand                      = onHand + _salesTmpATP.Receipts - _salesTmpATP.Issues;
                _salesTmpATP.ProjectedOnhand = onHand;

                this.updateSalesTmpATP(_salesTmpATP, DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + i);
            }

            activityContext
                .addCustomProperty('AtpTimeFence', int2Str(salesATPSettingsMap.atpTimeFence));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAtpDateForPastDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ATP date for past demand.
    /// </summary>
    /// <returns>
    /// The past demand date of the ATP calculation.
    /// </returns>
    private date getAtpDateForPastDemand()
    {
        return DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpApplyDemandTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDemandStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the demand start date of the ATP calculation.
    /// </summary>
    /// <param name="_atpEndDate">
    /// The end date of the ATP fence.
    /// </param>
    /// <param name="_atpDateForPastDemand">
    /// The date for past demand of the ATP.
    /// </param>
    /// <returns>
    /// The demand start date of the ATP calculation.
    /// </returns>
    protected date getDemandStartDate(
        date _atpEndDate, 
        date _atpDateForPastDemand = this.getAtpDateForPastDemand())
    {
        date today = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        // If delayed demand orders are considered as actual orders not within the ATP time fence,
        // it makes no sense to process them because their quantities do not affect ATP calculation process.
        if (_atpDateForPastDemand > _atpEndDate)
        {
            return today;
        }
        return today - salesATPSettingsMap.atpBackwardDemandTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity of all demand orders and the total quantity of all supply orders for
    /// every record in the <c>_salesTmpATP</c> table buffer.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// A table buffer for which demand and supply quantities are calculated.
    /// </param>
    /// <param name="_inventTransId">
    /// A transaction that is excluded from calculation. This is typically a transaction from which ATP
    /// calculation process is initiated. It is not required to include the initiating transaction into
    /// demand or supply quantity.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventory dimension parameters that are used to calculate demand and supply quantities.
    /// </param>
    protected void calculateOrders(
        SalesTmpATP         _salesTmpATP,
        InventTransId       _inventTransId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calculateOrders())
        {
            date        demandStartDate;
            date        supplyStartDate;

            date atpEndDate           = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpTimeFence;
            date atpDateForPastDemand = this.getAtpDateForPastDemand();
            date atpDateForPastSupply = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpApplySupplyTimeFence;
            demandStartDate = this.getDemandStartDate(atpEndDate, atpDateForPastDemand);
            //
            // If delayed supply orders are considered as actual orders not within the ATP time fence,
            // it makes no sense to process them because their quantities do not affect ATP calculation process.
            //
            if (atpDateForPastSupply > atpEndDate)
            {
                supplyStartDate     = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
            }
            else
            {
                supplyStartDate     = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) - salesATPSettingsMap.atpBackwardSupplyTimeFence;
            }

            // Process receipts.
            this.processReceipts(
                _salesTmpATP,
                itemId,
                atpEndDate,
                supplyStartDate,
                atpDateForPastSupply,
                _inventTransId,
                _inventDimCriteria,
                _inventDimParm);

            // Process issues.
            this.processIssues(
                _salesTmpATP,
                itemId,
                atpEndDate,
                demandStartDate,
                atpDateForPastDemand,
                _inventTransId,
                _inventDimCriteria,
                _inventDimParm);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePlannedOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates a total quantity of all planned demand orders and a total quantity of all planned supply orders
    ///     for every record in _salesTmpATP table buffer.
    /// </summary>
    /// <param name="_salesTmpATP">
    ///     A table buffer for which planned demand and supply quantities will be calculated.
    /// </param>
    /// <param name="_inventTransId">
    ///     A transaction which is excluded from calculation. This is typically a transaction from which ATP
    ///     calculation process is initiated. It is of no need to include the initiating transaction into
    ///     planned demand or supply quantity.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///     Inventory dimensions criteria used to calculate planned demand and supply quantities.
    /// </param>
    /// <param name="_inventDimParm">
    ///     Inventory dimension parameters used to calculate planned demand and supply quantities.
    /// </param>
    /// <remarks>
    ///     This method should be typically called if planned orders have to be included into calculation
    ///     according to ATP parameters.
    /// </remarks>
    protected void calculatePlannedOrders(
        SalesTmpATP         _salesTmpATP,
        InventTransId       _inventTransId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calculatePlannedOrders())
        {
            date                    plannedDemandStartDate;
            date                    plannedSupplyStartDate;

            InventTransOriginId inventTransOriginId = _inventTransId ? InventTransOrigin::findByInventTransId(_inventTransId).RecId : 0;

            date atpEndDate           = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpTimeFence;
            date atpDateForPastDemand = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpApplyDemandTimeFence;
            date atpDateForPastSupply = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) + salesATPSettingsMap.atpApplySupplyTimeFence;
            //
            // If delayed planned demand orders are considered as actual orders not within the ATP time fence,
            // it makes no sense to process them because their quantities do not affect ATP calculation process.
            //
            if (atpDateForPastDemand > atpEndDate)
            {
                plannedDemandStartDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
            }
            else
            {
                plannedDemandStartDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) - salesATPSettingsMap.atpBackwardDemandTimeFence;
            }
            //
            // If delayed planned supply orders are considered as actual orders not within the ATP time fence,
            // it makes no sense to process them because their quantities do not affect ATP calculation process.
            //
            if (atpDateForPastSupply > atpEndDate)
            {
                plannedSupplyStartDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
            }
            else
            {
                plannedSupplyStartDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) - salesATPSettingsMap.atpBackwardSupplyTimeFence;
            }

            ReqParameters reqParameters = ReqParameters::find();
            ReqPlanIdSched reqPlanIdSched = reqParameters.CurrentReqPlanIdSchedDynamic ?
                reqParameters.CurrentReqPlanIdSchedDynamic
                : reqParameters.CurrentReqPlanIdSchedStatic;

            RefRecId reqPlanVersionRefRecId =
                                              ReqPlan::findReqPlanId(reqPlanIdSched).findActiveVersion().RecId;

            // Process planned demand.
            this.processPlannedDemand(
                _salesTmpATP,
                itemId,
                reqPlanVersionRefRecId,
                atpEndDate,
                plannedDemandStartDate,
                atpDateForPastDemand,
                inventTransOriginId,
                _inventDimCriteria,
                _inventDimParm);

            // Process planned supply.
            this.processPlannedSupply(
                _salesTmpATP,
                itemId,
                reqPlanVersionRefRecId,
                atpEndDate,
                plannedSupplyStartDate,
                atpDateForPastSupply,
                inventTransOriginId,
                _inventDimCriteria,
                _inventDimParm);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInventDimPrimary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>InventDim</c> table buffer for the given dimension number.
    /// </summary>
    /// <param name = "_inventDim">
    /// An <c>InventDim</c> table buffer.
    /// </param>
    /// <returns>
    /// The <c>InventDim</c> table.
    /// </returns>
    protected InventDim populateInventDimPrimary(InventDim _inventDim)
    {
        InventDim inventDimPrimary;

        // Only primary stockings are considered in the ATP calculation
        inventDimPrimary.copyPrimaryDim(InventDimGroupSetup::newItemId(itemId), _inventDim);

        // Inventory location should always be enabled even if it's not a primary stocking,
        // because sales order cannot be further processed without specifying warehouse dimension.
        inventDimPrimary.InventLocationId = _inventDim.InventLocationId;

        return inventDimPrimary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and inserts the temporary data into the <c>SalesTmpATP</c> table.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventory transaction ID of the sales order line, if called from a sales order line, is not to
    /// be included in this calculation; optional.
    /// </param>
    /// <returns>
    /// The <c>SalesTmpATP</c> table.
    /// </returns>
    /// <remarks>
    /// The <c>SalesTmpATP.ATP</c> field is not filled in this method.
    /// </remarks>
    protected SalesTmpATP calculation(InventTransId _inventTransId = '')
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calculation())
        {
            InventDim                       inventDimCriteria;
            InventDimParm                   inventDimParm;
            SalesTmpATP                     salesTmpATP = null;
            InventDim                       inventDim = InventDim::find(inventDimId);

            InventDim inventDimPrimary = this.populateInventDimPrimary(inventDim);

            inventDimCriteria.data(inventDimPrimary);
            inventDimParm.initFromInventDim(inventDimCriteria);

            activityContext
                .addCustomProperty('HasInventTransId', any2Str(_inventTransId != ''))
                .addCustomProperty('InventDimRecId', int642Str(inventDim.RecId));

            this.calculateOrders(
                salesTmpATP,
                _inventTransId,
                inventDimCriteria,
                inventDimParm);

            if (salesATPSettingsMap.atpInclPlannedOrders)
            {
                this.calculatePlannedOrders(
                    salesTmpATP,
                    _inventTransId,
                    inventDimCriteria,
                    inventDimParm);
            }

            this.calculateOnHand(
                salesTmpATP,
                inventDimCriteria,
                inventDimParm);

            return salesTmpATP;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the current on-hand level for the specified item on the specified dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// An Item ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> table buffer that specifies inventory dimension values for the filter criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> table buffer that specifies which inventory dimensions are used in the filter criteria.
    /// </param>
    /// <param name="_atpEndDate">
    /// The last date of the ATP calculation.
    /// </param>
    /// <returns>
    /// The current on-hand level for the specified item on the specified dimensions.
    /// </returns>
    protected InventQtyPhysicalOnhand currentOnHand(
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm,
        date            _atpEndDate)
    {
        return InventSum::findSumQty(_itemId, _inventDimCriteria, _inventDimParm).PhysicalInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        useSupplyForcastInATPCheckIsEnabled = ReqTransUseSupplyForcastInSalesATPCalculationToggle::instance().isEnabled();
        deliveryScheduleFormContextFeatureIsEnabled = SalesATPCalculationDeliveryScheduleFormContextFeature::isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    public InventDimId parmInventDimId(InventDimId _inventDimId = inventDimId)
    {
        inventDimId = _inventDimId;
        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIssueMarginCalendarId</Name>
				<Source><![CDATA[
    public CalendarId parmIssueMarginCalendarId(CalendarId _issueMarginCalendarId = issueMarginCalendarId)
    {
        issueMarginCalendarId = _issueMarginCalendarId;
        return issueMarginCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarginIssue</Name>
				<Source><![CDATA[
    public MarginIssue parmMarginIssue(MarginIssue _marginIssue = marginIssue)
    {
        marginIssue = _marginIssue;

        return marginIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesATPSettingsMap</Name>
				<Source><![CDATA[
    public SalesATPSettingsMap parmSalesATPSettingsMap(
        SalesATPSettingsMap _salesATPSettingsMap = salesATPSettingsMap)
    {
        salesATPSettingsMap = _salesATPSettingsMap;

        return salesATPSettingsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIssues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all the issue inventory transactions that can affect ATP calculation.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// A <c>SalesTmpATP</c> table buffer.
    /// </param>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_atpEndDate">
    /// The last date of ATP calculation.
    /// </param>
    /// <param name="_demandStartDate">
    /// The first date of demand consideration.
    /// </param>
    /// <param name="_atpDateForPastDemand">
    /// The expected date of overdue demand.
    /// </param>
    /// <param name="_inventTransId">
    /// An inventory transaction ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> table buffer that specifies inventory dimension values for the filter criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> table buffer that specifies which inventory dimensions are used in the filter criteria.
    /// </param>
    protected void processIssues(
        SalesTmpATP     _salesTmpATP,
        ItemId          _itemId,
        date            _atpEndDate,
        date            _demandStartDate,
        date            _atpDateForPastDemand,
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processIssues())
        {
            SalesATPIssueInventTrans    atpIssueInventTrans;
            InventTransOriginTransfer   inventTransOriginTransfer;
            InventTrans                 inventTransTransfer;
            InventDim                   inventDimTransfer;
            InventDim                   inventDim;
            InventTransId               inventTransIdToSkip = _inventTransId;

            if (this.deliveryScheduleFormContextFeatureIsEnabled && SalesDeliveryScheduleFormContext::current())
            {
                deliverySchecduleFormContext = SalesDeliveryScheduleFormContext::current();
            }

            if (this.deliveryScheduleFormContextFeatureIsEnabled && deliverySchecduleFormContext)
            {
                if (deliverySchecduleFormContext.orderLineHasDeliveryLines())
                {
                    // If a delivery line exists, it should not be skipped and should be handled by the context-specific logic.
                    inventTransIdToSkip = '';
                }
                else if (deliverySchecduleFormContext.getOrderLineTransId() &&
                        (!_inventTransId || !InventTransOrigin::findByInventTransId(_inventTransId)))
                {
                    inventTransIdToSkip = deliverySchecduleFormContext.getOrderLineTransId();
                }
            }

            // Calculate issues - don't include transfers if a corresponding counterpart receipt transaction exist with same grouping inventory dimensions.
            // Notice quarantine orders and wms orders are not linked together by the table inventTransOriginTransfer - instead the receipt and issue inventTrans have same inventTransOrigin.
            if (SalesATPCalculationProcessIssuesForceliteralsFlight::instance().isEnabled())
            {
                while select forceliterals DateExpected, sum (Qty) from atpIssueInventTrans
                group by DateExpected
                where atpIssueInventTrans.ItemId == _itemId
                    && atpIssueInventTrans.DateExpected <= _atpEndDate
                    && atpIssueInventTrans.DateExpected >= _demandStartDate
                    && atpIssueInventTrans.InventTransId != inventTransIdToSkip
                    && atpIssueInventTrans.InventTransId != this.parmReplacedSalesLineInventTransId()
                outer join TableId from inventTransOriginTransfer
                    where inventTransOriginTransfer.IssueInventTransOrigin == atpIssueInventTrans.InventTransOrigin
                #inventDimExistsJoin(atpIssueInventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                notexists join inventTransTransfer
                    where inventTransTransfer.ItemId == itemId
                        && inventTransTransfer.StatusIssue == StatusIssue::None
                        && inventTransTransfer.StatusReceipt >= StatusReceipt::Arrived
                        && inventTransTransfer.StatusReceipt <= StatusReceipt::Ordered
                        && (inventTransTransfer.InventTransOrigin == atpIssueInventTrans.InventTransOrigin
                            || inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.ReceiptInventTransOrigin)
                #inventDimExistsJoin(inventTransTransfer.inventDimId,inventDimTransfer,_inventDimCriteria,_inventDimParm)
                {
                    this.updateSalesTmpATPWithIssue(
                    _salesTmpATP,
                    atpIssueInventTrans.Qty,
                    atpIssueInventTrans.DateExpected,
                    _atpDateForPastDemand);
                }
            }
            else
            {
                while select forceplaceholders DateExpected, sum (Qty) from atpIssueInventTrans
                group by DateExpected
                where atpIssueInventTrans.ItemId == _itemId
                    && atpIssueInventTrans.DateExpected <= _atpEndDate
                    && atpIssueInventTrans.DateExpected >= _demandStartDate
                    && atpIssueInventTrans.InventTransId != inventTransIdToSkip
                    && atpIssueInventTrans.InventTransId != this.parmReplacedSalesLineInventTransId()
                outer join TableId from inventTransOriginTransfer
                    where inventTransOriginTransfer.IssueInventTransOrigin == atpIssueInventTrans.InventTransOrigin
                #inventDimExistsJoin(atpIssueInventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                notexists join inventTransTransfer
                    where inventTransTransfer.ItemId == itemId
                        && inventTransTransfer.StatusIssue == StatusIssue::None
                        && inventTransTransfer.StatusReceipt >= StatusReceipt::Arrived
                        && inventTransTransfer.StatusReceipt <= StatusReceipt::Ordered
                        && (inventTransTransfer.InventTransOrigin == atpIssueInventTrans.InventTransOrigin
                            || inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.ReceiptInventTransOrigin)
                #inventDimExistsJoin(inventTransTransfer.inventDimId,inventDimTransfer,_inventDimCriteria,_inventDimParm)
                {
                    this.updateSalesTmpATPWithIssue(
                    _salesTmpATP,
                    atpIssueInventTrans.Qty,
                    atpIssueInventTrans.DateExpected,
                    _atpDateForPastDemand);
                }
            }

            if (ATPCalcBypassBlockingStatusFlight::instance().isEnabled())
            {
                InventBlocking inventBlocking;
                InventDim      inventDimBypassBlocking;

                while select forceplaceholders DateExpected, sum (Qty) from atpIssueInventTrans
                    group by DateExpected
                    where atpIssueInventTrans.ItemId == _itemId
                        && atpIssueInventTrans.DateExpected <= _atpEndDate
                        && atpIssueInventTrans.DateExpected >= _demandStartDate
                        && atpIssueInventTrans.InventTransId != _inventTransId
                        && atpIssueInventTrans.InventTransId != this.parmReplacedSalesLineInventTransId()
                        && atpIssueInventTrans.StatusIssue != StatusIssue::ReservPhysical
                    #inventDimExistsJoin(atpIssueInventTrans.inventDimId, inventDimBypassBlocking, _inventDimCriteria, _inventDimParm)
                exists join inventBlocking
                        where inventBlocking.InventTransIdIssue == atpIssueInventTrans.InventTransId
                            && inventBlocking.BlockingType == InventBlockingType::InventoryStatus
                {
                    this.updateSalesTmpATPWithIssue(
                    _salesTmpATP,
                    -1 * atpIssueInventTrans.Qty,
                    atpIssueInventTrans.DateExpected,
                    _atpDateForPastDemand);
                }
            }

            if (SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesOfSameItemFlight::instance().isEnabled() &&
                SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext::current())
            {
                SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext notUpdatedSalesLinesContext = SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext::current();

                MapIterator shippingDatesIterator = new MapIterator(notUpdatedSalesLinesContext.getShippingQtyByDateMap());

                while (shippingDatesIterator.more())
                {
                    DateExpected expectedShippingDateLocal = shippingDatesIterator.key();

                    if (_demandStartDate <= expectedShippingDateLocal && expectedShippingDateLocal <= _atpEndDate)
                    {
                        this.updateSalesTmpATPWithIssue(
                            _salesTmpATP,
                            shippingDatesIterator.value(),
                            expectedShippingDateLocal,
                            _atpDateForPastDemand);
                    }

                    shippingDatesIterator.next();
                }
            }

            if (this.deliveryScheduleFormContextFeatureIsEnabled && deliverySchecduleFormContext)
            {
                SalesDeliveryScheduleFormContextIssueParameters parameters = SalesDeliveryScheduleFormContextIssueParameters::construct();

                parameters.salesATPCalculation = this;
                parameters.salesTmpATP = _salesTmpATP;
                parameters.itemId = _itemId;
                parameters.atpEndDate = _atpEndDate;
                parameters.demandStartDate = _demandStartDate;
                parameters.atpDateForPastDemand = _atpDateForPastDemand;
                parameters.inventDimCriteria = _inventDimCriteria;
                parameters.inventDimParm = _inventDimParm;

                deliverySchecduleFormContext.applyDeliveryScheduleFormContextForIssues(parameters);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyDeliveryScheduleFormContextForIssues_SalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust already in delivery lines Qty with delivery schedule form context specific for SalesLine.
    /// </summary>
    /// <param name="_parameters">
    /// Parameters for the adjustment process.
    /// </param>
    /// <remarks>
    /// The method is called from processIssues() and utilise all it parameters.
    /// </remarks>
    internal void applyDeliveryScheduleFormContextForIssues_SalesLine(SalesDeliveryScheduleFormContextIssueParameters _parameters)
    {
        SalesDeliveryScheduleFormContext_SalesLine deliveryScheduleFormContextLocal = deliverySchecduleFormContext;

        if (!this.deliveryScheduleFormContextFeatureIsEnabled || !deliveryScheduleFormContextLocal)
        {
            return;
        }

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().applyDeliverySchedule())
        {
            // The query should operate with a small number of InventTrans records, limited by SalesLine and ItemId
            if (deliveryScheduleFormContextLocal.orderLineHasDeliveryLines())
            {
                SalesDeliverySchedule       salesDeliverySchedule;
                SalesATPIssueInventTrans    atpIssueInventTrans;
                InventTransOriginTransfer   inventTransOriginTransfer;
                InventTrans                 inventTransTransfer;
                InventDim                   inventDim;
                InventDim                   inventDimTransfer;

                InventTransId orderLineTransIdLocal = deliveryScheduleFormContextLocal.getOrderLineTransId();
            
                // Collect and deduct already available delivery lines Qty
                while select forceplaceholders TableID from salesDeliverySchedule
                        where salesDeliverySchedule.OrderLine == orderLineTransIdLocal
                    join DateExpected, sum (Qty) from atpIssueInventTrans
                    group by DateExpected
                        where atpIssueInventTrans.ItemId == _parameters.itemId &&
                              atpIssueInventTrans.DateExpected <= _parameters.atpEndDate &&
                              atpIssueInventTrans.DateExpected >= _parameters.demandStartDate &&
                              atpIssueInventTrans.InventTransId == salesDeliverySchedule.DeliveryLine &&
                              atpIssueInventTrans.InventTransId != this.parmReplacedSalesLineInventTransId()
                    outer join TableId from inventTransOriginTransfer
                        where inventTransOriginTransfer.IssueInventTransOrigin == atpIssueInventTrans.InventTransOrigin
                    #inventDimExistsJoin(atpIssueInventTrans.inventDimId, inventDim, _parameters.inventDimCriteria, _parameters.inventDimParm)
                notexists join inventTransTransfer
                        where inventTransTransfer.ItemId == itemId &&
                              inventTransTransfer.StatusIssue == StatusIssue::None &&
                              inventTransTransfer.StatusReceipt >= StatusReceipt::Arrived &&
                              inventTransTransfer.StatusReceipt <= StatusReceipt::Ordered &&
                             (inventTransTransfer.InventTransOrigin == atpIssueInventTrans.InventTransOrigin ||
                              inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.ReceiptInventTransOrigin)
                    #inventDimExistsJoin(inventTransTransfer.inventDimId, inventDimTransfer, _parameters.inventDimCriteria, _parameters.inventDimParm)
                {
                    this.updateSalesTmpATPWithIssue(
                        _parameters.salesTmpATP,
                        atpIssueInventTrans.Qty * -1,
                        atpIssueInventTrans.DateExpected,
                        _parameters.atpDateForPastDemand);
                }
            }

            MapIterator shippingDatesIterator = new MapIterator(deliveryScheduleFormContextLocal.getShippingQtyByDateMap());

            while (shippingDatesIterator.more())
            {
                DateExpected expectedShippingDateLocal = shippingDatesIterator.key();

                if (_parameters.demandStartDate <= expectedShippingDateLocal && expectedShippingDateLocal <= _parameters.atpEndDate)
                {
                    this.updateSalesTmpATPWithIssue(
                        _parameters.salesTmpATP,
                        shippingDatesIterator.value() * -1, // Need to have negative sign qty, same as InventTrans has
                        expectedShippingDateLocal,
                        _parameters.atpDateForPastDemand);
                }

                shippingDatesIterator.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPlannedDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all the planned demand transactions that can affect ATP calculation.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// A <c>SalesTmpATP</c> table buffer.
    /// </param>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_reqPlanVersionRefRecId">
    /// A master plan ID.
    /// </param>
    /// <param name="_atpEndDate">
    /// The last date of ATP calculation.
    /// </param>
    /// <param name="_plannedDemandStartDate">
    /// The first date of planned demand consideration.
    /// </param>
    /// <param name="_atpDateForPastDemand">
    /// The expected date of overdue demand.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// An inventory transaction originator ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> table buffer that specifies inventory dimension values for the filter criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> table buffer that specifies which inventory dimensions are used in the filter criteria.
    /// </param>
    protected void processPlannedDemand(
        SalesTmpATP             _salesTmpATP,
        ItemId                  _itemId,
        ReqPlanVersionRefRecId  _reqPlanVersionRefRecId,
        date                    _atpEndDate,
        date                    _plannedDemandStartDate,
        date                    _atpDateForPastDemand,
        InventTransOriginId     _inventTransOriginId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm)
    {
        ReqTrans    reqTrans;
        InventDim   inventDim;

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processPlannedDemand())
        {
            #LOCALMACRO.MatchStatement
                group by ReqDate
                    where reqTrans.ItemId                       == _itemId
                       && reqTrans.PlanVersion                  == _reqPlanVersionRefRecId
                       && reqTrans.ReqDate                      >= _plannedDemandStartDate
                       && reqTrans.ReqDate                      <= _atpEndDate
                       && reqTrans.IsForecastPurch == NoYes::No
                       && (reqTrans.InventTransOrigin           != _inventTransOriginId || !_inventTransOriginId)
                       && reqTrans.Qty                          < 0
                       && (reqTrans.RefType == ReqRefType::BOMPlannedOrder
                        || reqTrans.RefType == ReqRefType::PmfFormulaLine
                        || reqTrans.RefType == ReqRefType::PmfPlannedProdBatch
                        || reqTrans.RefType == ReqRefType::ItemPlannedOrder
                        || reqTrans.RefType == ReqRefType::TransferPlannedOrder
                        || reqTrans.RefType == ReqRefType::TransferDemand
                        || reqTrans.RefType == ReqRefType::BOMLine
                        || reqTrans.RefType == ReqRefType::PlannedKanban
                        || reqTrans.RefType == ReqRefType::PlannedKanbanLine)
                #inventDimExistsJoin(reqTrans.CovInventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                {
                    this.updateSalesTmpATPWithPlannedDemand(
                        _salesTmpATP,
                        reqTrans,
                        _atpDateForPastDemand);
                }
            #ENDMACRO

            while select forceSelectOrder forceNestedLoop ReqDate, sum (Qty) from reqTrans
                #MatchStatement
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPlannedSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all the planned supply transactions that can affect ATP calculation.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// A <c>SalesTmpATP</c> table buffer.
    /// </param>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_reqPlanVersionRefRecId">
    /// A master plan ID.
    /// </param>
    /// <param name="_atpEndDate">
    /// The last date of ATP calculation.
    /// </param>
    /// <param name="_plannedSupplyStartDate">
    /// The first date of planned supply consideration.
    /// </param>
    /// <param name="_atpDateForPastSupply">
    /// The expected date of overdue supply.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// An inventory transaction originator ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> table buffer that specifies inventory dimension values for the filter criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> table buffer that specifies which inventory dimensions are used in the filter criteria.
    /// </param>
    protected void processPlannedSupply(
        SalesTmpATP             _salesTmpATP,
        ItemId                  _itemId,
        ReqPlanVersionRefRecId  _reqPlanVersionRefRecId,
        date                    _atpEndDate,
        date                    _plannedSupplyStartDate,
        date                    _atpDateForPastSupply,
        InventTransOriginId     _inventTransOriginId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm)
    {
        ReqTrans    reqTrans;
        InventDim   inventDim;

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processPlannedSupply())
        {
            #LOCALMACRO.MatchStatement
                 group by ReqDate
                    where reqTrans.ItemId                   == _itemId
                       && reqTrans.PlanVersion              == _reqPlanVersionRefRecId
                       && reqTrans.ReqDate                  >= _plannedSupplyStartDate
                       && reqTrans.ReqDate                  <= _atpEndDate
                       && (useSupplyForcastInATPCheckIsEnabled  || reqTrans.IsForecastPurch == NoYes::No)
                       && (reqTrans.InventTransOrigin       != _inventTransOriginId || !_inventTransOriginId)
                       && reqTrans.Qty                      > 0
                       && (reqTrans.RefType == ReqRefType::BOMPlannedOrder
                        || reqTrans.RefType == ReqRefType::PmfFormulaLine
                        || reqTrans.RefType == ReqRefType::PmfPlannedProdBatch
                        || reqTrans.RefType == ReqRefType::ItemPlannedOrder
                        || reqTrans.RefType == ReqRefType::TransferPlannedOrder
                        || reqTrans.RefType == ReqRefType::TransferDemand
                        || reqTrans.RefType == ReqRefType::BOMLine
                        || reqTrans.RefType == ReqRefType::PlannedKanban
                        || reqTrans.RefType == ReqRefType::PlannedKanbanLine)
                #inventDimExistsJoin(reqTrans.CovInventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                {
                    this.updateSalesTmpATPWithPlannedSupply(
                    _salesTmpATP,
                    reqTrans,
                    _atpDateForPastSupply);
                }
            #ENDMACRO

            while select forceSelectOrder forceNestedLoop ReqDate, sum (Qty) from reqTrans
                #MatchStatement
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all the receipt inventory transactions that can affect ATP calculation.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// A <c>SalesTmpATP</c> table buffer.
    /// </param>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_atpEndDate">
    /// The last date of ATP calculation.
    /// </param>
    /// <param name="_supplyStartDate">
    /// The first date of demand consideration.
    /// </param>
    /// <param name="_atpDateForPastSupply">
    /// The expected date of overdue supply.
    /// </param>
    /// <param name="_inventTransId">
    /// An inventory transaction ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> table buffer that specifies inventory dimension values for the filter criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> table buffer that specifies which inventory dimensions are used in the filter criteria.
    /// </param>
    protected void processReceipts(
        SalesTmpATP     _salesTmpATP,
        ItemId          _itemId,
        date            _atpEndDate,
        date            _supplyStartDate,
        date            _atpDateForPastSupply,
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processReceipts())
        {
            SalesATPReceiptInventTrans  atpReceiptInventTrans;
            InventTransOriginTransfer   inventTransOriginTransfer;
            InventTrans                 inventTransTransfer;
            InventDim                   inventDimTransfer;
            InventDim                   inventDim;

            // Calculate receipts - don't include transfers if a corresponding counterpart issue transaction exist with same grouping inventory dimensions.
            // Notice quarantine orders and wms orders are not linked together by the table inventTransOriginTransfer - instead the receipt and issue inventTrans have same inventTransOrigin.

            while select forceplaceholders DateExpected, sum (Qty) from atpReceiptInventTrans
                group by DateExpected
                where atpReceiptInventTrans.ItemId == _itemId
                    && atpReceiptInventTrans.DateExpected <= _atpEndDate
                    && atpReceiptInventTrans.DateExpected >= _supplyStartDate
                    && atpReceiptInventTrans.InventTransId != _inventTransId
                    && atpReceiptInventTrans.InventTransId != this.parmDerivedPurchLineInventTransId()
                outer join TableId from inventTransOriginTransfer
                    where inventTransOriginTransfer.ReceiptInventTransOrigin == atpReceiptInventTrans.InventTransOrigin
                #inventDimExistsJoin(atpReceiptInventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParm)
            notexists join inventTransTransfer
                    where inventTransTransfer.ItemId == _itemId
                        && inventTransTransfer.StatusReceipt == StatusReceipt::None
                        && inventTransTransfer.StatusIssue >= StatusIssue::ReservPhysical
                        && inventTransTransfer.StatusIssue <= StatusIssue::OnOrder
                        && (inventTransTransfer.InventTransOrigin == atpReceiptInventTrans.InventTransOrigin
                            || inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.IssueInventTransOrigin)
                #inventDimExistsJoin(inventTransTransfer.inventDimId,inventDimTransfer,_inventDimCriteria,_inventDimParm)
            {
                this.updateSalesTmpATPWithReceipt(
                    _salesTmpATP,
                    atpReceiptInventTrans.Qty,
                    atpReceiptInventTrans.DateExpected,
                    _atpDateForPastSupply);
            }

            if(ATPCalcBypassBlockingStatusFlight::instance().isEnabled())
            {
                WHSInventStatus whsInventStatus;
                InventDim       inventDimBypassBlocking;

                while select forceplaceholders DateExpected, sum (Qty) from atpReceiptInventTrans
                    group by DateExpected
                    where atpReceiptInventTrans.ItemId == _itemId
                        && atpReceiptInventTrans.DateExpected <= _atpEndDate
                        && atpReceiptInventTrans.DateExpected >= _supplyStartDate
                        && atpReceiptInventTrans.InventTransId != _inventTransId
                        && atpReceiptInventTrans.InventTransId != this.parmDerivedPurchLineInventTransId()
                    #inventDimExistsJoin(atpReceiptInventTrans.inventDimId,inventDimBypassBlocking,_inventDimCriteria,_inventDimParm)
                exists join whsInventStatus
                        where inventDimBypassBlocking.InventStatusId == whsInventStatus.InventStatusId
                            && whsInventStatus.InventStatusBlocking == NoYes::Yes
                {
                    this.updateSalesTmpATPWithReceipt(
                    _salesTmpATP,
                    -1 * atpReceiptInventTrans.Qty,
                    atpReceiptInventTrans.DateExpected,
                    _atpDateForPastSupply);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTmpATP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a <c>salesTmpATP</c> table buffer.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// The table buffer to be updated.
    /// </param>
    /// <param name="_salesTmpATPDate">
    /// The ATP date to be put in the <c>salesTmpATP</c> buffer.
    /// </param>
    protected void updateSalesTmpATP(SalesTmpATP _salesTmpATP, date _salesTmpATPDate)
    {
        _salesTmpATP.atpDate = _salesTmpATPDate;
        _salesTmpATP.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTmpATPWithIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>SalesTmpATP</c> table record using data from the issue transaction.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// The <c>SalesTmpATP</c> table record to be updated.
    /// </param>
    /// <param name="_qty">
    /// The quantity of the issue transaction.
    /// </param>
    /// <param name="_dateExpected">
    /// The expected date of the issue transaction.
    /// </param>
    /// <param name="_atpDateForPastDemand">
    /// The expected date of overdue demand.
    /// </param>
    protected void updateSalesTmpATPWithIssue(
        SalesTmpATP     _salesTmpATP,
        InventQty       _qty,
        DateExpected    _dateExpected,
        date            _atpDateForPastDemand)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().updateSalesTmpATPWithIssue())
        {
            date atpQtyDate;

            if (_dateExpected < DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))
            {
                //
                // If it is a delayed order, then it is considerd as an actual order on a date
                // defined by atpDateForPastDemand or atpDateForPastSupply. Otherwise, transaction date is used.
                //
                atpQtyDate = _atpDateForPastDemand;
            }
            else
            {
                atpQtyDate = _dateExpected;
            }

            select firstonly forupdate _salesTmpATP
                where _salesTmpATP.atpDate == atpQtyDate;

            _salesTmpATP.Issues -= _qty;

            this.updateSalesTmpATP(_salesTmpATP, atpQtyDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTmpATPWithPlannedDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>SalesTmpATP</c> table record using data from the planned demand transaction.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// The <c>SalesTmpATP</c> table record to be updated.
    /// </param>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c> table record that represents planned demand transaction.
    /// </param>
    /// <param name="_atpDateForPastDemand">
    /// The expected date of overdue demand.
    /// </param>
    protected void updateSalesTmpATPWithPlannedDemand(
        SalesTmpATP _salesTmpATP,
        ReqTrans    _reqTrans,
        date        _atpDateForPastDemand)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().updateSalesTmpATPWithPlannedDemand())
        {
            //
            // If it is a delayed planned order, then it is considerd as an actual planned order on a date
            // defined by atpDateForPastDemand. Otherwise, transaction date is used.
            //
            date atpPlannedQtyDate = _reqTrans.ReqDate < DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) ?
                _atpDateForPastDemand
                : _reqTrans.ReqDate;

            select firstonly forupdate _salesTmpATP
                where _salesTmpATP.atpDate == atpPlannedQtyDate;

            _salesTmpATP.Issues -= _reqTrans.Qty;

            this.updateSalesTmpATP(_salesTmpATP, atpPlannedQtyDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTmpATPWithPlannedSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>SalesTmpATP</c> table record using data from the planned supply transaction.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// The <c>SalesTmpATP</c> table record to be updated.
    /// </param>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c> table record that represents planned supply transaction.
    /// </param>
    /// <param name="_atpDateForPastSupply">
    /// The expected date of overdue supply.
    /// </param>
    protected void updateSalesTmpATPWithPlannedSupply(
        SalesTmpATP _salesTmpATP,
        ReqTrans    _reqTrans,
        date        _atpDateForPastSupply)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().updateSalesTmpATPWithPlannedSupply())
        {
            //
            // If it is a delayed planned order, then it is considerd as an actual planned order on a date
            // defined by atpDateForPastSupply. Otherwise, transaction date is used.
            //
            date atpPlannedQtyDate = _reqTrans.ReqDate < DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) ?
                _atpDateForPastSupply
                : _reqTrans.ReqDate;

            select firstonly forupdate _salesTmpATP
                where _salesTmpATP.atpDate == atpPlannedQtyDate;

            _salesTmpATP.Receipts += _reqTrans.Qty;

            this.updateSalesTmpATP(_salesTmpATP, atpPlannedQtyDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTmpATPWithReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>SalesTmpATP</c> table record using data from the receipt transaction.
    /// </summary>
    /// <param name="_salesTmpATP">
    /// The <c>SalesTmpATP</c> table record to be updated.
    /// </param>
    /// <param name="_qty">
    /// The quantity of the receipt transaction.
    /// </param>
    /// <param name="_dateExpected">
    /// The expected date of the receipt transaction.
    /// </param>
    /// <param name="_atpDateForPastSupply">
    /// The expected date of overdue supply.
    /// </param>
    protected void updateSalesTmpATPWithReceipt(
        SalesTmpATP         _salesTmpATP,
        InventQty           _qty,
        DateExpected        _dateExpected,
        date                _atpDateForPastSupply)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().updateSalesTmpATPWithReceipt())
        {
            date atpQtyDate;

            if (_dateExpected < DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))
            {
                //
                // If it is a delayed order, then it is considerd as an actual order on a date
                // defined by atpDateForPastDemand or atpDateForPastSupply. Otherwise, transaction date is used.
                //
                atpQtyDate = _atpDateForPastSupply;
            }
            else
            {
                atpQtyDate = _dateExpected;
            }

            select firstonly forupdate _salesTmpATP
                where _salesTmpATP.atpDate == atpQtyDate;

            _salesTmpATP.Receipts += _qty;

            this.updateSalesTmpATP(_salesTmpATP, atpQtyDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static protected SalesATPCalculation construct()
    {
        return new SalesATPCalculation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findItemOrderSettings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default item order settings.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID for which the default item order settings are to be found.
    /// </param>
    /// <param name="_inventDimId">
    /// This inventory dimension defines whether to select a site specific ordersetting, or a default order
    /// setting.
    /// </param>
    /// <returns>
    /// An instance of <c>SalesATPSettingsMap</c> map.
    /// </returns>
    public static SalesATPSettingsMap findItemOrderSettings(
        ItemId          _itemId,
        InventDimId     _inventDimId)
    {
        SalesATPSettingsMap             salesATPSettingsMap;

        InventItemInventSetup inventItemInventSetupLocal = InventItemInventSetup::find(_itemId, _inventDimId);

        if (!inventItemInventSetupLocal.Override)
        {
            inventItemInventSetupLocal = InventItemInventSetup::find(_itemId, InventDim::inventDimIdBlank());
        }

        if (inventItemInventSetupLocal.Override)
        {
            salesATPSettingsMap.initFromInventSetup(inventItemInventSetupLocal);
        }
        else
        {
            salesATPSettingsMap.initFromSalesParameters();
        }

        if ((salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATP || salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATPPlusIssueMargin)
            && InventTable::find(_itemId).inventItemType().isServiceItem())
        {
            salesATPSettingsMap.initDefault();
        }

        return salesATPSettingsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesOrderSettings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default item sales order settings.
    /// </summary>
    /// <param name="_itemId">
    /// The item id for which the default item order settings are to be found.
    /// </param>
    /// <param name="_inventDimId">
    /// This inventory dimension defines whether to select a site specific ordersetting, or a default order setting.
    /// </param>
    /// <returns>
    /// An instance of SalesATPSettingsMap map.
    /// </returns>
    public static SalesATPSettingsMap findSalesOrderSettings(
        ItemId          _itemId,
        InventDimId     _inventDimId)
    {
        SalesATPSettingsMap             salesATPSettingsMap;

        InventItemSalesSetup inventItemSalesSetupLocal = InventItemSalesSetup::find(_itemId, _inventDimId);

        if (!inventItemSalesSetupLocal.Override)
        {
            inventItemSalesSetupLocal = InventItemSalesSetup::find(_itemId, InventDim::inventDimIdBlank());
        }

        if (inventItemSalesSetupLocal.Override)
        {
            salesATPSettingsMap.initFromSalesSetup(inventItemSalesSetupLocal);
        }
        else
        {
            salesATPSettingsMap.initFromSalesParameters();
        }

        if ((salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATP || salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATPPlusIssueMargin)
            && InventTable::find(_itemId).inventItemType().isServiceItem())
        {
            salesATPSettingsMap.initDefault();
        }

        return salesATPSettingsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransferOrderSettings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the transfer order settings for the ATP calculation.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The transfer order line table buffer.
    /// </param>
    /// <returns>
    /// An <c>SalesATPSettingsMap</c> map.
    /// </returns>
    public static SalesATPSettingsMap findTransferOrderSettings(
        InventTransferLine _inventTransferLine)
    {
        SalesATPSettingsMap             salesATPSettingsMap;

        // Parameters from transfer line must take precedence over item specific parameters.
        salesATPSettingsMap.initFromTransferLine(_inventTransferLine);

        if ((salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATP || salesATPSettingsMap.DeliveryDateControlType == SalesDeliveryDateControlType::ATPPlusIssueMargin)
            && InventTable::find(_inventTransferLine.ItemId).inventItemType().isServiceItem())
        {
            salesATPSettingsMap.initDefault();
        }

        return salesATPSettingsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesATPCalculation</c> class to calculate the ATP with the
    /// item-specific settings.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item for which to calculate the ATP.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimensions of the item for which to calculate the ATP.
    /// </param>
    /// <returns>
    /// The instance of the <c>SalesATPCalculation</c> class.
    /// </returns>
    public static SalesATPCalculation newItemCalculation(ItemId _itemId, InventDimId _inventDimId)
    {
        SalesATPCalculation             salesATPCalculation = SalesATPCalculation::newSalesATPCalculation(_itemId);

        SalesATPSettingsMap salesATPSettingsMap = SalesATPCalculation::findItemOrderSettings(_itemId, _inventDimId);

        salesATPCalculation.parmItemId(_itemId);
        salesATPCalculation.parmInventDimId(_inventDimId);
        salesATPCalculation.parmSalesATPSettingsMap(salesATPSettingsMap);

        return salesATPCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesATPCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>SalesATPCalculation</c> class instance.
    /// </summary>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_custAccount">
    /// A customer ID.
    /// </param>
    /// <param name="_custAccountCompany">
    /// The customer's <c>DataAreaID</c>, used when ATP is calculated in a different company.
    /// </param>
    /// <returns>
    /// A new <c>SalesATPCalculation</c> class instance.
    /// </returns>
    protected static SalesATPCalculation newSalesATPCalculation(ItemId _itemId, CustAccount _custAccount = '', DataAreaId _custAccountCompany = '')
    {
        InventTable                     inventTable = InventTable::find(_itemId);

        if (    #PdsShelfEnabled
            &&  inventTable.isShelfLifeItem()
            &&  inventTable.isItemBatchActivated())
        {
            SalesATPCalculationShelfLife salesATPCalculationShelfLife = SalesATPCalculationShelfLife::construct();
            salesATPCalculationShelfLife.parmCustAccount(_custAccount);
            salesATPCalculationShelfLife.parmCustAccountCompany(_custAccountCompany);
            return salesATPCalculationShelfLife;
        }

        return SalesATPCalculation::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesATPCalculation</c> class to calculate the ATP with the sales
    /// settings.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item for which to calculate the ATP.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimensions of the item for which to calculate the ATP.
    /// </param>
    /// <param name="_custAccount">
    /// A customer ID.
    /// </param>
    /// <param name="_custAccountCompany">
    /// The customer's <c>DataAreaID</c>, used when ATP is calculated in a different company.
    /// </param>
    /// <returns>
    /// The instance of the <c>SalesATPCalculation</c> class.
    /// </returns>
    /// <remarks>
    /// The <c>_custAccount</c> parameter has been added.
    /// </remarks>
    public static SalesATPCalculation newSalesCalculation(ItemId _itemId, InventDimId _inventDimId, CustAccount _custAccount, DataAreaId _custAccountCompany = '')
    {
        SalesATPCalculation             salesATPCalculation = SalesATPCalculation::newSalesATPCalculation(_itemId, _custAccount, _custAccountCompany);

        SalesATPSettingsMap salesATPSettingsMap = SalesATPCalculation::findSalesOrderSettings(_itemId, _inventDimId);

        salesATPCalculation.parmItemId(_itemId);
        salesATPCalculation.parmInventDimId(_inventDimId);
        salesATPCalculation.parmSalesATPSettingsMap(salesATPSettingsMap);

        return salesATPCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransferCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesATPCalculation</c> class to calculate the ATP with the transfer
    /// settings.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The inventory transfer line for which to calculate the ATP.
    /// </param>
    /// <returns>
    /// The instance of the <c>SalesATPCalculation</c> class.
    /// </returns>
    public static SalesATPCalculation newTransferCalculation(InventTransferLine _inventTransferLine)
    {
        SalesATPCalculation             salesATPCalculation = SalesATPCalculation::newSalesATPCalculation(_inventTransferLine.ItemId);

        SalesATPSettingsMap salesATPSettingsMap = SalesATPCalculation::findTransferOrderSettings(_inventTransferLine);

        salesATPCalculation.parmItemId(_inventTransferLine.ItemId);
        salesATPCalculation.parmInventDimId(_inventTransferLine.InventDimId);
        salesATPCalculation.parmSalesATPSettingsMap(salesATPSettingsMap);

        return salesATPCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDerivedPurchLineInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the Lot ID of the purch line that was derived from the current sales line.
    /// This purchase line will not be considered as a supply by the ATP algorithm
    /// because it will have to be replaced when the sourcing of the sales line changes.
    /// </summary>
    /// <param name = "_derivedPurchLineInventTransId">The Lot ID of the purch line that was derived from the current sales line.</param>
    /// <returns>The Lot ID of the purch line that was derived from the current sales line.</returns>
    public InventTransId parmDerivedPurchLineInventTransId(InventTransId _derivedPurchLineInventTransId = derivedPurchLineInventTransId)
    {
        derivedPurchLineInventTransId = _derivedPurchLineInventTransId;
        return _derivedPurchLineInventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplacedSalesLineInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the Lot ID of the sales line that will be replaced by the current sales line.
    /// This sales line will not be considered as a demand by the ATP algorithm.
    /// </summary>
    /// <param name = "_replacedSalesLineInventTransId">The Lot ID of the sales line that will be replaced by the current sales line.</param>
    /// <returns>The Lot ID of the sales line that will be replaced by the current sales line.</returns>
    public InventTransId parmReplacedSalesLineInventTransId(InventTransId _replacedSalesLineInventTransId = replacedSalesLineInventTransId)
    {
        replacedSalesLineInventTransId = _replacedSalesLineInventTransId;
        return _replacedSalesLineInventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal SalesInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = SalesInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>