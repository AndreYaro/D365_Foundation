<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjLedgerUpdate</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjLedgerUpdate
{
    ProjLedger projLedger;

    LedgerVoucherObject ledgerPostingReference;
    LedgerVoucherTransObject ledgerPostingTransaction;

    LedgerPostingType postingType;
    DimensionDefault dimension;
    TransDate transDate;
    AmountMST amountMST;
    Voucher voucher;
    boolean postToGeneralLedger;
    AccountNum accountNum;
    LedgerDimensionAccount ledgerDimension;
    Map taxExemptDistributions;
    List fundingSourceList;

    // This flight provides regression protection for the project ledger updates.
    // Created 10.0.19
    // Default state: Off
    internal static const str ProjLedgerUpdateLedgerStatusCostFlight = 'ProjLedgerUpdateLedgerStatusCostFlight';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkInsertTransPosting</Name>
				<Source><![CDATA[
    boolean checkInsertTransPosting(ProjTransPosting projTransPosting)
    {
        boolean ret;

        ret = projTransPosting.validateWrite();

        if (ret)
        {
            // This is to handle the case where Production order with BOM item is ended under "consumed" posting method. 
            // We do not need to insert posting since sub items should already have been posted by this point.
            if (this.productionOriginWithoutAdjustRefId(projTransPosting))
            {
                ret = false;
            }
            else if (projTransPosting.AmountMst
                || this.parmPostingType() == LedgerPostingType::ProjNeverLedger
                || this.parmPostingType() == LedgerPostingType::ProjNoLedger)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>productionOriginWithoutAdjustRefId</Name>
				<Source><![CDATA[
    private boolean productionOriginWithoutAdjustRefId(ProjTransPosting _projTransPosting)
    {
        return _projTransPosting.ProjTransType == ProjTransType::Item && _projTransPosting.PostingType == LedgerPostingType::ProjCost 
            && _projTransPosting.LedgerOrigin == ProjOrigin::ProductionConsumed && !_projTransPosting.ProjAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfOppositeExistsForItemReq</Name>
				<Source><![CDATA[
    [SysObsolete('Usage of this method has been removed', false, 14\06\2023)]
    protected boolean checkIfOppositeExistsForItemReq(ProjTransPosting _projTransPosting)
    {
        boolean ret = false;
        if (_projTransPosting.ProjTransType == ProjTransType::Item
            && _projTransPosting.LedgerOrigin == ProjOrigin::ItemRequirement
            && _projTransPosting.TransactionOrigin == ProjOrigin::ItemRequirement
            && _projTransPosting.PostingType == LedgerPostingType::ProjCost
            && _projTransPosting.CostSales == ProjCostSales::Cost
            && FeatureStateProvider::isFeatureEnabled(ProjCancelItemReqPackingSlipFeature::instance())
            && ProjItemTrans::isStocked(_projTransPosting.InventTransId))
        {
            ProjTransIdBase transID = _projTransPosting.TransId;
            if (!transID)
            {
                transID = ProjItemTrans::findInvent(_projTransPosting.InventTransId, _projTransPosting.ProjAdjustRefId).ProjTransId;
            }

            ProjTransPosting projTransPostingLoc;
            select count(RecId) from projTransPostingLoc
                where projTransPostingLoc.AmountMst == -_projTransPosting.AmountMst
                    && projTransPostingLoc.Qty == -_projTransPosting.Qty
                    && projTransPostingLoc.TransId == transID
                    && projTransPostingLoc.Voucher == _projTransPosting.Voucher
                    && projTransPostingLoc.PostingType == _projTransPosting.PostingType
                    && projTransPostingLoc.ProjType == _projTransPosting.ProjType
                    && projTransPostingLoc.ProjId == _projTransPosting.ProjId
                    && projTransPostingLoc.LedgerTransDate == _projTransPosting.LedgerTransDate
                    && projTransPostingLoc.ProjTransDate == _projTransPosting.ProjTransDate
                    && projTransPostingLoc.ProjTransType == ProjTransType::Item
                    && projTransPostingLoc.LedgerDimension == _projTransPosting.LedgerDimension
                    && projTransPostingLoc.DefaultDimension == _projTransPosting.DefaultDimension;
            
            if (projTransPostingLoc.RecId == 1)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemUpdateCost</Name>
				<Source><![CDATA[
    boolean checkItemUpdateCost(ProjTransPosting _projTransPosting)
    {
        if (_projTransPosting.ProjTransType == ProjTransType::Item
            && _projTransPosting.CostSales == ProjCostSales::Cost
            && (_projTransPosting.PostingType == LedgerPostingType::ProjCost || _projTransPosting.PostingType == LedgerPostingType::ProjNeverLedger)
            && !_projTransPosting.TransId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemUpdateTransId</Name>
				<Source><![CDATA[
    boolean checkItemUpdateTransId(ProjTransPosting _projTransPosting)
    {
        if (_projTransPosting.ProjTransType == ProjTransType::Item
            && !_projTransPosting.TransId
            && ((_projTransPosting.CostSales == ProjCostSales::Cost && _projTransPosting.PostingType == LedgerPostingType::ProjCost)
                || (_projTransPosting.CostSales == ProjCostSales::Cost && _projTransPosting.PostingType == LedgerPostingType::ProjNeverLedger)
                || (_projTransPosting.CostSales == ProjCostSales::Cost && _projTransPosting.PostingType == LedgerPostingType::ProjOffsetAccountItem)
                || (_projTransPosting.CostSales == ProjCostSales::Cost && _projTransPosting.PostingType == LedgerPostingType::ProjStatusAccountItem)
                || (_projTransPosting.CostSales == ProjCostSales::Sales && _projTransPosting.PostingType == LedgerPostingType::ProjTurnover))
           )
        {
            return true;
        }

        if (_projTransPosting.ProjTransType == ProjTransType::Item
            && _projTransPosting.InventTransId != ""
            && _projTransPosting.ProjAdjustRefId != ""
            && !ProjItemTrans::isStocked(_projTransPosting.inventTransId))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxExemptDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes the tax exemption based on allocation percentage defined.
    /// </summary>
    /// <param name="_totalTaxExemptAmount">
    /// The value of Pct. exempt tax.
    /// </param>
    /// <param name="_projCostTrans">
    /// The table <c>ProjCostTrans</c>.
    /// </param>
    public void createTaxExemptDistributions(AmountCur _totalTaxExemptAmount, ProjCostTrans _projCostTrans)
    {
        taxExemptDistributions = new Map(Types::Int64, Types::Real);
        ProjTrans projTrans = ProjTrans::newProjCostTrans(_projCostTrans);

        ProjFundingEngine projFundingEngine = ProjFundingEngine::construct(projTrans, _totalTaxExemptAmount,  0);
        if (projFundingEngine.allocate())
        {
            taxExemptDistributions = projFundingEngine.parmCostDistributions();
            fundingSourceList = projFundingEngine.parmfundingSourceAllocation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    void insert()
    {
        ProjTransPosting projTransPosting;
        ProjCostTrans projCostTrans;
        ProjCostTransCost projCostTransCost;
        MapEnumerator enumerateMap;

        projTransPosting.initFromProjLedger(projLedger);

        if (this.parmPostingType() == LedgerPostingType::ProjNeverLedger
            || this.parmPostingType() == LedgerPostingType::ProjNoLedger
            || postToGeneralLedger == false)
        {
            projTransPosting.PostingType = this.parmPostingType();
            projTransPosting.DefaultDimension = this.parmDimension();
            projTransPosting.LedgerTransDate = this.parmTransdate();
            projTransPosting.AmountMst = this.parmAmountMST();
            projTransPosting.Voucher = this.parmVoucher();
            projTransPosting.LedgerDimension = this.parmLedgerDimension();
        }
        else
        {
            projTransPosting.initFromLedgerPosting(ledgerPostingReference, ledgerPostingTransaction);
        }

        if ((projTransPosting.AmountMst < 0 && projTransPosting.Qty > 0)
            || (projTransPosting.AmountMst > 0 && projTransPosting.Qty < 0))
        {
            projTransPosting.Qty = -projTransPosting.Qty;
        }

        boolean includeTaxInCostAndSalesPrice;
        if (this.checkInsertTransPosting(projTransPosting))
        {
            //Replace scrap transId with production order's transid before ProjItemTransCost gets created
            if (this.checkItemUpdateTransId(projTransPosting) 
                && projLedger.parmInventTransType() == InventTransType::Production 
                && !InventTrans::findTransId(projTransPosting.InventTransId))
            {
                projTransPosting.InventTransId = ProdTable::find(projLedger.parmInventTransRefId()).InventTransId;
            }

            this.insertProjItemTransCost(projTransPosting);

            if (this.checkItemUpdateTransId(projTransPosting))
            {
                projTransPosting = this.initProjTransPostingTransId(projTransPosting);
            }

            if (projLedger.parmTaxUpdate())
            {
                projCostTrans = ProjCostTrans::find(projTransPosting.TransId, projTransPosting.AmountMst != 0 ? true : false);
                LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(projCostTrans.LedgerJournalTrans, false);
                AmountCur taxInAmountCur;

                if (projCostTrans)
                {
                    if (FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance()))
                    {
                        TaxGroupData taxGroupTable;
                        TaxData taxData;

                        select firstonly RecId from taxData
                            where taxData.TaxValue != 0
                                && ((taxData.TaxFromDate == dateNull() && taxData.TaxToDate == dateNull())
                                    || (taxData.TaxFromDate <= ledgerJournalTrans.TransDate && taxData.TaxToDate >= ledgerJournalTrans.TransDate))
                            exists join taxGroupTable
                                where taxGroupTable.DataAreaId == taxData.DataAreaId
                                    && taxGroupTable.TaxCode == taxData.TaxCode
                                    && taxGroupTable.TaxGroup == ledgerJournalTrans.TaxGroup;

                        if (taxData.RecId)
                        {
                            includeTaxInCostAndSalesPrice = true;
                        }                        
                    }
                    else
                    {
                        includeTaxInCostAndSalesPrice = true;
                    }

                    if (includeTaxInCostAndSalesPrice)
                    {
                        SalesPrice salesPriceWithoutTax;
                        SalesPrice salesMarkup;
                        CostPrice costPriceWithOutTax;

                        if (projCostTrans.Qty != 0)
                        {
                            costPriceWithOutTax = CurrencyExchangeHelper::price(projCostTrans.TotalCostAmountCur / projCostTrans.Qty);
                            salesPriceWithoutTax = CurrencyExchangeHelper::price(projCostTrans.TotalSalesAmountCur / projCostTrans.Qty);
                        }

                        boolean priceFound;
                        ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                            projCostTrans.ProjId,
                            projCostTrans.Resource,
                            projCostTrans.CategoryId,
                            costPriceWithOutTax,
                            CompanyInfoHelper::standardCurrency(),
                            projCostTrans.CurrencyId,
                            projCostTrans.TransDate);

                        [salesMarkup, priceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams);

                        if (projTransPosting.AmountMst)
                        {
                            taxInAmountCur = CurrencyExchangeHelper::curAmount (projTransPosting.AmountMst,
                                                                                projCostTrans.CurrencyIdCost,
                                                                                projTransPosting.LedgerTransDate,
                                                                                UnknownNoYes::Unknown,
                                                                                ledgerJournalTrans.ExchRate);

                            projCostTrans.TotalCostAmountCur += taxInAmountCur;
                            projCostTrans.update();

                            // Update tax amounts to budget.
                            if (ProjTable::find(projTransPosting.ProjId).UseBudgeting)
                            {
                                ProjBudgetTransactionLine projBudgetTransactionLine = ProjBudgetTransactionLine::construct(projCostTrans);
                                projBudgetTransactionLine.parmTransIdRef(projCostTrans.TransId);
                                projBudgetTransactionLine.parmCostAmount(taxInAmountCur);
                                projBudgetTransactionLine.parmSalesAmount(taxInAmountCur);

                                ProjBudgetTransaction projBudgetTransaction = new ProjBudgetTransaction();
                                projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);
                                ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction).adjustBudget(ProjBudgetAdjustmentType::Decrement);
                            }
                        }

                        this.createTaxExemptDistributions(taxInAmountCur, projCostTrans);
                        enumerateMap = new MapEnumerator(taxExemptDistributions);

                        while (enumerateMap.moveNext())
                        {
                            select forupdate projCostTransCost
                                where projCostTransCost.TransId == projCostTrans.TransId
                                    && projCostTransCost.FundingSource == enumerateMap.currentKey();
                            {
                                projCostTransCost.CostPriceCurrency = (projCostTransCost.CostPriceCurrency*projCostTrans.Qty) + enumerateMap.currentValue();
                                projCostTransCost.LineAmount = projCostTransCost.LineAmount + enumerateMap.currentValue();

                                projCostTransCost.CostPrice = 
                                    ExchangeRateHelper::mstPrice(
                                        projCostTransCost.CostPriceCurrency,
                                        projCostTrans.CurrencyIdCost,
                                        projTransPosting.LedgerTransDate,
                                        UnknownNoYes::Unknown,
                                        ledgerJournalTrans.ExchRate);

                                if (projCostTrans.Qty != 0)
                                {
                                    projCostTransCost.CostPrice = CurrencyExchangeHelper::price(projCostTransCost.CostPrice / projCostTrans.Qty);
                                }

                                projCostTransCost.CostAmountLedger = projCostTransCost.CostAmountLedger + CurrencyExchangeHelper::mstAmount(enumerateMap.currentValue(),
                                                                                                                                projCostTrans.CurrencyIdCost,
                                                                                                                                projTransPosting.LedgerTransDate,
                                                                                                                                UnknownNoYes::Unknown,
                                                                                                                                ledgerJournalTrans.ExchRate);

                                projCostTransCost.update();

                                if (this.mustUpdateSalesPrice(projCostTrans.TransIdRef))
                                {
                                    TaxAmount taxAmount = enumerateMap.currentValue();

                                    if (ProjInvoiceJourTaxExchangeRateFlight::instance().isEnabled() 
                                        && projCostTrans.CurrencyId != projCostTrans.CurrencyIdCost)
                                    {
                                        taxAmount = CurrencyExchangeHelper::curAmount2CurAmount(
                                            taxAmount,
                                            projCostTrans.CurrencyIdCost,
                                            projCostTrans.CurrencyId,
                                            projTransPosting.LedgerTransDate);
                                    }

                                    if (salesMarkup && salesMarkup != salesPriceWithoutTax)
                                    {
                                        ProjCostTransSale projCostTransSale;

                                        ttsbegin;
                                        select firstonly forupdate projCostTransSale
                                            where projCostTransSale.TransId == projCostTrans.TransId
                                                && projCostTransSale.FundingSource == enumerateMap.currentKey();
                                    
                                        if (projCostTrans.Qty != 0)
                                        {
                                            projCostTransSale.SalesPrice = projCostTransSale.SalesPrice + (taxAmount / projCostTrans.Qty);
                                        }
                                        
                                        projCostTransSale.LineAmount = this.calculateLineAmount(projCostTransSale, projCostTrans);
                                        projCostTransSale.update();
                                        ttscommit;
                                    }
                                    else if (projCostTrans.Qty != 0)
                                    {
                                        this.updateSalesPrice(projCostTrans, projCostTransCost, enumerateMap.currentKey(), taxAmount / projCostTrans.Qty);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            //Set payment date and payment status for Cash Flow
            this.setPaymentDateStatus(projTransPosting);

            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && projTransPosting.ProjTransType == ProjTransType::Cost)
            {
                LedgerJournalTrans ledgerJournalTrans;
                ITaxDocument taxDocument;
                ITaxableDocument taxableDocument;
                ITaxDocumentLine taxDocumentLineObject;
                AmountCur totLoiAmountCur;
                AmountMST totLoiAmoumtMst;
                ProjFundingSource projFundingSource;
                ProjFundingRule projFundingRule;
                ProjFundingRuleAllocation projFundingRuleAllocation;

                projCostTrans = ProjCostTrans::find(projTransPosting.TransId);
                if (projCostTrans.LedgerJournalTrans)
                {
                    ledgerJournalTrans = LedgerJournalTrans::findRecId(projCostTrans.LedgerJournalTrans, false);

                    taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(ledgerJournalTrans));
                    taxDocument = TaxBusinessService::calculateTax(taxableDocument);

                    if (taxDocument)
                    {
                        taxDocumentLineObject = taxDocument.findLineBySource(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);

                        if (taxDocumentLineObject)
                        {
                            totLoiAmountCur = taxDocumentLineObject.sumByTaxAccountingProvider(
                                TaxAccountingProvider::Inventory,
                                TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();

                            totLoiAmountCur -= taxDocumentLineObject.sumByTaxAccountingProvider(
                                TaxAccountingProvider::Inventory,
                                TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();

                            totLoiAmoumtMst = taxDocumentLineObject.sumByTaxAccountingProvider(
                                TaxAccountingProvider::Inventory,
                                TaxAccountingPostingProfileDistributionSide::Debit).amountAccountingCurrency();

                            totLoiAmoumtMst -= taxDocumentLineObject.sumByTaxAccountingProvider(
                                TaxAccountingProvider::Inventory,
                                TaxAccountingPostingProfileDistributionSide::Credit).amountAccountingCurrency();

                            projFundingSource = projFundingSource::find(projTransPosting.ProjFundingSource);

                            select firstOnly AllocationPercentage from projFundingRuleAllocation
                                exists join projFundingRule
                                    where projFundingRuleAllocation.FundingRule == projFundingRule.RecId
                                        && projFundingRule.ContractId == projFundingSource.ContractId
                                        && projFundingRuleAllocation.FundingSource == projFundingSource.RecId;

                            RealBase factor = projFundingRuleAllocation.AllocationPercentage ? projFundingRuleAllocation.AllocationPercentage/100 : 1;

                            projCostTrans.selectForUpdate(true);
                            projTransPosting.AmountMst += totLoiAmoumtMst * factor;
                            projCostTrans.TotalCostAmountCur += totLoiAmountCur * factor;
                            projCostTrans.update();

                            select firstonly forupdate projCostTransCost
                                where projCostTransCost.TransId == projCostTrans.TransId
                                    && (!projFundingSource.RecId || projCostTransCost.FundingSource == projFundingSource.RecId);

                            if (projCostTrans.Qty != 0)
                            {
                                projCostTransCost.CostPrice = CurrencyExchangeHelper::price(projTransPosting.AmountMst / projCostTrans.Qty);
                            }

                            projCostTransCost.CostPriceCurrency = CurrencyExchangeHelper::curAmount(projCostTransCost.CostPrice, projCostTrans.CurrencyIdCost, projTransPosting.LedgerTransDate);
                            projCostTransCost.CostAmountLedger = projCostTransCost.CostAmountLedger + totLoiAmountCur * factor;
                            projCostTransCost.LineAmount = projCostTransCost.LineAmount + totLoiAmountCur * factor;
                            projCostTransCost.update();
                        }
                    }
                }
            }
           // </GTE>
           
            if (!projLedger.parmTaxUpdate() || includeTaxInCostAndSalesPrice)
            {
                this.insertProjTransPosting(projTransPosting);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the project transaction record.
    /// </summary>
    /// <param name = "_projTransPosting">
    /// The <c>ProjTransPosting</c> buffer.
    /// </param>
    protected void insertProjTransPosting(ProjTransPosting _projTransPosting)
    {
        _projTransPosting.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProjTransPostingTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes transaction ID for <c>ProjTransPosting</c> table.
    /// </summary>
    /// <param name = "_projTransPosting">
    /// An instance of <c>ProjTransPosting</c> table buffer.
    /// </param>
    /// <returns>
    /// An instance of <c>ProjTransPosting</c> table.
    /// </returns>
    [Wrappable(true)]
    protected final ProjTransPosting initProjTransPostingTransId(ProjTransPosting _projTransPosting)
    {
        _projTransPosting.TransId = ProjItemTrans::findInvent(_projTransPosting.InventTransId, _projTransPosting.ProjAdjustRefId).ProjTransId;

        return _projTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the project expense sales transaction sales price and line amount.
    /// </summary>
    /// <param name = "_projCostTrans">
    /// A <c>ProjCostTrans</c> table buffer.
    /// </param>
    /// <param name = "_projCostTransCost">
    /// A <c>ProjCostTransCost</c> table buffer.
    /// </param>
    /// <param name = "_projFundingSourceRefId">
    /// The record Id of a funding source.
    /// </param>
    /// <param name = "_amount">
    /// The amount for the funding source.
    /// </param>
    protected void updateSalesPrice(ProjCostTrans _projCostTrans, ProjCostTransCost _projCostTransCost, ProjFundingSourceRefId _projFundingSourceRefId, AmountCur _amount)
    {
        boolean priceFound;
        SalesPrice salesPrice;
        ProjCostTransSale projCostTransSale;

        select forupdate projCostTransSale
            where projCostTransSale.TransId == _projCostTrans.TransId
                && projCostTransSale.FundingSource == _projFundingSourceRefId;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
				_projCostTrans.ProjId,
                _projCostTrans.Resource,
                _projCostTrans.CategoryId,
                _projCostTransCost.CostPrice,
                CompanyInfoHelper::standardCurrency(),
                _projCostTrans.CurrencyId,
                _projCostTrans.TransDate,
                '');
            [salesPrice, priceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams, false);
        }
        else
        {
            ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
				_projCostTrans.ProjId,
                _projCostTrans.Resource,
                _projCostTrans.CategoryId,
                _projCostTransCost.CostPrice,
                CompanyInfoHelper::standardCurrency(),
                _projCostTrans.CurrencyId,
                _projCostTrans.TransDate);
            [salesPrice, priceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams);
        }

        projCostTransSale.SalesPrice = this.calculateSalesPrice(projCostTransSale, salesPrice, priceFound, _amount);
        projCostTransSale.LineAmount = this.calculateLineAmount(projCostTransSale, _projCostTrans);
        projCostTransSale.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sales price. Tax amount will be added when sales price is different from price parameters.
    /// Otherwise no need to add tax amount to sales price here.
    /// </summary>
    /// <param name = "_projCostTransSale">
    /// A <c>ProjCostTransSale</c> table buffer.
    /// </param>
    /// <param name = "_salesPrice">
    /// The sales price that was found, if any.
    /// </param>
    /// <param name = "_priceFound">
    /// Indicates if the price was found.
    /// </param>
    /// <param name = "_amount">
    /// The amount for the funding source.
    /// </param>
    /// <returns>
    /// The sales price.
    /// </returns>
    protected SalesPrice calculateSalesPrice(ProjCostTransSale _projCostTransSale, SalesPrice _salesPrice, boolean _priceFound, AmountCur _amount)
    {
        SalesPrice salesPrice;

        if (_priceFound)
        {
            salesPrice = _salesPrice;
        }
        else
        {
            salesPrice = _projCostTransSale.SalesPrice + _amount;
        }
        
        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the line amount.
    /// </summary>
    /// <param name = "_projCostTransSale">
    /// A <c>ProjCostTransSale</c> table buffer.
    /// </param>
    /// <param name = "_projCostTrans">
    /// A <c>ProjCostTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// The line amount.
    /// </returns>
    protected Amount calculateLineAmount(ProjCostTransSale _projCostTransSale, ProjCostTrans _projCostTrans)
    {
        Amount amount = CurrencyExchangeHelper::amount(_projCostTrans.qty * _projCostTransSale.SalesPrice, _projCostTrans.currencyId);

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to update the sale price of the project cost transaction.
    /// </summary>
    /// <param name="_projCostTransId">
    /// The <c>ProjCostTransId</c> is the transaction Id of the ledger journal project transaction.
    /// </param>
    /// <returns>
    /// True if the ledger journal tarnsaction did not include the sales tax else false.
    /// </returns>
    private boolean mustUpdateSalesPrice(ProjCostTransId   _projCostTransId)
    {
        LedgerJournalTrans_Project ledgerJournalTransProject;

        select firstOnly ledgerJournalTransProject
            where ledgerJournalTransProject.TransId == _projCostTransId;

        return ledgerJournalTransProject.SalesPrice ? !(ledgerJournalTransProject.ledgerJournalTable().LedgerJournalInclTax) : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjItemTransCost</Name>
				<Source><![CDATA[
    void insertProjItemTransCost(ProjTransPosting _projTransPosting)
    {
        ProjItemTrans projItemTrans, projItemTransFirst;
        ProjItemTransCost projItemTransCost, projItemTransCostFirst;
        ProjItemTransSale projItemTransSaleFirst;
        InventTrans inventTrans;
        InventSettlement inventSettlement;
        ProjLineProperty projLineProperty;
        ProjItemTrans projItemTransAdjustRef;
        InventTransOriginId inventTransOriginId;

        //  ProjItemTransCost is created here, for every update made in the invent
        if (this.checkItemUpdateCost(_projTransPosting))
        {
            projItemTrans = ProjItemTrans::findInvent(_projTransPosting.InventTransId, _projTransPosting.ProjAdjustRefId);

            boolean itemTransCostInserted = false;

            if (FeatureStateProvider::isFeatureEnabled(ProjCancelItemReqPackingSlipFeature::instance()))
            {
                ProjItemTrans projItemTransOrig = this.getItemReqPackSlipCancellationOrigProjTrans(projItemTrans);
                if (projItemTransOrig.RecId)
                {
                    this.insertProjItemTransCostForCancellation(projItemTrans, projItemTransOrig, _projTransPosting);
                    itemTransCostInserted = true;
                }
            }

            if (!itemTransCostInserted)
            {
                inventTransOriginId = InventTransOrigin::findByInventTransId(_projTransPosting.InventTransId).RecId;

                select forceplaceholders firstonly RecId from inventTrans
                    where inventTrans.InventTransOrigin == inventTransOriginId
                        && inventTrans.ProjAdjustRefId == _projTransPosting.ProjAdjustRefId
                    exists join inventSettlement
                        where inventSettlement.TransRecId == inventTrans.RecId;

                projItemTransCost.TransStatus = ProjTransStatus::Posted;

                //  if inventTrans with an settlement is found here, this is an inventory adjustment
                if (inventTrans && InventTable::modelGroupByItemId(_projTransPosting.EmplItemId).InventModel != InventModel::StdCost)
                {
                    if (postingType == LedgerPostingType::ProjNeverLedger)
                    {
                        projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Never;
                    }
                    // The below condition is added only for purchase order scenario with negative quantity and product receipt inorder to consider ledgerstatus defined in project group.
                    else if (projItemTrans.Qty < 0 && ProjItemTrans.TransactionOrigin == ProjOrigin::PurchaseOrder && isFlightEnabled(ProjLedgerUpdateLedgerStatusCostFlight))
                    {
                        ProjTable projTableLocal = ProjTable::find(projLedger.parmProjId());
                        projItemTransCost.LedgerStatusCost = ProjRevRecHelper::getItemLedgerStatus(projTableLocal);
                    }
                    else
                    {
                        projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                    }
                    projItemTransCost.ProjInventAdjust = true;
                    ProjInvoiceJour::adjustCostAmount(_projTransPosting.InventTransId, _projTransPosting.ProjAdjustRefId, _projTransPosting.AmountMst);
                }
                else
                {
                    if (projItemTrans.AdjRefTransId)
                    {
                        projItemTransAdjustRef = ProjItemTrans::find(projItemTrans.AdjRefTransId);
                    }

                    if (projItemTransAdjustRef && (projItemTransAdjustRef.Qty == -projItemTrans.Qty))
                    {
                        projItemTransFirst = ProjItemTrans::find(projItemTrans.AdjRefTransId);
                        projItemTransCostFirst = ProjItemTransCost::find(projItemTransFirst.InventTransId, projItemTransFirst.ProjAdjustRefId, 1.0);

                        if (projItemTrans.projItemTransSaleFirst() && projItemTrans.projItemTransSaleFirst().TransStatus == ProjTransStatus::Adjusted)
                        {
                            // project regulated transactions is always set to profit & Loss (negative transaction)
                            // If LedgerStatusCostOrig = true, we need to honor original transaction's ledgerStatus.
                            projItemTransCost.TransStatus = ProjTransStatus::Adjusted;
                            if (projItemTransCostFirst && projLedger.parmLedgerStatusCostOrig())
                            {
                                projItemTransCost.LedgerStatusCost = projItemTransCostFirst.LedgerStatusCost;
                            }
						    else
                            {
                                projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                            }
                        }
                        else if (!projItemTrans.projItemTransSaleFirst())
                        {
                            if (projItemTransCostFirst)
                            {
                                if (projItemTransCostFirst.TransStatus == ProjTransStatus::Adjusted)
                                {
                                    // project regulated transactions is always set to profit & Loss (negative transaction)
                                    projItemTransCost.TransStatus = ProjTransStatus::Adjusted;
                                    projItemTransCost.LedgerStatusCost = projLedger.parmLedgerStatusCostOrig() ? projItemTransCostFirst.LedgerStatusCost : ProjLedgerStatus::Operations;
                                }
                            }
                            else
                            {
                                select firstonly TransStatus from projItemTransSaleFirst 
                                    where projItemTransSaleFirst.ProjTransId == projItemTransFirst.ProjTransId;

                                if (projItemTransSaleFirst.TransStatus == ProjTransStatus::Adjusted)
                                {
                                    // project regulated transactions is always set to profit & Loss (negative transaction)
                                    projItemTransCost.TransStatus = ProjTransStatus::Adjusted;
                                    projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                                }
                            }
                        }
                    }
                    if (projItemTransCost.LedgerStatusCost == ProjLedgerStatus::None)
                    {
                        switch (projItemTrans.TransactionOrigin)
                        {
                            case ProjOrigin::SalesOrder:
                                projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                                break;

                            case ProjOrigin::ItemRequirement:
                            case ProjOrigin::ItemJournal:
                            case ProjOrigin::PurchaseOrder:
                            case ProjOrigin::VendorInvoice:
                            case ProjOrigin::ProductionFinished:
                            case ProjOrigin::ProductionConsumed:
                                ProjTable projTableLoc = ProjTable::find(projLedger.parmProjId());
                                if (!projTableLoc.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                                {
                                    projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                                }
                                else
                                {
                                    projItemTransCost.LedgerStatusCost = ProjRevRecHelper::getItemLedgerStatus(projTableLoc);
                                }
                                break;
                        }

                        projLineProperty = ProjLineProperty::find(projItemTrans.LinePropertyId);

                        if (projItemTransCost.LedgerStatusCost == ProjLedgerStatus::BalanceSheet)
                        {
                            if (projLineProperty.ToBeCapitalize)
                            {
                                if (ProjTable::isPLPostingRequiredForTransType(_projTransPosting.ProjId, ProjTransType::Item))
                                {
                                     projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                                }
                            }
                            else
                            {
                                projItemTransCost.LedgerStatusCost = ProjLedgerStatus::Operations;
                            }
                        }

					    // LedgerStatusCostOrig is true when we want to use the original posted transaction's
					    // ledgerstatusCost needs to be used. This is only applicable for adjusted transactions.
					    if (projLedger.parmLedgerStatusCostOrig() && projItemTrans.AdjRefTransId)
                        {
                            if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                            {
							    ProjTable projTable = ProjTable::find(projLedger.parmProjId());
                                ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Item);
                            }

                            projItemTransFirst = ProjItemTrans::find(projItemTrans.AdjRefTransId);
                            projItemTransCostFirst = ProjItemTransCost::find(projItemTransFirst.InventTransId,projItemTransFirst.ProjAdjustRefId,1.0);

						    if (projItemTransCostFirst)
                            {
                                projItemTransCost.LedgerStatusCost = projItemTransCostFirst.LedgerStatusCost;
                            }
                        }
                    }
                }

                if (projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement)
                {
                    ProjItemTrans rootProjItemTrans;
                    select firstonly TransIdPackSlip from rootProjItemTrans
                        where rootProjItemTrans.AdjRefTransId == ''
                            && rootProjItemTrans.ProjTransIDRef == projItemTrans.ProjTransIDRef;

                    if (rootProjItemTrans.TransIdPackSlip != '')
                    {
                        //If transaction already has projitemTransCost in adjusted status then new transactions should also have same status if transaction is created during adjustment process
                        projItemTransCostFirst = ProjItemTransCost::find(projItemTrans.InventTransId, projItemTrans.ProjAdjustRefId, 1.0);
                        projItemTransSaleFirst = projItemTrans.projItemTransSaleFirst();

                        if (_projTransPosting.LedgerOrigin == ProjOrigin::Adjustment
                            && projItemTransCostFirst.TransStatus == ProjTransStatus::Adjusted
                            && projItemTransSaleFirst
                            && projItemTransSaleFirst.TransStatus == ProjTransStatus::Adjusted)
                        {
                            projItemTransCost.TransStatus = ProjTransStatus::Adjusted;
                        }
                    }
                }

                projItemTransCost.InventTransId = _projTransPosting.InventTransId;
                projItemTransCost.ProjAdjustRefId = _projTransPosting.ProjAdjustRefId;
                projItemTransCost.AmountMST = _projTransPosting.AmountMst;
                projItemTransCost.LineAmount = _projTransPosting.AmountMst;
                projItemTransCost.LedgerTransdate = _projTransPosting.LedgerTransDate;
                projItemTransCost.Voucher = _projTransPosting.Voucher;
                projItemTransCost.ProjId = _projTransPosting.ProjId;
                projItemTransCost.ItemType = ProjItemTrans::transactionOriginToItemType(projItemTrans.TransactionOrigin);
                projItemTransCost.CostType = this.parmProjLedger().parmProjItemTransCostType();
                projItemTransCost.FundingSource = this.parmProjLedger().parmfundingSourceID();
                projItemTransCost.DefaultDimension = projItemTrans.DefaultDimension ? projItemTrans.DefaultDimension :_projTransPosting.DefaultDimension;

                projItemTransCost.insert();

                if (projItemTrans.TransIdPackSlip
                    && projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement
                    && projItemTransSaleFirst.TransStatus == ProjTransStatus::Invoiced
                    && _projTransPosting.LedgerOrigin == ProjOrigin::ItemRequirement)
                {
                    /// Sales budget has already been processed before cost is updated for stocked items
                    ProjPost::invoicePostStockedItemReqBudgetUpdateCost(projItemTransCost);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemReqPackSlipCancellationOrigProjTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns projItemTrans record associated to the item requirement packing slip that is being cancelled
    /// </summary>
    /// <param name = "_projItemTrans">Record associated to the cancelled packing slip</param>
    /// <returns>ProjItemTrans for original packing slip posting</returns>
    private ProjItemTrans getItemReqPackSlipCancellationOrigProjTrans(ProjItemTrans _projItemTrans)
    {
        ProjItemTrans projItemTransLoc;
        ProjItemTransSale projItemTransSaleLoc;

        // Checking if TransIdPackSlip exists to confirm that packing slip was posted with feature on
        // Checking for AdjRefTransId as cancellation of packing slip is not supported for transactions 
        // on which project adjustment has been performed
        // Gets a transaction only if status of transaction is Adjusted and AdjRefTransId has no value
        // This only happens in item req packing slip cancellation case
        if (_projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement
            && _projItemTrans.TransIdPackSlip
            && !_projItemTrans.AdjRefTransId)
        {
            select firstonly projItemTransLoc
                where projItemTransLoc.TransIdPackSlip == _projItemTrans.TransIdPackSlip
                    && projItemTransLoc.InventTransId == _projItemTrans.InventTransId
                    && projItemTransLoc.ProjAdjustRefId != _projItemTrans.ProjAdjustRefId
                    && projItemTransLoc.ProjTransId != _projItemTrans.ProjTransId
                    && projItemTransLoc.Qty == -_projItemTrans.Qty
            exists join projItemTransSaleLoc 
                where projItemTransSaleLoc.TransStatus == ProjTransStatus::Adjusted
                    && projItemTransSaleLoc.ProjTransId == projItemTransLoc.ProjTransId;
        }

        return projItemTransLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjItemTransCostForCancellation</Name>
				<Source><![CDATA[
    private void insertProjItemTransCostForCancellation(ProjItemTrans _projItemTransRev, ProjItemTrans _projItemTransOrig, ProjTransPosting _projTransPosting)
    {
        ProjItemTransCost projItemTransCostLoc;
        ProjItemTransCost projItemTransCostNew;

        select firstonly projItemTransCostLoc
            where projItemTransCostLoc.FundingSource == _projTransPosting.ProjFundingSource
                && projItemTransCostLoc.InventTransId == _projItemTransOrig.InventTransId
                && projItemTransCostLoc.ProjAdjustRefId == _projItemTransOrig.ProjAdjustRefId
                && projItemTransCostLoc.AmountMST == -_projTransPosting.AmountMst;
        if (projItemTransCostLoc)
        {
            projItemTransCostNew.data(projItemTransCostLoc);
            projItemTransCostNew.AmountMST = -projItemTransCostLoc.AmountMST;
            projItemTransCostNew.LineAmount = -projItemTransCostLoc.LineAmount;
            projItemTransCostNew.LedgerCostAmountMST = -projItemTransCostLoc.LedgerCostAmountMST;
            projItemTransCostNew.Voucher = _projTransPosting.Voucher;
            projItemTransCostNew.ProjAdjustRefId = _projItemTransRev.ProjAdjustRefId;
            projItemTransCostNew.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        postToGeneralLedger = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountMST</Name>
				<Source><![CDATA[
    AmountMST parmAmountMST(AmountMST _amountMST = amountMST)
    {
        amountMST = _amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimension</Name>
				<Source><![CDATA[
    DimensionDefault parmDimension(DimensionDefault _dimension = dimension)
    {
        dimension = _dimension;

        return dimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount parmLedgerDimension(LedgerDimensionAccount _accountNum = ledgerDimension)
    {
        ledgerDimension = _accountNum;

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingType</Name>
				<Source><![CDATA[
    LedgerPostingType parmPostingType(LedgerPostingType _postingType = postingType)
    {
        postingType = _postingType;

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostToGeneralLedger</Name>
				<Source><![CDATA[
    protected boolean parmPostToGeneralLedger(boolean _postToGeneralLedger = postToGeneralLedger)
    {
        postToGeneralLedger = _postToGeneralLedger;

        return postToGeneralLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjLedger</Name>
				<Source><![CDATA[
    ProjLedger parmProjLedger(ProjLedger _projLedger = projLedger)
    {
        projLedger = _projLedger;

        return projLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransdate</Name>
				<Source><![CDATA[
    TransDate parmTransdate(TransDate _transDate = transDate)
    {
        transDate = _transDate;

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerPosting</Name>
				<Source><![CDATA[
    private void setLedgerPosting(LedgerVoucherObject _ledgerPostingReference, LedgerVoucherTransObject _ledgerPostingTransaction)
    {
        ledgerPostingReference = _ledgerPostingReference;
        ledgerPostingTransaction = _ledgerPostingTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentDateExpected</Name>
				<Source><![CDATA[
    //PaymentDate = Due date of Cust Trans + Individual buffer date + General Buffer days
    void setPaymentDateExpected(ProjTransPosting  _projTransPosting)
    {
        PaymTermId paymentTermId;
        ProjProposalJour projProposalJour;
        Num individualBuffer;
        ProjForecastBufferDays generalBuffer;
        ProjFundingSource projFundingSource;

        //get general buffer days
        generalBuffer = ProjParameters::find().ForecastBufferDays;

        select firstonly FundingSource, InvoiceDate from projProposalJour 
            where projProposalJour.LedgerVoucher == _projTransPosting.Voucher;

        if (projProposalJour.FundingSource)
        {
            projFundingSource = ProjFundingSource::find(projProposalJour.FundingSource);
            // Get the individual buffer
            individualBuffer = projFundingSource.IndividualBuffer;
            // Get payment terms from project contract
            paymentTermId = projFundingSource.PaymentTermsId;
        }

        _projTransPosting.PaymentDate = PaymTerm::advanceDate(paymentTermId, projProposalJour.InvoiceDate) + any2int(individualBuffer) + any2int(generalBuffer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentDatePaid</Name>
				<Source><![CDATA[
    //PaymentDate = Project Date + Terms of Payment for the trans type in Proj Parameters
    void setPaymentDatePaid(ProjTransPosting  _projTransPosting)
    {
        PaymTermId paymentTermId;
        ProjParameters projParameters;

        if (_projTransPosting.ProjTransType == ProjTransType::Revenue)
        {
            _projTransPosting.PaymentDate = _projTransPosting.ProjTransDate;
        }
        else
        {
            select ForecastPaymHour, ForecastPaymExpenses, ForecastPaymItem from projParameters;

            switch (_projTransPosting.ProjTransType)
            {
                case ProjTransType::Hour:
                    paymentTermId = projParameters.ForecastPaymHour;
                    break;

                case ProjTransType::Cost:
                    paymentTermId = projParameters.ForecastPaymExpenses;
                    break;

                case ProjTransType::Item:
                    paymentTermId = projParameters.ForecastPaymItem;
                    break;
            }

            _projTransPosting.PaymentDate = PaymTerm::advanceDate(paymentTermId, _projTransPosting.ProjTransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentDatePurchase</Name>
				<Source><![CDATA[
    void setPaymentDatePurchase(ProjTransPosting  _projTransPosting)
    {
        VendTrans vendTrans;

        if (_projTransPosting.PostingType != LedgerPostingType::ProjNeverLedger)
        {
            select firstonly DueDate from vendTrans
                where vendTrans.Voucher == _projTransPosting.Voucher
                    && vendTrans.TransType == LedgerTransType::Purch;

            _projTransPosting.PaymentDate = vendTrans.DueDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentDateStatus</Name>
				<Source><![CDATA[
    // COST posting type
    // if To=Lo and Lo = Purchase Order and posting type = Never ledger or Cost, set Payment Status = Expected.
    // else To=Lo or Lo=Adjustment or Inventory Closing and posting type = No ledger, Never ledger, Cost, WIP cost value, set Payment Status = Paid.
    //
    // SALES posting type
    // if Lo=Invoice and posting type = Invoiced revenue, Invoiced revenue-On account, WIP Invoiced on account, set Payment Status = Expected.
    //
    void setPaymentDateStatus(ProjTransPosting  projTransPosting)
    {
        //set to default
        projTransPosting.PaymentStatus = ProjPaymentStatus::NoPayment;
        projTransPosting.PaymentDate = dateNull();

        if (projTransPosting.CostSales == ProjCostSales::Cost)
        {
            if (projTransPosting.TransactionOrigin == projTransPosting.LedgerOrigin)
            {
                if (projTransPosting.LedgerOrigin == ProjOrigin::PurchaseOrder
                    || projTransPosting.LedgerOrigin == ProjOrigin::VendorInvoice
                    || projTransPosting.LedgerOrigin == ProjOrigin::InvoiceJournal)
                {
                    if (projTransPosting.PostingType == LedgerPostingType::ProjCost
                        || projTransPosting.PostingType == LedgerPostingType::ProjNeverLedger                        
                        || projTransPosting.PostingType == LedgerPostingType::ProjWIPCostvalue)
                    {
                        projTransPosting.PaymentStatus = ProjPaymentStatus::ExpectedPayment;
                        this.setPaymentDatePurchase(projTransPosting);
                    }
                }
                else
                {
                    if (projTransPosting.PostingType == LedgerPostingType::ProjNoLedger
                        || projTransPosting.PostingType == LedgerPostingType::ProjNeverLedger
                        || projTransPosting.PostingType == LedgerPostingType::ProjCost
                        || projTransPosting.PostingType == LedgerPostingType::ProjWIPCostvalue)

                    {
                        projTransPosting.PaymentStatus = ProjPaymentStatus::Paid;
                        this.setPaymentDatePaid(projTransPosting);
                    }
                }
            }
            else
                if ((projTransPosting.LedgerOrigin == ProjOrigin::Adjustment || projTransPosting.LedgerOrigin == ProjOrigin::InventoryClosing) 
                    && (projTransPosting.PostingType == LedgerPostingType::ProjNoLedger
                        || projTransPosting.PostingType == LedgerPostingType::ProjNeverLedger
                        || projTransPosting.PostingType == LedgerPostingType::ProjCost
                        || projTransPosting.PostingType == LedgerPostingType::ProjWIPCostvalue))

                {
                    projTransPosting.PaymentStatus = ProjPaymentStatus::Paid;
                    this.setPaymentDatePaid(projTransPosting);
                }
        }
        else if (projTransPosting.CostSales == ProjCostSales::Sales)
        {
            if (projTransPosting.LedgerOrigin == ProjOrigin::Invoice
                && (projTransPosting.PostingType == LedgerPostingType::ProjTurnover
                    || projTransPosting.PostingType == LedgerPostingType::ProjOnAccount
                    || projTransPosting.PostingType == LedgerPostingType::ProjWIPInvoicedOnAccount
                    || (isConfigurationkeyEnabled(configurationKeyNum(Project)) ? projTransPosting.PostingType == LedgerPostingType::PSAProjRetain : false)))
            {
                projTransPosting.PaymentStatus = ProjPaymentStatus::ExpectedPayment;
                this.setPaymentDateExpected(projTransPosting);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerPosting</Name>
				<Source><![CDATA[
    public static ProjLedgerUpdate newLedgerPosting(
        LedgerVoucherObject _ledgerPostingReference,
        LedgerVoucherTransObject _ledgerPostingTransaction,
        Object _projLedger)
    {
        ProjLedgerUpdate projLedgerUpdate;

        if (_ledgerPostingReference == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_ledgerPostingTransaction == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        projLedgerUpdate = new ProjLedgerUpdate();
        projLedgerUpdate.setLedgerPosting(_ledgerPostingReference, _ledgerPostingTransaction);
        projLedgerUpdate.parmProjLedger(_projLedger);

        return projLedgerUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newNeverLedger</Name>
				<Source><![CDATA[
    public static ProjLedgerUpdate newNeverLedger(
        Object _projLedger,
        LedgerPostingType _postingType,
        DimensionDefault _dimension,
        Voucher _voucher,
        TransDate _transDate,
        AmountMST _amountMST)
    {
        ProjLedgerUpdate projLedgerUpdate = new ProjLedgerUpdate();

        projLedgerUpdate.parmProjLedger(_projLedger);
        projLedgerUpdate.parmPostingType(_postingType);
        projLedgerUpdate.parmDimension(_dimension);
        projLedgerUpdate.parmVoucher(_voucher);
        projLedgerUpdate.parmTransdate(_transDate);
        projLedgerUpdate.parmAmountMST(_amountMST);

        return projLedgerUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newNoGeneralLedger</Name>
				<Source><![CDATA[
    public static ProjLedgerUpdate newNoGeneralLedger(
        Object _projLedger,
        LedgerPostingType _postingType,
        DimensionDefault _dimension,
        Voucher _voucher,
        TransDate _transDate,
        AmountMST _amountMST,
        LedgerDimensionAccount _ledgerDimension = 0)
    {
        ProjLedgerUpdate projLedgerUpdate = new ProjLedgerUpdate();

        projLedgerUpdate.parmProjLedger(_projLedger);
        projLedgerUpdate.parmPostingType(_postingType);
        projLedgerUpdate.parmDimension(_dimension);
        projLedgerUpdate.parmVoucher(_voucher);
        projLedgerUpdate.parmTransdate(_transDate);
        projLedgerUpdate.parmAmountMST(_amountMST);
        projLedgerUpdate.parmPostToGeneralLedger(false);
        projLedgerUpdate.parmLedgerDimension(_ledgerDimension);

        return projLedgerUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newNoneLedger</Name>
				<Source><![CDATA[
    public static ProjLedgerUpdate newNoneLedger(
        Object _projLedger,
        LedgerPostingType _postingType,
        DimensionDefault _dimension,
        Voucher _voucher,
        TransDate _transDate,
        AmountMST _amountMST)
    {
        ProjLedgerUpdate projLedgerUpdate = new ProjLedgerUpdate();

        projLedgerUpdate.parmProjLedger(_projLedger);
        projLedgerUpdate.parmPostingType(_postingType);
        projLedgerUpdate.parmDimension(_dimension);
        projLedgerUpdate.parmVoucher(_voucher);
        projLedgerUpdate.parmTransdate(_transDate);
        projLedgerUpdate.parmAmountMST(_amountMST);

        return projLedgerUpdate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>