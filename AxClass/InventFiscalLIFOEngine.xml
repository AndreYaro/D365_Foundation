<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventFiscalLIFOEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
class InventFiscalLIFOEngine extends RunBaseBatch implements BatchRetryable
{
    InventFiscalLIFOJournalTable    journalTable;
    InventParameters                inventParameters;

    InventFiscalLIFOJournalId       lastYearFinalJournalId;
    boolean                         lastYearFinalJournalIdCheckExist;
    ItemGroup                       updateType;
    JournalNumOfLines               numOfLines;

    Map                             totalGroupInflowQtyMap;
    Map                             totalGroupInflowQtyWIPMap;
    Map                             totalGroupInflowValueMap;
    Map                             totalGroupInflowValueWIPMap;
    Map                             totalGroupOutflowQtyMap;

    Map                             totalGroupInflowQtySubPeriodMap;
    Map                             totalGroupInflowValueSubPeriodMap;

    Map                             includeWIPinGroupMap;

    QueryRun                        itemQueryRun;

    InventFiscalLIFOJournalId       journalId;

    #define.CurrentVersion(6)
    #localmacro.CurrentList
        journalId
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcNormalValue</Name>
				<Source><![CDATA[
    protected InventFiscalLIFONormalValue calcNormalValue(ItemId                     _itemId,
                                                          InventFiscalLIFOGroupId    _groupId,
                                                          InventFiscalLIFOUnitValue  _unitValue,
                                                          InventTable                _inventTable,
                                                          InventFiscalLIFOGroup      _inventFiscalLIFOGroup = null)
    {
        InventFiscalLIFOGroup           inventFiscalLIFOGroup;
        InventFiscalLIFOJournalTrans    journalTransPeriod;
        InventFiscalLIFOStartDate       startDatePeriod;
        InventFiscalLIFOEndDate         endDatePeriod;
        InventFiscalLIFONormalValue     normalValue;

        if (updateType == ItemGroup::Item)
        {
            inventFiscalLIFOGroup = InventFiscalLIFOGroup::findByGroupId(_groupId);
        }
        else
        {
            inventFiscalLIFOGroup = _inventFiscalLIFOGroup;
        }

        if ( updateType                       == ItemGroup::Item)
        {
            InventFiscalLIFONormalValueCalc normalValueCalc = inventFiscalLIFOGroup.Individual ? _inventTable.FiscalLIFONormalValueCalc : inventFiscalLIFOGroup.ValueCalc;
            switch (normalValueCalc)
            {
                case InventFiscalLIFONormalValueCalc::Manual:
                    normalValue = inventFiscalLIFOGroup.Individual ? _inventTable.FiscalLIFONormalValue : inventFiscalLIFOGroup.NormalValue;
                    break;

                case InventFiscalLIFONormalValueCalc::Automatic:
                    if (_unitValue == 0)
                    {
                         normalValue = inventFiscalLIFOGroup.Individual ? _inventTable.FiscalLIFONormalValue : inventFiscalLIFOGroup.NormalValue;
                    }
                    else
                    {
                        endDatePeriod   = journalTable.EndDate;
                        startDatePeriod = this.calcStartDatePeriod(inventParameters.FiscalLIFOCalcPeriod,endDatePeriod);
                        journalTransPeriod.ItemId = _itemId;
                        [journalTransPeriod.QtyReceipt,journalTransPeriod.UnitValue,journalTransPeriod.wipIncluded] = this.calcTotalInflow(_itemId,_groupId,true,startDatePeriod);

                        if ((100 * abs(_unitValue - journalTransPeriod.UnitValue)/_unitValue) > inventParameters.FiscalLIFODeviationPercent)
                        {
                            normalValue = journalTransPeriod.UnitValue;
                        }
                        else
                        {
                            normalValue = _unitValue;
                        }
                    }
                    break;
            }
        }
        else
        if ( inventFiscalLIFOGroup.Individual == NoYes::No &&
             updateType                       == ItemGroup::GroupId)
        {
            switch (inventFiscalLIFOGroup.ValueCalc)
            {
                case InventFiscalLIFONormalValueCalc::Manual:
                    normalValue = inventFiscalLIFOGroup.NormalValue;
                    break;

                case InventFiscalLIFONormalValueCalc::Automatic:
                    if (_unitValue == 0)
                    {
                         normalValue = inventFiscalLIFOGroup.NormalValue;
                    }
                    else
                    {
                        endDatePeriod   = journalTable.EndDate;
                        startDatePeriod = this.calcStartDatePeriod(inventParameters.FiscalLIFOCalcPeriod,endDatePeriod);
                        journalTransPeriod.InventFiscalLIFOGroup = inventFiscalLIFOGroup.RecId;
                        [journalTransPeriod.QtyReceipt,journalTransPeriod.UnitValue,journalTransPeriod.wipIncluded] = this.calcTotalInflow(_itemId,_groupId,true,startDatePeriod);

                        if ((100 * abs(_unitValue - journalTransPeriod.UnitValue)/_unitValue) > inventParameters.FiscalLIFODeviationPercent)
                        {
                            normalValue = journalTransPeriod.UnitValue;
                        }
                        else
                        {
                            normalValue = _unitValue;
                        }
                    }
                    break;
            }
        }
        return normalValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcStartDatePeriod</Name>
				<Source><![CDATA[
    InventFiscalLIFOStartDate calcStartDatePeriod(InventFiscalLIFOCalcPeriod _calcPeriod,
                                                  TransDate                  _date)
    {
        int         day     = dayofmth(_date);
        int         month   = mthofyr( _date);
        int         yr      = year(    _date);

        switch (_calcPeriod)
        {
            case InventFiscalLIFOCalcPeriod::Month:
                month = month - 1;
                break;

            case InventFiscalLIFOCalcPeriod::Quarter:
                month = month - 3;
                break;

            case InventFiscalLIFOCalcPeriod::HalfYear:
                month = month - 6;
                break;
        }

        if (month < 1)
        {
            month = month + 12;
            yr    = yr - 1;
        }

        StartDate startDate = mkdate(day,month,yr);
        return max(startDate,journalTable.StartDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalInflow</Name>
				<Source><![CDATA[
    protected container calcTotalInflow(ItemId                     _itemId,
                                        InventFiscalLIFOGroupId    _groupId,
                                        boolean                    _calcSubPeriod = false,
                                        InventFiscalLIFOStartDate  _startDate = journalTable.StartDate,
                                        InventFiscalLIFOEndDate    _endDate   = journalTable.EndDate)
    {
        InventTransOrigin           inventTransOrigin;
        InventTransOriginProdBOM    inventTransOriginProdBOM;
        InventTransOriginProdTable  inventTransOriginProdTable;
        InventTrans                 inventTrans;
        InventTrans                 inventTransBOM;
        InventTrans                 inventTransWIP;
        InventQty                   totalInflowQty;
        InventQty                   totalInflowQtyWIP;
        AmountMST                   totalInflowValue;
        AmountMST                   totalInflowValueWIP;
        ProdTable                   prodTable;
        ProdCalcTrans               prodCalcTrans;
        ProdBOM                     prodBOM;
        InventFiscalLIFOWIPIncluded wipIncluded;
        boolean                     isInventTransNotPostedFinancialFound = false;

        if (updateType == ItemGroup::Item)
        {
            // Financial transactions - STARt
            select TableId from inventTransOrigin
                where  inventTransOrigin.ItemId == _itemId
                    && (inventTransOrigin.ReferenceCategory == InventTransType::Sales
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Statement
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::ProdLine
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Project
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Purch
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Production
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventTransaction
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventLossProfit
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::QuarantineOrder
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderScrap
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::BOMMain
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::BOMLine
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventCounting
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::PmfProdCoBy
                    )
                join sum(Qty),sum(CostAmountPosted),sum(CostAmountAdjustment) from inventTrans
                    where  inventTrans.InventTransOrigin   == inventTransOrigin.RecId
                        &&  inventTrans.DatePhysical       >= _startDate
                        &&  inventTrans.DatePhysical       <= _endDate
                        &&  inventTrans.StatusIssue        == StatusIssue::None
                        &&  inventTrans.StatusReceipt      == StatusReceipt::Purchased;

            if (_calcSubPeriod)
            {
                if (totalGroupInflowQtySubPeriodMap.exists(_groupId))
                    totalGroupInflowQtySubPeriodMap.insert(_groupId,inventTrans.Qty + totalGroupInflowQtySubPeriodMap.lookup(_groupId));
                else
                    totalGroupInflowQtySubPeriodMap.insert(_groupId,inventTrans.Qty);

                if (totalGroupInflowValueSubPeriodMap.exists(_groupId))
                    totalGroupInflowValueSubPeriodMap.insert(_groupId,inventTrans.CostAmountPosted + inventTrans.CostAmountAdjustment + totalGroupInflowValueSubPeriodMap.lookup(_groupId));
                else
                    totalGroupInflowValueSubPeriodMap.insert(_groupId,inventTrans.CostAmountPosted + inventTrans.CostAmountAdjustment);
            }
            else
            {
                if (totalGroupInflowQtyMap.exists(_groupId))
                    totalGroupInflowQtyMap.insert(_groupId,inventTrans.Qty + totalGroupInflowQtyMap.lookup(_groupId));
                else
                    totalGroupInflowQtyMap.insert(_groupId,inventTrans.Qty);

                if (totalGroupInflowValueMap.exists(_groupId))
                    totalGroupInflowValueMap.insert(_groupId,inventTrans.CostAmountPosted + inventTrans.CostAmountAdjustment + totalGroupInflowValueMap.lookup(_groupId));
                else
                    totalGroupInflowValueMap.insert(_groupId,inventTrans.CostAmountPosted + inventTrans.CostAmountAdjustment);
            }

            totalInflowQty   = inventTrans.Qty;
            totalInflowValue = inventTrans.CostAmountPosted + inventTrans.CostAmountAdjustment;
            // Financial transactions - ENd

            // Physical transactions - STARt
            select TableId from inventTransOrigin
                where  inventTransOrigin.ItemId == _itemId
                    && (inventTransOrigin.ReferenceCategory == InventTransType::Sales
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Statement
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::ProdLine
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Project
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Purch
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Production
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventTransaction
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventLossProfit
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::QuarantineOrder
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderScrap
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::BOMMain
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::BOMLine
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventCounting
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::PmfProdCoBy
                    )

                join count(RecId), sum(Qty),sum(CostAmountPhysical) from inventTrans
                    where  inventTrans.InventTransOrigin   == inventTransOrigin.RecId
                        &&  inventTrans.DatePhysical        >= _startDate
                        &&  inventTrans.DatePhysical        <= _endDate
                        &&  inventTrans.StatusIssue         == StatusIssue::None
                        &&  inventTrans.StatusReceipt       == StatusReceipt::Received;

            if (_calcSubPeriod)
            {
                if (totalGroupInflowQtySubPeriodMap.exists(_groupId))
                {
                    totalGroupInflowQtySubPeriodMap.insert(_groupId,inventTrans.Qty + totalGroupInflowQtySubPeriodMap.lookup(_groupId));
                }
                else
                {
                    totalGroupInflowQtySubPeriodMap.insert(_groupId,inventTrans.Qty);
                }

                if (totalGroupInflowValueSubPeriodMap.exists(_groupId))
                {
                    totalGroupInflowValueSubPeriodMap.insert(_groupId,inventTrans.CostAmountPhysical + totalGroupInflowValueSubPeriodMap.lookup(_groupId));
                }
                else
                {
                    totalGroupInflowValueSubPeriodMap.insert(_groupId,inventTrans.CostAmountPhysical);
                }
            }
            else
            {
                if (totalGroupInflowQtyMap.exists(_groupId))
                {
                    totalGroupInflowQtyMap.insert(_groupId,inventTrans.Qty + totalGroupInflowQtyMap.lookup(_groupId));
                }
                else
                {
                    totalGroupInflowQtyMap.insert(_groupId,inventTrans.Qty);
                }

                if (totalGroupInflowValueMap.exists(_groupId))
                {
                    totalGroupInflowValueMap.insert(_groupId,inventTrans.CostAmountPhysical + totalGroupInflowValueMap.lookup(_groupId));
                }
                else
                {
                    totalGroupInflowValueMap.insert(_groupId,inventTrans.CostAmountPhysical);
                }
            }

            totalInflowQty   += inventTrans.Qty;
            totalInflowValue += inventTrans.CostAmountPhysical;

            if (inventTrans.RecId > 0)
            {
                isInventTransNotPostedFinancialFound = true;
            }
            // Physical transactions - ENd

            // When including production orders, we must exclude sub productions, otherwise the value will be doubbled.
            select sum(Qty),sum(CostAmountPhysical),sum(CostAmountAdjustment) from inventTransBOM
                where  inventTransBOM.ItemId        == _itemId
                   &&  inventTransBOM.DatePhysical  >= _startDate
                   &&  inventTransBOM.DatePhysical  <= _endDate
                   &&  inventTransBOM.StatusReceipt == StatusReceipt::Received
                exists join inventTransOriginProdBOM
                    where inventTransOriginProdBOM.InventTransOrigin == inventTransBOM.InventTransOrigin
                    exists join prodBOM
                        where prodBOM.InventTransId == inventTransOriginProdBOM.ProdBOMInventTransId
                           && prodBOM.DataAreaId    == inventTransOriginProdBOM.ProdBOMDataAreaId
                           && prodBOM.ProdLineType  != BOMType::Item;

            if (_calcSubPeriod)
            {
                if (totalGroupInflowValueSubPeriodMap.exists(_groupId))
                    totalGroupInflowValueSubPeriodMap.insert(_groupId,totalGroupInflowValueSubPeriodMap.lookup(_groupId) - inventTransBOM.CostAmountPhysical - inventTransBOM.CostAmountAdjustment);
                else
                    totalGroupInflowValueSubPeriodMap.insert(_groupId,-inventTransBOM.CostAmountPhysical - inventTransBOM.CostAmountAdjustment);
            }
            else
            {
                if (totalGroupInflowValueMap.exists(_groupId))
                    totalGroupInflowValueMap.insert(_groupId,totalGroupInflowValueMap.lookup(_groupId) - inventTransBOM.CostAmountPhysical - inventTransBOM.CostAmountAdjustment);
                else
                    totalGroupInflowValueMap.insert(_groupId,-inventTransBOM.CostAmountPhysical - inventTransBOM.CostAmountAdjustment);
            }

            totalInflowValue -= (inventTransBOM.CostAmountPhysical + inventTransBOM.CostAmountAdjustment);
        }
        else
        {
            if (_calcSubPeriod)
            {
                if (totalGroupInflowQtySubPeriodMap.exists(_groupId))
                {
                    totalInflowQty   += totalGroupInflowQtySubPeriodMap.lookup(_groupId);
                }

                if (totalGroupInflowValueSubPeriodMap.exists(_groupId))
                {
                    totalInflowValue += totalGroupInflowValueSubPeriodMap.lookup(_groupId);
                }
            }
            else
            {
                if (totalGroupInflowQtyMap.exists(_groupId))
                {
                    totalInflowQty   += totalGroupInflowQtyMap.lookup(_groupId);
                }

                if (totalGroupInflowValueMap.exists(_groupId))
                {
                    totalInflowValue += totalGroupInflowValueMap.lookup(_groupId);
                }

                if (includeWIPinGroupMap.exists(_groupId))
                {
                    wipIncluded = includeWIPinGroupMap.lookup(_groupId);
                }
            }
        }

        if (journalTable.IncludeWIP && _calcSubPeriod == false)
        {
            if (updateType == ItemGroup::Item)
            {
                while select prodTable
                    group by InventTransId,ProdId,SchedStart,SchedEnd
                    where prodTable.ItemId == _itemId
                      && (prodTable.ProdStatus  == ProdStatus::StartedUp
                      ||  prodTable.ProdStatus  == ProdStatus::ReportedFinished)
                    join sum(RealCostAmount),sum(RealCostAdjustment) from prodCalcTrans
                        group by IdRefTableId,IdRefRecId
                        where prodCalcTrans.IdRefTableId    == prodTable.TableId
                           && prodCalcTrans.IdRefRecId      == prodTable.RecId
                           && prodCalcTrans.CollectRefLevel == 0
                {
                    if (prodTable.SchedEnd    >  (prodTable.SchedStart + inventParameters.FiscalLIFOWIPPeriod))
                    {
                        wipIncluded = NoYes::Yes;
                        includeWIPinGroupMap.insert(_groupId,wipIncluded);

                        select TableId from inventTransOriginProdTable
                            where inventTransOriginProdTable.ProdOrderId         == prodTable.ProdId
                               && inventTransOriginProdTable.ProdOrderDataAreaId == prodTable.DataAreaId
                            join sum(Qty) from inventTrans
                                where inventTrans.InventTransOrigin == inventTransOriginProdTable.InventTransOrigin
                                   && inventTrans.StatusIssue      == StatusIssue::None
                                   && inventTrans.StatusReceipt    == StatusReceipt::Received;

                        // When including WIP we make a lookup to return the total value of WIP as it is posted in Production.
                        // When doing this, we need to calculate the physical value of the received quantity and deduct this, otherwise the posted value will be incorrect.
                        select TableId from inventTransOriginProdTable
                            where inventTransOriginProdTable.ProdOrderId         == prodTable.ProdId
                               && inventTransOriginProdTable.ProdOrderDataAreaId == prodTable.DataAreaId
                            join sum(CostAmountPhysical) from inventTransWIP
                                where inventTransWIP.InventTransOrigin == inventTransOriginProdTable.InventTransOrigin
                                   && inventTransWIP.DateFinancial == dateNull();

                        totalInflowValueWIP += prodCalcTrans.RealCostAmount - inventTransWIP.CostAmountPhysical + prodCalcTrans.RealCostAdjustment;
                        totalInflowQtyWIP   += inventTrans.Qty;
                    }
                }
                if (totalGroupInflowValueWIPMap.exists(_groupId))
                    totalGroupInflowValueWIPMap.insert(_groupId,totalInflowValueWIP + totalGroupInflowValueWIPMap.lookup(_groupId));
                else
                    totalGroupInflowValueWIPMap.insert(_groupId,totalInflowValueWIP);

                if (totalGroupInflowQtyWIPMap.exists(_groupId))
                    totalGroupInflowQtyWIPMap.insert(_groupId,totalInflowQtyWIP + totalGroupInflowQtyWIPMap.lookup(_groupId));
                else
                    totalGroupInflowQtyWIPMap.insert(_groupId,totalInflowQtyWIP);
            }
            else
            {
                if (totalGroupInflowValueWIPMap.exists(_groupId))
                {
                    totalInflowValueWIP = totalGroupInflowValueWIPMap.lookup(_groupId);
                }

                if (totalGroupInflowQtyWIPMap.exists(_groupId))
                {
                    totalInflowQtyWIP = totalGroupInflowQtyWIPMap.lookup(_groupId);
                }
            }
        }

        return [totalInflowQty,(totalInflowQty ? totalInflowValue/totalInflowQty : 0) + (totalInflowQtyWIP ? totalInflowValueWIP/totalInflowQtyWIP : 0),wipIncluded, isInventTransNotPostedFinancialFound];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalOutflow</Name>
				<Source><![CDATA[
    protected AmountMST calcTotalOutflow(ItemId                       _itemId,
                                         InventFiscalLIFOGroupId      _groupId)
    {
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;
        InventQty           totalOutflowQty;

        if (updateType == ItemGroup::Item)
        {
            select TableId from inventTransOrigin
                where  inventTransOrigin.ItemId            == _itemId
                    && (inventTransOrigin.ReferenceCategory == InventTransType::Sales
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Statement
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::ProdLine
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Project
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Purch
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::Production
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventTransaction
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventLossProfit
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::QuarantineOrder
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderScrap
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::BOMMain
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::BOMLine
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::InventCounting
                    // <PMF>
                    ||  inventTransOrigin.ReferenceCategory == InventTransType::PmfProdCoBy
                    // </PMF>
                    )
                join sum(Qty) from inventTrans
                    where  inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    &&  inventTrans.DatePhysical         >= journalTable.StartDate
                    &&  inventTrans.DatePhysical         <= journalTable.EndDate
                    &&  inventTrans.StatusReceipt        == StatusReceipt::None
                    &&  (inventTrans.StatusIssue         == StatusIssue::Sold
                    || inventTrans.StatusIssue           == StatusIssue::Deducted);

            totalOutflowQty = inventTrans.Qty;
            if (totalGroupOutflowQtyMap.exists(_groupId))
                totalGroupOutflowQtyMap.insert(_groupId,inventTrans.Qty + totalGroupOutflowQtyMap.lookup(_groupId));
            else
                totalGroupOutflowQtyMap.insert(_groupId,inventTrans.Qty);
        }
        else
        {
            if (totalGroupOutflowQtyMap.exists(_groupId))
            {
                totalOutflowQty = totalGroupOutflowQtyMap.lookup(_groupId);
            }
        }

        return -totalOutflowQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class twice with the
    ///    same parameters is not always possible. If the <c>canGoBatch</c> class returns false, this method
    ///    will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFiscalLIFOGroupIdInInventTable</Name>
				<Source><![CDATA[
    boolean checkFiscalLIFOGroupIdInInventTable()
    {
        InventTable     inventTable;

        select count(RecId) from inventTable
            where inventTable.FiscalLIFOAvoidCalc   == NoYes::No &&
                  inventTable.InventFiscalLIFOGroup == 0         &&
                  inventTable.ItemType              != ItemType::Service;

        if (inventTable.RecId != 0)
            return checkFailed(strfmt("@SYS98349","@SYS92979",inventTable.RecId));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog(DialogRunbase   _dialog          = null,
                            boolean         _forceOnClient   = false)
    {
        DialogRunbase                   dialog = this.dialogInternal(_dialog, _forceOnClient);

        InventFiscalLIFOJournalTable journalTableLocal = InventFiscalLIFOJournalTable::findByJournalId(journalId);
        dialog.addFieldValue(extendedtypestr(InventFiscalLIFOStartDate),      journalTableLocal.StartDate).enabled(false);
        dialog.addFieldValue(extendedtypestr(InventFiscalLIFOEndDate),        journalTableLocal.EndDate).enabled(false);
        dialog.addFieldValue(extendedtypestr(InventFiscalLIFOIncludeWIP),     journalTableLocal.IncludeWIP).enabled(false);
        dialog.addFieldValue(extendedtypestr(InventFiscalLIFOUseNormalValue), journalTableLocal.UseNormalValue).enabled(false);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyPrimo</Name>
				<Source><![CDATA[
    InventFiscalLIFOQtyPrimo getQtyPrimo(InventFiscalLIFOJournalTrans _journalTrans)
    {
        InventFiscalLIFOJournalTable    journalTableLocal;
        InventFiscalLIFOJournalTrans    journalTransLocal;
        InventFiscalLIFORemainQty       lastYearFinalRemainQty;
        FiscalCalendarRecId             calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        TransDate transDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(calendarRecId,
                                                                                journalTable.StartDate) - 1;

        if (!lastYearFinalJournalId && !lastYearFinalJournalIdCheckExist)
        {
            select firstonly JournalId from journalTableLocal
                where journalTableLocal.FinalReportClosed == NoYes::Yes
                   && journalTableLocal.JournalType       == InventFiscalLIFOJournalType::FinalReport
                   && journalTableLocal.StartDate         <= transDate
                   && journalTableLocal.EndDate           >= transDate;

            lastYearFinalJournalId           = journalTableLocal.JournalId;
            lastYearFinalJournalIdCheckExist = true;
        }

        if (lastYearFinalJournalId)
        {
            if (updateType == ItemGroup::Item)
            {
                select firstonly QtyPrimo, QtyIssue, QtyReceipt from journalTransLocal
                    where journalTransLocal.JournalId == lastYearFinalJournalId
                       && journalTransLocal.ItemGroup == ItemGroup::Item
                       && journalTransLocal.ItemId    == _journalTrans.ItemId;

                lastYearFinalRemainQty = journalTransLocal.QtyPrimo + journalTransLocal.QtyReceipt - journalTransLocal.QtyIssue;
            }
            else
            {
                select firstonly QtyPrimo, QtyIssue, QtyReceipt from journalTransLocal
                    where journalTransLocal.JournalId             == lastYearFinalJournalId
                       && journalTransLocal.ItemGroup             == ItemGroup::GroupId
                       && journalTransLocal.InventFiscalLIFOGroup == _journalTrans.InventFiscalLIFOGroup;

                lastYearFinalRemainQty = journalTransLocal.QtyPrimo + journalTransLocal.QtyReceipt - journalTransLocal.QtyIssue;
            }
        }
        return lastYearFinalRemainQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public boolean init()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        if (!itemQueryRun)
        {
            itemQueryRun = new QueryRun(this.initQuery());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    Query initQuery()
    {
        Query query = new Query();

        QueryBuildDataSource qbdsInventTable = query.addDataSource(tablenum(InventTable));
        qbdsInventTable.addRange(fieldnum(InventTable,ItemId));
        qbdsInventTable.addRange(fieldnum(InventTable,InventFiscalLIFOGroup));

        QueryBuildRange qbr = qbdsInventTable.addRange(fieldnum(InventTable,FiscalLIFOAvoidCalc));
        qbr.value(queryValue(NoYes::No));
        qbr.status(RangeStatus::Locked);

        qbr = qbdsInventTable.addRange(fieldnum(InventTable,ItemType));
        qbr.value(SysQuery::valueNot(ItemType::Service));
        qbr.status(RangeStatus::Locked);

        QueryBuildDataSource qbdsInventItemGroupItem = qbdsInventTable.addDataSource(tablenum(InventItemGroupItem));
        qbdsInventItemGroupItem.joinMode(JoinMode::OuterJoin);
        qbdsInventItemGroupItem.fetchMode(QueryFetchMode::One2One);
        qbdsInventItemGroupItem.relations(true);
        qbdsInventItemGroupItem.addRange(fieldnum(InventItemGroupItem, ItemGroupId));

        // Filter out non-inventoried items.
        InventInventoriedPolicy::addInventoriedRangeToInventTable(qbdsInventTable);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        #ISOCountryRegionCodes
        super();
        GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes([
            [#isoIT, GlobalizationConstants::FeatureReferenceIT00011] ],
            funcName()
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,#CurrentList,itemQueryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalId</Name>
				<Source><![CDATA[
    public InventFiscalLIFOJournalId parmJournalId(InventFiscalLIFOJournalId _journalId = journalId)
    {
        journalId = _journalId;
        return journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return itemQueryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        InventFiscalLIFOJournalTrans    journalTrans;

        boolean                         isInventTransNotPostedFinancialFound = false;
        boolean                         isInventTransNotPostedFinancialForItemFound = false;

        LineNum                         lineNum;

        #OCCRetryCount

        this.validate();

        inventParameters            = InventParameters::find();
        Map fiscalLIFOGroupIdMap    = new Map(Types::String,Types::String);
        totalGroupInflowQtyMap      = new Map(Types::String,Types::Real);
        totalGroupInflowQtyWIPMap   = new Map(Types::String,Types::Real);
        totalGroupInflowValueMap    = new Map(Types::String,Types::Real);
        totalGroupInflowValueWIPMap = new Map(Types::String,Types::Real);
        totalGroupOutflowQtyMap     = new Map(Types::String,Types::Real);

        totalGroupInflowQtySubPeriodMap      = new Map(Types::String,Types::Real);
        totalGroupInflowValueSubPeriodMap    = new Map(Types::String,Types::Real);

        includeWIPinGroupMap                 = new Map(Types::String,Types::Enum);

        try
        {
            ttsbegin;
            journalTable = InventFiscalLIFOJournalTable::findByJournalId(journalId,true);
            Yr fiscalYear = year(journalTable.EndDate);

            delete_from journalTrans
                where journalTrans.JournalId == journalTable.JournalId;

            updateType = ItemGroup::Item;

            if (!itemQueryRun)
                itemQueryRun = new QueryRun(this.initQuery());

            while (itemQueryRun.next())
            {
                InventTable inventTable = itemQueryRun.get(tablenum(InventTable)) as InventTable;

                lineNum++;

                journalTrans.clear();
                journalTrans.initValue();
                journalTrans.LineNum     = lineNum;
                journalTrans.initFromInventFiscalLIFOJournalTable(journalTable);
                journalTrans.initFromInventTable(inventTable);
                journalTrans.ItemGroup   = ItemGroup::Item;
                journalTrans.Yr          = fiscalYear;
                [journalTrans.QtyReceipt,journalTrans.UnitValue,journalTrans.wipIncluded, isInventTransNotPostedFinancialForItemFound] = this.calcTotalInflow(journalTrans.ItemId,
                                                                                                              InventFiscalLIFOGroup::find(journalTrans.InventFiscalLIFOGroup).GroupId);
                isInventTransNotPostedFinancialFound = isInventTransNotPostedFinancialFound || isInventTransNotPostedFinancialForItemFound;
                journalTrans.QtyIssue    = this.calcTotalOutflow(journalTrans.ItemId,InventFiscalLIFOGroup::find(journalTrans.InventFiscalLIFOGroup).GroupId);
                if (journalTable.UseNormalValue)
                {
                    journalTrans.NormalValue = this.calcNormalValue(journalTrans.ItemId,InventFiscalLIFOGroup::find(journalTrans.InventFiscalLIFOGroup).GroupId,journalTrans.UnitValue,inventTable);
                }
                journalTrans.QtyPrimo    = this.getQtyPrimo(journalTrans);
                journalTrans.RemainQty   = (journalTrans.QtyReceipt > journalTrans.QtyIssue) ? journalTrans.QtyReceipt - journalTrans.QtyIssue : 0;

                journalTrans.insert();
                numOfLines++;

                fiscalLIFOGroupIdMap.insert(InventFiscalLIFOGroup::find(journalTrans.InventFiscalLIFOGroup).GroupId,'');
            }

            lineNum = 0;
            updateType = ItemGroup::GroupId;
            MapEnumerator enumerator = fiscalLIFOGroupIdMap.getEnumerator();
            while (enumerator.moveNext())
            {
                InventFiscalLIFOGroup inventFiscalLIFOGroup = InventFiscalLIFOGroup::findByGroupId(enumerator.currentKey());

                lineNum++;

                journalTrans.clear();
                journalTrans.initValue();
                journalTrans.LineNum   = lineNum;
                journalTrans.initFromInventFiscalLIFOJournalTable(journalTable);
                journalTrans.initFromInventFiscalLIFOGroup(inventFiscalLIFOGroup);
                journalTrans.ItemGroup = ItemGroup::GroupId;
                journalTrans.Yr        = fiscalYear;

                if (!inventFiscalLIFOGroup.Individual)
                {
                    [journalTrans.QtyReceipt,journalTrans.UnitValue,journalTrans.wipIncluded] = this.calcTotalInflow('',inventFiscalLIFOGroup.GroupId);
                    journalTrans.QtyIssue    = this.calcTotalOutflow(journalTrans.ItemId,InventFiscalLIFOGroup::find(journalTrans.InventFiscalLIFOGroup).GroupId);
                    if (journalTable.UseNormalValue)
                    {
                        journalTrans.NormalValue = this.calcNormalValue(journalTrans.ItemId,InventFiscalLIFOGroup::find(journalTrans.InventFiscalLIFOGroup).GroupId,journalTrans.UnitValue,null,inventFiscalLIFOGroup);
                    }
                    journalTrans.QtyPrimo    = this.getQtyPrimo(journalTrans);
                    journalTrans.RemainQty   = (journalTrans.QtyReceipt > journalTrans.QtyIssue) ? journalTrans.QtyReceipt - journalTrans.QtyIssue : 0;
                }

                journalTrans.insert();
                numOfLines++;
            }

            if (numOfLines)
            {
                journalTable.NumOfLines = numOfLines;
                journalTable.update();
            }

            journalTable.adjustRemainQty();
            ttscommit;

            if (isInventTransNotPostedFinancialFound)
            {
                warning("@InventoryIT:VerifyInventoryTransactionsCanBeenInvoiced");
            }
        }
        catch (Exception::Deadlock)
        {
            itemQueryRun.reset();
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    itemQueryRun.reset();
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instructs the batch framework that this class can run impersonating the user who requested the task.
    /// </summary>
    /// <returns>
    ///    true always.
    /// </returns>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a Select button to the dialog.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> .If you change the return value to false the button will no longer
    ///    be added.
    /// </remarks>
    boolean showQueryValues()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version     version = RunBase::getVersion(packedClass);
        container   packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList,packedQuery] = packedClass;
                if (packedQuery)
                {
                    itemQueryRun = new QueryRun(packedQuery);
                }
                break;
            case 5:
                [version,#CurrentList,packedQuery] = packedClass;
                if (packedQuery)
                {
                    itemQueryRun = new QueryRun(packedQuery);
                    InventInventoriedPolicy::addInventoriedRangeToInventTable(itemQueryRun.query().dataSourceTable(tablenum(InventTable)));
                }
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        boolean     ok = true;

        ok = this.checkFiscalLIFOGroupIdInInventTable();

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventFiscalLIFOEngine construct(InventFiscalLIFOJournalType _journalType)
    {
        switch (_journalType)
        {
            case InventFiscalLIFOJournalType::InternalReport : return new InventFiscalLIFOEngine_Internal();
            case InventFiscalLIFOJournalType::FinalReport    : return new InventFiscalLIFOEngine_Final();
        }

        throw error(strfmt("@SYS19306",funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    // Here goes a description of the class
    static ClassDescription description()
    {
        return "@SYS93961";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        InventFiscalLIFOEngine          fiscalLIFOEngine;
        InventFiscalLIFOJournalTable    inventFiscalLIFOJournalTable;

        if (! args)
            throw error("@SYS25407");

        Common record = args.record();
        if (record)
        {
            switch (record.TableId)
            {
                case tablenum(InventFiscalLIFOJournalTable):
                    inventFiscalLIFOJournalTable = record as InventFiscalLIFOJournalTable;
                    break;

                case tablenum(InventFiscalLIFOJournalTrans):
                    InventFiscalLIFOJournalTrans inventFiscalLIFOJournalTrans = record as InventFiscalLIFOJournalTrans;
                    inventFiscalLIFOJournalTable = inventFiscalLIFOJournalTrans.inventFiscalLIFOJournalTable();
                    break;
            }

            fiscalLIFOEngine = InventFiscalLIFOEngine::construct(inventFiscalLIFOJournalTable.JournalType);
            fiscalLIFOEngine.getLast();
            if (fiscalLIFOEngine)
            {
                fiscalLIFOEngine.parmJournalId(inventFiscalLIFOJournalTable.JournalId);
            }
            else
            {
                throw error("@SYS25407");
            }
        }
        if (fiscalLIFOEngine.prompt())
            fiscalLIFOEngine.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>